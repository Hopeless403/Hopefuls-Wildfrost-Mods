// Decompiled with JetBrains decompiler
// Type: AbilityTargetSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class AbilityTargetSystem : GameSystem
{
  public Transform targetGroup;
  public GameObject targetPrefab;
  public Dictionary<CardContainer, GameObject> currentTargets;

  public void OnEnable()
  {
    global::Events.OnAbilityTargetAdd += new UnityAction<CardContainer>(this.AddTarget);
    global::Events.OnAbilityTargetRemove += new UnityAction<CardContainer>(this.RemoveTarget);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
  }

  public void OnDisable()
  {
    global::Events.OnAbilityTargetAdd -= new UnityAction<CardContainer>(this.AddTarget);
    global::Events.OnAbilityTargetRemove -= new UnityAction<CardContainer>(this.RemoveTarget);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    this.Clear();
  }

  public void AddTarget(CardContainer container)
  {
    GameObject gameObject = UnityEngine.Object.Instantiate<GameObject>(this.targetPrefab, this.targetGroup);
    gameObject.transform.position = container.transform.position;
    if (this.currentTargets == null)
      this.currentTargets = new Dictionary<CardContainer, GameObject>();
    this.currentTargets[container] = gameObject;
  }

  public void RemoveTarget(CardContainer container)
  {
    if (this.currentTargets == null || !this.currentTargets.ContainsKey(container))
      return;
    this.currentTargets[container].Destroy();
    this.currentTargets.Remove(container);
  }

  public void SceneChanged(Scene scene) => this.Clear();

  public void Clear()
  {
    if (this.currentTargets == null)
      return;
    foreach (KeyValuePair<CardContainer, GameObject> keyValuePair in this.currentTargets.Where<KeyValuePair<CardContainer, GameObject>>((Func<KeyValuePair<CardContainer, GameObject>, bool>) (pair => (UnityEngine.Object) pair.Value != (UnityEngine.Object) null)))
      keyValuePair.Value.Destroy();
    this.currentTargets = (Dictionary<CardContainer, GameObject>) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AchievementsSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Steamworks.Data;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class AchievementsSystem : MonoBehaviour
{
  public static readonly Dictionary<string, string> ChallengeAchievement = new Dictionary<string, string>()
  {
    {
      "Challenge Charm 1",
      "ACHIEVEMENT_0"
    },
    {
      "Challenge Charm 2",
      "ACHIEVEMENT_1"
    },
    {
      "Challenge Charm 3",
      "ACHIEVEMENT_2"
    },
    {
      "Challenge Charm 4",
      "ACHIEVEMENT_3"
    },
    {
      "Challenge Charm 5",
      "ACHIEVEMENT_4"
    },
    {
      "Challenge Charm 6",
      "ACHIEVEMENT_5"
    },
    {
      "Challenge Charm 7",
      "ACHIEVEMENT_6"
    },
    {
      "Challenge Charm 8",
      "ACHIEVEMENT_7"
    },
    {
      "Challenge Charm 9",
      "ACHIEVEMENT_8"
    },
    {
      "Challenge Charm 10",
      "ACHIEVEMENT_9"
    },
    {
      "Challenge Charm 11",
      "ACHIEVEMENT_10"
    },
    {
      "Challenge Charm 12",
      "ACHIEVEMENT_11"
    },
    {
      "Challenge Charm 13",
      "ACHIEVEMENT_12"
    },
    {
      "Challenge Charm 14",
      "ACHIEVEMENT_13"
    },
    {
      "Challenge Charm 15",
      "ACHIEVEMENT_14"
    },
    {
      "Challenge Charm 16",
      "ACHIEVEMENT_15"
    }
  };

  public void OnEnable() => global::Events.OnChallengeCompletedSaved += new UnityAction<ChallengeData>(AchievementsSystem.ChallengeCompleted);

  public void OnDisable() => global::Events.OnChallengeCompletedSaved -= new UnityAction<ChallengeData>(AchievementsSystem.ChallengeCompleted);

  public static void ChallengeCompleted(ChallengeData challengeData)
  {
    if (!SteamManager.init)
      return;
    AchievementsSystem.Check(challengeData.name);
  }

  public static void Check(string challengeName)
  {
    string achievementId;
    if (!AchievementsSystem.ChallengeAchievement.TryGetValue(challengeName, out achievementId))
      return;
    AchievementsSystem.Achieve(achievementId);
  }

  public static void Achieve(string achievementId)
  {
    Debug.Log((object) ("Steam Achievement [" + achievementId + "] Unlocked!"));
    new Achievement(achievementId).Trigger();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionApplyStatus
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;

public class ActionApplyStatus : PlayAction
{
  public Entity target;
  public Entity applier;
  public StatusEffectData status;
  public int stacks;

  public ActionApplyStatus(Entity target, Entity applier, StatusEffectData status, int stacks)
  {
    this.target = target;
    this.applier = applier;
    this.status = status;
    this.stacks = stacks;
  }

  public override IEnumerator Run()
  {
    yield return (object) StatusEffectSystem.Apply(this.target, this.applier, this.status, this.stacks);
    yield return (object) Sequences.Wait(0.6f);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionChangePhase
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ActionChangePhase : PlayAction
{
  public readonly Entity entity;
  public readonly CardData newPhase;
  public readonly CardData[] newPhases;
  public readonly CardAnimation animation;
  public List<Entity> newCards;
  public bool loadingNewCards;

  public ActionChangePhase(Entity entity, CardData newPhase, CardAnimation animation)
  {
    this.entity = entity;
    this.newPhase = newPhase;
    this.animation = animation;
  }

  public ActionChangePhase(Entity entity, CardData[] newPhases, CardAnimation animation)
  {
    this.entity = entity;
    this.newPhases = newPhases;
    this.animation = animation;
  }

  public override IEnumerator Run()
  {
    if (this.entity.IsAliveAndExists())
    {
      Events.InvokeEntityChangePhase(this.entity);
      CardData[] newPhases = this.newPhases;
      bool multipleNewPhases = newPhases != null && newPhases.Length > 0;
      if (multipleNewPhases)
      {
        Routine routine = new Routine(this.CreateNewCards());
      }
      PauseMenu.Block();
      DeckpackBlocker.Block();
      if (Deckpack.IsOpen && References.Player.entity.display is CharacterDisplay display)
        display.CloseInventory();
      ChangePhaseAnimationSystem animationSystem = Object.FindObjectOfType<ChangePhaseAnimationSystem>();
      if ((bool) (Object) animationSystem)
        yield return (object) animationSystem.Focus(this.entity);
      if ((bool) (Object) this.animation)
        yield return (object) this.animation.Routine((object) this.entity);
      foreach (PlayAction action in ActionQueue.GetActions())
      {
        switch (action)
        {
          case ActionTrigger actionTrigger:
            if ((Object) actionTrigger.entity == (Object) this.entity)
            {
              ActionQueue.Remove(action);
              break;
            }
            break;
          case ActionEffectApply actionEffectApply:
            actionEffectApply.TryRemoveEntity(this.entity);
            break;
        }
      }
      if (multipleNewPhases)
      {
        ActionSequence action = new ActionSequence(this.Split(this.entity, (IEnumerable<CardData>) this.newPhases));
        action.note = "Split boss";
        action.priority = 10;
        ActionQueue.Stack((PlayAction) action, true);
      }
      else
      {
        ActionSequence action = new ActionSequence(ActionChangePhase.Change(this.entity, this.newPhase));
        action.note = "Change boss phase";
        action.priority = 10;
        ActionQueue.Stack((PlayAction) action, true);
      }
      if ((bool) (Object) animationSystem)
      {
        ActionSequence action = new ActionSequence(animationSystem.UnFocus());
        action.note = "Unfocus boss";
        action.priority = 10;
        ActionQueue.Stack((PlayAction) action, true);
      }
    }
  }

  public static IEnumerator Change(Entity entity, CardData newData)
  {
    entity.alive = false;
    yield return (object) entity.ClearStatuses();
    entity.data = newData;
    yield return (object) entity.display.UpdateData(true);
    entity.alive = true;
    yield return (object) StatusEffectSystem.EntityEnableEvent(entity);
  }

  public IEnumerator Split(Entity entity, IEnumerable<CardData> split)
  {
    entity.alive = false;
    while (this.loadingNewCards)
      yield return (object) null;
    int num = 0;
    int count = entity.actualContainers.Count;
    Dictionary<CardContainer, List<Entity>> toMove = new Dictionary<CardContainer, List<Entity>>();
    foreach (Entity newCard in this.newCards)
    {
      int index = num % count;
      CardContainer actualContainer = entity.actualContainers[index];
      if (toMove.ContainsKey(actualContainer))
      {
        CardContainer container = entity.containers[index];
        if (toMove.ContainsKey(container))
          toMove[container].Add(newCard);
        else
          toMove[container] = new List<Entity>() { newCard };
      }
      else
        toMove[actualContainer] = new List<Entity>()
        {
          newCard
        };
      ++num;
    }
    Vector3 position = entity.transform.position;
    entity.RemoveFromContainers();
    CardManager.ReturnToPool(entity);
    foreach (KeyValuePair<CardContainer, List<Entity>> keyValuePair in toMove)
    {
      CardContainer cardContainer1;
      List<Entity> entityList1;
      keyValuePair.Deconstruct(ref cardContainer1, ref entityList1);
      CardContainer cardContainer2 = cardContainer1;
      List<Entity> entityList2 = entityList1;
      if (entityList2 != null)
      {
        foreach (Entity entity1 in entityList2)
        {
          cardContainer2.Add(entity1);
          Transform transform = entity1.transform;
          transform.localScale = entity1.GetContainerScale();
          Vector3 containerWorldPosition = entity1.GetContainerWorldPosition();
          transform.position = Vector3.Lerp(position, containerWorldPosition, 0.1f);
          LeanTween.move(entity1.gameObject, containerWorldPosition, PettyRandom.Range(0.8f, 1.2f)).setEaseOutElastic();
          entity1.wobbler.WobbleRandom();
        }
      }
    }
    ChangePhaseAnimationSystem objectOfType1 = Object.FindObjectOfType<ChangePhaseAnimationSystem>();
    MinibossIntroSystem objectOfType2 = Object.FindObjectOfType<MinibossIntroSystem>();
    foreach (Entity newCard in this.newCards)
    {
      if ((bool) (Object) objectOfType1)
      {
        objectOfType1.RemoveTarget(entity);
        objectOfType1.Assign(newCard);
      }
      if ((bool) (Object) objectOfType2)
        objectOfType2.Ignore(newCard);
    }
    ActionSequence action = new ActionSequence(ActionChangePhase.FinalSplit(toMove));
    action.note = "Final boss split";
    action.priority = 10;
    ActionQueue.Stack((PlayAction) action, true);
  }

  public static IEnumerator FinalSplit(Dictionary<CardContainer, List<Entity>> toMove)
  {
    foreach (KeyValuePair<CardContainer, List<Entity>> keyValuePair in toMove)
    {
      foreach (Entity entity in keyValuePair.Value)
      {
        entity.enabled = true;
        entity.RemoveFromContainers();
        entity.owner.reserveContainer.Add(entity);
        ActionMove action1 = new ActionMove(entity, new CardContainer[1]
        {
          keyValuePair.Key
        });
        action1.priority = 10;
        ActionQueue.Stack((PlayAction) action1, true);
        ActionRunEnableEvent action2 = new ActionRunEnableEvent(entity);
        action2.priority = 10;
        ActionQueue.Stack((PlayAction) action2, true);
      }
    }
    yield return (object) null;
  }

  public static IEnumerator EnableBehaviour(Behaviour system)
  {
    system.enabled = true;
    yield return (object) null;
  }

  public IEnumerator CreateNewCards()
  {
    this.loadingNewCards = true;
    this.newCards = new List<Entity>();
    CardController controller = this.entity.display.hover.controller;
    Character owner = this.entity.owner;
    Routine.Clump clump = new Routine.Clump();
    foreach (CardData newPhase in this.newPhases)
    {
      Card card = CardManager.Get(newPhase, controller, owner, true, owner.team == References.Player.team);
      this.newCards.Add(card.entity);
      clump.Add(card.UpdateData(false));
    }
    yield return (object) clump.WaitForEnd();
    this.loadingNewCards = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionCombine
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class ActionCombine : PlayAction
{
  public readonly Entity[] entities;
  public readonly Entity finalEntity;

  public ActionCombine(Entity[] entities)
  {
    this.entities = entities;
    this.finalEntity = ((IEnumerable<Entity>) entities).Last<Entity>();
  }

  public override IEnumerator Run()
  {
    if ((bool) (Object) CombineSystem.instance)
      yield return (object) CombineSystem.instance.Combine(this.entities, this.finalEntity);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionDiscardEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class ActionDiscardEffect : PlayAction
{
  public readonly Entity target;
  public readonly int healAmount;

  public ActionDiscardEffect(Entity target, int healAmount)
  {
    this.target = target;
    this.healAmount = healAmount;
  }

  public override IEnumerator Run()
  {
    Routine.Clump clump = new Routine.Clump();
    if (this.target.data.hasHealth)
    {
      this.target.hp.current = Mathf.Min(this.target.hp.current + this.healAmount, this.target.hp.max);
      this.target.PromptUpdate();
      CurveAnimator curveAnimator = this.target.curveAnimator;
      if (curveAnimator != null)
      {
        double num = (double) curveAnimator.Ping();
      }
      clump.Add(Sequences.Wait(0.6f));
      SfxSystem.OneShot("event:/sfx/status/heal");
    }
    clump.Add(this.RemoveStatuses());
    yield return (object) clump.WaitForEnd();
  }

  public IEnumerator RemoveStatuses()
  {
    for (int i = this.target.statusEffects.Count - 1; i >= 0; --i)
    {
      StatusEffectData statusEffect = this.target.statusEffects[i];
      if ((bool) (Object) statusEffect && statusEffect.removeOnDiscard)
        yield return (object) statusEffect.Remove();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionDraw
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class ActionDraw : PlayAction
{
  public readonly Character character;
  public int count;
  public float pauseBetween;

  public ActionDraw(Character character, int count = 1, float pauseBetween = 0.1f)
  {
    this.character = character;
    this.count = count;
    this.pauseBetween = pauseBetween;
  }

  public override IEnumerator Run()
  {
    if (this.count > 0 && (bool) (Object) this.character.drawContainer && (bool) (Object) this.character.handContainer && (bool) (Object) this.character.discardContainer)
    {
      Events.InvokeCardDraw(this.count);
      for (; this.count > 0; --this.count)
      {
        yield return (object) Sequences.Wait(this.pauseBetween);
        Entity top = this.character.drawContainer.GetTop();
        if (!(bool) (Object) top)
        {
          Events.InvokeCardDrawEnd();
          yield return (object) Sequences.ShuffleTo(this.character.discardContainer, this.character.drawContainer);
          top = this.character.drawContainer.GetTop();
          Events.InvokeCardDraw(this.count);
        }
        if ((bool) (Object) top)
        {
          yield return (object) Sequences.CardMove(top, new CardContainer[1]
          {
            this.character.handContainer
          });
          this.character.handContainer.TweenChildPositions();
        }
      }
      Events.InvokeCardDrawEnd();
      ActionQueue.Stack((PlayAction) new ActionRevealAll(new CardContainer[1]
      {
        this.character.handContainer
      }));
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionDrawHand
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class ActionDrawHand : PlayAction
{
  public readonly Character character;
  public readonly float pauseBetween;

  public ActionDrawHand(Character character, float pauseBetween = 0.1f)
  {
    this.character = character;
    this.pauseBetween = pauseBetween;
  }

  public override bool IsRoutine => false;

  public override void Process() => ActionQueue.Stack((PlayAction) new ActionDraw(this.character, this.character.handContainer.max - this.character.handContainer.Count, this.pauseBetween));
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionEarlyDeploy
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class ActionEarlyDeploy : PlayAction
{
  public readonly Transform transform;
  public readonly IEnumerator earlyDeployRoutine;

  public ActionEarlyDeploy(Transform transform, IEnumerator earlyDeployRoutine)
  {
    this.transform = transform;
    this.earlyDeployRoutine = earlyDeployRoutine;
  }

  public override IEnumerator Run()
  {
    SfxSystem.OneShot("event:/sfx/inventory/wave_counter_ring");
    this.transform.localEulerAngles = new Vector3(0.0f, 0.0f, 20f);
    LeanTween.cancel(this.transform.gameObject);
    LeanTween.rotateLocal(this.transform.gameObject, Vector3.zero, 1.5f).setEaseOutElastic();
    yield return (object) this.earlyDeployRoutine;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionEffectApply
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ActionEffectApply : PlayAction
{
  public readonly StatusEffectApplyX effect;
  public readonly List<Entity> targets = new List<Entity>();
  public readonly List<int> amounts = new List<int>();
  public readonly List<ActionEffectApply.Sequence> sequences = new List<ActionEffectApply.Sequence>();
  public bool running;

  public ActionEffectApply(StatusEffectApplyX effect, List<Entity> targets, int amount)
  {
    this.effect = effect;
    this.sequences.Add(new ActionEffectApply.Sequence(targets, amount));
  }

  public void Stack(List<Entity> newTargets, int amount)
  {
    bool flag = false;
    foreach (ActionEffectApply.Sequence sequence in this.sequences)
    {
      if (sequence.targets.Count == newTargets.Count && sequence.targets.ContainsAll<Entity>((IEnumerable<Entity>) newTargets))
      {
        sequence.amount += amount;
        Debug.Log((object) string.Format("Stacking [{0}] {1} → {2}", (object) this.effect.name, (object) (sequence.amount - amount), (object) sequence.amount));
        flag = true;
        break;
      }
      if (!sequence.targets.ContainsAny<Entity>((IEnumerable<Entity>) newTargets))
      {
        sequence.targets.AddRange((IEnumerable<Entity>) newTargets);
        Debug.Log((object) ("Stacking [" + this.effect.name + "] adding " + string.Join<Entity>(", ", (IEnumerable<Entity>) newTargets)));
        flag = true;
        break;
      }
    }
    if (flag)
      return;
    this.sequences.Add(new ActionEffectApply.Sequence(newTargets, amount));
    Debug.Log((object) ("Stacking [" + this.effect.name + "] ↓\n" + string.Join<ActionEffectApply.Sequence>("\n", (IEnumerable<ActionEffectApply.Sequence>) this.sequences)));
  }

  public override IEnumerator Run()
  {
    this.running = true;
    foreach (ActionEffectApply.Sequence sequence in this.sequences)
      yield return (object) this.effect.Sequence(sequence.targets, sequence.amount);
  }

  public void TryRemoveEntity(Entity entity)
  {
    foreach (ActionEffectApply.Sequence sequence in this.sequences)
    {
      if (sequence.targets.Contains(entity))
        sequence.targets.Remove(entity);
    }
  }

  public class Sequence
  {
    public readonly List<Entity> targets;
    public int amount;

    public Sequence(List<Entity> targets, int amount)
    {
      this.targets = targets;
      this.amount = amount;
    }

    public override string ToString() => string.Format("Sequence: [{0}] → {1}", (object) string.Join<Entity>(", ", (IEnumerable<Entity>) this.targets), (object) this.amount);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionEndTurn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class ActionEndTurn : PlayAction
{
  public readonly Character character;

  public ActionEndTurn(Character character) => this.character = character;

  public override bool IsRoutine => false;

  public override void Process() => this.character.endTurn = true;
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionFlee
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System.Collections;
using UnityEngine;

public class ActionFlee : PlayAction
{
  public readonly Entity entity;

  public ActionFlee(Entity entity) => this.entity = entity;

  public override IEnumerator Run()
  {
    if (this.entity.IsAliveAndExists())
    {
      Debug.Log((object) ("[" + this.entity.name + "] Fleeing!"));
      yield return (object) Sequences.CardMove(this.entity, new CardContainer[1]
      {
        this.entity.owner.reserveContainer
      }, tweenAll: false);
      CardContainer actualContainer = this.entity.actualContainers[0];
      Vector3 localPosition = this.entity.transform.localPosition;
      Entity entity = this.entity;
      LeanTween.moveLocalX(this.entity.gameObject, actualContainer.GetChildPosition(entity).x, 0.8f).setEase(LeanTweenType.linear);
      LeanTween.moveLocalY(this.entity.gameObject, localPosition.y + 0.5f, 0.2f).setEase(Curves.Get("Jump")).setLoopPingPong(4);
      Events.InvokeEntityFlee(this.entity);
      yield return (object) new WaitForSeconds(PettyRandom.Range(0.15f, 0.25f));
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionInspect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class ActionInspect : PlayAction
{
  public Entity entity;
  public InspectSystem inspectSystem;

  public override bool IsRoutine => false;

  public ActionInspect(Entity entity, InspectSystem inspectSystem)
  {
    this.entity = entity;
    this.inspectSystem = inspectSystem;
  }

  public override void Process() => this.inspectSystem.Inspect(this.entity);
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionKill
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;

public class ActionKill : PlayAction
{
  public Entity entity;

  public ActionKill(Entity entity) => this.entity = entity;

  public override IEnumerator Run()
  {
    if (this.entity.IsAliveAndExists())
    {
      yield return (object) Sequences.WaitForAnimationEnd(this.entity);
      yield return (object) this.entity.Kill();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionMove
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;

public class ActionMove : PlayAction
{
  public readonly Entity entity;
  public CardContainer[] toContainers;
  public int insertPos = -1;
  public bool tweenAll = true;

  public ActionMove(Entity entity, params CardContainer[] toContainers)
  {
    this.entity = entity;
    this.toContainers = toContainers;
  }

  public ActionMove(Entity entity, CardContainer[] toContainers, int insertPos)
  {
    this.entity = entity;
    this.toContainers = toContainers;
    this.insertPos = insertPos;
  }

  public override IEnumerator Run()
  {
    if (this.entity.IsAliveAndExists() && this.toContainers != null)
      yield return (object) Sequences.CardMove(this.entity, this.toContainers, this.insertPos, this.tweenAll);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionProcessTrigger
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class ActionProcessTrigger : PlayAction
{
  public Trigger trigger;
  public readonly Func<Trigger> GetTriggerMethod;

  public ActionProcessTrigger(Trigger trigger) => this.trigger = trigger;

  public ActionProcessTrigger(Func<Trigger> GetTriggerMethod) => this.GetTriggerMethod = GetTriggerMethod;

  public override IEnumerator Run()
  {
    if (this.trigger == null && this.GetTriggerMethod != null)
      this.trigger = this.GetTriggerMethod();
    Events.InvokeEntityPreTrigger(ref this.trigger);
    yield return (object) StatusEffectSystem.PreTriggerEvent(this.trigger);
    if (!this.trigger.entity.data.hasAttack && this.trigger.entity.attackEffects.Count <= 0)
      this.trigger.targets = (Entity[]) null;
    if (this.trigger.entity.data.hasAttack)
    {
      Entity[] targets = this.trigger.targets;
      if ((targets == null || targets.Length <= 0) && NoTargetTextSystem.Exists())
        yield return (object) NoTargetTextSystem.Run(this.trigger.entity, NoTargetType.NoTargetToAttack);
    }
    if (this.trigger.targets != null)
      this.trigger.targets = ((IEnumerable<Entity>) this.trigger.targets).Where<Entity>((Func<Entity, bool>) (t => t.IsAliveAndExists())).ToArray<Entity>();
    this.trigger.entity.triggeredBy = this.trigger.triggeredBy;
    Events.InvokeEntityTrigger(ref this.trigger);
    if (!this.trigger.nullified && !this.trigger.entity.IsSnowed)
    {
      Entity[] targets = this.trigger.targets;
      if (targets != null && targets.Length > 0)
      {
        yield return (object) this.trigger.Process();
        yield return (object) Sequences.Wait(0.167f);
      }
      else
        yield return (object) this.trigger.Process();
    }
    Events.InvokeEntityTriggered(ref this.trigger);
    this.trigger.entity.triggeredBy = (Entity) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionQueue
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ActionQueue : MonoBehaviourSingleton<ActionQueue>
{
  public readonly List<PlayAction> queue = new List<PlayAction>();
  [SerializeField]
  public int count;
  [SerializeField]
  public float delayBefore;
  [SerializeField]
  public float delayAfter;
  public static PlayAction current;
  public static readonly global::Routine.Clump parallelClump = new global::Routine.Clump();

  public static bool Empty => MonoBehaviourSingleton<ActionQueue>.instance.count <= 0;

  public static PlayAction Insert(int index, PlayAction action, bool fixedPosition = false)
  {
    if (fixedPosition)
      action.fixedPosition = true;
    int index1 = index;
    while (index1 < MonoBehaviourSingleton<ActionQueue>.instance.count && MonoBehaviourSingleton<ActionQueue>.instance.queue[index1].fixedPosition)
      ++index1;
    MonoBehaviourSingleton<ActionQueue>.instance.queue.Insert(index1, action);
    ++MonoBehaviourSingleton<ActionQueue>.instance.count;
    Events.InvokeActionQueued(action);
    return action;
  }

  public static PlayAction Add(PlayAction action, bool fixedPosition = false) => ActionQueue.Insert(MonoBehaviourSingleton<ActionQueue>.instance.count, action, fixedPosition);

  public static PlayAction Stack(PlayAction action, bool fixedPosition = false) => ActionQueue.Insert(0, action, fixedPosition);

  public static PlayAction[] GetActions() => MonoBehaviourSingleton<ActionQueue>.instance.queue.ToArray();

  public static int IndexOf(PlayAction action) => MonoBehaviourSingleton<ActionQueue>.instance.queue.IndexOf(action);

  public static bool Remove(PlayAction action)
  {
    if (ActionQueue.IndexOf(action) < 0 || action == ActionQueue.current)
      return false;
    MonoBehaviourSingleton<ActionQueue>.instance.queue.Remove(action);
    --MonoBehaviourSingleton<ActionQueue>.instance.count;
    return true;
  }

  public static IEnumerator Wait(bool includeParallel = true)
  {
    while (MonoBehaviourSingleton<ActionQueue>.instance.count > 0)
      yield return (object) null;
    if (includeParallel)
      yield return (object) ActionQueue.parallelClump.WaitForEnd();
  }

  public void Start() => this.StartCoroutine(this.Routine());

  public static void Restart()
  {
    Debug.Log((object) "~ ACTION QUEUE RESET ~");
    MonoBehaviourSingleton<ActionQueue>.instance.StopAllCoroutines();
    MonoBehaviourSingleton<ActionQueue>.instance.queue.Clear();
    MonoBehaviourSingleton<ActionQueue>.instance.count = 0;
    ActionQueue.current = (PlayAction) null;
    ActionQueue.parallelClump.Clear();
    MonoBehaviourSingleton<ActionQueue>.instance.StartCoroutine(MonoBehaviourSingleton<ActionQueue>.instance.Routine());
  }

  public IEnumerator Routine()
  {
    while (true)
    {
      while (this.count <= 0 || GameManager.paused || Deckpack.IsOpen || ActionQueue.current != null)
        yield return (object) null;
      yield return (object) this.RunActionRoutine();
    }
  }

  public IEnumerator RunActionRoutine()
  {
    int index = ActionQueue.GetIndexOfHighestPriorityAction((IReadOnlyList<PlayAction>) this.queue);
    ActionQueue.current = this.queue[index];
    ActionQueue.current.fixedPosition = true;
    if (ActionQueue.current.parallel)
    {
      ActionQueue.RunParallel(ActionQueue.current);
      this.queue.RemoveAt(index);
      --this.count;
    }
    else
    {
      yield return (object) this.PerformAction(ActionQueue.current);
      this.queue.RemoveAt(index);
      --this.count;
      yield return (object) this.PostAction(ActionQueue.current);
    }
    ActionQueue.current = (PlayAction) null;
  }

  public static int GetIndexOfHighestPriorityAction(IReadOnlyList<PlayAction> actions)
  {
    int num = int.MinValue;
    int highestPriorityAction = -1;
    int count = actions.Count;
    for (int index = 0; index < count; ++index)
    {
      PlayAction action = actions[index];
      if (action.priority > num)
      {
        num = action.priority;
        highestPriorityAction = index;
      }
    }
    return highestPriorityAction;
  }

  public IEnumerator Run(PlayAction action)
  {
    yield return (object) this.PerformAction(action);
    yield return (object) this.PostAction(action);
  }

  public IEnumerator PerformAction(PlayAction action)
  {
    Events.InvokeActionPerform(action);
    if ((double) action.pauseBefore + (double) this.delayBefore > 0.0)
      yield return (object) Sequences.Wait(action.pauseBefore + this.delayBefore);
    if (action.IsRoutine)
      yield return (object) action.Run();
    else
      action.Process();
  }

  public IEnumerator PostAction(PlayAction action)
  {
    Events.InvokeActionFinished(action);
    yield return (object) StatusEffectSystem.ActionPerformedEvent(action);
    if ((double) action.pauseAfter + (double) this.delayAfter > 0.0)
      yield return (object) Sequences.Wait(action.pauseAfter + this.delayAfter);
  }

  public static void RunParallel(PlayAction action) => ActionQueue.parallelClump.Add(MonoBehaviourSingleton<ActionQueue>.instance.Run(action));
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionRedraw
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ActionRedraw : PlayAction
{
  public readonly Character character;
  public readonly int drawCount;

  public ActionRedraw(Character character, int drawCount = -1)
  {
    this.character = character;
    this.drawCount = drawCount;
  }

  public override bool IsRoutine => false;

  public override void Process()
  {
    if (!(bool) (Object) this.character)
      return;
    this.DiscardAll();
    if (this.drawCount < 0)
    {
      ActionQueue.Add((PlayAction) new ActionDrawHand(this.character));
    }
    else
    {
      if (this.drawCount <= 0)
        return;
      ActionQueue.Add((PlayAction) new ActionDraw(this.character, this.drawCount));
    }
  }

  public void DiscardAll()
  {
    foreach (Entity entity in this.character.handContainer)
    {
      entity.display.hover.SetHoverable(false);
      ActionQueue.Stack((PlayAction) new ActionMove(entity, new CardContainer[1]
      {
        this.character.discardContainer
      }));
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionReduceUses
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class ActionReduceUses : PlayAction
{
  public readonly Entity entity;

  public ActionReduceUses(Entity entity) => this.entity = entity;

  public override IEnumerator Run()
  {
    if ((bool) (Object) this.entity)
      yield return (object) ActionReduceUses.CardReduceUses(this.entity);
  }

  public static IEnumerator CardReduceUses(Entity entity)
  {
    if (entity.uses.max > 0 && entity.uses.current > 0)
    {
      if (--entity.uses.current <= 0)
      {
        if (entity.alive)
          yield return (object) Sequences.CardDiscard(entity);
      }
      else if (entity.alive)
        entity.TweenToContainer();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionRefreshWhileActiveEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;

public class ActionRefreshWhileActiveEffect : PlayAction
{
  public readonly StatusEffectWhileActiveX effect;
  public static ulong idCurrent;
  public readonly ulong id;

  public ActionRefreshWhileActiveEffect(StatusEffectWhileActiveX effect)
  {
    this.effect = effect;
    this.id = ActionRefreshWhileActiveEffect.idCurrent++;
  }

  public override IEnumerator Run()
  {
    yield return (object) this.effect.Deactivate();
    yield return (object) this.effect.Activate();
    PlayAction[] actions = ActionQueue.GetActions();
    for (int index = actions.Length - 1; index >= 0; --index)
    {
      PlayAction action = actions[index];
      if (action is ActionRefreshWhileActiveEffect whileActiveEffect && (long) whileActiveEffect.id != (long) this.id && (long) whileActiveEffect.effect.id == (long) this.effect.id)
        ActionQueue.Remove(action);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionResetOffset
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ActionResetOffset : PlayAction
{
  public readonly Entity entity;
  public const float dur = 0.33f;
  public const LeanTweenType ease = LeanTweenType.easeOutQuint;

  public ActionResetOffset(Entity entity) => this.entity = entity;

  public override bool IsRoutine => false;

  public override void Process()
  {
    if (!this.entity.IsAliveAndExists())
      return;
    GameObject gameObject = this.entity.offset.gameObject;
    LeanTween.cancel(gameObject);
    LeanTween.scale(gameObject, Vector3.one, 0.33f).setEase(LeanTweenType.easeOutQuint);
    LeanTween.moveLocal(gameObject, Vector3.zero, 0.33f).setEase(LeanTweenType.easeOutQuint);
    LeanTween.rotateLocal(gameObject, Vector3.zero, 0.33f).setEase(LeanTweenType.easeOutQuint);
    this.entity.ResetDrawOrder();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionReveal
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class ActionReveal : PlayAction
{
  public readonly Entity entity;

  public ActionReveal(Entity entity, float pauseAfter = 0.0f)
  {
    this.entity = entity;
    this.pauseAfter = pauseAfter;
  }

  public override bool IsRoutine => false;

  public override void Process()
  {
    if (this.entity.flipper.flipped)
      this.entity.flipper.FlipUp();
    this.entity.enabled = true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionRevealAll
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class ActionRevealAll : PlayAction
{
  public readonly CardContainer[] containers;

  public ActionRevealAll(params CardContainer[] containers) => this.containers = containers;

  public override bool IsRoutine => false;

  public override void Process()
  {
    HashSet<Entity> entitySet = new HashSet<Entity>();
    float pauseAfter = 0.167f;
    int num = 1;
    foreach (CardContainer container in this.containers)
    {
      if (!((Object) container == (Object) null))
      {
        foreach (Entity entity in container)
        {
          if (!((Object) entity == (Object) null))
          {
            if (entity.flipper.flipped)
              ActionQueue.Insert(num++, (PlayAction) new ActionReveal(entity, pauseAfter));
            if (!entity.enabled)
              entitySet.Add(entity);
          }
        }
      }
    }
    foreach (Entity entity in entitySet)
      ActionQueue.Insert(num++, (PlayAction) new ActionRunEnableEvent(entity));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionRunEnableEvent
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;

public class ActionRunEnableEvent : PlayAction
{
  public readonly Entity entity;

  public ActionRunEnableEvent(Entity entity) => this.entity = entity;

  public override IEnumerator Run()
  {
    if (this.entity.StillExists())
    {
      this.entity.enabled = true;
      Events.InvokeEntityEnabled(this.entity);
      yield return (object) StatusEffectSystem.EntityEnableEvent(this.entity);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionSelect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

public class ActionSelect : PlayAction
{
  public Entity entity;
  public Action<Entity> action;

  public override bool IsRoutine => false;

  public ActionSelect(Entity entity, Action<Entity> action)
  {
    this.entity = entity;
    this.action = action;
  }

  public override void Process() => this.action(this.entity);
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;

public class ActionSequence : PlayAction
{
  public readonly Routine routine;

  public ActionSequence(IEnumerator enumerator) => this.routine = new Routine(enumerator, false);

  public override IEnumerator Run()
  {
    this.routine.Start();
    while (this.routine.IsRunning)
      yield return (object) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionShove
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;

public class ActionShove : PlayAction
{
  public readonly Dictionary<Entity, List<CardSlot>> shoveData;
  public readonly bool updatePositions;

  public ActionShove(Dictionary<Entity, List<CardSlot>> shoveData, bool updatePositions = false)
  {
    this.shoveData = shoveData;
    this.updatePositions = updatePositions;
  }

  public override IEnumerator Run() => ShoveSystem.DoShove(this.shoveData, this.updatePositions);
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionTrigger
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

public class ActionTrigger : PlayAction
{
  public readonly Entity entity;
  public readonly Entity triggeredBy;
  public string triggerType = "basic";

  public ActionTrigger(Entity entity, Entity triggeredBy)
  {
    this.entity = entity;
    this.triggeredBy = triggeredBy;
  }

  public override bool IsRoutine => false;

  public override void Process()
  {
    if (!this.entity.IsAliveAndExists())
      return;
    Events.InvokePreProcessTrigger(this.entity);
    ActionQueue.Stack((PlayAction) new ActionProcessTrigger(new Func<Trigger>(this.GetTrigger)));
  }

  public virtual Trigger GetTrigger() => new Trigger(this.entity, this.triggeredBy, this.triggerType, (bool) (UnityEngine.Object) this.entity.targetMode ? this.entity.targetMode.GetTargets(this.entity, (Entity) null, (CardContainer) null) : (Entity[]) null);
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionTriggerAgainst
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

public class ActionTriggerAgainst : ActionTrigger
{
  public Entity target;
  public readonly CardContainer targetContainer;
  public Trigger trigger;
  public bool countsAsTrigger = true;

  public ActionTriggerAgainst(
    Entity entity,
    Entity triggeredBy,
    Entity target,
    CardContainer targetContainer)
    : base(entity, triggeredBy)
  {
    this.target = target;
    this.targetContainer = targetContainer;
  }

  public override bool IsRoutine => false;

  public override void Process()
  {
    if (!this.entity.IsAliveAndExists())
      return;
    Events.InvokePreProcessTrigger(this.entity);
    ActionQueue.Stack((PlayAction) new ActionProcessTrigger(new Func<Trigger>(((ActionTrigger) this).GetTrigger)));
  }

  public override Trigger GetTrigger()
  {
    Entity[] targets = this.GetTargets();
    if (this.trigger == null)
      this.trigger = new Trigger(this.entity, this.triggeredBy, this.triggerType, targets);
    this.trigger.triggerAgainst = true;
    this.trigger.triggerAgainstTarget = this.target;
    this.trigger.triggerAgainstContainer = this.targetContainer;
    this.trigger.countsAsTrigger = this.countsAsTrigger;
    return this.trigger;
  }

  public virtual Entity[] GetTargets() => !this.countsAsTrigger ? new Entity[1]
  {
    this.target
  } : (!(bool) (UnityEngine.Object) this.entity.targetMode ? (Entity[]) null : this.entity.targetMode.GetTargets(this.entity, this.target, this.targetContainer));
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionTriggerByCounter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

public class ActionTriggerByCounter : ActionTrigger
{
  public ActionTriggerByCounter(Entity entity, Entity triggeredBy)
    : base(entity, triggeredBy)
  {
  }

  public override bool IsRoutine => false;

  public override void Process()
  {
    if (!this.entity.IsAliveAndExists())
      return;
    Events.InvokePreProcessTrigger(this.entity);
    ActionQueue.Stack((PlayAction) new ActionProcessTrigger(new Func<Trigger>(((ActionTrigger) this).GetTrigger)));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ActionTriggerSubsequent
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ActionTriggerSubsequent : ActionTriggerAgainst
{
  public ActionTriggerSubsequent(
    Entity entity,
    Entity triggeredBy,
    Entity target,
    CardContainer targetContainer)
    : base(entity, triggeredBy, target, targetContainer)
  {
  }

  public override Entity[] GetTargets() => !(bool) (Object) this.entity.targetMode ? (Entity[]) null : this.entity.targetMode.GetSubsequentTargets(this.entity, this.target, this.targetContainer);
}
﻿// Decompiled with JetBrains decompiler
// Type: AddFrenzyToBossesModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine.Events;

public class AddFrenzyToBossesModifierSystem : GameSystem
{
  public StatusEffectData _effect;

  public StatusEffectData effect => this._effect ?? (this._effect = AddressableLoader.Get<StatusEffectData>("StatusEffectData", "MultiHit"));

  public void OnEnable() => global::Events.OnCardDataCreated += new UnityAction<CardData>(this.CardDataCreated);

  public void OnDisable() => global::Events.OnCardDataCreated -= new UnityAction<CardData>(this.CardDataCreated);

  public void CardDataCreated(CardData cardData)
  {
    string name = cardData.cardType.name;
    if (!(name == "Miniboss") && !(name == "Boss") && !(name == "BossSmall"))
      return;
    cardData.startWithEffects = CardData.StatusEffectStacks.Stack((IEnumerable<CardData.StatusEffectStacks>) cardData.startWithEffects, (IEnumerable<CardData.StatusEffectStacks>) new CardData.StatusEffectStacks[1]
    {
      new CardData.StatusEffectStacks(this.effect, 1)
    });
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AddressableAssetLoader`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

public abstract class AddressableAssetLoader<T> : MonoBehaviour
{
  [SerializeField]
  public bool instant = true;
  [SerializeField]
  public bool onEnable = true;
  [SerializeField]
  public bool releaseOnDisable = true;
  public AsyncOperationHandle<T> operation;
  public bool loaded;

  public void OnEnable()
  {
    if (!this.onEnable)
      return;
    this.Load();
  }

  public void OnDisable()
  {
    if (!this.releaseOnDisable)
      return;
    this.Release();
  }

  public void OnDestroy()
  {
    if (this.releaseOnDisable)
      return;
    this.Release();
  }

  public void Release()
  {
    if (this.operation.IsValid())
      Addressables.Release<T>(this.operation);
    this.loaded = false;
  }

  public virtual void Load()
  {
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AddressableGroup`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.AddressableAssets;
using UnityEngine.Events;
using UnityEngine.ResourceManagement.AsyncOperations;
using UnityEngine.SceneManagement;

public class AddressableGroup<T> : IEnumerable<T>, IEnumerable, IDisposable where T : UnityEngine.Object
{
  public readonly List<AsyncOperationHandle<T>> handles;
  public bool subbed;

  public AddressableGroup(params AssetReferenceT<T>[] assetRefs)
  {
    this.handles = new List<AsyncOperationHandle<T>>();
    foreach (AssetReferenceT<T> assetRef in assetRefs)
      this.handles.Add(assetRef.LoadAssetAsync());
  }

  public void WaitForCompletion()
  {
    foreach (AsyncOperationHandle<T> handle in this.handles)
      handle.WaitForCompletion();
  }

  public void Dispose()
  {
    this.Release();
    if (!this.subbed)
      return;
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
  }

  public void DisposeOnSceneChange()
  {
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    this.subbed = true;
  }

  public void SceneChanged(Scene scene) => this.Dispose();

  public void Release()
  {
    foreach (AsyncOperationHandle<T> handle in this.handles)
      Addressables.Release<T>(handle);
  }

  public IEnumerator<T> GetEnumerator() => this.handles.Select<AsyncOperationHandle<T>, T>((Func<AsyncOperationHandle<T>, T>) (a =>
  {
    a.WaitForCompletion();
    return a.Result;
  })).GetEnumerator();

  IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.handles.GetEnumerator();
}
﻿// Decompiled with JetBrains decompiler
// Type: AddressableLoader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

public class AddressableLoader : MonoBehaviour
{
  [SerializeField]
  public bool initOnStart;
  public static readonly Dictionary<string, AddressableLoader.Group> groups = new Dictionary<string, AddressableLoader.Group>();

  public IEnumerator Start()
  {
    if (this.initOnStart)
    {
      Debug.Log((object) "Addressables Init");
      yield return (object) Addressables.InitializeAsync();
      Debug.Log((object) "Addressables Init Done");
    }
  }

  public static bool IsGroupLoaded(string name) => AddressableLoader.groups.ContainsKey(name);

  public static void ForceLoadGroup(string name)
  {
    AsyncOperationHandle<IList<DataFile>> handle;
    if (!AddressableLoader.StartLoadGroup(name, out handle))
      return;
    handle.WaitForCompletion();
    AddressableLoader.StoreGroup<DataFile>(name, (ICollection<DataFile>) handle.Result);
  }

  public static async Task PreLoadGroup(string name)
  {
    if (AddressableLoader.IsGroupLoaded(name))
      return;
    AsyncOperationHandle<IList<DataFile>> handle;
    AddressableLoader.StartLoadGroup(name, out handle);
    IList<DataFile> task = await handle.Task;
  }

  public static IEnumerator LoadGroup(string name)
  {
    AsyncOperationHandle<IList<DataFile>> handle;
    if (AddressableLoader.StartLoadGroup(name, out handle))
    {
      yield return (object) handle;
      AddressableLoader.StoreGroup<DataFile>(name, (ICollection<DataFile>) handle.Result);
    }
  }

  public static bool StartLoadGroup(string name, out AsyncOperationHandle<IList<DataFile>> handle)
  {
    if (AddressableLoader.IsGroupLoaded(name))
    {
      Debug.Log((object) ("Group [" + name + "] is already loaded!"));
      handle = new AsyncOperationHandle<IList<DataFile>>();
      return false;
    }
    handle = Addressables.LoadAssetsAsync<DataFile>((object) name, (Action<DataFile>) null);
    return true;
  }

  public static void StoreGroup<T>(string name, ICollection<T> data) where T : DataFile
  {
    if (data == null)
      data = (ICollection<T>) new List<T>();
    AddressableLoader.Group group = new AddressableLoader.Group((IEnumerable<DataFile>) data);
    AddressableLoader.groups[name] = group;
    Debug.Log((object) string.Format("Group [{0}] loaded! ({1} items)", (object) name, (object) data.Count));
  }

  public static List<T> GetGroup<T>(string name) where T : DataFile
  {
    if (!AddressableLoader.IsGroupLoaded(name))
      AddressableLoader.ForceLoadGroup(name);
    return AddressableLoader.groups[name].GetList<T>();
  }

  public static void AddToGroup<T>(string name, T value) where T : DataFile
  {
    if (!AddressableLoader.IsGroupLoaded(name))
      AddressableLoader.ForceLoadGroup(name);
    AddressableLoader.groups[name].Add<T>(value);
  }

  public static void RemoveFromGroup<T>(string name, T value) where T : DataFile
  {
    if (!AddressableLoader.IsGroupLoaded(name))
      AddressableLoader.ForceLoadGroup(name);
    AddressableLoader.groups[name].Remove<T>(value);
  }

  public static void AddRangeToGroup<T>(string name, IEnumerable<T> value) where T : DataFile
  {
    if (!AddressableLoader.IsGroupLoaded(name))
      AddressableLoader.ForceLoadGroup(name);
    AddressableLoader.groups[name].AddRange<T>(value);
  }

  public static T Get<T>(string groupName, string assetName) where T : DataFile
  {
    if (!AddressableLoader.IsGroupLoaded(groupName))
      AddressableLoader.ForceLoadGroup(groupName);
    try
    {
      return AddressableLoader.groups[groupName].Get<T>(assetName);
    }
    catch (Exception ex)
    {
      throw new Exception("[" + assetName + "] does not exist!\n\n" + ex.Message, ex.InnerException);
    }
  }

  public static CardData GetCardDataClone(string cardDataName)
  {
    CardData cardData = AddressableLoader.Get<CardData>("CardData", cardDataName);
    return !(bool) (UnityEngine.Object) cardData ? MissingCardSystem.GetClone(cardDataName) : cardData.Clone();
  }

  public static T Get<T>(string assetName) where T : DataFile
  {
    AsyncOperationHandle<T> asyncOperationHandle = Addressables.LoadAssetAsync<T>((object) assetName);
    asyncOperationHandle.WaitForCompletion();
    return asyncOperationHandle.Result;
  }

  public static GameObject Get(string assetName)
  {
    AsyncOperationHandle<GameObject> asyncOperationHandle = Addressables.LoadAssetAsync<GameObject>((object) assetName);
    asyncOperationHandle.WaitForCompletion();
    return asyncOperationHandle.Result;
  }

  public static bool TryGet<T>(string groupName, string assetName, out T result) where T : DataFile
  {
    if (!AddressableLoader.IsGroupLoaded(groupName))
      AddressableLoader.ForceLoadGroup(groupName);
    result = AddressableLoader.groups[groupName].Get<T>(assetName);
    return (UnityEngine.Object) result != (UnityEngine.Object) null;
  }

  public static AsyncOperationHandle<GameObject> InstantiateAsync(
    string key,
    Vector3 position,
    Quaternion rotation,
    Transform parent = null)
  {
    return Addressables.InstantiateAsync((object) key, position, rotation, parent);
  }

  public static AsyncOperationHandle<GameObject> InstantiateAsync(
    AssetReference assetRef,
    Vector3 position,
    Quaternion rotation,
    Transform parent = null)
  {
    return assetRef.InstantiateAsync(position, rotation, parent);
  }

  public class Group
  {
    public readonly Dictionary<string, DataFile> lookup = new Dictionary<string, DataFile>();
    public readonly List<DataFile> list = new List<DataFile>();

    public T Get<T>(string name) where T : DataFile => !this.lookup.ContainsKey(name) ? default (T) : this.lookup[name] as T;

    public List<T> GetList<T>() where T : DataFile => this.list.Cast<T>().ToList<T>();

    public void Add<T>(T obj) where T : DataFile
    {
      this.list.Add((DataFile) obj);
      this.lookup[AddressableLoader.Group.GetName((DataFile) obj)] = (DataFile) obj;
    }

    public void Remove<T>(T obj) where T : DataFile
    {
      this.list.Remove((DataFile) obj);
      this.lookup.Remove(AddressableLoader.Group.GetName((DataFile) obj));
    }

    public void AddRange<T>(IEnumerable<T> obj) where T : DataFile
    {
      foreach (T obj1 in obj)
        this.Add<T>(obj1);
    }

    public Group(IEnumerable<DataFile> items)
    {
      foreach (DataFile asset in items)
      {
        this.list.Add(asset);
        this.lookup[AddressableLoader.Group.GetName(asset)] = asset;
      }
    }

    public static string GetName(DataFile asset) => !(asset is KeywordData keywordData) ? asset.name : keywordData.name.ToLower();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AddressablePrefabLoader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Events;
using UnityEngine.ResourceManagement.AsyncOperations;

public class AddressablePrefabLoader : AddressableAssetLoader<GameObject>
{
  [SerializeField]
  public AssetReferenceGameObject prefabRef;
  [SerializeField]
  public bool setChildIndex;
  [SerializeField]
  [ShowIf("setChildIndex")]
  public int childIndex;
  [SerializeField]
  public UnityEvent<GameObject> onLoad;

  public override void Load()
  {
    if (this.loaded)
      return;
    this.operation = this.prefabRef.InstantiateAsync(this.transform);
    if (this.instant)
    {
      this.operation.WaitForCompletion();
      this.Loaded();
    }
    else
      this.operation.Completed += (Action<AsyncOperationHandle<GameObject>>) (_ => this.Loaded());
    this.loaded = true;
  }

  public void Loaded()
  {
    if (this.setChildIndex)
      this.operation.Result.transform.SetSiblingIndex(this.childIndex);
    this.onLoad?.Invoke(this.operation.Result);
  }

  [CompilerGenerated]
  public void \u003CLoad\u003Eb__4_0(AsyncOperationHandle<GameObject> _) => this.Loaded();
}
﻿// Decompiled with JetBrains decompiler
// Type: AddressableReleaser
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

public class AddressableReleaser : MonoBehaviour
{
  [SerializeField]
  public bool releaseOnDisable = true;
  [SerializeField]
  [HideIf("releaseOnDisable")]
  public bool releaseOnDestroy;
  [CompilerGenerated]
  [SerializeField]
  public int \u003CassetsToRelease\u003Ek__BackingField;
  public readonly List<AsyncOperationHandle> handles = new List<AsyncOperationHandle>();

  public int assetsToRelease
  {
    get => this.\u003CassetsToRelease\u003Ek__BackingField;
    set => this.\u003CassetsToRelease\u003Ek__BackingField = value;
  }

  public void Add(AsyncOperationHandle handle)
  {
    this.handles.Add(handle);
    ++this.assetsToRelease;
  }

  public void OnDisable()
  {
    if (!this.releaseOnDisable)
      return;
    this.ReleaseAll();
  }

  public void OnDestroy()
  {
    if (!this.releaseOnDestroy)
      return;
    this.ReleaseAll();
  }

  public void ReleaseAll()
  {
    foreach (AsyncOperationHandle handle in this.handles)
    {
      Debug.Log((object) string.Format("→ Asset Releaser Releasing Asset: {0}", handle.Result));
      Addressables.Release(handle);
    }
    this.handles.Clear();
    this.assetsToRelease = 0;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AddressableSpriteLoader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
using UnityEngine.UI;

public class AddressableSpriteLoader : AddressableAssetLoader<Sprite>
{
  [SerializeField]
  public bool atlas = true;
  [ShowIf("atlas")]
  public AssetReferenceAtlasedSprite atlasedSpriteRef;
  [HideIf("atlas")]
  public AssetReferenceSprite spriteRef;
  [SerializeField]
  public AddressableSpriteLoader.Type type;
  [SerializeField]
  [ShowIf("IsSpriteRenderer")]
  public SpriteRenderer spriteRenderer;
  [SerializeField]
  [ShowIf("IsImage")]
  public Image image;
  [SerializeField]
  [ShowIf("IsImageSprite")]
  public ImageSprite imageSprite;

  public bool IsSpriteRenderer => this.type == AddressableSpriteLoader.Type.SpriteRenderer;

  public bool IsImage => this.type == AddressableSpriteLoader.Type.Image;

  public bool IsImageSprite => this.type == AddressableSpriteLoader.Type.ImageSprite;

  public override void Load()
  {
    if (this.loaded)
      return;
    this.operation = this.atlas ? this.atlasedSpriteRef.LoadAssetAsync() : this.spriteRef.LoadAssetAsync();
    if (this.instant)
    {
      this.operation.WaitForCompletion();
      this.SetSprite();
    }
    else
      this.operation.Completed += (Action<AsyncOperationHandle<Sprite>>) (_ => this.SetSprite());
    this.loaded = true;
  }

  public void SetSprite()
  {
    switch (this.type)
    {
      case AddressableSpriteLoader.Type.SpriteRenderer:
        this.spriteRenderer.sprite = this.operation.Result;
        break;
      case AddressableSpriteLoader.Type.Image:
        this.image.sprite = this.operation.Result;
        break;
      case AddressableSpriteLoader.Type.ImageSprite:
        this.imageSprite.SetSprite(this.operation.Result);
        break;
    }
  }

  [CompilerGenerated]
  public void \u003CLoad\u003Eb__14_0(AsyncOperationHandle<Sprite> _) => this.SetSprite();

  public enum Type
  {
    SpriteRenderer,
    Image,
    ImageSprite,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AddressableTieredSpriteLoader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
using UnityEngine.UI;

public class AddressableTieredSpriteLoader : AddressableAssetLoader<Sprite>
{
  [SerializeField]
  public AddressableTieredSpriteLoader.Tier[] tiers;
  [SerializeField]
  public AddressableTieredSpriteLoader.Type type;
  [SerializeField]
  [ShowIf("IsSpriteRenderer")]
  public SpriteRenderer spriteRenderer;
  [SerializeField]
  [ShowIf("IsImage")]
  public Image image;
  [SerializeField]
  [ShowIf("IsImageSprite")]
  public ImageSprite imageSprite;

  public bool IsSpriteRenderer => this.type == AddressableTieredSpriteLoader.Type.SpriteRenderer;

  public bool IsImage => this.type == AddressableTieredSpriteLoader.Type.Image;

  public bool IsImageSprite => this.type == AddressableTieredSpriteLoader.Type.ImageSprite;

  public override void Load() => this.Load(0);

  public void Load(int tier)
  {
    tier = Mathf.Clamp(tier, 0, this.tiers.Length - 1);
    this.Load(this.tiers[tier]);
  }

  public void Load(AddressableTieredSpriteLoader.Tier tier)
  {
    if (this.loaded)
      return;
    this.operation = tier.atlas ? tier.atlasedSpriteRef.LoadAssetAsync() : tier.spriteRef.LoadAssetAsync();
    if (this.instant)
    {
      this.operation.WaitForCompletion();
      this.SetSprite();
    }
    else
      this.operation.Completed += (Action<AsyncOperationHandle<Sprite>>) (_ => this.SetSprite());
    this.loaded = true;
  }

  public void SetSprite()
  {
    switch (this.type)
    {
      case AddressableTieredSpriteLoader.Type.SpriteRenderer:
        this.spriteRenderer.sprite = this.operation.Result;
        break;
      case AddressableTieredSpriteLoader.Type.Image:
        this.image.sprite = this.operation.Result;
        break;
      case AddressableTieredSpriteLoader.Type.ImageSprite:
        this.imageSprite.SetSprite(this.operation.Result);
        break;
    }
  }

  [CompilerGenerated]
  public void \u003CLoad\u003Eb__14_0(AsyncOperationHandle<Sprite> _) => this.SetSprite();

  public enum Type
  {
    SpriteRenderer,
    Image,
    ImageSprite,
  }

  [Serializable]
  public struct Tier
  {
    public bool atlas;
    public AssetReferenceAtlasedSprite atlasedSpriteRef;
    public AssetReferenceSprite spriteRef;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AddressableVideoClipLoader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
using UnityEngine.Video;

public class AddressableVideoClipLoader : AddressableAssetLoader<VideoClip>
{
  public AssetReferenceT<VideoClip> videoClipRef;
  [SerializeField]
  public VideoPlayer videoPlayer;

  public override void Load()
  {
    if (this.loaded)
      return;
    this.operation = this.videoClipRef.LoadAssetAsync();
    if (this.instant)
    {
      this.operation.WaitForCompletion();
      this.SetVideoClip();
    }
    else
      this.operation.Completed += (Action<AsyncOperationHandle<VideoClip>>) (_ => this.SetVideoClip());
    this.loaded = true;
  }

  public void SetVideoClip()
  {
    this.videoPlayer.clip = this.operation.Result;
    this.videoPlayer.Play();
  }

  [CompilerGenerated]
  public void \u003CLoad\u003Eb__2_0(AsyncOperationHandle<VideoClip> _) => this.SetVideoClip();
}
﻿// Decompiled with JetBrains decompiler
// Type: AddSecretCardsSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Events;

public class AddSecretCardsSystem : GameSystem
{
  [SerializeField]
  public GameModifierData[] requiredModifiers;
  [SerializeField]
  public string[] cardsToAdd;
  [SerializeField]
  public string[] possibleNodeTypes;
  [SerializeField]
  public int[] tiers = new int[2]{ 2, 4 };

  public bool HasRequiredModifiers() => Campaign.Data.GameMode.mainGameMode && StormBellManager.TrueFinalBossPointThresholdReached();

  public void OnEnable()
  {
    global::Events.OnCampaignGenerated += new global::Events.AsyncAction(this.Add);
    global::Events.OnEntityEnterBackpack += new UnityAction<Entity>(this.EntityEnterBackpack);
    if (Campaign.Data.Modifiers != null && this.HasRequiredModifiers())
      return;
    this.enabled = false;
  }

  public void OnDisable()
  {
    global::Events.OnCampaignGenerated -= new global::Events.AsyncAction(this.Add);
    global::Events.OnEntityEnterBackpack -= new UnityAction<Entity>(this.EntityEnterBackpack);
  }

  public async Task Add()
  {
    HashSet<CampaignNode> source = new HashSet<CampaignNode>();
    foreach (CampaignNode node in References.Campaign.nodes)
    {
      if (this.tiers.Contains<int>(node.tier) && this.possibleNodeTypes.Contains<string>(node.type.name))
        source.Add(node);
    }
    if (source.Count < this.cardsToAdd.Length)
      return;
    List<CampaignNode> list = source.InRandomOrder<CampaignNode>().OrderByDescending<CampaignNode, int>(new Func<CampaignNode, int>(AddSecretCardsSystem.OrderNodesBySingular)).ToList<CampaignNode>();
    foreach (string cardName in this.cardsToAdd)
    {
      CampaignNode node = list[0];
      list.RemoveAt(0);
      AddSecretCardsSystem.AddCardToNode(node, cardName);
      list.RemoveAll((Predicate<CampaignNode>) (a => a.tier == node.tier));
    }
  }

  public static int OrderNodesBySingular(CampaignNode a)
  {
    if (a.dataLinkedTo == -1)
    {
      List<int> linkedToThis = a.linkedToThis;
      if ((linkedToThis == null || linkedToThis.Count <= 0) && (a.connections.Count > 1 || a.connectedTo > 1))
        return 1;
    }
    return -1;
  }

  public void EntityEnterBackpack(Entity entity)
  {
    if (!((IEnumerable<string>) this.cardsToAdd).Any<string>((Func<string, bool>) (a => entity.name == a)))
      return;
    Campaign.FindCharacterNode(References.Player).glow = false;
  }

  public static void AddCardToNode(CampaignNode node, string cardName)
  {
    node.glow = true;
    switch (node.type)
    {
      case CampaignNodeTypeItem _:
      case CampaignNodeTypeCurseItems _:
        SaveCollection<string> saveCollection = node.data.Get<SaveCollection<string>>("cards");
        bool flag = false;
        foreach (int index in (IEnumerable<int>) ((IList<string>) saveCollection.collection).GetIndices<string>().InRandomOrder<int>())
        {
          if (!node.data.ContainsKey(string.Format("upgrades{0}", (object) index)))
          {
            saveCollection[index] = cardName;
            flag = true;
            break;
          }
        }
        if (flag)
          break;
        int index1 = UnityEngine.Random.Range(0, saveCollection.Count - 1);
        saveCollection[index1] = cardName;
        node.data.Remove(string.Format("upgrades{0}", (object) index1));
        break;
      case CampaignNodeTypeShop _:
        ShopRoutine.Data data1 = node.data.Get<ShopRoutine.Data>("shopData");
        float priceFactor1 = UnityEngine.Random.Range(0.8f, 1.2f);
        CardData cardData1 = AddressableLoader.Get<CardData>("CardData", cardName);
        using (IEnumerator<int> enumerator = data1.items.GetIndices<ShopRoutine.Item>().InRandomOrder<int>().GetEnumerator())
        {
          while (enumerator.MoveNext())
          {
            int current = enumerator.Current;
            if (data1.items[current].category == "Items" && (data1.upgrades == null || data1.upgrades.Count <= current || data1.upgrades[current] == null || data1.upgrades[current].Length == 0))
            {
              float priceFactor2 = data1.items[current].priceFactor;
              data1.items[current] = new ShopRoutine.Item("Items", cardData1, 0, priceFactor1)
              {
                priceFactor = priceFactor2
              };
              break;
            }
          }
          break;
        }
      case CampaignNodeTypeCharmShop _:
        EventRoutineCharmShop.Data data2 = node.data.Get<EventRoutineCharmShop.Data>("data");
        float num = UnityEngine.Random.Range(0.8f, 1.2f);
        CardData cardData2 = AddressableLoader.Get<CardData>("CardData", cardName);
        data2.cards[data2.cards.RandomIndex<EventRoutineCharmShop.UpgradedCard>()] = new EventRoutineCharmShop.UpgradedCard()
        {
          cardDataName = cardName,
          upgradeNames = Array.Empty<string>(),
          price = Mathf.RoundToInt((float) cardData2.value * num),
          priceFactor = 1f,
          purchased = false
        };
        break;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AmbienceSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMOD;
using FMOD.Studio;
using FMODUnity;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class AmbienceSystem : GameSystem
{
  [SerializeField]
  public string[] validScenes = new string[2]
  {
    "Battle",
    "Event"
  };
  public static EventInstance current;

  public void OnEnable() => global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);

  public void OnDisable()
  {
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    AmbienceSystem.Stop();
  }

  public void SceneChanged(Scene scene)
  {
    AmbienceSystem.Stop();
    if (!this.validScenes.Contains<string>(scene.name))
      return;
    AmbienceSystem.Play(References.GetCurrentArea().ambienceEvent);
  }

  public static void Play(EventReference eventId) => AmbienceSystem.Play(eventId.Guid);

  public static void Play(GUID eventGUID)
  {
    try
    {
      AmbienceSystem.current = RuntimeManager.CreateInstance(eventGUID);
      int num = (int) AmbienceSystem.current.start();
    }
    catch (EventNotFoundException ex)
    {
      UnityEngine.Debug.LogWarning((object) ex);
    }
  }

  public static void SetParam(string name, float value)
  {
    if (!AmbienceSystem.IsRunning(AmbienceSystem.current))
      return;
    int num = (int) AmbienceSystem.current.setParameterByName(name, value);
  }

  public static void Stop(FMOD.Studio.STOP_MODE stopMode = FMOD.Studio.STOP_MODE.ALLOWFADEOUT)
  {
    if (!AmbienceSystem.IsRunning(AmbienceSystem.current))
      return;
    int num1 = (int) AmbienceSystem.current.stop(stopMode);
    int num2 = (int) AmbienceSystem.current.release();
  }

  public static bool IsRunning(EventInstance instance)
  {
    if (instance.isValid())
    {
      PLAYBACK_STATE state;
      int playbackState = (int) instance.getPlaybackState(out state);
      if (state != PLAYBACK_STATE.STOPPED)
        return true;
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Analytics
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class Analytics : GameSystem
{
}
﻿// Decompiled with JetBrains decompiler
// Type: AngleWobbler
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using NaughtyAttributes;
using UnityEngine;

public class AngleWobbler : MonoBehaviour
{
  public Transform holder;
  public Transform target;
  public bool globalSpace = true;
  [SerializeField]
  public Vector3 movementInfluence = new Vector3(-1f, 0.5f, 0.0f);
  [SerializeField]
  public float rotationMax = 45f;
  [SerializeField]
  public Vector2 wobbleFactorRange = new Vector2(4.5f, 5.5f);
  [SerializeField]
  public Vector2 wobbleDampingRange = new Vector2(0.9f, 0.95f);
  [SerializeField]
  public Vector2 wobbleAccRange = new Vector2(0.65f, 0.75f);
  [SerializeField]
  [ReadOnly]
  public float wobbleFactor;
  [SerializeField]
  [ReadOnly]
  public float wobbleDamping;
  [SerializeField]
  [ReadOnly]
  public float wobbleAcc;
  public Vector3 prePosition;
  public float rotation;
  public float rotationVelocity;
  public float startAngle;

  public Vector3 HolderPosition => this.holder.position;

  public void Awake()
  {
    this.SetAngle(this.target.localEulerAngles.z);
    this.wobbleFactor = this.wobbleFactorRange.PettyRandom();
    this.wobbleDamping = this.wobbleDampingRange.PettyRandom();
    this.wobbleAcc = this.wobbleAccRange.PettyRandom();
  }

  public void OnEnable()
  {
    if (!((Object) this.holder != (Object) null))
      return;
    this.prePosition = this.HolderPosition;
  }

  public void Update()
  {
    this.rotationVelocity -= this.rotation * this.wobbleAcc * Time.deltaTime;
    this.rotationVelocity = Delta.Multiply(this.rotationVelocity, this.wobbleDamping, Time.deltaTime);
    this.rotation += this.rotationVelocity * 200f * Time.deltaTime;
    if (this.globalSpace)
    {
      Vector3 eulerAngles = this.target.eulerAngles;
      this.target.eulerAngles = new Vector3(eulerAngles.x, eulerAngles.y, this.startAngle + this.rotation);
    }
    else
    {
      Vector3 localEulerAngles = this.target.localEulerAngles;
      this.target.localEulerAngles = new Vector3(localEulerAngles.x, localEulerAngles.y, this.startAngle + this.rotation);
    }
    Vector3 holderPosition = this.HolderPosition;
    this.Wobble(holderPosition - this.prePosition);
    this.prePosition = holderPosition;
  }

  public void Wobble(Vector3 movement) => this.rotation = Mathf.Clamp(this.rotation + Vector3.Scale(movement, this.movementInfluence).magnitude * this.wobbleFactor, -this.rotationMax, this.rotationMax);

  public void WobbleRandom() => this.rotation = Mathf.Clamp(this.rotation + (this.rotationMax * PettyRandom.Range(0.5f, 1f)).WithRandomSign(), -this.rotationMax, this.rotationMax);

  public void SetAngle(float angle) => this.startAngle = angle;
}
﻿// Decompiled with JetBrains decompiler
// Type: Animator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;

public class Animator : MonoBehaviour
{
  [SerializeField]
  public Animator.Animation[] animations;
  public Dictionary<string, Animator.Animation> lookup;

  public void Awake()
  {
    this.lookup = new Dictionary<string, Animator.Animation>();
    foreach (Animator.Animation animation in this.animations)
      this.lookup[animation.name] = animation;
  }

  public void Play(string animationName)
  {
    if (!this.lookup.ContainsKey(animationName))
      return;
    this.lookup[animationName].Play(this.gameObject);
  }

  public void Stop() => LeanTween.cancel(this.gameObject);

  [Serializable]
  public struct Animation
  {
    public string name;
    public Animator.Animation.Property property;
    public AnimationCurve curve;
    public Vector2 duration;
    public Vector2 delay;
    public Vector3 to;
    public Vector3 from;
    public bool hasFrom;
    public bool loop;

    public void Play(GameObject target)
    {
      LeanTween.cancel(target);
      LTDescr ltDescr = (LTDescr) null;
      switch (this.property)
      {
        case Animator.Animation.Property.Move:
          if (this.hasFrom)
            target.transform.localPosition = this.from;
          ltDescr = LeanTween.moveLocal(target, this.to, this.duration.PettyRandom());
          break;
        case Animator.Animation.Property.Rotate:
          if (this.hasFrom)
            target.transform.localEulerAngles = this.from;
          ltDescr = LeanTween.rotateLocal(target, this.to, this.duration.PettyRandom());
          break;
        case Animator.Animation.Property.Scale:
          if (this.hasFrom)
            target.transform.localScale = this.from;
          ltDescr = LeanTween.scale(target, this.to, this.duration.PettyRandom());
          break;
      }
      float delay = this.delay.PettyRandom();
      if ((double) delay > 0.0 && ltDescr != null)
        ltDescr.setDelay(delay);
      ltDescr?.setEase(this.curve);
      if (!this.loop || ltDescr == null)
        return;
      ltDescr.setLoopClamp();
    }

    public enum Property
    {
      Move,
      Rotate,
      Scale,
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AreaData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using UnityEngine;
using UnityEngine.AddressableAssets;

[CreateAssetMenu(menuName = "Area", fileName = "Area")]
public class AreaData : ScriptableObject
{
  public EventReference battleMusicEvent;
  public EventReference minibossMusicEvent;
  public EventReference bossMusicEvent;
  public EventReference ambienceEvent;
  public AssetReferenceGameObject battleBackgroundPrefabRef;
  public Sprite battleBaseSprite;
}
﻿// Decompiled with JetBrains decompiler
// Type: AspectRatio
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public static class AspectRatio
{
  public static Vector2 GetAspectRatio(int x, int y)
  {
    float num = (float) x / (float) y;
    int y1 = 0;
    do
    {
      ++y1;
    }
    while (Math.Round((double) num * (double) y1, 2) != (double) Mathf.RoundToInt(num * (float) y1));
    return new Vector2((float) Math.Round((double) num * (double) y1, 2), (float) y1);
  }

  public static Vector2 GetAspectRatio(Vector2 xy)
  {
    float num = xy.x / xy.y;
    int y = 0;
    do
    {
      ++y;
    }
    while (Math.Round((double) num * (double) y, 2) != (double) Mathf.RoundToInt(num * (float) y));
    return new Vector2((float) Math.Round((double) num * (double) y, 2), (float) y);
  }

  public static Vector2 GetAspectRatio(int x, int y, bool debug)
  {
    float num = (float) x / (float) y;
    int y1 = 0;
    do
    {
      ++y1;
    }
    while (Math.Round((double) num * (double) y1, 2) != (double) Mathf.RoundToInt(num * (float) y1));
    if (debug)
      Debug.Log((object) ("Aspect ratio is " + (num * (float) y1).ToString() + ":" + y1.ToString() + " (Resolution: " + x.ToString() + nameof (x) + y.ToString() + ")"));
    return new Vector2((float) Math.Round((double) num * (double) y1, 2), (float) y1);
  }

  public static Vector2 GetAspectRatio(Vector2 xy, bool debug)
  {
    float num = xy.x / xy.y;
    int y = 0;
    do
    {
      ++y;
    }
    while (Math.Round((double) num * (double) y, 2) != (double) Mathf.RoundToInt(num * (float) y));
    if (debug)
      Debug.Log((object) ("Aspect ratio is " + (num * (float) y).ToString() + ":" + y.ToString() + " (Resolution: " + xy.x.ToString() + "x" + xy.y.ToString() + ")"));
    return new Vector2((float) Math.Round((double) num * (double) y, 2), (float) y);
  }
}
﻿using System.Reflection;
using System.Runtime.CompilerServices;

[assembly: Extension]
[assembly: AssemblyVersion("0.0.0.0")]
﻿// Decompiled with JetBrains decompiler
// Type: AssetLoader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class AssetLoader : MonoBehaviour
{
  public AssetLoader.Group[] groups;
  public static Dictionary<string, AssetLoader.Group> groupLookup;

  public void Awake()
  {
    Debug.Log((object) "> AssetLoader Loading Resources...");
    StopWatch.Start();
    int num1 = 0;
    int num2 = 0;
    AssetLoader.groupLookup = new Dictionary<string, AssetLoader.Group>();
    foreach (AssetLoader.Group group in this.groups)
    {
      AssetLoader.groupLookup[group.name.ToLower()] = group;
      group.lookup = new Dictionary<string, UnityEngine.Object>();
      ++num1;
      foreach (UnityEngine.Object asset in group.assets)
      {
        group.lookup[asset.name.ToLower()] = asset;
        ++num2;
      }
    }
    Debug.Log((object) string.Format("> {0} Groups", (object) num1));
    Debug.Log((object) string.Format("> {0} Assets", (object) num2));
    Debug.Log((object) string.Format("> DONE ({0}ms)", (object) StopWatch.Stop()));
  }

  public static T Lookup<T>(string groupName, string assetName) where T : UnityEngine.Object => AssetLoader.GetGroup(groupName)?.lookup[assetName.ToLower()] as T;

  public static AssetLoader.Group GetGroup(string groupName) => AssetLoader.groupLookup[groupName.ToLower()];

  public static IEnumerable<T> GetEnumerable<T>(string groupName)
  {
    AssetLoader.Group group = AssetLoader.GetGroup(groupName);
    return group == null ? (IEnumerable<T>) null : group.assets.Cast<T>();
  }

  public static List<T> GetList<T>(string groupName)
  {
    IEnumerable<T> enumerable = AssetLoader.GetEnumerable<T>(groupName);
    return enumerable == null ? (List<T>) null : enumerable.ToList<T>();
  }

  public static T[] GetArray<T>(string groupName)
  {
    IEnumerable<T> enumerable = AssetLoader.GetEnumerable<T>(groupName);
    return enumerable == null ? (T[]) null : enumerable.ToArray<T>();
  }

  [Serializable]
  public class Group
  {
    public string name;
    public UnityEngine.Object[] assets;
    public Dictionary<string, UnityEngine.Object> lookup;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AssignCharmSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UI;

public class AssignCharmSequence : UISequence
{
  [SerializeField]
  public Image background;
  [SerializeField]
  public float backgroundAlpha = 0.67f;
  [SerializeField]
  public Transform cardHolder;
  [SerializeField]
  public float cardScale = 1f;
  [SerializeField]
  public ParticleSystem glows;
  [SerializeField]
  public ParticleSystem ding;
  [SerializeField]
  public UnityEngine.Animator animator;
  public Entity target;
  public CardUpgradeData upgradeData;
  public float fade;
  public static float fadeInDur = 0.5f;
  public static float fadeOutDur = 0.25f;
  public Transform previousParent;
  public int previousChildIndex;
  public Vector3 previousPosition;

  public void Assign(Entity target, CardUpgradeData upgradeData)
  {
    this.target = target;
    this.upgradeData = upgradeData;
  }

  public void Focus()
  {
    this.target.ForceUnHover();
    this.previousParent = this.target.transform.parent;
    this.previousChildIndex = this.target.transform.GetSiblingIndex();
    this.previousPosition = this.target.transform.localPosition;
    this.target.transform.SetParent(this.cardHolder, true);
    LeanTween.moveLocal(this.target.gameObject, Vector3.zero, 0.5f).setEase(LeanTweenType.easeOutQuart);
    this.target.wobbler?.WobbleRandom();
    LeanTween.scale(this.target.gameObject, Vector3.one * this.cardScale, 0.67f).setEase(LeanTweenType.easeOutBack);
    LeanTween.rotateLocal(this.target.gameObject, Vector3.zero, 1f).setEase(LeanTweenType.easeOutBack);
  }

  public void Unfocus()
  {
    this.target.transform.parent = this.previousParent;
    this.target.transform.SetSiblingIndex(this.previousChildIndex);
    this.target.TweenToContainer();
    this.target.wobbler?.WobbleRandom();
  }

  public override IEnumerator Run()
  {
    AssignCharmSequence assignCharmSequence = this;
    assignCharmSequence.gameObject.SetActive(true);
    yield return (object) Sequences.Wait(assignCharmSequence.startDelay);
    assignCharmSequence.BackgroundFade(assignCharmSequence.backgroundAlpha, AssignCharmSequence.fadeInDur);
    assignCharmSequence.Focus();
    assignCharmSequence.animator.SetTrigger("Assign");
    SfxSystem.OneShot("event:/sfx/inventory/charm_assign");
    yield return (object) new WaitForSeconds(3f);
    assignCharmSequence.BackgroundFade(0.0f, AssignCharmSequence.fadeOutDur);
    yield return (object) new WaitForSeconds(AssignCharmSequence.fadeOutDur * 0.5f);
    assignCharmSequence.Unfocus();
    yield return (object) new WaitForSeconds(AssignCharmSequence.fadeOutDur * 0.5f);
    assignCharmSequence.gameObject.SetActive(false);
  }

  public void BackgroundFade(float alpha, float dur)
  {
    LeanTween.cancel(this.background.gameObject);
    LeanTween.value(this.background.gameObject, this.fade, alpha, dur).setEase(LeanTweenType.easeOutQuad).setOnUpdate((Action<float>) (a =>
    {
      this.fade = a;
      this.background.color = this.background.color.WithAlpha(a);
    }));
  }

  public void Rumble() => Events.InvokeScreenRumble(0.0f, 1f, 0.0f, 1f, 0.5f, 0.25f);

  public void AssignCharm()
  {
    Routine routine = new Routine(this.upgradeData.Assign(this.target));
  }

  public void StartGlow() => this.glows.Play();

  public void Ding() => this.ding.Play();

  [CompilerGenerated]
  public void \u003CBackgroundFade\u003Eb__19_0(float a)
  {
    this.fade = a;
    this.background.color = this.background.color.WithAlpha(a);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AudioSettingsSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMOD;
using FMODUnity;
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Events;

public class AudioSettingsSystem : GameSystem
{
  public static bool Loading;
  [SerializeField]
  public AudioSettingsSystem.Bus[] buses;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float slowmoPitchMin = 0.67f;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float slowmoPitchLerp = 0.25f;
  [SerializeField]
  public bool slowmoLerpUseDelta = true;
  [InfoBox("Master.strings and Master MUST be loaded first!", EInfoBoxType.Normal)]
  [SerializeField]
  public AssetReference[] banksToLoad;
  public Dictionary<string, AudioSettingsSystem.Bus> busLookup;
  public float slowmoPitch = 1f;
  public float slowmoPitchTarget = 1f;

  public void Awake() => this.StartCoroutine(this.LoadBanks());

  public void OnEnable()
  {
    global::Events.OnAudioVolumeChange += new UnityAction<string, float>(this.SetVolume);
    global::Events.OnAudioPitchChange += new UnityAction<string, float>(this.SetPitch);
    global::Events.OnTimeScaleChange += new UnityAction<float>(this.TimeScaleChange);
  }

  public void OnDisable()
  {
    global::Events.OnAudioVolumeChange -= new UnityAction<string, float>(this.SetVolume);
    global::Events.OnAudioPitchChange -= new UnityAction<string, float>(this.SetPitch);
    global::Events.OnTimeScaleChange -= new UnityAction<float>(this.TimeScaleChange);
  }

  public IEnumerator LoadBanks()
  {
    AudioSettingsSystem.Loading = true;
    UnityEngine.Debug.Log((object) "Audio Settings System → Loading Banks");
    foreach (AssetReference assetReference in this.banksToLoad)
    {
      RuntimeManager.LoadBank(assetReference, true);
      UnityEngine.Debug.Log((object) string.Format("FMOD BANK {0} LOADED", (object) assetReference));
    }
    while (!RuntimeManager.HaveAllBanksLoaded)
      yield return (object) null;
    while (RuntimeManager.AnySampleDataLoading())
      yield return (object) null;
    this.busLookup = new Dictionary<string, AudioSettingsSystem.Bus>();
    foreach (AudioSettingsSystem.Bus bus in this.buses)
    {
      bus.Init();
      this.busLookup.Add(bus.name, bus);
    }
    AudioSettingsSystem.Loading = false;
  }

  public void Update()
  {
    if ((double) this.slowmoPitch == (double) this.slowmoPitchTarget)
      return;
    this.slowmoPitch = !this.slowmoLerpUseDelta ? Mathf.Lerp(this.slowmoPitch, this.slowmoPitchTarget, this.slowmoPitchLerp) : Delta.Lerp(this.slowmoPitch, this.slowmoPitchTarget, this.slowmoPitchLerp, Time.deltaTime);
    if ((double) Mathf.Abs(this.slowmoPitch - this.slowmoPitchTarget) < 0.0099999997764825821)
      this.slowmoPitch = this.slowmoPitchTarget;
    this.SetPitch("Master", this.slowmoPitch);
  }

  public void TimeScaleChange(float value)
  {
    this.slowmoPitchTarget = this.slowmoPitchMin + (1f - this.slowmoPitchMin) * value;
    AudioSettingsSystem.Bus bus = this.busLookup["Master"];
    if (bus == null)
      return;
    this.slowmoPitch = bus.pitch;
  }

  public void SetVolume(string busName, float value)
  {
    AudioSettingsSystem.Bus bus = this.busLookup[busName];
    if (bus == null)
      return;
    bus.volume = value;
    bus.UpdateVolume();
    Settings.Save<float>(bus.volumeSettingsKey, value);
  }

  public static void Volume(string busName, float value)
  {
    AudioSettingsSystem objectOfType = UnityEngine.Object.FindObjectOfType<AudioSettingsSystem>();
    if (objectOfType == null || !objectOfType.enabled)
      return;
    objectOfType.SetVolume(busName, Mathf.Clamp(value, 0.0f, 1f));
  }

  public static float GetVolume(string busName)
  {
    AudioSettingsSystem objectOfType = UnityEngine.Object.FindObjectOfType<AudioSettingsSystem>();
    if (objectOfType != null)
    {
      if (objectOfType.enabled)
      {
        try
        {
          AudioSettingsSystem.Bus bus = objectOfType.busLookup[busName];
          if (bus != null)
            return bus.volume;
        }
        catch (KeyNotFoundException ex)
        {
          throw new KeyNotFoundException("[" + busName + "] does not exist", ex.InnerException);
        }
      }
    }
    return 0.0f;
  }

  public void SetPitch(string busName, float value)
  {
    try
    {
      AudioSettingsSystem.Bus bus = this.busLookup[busName];
      if (bus == null)
        return;
      bus.pitch = value;
      bus.UpdatePitch();
    }
    catch (KeyNotFoundException ex)
    {
      throw new KeyNotFoundException("[" + busName + "] does not exist", ex.InnerException);
    }
  }

  [Button(null, EButtonEnableMode.Always)]
  public void PromptUpdate()
  {
    foreach (AudioSettingsSystem.Bus bus in this.buses)
    {
      bus.UpdateVolume();
      bus.UpdatePitch();
    }
  }

  [Serializable]
  public class Bus
  {
    public string name;
    public string path;
    public string volumeSettingsKey;
    [Range(0.0f, 2f)]
    public float volume = 1f;
    [Range(0.0f, 2f)]
    public float pitch = 1f;
    public FMOD.Studio.Bus bus;
    public ChannelGroup channelGroup;

    public void Init()
    {
      this.bus = RuntimeManager.GetBus(this.path);
      int num = (int) this.bus.lockChannelGroup();
      this.volume = Settings.Load<float>(this.volumeSettingsKey, 1f);
      this.UpdateVolume();
      this.UpdatePitch();
    }

    public void UpdateVolume()
    {
      int num = (int) this.bus.setVolume(this.volume);
    }

    public void UpdatePitch()
    {
      int channelGroup = (int) this.bus.getChannelGroup(out this.channelGroup);
      int num = (int) this.channelGroup.setPitch(this.pitch);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AvatarEyePositions
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public class AvatarEyePositions : MonoBehaviour
{
  public AvatarEyePositions.Eye[] eyes;

  [Serializable]
  public class Eye
  {
    public Vector3 pos;
    public Vector3 scale = new Vector3(2.12765956f, 2.12765956f, 1f);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AvatarPart
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class AvatarPart : MonoBehaviour
{
  [SerializeField]
  public AvatarPart.Anchor[] anchors;
  [SerializeField]
  public AvatarPart.Part[] parts;

  public Transform GetAnchor(string name) => ((IEnumerable<AvatarPart.Anchor>) this.anchors).FirstOrDefault<AvatarPart.Anchor>((Func<AvatarPart.Anchor, bool>) (a => a.name == name)).transform;

  public AvatarPart.Part Get(string name) => ((IEnumerable<AvatarPart.Part>) this.parts).FirstOrDefault<AvatarPart.Part>((Func<AvatarPart.Part, bool>) (a => a.name == name));

  [Serializable]
  public struct Anchor
  {
    public string name;
    public Transform transform;
  }

  [Serializable]
  public struct Part
  {
    public string name;
    public Image image;

    public void Disable()
    {
      if (!((UnityEngine.Object) this.image != (UnityEngine.Object) null))
        return;
      this.image.enabled = false;
    }

    public void Set(Sprite sprite, Vector2 scale)
    {
      if (!((UnityEngine.Object) this.image != (UnityEngine.Object) null))
        return;
      this.image.enabled = true;
      this.image.sprite = sprite;
      Transform transform = this.image.transform;
      transform.localScale = (Vector3) ((Vector2) transform.localScale * scale);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AvatarPoser
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class AvatarPoser : MonoBehaviour
{
  [SerializeField]
  public Image faceImage;
  [SerializeField]
  public Image bodyImage;
  [SerializeField]
  [Range(0.0f, 2f)]
  public float pingStrength = 1f;
  [SerializeField]
  public Vector2 poseTime = new Vector2(1.5f, 2f);
  [SerializeField]
  public AvatarPoser.Pose[] poses;
  public readonly Dictionary<string, AvatarPoser.Pose> poseLookup = new Dictionary<string, AvatarPoser.Pose>();
  public Sprite baseFaceSprite;
  public Sprite baseBodySprite;
  public Vector3 scale;
  public float reset;

  public void Awake()
  {
    this.scale = this.transform.localScale;
    this.poseLookup.Clear();
    foreach (AvatarPoser.Pose pose in this.poses)
      this.poseLookup[pose.name] = pose;
    if ((bool) (UnityEngine.Object) this.faceImage)
      this.baseFaceSprite = this.faceImage.sprite;
    if (!(bool) (UnityEngine.Object) this.bodyImage)
      return;
    this.baseBodySprite = this.bodyImage.sprite;
  }

  public void Update()
  {
    if ((double) this.reset <= 0.0)
      return;
    this.reset -= Time.deltaTime;
    if ((double) this.reset > 0.0)
      return;
    if ((bool) (UnityEngine.Object) this.faceImage)
      this.faceImage.sprite = this.baseFaceSprite;
    if ((bool) (UnityEngine.Object) this.bodyImage)
      this.bodyImage.sprite = this.baseBodySprite;
    this.Ping();
  }

  public void Set(string poseName)
  {
    AvatarPoser.Pose pose;
    if (!this.poseLookup.TryGetValue(poseName, out pose))
      return;
    if ((bool) (UnityEngine.Object) this.faceImage && pose.setFace)
      this.faceImage.sprite = pose.face[PettyRandom.Range(0, pose.face.Length - 1)];
    if ((bool) (UnityEngine.Object) this.bodyImage && pose.setBody)
      this.bodyImage.sprite = pose.body[PettyRandom.Range(0, pose.body.Length - 1)];
    this.reset = this.poseTime.PettyRandom();
    this.Ping();
  }

  public void Ping()
  {
    if ((double) this.pingStrength <= 0.0)
      return;
    LeanTween.cancel(this.gameObject);
    float num = (float) (1.0 + 0.05000000074505806 * (double) this.pingStrength);
    this.transform.localScale = new Vector3(num * this.scale.x, 1f / num * this.scale.y, this.scale.z);
    LeanTween.scale(this.gameObject, this.scale, 1f).setEase(LeanTweenType.easeOutElastic);
  }

  [Serializable]
  public struct Pose
  {
    public string name;
    public bool setFace;
    public Sprite[] face;
    public bool setBody;
    public Sprite[] body;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: AvatarPoseSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

public class AvatarPoseSetter : MonoBehaviour
{
  [SerializeField]
  public bool onAwake;
  [SerializeField]
  [HideIf("onAwake")]
  public bool onEnable = true;
  [SerializeField]
  public AvatarPoser poser;
  [SerializeField]
  public string[] poseOptions = new string[2]{ "", "Greet" };
  [SerializeField]
  public Vector2 delay = new Vector2(0.5f, 1.5f);

  public void Awake()
  {
    if (!this.onAwake)
      return;
    this.StartCoroutine(this.Run());
  }

  public void OnEnable()
  {
    if (this.onAwake || !this.onEnable)
      return;
    this.StartCoroutine(this.Run());
  }

  public void OnDisable() => this.StopAllCoroutines();

  public IEnumerator Run()
  {
    yield return (object) new WaitForSeconds(this.delay.PettyRandom());
    if ((bool) (Object) this.poser && this.poseOptions != null && this.poseOptions.Length != 0)
      this.poser.Set(this.poseOptions.RandomItem<string>());
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Axis
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Flags]
[Serializable]
public enum Axis
{
  All = 0,
  X = 2,
  Y = 4,
  Z = 8,
}
﻿// Decompiled with JetBrains decompiler
// Type: BackButtonGamePadController
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class BackButtonGamePadController : MonoBehaviour
{
  public static bool isGoingBack;
  public Button backButton;
  public EventTrigger eventTrigger;
  public UINavigationLayer uINavigationLayer;
  public UINavigationItem navigationItem;
  public UnityEvent OnBackButtonOverride;
  public const float backClearTime = 0.1f;
  public Coroutine GoingBackClear;
  public bool navItemEnabled;
  public bool press;

  public void Update()
  {
    if (this.navItemEnabled)
    {
      if (!this.CheckNavigationItem())
        this.navItemEnabled = false;
      else if (BackButtonGamePadController.isGoingBack)
      {
        if (this.GoingBackClear == null)
          this.GoingBackClear = this.StartCoroutine(this.RunGoBackClear());
        if (!this.press)
          return;
        this.press = false;
        this.Release();
      }
      else if ((Object) MonoBehaviourSingleton<UINavigationSystem>.instance.lastActiveNavigationLayer == (Object) this.uINavigationLayer && !MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      {
        if (this.press)
        {
          if (!InputSystem.Enabled || InputSystem.reset)
          {
            this.press = false;
            this.Release();
          }
          if (InputSystem.IsButtonHeld("Back"))
            return;
          this.Release();
        }
        else
        {
          if (!InputSystem.IsButtonPressed("Back"))
            return;
          this.Press();
        }
      }
      else
      {
        if (!this.press)
          return;
        this.press = false;
        this.Release();
      }
    }
    else
    {
      if (!this.CheckNavigationItem())
        return;
      this.navItemEnabled = true;
    }
  }

  public void Press()
  {
    this.press = true;
    if (!(bool) (Object) this.eventTrigger || !this.eventTrigger.enabled)
      return;
    this.eventTrigger.OnPointerDown((PointerEventData) null);
  }

  public void Release()
  {
    if (this.press)
      this.Invoke();
    if ((bool) (Object) this.eventTrigger)
    {
      if (this.press && this.eventTrigger.enabled)
        this.eventTrigger.OnPointerClick((PointerEventData) null);
      this.eventTrigger.OnPointerUp((PointerEventData) null);
    }
    this.press = false;
  }

  public void Invoke()
  {
    BackButtonGamePadController.isGoingBack = true;
    if (this.OnBackButtonOverride != null && this.OnBackButtonOverride.GetPersistentEventCount() > 0)
      this.OnBackButtonOverride.Invoke();
    else
      this.backButton.onClick.Invoke();
  }

  public IEnumerator RunGoBackClear()
  {
    yield return (object) new WaitForSecondsRealtime(0.1f);
    BackButtonGamePadController.isGoingBack = false;
    this.GoingBackClear = (Coroutine) null;
  }

  public void Start() => this.CheckForNavigationLayer(this.transform);

  public void CheckForNavigationLayer(Transform checkTransform)
  {
    UINavigationLayer component = checkTransform.GetComponent<UINavigationLayer>();
    if (component != null && component.isOverrideLayer)
      this.uINavigationLayer = component;
    if (!((Object) this.uINavigationLayer == (Object) null) || !((Object) checkTransform.transform.parent != (Object) null))
      return;
    this.CheckForNavigationLayer(checkTransform.transform.parent);
  }

  public bool CheckNavigationItem() => !(bool) (Object) this.navigationItem || MonoBehaviourSingleton<UINavigationSystem>.instance.AvailableNavigationItems.Contains(this.navigationItem);
}
﻿// Decompiled with JetBrains decompiler
// Type: BalloonSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;

public class BalloonSequence : BuildingSequence
{
  [SerializeField]
  public RectTransform panel;
  [SerializeField]
  public TMP_Text title;
  [SerializeField]
  public TMP_Text date;
  [SerializeField]
  public LocalizedString titleKey;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public DeckDisplayGroup deckDisplayGroup;
  [SerializeField]
  public DailyGenerator dailyGenerator;
  [SerializeField]
  public GameMode gameMode;
  [SerializeField]
  public GameObject playButton;
  [SerializeField]
  public GameObject scoresButton;
  [SerializeField]
  public GameObject timer;
  [SerializeField]
  public HelpPanelShower noConnection;
  [SerializeField]
  public ModifierDisplay modifierDisplay;
  [SerializeField]
  public Scroller scroller;
  [SerializeField]
  public GameObject loadingIcon;
  [SerializeField]
  public HelpPanelShower firstTimeHelp;
  public int seed;
  public bool loading;

  public void OnDisable() => DailyFetcher.CancelFetch();

  public override IEnumerator Sequence()
  {
    BalloonSequence balloonSequence = this;
    balloonSequence.panel.anchoredPosition = new Vector2(-10f, 0.0f);
    balloonSequence.playButton.SetActive(false);
    balloonSequence.scoresButton.SetActive(false);
    balloonSequence.loadingIcon.SetActive(true);
    yield return (object) DailyFetcher.FetchDateTime();
    if (!DailyFetcher.fetched)
    {
      balloonSequence.noConnection.Show();
      balloonSequence.noConnection.AddButton(0, HelpPanelSystem.ButtonType.Positive, new UnityAction(balloonSequence.Close));
    }
    else
    {
      balloonSequence.loadingIcon.SetActive(false);
      balloonSequence.panel.LeanMove(new Vector3(-0.7f, 0.0f), 1.2f).setFrom(new Vector3(-2.5f, 0.0f)).setEaseOutElastic();
      bool flag = DailyFetcher.CanPlay();
      balloonSequence.playButton.SetActive(flag);
      balloonSequence.timer.SetActive(!flag);
      balloonSequence.scoresButton.SetActive(true);
      balloonSequence.seed = DailyFetcher.GetSeed();
      string localizedString = balloonSequence.titleKey.GetLocalizedString();
      balloonSequence.title.text = localizedString;
      DateTime dateTime = DailyFetcher.GetDateTime();
      Debug.Log((object) string.Format("DailyFetcher → Daily Time: {0}", (object) dateTime));
      CultureInfo cultureInfo = LocalizationSettings.SelectedLocale.Identifier.CultureInfo;
      balloonSequence.date.text = dateTime.ToString("D", (IFormatProvider) cultureInfo);
      yield return (object) balloonSequence.dailyGenerator.Run(balloonSequence.seed, balloonSequence.gameMode);
      List<GameModifierData> modifiers = Campaign.Data.Modifiers;
      if (modifiers != null && modifiers.Count > 0)
      {
        foreach (GameModifierData modifier in Campaign.Data.Modifiers)
          balloonSequence.modifierDisplay.CreateIcon(modifier);
      }
      yield return (object) balloonSequence.CreateCards((IEnumerable<CardData>) References.PlayerData.inventory.deck);
      if (!SaveSystem.LoadProgressData<bool>("dailyRunHelpSeen", false))
      {
        balloonSequence.firstTimeHelp.Show();
        SaveSystem.SaveProgressData<bool>("dailyRunHelpSeen", true);
      }
    }
  }

  public IEnumerator CreateCards(IEnumerable<CardData> cardsToCreate)
  {
    List<Card> cardList = new List<Card>();
    Routine.Clump clump = new Routine.Clump();
    foreach (CardData data in cardsToCreate)
    {
      Card card = CardManager.Get(data, this.cardController, (Character) null, false, true);
      cardList.Add(card);
      card.entity.flipper.FlipDownInstant();
      clump.Add(BalloonSequence.UpdateCardData(card));
    }
    foreach (Card card in cardList)
      this.deckDisplayGroup.AddCard(card);
    yield return (object) clump.WaitForEnd();
    yield return (object) null;
    this.deckDisplayGroup.UpdatePositions();
    if ((bool) (UnityEngine.Object) this.scroller)
      this.scroller.ScrollImmediate(10f);
  }

  public static IEnumerator UpdateCardData(Card card)
  {
    yield return (object) card.UpdateData(false);
    card.entity.flipper.FlipUp(true);
  }

  public void Continue()
  {
    if (!this.enabled)
      return;
    this.enabled = false;
    SaveSystem.SaveProgressData<string>("dailyPlayed", DailyFetcher.GetDateTime().ToString());
    Campaign.Begin();
    Routine routine = new Routine(Transition.To("Campaign"));
  }

  public new void Close() => UnityEngine.Object.FindObjectOfType<BuildingDisplay>()?.End();
}
﻿// Decompiled with JetBrains decompiler
// Type: BaseInputSwitcher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class BaseInputSwitcher : MonoBehaviour
{
  public bool canSwitchTo = true;

  public virtual bool CheckSwitchTo() => false;

  public virtual void SwitchTo()
  {
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Battle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Pool;

public class Battle : SceneRoutine
{
  public static Battle instance;
  public Character player;
  public Character enemy;
  public Character winner;
  public readonly List<Entity> minibosses = new List<Entity>();
  public Battle.Phase _phase;
  public Transform outOfUseCardsGroup;
  public CardController playerCardController;
  public readonly Dictionary<Character, List<CardContainer>> rows = new Dictionary<Character, List<CardContainer>>();
  public readonly Dictionary<CardContainer, int> rowIndices = new Dictionary<CardContainer, int>();
  public List<Entity> cards = new List<Entity>();
  public float startDelay = 1f;
  public bool canEnd = true;
  public int rowCount;
  public int turnCount;
  public bool cancelTurn;
  public bool auto;
  public bool loadMidBattle;

  public void Awake()
  {
    Battle.instance = this;
    References.Battle = this;
  }

  public int playerMinibossCount => this.minibosses.Count<Entity>((Func<Entity, bool>) (a => (bool) (UnityEngine.Object) a && (UnityEngine.Object) a.owner == (UnityEngine.Object) this.player));

  public int enemyMinibossCount => this.minibosses.Count<Entity>((Func<Entity, bool>) (a => (bool) (UnityEngine.Object) a && (UnityEngine.Object) a.owner == (UnityEngine.Object) this.enemy));

  public Battle.Phase phase
  {
    get => this._phase;
    set
    {
      if (this._phase == value || this.ended)
        return;
      Debug.Log((object) string.Format("Battle Phase: {0}", (object) value));
      global::Events.InvokeBattlePhaseStart(value);
      this._phase = value;
    }
  }

  public IEnumerable<CardSlotLane> allRows => this.rows.Values.SelectMany<List<CardContainer>, CardContainer>((Func<List<CardContainer>, IEnumerable<CardContainer>>) (a => (IEnumerable<CardContainer>) a)).Cast<CardSlotLane>();

  public IEnumerable<CardSlot> allSlots => this.allRows.SelectMany<CardSlotLane, CardSlot>((Func<CardSlotLane, IEnumerable<CardSlot>>) (a => (IEnumerable<CardSlot>) a.slots));

  public bool ended => this.phase == Battle.Phase.End;

  [Button("Win", EButtonEnableMode.Always)]
  public void PlayerWin()
  {
    this.winner = this.player;
    this.phase = Battle.Phase.End;
  }

  [Button("Lose", EButtonEnableMode.Always)]
  public void EnemyWin()
  {
    this.winner = this.enemy;
    this.phase = Battle.Phase.End;
  }

  public void Start()
  {
    global::Events.OnEntityCreated += new UnityAction<Entity>(this.EntityCreated);
    global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnEntityDestroyed += new UnityAction<Entity>(this.EntityDestroyed);
  }

  public void OnDestroy()
  {
    global::Events.OnEntityCreated -= new UnityAction<Entity>(this.EntityCreated);
    global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnEntityDestroyed -= new UnityAction<Entity>(this.EntityDestroyed);
  }

  public void EntityCreated(Entity entity)
  {
    if (entity.data.cardType.miniboss)
      this.minibosses.Add(entity);
    this.cards.Add(entity);
  }

  public void CancelTurn() => this.cancelTurn = true;

  public void EntityDestroyed(Entity entity) => this.EntityKilled(entity, DeathType.Normal);

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    if (this.minibosses.Remove(entity) && this.phase != Battle.Phase.LastStand)
      this.CheckEnd();
    this.cards.Remove(entity);
  }

  public bool CheckEnd()
  {
    if (!this.canEnd)
      return false;
    if (this.playerMinibossCount <= 0)
    {
      this.winner = this.enemy;
      this.phase = Battle.Phase.End;
      return true;
    }
    if (this.enemyMinibossCount > 0)
      return false;
    this.winner = this.player;
    this.phase = Battle.Phase.End;
    return true;
  }

  public static Character GetOpponent(Character character)
  {
    if ((UnityEngine.Object) character == (UnityEngine.Object) Battle.instance.enemy)
      return Battle.instance.player;
    return !((UnityEngine.Object) character == (UnityEngine.Object) Battle.instance.player) ? (Character) null : Battle.instance.enemy;
  }

  public int GetRowIndex(CardContainer rowContainer) => !(bool) (UnityEngine.Object) rowContainer ? -1 : this.rows[rowContainer.owner].IndexOf(rowContainer);

  public int[] GetRowIndices(Entity entity)
  {
    List<int> toRelease = GenericPool<List<int>>.Get();
    toRelease.Clear();
    if ((bool) (UnityEngine.Object) entity.owner)
    {
      List<CardContainer> row = this.rows[entity.owner];
      for (int index = 0; index < this.rowCount; ++index)
      {
        if (row[index].Contains(entity))
          toRelease.Add(index);
      }
    }
    int[] array = toRelease.ToArray();
    GenericPool<List<int>>.Release(toRelease);
    return array;
  }

  public int[] GetRowIndices(IEnumerable<CardContainer> containers)
  {
    HashSet<int> intSet = GenericPool<HashSet<int>>.Get();
    intSet.Clear();
    foreach (CardContainer container in containers)
    {
      int num;
      if (this.rowIndices.TryGetValue(container, out num))
        intSet.Add(num);
    }
    int[] array = intSet.ToArray<int>();
    GenericPool<HashSet<int>>.Release(intSet);
    return array;
  }

  public CardContainer GetRow(Character owner, int rowIndex) => this.rows[owner][rowIndex];

  public List<CardContainer> GetRows(Character owner)
  {
    List<CardContainer> row = this.rows[owner];
    List<CardContainer> rows = new List<CardContainer>();
    foreach (CardContainer cardContainer in row)
      rows.Add(cardContainer);
    return rows;
  }

  public CardSlotLane GetOppositeRow(CardSlotLane row)
  {
    int rowIndex = this.GetRowIndex((CardContainer) row);
    if (rowIndex >= 0)
    {
      Character opponent = Battle.GetOpponent(row.owner);
      if ((bool) (UnityEngine.Object) opponent && this.GetRow(opponent, rowIndex) is CardSlotLane row1)
        return row1;
    }
    return (CardSlotLane) null;
  }

  public CardContainer[] GetOppositeRows(CardContainer[] rows)
  {
    CardContainer[] oppositeRows = new CardContainer[rows.Length];
    int num = 0;
    Character owner = (Character) null;
    foreach (CardContainer row1 in rows)
    {
      int rowIndex = this.GetRowIndex(row1);
      if (rowIndex >= 0)
      {
        if (owner == null)
          owner = Battle.GetOpponent(row1.owner);
        if ((bool) (UnityEngine.Object) owner)
        {
          CardContainer row2 = this.GetRow(owner, rowIndex);
          if (row2 != null)
            oppositeRows[num++] = row2;
        }
      }
    }
    return oppositeRows;
  }

  public List<CardSlot> GetSlots()
  {
    List<CardSlot> slots = new List<CardSlot>();
    foreach (CardContainer cardContainer in this.rows.Values.SelectMany<List<CardContainer>, CardContainer>((Func<List<CardContainer>, IEnumerable<CardContainer>>) (a => (IEnumerable<CardContainer>) a)))
    {
      if (cardContainer is CardSlotLane cardSlotLane)
        slots.AddRange((IEnumerable<CardSlot>) cardSlotLane.slots);
    }
    return slots;
  }

  public List<CardSlot> GetSlots(Character owner)
  {
    List<CardContainer> row = this.rows[owner];
    List<CardSlot> slots = new List<CardSlot>();
    foreach (CardContainer cardContainer in row)
    {
      if (cardContainer is CardSlotLane cardSlotLane)
        slots.AddRange((IEnumerable<CardSlot>) cardSlotLane.slots);
    }
    return slots;
  }

  public static List<Entity> GetCards(Character character)
  {
    List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(character);
    List<CardContainer> list = new List<CardContainer>();
    list.AddIfNotNull<CardContainer>(character.reserveContainer);
    list.AddIfNotNull<CardContainer>(character.handContainer);
    list.AddIfNotNull<CardContainer>(character.drawContainer);
    list.AddIfNotNull<CardContainer>(character.discardContainer);
    foreach (CardContainer cardContainer in list)
    {
      foreach (Entity entity in cardContainer)
        cardsOnBoard.Add(entity);
    }
    return cardsOnBoard;
  }

  public static List<Entity> GetAllCards()
  {
    List<Entity> allCards = new List<Entity>();
    allCards.AddRange((IEnumerable<Entity>) Battle.GetCards(Battle.instance.player));
    allCards.AddRange((IEnumerable<Entity>) Battle.GetCards(Battle.instance.enemy));
    return allCards;
  }

  public static List<Entity> GetCardsOnBoard()
  {
    List<Entity> cardsOnBoard = new List<Entity>();
    cardsOnBoard.AddRange((IEnumerable<Entity>) Battle.GetCardsOnBoard(Battle.instance.player));
    cardsOnBoard.AddRange((IEnumerable<Entity>) Battle.GetCardsOnBoard(Battle.instance.enemy));
    return cardsOnBoard;
  }

  public static List<Entity> GetCardsOnBoard(Character character)
  {
    List<Entity> cardsOnBoard = new List<Entity>();
    int num1 = 2;
    int num2 = 3;
    for (int index = 0; index < num2; ++index)
    {
      for (int rowIndex = 0; rowIndex < num1; ++rowIndex)
      {
        if (Battle.instance.GetRow(character, rowIndex) is CardSlotLane row)
        {
          Entity top = row.slots[index].GetTop();
          if (top != null && !cardsOnBoard.Contains(top))
            cardsOnBoard.Add(top);
        }
      }
    }
    return cardsOnBoard;
  }

  public static bool IsOnBoard(Entity entity)
  {
    List<CardContainer> row = Battle.instance.rows[entity.owner];
    if (row.ContainsAny<CardContainer>((IEnumerable<CardContainer>) entity.containers))
      return true;
    return !entity.alive && entity.preContainers != null && ((IList<CardContainer>) entity.preContainers).ContainsAny<CardContainer>((IEnumerable<CardContainer>) row);
  }

  public static bool IsOnBoard(CardContainer[] containers)
  {
    foreach (CardContainer container in containers)
    {
      if (Battle.instance.GetRowIndex(container.Group) >= 0)
        return true;
    }
    return false;
  }

  public static bool IsOnBoard(CardContainer container) => Battle.instance.GetRowIndex(container) >= 0;

  public override IEnumerator Run()
  {
    CampaignNode node = Campaign.FindCharacterNode(this.player);
    NavigationState.Start((INavigationState) new NavigationStateBattle());
    NavigationState.Start((INavigationState) new NavigationStateWait());
    if (!this.loadMidBattle)
    {
      this.phase = Battle.Phase.Init;
      yield return (object) Sequences.Wait(this.startDelay);
      yield return (object) ActionQueue.Wait();
      Debug.Log((object) "BATTLE START!");
      global::Events.InvokeBattleStart();
      yield return (object) this.DrawChampions(this.player, this.player.drawContainer, this.player.handContainer);
      Battle.SetSeed(node.seed - 9999, 0);
      NavigationState.BackToPreviousState();
      yield return (object) this.WaitForChampionsToDeploy(this.player, this.playerCardController, this.player.handContainer);
      NavigationState.Start((INavigationState) new NavigationStateWait());
      global::Events.InvokeBattleTurnEnd(this.turnCount);
      ActionQueue.Add((PlayAction) new ActionDrawHand(this.player));
      yield return (object) ActionQueue.Wait();
    }
    yield return (object) this.BattleLoop(node);
    Debug.Log((object) "BATTLE END!");
    global::Events.InvokeBattleEnd();
    NavigationState.Reset();
    if ((bool) (UnityEngine.Object) this.playerCardController)
      this.playerCardController.Disable();
    List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(Battle.GetOpponent(this.winner));
    if (cardsOnBoard.Count > 0)
    {
      Debug.Log((object) string.Format("[{0}] Cards To Flee!", (object) cardsOnBoard.Count));
      foreach (Entity entity in cardsOnBoard)
        ActionQueue.Stack((PlayAction) new ActionFlee(entity));
      yield return (object) ActionQueue.Wait();
    }
    yield return (object) global::Events.InvokePreBattleEnd();
    if (Campaign.CheckVictory() || (UnityEngine.Object) this.winner != (UnityEngine.Object) this.player)
    {
      if ((UnityEngine.Object) this.winner != (UnityEngine.Object) this.player)
      {
        if (Settings.Load<bool>("showJournalNameOnEnd", false))
          yield return (object) JournalVoidNameSequence.LoadAndRun(true);
        else
          JournalNameHistory.MostRecentNameKilled();
      }
      yield return (object) SceneManager.Load("CampaignEnd", SceneType.Temporary);
      yield return (object) SceneManager.WaitUntilUnloaded("CampaignEnd");
    }
    else if ((UnityEngine.Object) this.winner == (UnityEngine.Object) this.player)
    {
      global::Events.InvokeBattleWinPreRewards();
      yield return (object) ActionQueue.Wait();
      if (node.data.ContainsKey("rewards"))
      {
        yield return (object) SceneManager.Load("BossReward", SceneType.Temporary);
        yield return (object) SceneManager.WaitUntilUnloaded("BossReward");
      }
      global::Events.InvokeBattleWin();
      yield return (object) ActionQueue.Wait();
      yield return (object) SceneManager.Load("BattleWin", SceneType.Temporary);
      yield return (object) UnityEngine.Object.FindObjectOfType<BattleVictorySequence>().Run();
    }
  }

  public IEnumerator BattleLoop(CampaignNode node)
  {
    while (!this.ended)
    {
      if (Deckpack.IsOpen)
        yield return (object) Battle.WaitForDeckpack();
      yield return (object) this.UpdateBoard(this.enemy);
      if (Deckpack.IsOpen)
        yield return (object) Battle.WaitForDeckpack();
      yield return (object) this.UpdateBoard(this.player);
      if (Deckpack.IsOpen)
        yield return (object) Battle.WaitForDeckpack();
      yield return (object) this.UpdateContainer(this.player.handContainer);
      if (!this.ended)
      {
        Battle.SetSeed(node.seed, this.turnCount);
        if (!this.auto)
        {
          this.cancelTurn = false;
          this.phase = Battle.Phase.Play;
        }
        yield return (object) ActionQueue.Wait();
        global::Events.InvokeBattlePreTurnStart(this.turnCount);
        ++this.turnCount;
        NavigationState.BackToPreviousState();
        if (!this.auto)
        {
          this.playerCardController.Enable();
          yield return (object) this.WaitForTurnEnd(this.player, this.playerCardController);
        }
        NavigationState.Start((INavigationState) new NavigationStateWait());
        global::Events.InvokeBattleTurnStart(this.turnCount);
        if (Deckpack.IsOpen)
          yield return (object) Battle.WaitForDeckpack();
        this.phase = Battle.Phase.Battle;
        if (!this.auto)
          yield return (object) Sequences.Wait(0.5f);
        yield return (object) this.CheckUnitsTakeTurns();
        yield return (object) ActionQueue.Wait();
        yield return (object) this.ProcessHandStart(this.player);
        if (!this.ended)
        {
          yield return (object) this.CheckUnitsTakeTurns();
          yield return (object) this.ProcessUnits(this.enemy);
          yield return (object) this.ProcessUnits(this.player);
          yield return (object) this.CheckUnitsTakeTurns();
          yield return (object) this.ProcessUnitTurnEnd();
          yield return (object) this.CheckUnitsTakeTurns();
          yield return (object) this.ProcessHandEnd(this.player);
          yield return (object) this.CheckUnitsTakeTurns();
        }
        yield return (object) this.CheckUnitsTakeTurns();
        global::Events.InvokeBattleTurnEnd(this.turnCount);
      }
    }
  }

  public static void SetSeed(int baseSeed, int offset)
  {
    Debug.Log((object) string.Format("Battle Setting Seed: {0} Offset: {1}", (object) baseSeed, (object) offset));
    UnityEngine.Random.InitState(baseSeed);
    for (int index = 0; index < offset; ++index)
    {
      double num = (double) UnityEngine.Random.Range(0.0f, 1f);
    }
  }

  public static IEnumerator WaitForDeckpack()
  {
    yield return (object) new WaitUntil((Func<bool>) (() => !Deckpack.IsOpen));
    yield return (object) new WaitForSeconds(0.5f);
  }

  public IEnumerator WaitForTurnEnd(Character character, CardController cardController)
  {
    while (!this.ended && !this.auto)
    {
      yield return (object) ActionQueue.Wait();
      if (character.endTurn)
      {
        if (!character.freeAction)
          this.phase = Battle.Phase.Battle;
        yield return (object) this.CheckUnitsTakeTurns(this.enemy);
        yield return (object) this.CheckUnitsTakeTurns(this.player);
        yield return (object) this.UpdateBoard(this.enemy);
        yield return (object) this.UpdateBoard(this.player);
        global::Events.InvokeCharacterActionPerformed(character);
        if (character.freeAction)
        {
          character.freeAction = false;
          character.endTurn = false;
          cardController.Enable();
          character.handContainer.TweenChildPositions();
          this.phase = Battle.Phase.Play;
        }
        else
        {
          character.endTurn = false;
          break;
        }
      }
      yield return (object) ActionQueue.Wait();
    }
    cardController.Disable();
  }

  public IEnumerator DrawChampions(
    Character character,
    CardContainer fromContainer,
    CardContainer toContainer)
  {
    Battle battle = this;
    float pauseBetween = 0.1f;
    for (int i = fromContainer.Count - 1; i >= 0; --i)
    {
      Entity entity = fromContainer[i];
      if (entity.data.HasCrown)
      {
        if ((bool) (UnityEngine.Object) entity)
        {
          battle.StartCoroutine(Sequences.CardMove(entity, new CardContainer[1]
          {
            toContainer
          }));
          toContainer.TweenChildPositions();
        }
        yield return (object) Sequences.Wait(pauseBetween);
      }
    }
    ActionQueue.Stack((PlayAction) new ActionRevealAll(new CardContainer[1]
    {
      toContainer
    }));
    yield return (object) ActionQueue.Wait();
  }

  public IEnumerator WaitForChampionsToDeploy(
    Character character,
    CardController cardController,
    CardContainer handContainer)
  {
    if (Battle.CrownCardsInContainer(handContainer) > 0)
    {
      cardController.Enable();
      while (!this.ended)
      {
        if (character.endTurn)
        {
          yield return (object) null;
          character.endTurn = false;
          Routine.Clump clump = new Routine.Clump();
          clump.Add(this.UpdateBoard(this.enemy));
          clump.Add(this.UpdateBoard(this.player));
          clump.Add(this.UpdateContainer(this.player.handContainer));
          yield return (object) clump.WaitForEnd();
          if (Battle.CrownCardsInContainer(handContainer) > 0)
            cardController.Enable();
          else
            break;
        }
        yield return (object) null;
      }
      character.freeAction = false;
    }
  }

  public static int CrownCardsInContainer(CardContainer container) => container.Count<Entity>((Func<Entity, bool>) (a => a.data.HasCrown));

  public IEnumerator UpdateBoard(Character character)
  {
    float seconds = 0.0f;
    foreach (CardContainer row in this.GetRows(character))
    {
      row.MoveChildrenForward();
      row.TweenChildPositions();
    }
    yield return (object) Sequences.Wait(seconds);
  }

  public bool CanDeploy(Entity entity, int targetRow, out int targetColumn)
  {
    targetColumn = 0;
    bool flag1 = false;
    List<CardContainer> rows = this.GetRows(entity.owner);
    int a = int.MaxValue;
    foreach (CardContainer cardContainer in rows)
      a = Mathf.Min(a, cardContainer.max);
    if (entity.positionPriority >= 0)
    {
      for (int index1 = 0; index1 < a; ++index1)
      {
        bool flag2 = false;
        for (int index2 = 0; index2 < entity.height; ++index2)
        {
          CardContainer cardContainer = rows[(targetRow + index2) % rows.Count];
          if (cardContainer is CardSlotLane cardSlotLane && cardContainer.canBePlacedOn)
          {
            CardSlot slot = cardSlotLane.slots[index1];
            if (slot.canBePlacedOn)
            {
              Entity top1 = slot.GetTop();
              if ((UnityEngine.Object) top1 == (UnityEngine.Object) null)
                flag2 = true;
              else if ((top1.positionPriority < entity.positionPriority || entity.positionPriority > 1 && top1.positionPriority <= entity.positionPriority) && Battle.CanPushBack(top1))
              {
                bool flag3 = true;
                for (int index3 = index1 + 1; index3 < cardSlotLane.max; ++index3)
                {
                  Entity top2 = cardSlotLane.slots[index3].GetTop();
                  if ((bool) (UnityEngine.Object) top2 && top2.positionPriority >= entity.positionPriority)
                  {
                    flag3 = false;
                    break;
                  }
                }
                if (flag3)
                  flag2 = true;
              }
            }
          }
        }
        if (flag2)
        {
          flag1 = true;
          targetColumn = index1;
          break;
        }
      }
    }
    else
    {
      for (int index4 = a - 1; index4 >= 0; --index4)
      {
        bool flag4 = true;
        for (int index5 = 0; index5 < entity.height; ++index5)
        {
          if (rows[(targetRow + index5) % rows.Count] is CardSlotLane cardSlotLane)
          {
            Entity top = cardSlotLane.slots[index4].GetTop();
            if ((bool) (UnityEngine.Object) top && (top.positionPriority > entity.positionPriority || !Battle.CanPushForwards(top)))
              flag4 = false;
          }
        }
        if (flag4)
        {
          flag1 = true;
          targetColumn = index4;
          break;
        }
      }
    }
    return flag1;
  }

  public static bool CanPushBack(Entity entity)
  {
    bool flag = true;
    foreach (CardContainer container in entity.containers)
    {
      if (container is CardSlotLane cardSlotLane)
      {
        int index = cardSlotLane.IndexOf(entity) + 1;
        CardSlot slot = index < cardSlotLane.max ? cardSlotLane.slots[index] : (CardSlot) null;
        if ((UnityEngine.Object) slot == (UnityEngine.Object) null)
        {
          flag = false;
          break;
        }
        Entity top = slot.GetTop();
        if ((bool) (UnityEngine.Object) top && !Battle.CanPushBack(top))
        {
          flag = false;
          break;
        }
      }
    }
    return flag;
  }

  public static bool CanPushForwards(Entity entity)
  {
    bool flag = true;
    foreach (CardContainer container in entity.containers)
    {
      if (container is CardSlotLane cardSlotLane)
      {
        int index = cardSlotLane.IndexOf(entity) - 1;
        CardSlot slot = index >= 0 ? cardSlotLane.slots[index] : (CardSlot) null;
        if ((UnityEngine.Object) slot == (UnityEngine.Object) null || !slot.Empty)
        {
          flag = false;
          break;
        }
      }
    }
    return flag;
  }

  public IEnumerator UpdateContainer(CardContainer container)
  {
    float seconds = 0.0f;
    container.TweenChildPositions();
    yield return (object) Sequences.Wait(seconds);
  }

  public IEnumerator CheckUnitsTakeTurns()
  {
    if (!this.cancelTurn)
    {
      yield return (object) this.CheckUnitsTakeTurns(this.enemy);
      if (!this.cancelTurn)
        yield return (object) this.CheckUnitsTakeTurns(this.player);
    }
  }

  public IEnumerator CheckUnitsTakeTurns(Character character)
  {
    float pauseAfter = 0.167f;
    List<CardContainer> rows = this.GetRows(character);
    List<Entity> entityList = new List<Entity>();
    foreach (CardContainer cardContainer in rows)
    {
      for (int index = 0; index < cardContainer.Count; ++index)
        entityList.Add(cardContainer[index]);
    }
    foreach (Entity entity in entityList)
    {
      Entity unit = entity;
      if (!this.cancelTurn)
      {
        if (unit.counter.current <= 0 && unit.counter.max > 0 && !unit.IsSnowed && unit.alive && unit.owner.autoTriggerUnits)
        {
          ActionTriggerByCounter triggerAction = new ActionTriggerByCounter(unit, unit);
          if (Deckpack.IsOpen)
            yield return (object) Battle.WaitForDeckpack();
          if (global::Events.CheckAction((PlayAction) triggerAction))
          {
            ActionQueue.Add((PlayAction) triggerAction);
            yield return (object) ActionQueue.Wait();
            yield return (object) Sequences.Wait(pauseAfter);
          }
          unit.counter.current = unit.counter.max;
          unit.PromptUpdate();
          triggerAction = (ActionTriggerByCounter) null;
        }
        unit = (Entity) null;
      }
      else
        break;
    }
  }

  public IEnumerator ProcessUnits(Character character)
  {
    List<Entity> processed = new List<Entity>();
    global::Events.InvokePreProcessUnits(character);
label_1:
    bool dirty = false;
    List<Entity> list = Battle.GetAllUnits(character).ToList<Entity>();
    list.RemoveMany<Entity>((ICollection<Entity>) processed);
    Dictionary<Entity, CardContainer[]> positions = list.ToDictionary<Entity, Entity, CardContainer[]>((Func<Entity, Entity>) (e => e), (Func<Entity, CardContainer[]>) (e => e.actualContainers.ToArray()));
    foreach (Entity entity1 in list)
    {
      Entity entity = entity1;
      if (!entity.IsAliveAndExists())
      {
        dirty = true;
        Debug.Log((object) "BATTLE PROCESS LIST DIRTIED! An entity in the list no longer exists");
        break;
      }
      CardContainer[] array = entity.actualContainers.ToArray();
      if (!positions.ContainsKey(entity) || !((IList<CardContainer>) positions[entity]).ContainsAll<CardContainer>((IEnumerable<CardContainer>) array))
      {
        dirty = true;
        Debug.Log((object) string.Format("BATTLE PROCESS LIST DIRTIED! [{0}] was expected at [{1}], but was actually at [{2}]", (object) entity.name, (object) positions[entity], (object) array));
        break;
      }
      if (this.minibosses.Count<Entity>((Func<Entity, bool>) (a => a.owner.team == entity.owner.team)) <= 0)
      {
        Debug.Log((object) (entity.name + "'s Leader No Longer Exists! Skipping Processing..."));
      }
      else
      {
        yield return (object) this.ProcessUnit(entity);
        processed.Add(entity);
        if (!this.cancelTurn)
          ;
        else
          break;
      }
    }
    positions = (Dictionary<Entity, CardContainer[]>) null;
    if (!dirty || this.cancelTurn)
      global::Events.InvokePostProcessUnits(character);
    else
      goto label_1;
  }

  public static HashSet<Entity> GetAllUnits(Character character)
  {
    HashSet<Entity> list = new HashSet<Entity>();
    list.AddRange<Entity>((IEnumerable<Entity>) Battle.GetCardsOnBoard(character));
    if ((bool) (UnityEngine.Object) character.entity && character.entity.alive && character.entity.canBeHit)
      list.Add(character.entity);
    return list;
  }

  public static HashSet<Entity> GetAllUnits()
  {
    HashSet<Entity> list = new HashSet<Entity>();
    Character[] characterArray = new Character[2]
    {
      Battle.instance.enemy,
      Battle.instance.player
    };
    foreach (Character character in characterArray)
      list.AddRange<Entity>((IEnumerable<Entity>) Battle.GetAllUnits(character));
    return list;
  }

  public IEnumerator ProcessUnit(Entity unit)
  {
    float pauseAfter = 0.133f;
    if (Deckpack.IsOpen)
      yield return (object) Battle.WaitForDeckpack();
    bool snowed = unit.IsSnowed;
    yield return (object) StatusEffectSystem.TurnStartEvent(unit);
    if (unit.counter.max > 0 | snowed && unit.alive)
    {
      yield return (object) Battle.CardCountDown(unit);
      if (unit.counter.current <= 0 && unit.counter.max > 0 && !snowed && unit.owner.autoTriggerUnits)
      {
        ActionTriggerByCounter action = new ActionTriggerByCounter(unit, unit);
        if (global::Events.CheckAction((PlayAction) action))
        {
          ActionQueue.Add((PlayAction) action);
          yield return (object) ActionQueue.Wait();
          if (this.cancelTurn)
            yield break;
        }
        unit.counter.current = unit.counter.max;
        unit.PromptUpdate();
      }
      Routine.Clump clump = new Routine.Clump();
      clump.Add(StatusEffectSystem.TurnEvent(unit));
      clump.Add(Sequences.Wait(pauseAfter));
      yield return (object) clump.WaitForEnd();
    }
    else
      yield return (object) StatusEffectSystem.TurnEvent(unit);
    if (StatusEffectSystem.EventsRunning)
      yield return (object) Sequences.WaitForStatusEffectEvents();
  }

  public IEnumerator ProcessHandStart(Character character)
  {
    if (!this.cancelTurn)
    {
      Entity entity;
      foreach (Entity entity1 in character.handContainer)
      {
        entity = entity1;
        if (Deckpack.IsOpen)
          yield return (object) Battle.WaitForDeckpack();
        yield return (object) StatusEffectSystem.TurnStartEvent(entity);
        if (!this.cancelTurn)
          entity = (Entity) null;
        else
          break;
      }
      foreach (Entity entity2 in character.handContainer)
      {
        entity = entity2;
        if (Deckpack.IsOpen)
          yield return (object) Battle.WaitForDeckpack();
        yield return (object) StatusEffectSystem.TurnEvent(entity);
        if (!this.cancelTurn)
          entity = (Entity) null;
        else
          break;
      }
    }
  }

  public IEnumerator ProcessHandEnd(Character character)
  {
    if (!this.cancelTurn)
    {
      foreach (Entity entity1 in character.handContainer)
      {
        Entity entity = entity1;
        if (Deckpack.IsOpen)
          yield return (object) Battle.WaitForDeckpack();
        yield return (object) StatusEffectSystem.TurnEndEvent(entity);
        if (!this.cancelTurn)
          entity = (Entity) null;
        else
          break;
      }
    }
  }

  public IEnumerator ProcessUnitTurnEnd()
  {
    if (!this.cancelTurn)
    {
      HashSet<Entity> list = new HashSet<Entity>();
      Character[] characterArray = new Character[2]
      {
        this.enemy,
        this.player
      };
      foreach (Character character in characterArray)
      {
        list.AddRange<Entity>((IEnumerable<Entity>) Battle.GetCardsOnBoard(character));
        if ((bool) (UnityEngine.Object) character.entity && character.entity.alive)
          list.Add(character.entity);
      }
      foreach (Entity entity in list)
      {
        Entity unit = entity;
        if (Deckpack.IsOpen)
          yield return (object) Battle.WaitForDeckpack();
        ActionQueue.Stack((PlayAction) new ActionSequence(StatusEffectSystem.TurnEndEvent(unit)), true);
        yield return (object) ActionQueue.Wait();
        if (!this.cancelTurn)
          unit = (Entity) null;
        else
          break;
      }
    }
  }

  public static IEnumerator CardCountDown(Entity entity)
  {
    if (Deckpack.IsOpen)
      yield return (object) Battle.WaitForDeckpack();
    int amount = 1;
    global::Events.InvokeEntityCountDown(entity, ref amount);
    yield return (object) new Hit((Entity) null, entity)
    {
      counterReduction = amount,
      screenShake = 0.0f
    }.Process();
  }

  [CompilerGenerated]
  public bool \u003Cget_playerMinibossCount\u003Eb__8_0(Entity a) => (bool) (UnityEngine.Object) a && (UnityEngine.Object) a.owner == (UnityEngine.Object) this.player;

  [CompilerGenerated]
  public bool \u003Cget_enemyMinibossCount\u003Eb__10_0(Entity a) => (bool) (UnityEngine.Object) a && (UnityEngine.Object) a.owner == (UnityEngine.Object) this.enemy;

  public enum Phase
  {
    None,
    Init,
    Play,
    Battle,
    End,
    LastStand,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization;

[CreateAssetMenu(fileName = "BattleData", menuName = "Battle")]
public class BattleData : DataFile
{
  public string title;
  public float pointFactor = 1f;
  public int waveCounter = 4;
  public BattleWavePoolData[] pools;
  public CardData[] bonusUnitPool;
  public Vector2Int bonusUnitRange;
  public CardData[] goldGiverPool;
  public int goldGivers = 1;
  public BattleGenerationScript generationScript;
  public Script setUpScript;
  public Sprite sprite;
  public LocalizedString nameRef;
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleEntity
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine.Localization;

[Serializable]
public struct BattleEntity
{
  public LocalizedString titleKey;
  public string forceTitle;
  public string cardType;
  public bool friendly;
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleEntityData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Linq;

[Serializable]
public class BattleEntityData
{
  public CardSaveData cardSaveData;
  public int height;
  public int damage;
  public int damageMax;
  public int hp;
  public int hpMax;
  public int counter;
  public int counterMax;
  public int uses;
  public int usesMax;
  public bool flipped;
  public StatusEffectSaveData[] attackEffects;

  public BattleEntityData()
  {
  }

  public BattleEntityData(Entity entity)
  {
    this.cardSaveData = entity.data.Save();
    this.height = entity.height;
    this.damage = entity.damage.current;
    this.damageMax = entity.damage.max;
    this.hp = entity.hp.current;
    this.hpMax = entity.hp.max;
    this.counter = entity.counter.current;
    this.counterMax = entity.counter.max;
    this.uses = entity.uses.current;
    this.usesMax = entity.uses.max;
    this.flipped = !entity.enabled;
    this.attackEffects = entity.attackEffects.Select<CardData.StatusEffectStacks, StatusEffectSaveData>((Func<CardData.StatusEffectStacks, StatusEffectSaveData>) (a => a.Save())).ToArray<StatusEffectSaveData>();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleGenerationScript
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public abstract class BattleGenerationScript : ScriptableObject
{
  public virtual SaveCollection<BattleWaveManager.WaveData> Run(BattleData battleData, int points) => new SaveCollection<BattleWaveManager.WaveData>();

  public void AddGoldGivers(BattleGenerationScript.WaveList waves, BattleData battleData)
  {
    if (battleData.goldGivers <= 0 || battleData.goldGiverPool.Length == 0)
      return;
    List<int> list = new List<int>();
    for (int index = 1; index < waves.Count - 1; ++index)
      list.Add(index);
    for (int index = 0; index < battleData.goldGivers && list.Count > 0; ++index)
    {
      int waveIndex = list.RandomItem<int>();
      list.Remove(waveIndex);
      waves.AddUnit(waveIndex, battleData.goldGiverPool.RandomItem<CardData>());
    }
  }

  public void AddBonusUnits(BattleGenerationScript.WaveList waves, BattleData battleData)
  {
    int num = battleData.bonusUnitRange.Random();
    if (num <= 0 || battleData.bonusUnitPool.Length == 0)
      return;
    List<int> list = new List<int>();
    for (int waveIndex = 0; waveIndex < waves.Count; ++waveIndex)
    {
      if (waves.GetWave(waveIndex).CanAddTo())
        list.Add(waveIndex);
    }
    for (int index = 0; index < num && list.Count > 0; ++index)
    {
      int waveIndex = list.RandomItem<int>();
      list.Remove(waveIndex);
      waves.AddUnit(waveIndex, battleData.bonusUnitPool.RandomItem<CardData>());
    }
  }

  public class WaveList
  {
    public List<BattleWavePoolData.Wave> list;
    public int value;
    public int targetValue;

    public WaveList(int targetValue) => this.targetValue = targetValue;

    public void Add(BattleWavePoolData.Wave wave)
    {
      if (this.list == null)
        this.list = new List<BattleWavePoolData.Wave>();
      if (!wave.fixedOrder)
        wave.units.Shuffle<CardData>();
      int num = this.list.Count;
      int positionPriority1 = wave.positionPriority;
      for (int index1 = 0; index1 < this.list.Count; ++index1)
      {
        int positionPriority2 = this.list[index1].positionPriority;
        if (positionPriority2 >= positionPriority1)
        {
          num = index1;
          if (positionPriority2 == positionPriority1)
          {
            for (int index2 = index1 + 1; index2 < this.list.Count; ++index2)
            {
              if (this.list[index2].positionPriority > positionPriority1)
              {
                num = RandomInclusive.Range(num, index2);
                break;
              }
            }
            break;
          }
          break;
        }
      }
      this.list.Insert(num, wave);
      this.value += wave.value;
    }

    public void RemoveAt(int index) => this.list.RemoveAt(index);

    public BattleWavePoolData.Wave GetWave(int waveIndex) => this.list[waveIndex];

    public void AddUnit(int waveIndex, CardData unit) => this.GetWave(waveIndex).units.Add(unit);

    public int Count => this.list.Count;

    public bool Satisfied() => this.value >= this.targetValue;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleGenerationScriptFinalBoss
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "FinalBossBattleGenerator", menuName = "Battle Generation Scripts/Final Boss")]
public class BattleGenerationScriptFinalBoss : BattleGenerationScript
{
  [SerializeField]
  public FinalBossGenerationSettings settings;
  [SerializeField]
  public CardType leaderCardType;
  [SerializeField]
  public CardType enemyCardType;
  [Header("Waves")]
  [SerializeField]
  public int waveCount = 3;
  [SerializeField]
  public int leaderWave;
  [SerializeField]
  public int bossWave = 3;
  [SerializeField]
  public int[] waveMaxSize = new int[3]{ 6, 6, 6 };
  [SerializeField]
  public bool insertBossAtFront;
  [SerializeField]
  public bool insertLeaderAtFront;
  [Header("Boss")]
  [SerializeField]
  public CardData[] bossOptions;
  [SerializeField]
  public StatusEffectData[] leaderNextPhase;
  [Header("Default Deck")]
  [SerializeField]
  public CardData[] defaultLeaderOptions;
  [SerializeField]
  public bool processDefaultLeader;
  [SerializeField]
  public CardData[] defaultDeck;

  public CardData[] LoadCards(GameMode gameMode)
  {
    if (!gameMode.mainGameMode)
      return (CardData[]) null;
    CardSaveData[] data = SaveSystem.LoadProgressData<CardSaveData[]>("finalBossDeck", (CardSaveData[]) null);
    if (data == null)
      return (CardData[]) null;
    CardData[] source = data.LoadArray<CardData, CardSaveData>();
    return source == null ? (CardData[]) null : ((IEnumerable<CardData>) source).Where<CardData>((Func<CardData, bool>) (a => !MissingCardSystem.IsMissing(a))).ToArray<CardData>();
  }

  public void GetBaseEnemies(
    CardData[] cardList,
    int seed,
    out List<CardData> enemiesCloned,
    out bool hasStoredCards,
    out bool hasLeader,
    out CardData leaderCloned,
    out bool hasBoss,
    out CardData bossCloned)
  {
    UnityEngine.Random.State state = UnityEngine.Random.state;
    UnityEngine.Random.InitState(seed);
    int num = ((IEnumerable<int>) this.waveMaxSize).Sum();
    leaderCloned = (CardData) null;
    hasLeader = false;
    hasStoredCards = cardList != null;
    if (!hasStoredCards)
    {
      enemiesCloned = new List<CardData>();
      foreach (CardData cardData in (IEnumerable<CardData>) ((IEnumerable<CardData>) this.defaultDeck).InRandomOrder<CardData>())
      {
        enemiesCloned.Add(cardData.Clone());
        if (enemiesCloned.Count >= num)
          break;
      }
    }
    else
    {
      List<CardData> list = ((IEnumerable<CardData>) cardList).Where<CardData>((Func<CardData, bool>) (a =>
      {
        string name = a.cardType.name;
        return (name == "Friendly" || name == "Enemy" ? 0 : (!(name == "Leader") ? 1 : 0)) == 0;
      })).ToList<CardData>();
      this.settings.ReplaceCards((IList<CardData>) list);
      enemiesCloned = new List<CardData>(list.Select<CardData, CardData>((Func<CardData, CardData>) (a => a.Clone(a.random3, false))));
      enemiesCloned.Shuffle<CardData>();
      leaderCloned = enemiesCloned.FirstOrDefault<CardData>((Func<CardData, bool>) (a => a.cardType.name == "Leader"));
      if ((bool) (UnityEngine.Object) leaderCloned)
      {
        hasLeader = true;
        leaderCloned.cardType = this.leaderCardType;
      }
      this.settings.Process(leaderCloned, (IList<CardData>) enemiesCloned);
      foreach (CardData cardData in enemiesCloned)
        cardData.SetCustomData("eyes", (object) "frost");
    }
    foreach (CardData cardData in enemiesCloned.Where<CardData>((Func<CardData, bool>) (a => a.cardType.name == "Friendly")))
      cardData.cardType = this.enemyCardType;
    if (!hasLeader && this.defaultLeaderOptions.Length != 0)
    {
      hasLeader = true;
      leaderCloned = this.defaultLeaderOptions.RandomItem<CardData>().Clone();
      leaderCloned.cardType = this.leaderCardType;
      enemiesCloned.Insert(0, leaderCloned);
      if (this.processDefaultLeader)
        this.settings.Process(leaderCloned, (IList<CardData>) new List<CardData>()
        {
          leaderCloned
        });
    }
    hasBoss = this.bossOptions.Length != 0;
    bossCloned = (CardData) null;
    if (hasBoss)
    {
      bossCloned = this.bossOptions.RandomItem<CardData>().Clone();
      enemiesCloned.Insert(0, bossCloned);
    }
    int count = num + (hasLeader ? 1 : 0) - enemiesCloned.Count;
    if (count > 0 & hasStoredCards)
      enemiesCloned.AddRange(this.settings.GenerateBonusEnemies(count, (IEnumerable<CardData>) cardList, this.defaultDeck));
    UnityEngine.Random.state = state;
  }

  public override SaveCollection<BattleWaveManager.WaveData> Run(BattleData battleData, int points)
  {
    Debug.Log((object) string.Format("Creating FINAL BOSS WAVES for [{0}]", (object) battleData));
    List<CardData> enemiesCloned;
    bool hasLeader;
    CardData leaderCloned;
    bool hasBoss;
    CardData bossCloned;
    this.GetBaseEnemies(this.LoadCards(Campaign.Data.GameMode), Campaign.Data.Seed, out enemiesCloned, out bool _, out hasLeader, out leaderCloned, out hasBoss, out bossCloned);
    if (hasLeader)
      enemiesCloned.Remove(leaderCloned);
    if (hasBoss)
      enemiesCloned.Remove(bossCloned);
    if (hasLeader && this.leaderNextPhase.Length != 0)
      leaderCloned.startWithEffects = CardData.StatusEffectStacks.Stack((IEnumerable<CardData.StatusEffectStacks>) leaderCloned.startWithEffects, (IEnumerable<CardData.StatusEffectStacks>) new CardData.StatusEffectStacks[1]
      {
        new CardData.StatusEffectStacks(this.leaderNextPhase.RandomItem<StatusEffectData>(), 1)
      });
    BattleGenerationScript.WaveList waves = new BattleGenerationScript.WaveList(Mathf.RoundToInt((float) points * battleData.pointFactor));
    for (int index = 0; index < this.waveCount; ++index)
      waves.Add(new BattleWavePoolData.Wave()
      {
        units = new List<CardData>(),
        maxSize = this.waveMaxSize[index],
        positionPriority = index
      });
    int num = 0;
    foreach (CardData cardData in enemiesCloned)
    {
      bool flag = false;
      for (int index = 0; index < this.waveCount; ++index)
      {
        BattleWavePoolData.Wave wave = waves.GetWave(index % this.waveCount);
        if (wave.maxSize > 0 && wave.CanAddTo())
        {
          flag = true;
          wave.units.Add(cardData);
          break;
        }
        ++num;
      }
      ++num;
      if (!flag)
        break;
    }
    if (hasLeader)
    {
      List<CardData> units = waves.GetWave(this.leaderWave).units;
      if (this.insertLeaderAtFront)
        units.Insert(0, leaderCloned);
      else
        units.Add(leaderCloned);
    }
    if (hasBoss)
    {
      List<CardData> units = waves.GetWave(this.bossWave).units;
      if (this.insertBossAtFront)
        units.Insert(0, bossCloned);
      else
        units.Add(bossCloned);
    }
    for (int index = this.waveCount - 1; index >= 0; --index)
    {
      if (waves.GetWave(index).units.Count <= 0)
        waves.RemoveAt(index);
    }
    this.AddGoldGivers(waves, battleData);
    this.AddBonusUnits(waves, battleData);
    List<BattleWaveManager.WaveData> collection = new List<BattleWaveManager.WaveData>();
    int count = waves.Count;
    for (int waveIndex = 0; waveIndex < count; ++waveIndex)
    {
      BattleWaveManager.WaveDataFull waveDataFull1 = new BattleWaveManager.WaveDataFull();
      waveDataFull1.counter = battleData.waveCounter;
      BattleWaveManager.WaveDataFull waveDataFull2 = waveDataFull1;
      BattleWavePoolData.Wave wave = waves.GetWave(waveIndex);
      List<CardSaveData> cardSaveDataList = new List<CardSaveData>();
      foreach (CardData unit in wave.units)
      {
        cardSaveDataList.Add(unit.Save());
        if (!waveDataFull2.isBossWave && unit.cardType.miniboss)
          waveDataFull2.isBossWave = true;
      }
      waveDataFull2.cardDatas = cardSaveDataList.ToArray();
      collection.Add((BattleWaveManager.WaveData) waveDataFull2);
    }
    foreach (UnityEngine.Object @object in enemiesCloned)
      UnityEngine.Object.Destroy(@object);
    if ((bool) (UnityEngine.Object) leaderCloned)
      UnityEngine.Object.Destroy((UnityEngine.Object) leaderCloned);
    if ((bool) (UnityEngine.Object) bossCloned)
      UnityEngine.Object.Destroy((UnityEngine.Object) bossCloned);
    return new SaveCollection<BattleWaveManager.WaveData>(collection);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleGenerationScriptWaves
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "WaveBattleGenerator", menuName = "Battle Generation Scripts/Waves")]
public class BattleGenerationScriptWaves : BattleGenerationScript
{
  public override SaveCollection<BattleWaveManager.WaveData> Run(BattleData battleData, int points)
  {
    Debug.Log((object) string.Format("Creating Waves for [{0}]", (object) battleData));
    List<BattleWavePoolData> list = new List<BattleWavePoolData>();
    int targetValue = Mathf.RoundToInt((float) points * battleData.pointFactor);
    Debug.Log((object) string.Format("Points: {0}", (object) targetValue));
    BattleGenerationScript.WaveList waves = new BattleGenerationScript.WaveList(targetValue);
    foreach (BattleWavePoolData pool in battleData.pools)
    {
      BattleWavePoolData battleWavePoolData = UnityEngine.Object.Instantiate<BattleWavePoolData>(pool);
      while (battleWavePoolData.MustPull() && battleWavePoolData.CanPull())
        waves.Add(battleWavePoolData.Pull());
      for (int index = 0; index < battleWavePoolData.weight; ++index)
        list.Add(battleWavePoolData);
    }
    while (!waves.Satisfied() && list.Count > 0)
    {
      BattleWavePoolData battleWavePoolData = list.RandomItem<BattleWavePoolData>();
      if ((UnityEngine.Object) battleWavePoolData != (UnityEngine.Object) null && battleWavePoolData.CanPull())
      {
        waves.Add(battleWavePoolData.Pull());
      }
      else
      {
        list.Remove(battleWavePoolData);
        UnityEngine.Object.Destroy((UnityEngine.Object) battleWavePoolData);
      }
    }
    for (int index = list.Count - 1; index >= 0; --index)
    {
      UnityEngine.Object.Destroy((UnityEngine.Object) list[index]);
      list.RemoveAt(index);
    }
    this.AddGoldGivers(waves, battleData);
    this.AddBonusUnits(waves, battleData);
    List<BattleWaveManager.WaveData> collection = new List<BattleWaveManager.WaveData>();
    int count = waves.Count;
    for (int waveIndex = 0; waveIndex < count; ++waveIndex)
    {
      BattleWaveManager.WaveDataBasic waveDataBasic1 = new BattleWaveManager.WaveDataBasic();
      waveDataBasic1.counter = battleData.waveCounter;
      BattleWaveManager.WaveDataBasic waveDataBasic2 = waveDataBasic1;
      BattleWavePoolData.Wave wave = waves.GetWave(waveIndex);
      List<string> source = new List<string>();
      foreach (CardData unit in wave.units)
      {
        source.Add(unit.name);
        if (!waveDataBasic2.isBossWave && unit.cardType.miniboss)
          waveDataBasic2.isBossWave = true;
      }
      waveDataBasic2.cards = source.Select<string, BattleWaveManager.Card>((Func<string, BattleWaveManager.Card>) (a => new BattleWaveManager.Card(a))).ToArray<BattleWaveManager.Card>();
      collection.Add((BattleWaveManager.WaveData) waveDataBasic2);
    }
    return new SaveCollection<BattleWaveManager.WaveData>(collection);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleLog
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine.Localization;

[Serializable]
public struct BattleLog
{
  public LocalizedString textKey;
  public object[] args;
  public BattleLogType type;
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleLogButton
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class BattleLogButton : MonoBehaviour
{
  [SerializeField]
  public JournalTab battleLogTab;

  public void Awake()
  {
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    this.SetActive(false);
  }

  public void OnDestroy() => global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);

  public void SceneChanged(Scene scene) => this.SetActive(scene.name == "Battle");

  public void SetActive(bool value)
  {
    this.gameObject.SetActive(value);
    if (!(bool) (Object) this.battleLogTab)
      return;
    this.battleLogTab.gameObject.SetActive(value);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleLogDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class BattleLogDisplay : MonoBehaviour
{
  [SerializeField]
  public BattleLogDisplayBuilder builder;
  [SerializeField]
  public ScrollRect scroll;
  [SerializeField]
  public GameObject loadingWidget;
  public bool promptScrollToBottom;
  public bool loadingWidgetActive;

  public void OnEnable()
  {
    this.CheckScrollToBottom();
    this.loadingWidget.SetActive(this.builder.running);
    this.loadingWidgetActive = this.loadingWidget.activeSelf;
  }

  public void Update()
  {
    this.CheckScrollToBottom();
    if (!this.loadingWidgetActive || this.builder.running)
      return;
    this.loadingWidget.SetActive(false);
    this.loadingWidgetActive = false;
  }

  public void CheckScrollToBottom()
  {
    if (!this.promptScrollToBottom || this.builder.running)
      return;
    this.scroll.normalizedPosition = Vector2.zero;
    this.promptScrollToBottom = false;
  }

  public void PromptScrollToBottom() => this.promptScrollToBottom = true;
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleLogDisplayBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.AddressableAssets;

public class BattleLogDisplayBuilder : MonoBehaviour
{
  [SerializeField]
  public BattleLogDisplay battleLogDisplay;
  [SerializeField]
  public Transform tempGroup;
  [SerializeField]
  public Transform finalGroup;
  [SerializeField]
  public AssetReferenceGameObject groupPrefabRef;
  [SerializeField]
  public BattleLogDisplayBuilder.EntryLookup[] entryTypes;
  public readonly Dictionary<BattleLogType, AssetReferenceGameObject> entryLookup = new Dictionary<BattleLogType, AssetReferenceGameObject>();
  public readonly List<Transform> progress = new List<Transform>();
  public BattleLogSystem battleLogSystem;
  public readonly CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();
  public CancellationToken cancellationToken;
  [CompilerGenerated]
  public int \u003Centries\u003Ek__BackingField;
  [CompilerGenerated]
  public bool \u003Crunning\u003Ek__BackingField;

  public int entries
  {
    get => this.\u003Centries\u003Ek__BackingField;
    set => this.\u003Centries\u003Ek__BackingField = value;
  }

  public bool running
  {
    get => this.\u003Crunning\u003Ek__BackingField;
    set => this.\u003Crunning\u003Ek__BackingField = value;
  }

  public void Awake()
  {
    this.entryLookup.Clear();
    foreach (BattleLogDisplayBuilder.EntryLookup entryType in this.entryTypes)
      this.entryLookup[entryType.type] = entryType.entryPrefab;
    this.cancellationToken = this.cancellationTokenSource.Token;
  }

  public async void OnEnable()
  {
    this.battleLogSystem = UnityEngine.Object.FindObjectOfType<BattleLogSystem>();
    if (!(bool) (UnityEngine.Object) this.battleLogSystem)
    {
      this.entries = -1;
    }
    else
    {
      int num = this.entries != this.battleLogSystem.list.Count ? 1 : 0;
      this.entries = this.battleLogSystem.list.Count;
      if (num == 0)
        return;
      this.battleLogDisplay.PromptScrollToBottom();
      if (this.running)
      {
        this.cancellationTokenSource.Cancel();
        while (this.running)
          await Task.Yield();
      }
      await this.Build();
    }
  }

  public async Task Build()
  {
    this.running = true;
    this.finalGroup.DestroyAllChildren();
    await this.Populate();
    foreach (Transform transform in this.progress)
    {
      if (!this.cancellationToken.IsCancellationRequested)
        transform.SetParent(this.finalGroup);
      else
        break;
    }
    this.progress.Clear();
    this.tempGroup.DestroyAllChildren();
    this.running = false;
  }

  public async Task Populate()
  {
    if (this.cancellationToken.IsCancellationRequested)
      return;
    int num1 = 0;
    int count = this.battleLogSystem.list.Count;
    List<Task> taskList = new List<Task>();
    for (int index = 0; index < count; ++index)
    {
      if (this.cancellationToken.IsCancellationRequested)
        return;
      BattleLog battleLog = this.battleLogSystem.list[index];
      if (index == 0 || battleLog.type == BattleLogType.Turn)
      {
        int num2 = this.battleLogSystem.list.FindIndex(index + 1, (Predicate<BattleLog>) (a => a.type == BattleLogType.Turn));
        if (num2 == -1)
          num2 = count;
        List<BattleLog> range = this.battleLogSystem.list.GetRange(index, num2 - index);
        index = num2 - 1;
        if (this.cancellationToken.IsCancellationRequested)
          return;
        this.progress.Add((Transform) null);
        taskList.Add(this.CreateGroup(num1++, range));
      }
    }
    await Task.WhenAll((IEnumerable<Task>) taskList);
  }

  public async Task CreateGroup(int groupIndex, List<BattleLog> logs)
  {
    List<Task<Transform>> tasks;
    if (this.cancellationToken.IsCancellationRequested)
    {
      tasks = (List<Task<Transform>>) null;
    }
    else
    {
      Transform group = await this.CreateGroup(this.tempGroup);
      this.progress[groupIndex] = group;
      tasks = new List<Task<Transform>>();
      foreach (BattleLog log in logs)
      {
        if (this.cancellationToken.IsCancellationRequested)
        {
          tasks = (List<Task<Transform>>) null;
          return;
        }
        tasks.Add(this.CreateEntry(log, group));
      }
      Transform[] transformArray = await Task.WhenAll<Transform>((IEnumerable<Task<Transform>>) tasks);
      if (this.cancellationToken.IsCancellationRequested)
      {
        tasks = (List<Task<Transform>>) null;
      }
      else
      {
        for (int index = 0; index < tasks.Count; ++index)
        {
          Transform result = tasks[index].Result;
          if ((bool) (UnityEngine.Object) result)
            result.SetSiblingIndex(index + 1);
        }
        tasks = (List<Task<Transform>>) null;
      }
    }
  }

  public async Task<Transform> CreateGroup(Transform parent) => (await this.groupPrefabRef.InstantiateAsync(parent).Task).transform;

  public async Task<Transform> CreateEntry(BattleLog log, Transform group)
  {
    AssetReferenceGameObject referenceGameObject = this.entryLookup[log.type];
    if (this.cancellationToken.IsCancellationRequested)
      return (Transform) null;
    GameObject result = await referenceGameObject.InstantiateAsync(group).Task;
    await result.GetComponent<BattleLogEntry>().SetUp(log);
    return result.transform;
  }

  public void Cancel() => this.cancellationTokenSource.Cancel();

  [Serializable]
  public struct EntryLookup
  {
    public BattleLogType type;
    public AssetReferenceGameObject entryPrefab;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleLogEntry
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Threading.Tasks;
using TMPro;
using UnityEngine;

public class BattleLogEntry : MonoBehaviour
{
  [SerializeField]
  public TMP_Text textElement;
  public const string colorFriendly = "5E849A";
  public const string colorEnemy = "804248";
  public const string colorNumber = "EE5D46";

  public async Task SetUp(BattleLog log) => this.textElement.text = BattleLogEntry.FormatLogText(BattleLogEntry.AddInserts(await log.textKey.GetLocalizedStringAsync().Task, log.args));

  public static string AddInserts(string text, object[] inserts)
  {
    if (inserts != null && inserts.Length != 0)
    {
      object[] objArray = new object[inserts.Length];
      for (int index = 0; index < inserts.Length; ++index)
      {
        object insert = inserts[index];
        if (insert is BattleEntity entity)
        {
          string entityName = BattleLogEntry.GetEntityName(entity);
          string str = entity.friendly ? "5E849A" : "804248";
          objArray[index] = (object) ("<#" + str + ">" + entityName + "</color>");
        }
        else
          objArray[index] = insert;
      }
      text = string.Format(text, objArray);
    }
    return text;
  }

  public static string GetEntityName(BattleEntity entity)
  {
    string str = entity.forceTitle;
    if (str.IsNullOrWhitespace())
      str = entity.titleKey.GetLocalizedString();
    return str;
  }

  public static string FormatLogText(string text)
  {
    int startIndex = text.IndexOf('[');
    if (startIndex >= 0)
    {
      int num = text.IndexOf(']');
      if (num >= startIndex + 2)
      {
        string str = text.Substring(startIndex + 1, num - startIndex - 1);
        text = text.Remove(startIndex, num - startIndex + 1);
        text = text.Insert(startIndex, "<#EE5D46>" + str + "</color>");
        text = BattleLogEntry.FormatLogText(text);
      }
    }
    return text;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleLogSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;

public class BattleLogSystem : GameSystem
{
  public List<BattleLog> list = new List<BattleLog>();
  public static readonly Dictionary<string, string> damageTypes = new Dictionary<string, string>()
  {
    {
      "shroom",
      "<sprite name=shroom>"
    },
    {
      "spikes",
      "<sprite name=teeth>"
    },
    {
      "overload",
      "<sprite name=overload>"
    }
  };
  [SerializeField]
  public LocalizedString logTurnKey;
  [SerializeField]
  public LocalizedString logHitKey;
  [SerializeField]
  public LocalizedString logDamageKey;
  [SerializeField]
  public LocalizedString logSpecialDamageKey;
  [SerializeField]
  public LocalizedString logDestroyKey;
  [SerializeField]
  public LocalizedString logConsumedKey;
  [SerializeField]
  public LocalizedString logEatenKey;
  [SerializeField]
  public LocalizedString logSacrificedKey;
  [SerializeField]
  public LocalizedString logBlockKey;
  [SerializeField]
  public LocalizedString logStatusKey;
  [SerializeField]
  public LocalizedString logStatusFromKey;
  [SerializeField]
  public LocalizedString logHealKey;
  [SerializeField]
  public LocalizedString logRestoredKey;
  [SerializeField]
  public LocalizedString logBoostKey;
  [SerializeField]
  public LocalizedString logDamageUpKey;
  [SerializeField]
  public LocalizedString logDamageUpSelfKey;
  [SerializeField]
  public LocalizedString logDamageDownKey;
  [SerializeField]
  public LocalizedString logDamageDownSelfKey;
  [SerializeField]
  public LocalizedString logHealthUpKey;
  [SerializeField]
  public LocalizedString logHealthUpSelfKey;
  [SerializeField]
  public LocalizedString logHealthDownKey;
  [SerializeField]
  public LocalizedString logHealthDownSelfKey;
  [SerializeField]
  public LocalizedString logCounterUpKey;
  [SerializeField]
  public LocalizedString logCounterUpSelfKey;
  [SerializeField]
  public LocalizedString logCounterDownKey;
  [SerializeField]
  public LocalizedString logCounterDownSelfKey;
  [SerializeField]
  public LocalizedString logEnterBattleKey;
  [SerializeField]
  public LocalizedString logRecalledKey;
  [SerializeField]
  public LocalizedString logSummonedKey;
  [SerializeField]
  public LocalizedString logBattleWinKey;
  [SerializeField]
  public LocalizedString logBattleLoseKey;
  [SerializeField]
  public LocalizedString logFleeKey;

  public void OnEnable()
  {
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnBattleTurnEnd += new UnityAction<int>(this.TurnEnd);
    global::Events.OnEntityHit += new UnityAction<global::Hit>(this.Hit);
    global::Events.OnEntityMove += new UnityAction<Entity>(this.EntityMove);
    global::Events.OnStatusEffectApplied += new UnityAction<StatusEffectApply>(this.StatusApplied);
    global::Events.OnEntityPostHit += new UnityAction<global::Hit>(this.PostHit);
    global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnEntityFlee += new UnityAction<Entity>(this.EntityFlee);
    global::Events.OnBattleEnd += new UnityAction(this.BattleEnd);
  }

  public void OnDisable()
  {
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnBattleTurnEnd -= new UnityAction<int>(this.TurnEnd);
    global::Events.OnEntityHit -= new UnityAction<global::Hit>(this.Hit);
    global::Events.OnEntityMove -= new UnityAction<Entity>(this.EntityMove);
    global::Events.OnStatusEffectApplied -= new UnityAction<StatusEffectApply>(this.StatusApplied);
    global::Events.OnEntityPostHit -= new UnityAction<global::Hit>(this.PostHit);
    global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnEntityFlee -= new UnityAction<Entity>(this.EntityFlee);
    global::Events.OnBattleEnd -= new UnityAction(this.BattleEnd);
  }

  public void BattlePhaseStart(Battle.Phase phase)
  {
    if (phase != Battle.Phase.Init)
      return;
    this.list.Clear();
  }

  public void TurnEnd(int turnNumber)
  {
    if (References.Battle.ended)
      return;
    this.Log(this.logTurnKey, BattleLogType.Turn, (object) (turnNumber + 1));
  }

  public void Hit(global::Hit hit)
  {
    if (!hit.countsAsHit || !hit.Offensive)
      return;
    if (!hit.BasicHit || !(bool) (Object) hit.attacker || !(bool) (Object) hit.attacker.data)
      this.LogDamage(hit.target, hit.damage + hit.damageBlocked, hit.damageType);
    else
      this.LogHit(hit.attacker, hit.target, hit.damage + hit.damageBlocked, hit.damageType);
  }

  public void EntityMove(Entity entity)
  {
    if (!Battle.IsOnBoard(entity) || Battle.IsOnBoard(entity.preContainers))
      return;
    this.Log(this.logEnterBattleKey, BattleLogType.Enter, (object) BattleLogSystem.GetBattleEntity(entity));
  }

  public void StatusApplied(StatusEffectApply apply)
  {
    if (!(bool) (Object) apply.effectData || apply.effectData.type.IsNullOrWhitespace() || apply.count <= 0)
      return;
    switch (apply.effectData.type)
    {
      case "counter down":
      case "max counter down":
        this.LogCounterDown(apply.applier, apply.target, apply.count);
        break;
      case "counter up":
      case "max counter up":
        this.LogCounterUp(apply.applier, apply.target, apply.count);
        break;
      case "damage down":
        this.LogDamageDown(apply.applier, apply.target, apply.count);
        break;
      case "damage up":
        this.LogDamageUp(apply.applier, apply.target, apply.count);
        break;
      case "heal":
        this.LogHeal(apply.applier, apply.target);
        break;
      case "max health down":
        this.LogHealthDown(apply.applier, apply.target, apply.count);
        break;
      case "max health up":
        this.LogHealthUp(apply.applier, apply.target, apply.count);
        break;
      default:
        this.LogStatus(apply.applier, apply.target, apply.effectData, apply.count);
        break;
    }
  }

  public void PostHit(global::Hit hit)
  {
    if (!hit.countsAsHit || !hit.Offensive || hit.damageBlocked <= 0)
      return;
    this.LogBlock(hit.target, hit.damageBlocked);
  }

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    if (deathType != DeathType.Consume)
    {
      if (DeathSystem.KilledByOwnTeam(entity))
        this.Log(this.logSacrificedKey, BattleLogType.Die, (object) BattleLogSystem.GetBattleEntity(entity));
      else
        this.Log(this.logDestroyKey, BattleLogType.Die, (object) BattleLogSystem.GetBattleEntity(entity));
    }
    else
      this.Log(this.logConsumedKey, BattleLogType.Consume, (object) BattleLogSystem.GetBattleEntity(entity));
  }

  public void EntityFlee(Entity entity) => this.Log(this.logFleeKey, BattleLogType.Flee, (object) BattleLogSystem.GetBattleEntity(entity));

  public void BattleEnd()
  {
    if ((Object) References.Battle.winner == (Object) References.Battle.player)
      this.Log(this.logBattleWinKey, BattleLogType.Win);
    else
      this.Log(this.logBattleLoseKey, BattleLogType.Win);
  }

  public void LogHit(Entity attacker, Entity target, int damage, string damageType)
  {
    if (!(bool) (Object) target)
      return;
    this.Log(this.logHitKey, BattleLogType.Attack, (object) BattleLogSystem.GetBattleEntity(attacker), (object) BattleLogSystem.GetBattleEntity(target), (object) damage);
  }

  public void LogDamage(Entity target, int damage, string damageType)
  {
    if (damage <= 0)
      return;
    string str;
    if (BattleLogSystem.damageTypes.TryGetValue(damageType, out str))
      this.Log(this.logSpecialDamageKey, BattleLogType.Debuff, (object) BattleLogSystem.GetBattleEntity(target), (object) damage, (object) str);
    else
      this.Log(this.logDamageKey, BattleLogType.Debuff, (object) BattleLogSystem.GetBattleEntity(target), (object) damage);
  }

  public void LogBlock(Entity target, int damageBlocked) => this.Log(this.logBlockKey, BattleLogType.Buff, (object) BattleLogSystem.GetBattleEntity(target), (object) damageBlocked);

  public void LogStatus(Entity applier, Entity target, StatusEffectData status, int count)
  {
    if (!status.isStatus)
      return;
    BattleLogType type = status.offensive ? BattleLogType.Debuff : BattleLogType.Buff;
    if ((bool) (Object) applier && (long) applier.data.id != (long) target.data.id)
      this.Log(this.logStatusFromKey, type, (object) BattleLogSystem.GetBattleEntity(applier), (object) BattleLogSystem.GetBattleEntity(target), (object) count, (object) status.type);
    else
      this.Log(this.logStatusKey, type, (object) BattleLogSystem.GetBattleEntity(target), (object) count, (object) status.type);
  }

  public void LogHeal(Entity healer, Entity target) => this.Log(this.logHealKey, BattleLogType.Heal, (object) BattleLogSystem.GetBattleEntity(healer), (object) BattleLogSystem.GetBattleEntity(target));

  public void LogRestore(Entity target, int amount) => this.Log(this.logRestoredKey, BattleLogType.Heal, (object) BattleLogSystem.GetBattleEntity(target), (object) amount);

  public void LogDamageUp(Entity applier, Entity target, int amount)
  {
    if (!(bool) (Object) applier || (Object) applier == (Object) target)
      this.Log(this.logDamageUpSelfKey, BattleLogType.Buff, (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
    else
      this.Log(this.logDamageUpKey, BattleLogType.Buff, (object) BattleLogSystem.GetBattleEntity(applier), (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
  }

  public void LogDamageDown(Entity applier, Entity target, int amount)
  {
    if (!(bool) (Object) applier || (Object) applier == (Object) target)
      this.Log(this.logDamageDownSelfKey, BattleLogType.Debuff, (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
    else
      this.Log(this.logDamageDownKey, BattleLogType.Debuff, (object) BattleLogSystem.GetBattleEntity(applier), (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
  }

  public void LogHealthUp(Entity applier, Entity target, int amount)
  {
    if (!(bool) (Object) applier || (Object) applier == (Object) target)
      this.Log(this.logHealthUpSelfKey, BattleLogType.Buff, (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
    else
      this.Log(this.logHealthUpKey, BattleLogType.Buff, (object) BattleLogSystem.GetBattleEntity(applier), (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
  }

  public void LogHealthDown(Entity applier, Entity target, int amount)
  {
    if (!(bool) (Object) applier || (Object) applier == (Object) target)
      this.Log(this.logHealthDownSelfKey, BattleLogType.Debuff, (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
    else
      this.Log(this.logHealthDownKey, BattleLogType.Debuff, (object) BattleLogSystem.GetBattleEntity(applier), (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
  }

  public void LogCounterUp(Entity applier, Entity target, int amount)
  {
    if (!(bool) (Object) applier || (Object) applier == (Object) target)
      this.Log(this.logCounterUpSelfKey, BattleLogType.Debuff, (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
    else
      this.Log(this.logCounterUpKey, BattleLogType.Debuff, (object) BattleLogSystem.GetBattleEntity(applier), (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
  }

  public void LogCounterDown(Entity applier, Entity target, int amount)
  {
    if (!(bool) (Object) applier || (Object) applier == (Object) target)
      this.Log(this.logCounterDownSelfKey, BattleLogType.Buff, (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
    else
      this.Log(this.logCounterDownKey, BattleLogType.Buff, (object) BattleLogSystem.GetBattleEntity(applier), (object) BattleLogSystem.GetBattleEntity(target), (object) amount);
  }

  public void Log(LocalizedString textKey, BattleLogType type, params object[] args) => this.list.Add(new BattleLog()
  {
    textKey = textKey,
    type = type,
    args = args
  });

  public static BattleEntity GetBattleEntity(Entity entity)
  {
    BattleEntity battleEntity = new BattleEntity()
    {
      cardType = entity.data.cardType.name,
      friendly = entity.owner.team == References.Player.team,
      forceTitle = entity.data.forceTitle
    };
    if (battleEntity.forceTitle.IsNullOrWhitespace())
    {
      if (entity.data.titleKey.IsEmpty)
        battleEntity.forceTitle = entity.data.titleFallback;
      else
        battleEntity.titleKey = entity.data.titleKey;
    }
    return battleEntity;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleLogType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public enum BattleLogType
{
  None,
  Turn,
  Attack,
  Heal,
  Enter,
  Flee,
  Buff,
  Debuff,
  EnemyDie,
  Die,
  Consume,
  Win,
  Lose,
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleMusicSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Serializable]
public class BattleMusicSaveData
{
  public int intensity;
  public bool bossEntered;
  public int bossPhase;
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleMusicSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMOD;
using FMOD.Studio;
using FMODUnity;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class BattleMusicSystem : GameSystem, ISaveable<BattleMusicSaveData>
{
  public int startingIntensity;
  public int normalIntensity = 1;
  [Header("Win/Lose Jingles")]
  [SerializeField]
  public EventReference winJingle;
  [SerializeField]
  public EventReference loseJingle;
  [Header("Miniboss Intros")]
  [SerializeField]
  public EventReference minibossIntroDefault;
  [SerializeField]
  public BattleMusicSystem.MinibossIntroRef[] minibossIntros;
  [SerializeField]
  public float minibossIntroDuration = 2f;
  public readonly Dictionary<string, EventReference> minibossIntroLookup = new Dictionary<string, EventReference>();
  public Scene currentScene;
  public EventInstance current;
  public EventInstance minibossIntroInstance;
  public int intensity;
  public PARAMETER_ID intensityParameterId;
  public bool bossEntered;
  public float promptStartMiniboss;
  public int bossPhase = 1;
  public float volume = 1f;
  public float pitch = 1f;
  public float targetVolume = 1f;
  public float targetPitch = 1f;
  public const float fadeAmount = 1f;

  public void Awake()
  {
    foreach (BattleMusicSystem.MinibossIntroRef minibossIntro in this.minibossIntros)
      this.minibossIntroLookup[minibossIntro.cardData.name] = minibossIntro.introEvent;
  }

  public void OnEnable()
  {
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChange);
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseChange);
    global::Events.OnBattleEnd += new UnityAction(this.BattleEnd);
    global::Events.OnEntityHit += new UnityAction<Hit>(this.EntityHit);
    global::Events.OnEntityMove += new UnityAction<Entity>(this.EntityMove);
    global::Events.OnMinibossIntro += new UnityAction<Entity>(this.MinibossIntro);
    global::Events.OnEntityChangePhase += new UnityAction<Entity>(this.EntityChangePhase);
    this.Check();
  }

  public void OnDisable()
  {
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChange);
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseChange);
    global::Events.OnBattleEnd -= new UnityAction(this.BattleEnd);
    global::Events.OnEntityHit -= new UnityAction<Hit>(this.EntityHit);
    global::Events.OnEntityMove -= new UnityAction<Entity>(this.EntityMove);
    global::Events.OnMinibossIntro -= new UnityAction<Entity>(this.MinibossIntro);
    global::Events.OnEntityChangePhase -= new UnityAction<Entity>(this.EntityChangePhase);
    this.StopMusic();
  }

  public void OnDestroy() => this.StopMusic();

  public void Update()
  {
    if ((double) this.promptStartMiniboss > 0.0)
    {
      this.promptStartMiniboss -= Time.deltaTime;
      if ((double) this.promptStartMiniboss <= 0.0)
      {
        this.StartMusic(References.GetCurrentArea().minibossMusicEvent);
        this.SetParam("bossHealth", 1f);
      }
    }
    float max = 1f * Time.deltaTime;
    if ((double) Mathf.Abs(this.pitch - this.targetPitch) <= (double) max)
      return;
    this.pitch += Mathf.Clamp(this.targetPitch - this.pitch, -max, max);
    if (!BattleMusicSystem.IsRunning(this.current))
      return;
    int num = (int) this.current.setPitch(this.pitch);
  }

  public void FadePitchTo(float value) => this.targetPitch = value;

  public void SceneChange(Scene scene)
  {
    this.currentScene = scene;
    this.Check();
  }

  public void BattlePhaseChange(Battle.Phase phase)
  {
    if (phase != Battle.Phase.End)
      return;
    this.StopMusic(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);
  }

  public void BattleEnd()
  {
    if ((UnityEngine.Object) Battle.instance.winner == (UnityEngine.Object) Battle.instance.player)
      SfxSystem.OneShot(this.winJingle);
    else
      SfxSystem.OneShot(this.loseJingle);
  }

  public void EntityHit(Hit hit)
  {
    if (this.bossEntered || this.intensity != this.startingIntensity || !hit.Offensive)
      return;
    this.SetIntensity(this.normalIntensity);
  }

  public void EntityMove(Entity entity)
  {
    if (this.bossEntered || !this.currentScene.IsValid() || !(bool) (UnityEngine.Object) References.Battle || !((UnityEngine.Object) entity.owner == (UnityEngine.Object) References.Battle.enemy))
      return;
    CardType cardType = entity.data?.cardType;
    if (cardType == null || !cardType.miniboss || !Battle.IsOnBoard(entity) || Battle.IsOnBoard(entity.preContainers))
      return;
    this.bossEntered = true;
    this.StopMusic(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);
  }

  public void MinibossIntro(Entity entity)
  {
    if (BattleMusicSystem.IsBossBattle())
      return;
    this.minibossIntroInstance = SfxSystem.OneShot(this.minibossIntroLookup.ContainsKey(entity.data.name) ? this.minibossIntroLookup[entity.data.name] : this.minibossIntroDefault);
    this.promptStartMiniboss = this.minibossIntroDuration;
  }

  public void EntityChangePhase(Entity entity)
  {
    if (!entity.data.cardType.miniboss || entity.owner.team != References.Battle.enemy.team || this.bossPhase >= 2)
      return;
    ++this.bossPhase;
    this.SetParam("finalboss", (float) this.bossPhase);
  }

  public void Check()
  {
    if (this.currentScene.name == "Battle")
    {
      CampaignNode characterNode = Campaign.FindCharacterNode(References.Player);
      AreaData area = References.Areas[characterNode.areaIndex];
      if (characterNode.type is CampaignNodeTypeBattle type && !type.overrideMusic.IsNull)
        this.StartMusic(type.overrideMusic);
      else if (characterNode.type.isBoss)
      {
        this.StartMusic(area.bossMusicEvent);
      }
      else
      {
        this.StartMusic(area.battleMusicEvent);
        this.InitBattleMusic();
      }
      if (!characterNode.type.isBoss)
        return;
      this.bossEntered = true;
      this.bossPhase = 1;
      this.SetParam("finalboss", (float) this.bossPhase);
    }
    else
      this.StopMusic(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);
  }

  public void InitBattleMusic()
  {
    EventDescription description1;
    int description2 = (int) this.current.getDescription(out description1);
    PARAMETER_DESCRIPTION parameter;
    int descriptionByName = (int) description1.getParameterDescriptionByName("Phase", out parameter);
    this.intensityParameterId = parameter.id;
    this.SetIntensity(this.startingIntensity);
    this.bossEntered = false;
  }

  public void StartMusic(EventReference eventReference) => this.StartMusic(eventReference.Guid);

  public void StartMusic(GUID eventGUID)
  {
    try
    {
      this.current = RuntimeManager.CreateInstance(eventGUID);
      int num1 = (int) this.current.start();
      int num2 = (int) this.current.setPitch(this.pitch);
    }
    catch (EventNotFoundException ex)
    {
      UnityEngine.Debug.LogWarning((object) ex);
    }
  }

  public void StopMusic(FMOD.Studio.STOP_MODE stopMode = FMOD.Studio.STOP_MODE.IMMEDIATE)
  {
    int num1 = (int) this.current.stop(stopMode);
    int num2 = (int) this.current.release();
    this.targetPitch = 1f;
    this.targetVolume = 1f;
  }

  public void SetIntensity(int amount)
  {
    this.intensity = amount;
    int num = (int) this.current.setParameterByID(this.intensityParameterId, (float) this.intensity);
    UnityEngine.Debug.Log((object) string.Format("Battle Music System → Intensity Set to {0}", (object) this.intensity));
  }

  public void SetParam(string name, float value)
  {
    if (!BattleMusicSystem.IsRunning(this.current))
      return;
    int num = (int) this.current.setParameterByName(name, value);
    UnityEngine.Debug.Log((object) string.Format("Param Set: {0}: {1}", (object) name, (object) value));
  }

  public static bool IsRunning(EventInstance instance)
  {
    if (instance.isValid())
    {
      PLAYBACK_STATE state;
      int playbackState = (int) instance.getPlaybackState(out state);
      if (state != PLAYBACK_STATE.STOPPED)
        return true;
    }
    return false;
  }

  public static bool IsBossBattle() => Campaign.FindCharacterNode(References.Player).type.isBoss;

  public BattleMusicSaveData Save() => new BattleMusicSaveData()
  {
    intensity = this.intensity,
    bossEntered = this.bossEntered,
    bossPhase = this.bossPhase
  };

  public void Load(BattleMusicSaveData state)
  {
    if (BattleMusicSystem.IsRunning(this.current) && this.bossEntered == state.bossEntered && this.bossPhase == state.bossPhase)
      return;
    this.StopMusic();
    this.bossEntered = state.bossEntered;
    this.bossPhase = state.bossPhase;
    if (BattleMusicSystem.IsBossBattle())
    {
      this.StartMusic(References.GetCurrentArea().bossMusicEvent);
      this.SetParam("finalboss", (float) this.bossPhase);
    }
    else if (this.bossEntered)
    {
      this.StartMusic(References.GetCurrentArea().minibossMusicEvent);
    }
    else
    {
      this.StartMusic(References.GetCurrentArea().battleMusicEvent);
      this.SetIntensity(state.intensity);
    }
  }

  [Serializable]
  public struct MinibossIntroRef
  {
    [SerializeField]
    public CardData cardData;
    [SerializeField]
    public EventReference introEvent;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleRewards
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class BattleRewards : MonoBehaviour
{
  public List<RewardData> rewards;
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[Serializable]
public class BattleSaveData
{
  public int campaignNodeId;
  public int turnCount;
  public int redrawBellCount;
  public BattleSaveData.ContainerGroup playerRows;
  public BattleSaveData.ContainerGroup enemyRows;
  public BattleSaveData.Container playerHand;
  public BattleSaveData.Container playerDraw;
  public BattleSaveData.Container playerDiscard;
  public BattleSaveData.Container playerReserve;
  public BattleSaveData.Container enemyReserve;
  public BattleSaveData.Status[] statuses;
  public BattleEntityData[] destroyed;
  public BattleWaveData enemyWaves;
  public BattleMusicSaveData battleMusicState;
  public Dictionary<string, object> storeStatusData = new Dictionary<string, object>();
  public int gold;

  public bool HasMissingCardData()
  {
    List<BattleSaveData.Container> containerList = new List<BattleSaveData.Container>();
    containerList.AddRange((IEnumerable<BattleSaveData.Container>) this.playerRows.containers);
    containerList.AddRange((IEnumerable<BattleSaveData.Container>) this.enemyRows.containers);
    containerList.Add(this.playerReserve);
    containerList.Add(this.enemyReserve);
    containerList.Add(this.playerDraw);
    containerList.Add(this.playerDiscard);
    containerList.Add(this.playerHand);
    foreach (BattleSaveData.Container container in containerList)
    {
      foreach (BattleEntityData card in container.cards)
      {
        if (card != null && (card.cardSaveData == null || MissingCardSystem.IsMissing(card.cardSaveData.name)))
        {
          Debug.LogError((object) "BattleSaveData has missing CardData");
          return true;
        }
      }
    }
    return false;
  }

  [Serializable]
  public class ContainerGroup
  {
    public BattleSaveData.Container[] containers;

    public ContainerGroup()
    {
    }

    public ContainerGroup(IEnumerable<CardContainer> containers) => this.containers = containers.Select<CardContainer, BattleSaveData.Container>((Func<CardContainer, BattleSaveData.Container>) (a => new BattleSaveData.Container(a))).ToArray<BattleSaveData.Container>();
  }

  [Serializable]
  public class Container
  {
    public BattleEntityData[] cards;

    public Container()
    {
    }

    public Container(CardContainer container)
    {
      if (container is CardSlotLane cardSlotLane)
        this.cards = cardSlotLane.slots.Select<CardSlot, BattleEntityData>((Func<CardSlot, BattleEntityData>) (a =>
        {
          Entity top = a.GetTop();
          return top == null ? (BattleEntityData) null : new BattleEntityData(top);
        })).ToArray<BattleEntityData>();
      else
        this.cards = container.Select<Entity, BattleEntityData>((Func<Entity, BattleEntityData>) (a => new BattleEntityData(a))).ToArray<BattleEntityData>();
    }
  }

  [Serializable]
  public class Status
  {
    public string name;
    public int count;
    public ulong targetId;
    public bool hasApplier;
    public ulong applierId;

    public Status()
    {
    }

    public Status(StatusEffectData data)
    {
      this.name = data.name;
      this.count = data.count - data.temporary;
      this.targetId = data.target.data.id;
      this.hasApplier = (bool) (UnityEngine.Object) data.applier;
      if (!this.hasApplier)
        return;
      this.applierId = data.applier.data.id;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleSaveSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class BattleSaveSystem : GameSystem
{
  public static BattleSaveSystem instance;
  public bool loading;
  public bool justLoaded;
  public BattleSaveData state;
  public bool saveRequired;
  public bool campaignNodeIdSet;
  public int campaignNodeId;

  public void OnEnable()
  {
    BattleSaveSystem.instance = this;
    global::Events.OnBattlePreTurnStart += new UnityAction<int>(this.BattleTurnEnd);
    global::Events.OnCampaignFinal += new UnityAction(this.CampaignFinal);
  }

  public void OnDisable()
  {
    global::Events.OnBattlePreTurnStart -= new UnityAction<int>(this.BattleTurnEnd);
    global::Events.OnCampaignFinal -= new UnityAction(this.CampaignFinal);
  }

  public void OnApplicationQuit() => this.CheckSave();

  public static BattleSaveData GetBattleState() => BattleSaveSystem.instance.state;

  public void BattleTurnEnd(int turnCount)
  {
    if (this.justLoaded)
    {
      this.justLoaded = false;
    }
    else
    {
      this.BuildBattleState();
      this.saveRequired = true;
    }
  }

  public void CampaignFinal() => this.CheckSave();

  public void CheckSave()
  {
    if (!this.saveRequired || this.loading)
      return;
    if (Campaign.Data.GameMode.doSave)
      this.Save();
    global::Events.InvokeBattleSaved();
    global::Events.InvokeCampaignSaved();
    this.saveRequired = false;
  }

  [Button(null, EButtonEnableMode.Always)]
  public void Save()
  {
    if (this.state == null)
    {
      Debug.LogWarning((object) "Cannot save Battle State right now!");
    }
    else
    {
      Debug.Log((object) "> Saving Battle State...");
      SaveSystem.SaveCampaignData<BattleSaveData>(Campaign.Data.GameMode, "battleState", this.state);
    }
  }

  public void BuildBattleState()
  {
    global::Events.InvokeBattleStateBuild();
    StopWatch.Start();
    if (!this.campaignNodeIdSet)
      this.campaignNodeId = Campaign.FindCharacterNode(References.Battle.player).id;
    this.state = new BattleSaveData()
    {
      gold = References.PlayerData.inventory.gold.Value + References.PlayerData.inventory.goldOwed,
      campaignNodeId = this.campaignNodeId,
      turnCount = References.Battle.turnCount + 1,
      statuses = StatusEffectSystem.activeEffects.Where<StatusEffectData>((Func<StatusEffectData, bool>) (e => (bool) (UnityEngine.Object) e && e.count > e.temporary && (bool) (UnityEngine.Object) e.target && e.target.alive)).Select<StatusEffectData, BattleSaveData.Status>((Func<StatusEffectData, BattleSaveData.Status>) (e => new BattleSaveData.Status(e))).ToArray<BattleSaveData.Status>()
    };
    foreach (StatusEffectData activeEffect in StatusEffectSystem.activeEffects)
    {
      object midBattleData = activeEffect.GetMidBattleData();
      if (midBattleData != null)
        this.state.storeStatusData[string.Format("{0}{1}", (object) activeEffect.target.data.id, (object) activeEffect.name)] = midBattleData;
    }
    RedrawBellSystem objectOfType1 = UnityEngine.Object.FindObjectOfType<RedrawBellSystem>();
    if (objectOfType1 != null)
      this.state.redrawBellCount = objectOfType1.counter.current;
    WaveDeploySystemOverflow objectOfType2 = UnityEngine.Object.FindObjectOfType<WaveDeploySystemOverflow>();
    if (objectOfType2 != null)
      this.state.enemyWaves = objectOfType2.Save();
    BattleMusicSystem objectOfType3 = UnityEngine.Object.FindObjectOfType<BattleMusicSystem>();
    if (objectOfType3 != null)
      this.state.battleMusicState = objectOfType3.Save();
    this.state.playerRows = new BattleSaveData.ContainerGroup((IEnumerable<CardContainer>) References.Battle.GetRows(References.Battle.player));
    this.state.enemyRows = new BattleSaveData.ContainerGroup((IEnumerable<CardContainer>) References.Battle.GetRows(References.Battle.enemy));
    this.state.playerHand = new BattleSaveData.Container(References.Battle.player.handContainer);
    this.state.playerDraw = new BattleSaveData.Container(References.Battle.player.drawContainer);
    this.state.playerDiscard = new BattleSaveData.Container(References.Battle.player.discardContainer);
    this.state.playerReserve = new BattleSaveData.Container(References.Battle.player.reserveContainer);
    this.state.enemyReserve = new BattleSaveData.Container(References.Battle.enemy.reserveContainer);
    Debug.Log((object) string.Format("> Battle State Built ({0}ms)", (object) StopWatch.Stop()));
    global::Events.InvokeBattleStateBuilt(this.state);
  }

  public bool TryLoadBattleState(CampaignNode campaignNode)
  {
    this.state = SaveSystem.LoadCampaignData<BattleSaveData>(Campaign.Data.GameMode, "battleState", (BattleSaveData) null);
    if (this.state == null)
      return false;
    if (this.state.campaignNodeId == campaignNode.id)
      return true;
    this.state = (BattleSaveData) null;
    return false;
  }

  public bool TryLoadBattleState(BattleSaveData state)
  {
    this.state = state;
    return state != null;
  }

  public IEnumerator LoadRoutine()
  {
    this.loading = true;
    References.Battle.loadMidBattle = true;
    References.Battle.turnCount = this.state.turnCount;
    References.PlayerData.inventory.gold.Value = this.state.gold;
    References.Player.entity.PromptUpdate();
    UnityEngine.Object.FindObjectOfType<BattleMusicSystem>()?.Load(this.state.battleMusicState);
    Routine.Clump clump = new Routine.Clump();
    CardSlotLane[] array1 = References.Battle.GetRows(References.Battle.player).Cast<CardSlotLane>().ToArray<CardSlotLane>();
    clump.Add(BattleSaveSystem.CreateCardsInRows((IReadOnlyList<CardSlotLane>) array1, (IReadOnlyList<BattleSaveData.Container>) this.state.playerRows.containers));
    CardSlotLane[] array2 = References.Battle.GetRows(References.Battle.enemy).Cast<CardSlotLane>().ToArray<CardSlotLane>();
    clump.Add(BattleSaveSystem.CreateCardsInRows((IReadOnlyList<CardSlotLane>) array2, (IReadOnlyList<BattleSaveData.Container>) this.state.enemyRows.containers));
    clump.Add(BattleSaveSystem.CreateCards(References.Battle.player.handContainer, (IReadOnlyList<BattleEntityData>) this.state.playerHand.cards));
    clump.Add(BattleSaveSystem.CreateCards(References.Battle.player.drawContainer, (IReadOnlyList<BattleEntityData>) this.state.playerDraw.cards));
    clump.Add(BattleSaveSystem.CreateCards(References.Battle.player.discardContainer, (IReadOnlyList<BattleEntityData>) this.state.playerDiscard.cards));
    clump.Add(BattleSaveSystem.CreateCards(References.Battle.player.reserveContainer, (IReadOnlyList<BattleEntityData>) this.state.playerReserve.cards));
    clump.Add(BattleSaveSystem.CreateCards(References.Battle.enemy.reserveContainer, (IReadOnlyList<BattleEntityData>) this.state.enemyReserve.cards));
    yield return (object) clump.WaitForEnd();
    BattleSaveData.Status[] statusArray = this.state.statuses;
    for (int index = 0; index < statusArray.Length; ++index)
    {
      BattleSaveData.Status status = statusArray[index];
      Entity target = References.Battle.cards.FirstOrDefault<Entity>((Func<Entity, bool>) (a => (long) a.data.id == (long) status.targetId));
      if (!(bool) (UnityEngine.Object) target)
      {
        Debug.LogError((object) string.Format("No Entity[{0}] found for Status ({1} {2})", (object) status.targetId, (object) status.name, (object) status.count));
      }
      else
      {
        target.display.promptUpdateDescription = true;
        Entity applier = References.Battle.cards.FirstOrDefault<Entity>((Func<Entity, bool>) (a => (long) a.data.id == (long) status.applierId));
        StatusEffectData effectData = AddressableLoader.Get<StatusEffectData>("StatusEffectData", status.name);
        if ((bool) (UnityEngine.Object) effectData)
          yield return (object) StatusEffectSystem.Apply(target, applier, effectData, status.count, fireEvents: false);
        else
          Debug.LogError((object) string.Format("Effect [{0}] not found for target ({1} {2})", (object) status.name, (object) target.data.name, (object) status.targetId));
      }
    }
    statusArray = (BattleSaveData.Status[]) null;
    foreach (Entity card in References.Battle.cards.ToList<Entity>())
      yield return (object) BattleSaveSystem.UpdateCard(card, (IReadOnlyDictionary<string, object>) this.state.storeStatusData);
    UnityEngine.Object.FindObjectOfType<WaveDeploySystemOverflow>()?.Load(this.state.enemyWaves, (IReadOnlyCollection<CardData>) References.Battle.cards.Select<Entity, CardData>((Func<Entity, CardData>) (a => a.data)).ToArray<CardData>());
    RedrawBellSystem objectOfType = UnityEngine.Object.FindObjectOfType<RedrawBellSystem>();
    if (objectOfType != null)
    {
      objectOfType.BecomeInteractable();
      objectOfType.SetCounter(this.state.redrawBellCount);
    }
    global::Events.InvokeBattleLoaded();
    this.justLoaded = true;
    this.loading = false;
  }

  public static IEnumerator CreateCardsInRows(
    IReadOnlyList<CardSlotLane> rows,
    IReadOnlyList<BattleSaveData.Container> rowSaveDatas)
  {
    Dictionary<ulong, Entity> entities = new Dictionary<ulong, Entity>();
    CardController cardController = References.Battle.playerCardController;
    Routine.Clump clump = new Routine.Clump();
    for (int rowI = 0; rowI < rows.Count; ++rowI)
    {
      CardSlotLane row = rows[rowI];
      BattleEntityData[] cards = rowSaveDatas[rowI].cards;
      for (int index = 0; index < cards.Length; ++index)
      {
        BattleEntityData d = cards[index];
        if (d != null)
        {
          if (!entities.ContainsKey(d.cardSaveData.id))
          {
            entities.Add(d.cardSaveData.id, (Entity) null);
            int entityIndex = index;
            clump.Add(BattleSaveSystem.CreateCard(d, cardController, row.owner, (UnityAction<Card>) (a =>
            {
              entities[d.cardSaveData.id] = a.entity;
              row.slots[entityIndex].Add(a.entity);
            })));
          }
          else
            row.slots[index].Add(entities[d.cardSaveData.id]);
        }
      }
      yield return (object) clump.WaitForEnd();
    }
    foreach (Entity child in entities.Values)
      child.containers[0].TweenChildPosition(child);
  }

  public static IEnumerator CreateCards(
    CardContainer container,
    IReadOnlyList<BattleEntityData> entitySaveData)
  {
    Character owner = container.owner;
    CardController playerCardController = References.Battle.playerCardController;
    Routine.Clump clump = new Routine.Clump();
    Entity[] entities = new Entity[entitySaveData.Count];
    for (int index = 0; index < entitySaveData.Count; ++index)
    {
      BattleEntityData entityData = entitySaveData[index];
      if (entityData != null)
      {
        int arrayIndex = index;
        clump.Add(BattleSaveSystem.CreateCard(entityData, playerCardController, owner, (UnityAction<Card>) (a => entities[arrayIndex] = a.entity)));
      }
    }
    yield return (object) clump.WaitForEnd();
    foreach (Entity entity in entities)
      container.Add(entity);
    container.SetChildPositions();
  }

  public static IEnumerator CreateCard(
    BattleEntityData entityData,
    CardController cardController,
    Character owner,
    UnityAction<Card> onComplete)
  {
    Card card = CardManager.Get(entityData.cardSaveData.Load(), cardController, owner, true, owner.team == References.Player.team);
    Entity entity = card.entity;
    entity.startingEffectsApplied = true;
    entity.alive = false;
    if (entityData.flipped)
      entity.flipper.FlipDownInstant();
    entity.attackEffects = ((IEnumerable<StatusEffectSaveData>) entityData.attackEffects).Select<StatusEffectSaveData, CardData.StatusEffectStacks>((Func<StatusEffectSaveData, CardData.StatusEffectStacks>) (e => e.Load())).ToList<CardData.StatusEffectStacks>();
    entity.traits.Clear();
    foreach (CardData.TraitStacks trait in entity.data.traits)
    {
      if ((bool) (UnityEngine.Object) trait.data)
        entity.traits.Add(new Entity.TraitStacks(trait.data, trait.count));
    }
    UnityAction<Card> unityAction = onComplete;
    if (unityAction != null)
      unityAction(card);
    if (!entityData.flipped)
      entity.enabled = true;
    yield return (object) card.UpdateData(false);
    entity.height = entityData.height;
    entity.damage.current = entityData.damage;
    entity.damage.max = entityData.damageMax;
    entity.hp.current = entityData.hp;
    entity.hp.max = entityData.hpMax;
    entity.counter.current = entityData.counter;
    entity.counter.max = entityData.counterMax;
    entity.uses.current = entityData.uses;
    entity.uses.max = entityData.usesMax;
  }

  public static IEnumerator UpdateCard(Entity card, IReadOnlyDictionary<string, object> customDatas)
  {
    card.alive = true;
    yield return (object) card.UpdateTraits();
    if (customDatas != null)
    {
      foreach (StatusEffectData statusEffect in card.statusEffects)
      {
        object data;
        if (customDatas.TryGetValue(string.Format("{0}{1}", (object) card.data.id, (object) statusEffect.name), out data))
          statusEffect.RestoreMidBattleData(data);
      }
    }
    if (card.enabled)
    {
      global::Events.InvokeEntityEnabled(card);
      yield return (object) StatusEffectSystem.EntityEnableEvent(card);
    }
    else
      CoroutineManager.Start(card.display.UpdateDisplay());
    card.PromptUpdate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleSetUp
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BattleSetUp : SceneRoutine
{
  [SerializeField]
  [Required(null)]
  public Battle battle;
  [SerializeField]
  public Character enemy;
  [SerializeField]
  public CharacterDisplay enemyCharacterDisplay;
  [SerializeField]
  [Required(null)]
  public BoardDisplay board;
  [SerializeField]
  [Required(null)]
  public CardController cardController;
  [SerializeField]
  public TweenUI startTween;
  [Header("Background")]
  [SerializeField]
  public PrefabLoaderAsync backgroundLoader;
  public CharacterDisplay playerDisplay;

  public override IEnumerator Run()
  {
    Routine updateBackgroundRoutine = new Routine(this.UpdateBackground());
    Character player = References.Player;
    CampaignNode node = Campaign.FindCharacterNode(player);
    this.playerDisplay = (CharacterDisplay) player.entity.display;
    if ((bool) (UnityEngine.Object) this.playerDisplay)
    {
      Debug.Log((object) "BATTLE SET UP");
      this.battle.player = player;
      this.battle.enemy = this.enemy;
      this.board.player = player;
      this.board.enemy = this.enemy;
      this.cardController.owner = player;
      this.battle.rows[player] = new List<CardContainer>();
      this.battle.rows[this.enemy] = new List<CardContainer>();
      yield return (object) null;
      yield return (object) this.board.SetUp(node, this.cardController);
      player.handContainer.AssignController(this.cardController);
      player.handContainer.SetSize(player.data.handSize, player.handContainer.CardScale);
      player.discardContainer.AssignController(this.cardController);
      player.drawContainer.AssignController(this.cardController);
      this.enemyCharacterDisplay.Assign(this.enemy);
    }
    else
      Debug.LogError((object) string.Format("PLAYER [{0}] IS NOT ASSIGNED TO → CharacterDisplay", (object) player));
    yield return (object) new WaitUntil((Func<bool>) (() => !updateBackgroundRoutine.IsRunning));
  }

  public IEnumerator StartAnimation()
  {
    if ((bool) (UnityEngine.Object) this.startTween)
      this.startTween.Fire();
    new Routine.Clump().Add(this.playerDisplay.handOverlay.Show());
    yield return (object) Sequences.Wait(0.1f);
  }

  public IEnumerator UpdateBackground()
  {
    if (Campaign.FindCharacterNode(References.Player).type is CampaignNodeTypeBattle type && type.overrideBackground)
    {
      yield return (object) this.backgroundLoader.Load(type.background);
    }
    else
    {
      AreaData currentArea = References.GetCurrentArea();
      if ((bool) (UnityEngine.Object) currentArea)
        yield return (object) this.backgroundLoader.Load(currentArea.battleBackgroundPrefabRef);
    }
  }

  [Serializable]
  public struct Background
  {
    public string key;
    public GameObject prefab;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleUndoSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class BattleUndoSystem : GameSystem
{
  [SerializeField]
  public BattleSaveSystem battleSaveSystem;
  [SerializeField]
  public GameObject button;

  public void Undo()
  {
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleVictorySequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;

public class BattleVictorySequence : MonoBehaviour
{
  public CanvasGroup fade;
  public float fadeTime = 0.5f;
  public Transform rewardContainer;
  public CardContainer injuredContainer;
  public RectTransform injuredPanel;
  [SerializeField]
  public float startDelay;
  [SerializeField]
  public GameObject winLayout;
  [SerializeField]
  public GameObject injuriesLayout;
  [SerializeField]
  public GameObject[] disableGapsForInjuries;
  [SerializeField]
  public GameObject continueLayout;
  public bool active;

  public IEnumerator Run()
  {
    BattleVictorySequence battleVictorySequence = this;
    battleVictorySequence.active = true;
    yield return (object) new WaitForSeconds(battleVictorySequence.startDelay);
    battleVictorySequence.winLayout.SetActive(true);
    yield return (object) new WaitForSeconds(0.75f);
    yield return (object) battleVictorySequence.RevealInjuries();
    battleVictorySequence.continueLayout.SetActive(true);
    yield return (object) new WaitUntil(new Func<bool>(battleVictorySequence.\u003CRun\u003Eb__11_0));
  }

  public IEnumerator RevealInjuries()
  {
    CardData[] injuriesThisBattle = InjurySystem.GetInjuriesThisBattle();
    if (injuriesThisBattle != null && injuriesThisBattle.Length > 0)
    {
      SfxSystem.OneShot("event:/sfx/ui/injuries_showup");
      this.injuredContainer.SetSize(injuriesThisBattle.Length, 0.6f);
      CardData[] cardDataArray = injuriesThisBattle;
      for (int index = 0; index < cardDataArray.Length; ++index)
      {
        Card card = CardManager.Get(cardDataArray[index], (CardController) null, (Character) null, false, true);
        this.injuredContainer.Add(card.entity);
        yield return (object) card.UpdateData(false);
      }
      cardDataArray = (CardData[]) null;
      this.injuredPanel.sizeDelta = this.injuredContainer.GetComponent<RectTransform>().sizeDelta + new Vector2(6f, 1.5f);
      this.injuredContainer.SetChildPositions();
      foreach (GameObject disableGapsForInjury in this.disableGapsForInjuries)
        disableGapsForInjury.SetActive(false);
      this.injuriesLayout.SetActive(true);
      yield return (object) new WaitForSeconds(0.75f);
    }
  }

  public bool CharacterDeckpackOpen(Character character)
  {
    bool flag = false;
    if ((UnityEngine.Object) character.entity?.display != (UnityEngine.Object) null && character.entity.display is CharacterDisplay display)
      flag = display.IsDeckpackOpen;
    return flag;
  }

  public void End() => this.active = false;

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__11_0() => !this.active;
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleWaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;

[Serializable]
public class BattleWaveData
{
  public List<ulong> deployed;
  public int counter;
  public int counterMax;
  public int currentWave;
  public int overflowWaveIndex;
  public BattleWaveData.Wave[] waves;

  [Serializable]
  public class Wave
  {
    public int counter;
    public ulong[] unitIds;
    public bool isBossWave;
    public bool spawned;

    public Wave()
    {
    }

    public Wave(BattleWaveManager.Wave wave)
    {
      this.counter = wave.counter;
      this.unitIds = wave.units.Where<CardData>((Func<CardData, bool>) (a => (bool) (UnityEngine.Object) a)).Select<CardData, ulong>((Func<CardData, ulong>) (a => a.id)).ToArray<ulong>();
      this.isBossWave = wave.isBossWave;
      this.spawned = wave.spawned;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleWaveManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;

public class BattleWaveManager : MonoBehaviour
{
  public List<BattleWaveManager.Wave> list;
  public Queue<Entity[]> remainingWaves;

  public void AddWave(BattleWaveManager.Wave wave)
  {
    if (this.list == null)
      this.list = new List<BattleWaveManager.Wave>();
    this.list.Add(wave);
    Debug.Log((object) string.Format("\"{0}\" Added", (object) wave));
  }

  public void AddEntities(Entity[] entities)
  {
    if (this.remainingWaves == null)
      this.remainingWaves = new Queue<Entity[]>();
    this.remainingWaves.Enqueue(entities);
  }

  public Entity[] Pull() => this.remainingWaves.Dequeue();

  public Entity[] Peek() => this.remainingWaves.Peek();

  [Serializable]
  public class Wave
  {
    public int counter;
    public List<CardData> units;
    public bool isBossWave;
    public bool spawned;

    public Wave()
    {
    }

    public Wave(BattleWaveManager.WaveData data)
    {
      this.counter = data.counter;
      this.units = new List<CardData>();
      int count = data.Count;
      for (int index = 0; index < count; ++index)
        this.units.Add(data.GetCardData(index));
      this.isBossWave = data.isBossWave;
    }

    public override string ToString() => string.Format("Wave ({0}) counter: {1}", (object) string.Join<CardData>(", ", (IEnumerable<CardData>) this.units), (object) this.counter);
  }

  [Serializable]
  public abstract class WaveData
  {
    public int counter;
    public bool isBossWave;

    public virtual int Count => 0;

    public abstract void AddCard(CardData card);

    public abstract void InsertCard(int index, CardData card);

    public abstract CardData GetCardData(int index);

    public abstract string GetCardName(int index);

    public abstract CardData PeekCardData(int index);

    public abstract bool AddUpgradeToCard(int index, CardUpgradeData upgradeData);
  }

  [Serializable]
  public class WaveDataBasic : BattleWaveManager.WaveData
  {
    public BattleWaveManager.Card[] cards;

    public override int Count => this.cards.Length;

    public override void AddCard(CardData card)
    {
      List<BattleWaveManager.Card> list = this.cards.ToList<BattleWaveManager.Card>();
      list.Add(new BattleWaveManager.Card(card.name));
      this.cards = list.ToArray();
    }

    public override void InsertCard(int index, CardData card)
    {
      List<BattleWaveManager.Card> list = this.cards.ToList<BattleWaveManager.Card>();
      list.Insert(index, new BattleWaveManager.Card(card.name));
      this.cards = list.ToArray();
    }

    public override CardData GetCardData(int index)
    {
      BattleWaveManager.Card card = this.cards[index];
      CardData cardDataClone = AddressableLoader.GetCardDataClone(card.cardName);
      if (card.upgradeNames != null)
      {
        foreach (string upgradeName in card.upgradeNames)
        {
          CardUpgradeData cardUpgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", upgradeName);
          if ((bool) (UnityEngine.Object) cardUpgradeData)
            cardUpgradeData.Clone().Assign(cardDataClone);
        }
      }
      return cardDataClone;
    }

    public override CardData PeekCardData(int index) => AddressableLoader.Get<CardData>("CardData", this.cards[index].cardName);

    public override string GetCardName(int index) => this.cards[index].cardName;

    public override bool AddUpgradeToCard(int index, CardUpgradeData upgradeData)
    {
      BattleWaveManager.Card card = this.cards[index];
      CardData cardData = AddressableLoader.Get<CardData>("CardData", card.cardName);
      if (!(bool) (UnityEngine.Object) cardData || !upgradeData.CanAssign(cardData))
        return false;
      card.AddUpgrade(upgradeData.name);
      return true;
    }

    public BattleWaveManager.Card Get(int index) => this.cards[index];

    public BattleWaveManager.WaveDataFull ConvertToFull()
    {
      BattleWaveManager.WaveDataFull full = new BattleWaveManager.WaveDataFull();
      List<CardSaveData> list = new List<CardSaveData>();
      for (int index = 0; index < this.cards.Length; ++index)
        list.AddIfNotNull<CardSaveData>(new CardSaveData(this.PeekCardData(index)));
      full.cardDatas = list.ToArray();
      for (int index = 0; index < this.cards.Length; ++index)
      {
        BattleWaveManager.Card card = this.cards[index];
        CardSaveData cardData = full.cardDatas[index];
        List<CardUpgradeSaveData> cardUpgradeSaveDataList = new List<CardUpgradeSaveData>();
        foreach (string upgradeName in card.upgradeNames)
          cardUpgradeSaveDataList.Add(new CardUpgradeSaveData(upgradeName));
        cardData.upgrades = cardUpgradeSaveDataList.ToArray();
      }
      return full;
    }
  }

  [Serializable]
  public class WaveDataFull : BattleWaveManager.WaveData
  {
    public CardSaveData[] cardDatas;

    public override int Count => this.cardDatas.Length;

    public override void AddCard(CardData card)
    {
      List<CardSaveData> list = this.cardDatas.ToList<CardSaveData>();
      list.Add(new CardSaveData(card));
      this.cardDatas = list.ToArray();
    }

    public override void InsertCard(int index, CardData card)
    {
      List<CardSaveData> list = this.cardDatas.ToList<CardSaveData>();
      list.Insert(index, new CardSaveData(card));
      this.cardDatas = list.ToArray();
    }

    public override CardData GetCardData(int index) => this.cardDatas[index].Load(false);

    public override CardData PeekCardData(int index) => AddressableLoader.Get<CardData>("CardData", this.cardDatas[index].name);

    public override string GetCardName(int index) => this.cardDatas[index].name;

    public override bool AddUpgradeToCard(int index, CardUpgradeData upgradeData)
    {
      bool card = false;
      CardData cardData = this.cardDatas[index].Load(false);
      if (upgradeData.CanAssign(cardData))
      {
        upgradeData.Assign(cardData);
        this.cardDatas[index] = new CardSaveData(cardData);
        card = true;
      }
      return card;
    }
  }

  [Serializable]
  public class Card
  {
    public string cardName;
    public List<string> upgradeNames;

    public Card()
    {
    }

    public Card(string cardName) => this.cardName = cardName;

    public void AddUpgrade(string upgradeName)
    {
      if (this.upgradeNames == null)
        this.upgradeNames = new List<string>();
      this.upgradeNames.Add(upgradeName);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BattleWavePoolData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Battle Wave Pool Data", menuName = "Battle Wave Pool")]
public class BattleWavePoolData : ScriptableObject
{
  [Range(1f, 5f)]
  public int weight = 1;
  public int forcePulls;
  public int maxPulls = 999;
  public BattleWavePoolData.Wave[] waves;
  public int pullCount;
  public List<BattleWavePoolData.Wave> workingList;

  public bool CanPull() => this.pullCount < this.maxPulls;

  public bool MustPull() => this.pullCount < this.forcePulls;

  public BattleWavePoolData.Wave Pull()
  {
    if (this.workingList == null)
      this.workingList = new List<BattleWavePoolData.Wave>();
    if (this.workingList.Count <= 0)
      this.workingList.AddRange((IEnumerable<BattleWavePoolData.Wave>) this.waves);
    int index = this.workingList.Count > 0 ? this.workingList.RandomIndex<BattleWavePoolData.Wave>() : throw new Exception("BattleWavePoolData \"waves\" list is empty!");
    BattleWavePoolData.Wave working = this.workingList[index];
    this.workingList.RemoveAt(index);
    ++this.pullCount;
    return working;
  }

  public void Reset()
  {
    this.pullCount = 0;
    this.workingList = (List<BattleWavePoolData.Wave>) null;
  }

  [Serializable]
  public struct Wave
  {
    public List<CardData> units;
    public int value;
    public int positionPriority;
    public bool fixedOrder;
    public int maxSize;

    public bool CanAddTo() => this.maxSize <= 0 || this.units.Count < this.maxSize;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BellRinger
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using FMODUnity;
using NaughtyAttributes;
using UnityEngine;

public class BellRinger : MonoBehaviour
{
  public TweenUI[] ringTweens;
  public bool playRingSfx = true;
  [SerializeField]
  [ShowIf("playRingSfx")]
  public EventReference ringSfxEvent;
  [SerializeField]
  [ShowIf("playRingSfx")]
  public Vector2 ringSfxPitch = new Vector2(1f, 1f);

  public void Ring()
  {
    foreach (TweenUI ringTween in this.ringTweens)
      ringTween.Fire();
    if (!this.playRingSfx)
      return;
    this.PlayRingSfx();
  }

  public void PlayRingSfx()
  {
    if (this.ringSfxEvent.IsNull)
      return;
    int num = (int) SfxSystem.OneShot(this.ringSfxEvent).setPitch(this.ringSfxPitch.PettyRandom() * PettyRandom.Range(0.95f, 1.05f));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Bezier
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[RequireComponent(typeof (LineRenderer))]
public class Bezier : MonoBehaviour
{
  public LineRenderer lineRenderer;
  public int quality = 30;

  public int pointCount => this.lineRenderer.positionCount;

  public Vector3 GetPoint(int index) => this.lineRenderer.GetPosition(index);

  public void Start()
  {
    if (this.lineRenderer != null)
      return;
    this.lineRenderer = this.GetComponent<LineRenderer>();
  }

  public void UpdateCurve(Vector3 p0, Vector3 p1, Vector3 p2)
  {
    this.lineRenderer.positionCount = this.quality + 1;
    this.lineRenderer.SetPosition(0, p0);
    for (int index = 1; index <= this.quality; ++index)
    {
      Vector3 position = this.Calculate((float) index / (float) this.quality, p0, p1, p2);
      this.lineRenderer.SetPosition(index, position);
    }
  }

  public void UpdateCurve(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
  {
    this.lineRenderer.positionCount = this.quality + 1;
    this.lineRenderer.SetPosition(0, p0);
    for (int index = 1; index <= this.quality; ++index)
    {
      Vector3 position = this.Calculate((float) index / (float) this.quality, p0, p1, p2, p3);
      this.lineRenderer.SetPosition(index, position);
    }
  }

  public Vector3 Calculate(float t, Vector3 p0, Vector3 p1, Vector3 p2)
  {
    float num1 = 1f - t;
    double num2 = (double) num1 * (double) num1;
    float num3 = t * t;
    Vector3 vector3 = p0;
    return (float) num2 * vector3 + 2f * num1 * t * p1 + num3 * p2;
  }

  public Vector3 Calculate(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
  {
    float num1 = 1f - t;
    float num2 = t * t;
    float num3 = num1 * num1;
    double num4 = (double) num3 * (double) num1;
    float num5 = num2 * t;
    Vector3 vector3 = p0;
    return (float) num4 * vector3 + 3f * num3 * t * p1 + 3f * num1 * num2 * p2 + num5 * p3;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BlessingData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public class BlessingData
{
  public GameModifierData modifierToAdd;

  public void Select()
  {
    ModifierSystem.AddModifier(Campaign.Data, this.modifierToAdd);
    Routine.Clump clump = new Routine.Clump();
    foreach (Script startScript in this.modifierToAdd.startScripts)
      clump.Add(startScript.Run());
    foreach (Script setupScript in this.modifierToAdd.setupScripts)
      clump.Add(setupScript.Run());
    foreach (string componentName in this.modifierToAdd.systemsToAdd)
    {
      Debug.Log((object) string.Format("[{0}] adding system: {1}", (object) this.modifierToAdd, (object) componentName));
      Campaign.instance.gameObject.AddComponentByName(componentName);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BlessingSelect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization.Components;

public class BlessingSelect : MonoBehaviour
{
  [SerializeField]
  public InputAction inputAction;
  [SerializeField]
  public ImageSprite bellImage;
  [SerializeField]
  public ImageSprite dingerImage;
  [SerializeField]
  public LocalizeStringEvent titleString;
  [SerializeField]
  public LocalizeStringEvent descString;

  public void SetUp(BlessingData blessingData, GainBlessingSequence gainBlessingSequence)
  {
    this.inputAction.action.AddListener((UnityAction) (() => gainBlessingSequence.SelectBlessing(blessingData)));
    this.bellImage.SetSprite(blessingData.modifierToAdd.bellSprite);
    this.dingerImage.SetSprite(blessingData.modifierToAdd.dingerSprite);
    this.titleString.StringReference = blessingData.modifierToAdd.titleKey;
    this.descString.StringReference = blessingData.modifierToAdd.descriptionKey;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BlingParticle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using UnityEngine;

[RequireComponent(typeof (SpriteRenderer))]
public class BlingParticle : MonoBehaviour
{
  public BlingParticleSystem system;
  public Character owner;
  public int value = 1;
  [SerializeField]
  public Vector2 sizeRange = new Vector2(0.7f, 0.9f);
  [SerializeField]
  public Vector2 angleRange = new Vector2(-20f, 20f);
  [SerializeField]
  public Vector3 groundRotation = new Vector3(20f, 0.0f, 0.0f);
  [SerializeField]
  public Vector2 bounceRange = new Vector2(0.35f, 0.45f);
  [SerializeField]
  public Vector2 bounceSlowdownRange = new Vector2(0.75f, 0.85f);
  [SerializeField]
  public Vector2 flyToBagRange = new Vector2(2f, 2.5f);
  [SerializeField]
  public Vector2 startSpeedRange = new Vector2(1f, 2f);
  [SerializeField]
  public Vector2 startUpSpeedRange = new Vector2(0.0f, 1f);
  [SerializeField]
  public Vector2 frictMultRange = new Vector2(0.94f, 0.96f);
  [SerializeField]
  public float grav = 10f;
  [SerializeField]
  public Vector2 groundOffsetRange = new Vector2(0.5f, 1f);
  [SerializeField]
  public bool startTimerWhenOnGround = true;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float zInfluence = 0.5f;
  [SerializeField]
  public float flyToBagSpeed = 1f;
  [SerializeField]
  public float flyMaxSpeed = 10f;
  public float worldGroundY;
  public float bounce;
  public float bounceSlowdown;
  public float flyToBag;
  public Vector3 velocity;
  public float frictMult;
  public bool onGround;
  public GoldDisplay targetBag;
  public SpriteRenderer _spr;

  public SpriteRenderer spr => this._spr ?? (this._spr = this.GetComponent<SpriteRenderer>());

  public Sprite sprite
  {
    set => this.spr.sprite = value;
  }

  public string sortingLayer
  {
    set => this.spr.sortingLayerName = value;
  }

  public void OnEnable()
  {
    this.sortingLayer = "ParticlesBehind";
    this.onGround = false;
    this.targetBag = (GoldDisplay) null;
    float num = this.sizeRange.PettyRandom();
    this.bounce = this.bounceRange.PettyRandom();
    this.bounceSlowdown = this.bounceSlowdownRange.PettyRandom();
    this.flyToBag = this.flyToBagRange.PettyRandom();
    this.frictMult = this.frictMultRange.PettyRandom();
    this.transform.localScale = new Vector3(num, num, 1f);
    this.transform.localEulerAngles = this.groundRotation.WithZ(this.angleRange.PettyRandom());
    this.worldGroundY = this.transform.position.y - this.groundOffsetRange.PettyRandom();
    this.spr.flipX = (PettyRandom.Choose<bool>(true, false) ? 1 : 0) != 0;
    this.velocity = new Vector3(PettyRandom.Range(-1f, 1f), PettyRandom.Range(-1f, 1f), 0.0f).normalized * this.startSpeedRange.PettyRandom();
    this.velocity.y += this.startUpSpeedRange.PettyRandom();
  }

  public void Update()
  {
    Vector3 vector3_1 = this.transform.localPosition + this.velocity * Time.deltaTime;
    if ((bool) (Object) this.targetBag)
    {
      Vector3 vector3_2 = this.targetBag.transform.position - this.transform.position;
      this.velocity += vector3_2 * (this.flyToBagSpeed * Time.deltaTime);
      if ((double) vector3_2.sqrMagnitude < 0.10000000149011612)
        this.Collect();
      else if ((double) this.velocity.magnitude > (double) this.flyMaxSpeed)
        this.velocity = vector3_2.normalized * this.flyMaxSpeed;
    }
    else
    {
      if (!this.onGround && (double) this.velocity.y <= 0.0 && (double) vector3_1.y <= (double) this.worldGroundY)
      {
        this.velocity.y *= -this.bounce;
        this.velocity.x *= this.bounceSlowdown;
        if ((double) Mathf.Abs(this.velocity.y) < 0.05000000074505806)
        {
          this.velocity.y = 0.0f;
          this.onGround = true;
        }
        vector3_1.y = this.worldGroundY;
      }
      if ((double) this.zInfluence > 0.0)
        vector3_1.z -= this.velocity.y * this.zInfluence * Time.deltaTime;
      this.velocity.x = Delta.Multiply(this.velocity.x, this.frictMult, Time.deltaTime);
      if (!this.onGround)
        this.velocity.y -= this.grav * Time.deltaTime;
      else if ((double) vector3_1.y != (double) this.worldGroundY)
        this.onGround = false;
      if (!this.startTimerWhenOnGround || this.onGround)
      {
        this.flyToBag -= Time.deltaTime;
        if ((double) this.flyToBag <= 0.0)
          this.FlyToBag();
      }
    }
    this.transform.localPosition = vector3_1;
  }

  public void FlyToBag()
  {
    if (this.owner.entity.display is CharacterDisplay display && (Object) display.goldDisplay != (Object) null)
    {
      this.targetBag = display.goldDisplay;
      this.sortingLayer = "ParticlesFront";
      Events.InvokeGoldFlyToBag(this.value, this.owner, this.transform.position);
    }
    else
      this.Collect();
  }

  public void Collect()
  {
    this.owner.GainGold(this.value);
    this.ReturnToPool();
    Events.InvokeCollectGold(this.value);
  }

  public void ReturnToPool() => this.system.Pool(this);
}
﻿// Decompiled with JetBrains decompiler
// Type: BlingParticleSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class BlingParticleSystem : GameSystem
{
  [SerializeField]
  public BlingParticle blingPrefab;
  [SerializeField]
  public int initialPoolSize = 20;
  [SerializeField]
  public Sprite lowValueSprite;
  [SerializeField]
  public Sprite highValueSprite;
  [SerializeField]
  public int highValueAmount = 5;
  public readonly Queue<BlingParticle> pool = new Queue<BlingParticle>();

  public void Start()
  {
    for (int index = 0; index < this.initialPoolSize; ++index)
      this.Pool(Object.Instantiate<BlingParticle>(this.blingPrefab, this.transform));
  }

  public void OnEnable() => global::Events.OnDropGold += new UnityAction<int, string, Character, Vector3>(this.DropGold);

  public void OnDisable() => global::Events.OnDropGold -= new UnityAction<int, string, Character, Vector3>(this.DropGold);

  public void DropGold(int amount, string source, Character owner, Vector3 position)
  {
    int num = PettyRandom.Range(3, 5);
    owner.data.inventory.goldOwed += amount;
    BlingParticle blingParticle;
    for (; amount > 0; amount -= blingParticle.value)
    {
      blingParticle = this.Get();
      blingParticle.transform.position = position;
      blingParticle.gameObject.SetActive(true);
      blingParticle.owner = owner;
      if (num > 0 || amount < this.highValueAmount)
      {
        blingParticle.value = 1;
        blingParticle.sprite = this.lowValueSprite;
        --num;
      }
      else
      {
        blingParticle.value = this.highValueAmount;
        blingParticle.sprite = this.highValueSprite;
      }
    }
  }

  public BlingParticle Get() => this.pool.Count > 0 ? this.pool.Dequeue() : Object.Instantiate<BlingParticle>(this.blingPrefab, this.transform);

  public void Pool(BlingParticle particle)
  {
    particle.gameObject.SetActive(false);
    this.pool.Enqueue(particle);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Blink
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using DeadExtensions;
using UnityEngine;

public class Blink : MonoBehaviour
{
  public Vector2 onRange = new Vector2(5f, 6f);
  public Vector2 offRange = new Vector2(0.1f, 0.1f);
  public AnimationCurve blinkCurve;
  public AnimationCurve unblinkCurve;
  public float blinkCurveDuration = 0.1f;
  [SerializeField]
  public bool startOn = true;
  public bool on;
  public float timer;
  public float preScaleY;

  public void Awake()
  {
    this.on = this.startOn;
    if (this.on)
    {
      this.timer = this.onRange.PettyRandom() * PettyRandom.value;
    }
    else
    {
      Transform transform = this.transform;
      Vector3 localScale = transform.localScale;
      this.preScaleY = localScale.y;
      localScale.y = 0.0f;
      transform.localScale = localScale;
      this.timer = this.offRange.PettyRandom() * PettyRandom.value;
    }
  }

  public void Update()
  {
    this.timer -= Time.deltaTime;
    if ((double) this.timer > 0.0)
      return;
    this.Toggle();
  }

  public void Toggle()
  {
    this.on = !this.on;
    LeanTween.cancel(this.gameObject);
    if (this.on)
    {
      LeanTween.scaleY(this.gameObject, this.preScaleY, this.blinkCurveDuration).setEase(this.unblinkCurve);
    }
    else
    {
      this.preScaleY = this.transform.localScale.y;
      LeanTween.scaleY(this.gameObject, 0.0f, this.blinkCurveDuration).setEase(this.blinkCurve);
    }
    if (this.on)
      this.timer = this.onRange.PettyRandom();
    else
      this.timer = this.offRange.PettyRandom();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BlockForMinibossesModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class BlockForMinibossesModifierSystem : GameSystem
{
  public const float healthFactor = 0.75f;
  public const float blockPerHealthLost = 0.25f;
  public static StatusEffectData _effect;

  public static StatusEffectData effect => BlockForMinibossesModifierSystem._effect ?? (BlockForMinibossesModifierSystem._effect = AddressableLoader.Get<StatusEffectData>("StatusEffectData", "Block"));

  public void OnEnable() => global::Events.OnCardDataCreated += new UnityAction<CardData>(BlockForMinibossesModifierSystem.CardDataCreated);

  public void OnDisable() => global::Events.OnCardDataCreated -= new UnityAction<CardData>(BlockForMinibossesModifierSystem.CardDataCreated);

  public static void CardDataCreated(CardData cardData)
  {
    if (!(cardData.cardType.name == "Miniboss") || !cardData.hasHealth)
      return;
    int hp1 = cardData.hp;
    cardData.hp = Mathf.CeilToInt((float) cardData.hp * 0.75f);
    int hp2 = cardData.hp;
    int count = Mathf.Max(1, Mathf.CeilToInt((float) (hp1 - hp2) * 0.25f));
    cardData.startWithEffects = CardData.StatusEffectStacks.Stack((IEnumerable<CardData.StatusEffectStacks>) cardData.startWithEffects, (IEnumerable<CardData.StatusEffectStacks>) new CardData.StatusEffectStacks[1]
    {
      new CardData.StatusEffectStacks(BlockForMinibossesModifierSystem.effect, count)
    });
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BloodProfile
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

[CreateAssetMenu(fileName = "Blood Profile", menuName = "Blood Profile")]
public class BloodProfile : ScriptableObject
{
  public bool variableColor;
  [HideIf("variableColor")]
  public Color color;
  [ShowIf("variableColor")]
  public Gradient colorRange;
  [Range(0.0f, 2f)]
  public float bleedFactor = 1f;
  public SplatterParticle splatterParticlePrefab;
}
﻿// Decompiled with JetBrains decompiler
// Type: BlurManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class BlurManager : MonoBehaviour
{
  [SerializeField]
  public Camera blurCamera;
  [SerializeField]
  public Material blurMaterial;

  public void Start()
  {
    if ((Object) this.blurCamera.targetTexture != (Object) null)
      this.blurCamera.targetTexture.Release();
    this.blurCamera.targetTexture = new RenderTexture(Screen.width, Screen.height, 24, RenderTextureFormat.ARGB32, 1);
    this.blurMaterial.SetTexture("_MainTex", (Texture) this.blurCamera.targetTexture);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BoardDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.UI;

public class BoardDisplay : MonoBehaviour
{
  public Character player;
  public Character enemy;
  public int playerRowLength = 3;
  public int enemyRowLength = 3;
  [Range(0.0f, 1f)]
  public float cardScale = 0.333333343f;
  [SerializeField]
  public LayoutGroup layout;
  [Header("Card Container References")]
  public CardContainer playerReserve;
  public CardContainer[] playerRows;
  public CardContainer enemyReserve;
  public CardContainer[] enemyRows;

  public IEnumerator SetUp(CampaignNode node, CardController cardController)
  {
    this.layout.enabled = false;
    if ((Object) this.playerReserve != (Object) null)
    {
      this.playerReserve.owner = this.player;
      this.player.reserveContainer = this.playerReserve;
      this.playerReserve.SetSize(999, this.cardScale);
      this.playerReserve.AssignController(cardController);
    }
    if ((Object) this.enemyReserve != (Object) null)
    {
      this.enemyReserve.owner = this.enemy;
      this.enemy.reserveContainer = this.enemyReserve;
      this.enemyReserve.SetSize(999, this.cardScale);
      this.enemyReserve.AssignController(cardController);
    }
    for (int index = 0; index < this.playerRows.Length; ++index)
    {
      CardContainer playerRow = this.playerRows[index];
      playerRow.owner = this.player;
      playerRow.SetSize(this.playerRowLength, this.cardScale);
      playerRow.AssignController(cardController);
      if (playerRow is CardSlotLane cardSlotLane)
        cardSlotLane.SetDirection(1);
      References.Battle.rows[this.player].Add(playerRow);
      References.Battle.rowIndices[playerRow] = index;
    }
    for (int index = 0; index < this.enemyRows.Length; ++index)
    {
      CardContainer enemyRow = this.enemyRows[index];
      enemyRow.owner = this.enemy;
      enemyRow.SetSize(this.enemyRowLength, this.cardScale);
      enemyRow.AssignController(cardController);
      if (enemyRow is CardSlotLane cardSlotLane)
        cardSlotLane.SetDirection(-1);
      References.Battle.rows[this.enemy].Add(enemyRow);
      References.Battle.rowIndices[enemyRow] = index;
    }
    yield return (object) null;
    this.layout.enabled = true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Bolgo
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class Bolgo : ScriptableCardImage
{
  [SerializeField]
  public Image image;
  [Header("Scale Based On Damage")]
  [SerializeField]
  public AnimationCurve scaleCurve;
  [SerializeField]
  public AnimationCurve tweenCurve;
  [SerializeField]
  public float tweenDur;
  [Header("Set Sprite Based On Shell")]
  [SerializeField]
  public Sprite[] sprites;
  [SerializeField]
  public AnimationCurve spriteIndexCurve;
  public int currentShell;
  public bool currentDamageSet;
  public int currentDamage;
  public float scaleFrom = 1f;
  public float scaleTo = 1f;
  public float tweenT;
  public bool tween;

  public override void UpdateEvent()
  {
    if (!this.currentDamageSet || this.currentDamage != this.entity.damage.current)
    {
      this.currentDamageSet = true;
      this.currentDamage = this.entity.damage.current;
      this.SetScale();
    }
    StatusEffectData status = this.entity.FindStatus("shell");
    int count = status != null ? status.count : 0;
    if (count == this.currentShell)
      return;
    this.currentShell = count;
    this.image.sprite = this.sprites[Mathf.RoundToInt(Mathf.Clamp(this.spriteIndexCurve.Evaluate((float) this.currentShell), 0.0f, 1f) * ((float) this.sprites.Length - 1f))];
  }

  public void SetScale()
  {
    this.scaleFrom = Mathf.Lerp(1f, this.image.transform.localScale.x, 0.5f);
    this.scaleTo = this.scaleCurve.Evaluate((float) this.currentDamage);
    this.StartScaleTween();
  }

  public void StartScaleTween()
  {
    this.tween = true;
    this.tweenT = 0.0f;
  }

  public void Update()
  {
    if (!this.tween)
      return;
    this.tweenT += Time.deltaTime / this.tweenDur;
    float num = this.scaleFrom + this.tweenCurve.Evaluate(this.tweenT) * (this.scaleTo - this.scaleFrom);
    this.image.transform.localScale = new Vector3(num, num, 1f);
    if ((double) this.tweenT <= 1.0)
      return;
    this.tween = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BombardRocket
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class BombardRocket : MonoBehaviour
{
  [SerializeField]
  public ParticleSystem rocketTrail;
  [SerializeField]
  public GameObject rocket;
  [SerializeField]
  public ParticleSystem explosion;
  [SerializeField]
  public float explosionShakeAmount = 2f;

  public void Explode() => this.StartCoroutine(this.ExplodeRoutine());

  public IEnumerator ExplodeRoutine()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    BombardRocket bombardRocket = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      bombardRocket.gameObject.Destroy();
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    bombardRocket.rocketTrail.Stop(true, ParticleSystemStopBehavior.StopEmitting);
    bombardRocket.rocket.Destroy();
    bombardRocket.explosion.Play();
    Events.InvokeScreenShake(bombardRocket.explosionShakeAmount, new float?(180f));
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) new WaitForSeconds(4f);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BombskullClunkersModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class BombskullClunkersModifierSystem : GameSystem
{
  public static CardUpgradeData _upgradeData;
  public readonly List<ulong> ids = new List<ulong>();

  public static CardUpgradeData upgradeData => BombskullClunkersModifierSystem._upgradeData ?? (BombskullClunkersModifierSystem._upgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", "CardUpgradeBombskull"));

  public void OnEnable()
  {
    global::Events.OnCardDataCreated += new UnityAction<CardData>(this.CardDataCreated);
    global::Events.OnEntityCreated += new UnityAction<Entity>(this.EntityCreated);
  }

  public void OnDisable()
  {
    global::Events.OnCardDataCreated -= new UnityAction<CardData>(this.CardDataCreated);
    global::Events.OnEntityCreated -= new UnityAction<Entity>(this.EntityCreated);
  }

  public void CardDataCreated(CardData cardData)
  {
    if (!(cardData.cardType.name == "Clunker"))
      return;
    this.ids.Add(cardData.id);
  }

  public void EntityCreated(Entity entity)
  {
    if (!this.ids.Contains(entity.data.id))
      return;
    this.ids.Remove(entity.data.id);
    if (!(bool) (Object) entity.owner || entity.owner.team != References.Player.team)
      return;
    BombskullClunkersModifierSystem.upgradeData.Clone().Assign(entity.data);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BoostAllEffectsModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Events;

public class BoostAllEffectsModifierSystem : GameSystem
{
  public const int add = 1;

  public void OnEnable() => global::Events.OnCardDataCreated += new UnityAction<CardData>(BoostAllEffectsModifierSystem.CardDataCreated);

  public void OnDisable() => global::Events.OnCardDataCreated -= new UnityAction<CardData>(BoostAllEffectsModifierSystem.CardDataCreated);

  public static void CardDataCreated(CardData cardData)
  {
    foreach (CardData.StatusEffectStacks statusEffectStacks in ((IEnumerable<CardData.StatusEffectStacks>) cardData.attackEffects).Where<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (e => e.data.stackable)))
      ++statusEffectStacks.count;
    foreach (CardData.StatusEffectStacks statusEffectStacks in ((IEnumerable<CardData.StatusEffectStacks>) cardData.startWithEffects).Where<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (e => !e.data.isStatus && e.data.canBeBoosted)))
      ++statusEffectStacks.count;
    foreach (CardData.TraitStacks traitStacks in cardData.traits.Where<CardData.TraitStacks>((Func<CardData.TraitStacks, bool>) (t => t.data.keyword.canStack)))
      ++traitStacks.count;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BoostAllHealthModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine.Events;

public class BoostAllHealthModifierSystem : GameSystem
{
  public const int healthAdd = 2;

  public void OnEnable() => global::Events.OnCardDataCreated += new UnityAction<CardData>(BoostAllHealthModifierSystem.CardDataCreated);

  public void OnDisable() => global::Events.OnCardDataCreated -= new UnityAction<CardData>(BoostAllHealthModifierSystem.CardDataCreated);

  public static void CardDataCreated(CardData cardData)
  {
    if (!(cardData.cardType.name == "Friendly") || !cardData.hasHealth)
      return;
    cardData.hp += 2;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BoostArea2EnemyDamageModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine.Events;

public class BoostArea2EnemyDamageModifierSystem : GameSystem
{
  public const int area = 1;
  public const int damageAdd = 1;
  public bool correctArea;

  public void OnEnable()
  {
    global::Events.PreBattleSetUp += new UnityAction<CampaignNode>(this.PreBattleSetUp);
    global::Events.PostBattleSetUp += new UnityAction<CampaignNode>(this.PostBattleSetUp);
  }

  public void OnDisable()
  {
    global::Events.PreBattleSetUp -= new UnityAction<CampaignNode>(this.PreBattleSetUp);
    global::Events.PostBattleSetUp -= new UnityAction<CampaignNode>(this.PostBattleSetUp);
  }

  public void PreBattleSetUp(CampaignNode node)
  {
    this.correctArea = node.areaIndex == 1;
    if (!this.correctArea)
      return;
    global::Events.OnCardDataCreated += new UnityAction<CardData>(this.CardDataCreated);
  }

  public void PostBattleSetUp(CampaignNode node)
  {
    if (this.correctArea)
      global::Events.OnCardDataCreated -= new UnityAction<CardData>(this.CardDataCreated);
    this.correctArea = false;
  }

  public void CardDataCreated(CardData cardData)
  {
    if (!this.correctArea)
      return;
    string name = cardData.cardType.name;
    if (!(name == "Enemy") && !(name == "Miniboss") && !(name == "Boss") || !cardData.hasAttack)
      return;
    ++cardData.damage;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BoostArea3EnemyDamageModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine.Events;

public class BoostArea3EnemyDamageModifierSystem : GameSystem
{
  public const int area = 2;
  public const int damageAdd = 1;
  public bool correctArea;

  public void OnEnable()
  {
    global::Events.PreBattleSetUp += new UnityAction<CampaignNode>(this.PreBattleSetUp);
    global::Events.PostBattleSetUp += new UnityAction<CampaignNode>(this.PostBattleSetUp);
  }

  public void OnDisable()
  {
    global::Events.PreBattleSetUp -= new UnityAction<CampaignNode>(this.PreBattleSetUp);
    global::Events.PostBattleSetUp -= new UnityAction<CampaignNode>(this.PostBattleSetUp);
  }

  public void PreBattleSetUp(CampaignNode node)
  {
    this.correctArea = node.areaIndex == 2;
    if (!this.correctArea)
      return;
    global::Events.OnCardDataCreated += new UnityAction<CardData>(this.CardDataCreated);
  }

  public void PostBattleSetUp(CampaignNode node)
  {
    if (this.correctArea)
      global::Events.OnCardDataCreated -= new UnityAction<CardData>(this.CardDataCreated);
    this.correctArea = false;
  }

  public void CardDataCreated(CardData cardData)
  {
    if (!this.correctArea)
      return;
    string name = cardData.cardType.name;
    if (!(name == "Enemy") && !(name == "Miniboss") && !(name == "Boss") || !cardData.hasAttack)
      return;
    ++cardData.damage;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BoostEnemyDamageModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine.Events;

public class BoostEnemyDamageModifierSystem : GameSystem
{
  public const int attackAdd = 1;
  public const int healthAdd = 1;

  public void OnEnable() => global::Events.OnCardDataCreated += new UnityAction<CardData>(BoostEnemyDamageModifierSystem.CardDataCreated);

  public void OnDisable() => global::Events.OnCardDataCreated -= new UnityAction<CardData>(BoostEnemyDamageModifierSystem.CardDataCreated);

  public static void CardDataCreated(CardData cardData)
  {
    string name = cardData.cardType.name;
    if (!(name == "Enemy") && !(name == "Miniboss") && !(name == "Boss") && !(name == "BossSmall"))
      return;
    if (cardData.hasAttack)
      ++cardData.damage;
    if (!cardData.hasHealth)
      return;
    ++cardData.hp;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BoostFriendlyDamageModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine.Events;

public class BoostFriendlyDamageModifierSystem : GameSystem
{
  public const int attackAdd = 1;

  public void OnEnable() => global::Events.OnCardDataCreated += new UnityAction<CardData>(BoostFriendlyDamageModifierSystem.CardDataCreated);

  public void OnDisable() => global::Events.OnCardDataCreated -= new UnityAction<CardData>(BoostFriendlyDamageModifierSystem.CardDataCreated);

  public static void CardDataCreated(CardData cardData)
  {
    if (!(cardData.cardType.name == "Friendly") || !cardData.hasAttack)
      return;
    ++cardData.damage;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BoostMinibossHealthModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class BoostMinibossHealthModifierSystem : GameSystem
{
  public const float healthFactor = 1.1f;

  public void OnEnable() => global::Events.OnCardDataCreated += new UnityAction<CardData>(this.CardDataCreated);

  public void OnDisable() => global::Events.OnCardDataCreated -= new UnityAction<CardData>(this.CardDataCreated);

  public void CardDataCreated(CardData cardData)
  {
    string name = cardData.cardType.name;
    if (!(name == "Miniboss") && !(name == "Boss"))
      return;
    if (cardData.hasHealth)
      this.BoostHealth(cardData, 1.1f);
    else
      this.BoostStatusEffect(cardData, "scrap", 1.1f);
  }

  public void BoostHealth(CardData cardData, float factor)
  {
    float f = (float) cardData.hp * factor;
    cardData.hp = Mathf.RoundToInt(f);
  }

  public void BoostStatusEffect(CardData cardData, string statusType, float factor)
  {
    foreach (CardData.StatusEffectStacks startWithEffect in cardData.startWithEffects)
    {
      if (!(startWithEffect.data.type != statusType))
      {
        float f = (float) startWithEffect.count * factor;
        startWithEffect.count = Mathf.RoundToInt(f);
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Bootstrap
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Deadpan.Enums.Engine.Components.Modding;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class Bootstrap : MonoBehaviour
{
  [SerializeField]
  public string[] loadFirst = new string[2]
  {
    "Camera",
    "Global"
  };
  [SerializeField]
  public string[] thenLoad = new string[4]
  {
    "Input",
    "Systems",
    "Saving",
    "PauseScreen"
  };
  [SerializeField]
  public string startSceneKey = "MainMenu";
  [SerializeField]
  public string culture = "en-GB";
  [SerializeField]
  public UnityEngine.Animator progressAnimator;
  [SerializeField]
  public Image progressFill;
  [SerializeField]
  public float pauseBefore = 0.5f;
  [SerializeField]
  public float pauseAfter = 0.5f;
  [SerializeField]
  public bool unloadSceneAfter = true;
  [SerializeField]
  public float fillLerp = 0.1f;
  [SerializeField]
  public SplashScreenSequence splashScreen;
  [SerializeField]
  public float minTime;
  public float targetFill;
  public float fillAdd;
  public static bool done;
  public static int Count;
  public static readonly SortedSet<WildfrostMod> Mods = new SortedSet<WildfrostMod>();

  public void OnEnable() => ++Bootstrap.Count;

  public void OnDisable() => --Bootstrap.Count;

  public IEnumerator Start()
  {
    Bootstrap bootstrap = this;
    if (Bootstrap.done)
    {
      UnityEngine.Object.Destroy((UnityEngine.Object) bootstrap.gameObject);
    }
    else
    {
      Bootstrap.done = true;
      Scene thisScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene();
      Routine.Clump clump = new Routine.Clump();
      clump.Add(bootstrap.Load());
      if ((double) bootstrap.minTime > 0.0)
        clump.Add(Sequences.Wait(bootstrap.minTime));
      yield return (object) clump.WaitForEnd();
      while (AudioSettingsSystem.Loading)
        yield return (object) null;
      if ((bool) (UnityEngine.Object) bootstrap.splashScreen)
        yield return (object) bootstrap.splashScreen.Run();
      bootstrap.ModsSetup();
      SceneManager.JobStart();
      yield return (object) Transition.To(bootstrap.startSceneKey);
      if (bootstrap.unloadSceneAfter)
      {
        UnityEngine.SceneManagement.SceneManager.UnloadSceneAsync(thisScene).completed += (Action<AsyncOperation>) (a => SceneManager.JobEnd());
      }
      else
      {
        UnityEngine.Object.Destroy((UnityEngine.Object) bootstrap.gameObject);
        SceneManager.JobEnd();
      }
    }
  }

  public IEnumerator Load()
  {
    Thread.CurrentThread.CurrentCulture = CultureInfo.CreateSpecificCulture(this.culture);
    this.fillAdd = 1f / (float) (this.loadFirst.Length + this.thenLoad.Length);
    yield return (object) new WaitForSeconds(this.pauseBefore);
    if ((bool) (UnityEngine.Object) this.progressAnimator)
      this.progressAnimator.SetBool("Increasing", true);
    yield return (object) this.Load((IEnumerable<string>) this.loadFirst);
    yield return (object) this.Load((IEnumerable<string>) this.thenLoad);
    if ((bool) (UnityEngine.Object) this.progressAnimator)
    {
      this.progressAnimator.SetBool("Increasing", false);
      this.progressAnimator.SetTrigger("Ping");
    }
    yield return (object) new WaitForSeconds(this.pauseAfter);
  }

  public void Update()
  {
    if (!(bool) (UnityEngine.Object) this.progressFill)
      return;
    this.progressFill.fillAmount = Delta.Lerp(this.progressFill.fillAmount, this.targetFill, this.fillLerp, Time.deltaTime);
  }

  public IEnumerator Load(IEnumerable<string> sceneKeys)
  {
    Bootstrap bootstrap = this;
    Routine.Clump clump = new Routine.Clump();
    foreach (string sceneKey in sceneKeys)
      clump.Add(SceneManager.Load(sceneKey, SceneType.Persistent, new Action<Scene>(bootstrap.\u003CLoad\u003Eb__21_0)));
    yield return (object) clump.WaitForEnd();
  }

  public static bool IsModDirectory(string dir, out string[] dlls)
  {
    dlls = System.IO.Directory.GetFiles(dir, "*.dll");
    return dlls.Length != 0;
  }

  public static void LoadModAtPath(string path)
  {
    string[] dlls;
    if (!Bootstrap.IsModDirectory(path, out dlls))
      return;
    Assembly assembly1 = (Assembly) null;
    foreach (string assemblyFile in dlls)
    {
      Assembly assembly2 = Assembly.LoadFrom(assemblyFile);
      try
      {
        foreach (System.Type type in assembly2.GetTypes())
        {
          if (type.BaseType == typeof (WildfrostMod))
          {
            Debug.Log((object) "Found valid mod type");
            assembly1 = assembly2;
            break;
          }
        }
      }
      catch (TypeLoadException ex)
      {
      }
    }
    if (assembly1 == (Assembly) null)
    {
      Debug.LogWarning((object) ("Empty mod? " + path));
    }
    else
    {
      foreach (System.Type type in assembly1.GetTypes())
      {
        if (type.BaseType == typeof (WildfrostMod) && type != typeof (InternalMod))
        {
          WildfrostMod instance = Activator.CreateInstance(type, (object) path) as WildfrostMod;
          Bootstrap.Mods.Add(instance);
          break;
        }
      }
      Debug.LogWarning((object) ("Properly loaded mod and added instance " + assembly1?.ToString()));
    }
    Debug.LogWarning((object) ("Found mod directory " + path));
  }

  public void ModsSetup()
  {
    foreach (System.Type allDataType in WildfrostMod.AllDataTypes)
      typeof (AddressableLoader).GetMethod("GetGroup", BindingFlags.Static | BindingFlags.Public).MakeGenericMethod(allDataType).Invoke((object) this, new object[1]
      {
        (object) allDataType.ToString()
      });
    TMP_Text.OnSpriteAssetRequest += (Func<int, string, TMP_SpriteAsset>) ((hash, s) =>
    {
      foreach (WildfrostMod mod in Bootstrap.Mods)
      {
        if (s == mod.GUID)
          return mod.HasLoaded ? mod.SpriteAsset : (TMP_SpriteAsset) null;
      }
      return (TMP_SpriteAsset) null;
    });
    string path = Path.Combine(Application.streamingAssetsPath, "Mods");
    if (!System.IO.Directory.Exists(path))
      System.IO.Directory.CreateDirectory(path);
    foreach (string directory in System.IO.Directory.GetDirectories(path))
      Bootstrap.LoadModAtPath(directory);
    foreach (WildfrostMod lastMod in WildfrostMod.GetLastMods())
      lastMod?.ModLoad();
  }

  [CompilerGenerated]
  public void \u003CLoad\u003Eb__21_0(Scene a) => this.targetFill += this.fillAdd;
}
﻿// Decompiled with JetBrains decompiler
// Type: BossRewardCompatibilitySystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class BossRewardCompatibilitySystem : GameSystem
{
  public void OnEnable() => global::Events.OnCampaignLoaded += new UnityAction(this.CampaignLoaded);

  public void OnDisable() => global::Events.OnCampaignLoaded -= new UnityAction(this.CampaignLoaded);

  public void CampaignLoaded()
  {
    bool flag = false;
    foreach (CampaignNode node in Campaign.instance.nodes)
    {
      if (node.type.isBattle && node.type is CampaignNodeTypeBoss type && !node.data.ContainsKey("rewards"))
      {
        if (!flag)
        {
          CharacterRewards component = References.Player.GetComponent<CharacterRewards>();
          if (component != null)
          {
            component.Populate(References.PlayerData.classData);
            component.RemoveLockedCards();
            flag = true;
          }
        }
        type.GetRewards(node);
        Debug.Log((object) string.Format("Boss Node [{0}][{1}] doesn't contain any boss reward data! Pulling new rewards!", (object) node.name, (object) node.id));
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BossRewardData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

public abstract class BossRewardData : DataFile
{
  public abstract BossRewardData.Data Pull();

  public enum Type
  {
    Modifier,
    Charm,
    Crown,
  }

  [Serializable]
  public abstract class Data
  {
    public BossRewardData.Type type;

    public abstract void Select();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BossRewardDataCrown
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Boss Rewards/Crown", fileName = "Crown")]
public class BossRewardDataCrown : BossRewardData
{
  public override BossRewardData.Data Pull()
  {
    BossRewardDataCrown.Data data = new BossRewardDataCrown.Data();
    data.type = BossRewardData.Type.Crown;
    return (BossRewardData.Data) data;
  }

  [Serializable]
  public new class Data : BossRewardData.Data
  {
    public string upgradeDataName;

    public CardUpgradeData GetUpgrade() => AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", this.upgradeDataName.IsNullOrWhitespace() ? "Crown" : this.upgradeDataName);

    public override void Select()
    {
      CardUpgradeData upgradeData = this.GetUpgrade().Clone();
      References.PlayerData.inventory.upgrades.Add(upgradeData);
      Events.InvokeUpgradeGained(upgradeData);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BossRewardDataModifier
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Boss Rewards/Modifier", fileName = "Modifier")]
public class BossRewardDataModifier : BossRewardData
{
  public override BossRewardData.Data Pull()
  {
    string name = References.Player.GetComponent<CharacterRewards>().Pull<GameModifierData>((object) this, "Modifiers").name;
    BossRewardDataModifier.Data data = new BossRewardDataModifier.Data();
    data.type = BossRewardData.Type.Modifier;
    data.modifierName = name;
    return (BossRewardData.Data) data;
  }

  [Serializable]
  public new class Data : BossRewardData.Data
  {
    public string modifierName;

    public GameModifierData GetModifier() => AddressableLoader.Get<GameModifierData>("GameModifierData", this.modifierName);

    public override void Select()
    {
      GameModifierData modifier = this.GetModifier();
      ModifierSystem.AddModifier(Campaign.Data, modifier);
      Routine.Clump clump = new Routine.Clump();
      foreach (Script startScript in modifier.startScripts)
        clump.Add(startScript.Run());
      foreach (Script setupScript in modifier.setupScripts)
        clump.Add(setupScript.Run());
      foreach (string componentName in modifier.systemsToAdd)
      {
        Debug.Log((object) string.Format("[{0}] adding system: {1}", (object) modifier, (object) componentName));
        Campaign.instance.gameObject.AddComponentByName(componentName);
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BossRewardDataRandomCharm
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Boss Rewards/Random Charm", fileName = "Random Charm")]
public class BossRewardDataRandomCharm : BossRewardData
{
  [SerializeField]
  public int minTier = 1;

  public override BossRewardData.Data Pull()
  {
    string name = References.Player.GetComponent<CharacterRewards>().Pull<CardUpgradeData>((object) this, "Charms", 1, false, new Predicate<DataFile>(this.CheckTier))[0].name;
    BossRewardDataRandomCharm.Data data = new BossRewardDataRandomCharm.Data();
    data.type = BossRewardData.Type.Charm;
    data.upgradeName = name;
    return (BossRewardData.Data) data;
  }

  public bool CheckTier(DataFile dataFile) => dataFile is CardUpgradeData cardUpgradeData && cardUpgradeData.tier >= this.minTier;

  [Serializable]
  public new class Data : BossRewardData.Data
  {
    public string upgradeName;

    public CardUpgradeData GetUpgrade() => AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", this.upgradeName);

    public override void Select()
    {
      CardUpgradeData upgradeData = this.GetUpgrade().Clone();
      References.PlayerData.inventory.upgrades.Add(upgradeData);
      Events.InvokeUpgradeGained(upgradeData);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BossRewardPool
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Boss Reward Pool", fileName = "Boss Reward Pool")]
public class BossRewardPool : ScriptableObject
{
  public BossRewardData[] bossRewards;
}
﻿// Decompiled with JetBrains decompiler
// Type: BossRewardSelect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class BossRewardSelect : MonoBehaviourRect
{
  [SerializeField]
  public InputAction inputAction;
  [SerializeField]
  public KeywordData popUpKeyword;
  public string title;
  public string body;
  public string popUpName;
  public bool poppedUp;
  public static readonly Vector2 popUpOffset = new Vector2(1f, 0.0f);

  public virtual void SetUp(
    BossRewardData.Data rewardData,
    GainBlessingSequence2 gainBlessingSequence)
  {
    this.inputAction.action.AddListener((UnityAction) (() => gainBlessingSequence.Select(rewardData)));
    this.inputAction.action.AddListener(new UnityAction(this.Destroy));
  }

  public void Pop()
  {
    if (this.poppedUp)
      return;
    CardPopUp.AssignTo(this.rectTransform, BossRewardSelect.popUpOffset.x, BossRewardSelect.popUpOffset.y);
    if ((bool) (Object) this.popUpKeyword)
      CardPopUp.AddPanel(this.popUpKeyword);
    else
      CardPopUp.AddPanel(this.popUpName, this.title, this.body);
    this.poppedUp = true;
  }

  public void UnPop()
  {
    if (!this.poppedUp)
      return;
    CardPopUp.RemovePanel((bool) (Object) this.popUpKeyword ? this.popUpKeyword.name : this.popUpName);
    this.poppedUp = false;
  }

  public void Destroy()
  {
    this.UnPop();
    Object.Destroy((Object) this.gameObject);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BossRewardSelectCharm
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class BossRewardSelectCharm : BossRewardSelect
{
  [SerializeField]
  public ImageSprite charmImage;

  public override void SetUp(
    BossRewardData.Data rewardData,
    GainBlessingSequence2 gainBlessingSequence)
  {
    base.SetUp(rewardData, gainBlessingSequence);
    if (!(rewardData is BossRewardDataRandomCharm.Data data))
      return;
    CardUpgradeData upgrade = data.GetUpgrade();
    this.charmImage.SetSprite(upgrade.image);
    this.popUpName = upgrade.name;
    this.title = upgrade.title;
    this.body = upgrade.text;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BossRewardSelectCrown
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class BossRewardSelectCrown : BossRewardSelect
{
  [SerializeField]
  public ImageSprite crownImage;

  public override void SetUp(
    BossRewardData.Data rewardData,
    GainBlessingSequence2 gainBlessingSequence)
  {
    base.SetUp(rewardData, gainBlessingSequence);
    if (!(rewardData is BossRewardDataCrown.Data data))
      return;
    CardUpgradeData upgrade = data.GetUpgrade();
    this.crownImage.SetSprite(upgrade.image);
    this.popUpName = upgrade.name;
    this.title = upgrade.title;
    this.body = upgrade.text;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BossRewardSelectModifier
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class BossRewardSelectModifier : BossRewardSelect
{
  [SerializeField]
  public ImageSprite bellImage;
  [SerializeField]
  public ImageSprite dingerImage;

  public override void SetUp(
    BossRewardData.Data rewardData,
    GainBlessingSequence2 gainBlessingSequence)
  {
    base.SetUp(rewardData, gainBlessingSequence);
    if (!(rewardData is BossRewardDataModifier.Data data))
      return;
    GameModifierData modifier = data.GetModifier();
    this.bellImage.SetSprite(modifier.bellSprite);
    this.dingerImage.SetSprite(modifier.dingerSprite);
    this.popUpName = modifier.name;
    this.title = modifier.titleKey.GetLocalizedString();
    this.body = modifier.descriptionKey.GetLocalizedString();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BossSetUp
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using NaughtyAttributes;
using UnityEngine;

public class BossSetUp : MonoBehaviour
{
  public CharacterAvatar avatarPrefab;
  public CardData cardData;
  [SerializeField]
  [Required(null)]
  public Entity entity;
  [SerializeField]
  [Required(null)]
  public Character character;

  public void Awake() => this.SetUp();

  public void SetUp()
  {
    this.entity.random3 = PettyRandom.Vector3();
    this.entity.data = this.cardData.Clone();
    this.entity.hp.max = this.entity.data.hp;
    this.entity.hp.current = this.entity.hp.max;
    this.entity.data.hasAttack = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Building
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class Building : MonoBehaviour
{
  public BuildingType type;
  public bool canSelect = true;
  [SerializeField]
  public UnityEventGameObject onSelect;
  [SerializeField]
  public GameObject toBuild;
  [SerializeField]
  public GameObject underConstruction;
  [SerializeField]
  public GameObject fullyBuilt;
  [SerializeField]
  public Building.Icon[] icons;
  [SerializeField]
  public UnityEvent onDataUpdated;
  public bool buildStarted;
  public bool built;
  public List<string> unlocks;
  public List<string> uncheckedUnlocks;
  public GameObject currentActiveIcon;

  public List<string> checkedUnlocks
  {
    get
    {
      if (this.unlocks == null)
        return (List<string>) null;
      return this.uncheckedUnlocks == null ? this.unlocks : this.unlocks.Except<string>((IEnumerable<string>) this.uncheckedUnlocks).ToList<string>();
    }
  }

  public bool HasUncheckedUnlocks
  {
    get
    {
      List<string> uncheckedUnlocks = this.uncheckedUnlocks;
      return uncheckedUnlocks != null && uncheckedUnlocks.Count > 0;
    }
  }

  public void CheckIfUnlocked()
  {
    List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
    this.buildStarted = (UnityEngine.Object) this.type.started == (UnityEngine.Object) null || MetaprogressionSystem.IsUnlocked(this.type.started, unlockedList);
    this.built = (UnityEngine.Object) this.type.finished == (UnityEngine.Object) null || MetaprogressionSystem.IsUnlocked(this.type.finished, unlockedList);
    if (!this.built && !this.buildStarted)
    {
      this.gameObject.SetActive(false);
    }
    else
    {
      this.gameObject.SetActive(true);
      this.RunUpdateEvent();
    }
  }

  public void RunUpdateEvent()
  {
    this.onDataUpdated?.Invoke();
    if (this.built && this.type.unlocks != null && this.type.unlocks.Length != 0)
    {
      List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
      this.unlocks = ((IEnumerable<UnlockData>) this.type.unlocks).Select<UnlockData, string>((Func<UnlockData, string>) (a => a.name)).Intersect<string>((IEnumerable<string>) unlockedList).ToList<string>();
      if (this.unlocks.Count > 0 && !this.type.unlockedCheckedKey.IsNullOrWhitespace())
      {
        List<string> second = SaveSystem.LoadProgressData<List<string>>(this.type.unlockedCheckedKey);
        this.uncheckedUnlocks = second == null ? new List<string>((IEnumerable<string>) this.unlocks) : this.unlocks.Except<string>((IEnumerable<string>) second).ToList<string>();
        Debug.Log((object) string.Format("[{0}] has unchecked {1} unlocks [{2}]", (object) this.name, (object) this.uncheckedUnlocks.Count, (object) string.Join(", ", (IEnumerable<string>) this.uncheckedUnlocks)));
      }
    }
    this.UpdateSprite();
    this.SetSuitableIcon();
  }

  public bool Select()
  {
    try
    {
      if (this.canSelect)
      {
        if (this.onSelect != null)
        {
          this.onSelect.Invoke(this.onSelect.GetPersistentTarget(0) as GameObject);
          return true;
        }
      }
    }
    catch (ArgumentOutOfRangeException ex)
    {
      return false;
    }
    return false;
  }

  public void UpdateSprite()
  {
    if ((bool) (UnityEngine.Object) this.toBuild)
      this.toBuild.gameObject.SetActive(!this.buildStarted && !this.built);
    if ((bool) (UnityEngine.Object) this.underConstruction)
      this.underConstruction.gameObject.SetActive(this.buildStarted && !this.built);
    if (!(bool) (UnityEngine.Object) this.fullyBuilt)
      return;
    this.fullyBuilt.gameObject.SetActive(this.built);
  }

  public void SetSuitableIcon()
  {
    string name = "";
    foreach (BuildingIconSetter component in this.GetComponents<BuildingIconSetter>())
      name = component.Get(this);
    this.SetIcon(name);
  }

  public void SetIcon(string name)
  {
    if ((bool) (UnityEngine.Object) this.currentActiveIcon)
      this.currentActiveIcon.SetActive(false);
    if (name.IsNullOrWhitespace())
      return;
    Building.Icon icon = ((IEnumerable<Building.Icon>) this.icons).FirstOrDefault<Building.Icon>((Func<Building.Icon, bool>) (a => a.name == name));
    if (icon == null)
      return;
    this.currentActiveIcon = icon.obj;
    this.currentActiveIcon.SetActive(true);
  }

  public void Bloop()
  {
    this.transform.localScale = new Vector3(1.5f, 0.6666667f, 1f);
    LeanTween.cancel(this.gameObject);
    LeanTween.scale(this.gameObject, Vector3.one, 1.5f).setEase(LeanTweenType.easeOutElastic);
  }

  public void CreateDisplay(GameObject prefab) => UnityEngine.Object.FindObjectOfType<BuildingDisplay>(true)?.Create(prefab, this);

  [Serializable]
  public class Icon
  {
    public string name;
    public GameObject obj;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingBalloon
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[RequireComponent(typeof (Building))]
public class BuildingBalloon : MonoBehaviour
{
  [SerializeField]
  public string gameModeName = "GameModeDaily";
  [SerializeField]
  public GameObject displayPrefab;
  public Building _building;

  public Building building => this._building ?? (this._building = this.GetComponent<Building>());

  public void Select()
  {
    GameMode gameMode = AddressableLoader.Get<GameMode>("GameMode", this.gameModeName);
    if (Campaign.CheckContinue(gameMode))
    {
      Campaign.Data = CampaignData.Load(gameMode);
      DailyFetcher.SetContinueDateTime();
      this.StartCoroutine(BuildingBalloon.ContinueRoutine());
    }
    else
      this.building.CreateDisplay(this.displayPrefab);
  }

  public static IEnumerator ContinueRoutine()
  {
    yield return (object) SceneManager.Load("ContinueRun", SceneType.Temporary);
    yield return (object) SceneManager.WaitUntilUnloaded("ContinueRun");
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingCardUnlockSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class BuildingCardUnlockSequence : BuildingSequenceWithUnlocks<BuildingCardUnlockSequence>
{
  [SerializeField]
  public CardController controller;
  [SerializeField]
  public Transform owner;
  [SerializeField]
  public CardUnlockSequence cardUnlockSequence;
  [SerializeField]
  public string metaprogressionKey = "companions";
  [SerializeField]
  public string firstGreetKey;

  public void Start() => this._OnStart();

  public override IEnumerator Sequence()
  {
    BuildingCardUnlockSequence cardUnlockSequence = this;
    int num = Mathf.Min(cardUnlockSequence.locks.Length, cardUnlockSequence.building.type.unlocks.Length);
    for (int index = 0; index < num; ++index)
    {
      if (cardUnlockSequence.building.type.unlocks[index].IsActive)
        cardUnlockSequence.locks[index].SetActive(false);
    }
    yield return (object) cardUnlockSequence.CreateCards();
    if (cardUnlockSequence.building.HasUncheckedUnlocks)
    {
      foreach (string uncheckedUnlock in cardUnlockSequence.building.uncheckedUnlocks)
        yield return (object) cardUnlockSequence.Unlock(uncheckedUnlock);
      Entity top = ((IEnumerable<CardContainer>) cardUnlockSequence.cardSlots).LastOrDefault<CardContainer>((Func<CardContainer, bool>) (a => !a.Empty))?.GetTop();
      if ((bool) (UnityEngine.Object) top)
        cardUnlockSequence.TalkerNewCard(top.data);
    }
    else if (!cardUnlockSequence.firstGreetKey.IsNullOrEmpty() && !SaveSystem.LoadProgressData<bool>(cardUnlockSequence.firstGreetKey, false))
    {
      cardUnlockSequence.TalkerFirstGreet();
      SaveSystem.SaveProgressData<bool>(cardUnlockSequence.firstGreetKey, true);
    }
    else
      cardUnlockSequence.TalkerGreet();
  }

  public IEnumerator Unlock(string unlockDataName)
  {
    BuildingCardUnlockSequence cardUnlockSequence = this;
    int index = ((IEnumerable<UnlockData>) cardUnlockSequence.building.type.unlocks).Select<UnlockData, string>((Func<UnlockData, string>) (a => a.name)).ToList<string>().IndexOf(unlockDataName);
    if (index < 0)
      throw new IndexOutOfRangeException("[" + unlockDataName + "] does not exist in [" + cardUnlockSequence.building.name + "] unlocks list!");
    string assetName = MetaprogressionSystem.Get<List<string>>(cardUnlockSequence.metaprogressionKey)[index];
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>(cardUnlockSequence.building.type.unlockedCheckedKey, new List<string>());
    stringList.Add(unlockDataName);
    SaveSystem.SaveProgressData<List<string>>(cardUnlockSequence.building.type.unlockedCheckedKey, stringList);
    Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", assetName), cardUnlockSequence.controller, (Character) null, false, true);
    yield return (object) card.UpdateData(false);
    CardContainer finalSlot = ((IEnumerable<CardContainer>) cardUnlockSequence.cardSlots).FirstOrDefault<CardContainer>((Func<CardContainer, bool>) (a => a.Empty));
    yield return (object) cardUnlockSequence.cardUnlockSequence.Run(card.entity, finalSlot);
    if ((bool) (UnityEngine.Object) finalSlot)
    {
      Image component = finalSlot.GetComponent<Image>();
      if (component != null)
        component.enabled = true;
    }
  }

  public IEnumerator CreateCards()
  {
    BuildingCardUnlockSequence cardUnlockSequence = this;
    List<Entity> cards = new List<Entity>();
    Routine.Clump clump = new Routine.Clump();
    List<string> checkedUnlocks = cardUnlockSequence.building.checkedUnlocks;
    // ISSUE: explicit non-virtual call
    int count = checkedUnlocks != null ? __nonvirtual (checkedUnlocks.Count) : 0;
    List<string> stringList = MetaprogressionSystem.Get<List<string>>(cardUnlockSequence.metaprogressionKey);
    for (int index = 0; index < count && index < stringList.Count; ++index)
    {
      Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", stringList[index]), cardUnlockSequence.controller, (Character) null, false, true);
      cards.Add(card.entity);
      clump.Add(card.UpdateData(false));
    }
    yield return (object) clump.WaitForEnd();
    foreach (Entity entity in cards)
    {
      CardContainer cardContainer = ((IEnumerable<CardContainer>) cardUnlockSequence.cardSlots).FirstOrDefault<CardContainer>((Func<CardContainer, bool>) (a => a.Empty));
      if (cardContainer == null)
        break;
      entity.flipper.FlipUpInstant();
      entity.enabled = true;
      cardContainer.Add(entity);
      cardContainer.SetChildPositions();
      Image component = cardContainer.GetComponent<Image>();
      if (component != null)
        component.enabled = false;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class BuildingDisplay : MonoBehaviour
{
  [SerializeField]
  public UnityEvent onEnable;
  [SerializeField]
  public UnityEvent onDisable;
  [SerializeField]
  public int setSiblingIndex = 1;
  [SerializeField]
  public HelpPanelShower helpShower;
  public GameObject current;

  public void Create(GameObject prefab, Building building)
  {
    this.gameObject.SetActive(true);
    this.current = Object.Instantiate<GameObject>(prefab, this.transform);
    this.current.transform.SetSiblingIndex(this.setSiblingIndex);
    this.current.GetComponent<BuildingSequence>()?.Play(building);
    this.onEnable.Invoke();
    this.SetHelp(building.type);
  }

  public void SetHelp(BuildingType buildingType)
  {
    if (buildingType.helpKey.IsEmpty)
    {
      this.helpShower.gameObject.SetActive(false);
    }
    else
    {
      this.helpShower.gameObject.SetActive(true);
      this.helpShower.SetKey(buildingType.helpKey, new Prompt.Emote.Type?(buildingType.helpEmoteType));
    }
  }

  public void End()
  {
    this.current.GetComponent<BuildingSequence>()?.building?.RunUpdateEvent();
    this.current.Destroy();
    this.current = (GameObject) null;
    this.gameObject.SetActive(false);
    this.onDisable.Invoke();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingIconSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public abstract class BuildingIconSetter : MonoBehaviour
{
  public virtual string Get(Building building) => "";
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingIconSetterDaily
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class BuildingIconSetterDaily : BuildingIconSetter
{
  [SerializeField]
  public string gameModeName = "GameModeDaily";
  public GameMode _gameMode;

  public GameMode gameMode => this._gameMode ?? (this._gameMode = AddressableLoader.Get<GameMode>("GameMode", this.gameModeName));

  public override string Get(Building building)
  {
    string str = "";
    if (DailyFetcher.CanPlay())
      str = "Unlock";
    else if (Campaign.CheckContinue(this.gameMode))
      str = "Unlock";
    return str;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingIconSetterUnlocks
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class BuildingIconSetterUnlocks : BuildingIconSetter
{
  public override string Get(Building building) => building.built && building.HasUncheckedUnlocks ? "Unlock" : "";
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingInteraction
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.EventSystems;

[RequireComponent(typeof (Building))]
public class BuildingInteraction : MonoBehaviour
{
  [SerializeField]
  public SpriteRenderer[] spritesToOutline;
  public Building _building;
  public Material _outlineMaterial;
  public readonly Dictionary<SpriteRenderer, Material> previous = new Dictionary<SpriteRenderer, Material>();
  public bool hover;

  public Building building => this._building ?? (this._building = this.GetComponent<Building>());

  public Material outlineMaterial => this._outlineMaterial ?? (this._outlineMaterial = AssetLoader.Lookup<Material>("Materials", "SpriteOutline"));

  public void Hover()
  {
    if (this.hover)
      return;
    Debug.Log((object) ("[" + this.name + " Hover]"));
    this.hover = true;
    this.previous.Clear();
    foreach (SpriteRenderer key in this.spritesToOutline)
    {
      this.previous[key] = key.sharedMaterial;
      key.sharedMaterial = this.outlineMaterial;
    }
    this.HoverTween();
    this.building.SetIcon("Select");
    Events.InvokeButtonHover(ButtonType.Building);
  }

  public void UnHover()
  {
    if (!this.hover)
      return;
    this.hover = false;
    Debug.Log((object) ("[" + this.name + " UnHover]"));
    foreach (KeyValuePair<SpriteRenderer, Material> keyValuePair in this.previous.Where<KeyValuePair<SpriteRenderer, Material>>((Func<KeyValuePair<SpriteRenderer, Material>, bool>) (pair => (UnityEngine.Object) pair.Key != (UnityEngine.Object) null)))
      keyValuePair.Key.sharedMaterial = keyValuePair.Value;
    this.UnHoverTween();
    this.building.SetSuitableIcon();
  }

  public void Select(BaseEventData eventData)
  {
    if (eventData is PointerEventData pointerEventData && pointerEventData.button != PointerEventData.InputButton.Left)
      return;
    Town.SelectBuilding(this.building);
    Events.InvokeButtonPress(ButtonType.Building);
  }

  public void HoverTween()
  {
    LeanTween.cancel(this.gameObject);
    this.transform.localScale = new Vector3(0.99502486f, 0.99502486f, 1f);
    LeanTween.scale(this.gameObject, new Vector3(1.005f, 1.005f, 1f), 1.2f).setEaseOutElastic();
  }

  public void UnHoverTween()
  {
    LeanTween.cancel(this.gameObject);
    LeanTween.scale(this.gameObject, Vector3.one, 0.1f).setEaseOutQuart();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingPlot
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class BuildingPlot : MonoBehaviour
{
  [SerializeField]
  public string sortingLayerName;
  [SerializeField]
  public int sortingOrder;

  public void Start()
  {
    Building componentInChildren = this.GetComponentInChildren<Building>(true);
    if ((Object) componentInChildren != (Object) null)
    {
      foreach (SpriteRenderer componentsInChild in componentInChildren.GetComponentsInChildren<SpriteRenderer>(true))
      {
        componentsInChild.sortingLayerName = this.sortingLayerName;
        componentsInChild.sortingOrder += this.sortingOrder;
      }
    }
    Image component = this.GetComponent<Image>();
    if (component == null)
      return;
    component.enabled = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingPlotType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Building Plot", menuName = "Town/Building Plot")]
public class BuildingPlotType : DataFile
{
  [SerializeField]
  public BuildingType[] illegalBuildings;
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using FMODUnity;
using NaughtyAttributes;
using System.Collections;
using UnityEngine;

public class BuildingSequence : MonoBehaviour
{
  [ReadOnly]
  public Building building;
  [SerializeField]
  public Talker talker;
  [SerializeField]
  public EventReference enterSfxEvent;

  public virtual IEnumerator Sequence()
  {
    yield return (object) null;
  }

  public void TalkerGreet() => this.TalkerSay("greet", PettyRandom.Range(0.25f, 0.5f));

  public void TalkerFirstGreet() => this.TalkerSay("firstGreet", 0.5f);

  public void TalkerNewCard(CardData cardData) => this.TalkerSay("new card", 0.5f, (object) cardData.title);

  public void TalkerSay(string speechType, float delay, params object[] inserts)
  {
    if (!(bool) (Object) this.talker)
      return;
    this.talker.Say(speechType, delay, inserts);
  }

  public void Play(Building building)
  {
    if (!this.enterSfxEvent.IsNull)
      SfxSystem.OneShot(this.enterSfxEvent);
    this.building = building;
    this.StartCoroutine(this.Sequence());
  }

  public void Close()
  {
    this.StopAllCoroutines();
    Object.FindObjectOfType<BuildingDisplay>(true)?.End();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingSequenceWithUnlocks`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using HarmonyLib;
using MonoMod.Cil;
using System;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.UI;

public abstract class BuildingSequenceWithUnlocks<T> : BuildingSequence where T : BuildingSequenceWithUnlocks<T>
{
  [SerializeField]
  public GridLayoutGroup slotGrid;
  [SerializeField]
  public Transform challengeStonesParent;
  [SerializeField]
  public GameObject[] locks;
  [SerializeField]
  public CardContainer[] cardSlots;
  [SerializeField]
  public ChallengeStone[] challengeStones;

  public static event RuntimeILReferenceBag.FastDelegateInvokers.Action<T> OnStart;

  public void AddChallengeStone(ChallengeData unlock)
  {
    if (!(bool) (UnityEngine.Object) unlock || (bool) (UnityEngine.Object) this.challengeStones.ToList<ChallengeStone>().Find((Predicate<ChallengeStone>) (a => (UnityEngine.Object) a.challenge == (UnityEngine.Object) unlock)))
      return;
    GameObject gameObject = Addressables.LoadAssetAsync<GameObject>((object) "ChallengeStone").WaitForCompletion().InstantiateKeepName<GameObject>();
    gameObject.transform.parent = this.challengeStonesParent.transform;
    gameObject.transform.localPosition = gameObject.transform.localPosition.WithZ(0.0f);
    ChallengeStone componentInChildren = gameObject.GetComponentInChildren<ChallengeStone>();
    this.challengeStones = this.challengeStones.AddToArray<ChallengeStone>(componentInChildren);
    componentInChildren.challenge = unlock;
    componentInChildren.OnEnable();
  }

  public void AddSlot(ChallengeData unlock)
  {
    if (!(bool) (UnityEngine.Object) unlock || (bool) (UnityEngine.Object) this.cardSlots.ToList<CardContainer>().Find((Predicate<CardContainer>) (a => (UnityEngine.Object) a.gameObject?.GetComponentInChildren<ChallengeDisplayCreator>()?.challenge == (UnityEngine.Object) unlock)))
      return;
    GameObject gameObject = Addressables.LoadAssetAsync<GameObject>((object) "ProgressableCardStack").WaitForCompletion().InstantiateKeepName<GameObject>();
    gameObject.transform.parent = this.slotGrid.transform;
    CardStack componentInChildren1 = gameObject.GetComponentInChildren<CardStack>();
    this.cardSlots = this.cardSlots.AddToArray<CardContainer>((CardContainer) componentInChildren1);
    this.locks = this.locks.AddToArray<GameObject>(componentInChildren1.gameObject.transform.GetChild(0).gameObject);
    ChallengeDisplayCreator componentInChildren2 = gameObject.GetComponentInChildren<ChallengeDisplayCreator>();
    componentInChildren2.challenge = unlock;
    componentInChildren2.Check();
  }

  public void _OnStart()
  {
    RuntimeILReferenceBag.FastDelegateInvokers.Action<T> onStart = BuildingSequenceWithUnlocks<T>.OnStart;
    if (onStart == null)
      return;
    onStart(this as T);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BuildingType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization;

[CreateAssetMenu(fileName = "Building", menuName = "Town/Building")]
public class BuildingType : DataFile
{
  public LocalizedString titleKey;
  public LocalizedString helpKey;
  public Prompt.Emote.Type helpEmoteType = Prompt.Emote.Type.Explain;
  [Header("Progression")]
  public UnlockData started;
  public UnlockData finished;
  public UnlockData[] unlocks;
  public string unlockedCheckedKey;
}
﻿// Decompiled with JetBrains decompiler
// Type: ButtonAnimator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ButtonAnimator : MonoBehaviour
{
  [SerializeField]
  public ButtonType type;
  [InfoBox("This component should be on a separate object to the Button object, so as not to interfere with their tweens", EInfoBoxType.Normal)]
  [SerializeField]
  [Required(null)]
  public Selectable button;
  [SerializeField]
  public UINavigationItem nav;
  public bool hover;
  public bool press;
  public LTDescr tween;
  [Header("Text Colours")]
  public TMP_Text text;
  public Color textNormalColour = Color.white;
  [SerializeField]
  public bool textCopyBase = true;
  [HideIf("textCopyBase")]
  [SerializeField]
  public Color textHighlightColour = Color.white;
  [SerializeField]
  public bool strikeTextWhenDisabled;
  [ShowIf("strikeTextWhenDisabled")]
  [SerializeField]
  public Color textDisabledColour = Color.black;
  public Image image;
  public bool baseColourSet;
  public Color baseColour;
  public Color highlightColour = new Color(1f, 1f, 1f, 0.8f);
  public Color disabledColour = new Color(0.5f, 0.5f, 0.5f, 0.75f);
  [SerializeField]
  public bool setPressColour;
  [ShowIf("setPressColour")]
  [SerializeField]
  public Color pressColour;
  [Header("Tweens")]
  public TweenUI hoverTween;
  public TweenUI unHoverTween;
  public TweenUI pressTween;
  public TweenUI releaseTween;

  public bool interactable
  {
    get => this.button.interactable;
    set
    {
      if (value)
      {
        this.UnHighlight();
        if ((bool) (Object) this.text && this.strikeTextWhenDisabled)
          this.text.fontStyle = FontStyles.Normal;
      }
      else
        this.Disable();
      this.button.interactable = value;
      if (!(bool) (Object) this.nav)
        return;
      this.nav.enabled = value;
    }
  }

  public bool IsHoveredOrPressed => this.hover || this.press;

  public void OnEnable()
  {
    this.hover = false;
    this.press = false;
    if (this.interactable)
    {
      this.UnHighlight();
      if (!((Object) this.text != (Object) null) || !this.strikeTextWhenDisabled)
        return;
      this.text.fontStyle = FontStyles.Normal;
    }
    else
      this.Disable();
  }

  public void OnDisable()
  {
    this.press = false;
    this.UnHoverInstant();
  }

  public virtual void Hover()
  {
    if (this.hover || !this.interactable)
      return;
    this.hover = true;
    if (this.press)
      return;
    this.StopCurrentAnimation();
    this.hoverTween?.Fire();
    Events.InvokeButtonHover(this.type);
    this.Highlight();
  }

  public virtual void UnHover()
  {
    if (!this.hover)
      return;
    this.hover = false;
    if (this.press)
      return;
    this.StopCurrentAnimation();
    this.unHoverTween?.Fire();
    this.UnHighlight();
  }

  public void UnHoverInstant()
  {
    if (!this.hover)
      return;
    this.hover = false;
    if (this.press)
      return;
    this.StopCurrentAnimation();
    this.transform.localScale = Vector3.one;
    this.UnHighlight();
  }

  public virtual void Press()
  {
    if (this.press || !this.interactable)
      return;
    this.press = true;
    this.StopCurrentAnimation();
    this.pressTween?.Fire();
    Events.InvokeButtonPress(this.type);
    if (this.setPressColour)
    {
      if (!((Object) this.image != (Object) null))
        return;
      this.image.color = this.pressColour;
    }
    else
      this.UnHighlight();
  }

  public virtual void Release()
  {
    if (!this.press)
      return;
    this.press = false;
    this.StopCurrentAnimation();
    if (!this.hover)
      this.releaseTween?.Fire();
    else if (this.interactable)
    {
      this.hoverTween?.Fire();
      this.Highlight();
    }
    else
      this.hover = false;
    if (!this.setPressColour || this.hover)
      return;
    this.UnHighlight();
  }

  public void StopCurrentAnimation() => LeanTween.cancel(this.gameObject);

  public void CheckSetBaseColour()
  {
    if (this.baseColourSet)
      return;
    this.baseColourSet = true;
    this.baseColour = this.image.color;
  }

  public void Highlight()
  {
    if ((Object) this.image != (Object) null)
    {
      this.CheckSetBaseColour();
      this.image.color = this.highlightColour;
    }
    if (!((Object) this.text != (Object) null))
      return;
    this.text.color = this.textCopyBase ? this.baseColour : this.textHighlightColour;
  }

  public void UnHighlight()
  {
    if ((Object) this.image != (Object) null)
    {
      this.CheckSetBaseColour();
      this.image.color = this.baseColour;
    }
    if (!((Object) this.text != (Object) null))
      return;
    this.text.color = this.textNormalColour;
  }

  public void Disable()
  {
    if (this.hover)
      this.UnHover();
    if ((Object) this.image != (Object) null)
    {
      this.CheckSetBaseColour();
      this.image.color = this.disabledColour;
    }
    if (!((Object) this.text != (Object) null))
      return;
    if (this.strikeTextWhenDisabled)
      this.text.fontStyle = FontStyles.Strikethrough;
    this.text.color = this.strikeTextWhenDisabled ? this.textDisabledColour : this.disabledColour;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ButtonType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public enum ButtonType
{
  Normal,
  Sub,
  Back,
  Building,
  Bell,
}
﻿// Decompiled with JetBrains decompiler
// Type: CameraAnimationSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class CameraAnimationSystem : GameSystem
{
  public Transform target;
  public CameraAnimationSystem.Animation[] animations;
  public Dictionary<string, CameraAnimationSystem.Animation> lookup;
  public List<CameraAnimationSystem.RunCurve> running = new List<CameraAnimationSystem.RunCurve>();

  public void OnEnable()
  {
    this.lookup = new Dictionary<string, CameraAnimationSystem.Animation>();
    foreach (CameraAnimationSystem.Animation animation in this.animations)
      this.lookup[animation.name] = animation;
    this.running.Clear();
    global::Events.OnCameraAnimation += new UnityAction<string>(this.Run);
  }

  public void OnDisable() => global::Events.OnCameraAnimation -= new UnityAction<string>(this.Run);

  public void Update()
  {
    int count = this.running.Count;
    if (count <= 0)
      return;
    Vector3 zero1 = Vector3.zero;
    Vector3 zero2 = Vector3.zero;
    float deltaTime = Time.deltaTime;
    for (int index = count - 1; index >= 0; --index)
    {
      CameraAnimationSystem.RunCurve runCurve = this.running[index];
      runCurve.Update(deltaTime);
      zero1 += runCurve.GetPosOffset();
      zero2 += runCurve.GetRotOffset();
      if (runCurve.IsDone)
        this.running.RemoveAt(index);
    }
    this.target.localPosition = zero1;
    this.target.localEulerAngles = zero2;
  }

  public void Run(string name)
  {
    if (!this.lookup.ContainsKey(name))
      return;
    this.Run(this.lookup[name]);
  }

  public void Run(CameraAnimationSystem.Animation animation)
  {
    foreach (CameraAnimationSystem.Curve curve in animation.curves)
      this.running.Add(new CameraAnimationSystem.RunCurve(curve));
  }

  [Serializable]
  public struct Animation
  {
    public string name;
    public CameraAnimationSystem.Curve[] curves;
  }

  [Serializable]
  public struct Curve
  {
    public AnimationCurve curve;
    public Vector3 moveAmount;
    public Vector3 rotateAmount;
    public Vector2 durationRange;
  }

  public class RunCurve
  {
    public CameraAnimationSystem.Curve curve;
    public float time;
    public float duration;
    public float value;

    public bool IsDone => (double) this.time >= (double) this.duration;

    public RunCurve(CameraAnimationSystem.Curve curve)
    {
      this.curve = curve;
      this.duration = curve.durationRange.PettyRandom();
    }

    public void Update(float delta)
    {
      this.time += delta;
      this.value = this.curve.curve.Evaluate(this.time / this.duration);
    }

    public Vector3 GetPosOffset() => this.curve.moveAmount * this.value;

    public Vector3 GetRotOffset() => this.curve.rotateAmount * this.value;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CameraMover
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class CameraMover : GameSystem
{
  [SerializeField]
  public CameraMover.Translation[] battlePhasePositions;

  public void OnEnable()
  {
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChange);
  }

  public void OnDisable()
  {
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChange);
  }

  public void BattlePhaseStart(Battle.Phase phase)
  {
    CameraMover.Translation translation = ((IEnumerable<CameraMover.Translation>) this.battlePhasePositions).FirstOrDefault<CameraMover.Translation>((Func<CameraMover.Translation, bool>) (a => a.name == phase.ToString().ToLower()));
    if (translation == null)
      return;
    LeanTween.cancel(this.gameObject);
    LeanTween.moveLocal(this.gameObject, translation.position, translation.dur).setEase(translation.ease);
    LeanTween.rotateLocal(this.gameObject, translation.rotation, translation.dur).setEase(translation.ease);
  }

  public void SceneChange(Scene scene)
  {
    LeanTween.cancel(this.gameObject);
    this.transform.localPosition = Vector3.zero;
    this.transform.localEulerAngles = Vector3.zero;
  }

  [Serializable]
  public class Translation
  {
    public string name;
    public Vector3 position;
    public Vector3 rotation;
    public LeanTweenType ease;
    public float dur;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CameraRumbleSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using NaughtyAttributes;
using UnityEngine;

public class CameraRumbleSystem : GameSystem
{
  public Transform target;
  [HorizontalLine(2f, EColor.Gray)]
  public float strength = 1f;
  public Vector3 positionInfluence = new Vector3(1f, 1f, 1f);
  public Vector3 rotationInfluence = new Vector3(1f, 1f, 1f);
  public float t;
  public float d;
  [SerializeField]
  public AnimationCurve curve;
  public bool active;
  public float delay;

  public void OnEnable() => Events.OnScreenRumble += new Events.UnityAction<float, float, float, float, float, float>(this.Rumble);

  public void OnDisable() => Events.OnScreenRumble -= new Events.UnityAction<float, float, float, float, float, float>(this.Rumble);

  public void Update()
  {
    if (!this.active)
      return;
    if ((double) this.delay > 0.0)
    {
      this.delay -= Time.deltaTime;
    }
    else
    {
      this.t += Time.deltaTime;
      float num = ((double) this.t <= (double) this.d ? this.curve.Evaluate(this.t) : 0.0f) * this.strength * CameraShakerSystem.ShakeAmount;
      if ((double) num > 0.0)
      {
        this.target.localPosition = Vector3.Cross(this.positionInfluence, PettyRandom.Vector3()) * num;
        this.target.localEulerAngles = Vector3.Cross(this.rotationInfluence, PettyRandom.Vector3()) * num;
      }
      else
      {
        this.target.localPosition = Vector3.zero;
        this.target.localEulerAngles = Vector3.zero;
      }
      if ((double) this.t <= (double) this.d)
        return;
      this.active = false;
    }
  }

  public void Rumble(
    float startStrength,
    float endStrength,
    float delay,
    float fadeInTime,
    float holdTime,
    float fadeOutTime)
  {
    this.delay = delay;
    this.t = 0.0f;
    this.d = fadeInTime + holdTime + fadeOutTime;
    this.curve = new AnimationCurve(new Keyframe[4]
    {
      new Keyframe(0.0f, startStrength, 0.0f, 0.0f),
      new Keyframe(fadeInTime, endStrength, 0.0f, 0.0f),
      new Keyframe(fadeInTime + holdTime, endStrength, 0.0f, 0.0f),
      new Keyframe(this.d, 0.0f, 0.0f, 0.0f)
    });
    this.active = true;
    this.target.localPosition = Vector3.zero;
    this.target.localEulerAngles = Vector3.zero;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CameraShakerSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using UnityEngine;
using UnityEngine.Events;

public class CameraShakerSystem : GameSystem
{
  public Transform target;
  [HorizontalLine(2f, EColor.Gray)]
  public float magnitudeMod = 1f;
  public float angularMod = 0.67f;
  public float accelerationMod = 300f;
  [HorizontalLine(2f, EColor.Gray)]
  [SerializeField]
  public AnimationCurve hitStrengthCurve;
  [HorizontalLine(2f, EColor.Gray)]
  [Range(0.0f, 1f)]
  public float frict = 0.2f;
  [Range(0.0f, 180f)]
  public float angleRand = 20f;
  [Range(0.0f, 1f)]
  public float angularFrict = 0.1f;
  [HorizontalLine(2f, EColor.Gray)]
  public Vector3 positionInfluence = new Vector3(0.2f, 0.2f, 0.0f);
  public Vector3 rotationInfluence = new Vector3(1f, 1f, 1f);
  public Vector2 pos;
  public Vector2 velocity;
  public float angle;
  public float angularSpeed;
  public static float ShakeAmount;

  public void OnEnable()
  {
    global::Events.OnEntityHit += new UnityAction<global::Hit>(this.Hit);
    global::Events.OnScreenShake += new UnityAction<float, float?>(this.Shake);
    global::Events.OnSettingChanged += new UnityAction<string, object>(CameraShakerSystem.SettingChanged);
    CameraShakerSystem.ShakeAmount = Settings.Load<float>("ScreenShake", 1f);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHit -= new UnityAction<global::Hit>(this.Hit);
    global::Events.OnScreenShake -= new UnityAction<float, float?>(this.Shake);
    global::Events.OnSettingChanged -= new UnityAction<string, object>(CameraShakerSystem.SettingChanged);
    this.Stop();
  }

  public static void SettingChanged(string key, object value)
  {
    if (!(key == "ScreenShake") || !(value is float num))
      return;
    CameraShakerSystem.ShakeAmount = num;
  }

  public void Hit(global::Hit hit)
  {
    if (!hit.Offensive || (double) hit.screenShake <= 0.0)
      return;
    float hitDirection = this.GetHitDirection(hit);
    int offensiveness = hit.GetOffensiveness();
    this.Shake(hit.screenShake * this.hitStrengthCurve.Evaluate((float) offensiveness), new float?(hitDirection));
  }

  [Button("Test Shake", EButtonEnableMode.Always)]
  public void Shake(float magnitude = 1f) => this.Shake(magnitude, new float?(DeadExtensions.PettyRandom.value * 360f));

  public void Shake(float magnitude = 1f, float? direction = null)
  {
    float radians = (float) ((((double) direction ?? (double) Dead.PettyRandom.Range(0.0f, 360f)) + (double) Dead.PettyRandom.Range(-this.angleRand, this.angleRand)) * (Math.PI / 180.0));
    this.velocity = Lengthdir.ToVector2(this.velocity.magnitude + magnitude * this.magnitudeMod * CameraShakerSystem.ShakeAmount, radians);
    this.angularSpeed += magnitude * CameraShakerSystem.ShakeAmount * this.angularMod.WithRandomSign();
  }

  [Button(null, EButtonEnableMode.Always)]
  public void Stop()
  {
    this.velocity = Vector2.zero;
    this.pos = Vector2.zero;
    this.angle = 0.0f;
    this.angularSpeed = 0.0f;
    if (!((UnityEngine.Object) this.target != (UnityEngine.Object) null))
      return;
    this.target.localPosition = Vector3.zero;
    this.target.localEulerAngles = Vector3.zero;
  }

  public void Update()
  {
    float magnitude = this.pos.magnitude;
    if ((double) magnitude > 0.0099999997764825821)
    {
      float radians = this.pos.Angle();
      this.velocity -= Lengthdir.ToVector2(magnitude * this.accelerationMod, radians) * Time.deltaTime;
    }
    this.velocity = Delta.Multiply(this.velocity, 1f - this.frict, Time.deltaTime);
    this.pos += this.velocity * Time.deltaTime;
    this.angularSpeed -= this.angle * this.accelerationMod * Time.deltaTime;
    this.angularSpeed = Delta.Multiply(this.angularSpeed, 1f - this.angularFrict, Time.deltaTime);
    this.angle += this.angularSpeed * Time.deltaTime;
    this.target.localPosition = Vector3.Scale(new Vector3(-this.pos.x, this.pos.y, this.angle), this.positionInfluence);
    this.target.localEulerAngles = Vector3.Scale(new Vector3(-this.pos.x, this.pos.y, this.angle), this.rotationInfluence);
  }

  public float GetHitDirection(global::Hit hit) => !(bool) (UnityEngine.Object) hit.attacker ? Dead.PettyRandom.Range(0.0f, 360f) : hit.attacker.transform.position.AngleTo(hit.target.transform.position);
}
﻿// Decompiled with JetBrains decompiler
// Type: Campaign
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

public class Campaign : MonoBehaviour, ISaveable<CampaignSaveData>
{
  public static Campaign instance;
  public Transform characterContainer;
  public List<Character> characters = new List<Character>();
  public List<CampaignNode> nodes = new List<CampaignNode>();
  public GameObject systems;
  [ReadOnly]
  public TextAsset preset;
  [ReadOnly]
  public string battleTiers;
  public static CampaignData Data;
  [CompilerGenerated]
  public Campaign.Result \u003Cresult\u003Ek__BackingField;

  public void Awake()
  {
    Campaign.instance = this;
    References.Campaign = this;
  }

  public Campaign.Result result
  {
    get => this.\u003Cresult\u003Ek__BackingField;
    set => this.\u003Cresult\u003Ek__BackingField = value;
  }

  public void OnEnable() => global::Events.OnBattleEnd += new UnityAction(this.BattleEnd);

  public void OnDisable() => global::Events.OnBattleEnd -= new UnityAction(this.BattleEnd);

  public void BattleEnd()
  {
    if ((UnityEngine.Object) References.Battle.winner == (UnityEngine.Object) References.Battle.player)
    {
      if (!Campaign.CheckVictory())
        return;
      this.End(Campaign.Result.Win);
      JournalNameHistory.MostRecentNameMissing();
    }
    else
      this.End(Campaign.Result.Lose);
  }

  public static void Begin()
  {
    if (Campaign.Data.GameMode.doSave)
    {
      SaveSystem.DeleteCampaign(Campaign.Data.GameMode);
      SaveSystem.SaveCampaignData<int>(Campaign.Data.GameMode, "seed", Campaign.Data.Seed);
    }
    if (!Campaign.Data.GameMode.mainGameMode)
      return;
    SaveSystem.SaveProgressData<int>("nextSeed", Dead.Random.Seed());
  }

  public void End(Campaign.Result result)
  {
    this.result = result;
    Debug.Log((object) ">>>> CAMPAIGN END <<<<");
    global::Events.InvokeCampaignEnd(result, StatsSystem.Get(), References.PlayerData);
    Campaign.PromptSave();
  }

  public void Final()
  {
    this.StopAllCoroutines();
    ActionQueue.Restart();
    References.Campaign = (Campaign) null;
    global::Events.InvokeCampaignFinal();
  }

  public IEnumerator Start()
  {
    Campaign campaign = this;
    yield return (object) new WaitUntil((Func<bool>) (() => !GameManager.Busy));
    yield return (object) SceneManager.Load("UI", SceneType.Persistent);
    global::Events.InvokeCampaignStart();
    UnityEngine.Random.InitState(Campaign.Data.Seed);
    CampaignNode continueBattleNode = (CampaignNode) null;
    if (Campaign.CheckContinue(Campaign.Data.GameMode))
    {
      CampaignSaveData campaignSaveData = SaveSystem.LoadCampaignData<CampaignSaveData>(Campaign.Data.GameMode, "data");
      StatsSystem.Set(SaveSystem.LoadCampaignData<CampaignStats>(Campaign.Data.GameMode, "stats"));
      campaign.nodes = campaignSaveData.LoadNodes();
      Campaign.Data.GameMode.populator.LoadCharacters(campaign, campaignSaveData.characters);
      References.Player = campaign.characters[campaignSaveData.playerId];
      References.PlayerData = References.Player.data;
      CharacterDisplay.FindAndAssign(References.Player);
      BattleSaveData battleSaveData = SaveSystem.LoadCampaignData<BattleSaveData>(Campaign.Data.GameMode, "battleState", (BattleSaveData) null);
      if (battleSaveData != null)
      {
        CampaignNode characterNode = Campaign.FindCharacterNode(References.Player);
        if (characterNode != null && characterNode.id == battleSaveData.campaignNodeId)
        {
          if (battleSaveData.HasMissingCardData())
            SaveSystem.SaveCampaignData<BattleSaveData>(Campaign.Data.GameMode, "battleState", (BattleSaveData) null);
          else
            continueBattleNode = characterNode;
        }
      }
      if (campaignSaveData.modifiers != null)
      {
        foreach (string modifier1 in campaignSaveData.modifiers)
        {
          GameModifierData modifier2 = AddressableLoader.Get<GameModifierData>("GameModifierData", modifier1);
          if ((UnityEngine.Object) modifier2 != (UnityEngine.Object) null)
            ModifierSystem.AddModifier(Campaign.Data, modifier2);
        }
      }
      global::Events.InvokeCampaignLoaded();
    }
    else
    {
      yield return (object) Campaign.Data.GameMode.generator.Generate(campaign);
      global::Events.InvokePreCampaignPopulate();
      yield return (object) Campaign.Data.GameMode.populator.Populate(campaign);
      StatsSystem.Set(new CampaignStats());
      yield return (object) global::Events.InvokeCampaignGenerated();
      Campaign.FirstSave();
    }
    if (Campaign.Data.GameMode.campaignSystemNames != null)
    {
      foreach (string campaignSystemName in Campaign.Data.GameMode.campaignSystemNames)
        campaign.gameObject.AddComponentByName(campaignSystemName);
    }
    if (Campaign.Data.GameMode.systemsToDisable != null)
    {
      foreach (string typeName in Campaign.Data.GameMode.systemsToDisable)
      {
        System.Type type = System.Type.GetType(typeName);
        if ((object) type != null && UnityEngine.Object.FindObjectOfType(type, true) is GameSystem objectOfType)
        {
          Debug.Log((object) ("Disabling [" + typeName + "]"));
          objectOfType.Disable();
        }
      }
    }
    yield return (object) SceneManager.Load("MapNew", SceneType.Active);
    if (continueBattleNode == null || !Campaign.TryEnterNode(continueBattleNode, false))
      Transition.End();
  }

  public static CampaignNode GetNode(int id) => Campaign.instance.nodes[id];

  public static Character GetCharacter(int id) => Campaign.instance.characters[id];

  public static int GetCharacterId(Character character) => Campaign.instance.characters.IndexOf(character);

  public static void MoveCharacter(Character character, CampaignNode toNode)
  {
    Campaign.FindCharacterNode(character)?.characters?.Remove(Campaign.GetCharacterId(character));
    toNode.characters.Add(Campaign.GetCharacterId(character));
    Campaign.PromptSave();
  }

  public static CampaignNode FindCharacterNode(Character character)
  {
    foreach (CampaignNode node in Campaign.instance.nodes)
    {
      if (node.characters.Contains(Campaign.GetCharacterId(character)))
        return node;
    }
    return (CampaignNode) null;
  }

  public static bool TryEnterNode(CampaignNode node, bool delay = true)
  {
    if (node.cleared || !node.characters.Contains(Campaign.GetCharacterId(References.Player)))
      return false;
    Campaign.instance.StartCoroutine(Campaign.EnterNode(node, delay));
    return true;
  }

  public static IEnumerator EnterNode(CampaignNode node, bool delay = true)
  {
    if ((bool) (UnityEngine.Object) node?.type)
    {
      InputSystem.Disable();
      if (delay)
        yield return (object) Sequences.Wait(0.5f);
      InputSystem.Enable();
      UnityEngine.Random.InitState(node.seed);
      yield return (object) node.type.Run(node);
    }
  }

  public static void FirstSave()
  {
    if (!Campaign.Data.GameMode.doSave)
      return;
    SaveSystem.SaveCampaignData<string>(Campaign.Data.GameMode, "gameVersion", Campaign.Data.GameVersion);
    SaveSystem.SaveCampaignData<string>(Campaign.Data.GameMode, "gameMode", Campaign.Data.GameMode.name);
    string str = Campaign.Data.GameMode.dailyRun ? DailyFetcher.GetDateTime().ToString("dd/MM/yyyy") : DateTime.Now.ToString("dd/MM/yyyy");
    SaveSystem.SaveCampaignData<string>(Campaign.Data.GameMode, "startDate", str);
    Campaign.PromptSave();
  }

  public static void PromptSave()
  {
    if (Campaign.Data.GameMode.doSave)
    {
      SaveSystem.SaveCampaignData<CampaignSaveData>(Campaign.Data.GameMode, "data", Campaign.instance.Save());
      if (Campaign.instance.result != Campaign.Result.None)
        SaveSystem.SaveCampaignData<Campaign.Result>(Campaign.Data.GameMode, "result", Campaign.instance.result);
    }
    global::Events.InvokeCampaignSaved();
  }

  public static bool CheckVictory()
  {
    CampaignNode characterNode = Campaign.FindCharacterNode(References.Player);
    return characterNode.finalNode || characterNode.connections.Count <= 0;
  }

  public static bool CheckContinue(GameMode gameMode) => gameMode.doSave && SaveSystem.CampaignExists(gameMode) && SaveSystem.LoadCampaignData<Campaign.Result>(gameMode, "result", Campaign.Result.None) == Campaign.Result.None && SaveSystem.CampaignDataExists(gameMode, "data");

  public CampaignSaveData Save() => new CampaignSaveData(this);

  public enum Result
  {
    None,
    Win,
    Lose,
    Restart,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignBattlePool
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public class CampaignBattlePool : MonoBehaviour
{
  [SerializeField]
  public int basePoints;
  [SerializeField]
  public CampaignBattlePool.Tier[] tiers;

  public BattleData GetRandomBattle(int tier) => this.tiers[tier].battles.RandomItem<BattleData>();

  public BattleData GetRandomBossBattle(int tier) => this.tiers[tier].bosses.RandomItem<BattleData>();

  public int GetPoints(int tier, int battleLevel)
  {
    CampaignBattlePool.Tier tier1 = this.tiers[tier];
    return this.basePoints + tier1.pointRange.Random() + battleLevel * tier1.pointsAdd;
  }

  [Serializable]
  public struct Tier
  {
    public Vector2Int pointRange;
    public int pointsAdd;
    public BattleData[] battles;
    public BattleData[] bosses;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignBattleRewardPool
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;

public class CampaignBattleRewardPool : MonoBehaviour
{
  public CampaignBattleRewardPool.Pool[] pools;

  [Serializable]
  public struct Pool
  {
    public string name;
    public List<CampaignNodeType> nodeTypes;
    public RewardData[] rewards;
    public List<RewardData> pool;

    public RewardData Pull()
    {
      if (this.pool == null)
        this.pool = new List<RewardData>();
      if (this.pool.Count <= 0)
      {
        this.pool.AddRange((IEnumerable<RewardData>) this.rewards);
        this.pool.Shuffle<RewardData>();
      }
      if (this.pool.Count <= 0)
        throw new Exception("CampaignBattleRewardPool IS EMPTY! God Dammit!");
      RewardData rewardData = this.pool[0];
      this.pool.RemoveAt(0);
      return rewardData;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

[Serializable]
public class CampaignData
{
  [CompilerGenerated]
  public GameMode \u003CGameMode\u003Ek__BackingField;
  [CompilerGenerated]
  public List<GameModifierData> \u003CModifiers\u003Ek__BackingField;
  [CompilerGenerated]
  public string \u003CGameVersion\u003Ek__BackingField;
  [CompilerGenerated]
  public int \u003CSeed\u003Ek__BackingField = -1;

  public GameMode GameMode
  {
    get => this.\u003CGameMode\u003Ek__BackingField;
    set => this.\u003CGameMode\u003Ek__BackingField = value;
  }

  public List<GameModifierData> Modifiers
  {
    get => this.\u003CModifiers\u003Ek__BackingField;
    set => this.\u003CModifiers\u003Ek__BackingField = value;
  }

  public string GameVersion
  {
    get => this.\u003CGameVersion\u003Ek__BackingField;
    set => this.\u003CGameVersion\u003Ek__BackingField = value;
  }

  public int Seed
  {
    get => this.\u003CSeed\u003Ek__BackingField;
    set => this.\u003CSeed\u003Ek__BackingField = value;
  }

  public CampaignData()
  {
  }

  public CampaignData(string gameModeName, int seed = -1)
  {
    GameMode result;
    if (AddressableLoader.TryGet<GameMode>(nameof (GameMode), gameModeName, out result))
      this.Init(result, seed);
    else
      this.Init(AddressableLoader.Get<GameMode>(nameof (GameMode), "GameModeNormal"), seed);
  }

  public CampaignData(GameMode gameMode, int seed = -1) => this.Init(gameMode, seed);

  public static CampaignData Load(GameMode gameMode)
  {
    CampaignData message = new CampaignData();
    message.GameMode = gameMode;
    message.GameVersion = SaveSystem.LoadCampaignData<string>(gameMode, "gameVersion");
    message.Seed = SaveSystem.LoadCampaignData<int>(gameMode, "seed", 0);
    Debug.Log((object) message);
    return message;
  }

  public void Init(GameMode gameMode, int seed = -1)
  {
    this.GameMode = gameMode;
    this.GameVersion = Config.data.version;
    if (seed >= 0)
      this.Seed = seed;
    else if (!gameMode.seed.IsNullOrWhitespace())
    {
      this.Seed = gameMode.seed.ToSeed();
    }
    else
    {
      this.Seed = SaveSystem.LoadProgressData<int>("nextSeed", -1);
      if (this.Seed <= 0)
      {
        this.Seed = Dead.Random.Seed();
        SaveSystem.SaveProgressData<int>("nextSeed", this.Seed);
      }
    }
    Debug.Log((object) this);
    Events.InvokeCampaignDataCreated(this);
  }

  public override string ToString() => string.Format("CampaignData (GameMode: {0}, GameVersion: {1}, Seed: {2})", (object) this.GameMode.name, (object) this.GameVersion, (object) this.Seed);
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignGenerator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignGenerator", menuName = "Campaign/Generator")]
public class CampaignGenerator : ScriptableObject
{
  [SerializeField]
  public string seed;
  [SerializeField]
  public Vector2 nodeSizeRange = new Vector2(1.8f, 2f);
  [SerializeField]
  public float nodeCreationRand = 1.5f;
  [SerializeField]
  public Vector2 nodeSpacing = new Vector2(3.2f, 2f);
  [SerializeField]
  public Vector2 battleDistanceRange = new Vector2(13f, 14f);
  [SerializeField]
  public Vector2 mapDirection = new Vector2(0.67f, 0.33f);
  [SerializeField]
  public TextAsset[] presets;
  [SerializeField]
  public bool instant = true;
  [SerializeField]
  public bool restart;
  [SerializeField]
  public bool restartOnError = true;

  public virtual IEnumerator Generate(Campaign campaign)
  {
    CampaignGenerator campaignGenerator1 = this;
    campaignGenerator1.SetSeed();
    Debug.Log((object) string.Format("[{0}] GENERATING", (object) campaignGenerator1));
    StopWatch.Start();
    campaign.nodes.Clear();
    Dictionary<string, CampaignNodeType> nodeDict = new Dictionary<string, CampaignNodeType>();
    foreach (CampaignNodeType campaignNodeType in AddressableLoader.GetGroup<CampaignNodeType>("CampaignNodeType"))
    {
      if (!campaignNodeType.letter.IsNullOrWhitespace())
        nodeDict[campaignNodeType.letter] = campaignNodeType;
    }
    List<CampaignGenerator.Node> nodes = new List<CampaignGenerator.Node>();
    int attempt = 0;
    while (true)
    {
      CampaignGenerator campaignGenerator = campaignGenerator1;
      Task<bool> task = campaignGenerator1.TryGenerate(campaign, attempt, nodes, (IReadOnlyDictionary<string, CampaignNodeType>) nodeDict);
      yield return (object) new WaitUntil((Func<bool>) (() => task.IsCompleted));
      bool error = task.Result;
      ++attempt;
      if (error)
      {
        Debug.Log((object) "Generation failed!");
        nodes.Clear();
        yield return (object) new WaitUntil((Func<bool>) (() =>
        {
          if (campaignGenerator.restart)
            return true;
          return error && campaignGenerator.restartOnError;
        }));
        campaignGenerator1.restart = false;
      }
      else
        break;
    }
    Debug.Log((object) string.Format("DONE! ({0}ms) [{1} attempts]", (object) StopWatch.Stop(), (object) attempt));
    foreach (CampaignGenerator.Node node in (IEnumerable<CampaignGenerator.Node>) nodes.OrderByDescending<CampaignGenerator.Node, bool>((Func<CampaignGenerator.Node, bool>) (a => a.interactable)))
    {
      CampaignNodeType type = nodeDict[node.type];
      node.campaignNode = new CampaignNode(type, node.x, node.y, node.tier, node.positionIndex, node.areaIndex, node.r);
      campaign.nodes.Add(node.campaignNode);
      node.campaignNode.id = campaign.nodes.Count - 1;
    }
    foreach (CampaignGenerator.Node node in nodes)
    {
      foreach (CampaignGenerator.Node.Connection connection in node.connections)
        node.campaignNode.ConnectTo(connection.node.campaignNode);
    }
    Stack<CampaignNode> campaignNodeStack = new Stack<CampaignNode>();
    List<int> intList = new List<int>();
    campaignNodeStack.Push(campaign.nodes[0]);
    while (campaignNodeStack.Count > 0)
    {
      CampaignNode campaignNode = campaignNodeStack.Pop();
      intList.Add(campaignNode.id);
      bool flag1 = campaignNode.connections.Count > 1;
      for (int index = 0; index < campaignNode.connections.Count; ++index)
      {
        CampaignNode.Connection connection = campaignNode.connections[index];
        if (!intList.Contains(connection.otherId))
        {
          CampaignNode node = Campaign.GetNode(connection.otherId);
          bool flag2 = node.connectedTo > 1;
          node.pathId = flag2 ? -1 : (flag1 ? index : campaignNode.pathId);
          campaignNodeStack.Push(node);
        }
      }
    }
  }

  public async Task<bool> TryGenerate(
    Campaign campaign,
    int attempt,
    List<CampaignGenerator.Node> nodes,
    IReadOnlyDictionary<string, CampaignNodeType> nodeDict)
  {
    Debug.Log((object) string.Format("Attempt #{0}", (object) (attempt + 1)));
    campaign.preset = this.ChoosePreset();
    string[] presetLines = CampaignGenerator.GetPresetLines(campaign.preset);
    Events.InvokeCampaignLoadPreset(ref presetLines);
    int campaignLength = CampaignGenerator.GetCampaignLength(presetLines);
    campaign.battleTiers = presetLines[2];
    List<int> intList = new List<int>();
    foreach (char battleTier in campaign.battleTiers)
    {
      int num = int.Parse(battleTier.ToString());
      intList.Add(num);
    }
    string str1 = presetLines[3];
    int num1 = 0;
    float x = 0.0f;
    List<CampaignGenerator.Node> nodeList1 = new List<CampaignGenerator.Node>();
    for (int index1 = 0; index1 < campaignLength; ++index1)
    {
      string str2 = str1[index1].ToString();
      int result;
      int.TryParse(str2, out result);
      List<string> stringList = new List<string>();
      for (int index2 = 0; index2 <= 1; ++index2)
      {
        string str3 = presetLines[index2][index1].ToString();
        if (!str3.IsNullOrWhitespace())
          stringList.Add(str3);
      }
      if (result != num1)
      {
        CampaignNodeType type = nodeDict["area" + str2];
        float y = this.nodeSpacing.y * 0.25f.WithRandomSign();
        CampaignGenerator.Node node = this.CreateNode(x - this.nodeSpacing.x * 0.5f, y, type, intList[index1], index1, result);
        nodes.Add(node);
        node.interactable = false;
      }
      num1 = result;
      float y1 = (float) ((double) -(stringList.Count - 1) * (double) this.nodeSpacing.y * 0.5);
      List<CampaignGenerator.Node> nodeList2 = new List<CampaignGenerator.Node>();
      foreach (string key in stringList)
      {
        CampaignNodeType type = nodeDict[key];
        CampaignGenerator.Node node = this.CreateNode(x, y1, type, intList[index1], index1, result);
        nodes.Add(node);
        nodeList2.Add(node);
        y1 += this.nodeSpacing.y;
      }
      CampaignNodeType type1 = nodeDict[str2];
      for (int index3 = 0; index3 < 2; ++index3)
      {
        CampaignGenerator.Node node = this.CreateNode(x, this.nodeSpacing.y * UnityEngine.Random.Range(-0.5f, 0.5f), type1, -1, 0, result);
        nodes.Add(node);
        node.interactable = false;
      }
      x += this.nodeSpacing.x;
      if (nodeList1.Count > 0)
      {
        int num2 = Mathf.Max(nodeList2.Count, nodeList1.Count);
        for (int index4 = 0; index4 < num2; ++index4)
        {
          CampaignGenerator.Node other = nodeList2[index4 % nodeList2.Count];
          nodeList1[index4 % nodeList1.Count].Connect(other);
        }
      }
      nodeList1 = nodeList2;
    }
    Events.InvokeCampaignNodesCreated(ref nodes, this.nodeSpacing);
    await Task.Run((System.Action) (() => CampaignGenerator.ShuffleNodes(nodes)));
    bool flag = false;
    foreach (CampaignGenerator.Node node1 in nodes)
    {
      if (node1.interactable)
      {
        foreach (CampaignGenerator.Node.Connection connection in node1.connections)
        {
          CampaignGenerator.Line line = new CampaignGenerator.Line(node1.x, node1.y, connection.node.x, connection.node.y);
          foreach (CampaignGenerator.Node node2 in nodes)
          {
            if (node2 != node1 && node2 != connection.node && node2.interactable && ((double) node2.x > (double) node1.x && (double) node2.x < (double) connection.node.x || (double) node2.x > (double) connection.node.x && (double) node2.x < (double) node1.x) && ((double) node2.y > (double) node1.y && (double) node2.y < (double) connection.node.y || (double) node2.y > (double) connection.node.y && (double) node2.y < (double) node1.y) && CampaignGenerator.LineIntersectsCircle(line, node2.x, node2.y, node2.r))
            {
              Debug.Log((object) string.Format("Error: [{0}] INTERSECTS [{1}]", (object) connection, (object) node2));
              connection.color = Color.yellow;
              node2.color = Color.red;
              flag = true;
              break;
            }
          }
          if (flag)
            break;
        }
        if (flag)
          break;
      }
    }
    return flag;
  }

  public void SetSeed()
  {
    if (this.seed.IsNullOrWhitespace())
      return;
    UnityEngine.Random.InitState(this.seed.ToSeed());
  }

  public TextAsset ChoosePreset() => this.presets.Length != 0 ? this.presets.RandomItem<TextAsset>() : throw new Exception("Campaign Generation Error: No Presets Found!");

  public static string[] GetPresetLines(TextAsset preset)
  {
    string[] strArray = Regex.Split(preset.text, "\r\n|\n|\r");
    int length = strArray.Length > 1 ? strArray.Length : throw new Exception("Campaign Generation Error: Preset [" + preset.name + "] Must Contain AT LEAST 2 lines (1st for nodes, last for battle tiers)");
    string[] presetLines = new string[length];
    for (int index = 0; index < length; ++index)
      presetLines[index] = strArray[index];
    return presetLines;
  }

  public static int GetCampaignLength(string[] lines)
  {
    int length = lines[0].Length;
    for (int index = 1; index < lines.Length; ++index)
    {
      if (lines[index].Length != length)
        throw new Exception("Campaign Generation Error: Preset line length mismatch — all lines in the preset file must be the same length");
    }
    return length;
  }

  public CampaignGenerator.Node CreateNode(
    float x,
    float y,
    CampaignNodeType type,
    int tier,
    int positionIndex,
    int areaIndex,
    float r = 1f)
  {
    Vector2 vector2 = new Vector2(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)).normalized * UnityEngine.Random.Range(0.0f, this.nodeCreationRand);
    x += vector2.x;
    y += vector2.y;
    return new CampaignGenerator.Node(x, y, this.nodeSizeRange.Random() * type.size * r, tier, positionIndex, areaIndex, type.letter);
  }

  public static void ShuffleNodes(List<CampaignGenerator.Node> nodes)
  {
    bool flag = true;
    for (int index = 10000; flag && index > 0; --index)
    {
      flag = false;
      foreach (CampaignGenerator.Node node1 in nodes)
      {
        foreach (CampaignGenerator.Node node2 in nodes)
        {
          if (node1 != node2)
          {
            Vector2 vector2_1 = new Vector2(node1.x - node2.x, node1.y - node2.y);
            if ((double) vector2_1.magnitude < (double) node1.r + (double) node2.r)
            {
              Vector2 vector2_2 = vector2_1.normalized * 0.01f;
              node1.x += vector2_2.x;
              node1.y += vector2_2.y;
              node2.x -= vector2_2.x;
              node2.y -= vector2_2.y;
              flag = true;
            }
          }
        }
        foreach (CampaignGenerator.Node.Connection connection in node1.connections)
        {
          Vector2 vector2_3 = new Vector2(node1.x - connection.node.x, node1.y - connection.node.y);
          float num = vector2_3.magnitude - (node1.r + connection.node.r);
          if ((double) num > 0.0)
          {
            Vector2 vector2_4 = vector2_3.normalized * (1f / 1000f) * num;
            node1.x -= vector2_4.x;
            node1.y -= vector2_4.y;
            connection.node.x += vector2_4.x;
            connection.node.y += vector2_4.y;
          }
        }
      }
    }
  }

  public static void ShuffleNodes(List<CampaignNode> nodes)
  {
    bool flag = true;
    for (int index = 10000; flag && index > 0; --index)
    {
      flag = false;
      foreach (CampaignNode node1 in nodes)
      {
        foreach (CampaignNode node2 in nodes)
        {
          if (node1 != node2)
          {
            Vector2 vector2_1 = new Vector2(node1.position.x - node2.position.x, node1.position.y - node2.position.y);
            if ((double) vector2_1.magnitude < (double) node1.radius + (double) node2.radius)
            {
              Vector2 vector2_2 = vector2_1.normalized * 0.01f;
              node1.position.x += vector2_2.x;
              node1.position.y += vector2_2.y;
              node2.position.x -= vector2_2.x;
              node2.position.y -= vector2_2.y;
              flag = true;
            }
          }
        }
        foreach (CampaignNode.Connection connection in node1.connections)
        {
          CampaignNode.Connection c = connection;
          CampaignNode campaignNode = nodes.FirstOrDefault<CampaignNode>((Func<CampaignNode, bool>) (a => a.id == c.otherId));
          if (campaignNode != null)
          {
            Vector2 vector2_3 = new Vector2(node1.position.x - campaignNode.position.x, node1.position.y - campaignNode.position.y);
            float num = vector2_3.magnitude - (node1.radius + campaignNode.radius);
            if ((double) num > 0.0)
            {
              Vector2 vector2_4 = vector2_3.normalized * (1f / 1000f * num);
              node1.position.x -= vector2_4.x;
              node1.position.y -= vector2_4.y;
              campaignNode.position.x += vector2_4.x;
              campaignNode.position.y += vector2_4.y;
            }
          }
        }
      }
    }
  }

  public static bool LineIntersectsCircle(
    CampaignGenerator.Line line,
    float cx,
    float cy,
    float r)
  {
    float num1 = line.x1 - cx;
    float num2 = line.x2 - cx;
    float num3 = line.y1 - cy;
    float num4 = line.y2 - cy;
    double num5 = (double) num2 - (double) num1;
    float num6 = num4 - num3;
    float num7 = (float) (num5 * num5 + (double) num6 * (double) num6);
    float num8 = (float) ((double) num1 * (double) num4 - (double) num2 * (double) num3);
    return (double) r * (double) r * (double) num7 > (double) num8 * (double) num8;
  }

  public class Line
  {
    public float x1;
    public float y1;
    public float x2;
    public float y2;

    public Line(float x1, float y1, float x2, float y2)
    {
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
    }
  }

  public class Node
  {
    public float x;
    public float y;
    public float r;
    public int tier;
    public int positionIndex;
    public string type;
    public Color color = Color.white;
    public CampaignNode campaignNode;
    public int areaIndex;
    public readonly List<CampaignGenerator.Node.Connection> connections = new List<CampaignGenerator.Node.Connection>();
    public int connectionCount;
    public bool interactable = true;

    public Node(
      float x,
      float y,
      float r,
      int tier,
      int positionIndex,
      int areaIndex,
      string type)
    {
      this.x = x;
      this.y = y;
      this.r = r;
      this.tier = tier;
      this.positionIndex = positionIndex;
      this.areaIndex = areaIndex;
      this.type = type;
    }

    public void Connect(CampaignGenerator.Node other)
    {
      this.connections.Add(new CampaignGenerator.Node.Connection(other));
      ++this.connectionCount;
      ++other.connectionCount;
    }

    public override string ToString() => string.Format("Node ({0}, {1})", (object) this.x, (object) this.y);

    public class Connection
    {
      public CampaignGenerator.Node node;
      public Color color = Color.gray;

      public Connection(CampaignGenerator.Node node) => this.node = node;

      public override string ToString() => string.Format("Connection to {0}", (object) this.node);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNode
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[Serializable]
public class CampaignNode : ISaveable<CampaignNodeSaveData>
{
  public string name = "Salty Spicelands";
  public int id;
  [CompilerGenerated]
  public CampaignNodeType \u003Ctype\u003Ek__BackingField;
  public int seed;
  public Vector2 position;
  public int tier;
  public int positionIndex;
  public int areaIndex;
  public List<CampaignNode.Connection> connections;
  public List<int> characters;
  public bool revealed;
  public bool cleared;
  public float radius;
  public bool glow;
  public bool finalNode;
  public Dictionary<string, object> data;
  public int connectedTo;
  public int pathId = -1;
  public int dataLinkedTo = -1;
  public List<int> linkedToThis;

  public CampaignNodeType type
  {
    get => this.\u003Ctype\u003Ek__BackingField;
    set => this.\u003Ctype\u003Ek__BackingField = value;
  }

  public void CopyData(CampaignNode otherNode) => this.data = otherNode.data.ToDictionary<KeyValuePair<string, object>, string, object>((Func<KeyValuePair<string, object>, string>) (entry => entry.Key), new Func<KeyValuePair<string, object>, object>(this.CloneDataValue));

  public object CloneDataValue(KeyValuePair<string, object> pair) => !(pair.Value is ICloneable cloneable) ? pair.Value : cloneable.Clone();

  public CampaignNode()
  {
  }

  public CampaignNode(
    CampaignNodeType type,
    float x,
    float y,
    int tier,
    int positionIndex,
    int areaIndex,
    float radius)
  {
    this.SetType(type);
    this.position = new Vector2(x, y);
    this.tier = tier;
    this.positionIndex = positionIndex;
    this.areaIndex = areaIndex;
    this.radius = radius;
    this.seed = Dead.Random.Seed();
    this.connections = new List<CampaignNode.Connection>();
    this.characters = new List<int>();
    this.finalNode = type.finalNode;
    if (type.canEnter)
      return;
    this.cleared = true;
  }

  public virtual IEnumerator SetUp() => (IEnumerator) null;

  public virtual IEnumerator Run() => (IEnumerator) null;

  public void ConnectTo(CampaignNode other)
  {
    ++other.connectedTo;
    CampaignNode.Connection connection = new CampaignNode.Connection()
    {
      otherId = other.id
    };
    if (this.connections.Count == 0)
    {
      connection.direction = 1f;
    }
    else
    {
      float direction = this.connections[0].direction;
      connection.direction = direction * -1f;
    }
    this.connections.Insert(0, connection);
  }

  public bool CanReceiveCharacter(Character character) => character.GetCompanionCount() <= character.data.companionLimit;

  public void SetType(CampaignNodeType type)
  {
    this.type = type;
    this.name = type.zoneName;
    this.revealed = type.startRevealed;
  }

  public string GetDesc()
  {
    string desc = "";
    List<string> stringList = new List<string>();
    foreach (int character in this.characters)
    {
      List<RewardData> rewards = Campaign.GetCharacter(character).GetComponent<BattleRewards>()?.rewards;
      if (rewards != null)
      {
        foreach (RewardData rewardData in rewards)
          stringList.Add(rewardData.title);
      }
    }
    if (stringList.Count > 0)
    {
      string str1 = "#BABABA";
      if (stringList.Count == 1)
      {
        desc = "<color=" + str1 + ">Reward:</color>\n" + stringList[0];
      }
      else
      {
        desc = "<color=" + str1 + ">Rewards:</color>";
        foreach (string str2 in stringList)
          desc = desc + "\n" + str2;
      }
    }
    return desc;
  }

  public void SetCleared()
  {
    if (this.cleared)
      return;
    this.cleared = true;
    Campaign.PromptSave();
  }

  public CampaignNodeSaveData Save() => new CampaignNodeSaveData(this);

  [Serializable]
  public class Connection
  {
    public int otherId;
    public float direction;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class CampaignNodeSaveData : ILoadable<CampaignNode>
{
  public string name;
  public int id;
  public string typeName;
  public int seed;
  public Vector2 position;
  public int tier;
  public int positionIndex;
  public int areaIndex;
  public List<CampaignNode.Connection> connections;
  public List<int> characters;
  public bool revealed;
  public bool cleared;
  public bool glow;
  public bool finalNode;
  public Dictionary<string, object> data;

  public CampaignNodeSaveData()
  {
  }

  public CampaignNodeSaveData(CampaignNode node)
  {
    this.name = node.name;
    this.id = node.id;
    this.typeName = node.type.name;
    this.seed = node.seed;
    this.position = node.position;
    this.tier = node.tier;
    this.positionIndex = node.positionIndex;
    this.areaIndex = node.areaIndex;
    this.connections = node.connections;
    this.characters = node.characters;
    this.revealed = node.revealed;
    this.cleared = node.cleared;
    this.glow = node.glow;
    this.finalNode = node.finalNode;
    this.data = node.data;
  }

  public CampaignNode Load()
  {
    CampaignNodeType type = AddressableLoader.Get<CampaignNodeType>("CampaignNodeType", this.typeName);
    CampaignNode campaignNode = new CampaignNode();
    campaignNode.SetType(type);
    campaignNode.name = this.name;
    campaignNode.id = this.id;
    campaignNode.position = this.position;
    campaignNode.tier = this.tier;
    campaignNode.positionIndex = this.positionIndex;
    campaignNode.areaIndex = this.areaIndex;
    campaignNode.seed = this.seed;
    campaignNode.connections = this.connections;
    campaignNode.characters = this.characters;
    campaignNode.revealed = this.revealed;
    campaignNode.cleared = this.cleared;
    campaignNode.glow = this.glow;
    campaignNode.finalNode = this.finalNode;
    campaignNode.data = this.data;
    return campaignNode;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeType", menuName = "Campaign/Node Type/Basic")]
public class CampaignNodeType : DataFile
{
  public string letter;
  public string zoneName;
  public bool mustClear;
  public bool canSkip;
  public bool canEnter;
  public bool isBattle;
  public bool isBoss;
  public bool modifierReward;
  public bool interactable;
  public bool startRevealed;
  public bool finalNode;
  public MapNode mapNodePrefab;
  public Sprite mapNodeSprite;
  public float size = 1f;
  public bool canLink;

  public virtual IEnumerator SetUp(CampaignNode node) => (IEnumerator) null;

  public virtual IEnumerator Run(CampaignNode node) => (IEnumerator) null;

  public virtual bool HasMissingData(CampaignNode node) => false;
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeBattle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using NaughtyAttributes;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AddressableAssets;

[CreateAssetMenu(fileName = "CampaignNodeTypeBattle", menuName = "Campaign/Node Type/Battle")]
public class CampaignNodeTypeBattle : CampaignNodeType
{
  public EventReference overrideMusic;
  public bool overrideBackground;
  [ShowIf("overrideBackground")]
  public AssetReferenceGameObject background;

  public override IEnumerator Run(CampaignNode node)
  {
    yield return (object) Transition.To("Battle");
    BattleSetUp battleSetUp = Object.FindObjectOfType<BattleSetUp>();
    if ((bool) (Object) battleSetUp)
      yield return (object) battleSetUp.Run();
    BattleSaveSystem objectOfType = Object.FindObjectOfType<BattleSaveSystem>();
    if (objectOfType != null && objectOfType.TryLoadBattleState(node))
    {
      yield return (object) objectOfType.LoadRoutine();
    }
    else
    {
      object obj;
      if (node.data.TryGetValue("battle", out obj) && obj is string assetName)
      {
        BattleData battleData = AddressableLoader.Get<BattleData>("BattleData", assetName);
        if (battleData != null && (bool) (Object) battleData.setUpScript)
          yield return (object) battleData.setUpScript.Run();
      }
    }
    Transition.End();
    if ((bool) (Object) battleSetUp)
      yield return (object) battleSetUp.StartAnimation();
    yield return (object) References.Battle.Run();
    if (Campaign.CheckVictory())
    {
      yield return (object) Transition.WaitUntilDone(Transition.Begin());
      yield return (object) CampaignNodeTypeBattle.BattleEnd(node);
      Routine routine = new Routine(Sequences.EndCampaign("MainMenu"));
    }
    else
    {
      yield return (object) Transition.WaitUntilDone(Transition.Begin());
      yield return (object) CampaignNodeTypeBattle.BattleEnd(node);
      yield return (object) Sequences.SceneChange("MapNew");
      Transition.End();
      Events.InvokePostBattle(node);
      yield return (object) ActionQueue.Wait();
      yield return (object) CampaignNodeTypeBattle.CheckRecovery();
      yield return (object) MapNew.CheckCompanionLimit();
    }
  }

  public static IEnumerator BattleEnd(CampaignNode node)
  {
    Character player = Battle.instance.player;
    if ((bool) (Object) player.handContainer)
      player.handContainer.Clear();
    if ((bool) (Object) player.reserveContainer)
      player.reserveContainer.Clear();
    if ((bool) (Object) player.drawContainer)
      player.drawContainer.Clear();
    if ((bool) (Object) player.discardContainer)
      player.discardContainer.Clear();
    List<Entity> cards = References.Battle.cards;
    Debug.Log((object) string.Format("BattleEnd → Destroying [{0}] Cards!", (object) cards.Count));
    for (int index = cards.Count - 1; index >= 0; --index)
      CardManager.ReturnToPool(cards[index]);
    yield return (object) StatusEffectSystem.Clear();
    if (player.entity.alive && player.data.inventory.reserve != null)
    {
      node.SetCleared();
      if (player.entity.display is CharacterDisplay display)
        yield return (object) display.handOverlay.Hide();
    }
  }

  public static IEnumerator CheckRecovery()
  {
    if (References.Player.entity.display is CharacterDisplay display)
      yield return (object) display.deckDisplay.companionRecoverSequence.Run();
  }

  public override bool HasMissingData(CampaignNode node)
  {
    object obj;
    if (node.data.TryGetValue("battle", out obj) && obj is string assetName)
    {
      BattleData battleData = AddressableLoader.Get<BattleData>("BattleData", assetName);
      if (battleData != null && (bool) (Object) battleData.setUpScript)
      {
        BattleWaveManager.WaveData[] saveCollection = node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves");
        if (saveCollection == null)
          return true;
        foreach (BattleWaveManager.WaveData waveData in saveCollection)
        {
          for (int index = 0; index < waveData.Count; ++index)
          {
            if ((Object) waveData.PeekCardData(index) == (Object) null)
              return true;
          }
        }
        return false;
      }
    }
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeBoss
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeBoss", menuName = "Campaign/Node Type/Boss")]
public class CampaignNodeTypeBoss : CampaignNodeTypeBattle
{
  [SerializeField]
  public CampaignNodeTypeBoss.AreaProfile[] areaProfiles;

  public override IEnumerator SetUp(CampaignNode node)
  {
    this.GetRewards(node);
    yield break;
  }

  public void GetRewards(CampaignNode node)
  {
    CampaignNodeTypeBoss.AreaProfile profile = ((IEnumerable<CampaignNodeTypeBoss.AreaProfile>) this.areaProfiles).FirstOrDefault<CampaignNodeTypeBoss.AreaProfile>((Func<CampaignNodeTypeBoss.AreaProfile, bool>) (a => a.areaIndex == node.areaIndex));
    if (profile == null)
      return;
    List<BossRewardData.Data> rewards = CampaignNodeTypeBoss.GetRewards(profile);
    CampaignNode campaignNode = node;
    if (campaignNode.data == null)
      campaignNode.data = new Dictionary<string, object>();
    node.data.Add("rewards", (object) new CampaignNodeTypeBoss.RewardData()
    {
      rewards = rewards,
      canTake = profile.canTake
    });
  }

  public static List<BossRewardData.Data> GetRewards(CampaignNodeTypeBoss.AreaProfile profile)
  {
    List<BossRewardData.Data> rewards = new List<BossRewardData.Data>();
    UnityEngine.Random.InitState(Campaign.FindCharacterNode(References.Player).seed);
    foreach (BossRewardData bossRewardData in (IEnumerable<BossRewardData>) ((IEnumerable<BossRewardData>) profile.pool.bossRewards).InRandomOrder<BossRewardData>())
    {
      BossRewardData.Data data = bossRewardData.Pull();
      rewards.Add(data);
    }
    return rewards;
  }

  [Serializable]
  public class AreaProfile
  {
    public int areaIndex;
    public int canTake = 2;
    public BossRewardPool pool;
  }

  [Serializable]
  public class RewardData
  {
    public List<BossRewardData.Data> rewards;
    public int canTake;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeCharm
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeCharm", menuName = "Campaign/Node Type/Charm")]
public class CampaignNodeTypeCharm : CampaignNodeTypeEvent
{
  [SerializeField]
  public CardUpgradeData force;

  public override IEnumerator SetUp(CampaignNode node)
  {
    yield return (object) null;
    CharacterRewards component = References.Player.GetComponent<CharacterRewards>();
    CardUpgradeData cardUpgradeData;
    if ((bool) (Object) this.force)
    {
      cardUpgradeData = this.force;
      component.PullOut("Charms", (DataFile) cardUpgradeData);
    }
    else
      cardUpgradeData = component.Pull<CardUpgradeData>((object) node, "Charms");
    node.data = new Dictionary<string, object>()
    {
      {
        "open",
        (object) false
      },
      {
        "charm",
        (object) cardUpgradeData.name
      }
    };
  }

  public override bool HasMissingData(CampaignNode node)
  {
    object obj;
    return !node.data.TryGetValue("charm", out obj) || !(obj is string assetName) || (Object) AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", assetName) == (Object) null;
  }

  public override IEnumerator Populate(CampaignNode node)
  {
    EventRoutineCharm objectOfType = Object.FindObjectOfType<EventRoutineCharm>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeCharmShop
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeCharmShop", menuName = "Campaign/Node Type/Charm Shop")]
public class CampaignNodeTypeCharmShop : CampaignNodeTypeEvent
{
  [SerializeField]
  public int cardChoices = 1;
  [SerializeField]
  public CampaignNodeTypeCharmShop.UpgradedCard[] forceCards;
  [SerializeField]
  public int choices = 3;
  [SerializeField]
  public CardUpgradeData[] force;
  [SerializeField]
  public Vector2Int priceRange = new Vector2Int(20, 80);
  [SerializeField]
  public int priceOffset = -5;

  public override IEnumerator SetUp(CampaignNode node)
  {
    yield return (object) null;
    CharacterRewards component = References.Player.GetComponent<CharacterRewards>();
    List<EventRoutineCharmShop.UpgradedCard> upgradedCardList = new List<EventRoutineCharmShop.UpgradedCard>();
    CampaignNodeTypeCharmShop.UpgradedCard[] forceCards = this.forceCards;
    if (forceCards != null && forceCards.Length > 0)
    {
      foreach (CampaignNodeTypeCharmShop.UpgradedCard forceCard in this.forceCards)
      {
        upgradedCardList.Add(new EventRoutineCharmShop.UpgradedCard()
        {
          cardDataName = forceCard.cardData.name,
          upgradeNames = ((IEnumerable<CardUpgradeData>) forceCard.upgrades).Select<CardUpgradeData, string>((Func<CardUpgradeData, string>) (a => a.name)).ToArray<string>(),
          price = forceCard.price,
          priceFactor = forceCard.priceFactor
        });
        component.PullOut("Items", (DataFile) forceCard.cardData);
      }
    }
    int num1 = this.cardChoices - upgradedCardList.Count;
    for (int index = 0; index < num1; ++index)
    {
      CardData card = component.Pull<CardData>((object) node, "Items");
      int itemCount = 1;
      if ((double) UnityEngine.Random.Range(0.0f, 1f) < 0.0099999997764825821)
        itemCount = 2;
      CardUpgradeData[] source = component.Pull<CardUpgradeData>((object) node, "Charms", itemCount, false, (Predicate<DataFile>) (a => a is CardUpgradeData cardUpgradeData && cardUpgradeData.CanAssign(card)));
      float f = (float) card.value * UnityEngine.Random.Range(0.8f, 1.2f) + (float) (source.Length * UnityEngine.Random.Range(10, 20)) + (float) this.priceOffset;
      EventRoutineCharmShop.UpgradedCard upgradedCard = new EventRoutineCharmShop.UpgradedCard()
      {
        cardDataName = card.name,
        price = Mathf.RoundToInt(f),
        priceFactor = 1f
      };
      if (source.Length != 0)
        upgradedCard.upgradeNames = ((IEnumerable<CardUpgradeData>) source).Select<CardUpgradeData, string>((Func<CardUpgradeData, string>) (a => a.name)).ToArray<string>();
      upgradedCardList.Add(upgradedCard);
    }
    List<EventRoutineCharmShop.CharmShopItemData> charmShopItemDataList = new List<EventRoutineCharmShop.CharmShopItemData>();
    CardUpgradeData[] force = this.force;
    if (force != null && force.Length > 0)
    {
      foreach (CardUpgradeData upgradeData in this.force)
        charmShopItemDataList.Add(new EventRoutineCharmShop.CharmShopItemData(upgradeData.name, this.GetPrice(upgradeData)));
      component.PullOut("Charms", (IEnumerable<DataFile>) this.force);
    }
    int num2 = this.choices - charmShopItemDataList.Count;
    for (int index = 0; index < num2; ++index)
    {
      CardUpgradeData upgradeData = component.Pull<CardUpgradeData>((object) node, "Charms");
      charmShopItemDataList.Add(new EventRoutineCharmShop.CharmShopItemData(upgradeData.name, this.GetPrice(upgradeData)));
    }
    node.data = new Dictionary<string, object>()
    {
      {
        "data",
        (object) new EventRoutineCharmShop.Data()
        {
          cards = upgradedCardList,
          items = charmShopItemDataList
        }
      }
    };
  }

  public override bool HasMissingData(CampaignNode node)
  {
    EventRoutineCharmShop.Data data = node.data.Get<EventRoutineCharmShop.Data>("data");
    foreach (EventRoutineCharmShop.UpgradedCard card in data.cards)
    {
      if (MissingCardSystem.IsMissing(card.cardDataName))
        return true;
    }
    foreach (EventRoutineCharmShop.CharmShopItemData charmShopItemData in data.items)
    {
      if ((UnityEngine.Object) AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", charmShopItemData.upgradeDataName) == (UnityEngine.Object) null)
        return true;
    }
    return false;
  }

  public int GetPrice(CardUpgradeData upgradeData) => this.priceRange.Random() + upgradeData.tier * 10 + this.priceOffset;

  public override IEnumerator Populate(CampaignNode node)
  {
    EventRoutineCharmShop objectOfType = UnityEngine.Object.FindObjectOfType<EventRoutineCharmShop>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }

  [Serializable]
  public class UpgradedCard
  {
    public CardData cardData;
    public CardUpgradeData[] upgrades;
    public int price;
    public float priceFactor;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeClunkShop
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeClunkShop", menuName = "Campaign/Node Type/Clunk Shop")]
public class CampaignNodeTypeClunkShop : CampaignNodeTypeEvent
{
  [Header("Stock")]
  [SerializeField]
  public int itemCount = 3;
  [SerializeField]
  public int charmCount = 3;
  [SerializeField]
  public CardUpgradeData[] charmPool;
  [Header("Prices")]
  [SerializeField]
  [MinMaxSlider(0.0f, 2f)]
  public Vector2 priceFactorRange = new Vector2(0.8f, 1.2f);
  [SerializeField]
  public int discounts = 1;
  [SerializeField]
  public float discountFactor = 0.5f;
  [SerializeField]
  public Vector2Int charmPriceRange = new Vector2Int(60, 80);

  public override IEnumerator SetUp(CampaignNode node)
  {
    yield return (object) null;
    CharacterRewards component = References.Player.GetComponent<CharacterRewards>();
    EventRoutineClunkShop.Data data = new EventRoutineClunkShop.Data();
    Predicate<DataFile> predicate = (Predicate<DataFile>) (a => a is CardData cardData1 && cardData1.cardType.name == "Clunker");
    CampaignNode pulledBy = node;
    int itemCount = this.itemCount;
    Predicate<DataFile> match = predicate;
    CardData[] cardDataArray = component.Pull<CardData>((object) pulledBy, "Items", itemCount, false, match);
    data.cards = new List<EventRoutineClunkShop.CardItem>();
    foreach (CardData cardData2 in cardDataArray)
      data.cards.Add(new EventRoutineClunkShop.CardItem(cardData2));
    List<CardUpgradeData> list1 = new List<CardUpgradeData>((IEnumerable<CardUpgradeData>) this.charmPool);
    list1.Shuffle<CardUpgradeData>();
    data.charms = new List<EventRoutineClunkShop.CharmItem>();
    for (int index = 0; index < this.charmCount; ++index)
    {
      CardUpgradeData cardUpgradeData = list1.Count > 0 ? list1[0] : (CardUpgradeData) null;
      if (!((UnityEngine.Object) cardUpgradeData == (UnityEngine.Object) null))
      {
        list1.RemoveAt(0);
        data.charms.Add(new EventRoutineClunkShop.CharmItem(cardUpgradeData.name, this.charmPriceRange.Random()));
      }
      else
        break;
    }
    if (this.discounts > 0)
    {
      List<EventRoutineClunkShop.Item> list2 = new List<EventRoutineClunkShop.Item>();
      list2.AddRange((IEnumerable<EventRoutineClunkShop.Item>) data.cards);
      list2.AddRange((IEnumerable<EventRoutineClunkShop.Item>) data.charms);
      list2.Shuffle<EventRoutineClunkShop.Item>();
      for (int index = 0; index < this.discounts; ++index)
      {
        EventRoutineClunkShop.Item obj = list2.Count > 0 ? list2[0] : (EventRoutineClunkShop.Item) null;
        if (obj != null)
        {
          list2.RemoveAt(0);
          obj.priceFactor = this.discountFactor;
        }
        else
          break;
      }
    }
    node.data = new Dictionary<string, object>()
    {
      {
        "shopData",
        (object) data
      }
    };
  }

  public override bool HasMissingData(CampaignNode node)
  {
    foreach (EventRoutineClunkShop.CardItem card in node.data.Get<EventRoutineClunkShop.Data>("shopData").cards)
    {
      if (MissingCardSystem.IsMissing(card.dataName))
        return true;
    }
    return false;
  }

  public override IEnumerator Populate(CampaignNode node)
  {
    EventRoutineClunkShop objectOfType = UnityEngine.Object.FindObjectOfType<EventRoutineClunkShop>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeCompanion
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeCompanion", menuName = "Campaign/Node Type/Companion")]
public class CampaignNodeTypeCompanion : CampaignNodeTypeEvent
{
  [SerializeField]
  public int choices = 3;
  [SerializeField]
  public List<CardData> force;

  public override IEnumerator SetUp(CampaignNode node)
  {
    yield return (object) null;
    CharacterRewards component = References.Player.GetComponent<CharacterRewards>();
    List<CardData> cardDataList = this.force.Clone<CardData>();
    if (cardDataList.Count > 0)
      component.PullOut("Units", (IEnumerable<DataFile>) cardDataList);
    int itemCount = this.choices - cardDataList.Count;
    cardDataList.AddRange((IEnumerable<CardData>) component.Pull<CardData>((object) node, "Units", itemCount));
    node.data = new Dictionary<string, object>()
    {
      {
        "damage",
        (object) 0
      },
      {
        "cards",
        (object) cardDataList.ToSaveCollectionOfNames<CardData>()
      }
    };
  }

  public override IEnumerator Populate(CampaignNode node)
  {
    EventRoutineCompanion objectOfType = Object.FindObjectOfType<EventRoutineCompanion>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }

  public override bool HasMissingData(CampaignNode node) => MissingCardSystem.HasMissingData((IEnumerable<string>) node.data.GetSaveCollection<string>("cards"));
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeCopyItem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeCopyItem", menuName = "Campaign/Node Type/Copy Item")]
public class CampaignNodeTypeCopyItem : CampaignNodeTypeEvent
{
  [SerializeField]
  public int canCopy = 1;

  public override IEnumerator SetUp(CampaignNode node)
  {
    node.data = new Dictionary<string, object>()
    {
      {
        "canCopy",
        (object) this.canCopy
      },
      {
        "enterCount",
        (object) 0
      }
    };
    yield return (object) null;
  }

  public override bool HasMissingData(CampaignNode node) => false;

  public override IEnumerator Populate(CampaignNode node)
  {
    EventRoutineCopyItem objectOfType = Object.FindObjectOfType<EventRoutineCopyItem>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeCurseItems
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeCurseItems", menuName = "Campaign/Node Type/Curse Items")]
public class CampaignNodeTypeCurseItems : CampaignNodeTypeEvent
{
  [SerializeField]
  public int choices = 3;
  [SerializeField]
  public int curseCards = 2;
  [SerializeField]
  public List<CardData> force;
  [SerializeField]
  public CardData[] cursePool;
  [SerializeField]
  public CardData[] extraCards;
  [SerializeField]
  public CardData[] illegalCards;

  public override IEnumerator SetUp(CampaignNode node)
  {
    yield return (object) null;
    Campaign objectOfType = UnityEngine.Object.FindObjectOfType<Campaign>();
    CharacterRewards characterRewards = objectOfType.GetComponent<CharacterRewards>();
    if (!(bool) (UnityEngine.Object) characterRewards)
    {
      characterRewards = objectOfType.gameObject.AddComponent<CharacterRewards>();
      List<ClassData> group = AddressableLoader.GetGroup<ClassData>("ClassData");
      HashSet<RewardPool> rewardPoolSet = new HashSet<RewardPool>();
      foreach (ClassData classData in group)
      {
        foreach (RewardPool rewardPool in classData.rewardPools)
        {
          if (rewardPool.type == "Items")
            rewardPoolSet.Add(rewardPool);
        }
      }
      foreach (RewardPool rewardPool in rewardPoolSet)
        characterRewards.Add(rewardPool);
      characterRewards.PullOut("Items", (IEnumerable<DataFile>) this.illegalCards);
      characterRewards.Add("Items", (IEnumerable<DataFile>) this.extraCards);
      characterRewards.RemoveLockedCards();
    }
    List<CardData> cardDataList = this.force.Clone<CardData>();
    if (cardDataList.Count > 0)
      characterRewards.PullOut("Items", (IEnumerable<DataFile>) cardDataList);
    int itemCount = this.choices - cardDataList.Count;
    cardDataList.AddRange((IEnumerable<CardData>) characterRewards.Pull<CardData>((object) node, "Items", itemCount));
    List<CardData> list = new List<CardData>();
    for (int index = 0; index < this.choices; ++index)
    {
      CardData cardData = index < this.curseCards ? this.cursePool.RandomItem<CardData>() : (CardData) null;
      list.Insert(list.RandomIndex<CardData>(), cardData);
    }
    node.data = new Dictionary<string, object>()
    {
      {
        "cards",
        (object) CampaignNodeTypeCurseItems.ToSaveCollectionOfNames((IEnumerable<UnityEngine.Object>) cardDataList)
      },
      {
        "curses",
        (object) CampaignNodeTypeCurseItems.ToSaveCollectionOfNames((IEnumerable<UnityEngine.Object>) list)
      },
      {
        "analyticsEventSent",
        (object) false
      }
    };
  }

  public override bool HasMissingData(CampaignNode node)
  {
    string[] saveCollection1 = node.data.GetSaveCollection<string>("cards");
    string[] saveCollection2 = node.data.GetSaveCollection<string>("curses");
    return MissingCardSystem.HasMissingData((IEnumerable<string>) saveCollection1) || MissingCardSystem.HasMissingData(((IEnumerable<string>) saveCollection2).Where<string>((Func<string, bool>) (a => a != null)));
  }

  public override IEnumerator Populate(CampaignNode node)
  {
    EventRoutineCurseItems objectOfType = UnityEngine.Object.FindObjectOfType<EventRoutineCurseItems>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }

  public static SaveCollection<string> ToSaveCollectionOfNames(IEnumerable<UnityEngine.Object> list) => new SaveCollection<string>(list.Select<UnityEngine.Object, string>((Func<UnityEngine.Object, string>) (a => !(bool) a ? (string) null : a.name)).ToArray<string>());
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeEvent
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

public abstract class CampaignNodeTypeEvent : CampaignNodeType
{
  [SerializeField]
  public AssetReferenceGameObject routinePrefabRef;

  public override IEnumerator Run(CampaignNode node)
  {
    yield return (object) Transition.To("Event");
    AsyncOperationHandle<GameObject> task = this.routinePrefabRef.InstantiateAsync(EventManager.EventRoutineHolder);
    yield return (object) new WaitUntil((Func<bool>) (() => task.IsDone));
    EventRoutine eventRoutine = task.Result.GetComponent<EventRoutine>();
    task.Result.AddComponent<AddressableReleaser>().Add((AsyncOperationHandle) task);
    Events.InvokeEventStart(node, eventRoutine);
    yield return (object) this.Populate(node);
    Events.InvokeEventPopulated(eventRoutine);
    Transition.End();
    yield return (object) eventRoutine.Run();
    yield return (object) Transition.To("MapNew");
    Transition.End();
    yield return (object) MapNew.CheckCompanionLimit();
  }

  public virtual IEnumerator Populate(CampaignNode node) => (IEnumerator) null;
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeGnomeShop
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeGnomeShop", menuName = "Campaign/Node Type/Gnome Shop")]
public class CampaignNodeTypeGnomeShop : CampaignNodeTypeEvent
{
  [SerializeField]
  public int poolSize = 10;
  [SerializeField]
  public int rerollPrice = 10;
  [SerializeField]
  public int rerollPriceAdd = 5;

  public override IEnumerator SetUp(CampaignNode node)
  {
    CardData[] fromOriginalList = References.Player.GetComponent<CharacterRewards>().GetFromOriginalList<CardData>((object) node, "Items", this.poolSize, false);
    EventRoutineGnomeShop.Data data = new EventRoutineGnomeShop.Data()
    {
      pool = ((IEnumerable<CardData>) fromOriginalList).Select<CardData, string>((Func<CardData, string>) (a => a.name)).ToArray<string>(),
      price = this.rerollPrice,
      priceAdd = this.rerollPriceAdd
    };
    node.data = new Dictionary<string, object>()
    {
      {
        "data",
        (object) data
      }
    };
    yield break;
  }

  public override bool HasMissingData(CampaignNode node) => false;

  public override IEnumerator Populate(CampaignNode node)
  {
    EventRoutineGnomeShop objectOfType = UnityEngine.Object.FindObjectOfType<EventRoutineGnomeShop>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeGold
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeGold", menuName = "Campaign/Node Type/Gold")]
public class CampaignNodeTypeGold : CampaignNodeType
{
  [SerializeField]
  public Vector2Int amountRange = new Vector2Int(40, 80);
  [SerializeField]
  public float pauseAfter = 1.5f;

  public override IEnumerator SetUp(CampaignNode node)
  {
    node.data = new Dictionary<string, object>()
    {
      {
        "amount",
        (object) this.amountRange.Random()
      }
    };
    yield return (object) null;
  }

  public override IEnumerator Run(CampaignNode node)
  {
    Character player = References.Player;
    Vector3 position = Vector3.zero;
    MapNew objectOfType = Object.FindObjectOfType<MapNew>();
    if (objectOfType != null)
    {
      MapNode node1 = objectOfType.FindNode(node);
      if (node1 != null)
        position = node1.transform.position;
    }
    if ((bool) (Object) player && (bool) (Object) player.data?.inventory)
      Events.InvokeDropGold(node.data.Get<int>("amount"), "GoldCave", player, position);
    node.data["amount"] = (object) 0;
    node.SetCleared();
    yield return (object) Sequences.Wait(this.pauseAfter);
    References.Map.Continue();
  }

  public override bool HasMissingData(CampaignNode node) => false;
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeInjuredCompanion
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeInjuredCompanion", menuName = "Campaign/Node Type/Injured Companion")]
public class CampaignNodeTypeInjuredCompanion : CampaignNodeTypeEvent
{
  public override IEnumerator SetUp(CampaignNode node)
  {
    RunHistory mostRecentRun = InjuredCompanionEventSystem.GetMostRecentRun();
    if (mostRecentRun != null)
    {
      List<CardSaveData> eligibleCompanions = InjuredCompanionEventSystem.GetEligibleCompanions(mostRecentRun);
      if (eligibleCompanions.Count > 0)
      {
        CardSaveData cardSaveData = eligibleCompanions.RandomItem<CardSaveData>();
        References.Player.GetComponent<CharacterRewards>().PullOut("Units", (DataFile) AddressableLoader.Get<CardData>("CardData", cardSaveData.name));
        node.data = new Dictionary<string, object>()
        {
          {
            "cardSaveData",
            (object) cardSaveData
          }
        };
      }
    }
    yield return (object) null;
  }

  public override bool HasMissingData(CampaignNode node) => false;

  public override IEnumerator Populate(CampaignNode node)
  {
    EventRoutineInjuredCompanion objectOfType = Object.FindObjectOfType<EventRoutineInjuredCompanion>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeItem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeItem", menuName = "Campaign/Node Type/Item")]
public class CampaignNodeTypeItem : CampaignNodeTypeEvent
{
  [SerializeField]
  public int choices = 3;
  [SerializeField]
  public List<CardData> force;

  public override IEnumerator SetUp(CampaignNode node)
  {
    yield return (object) null;
    CharacterRewards component = References.Player.GetComponent<CharacterRewards>();
    List<CardData> cardDataList = this.force.Clone<CardData>();
    if (cardDataList.Count > 0)
      component.PullOut("Items", (IEnumerable<DataFile>) cardDataList);
    int itemCount = this.choices - cardDataList.Count;
    cardDataList.AddRange((IEnumerable<CardData>) component.Pull<CardData>((object) node, "Items", itemCount));
    node.data = new Dictionary<string, object>()
    {
      {
        "open",
        (object) false
      },
      {
        "cards",
        (object) cardDataList.ToSaveCollectionOfNames<CardData>()
      }
    };
  }

  public override bool HasMissingData(CampaignNode node) => MissingCardSystem.HasMissingData((IEnumerable<string>) node.data.GetSaveCollection<string>("cards"));

  public override IEnumerator Populate(CampaignNode node)
  {
    ItemEventRoutine objectOfType = Object.FindObjectOfType<ItemEventRoutine>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeJournalPage
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeJournalPage", menuName = "Campaign/Node Type/Journal Page")]
public class CampaignNodeTypeJournalPage : CampaignNodeType
{
  [SerializeField]
  public UnlockData unlock;

  public override IEnumerator Run(CampaignNode node)
  {
    List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
    if (!unlockedList.Contains(this.unlock.name))
    {
      unlockedList.Add(this.unlock.name);
      SaveSystem.SaveProgressData<List<string>>("unlocked", unlockedList);
    }
    node.SetCleared();
    PauseMenu pauseMenu = UnityEngine.Object.FindObjectOfType<PauseMenu>(true);
    if (pauseMenu != null)
    {
      pauseMenu.OpenLorePages();
      yield return (object) new WaitUntil((Func<bool>) (() => !pauseMenu.gameObject.activeSelf));
    }
    References.Map.Continue();
  }

  public override bool HasMissingData(CampaignNode node) => false;
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeMuncher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeMuncher", menuName = "Campaign/Node Type/Muncher")]
public class CampaignNodeTypeMuncher : CampaignNodeTypeEvent
{
  [SerializeField]
  public int canEat = 2;

  public override IEnumerator SetUp(CampaignNode node)
  {
    node.data = new Dictionary<string, object>()
    {
      {
        "canEat",
        (object) this.canEat
      },
      {
        "enterCount",
        (object) 0
      },
      {
        "openCount",
        (object) 0
      },
      {
        "thankCount",
        (object) 0
      }
    };
    yield return (object) null;
  }

  public override bool HasMissingData(CampaignNode node) => false;

  public override IEnumerator Populate(CampaignNode node)
  {
    EventRoutineMuncher objectOfType = Object.FindObjectOfType<EventRoutineMuncher>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignNodeTypeShop
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignNodeTypeShop", menuName = "Campaign/Node Type/Shop")]
public class CampaignNodeTypeShop : CampaignNodeTypeEvent
{
  [SerializeField]
  public CampaignNodeTypeShop.Stock stock;
  [Header("Prices")]
  [SerializeField]
  [MinMaxSlider(0.0f, 2f)]
  public Vector2 priceFactorRange = new Vector2(0.8f, 1.2f);
  [SerializeField]
  public int discounts = 1;
  [SerializeField]
  public float discountFactor = 0.5f;
  [SerializeField]
  public int charmPrice = 50;
  [SerializeField]
  public int charmPriceAdd = 20;
  [SerializeField]
  public int crownPrice = 80;
  [SerializeField]
  public int crownPriceAdd = 30;
  [SerializeField]
  public int priceOffset = -5;

  public override IEnumerator SetUp(CampaignNode node)
  {
    yield return (object) null;
    CharacterRewards component = References.Player.GetComponent<CharacterRewards>();
    Dictionary<string, DataFile[]> dictionary = new Dictionary<string, DataFile[]>();
    dictionary["Companions"] = component.Pull<DataFile>((object) node, "Units", this.stock.companionCount);
    Predicate<DataFile> match1 = (Predicate<DataFile>) (a => a is CardData cardData1 && cardData1.cardType.name == "Item" && !cardData1.traits.Exists((Predicate<CardData.TraitStacks>) (b => b.data.name == "Consume")));
    dictionary["Items"] = component.Pull<DataFile>((object) node, "Items", this.stock.itemCount, false, match1);
    Predicate<DataFile> match2 = (Predicate<DataFile>) (a => a is CardData cardData2 && cardData2.cardType.name == "Item" && cardData2.traits.Exists((Predicate<CardData.TraitStacks>) (b => b.data.name == "Consume")));
    dictionary["Consumables"] = component.Pull<DataFile>((object) node, "Items", this.stock.consumableCount, false, match2);
    ShopRoutine.Data data = new ShopRoutine.Data()
    {
      charmPrice = this.charmPrice,
      charmPriceAdd = this.charmPriceAdd,
      crownPrice = this.crownPrice,
      crownPriceAdd = this.crownPriceAdd
    };
    foreach (KeyValuePair<string, DataFile[]> keyValuePair in dictionary)
    {
      string str;
      DataFile[] dataFileArray1;
      keyValuePair.Deconstruct(ref str, ref dataFileArray1);
      string category = str;
      DataFile[] dataFileArray2 = dataFileArray1;
      if (dataFileArray2 != null)
      {
        dataFileArray1 = dataFileArray2;
        for (int index = 0; index < dataFileArray1.Length; ++index)
        {
          if (dataFileArray1[index] is CardData cardData3)
          {
            ShopRoutine.Item obj = new ShopRoutine.Item(category, cardData3, this.priceOffset, this.priceFactorRange.Random());
            data.items.Add(obj);
          }
        }
      }
    }
    foreach (CardUpgradeData cardUpgradeData in component.Pull<CardUpgradeData>((object) node, "Charms", this.stock.charmCount))
      data.charms.Add(cardUpgradeData.name);
    List<ShopRoutine.Item> list = new List<ShopRoutine.Item>();
    foreach (ShopRoutine.Item obj in data.items)
    {
      if (obj.category == "Companions" && this.stock.companionsCanDiscount)
        list.Add(obj);
      else if (obj.category == "Items" && this.stock.itemsCanDiscount)
        list.Add(obj);
      else if (obj.category == "Consumables" && this.stock.consumablesCanDiscount)
        list.Add(obj);
    }
    for (int index1 = 0; index1 < this.discounts; ++index1)
    {
      if (list.Count > 0)
      {
        int index2 = list.RandomIndex<ShopRoutine.Item>();
        list[index2].priceFactor = this.discountFactor;
        list.RemoveAt(index2);
      }
    }
    node.data = new Dictionary<string, object>()
    {
      {
        "shopData",
        (object) data
      }
    };
  }

  public override IEnumerator Populate(CampaignNode node)
  {
    ShopRoutine objectOfType = UnityEngine.Object.FindObjectOfType<ShopRoutine>();
    objectOfType.node = node;
    yield return (object) objectOfType.Populate();
  }

  public override bool HasMissingData(CampaignNode node)
  {
    foreach (ShopRoutine.Item obj in node.data.Get<ShopRoutine.Data>("shopData").items)
    {
      if (MissingCardSystem.IsMissing(obj.cardDataName))
        return true;
    }
    return false;
  }

  [Serializable]
  public struct Stock
  {
    public AnimationCurve companions;
    public bool companionsCanDiscount;
    public AnimationCurve items;
    public bool itemsCanDiscount;
    public AnimationCurve consumables;
    public bool consumablesCanDiscount;
    public AnimationCurve charms;

    public int companionCount => Mathf.RoundToInt(this.companions.Evaluate(UnityEngine.Random.value));

    public int itemCount => Mathf.RoundToInt(this.items.Evaluate(UnityEngine.Random.value));

    public int consumableCount => Mathf.RoundToInt(this.consumables.Evaluate(UnityEngine.Random.value));

    public int charmCount => Mathf.RoundToInt(this.charms.Evaluate(UnityEngine.Random.value));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignPopulator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "CampaignPopulator", menuName = "Campaign/Populator")]
public class CampaignPopulator : ScriptableObject
{
  [SerializeField]
  public bool removeLockedCards = true;
  [SerializeField]
  public CampaignTier[] tiers;
  [SerializeField]
  public int playerStartNodeId;

  public void LoadCharacters(Campaign campaign, CharacterSaveData[] data)
  {
    foreach (CharacterSaveData characterSaveData in data)
    {
      Character character = characterSaveData.Load();
      character.transform.SetParent(campaign.characterContainer);
      campaign.characters.Add(character);
    }
  }

  public IEnumerator Populate(Campaign campaign)
  {
    CampaignPopulator campaignPopulator = this;
    Debug.Log((object) string.Format("[{0}] POPULATING", (object) campaignPopulator));
    StopWatch.Start();
    campaign.characterContainer.DestroyAllChildren();
    Character character = UnityEngine.Object.Instantiate<Character>(References.PlayerData.classData.characterPrefab, campaign.characterContainer);
    character.name = "Player (" + character.title + ")";
    campaign.characters.Add(character);
    campaign.nodes[campaignPopulator.playerStartNodeId].characters.Add(campaign.characters.Count - 1);
    for (int index = 0; index < campaignPopulator.playerStartNodeId; ++index)
    {
      CampaignNode node = campaign.nodes[index];
      if (node.type.interactable)
      {
        node.revealed = true;
        node.SetCleared();
      }
    }
    References.Player = character;
    character.Assign(References.PlayerData);
    CharacterRewards component = character.GetComponent<CharacterRewards>();
    if (component != null)
    {
      component.Populate(character.data.classData);
      if (campaignPopulator.removeLockedCards)
        component.RemoveLockedCards();
      component.RemoveCardsFromStartingDeck();
      if (Campaign.Data.GameMode.mainGameMode)
        component.RemoveCompanionsInFinalBossBattle();
    }
    CharacterDisplay.FindAndAssign(character);
    List<int> intList = new List<int>();
    foreach (char battleTier in campaign.battleTiers)
    {
      int num = int.Parse(battleTier.ToString());
      intList.Add(num);
    }
    List<CampaignPopulator.Tier> currentTiers = new List<CampaignPopulator.Tier>();
    foreach (CampaignNode node in campaign.nodes)
    {
      int tierNumber = intList[node.positionIndex];
      CampaignPopulator.Tier tier = currentTiers.Find((Predicate<CampaignPopulator.Tier>) (a => a.number == tierNumber));
      if (tier == null)
        currentTiers.Add(new CampaignPopulator.Tier(tierNumber, campaignPopulator.tiers[tierNumber])
        {
          nodes = {
            node
          }
        });
      else
        tier.nodes.Add(node);
    }
    foreach (CampaignPopulator.Tier tier in currentTiers)
    {
      foreach (CampaignNode node in tier.nodes)
      {
        if (node.type.isBattle)
        {
          BattleData battleData = tier.PullBattle();
          int battlePoints = tier.GetBattlePoints();
          node.data = new Dictionary<string, object>()
          {
            ["battle"] = (object) battleData.name,
            ["waves"] = (object) battleData.generationScript.Run(battleData, battlePoints)
          };
        }
        else if (node.type.name == "CampaignNodeReward")
          node.SetType(tier.PullReward());
      }
    }
    Dictionary<CampaignNode, CampaignNode> links = CampaignPopulator.LinkNodes(currentTiers);
    Routine.Clump clump = new Routine.Clump();
    foreach (CampaignNode node in campaign.nodes)
    {
      if (!links.ContainsKey(node))
        clump.Add(node.type.SetUp(node));
    }
    yield return (object) clump.WaitForEnd();
    foreach (KeyValuePair<CampaignNode, CampaignNode> keyValuePair in links)
      keyValuePair.Key.CopyData(keyValuePair.Value);
    Debug.Log((object) string.Format("DONE ({0}ms)", (object) StopWatch.Stop()));
    yield return (object) null;
  }

  public static Dictionary<CampaignNode, CampaignNode> LinkNodes(
    List<CampaignPopulator.Tier> currentTiers)
  {
    Dictionary<CampaignNode, CampaignNode> links = new Dictionary<CampaignNode, CampaignNode>();
    foreach (CampaignPopulator.Tier currentTier in currentTiers)
    {
      foreach (CampaignNode node1 in currentTier.nodes)
      {
        CampaignNode node = node1;
        if (node.type.canLink && !links.ContainsKey(node) && !links.ContainsValue(node) && node.pathId >= 0)
        {
          CampaignNode campaignNode1 = currentTier.nodes.Where<CampaignNode>((Func<CampaignNode, bool>) (a => !links.ContainsKey(a) && !links.ContainsValue(a) && a.type.canLink && a.id != node.id && a.pathId != node.pathId && a.pathId >= 0 && a.type.name == node.type.name)).OrderBy<CampaignNode, int>((Func<CampaignNode, int>) (a => a.id)).FirstOrDefault<CampaignNode>();
          if (campaignNode1 != null)
          {
            node.dataLinkedTo = campaignNode1.id;
            CampaignNode campaignNode2 = campaignNode1;
            if (campaignNode2.linkedToThis == null)
              campaignNode2.linkedToThis = new List<int>();
            campaignNode1.linkedToThis.Add(node.id);
            links.Add(node, campaignNode1);
          }
        }
      }
    }
    return links;
  }

  public class Tier
  {
    public int number;
    public List<CampaignNode> nodes = new List<CampaignNode>();
    public List<BattleData> battles = new List<BattleData>();
    public List<CampaignNodeType> rewards = new List<CampaignNodeType>();
    public CampaignTier campaignTier;

    public Tier(int number, CampaignTier campaignTier)
    {
      this.number = number;
      this.campaignTier = campaignTier;
    }

    public BattleData PullBattle()
    {
      if (this.battles.Count <= 0)
        this.battles.AddRange((IEnumerable<BattleData>) this.campaignTier.battlePool);
      BattleData battleData = this.battles.RandomItem<BattleData>();
      this.battles.Remove(battleData);
      return battleData;
    }

    public int GetBattlePoints() => this.campaignTier.pointRange.Random();

    public CampaignNodeType PullReward()
    {
      if (this.rewards.Count <= 0)
        this.rewards.AddRange((IEnumerable<CampaignNodeType>) this.campaignTier.rewardPool);
      CampaignNodeType campaignNodeType = this.rewards.RandomItem<CampaignNodeType>();
      this.rewards.Remove(campaignNodeType);
      return campaignNodeType;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;

[Serializable]
public class CampaignSaveData
{
  public CharacterSaveData[] characters;
  public CampaignNodeSaveData[] nodes;
  public int playerId;
  public string[] modifiers;

  public CampaignSaveData()
  {
  }

  public CampaignSaveData(Campaign campaign)
  {
    this.characters = campaign.characters.SaveArray<Character, CharacterSaveData>();
    this.nodes = campaign.nodes.SaveArray<CampaignNode, CampaignNodeSaveData>();
    this.playerId = Campaign.GetCharacterId(References.Player);
    this.modifiers = Campaign.Data.Modifiers != null ? Campaign.Data.Modifiers.Select<GameModifierData, string>((Func<GameModifierData, string>) (a => a.name)).ToArray<string>() : (string[]) null;
  }

  public List<CampaignNode> LoadNodes()
  {
    List<CampaignNode> campaignNodeList = new List<CampaignNode>();
    foreach (CampaignNodeSaveData node in this.nodes)
      campaignNodeList.Add(node.Load());
    return campaignNodeList;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignStats
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[Serializable]
public class CampaignStats
{
  public float time;
  public int hours;
  public Dictionary<string, Dictionary<string, int>> add;
  public Dictionary<string, Dictionary<string, int>> max;

  public void Add(string stat, int value) => this.Change(stat, value, ref this.add, new Func<int, int, int>(this.Add));

  public void Add(string stat, string key, int value) => this.Change(stat, key, value, ref this.add, new Func<int, int, int>(this.Add));

  public void Max(string stat, int value) => this.Change(stat, value, ref this.max, new Func<int, int, int>(this.Max));

  public void Max(string stat, string key, int value) => this.Change(stat, key, value, ref this.max, new Func<int, int, int>(this.Max));

  public void Change(
    string stat,
    int value,
    ref Dictionary<string, Dictionary<string, int>> values,
    Func<int, int, int> action)
  {
    this.Change(stat, "", value, ref values, action);
  }

  public void Change(
    string stat,
    string key,
    int value,
    ref Dictionary<string, Dictionary<string, int>> values,
    Func<int, int, int> action)
  {
    int oldValue = 0;
    if (values == null)
      values = new Dictionary<string, Dictionary<string, int>>();
    Dictionary<string, int> dictionary1;
    if (!values.ContainsKey(stat))
    {
      dictionary1 = new Dictionary<string, int>();
      values[stat] = dictionary1;
    }
    else
    {
      Dictionary<string, int> dictionary2 = values[stat];
      if (dictionary2 != null)
      {
        dictionary1 = dictionary2;
      }
      else
      {
        dictionary1 = new Dictionary<string, int>();
        values[stat] = dictionary1;
      }
    }
    int newValue;
    if (dictionary1.ContainsKey(key))
    {
      oldValue = dictionary1[key];
      newValue = action(oldValue, value);
    }
    else
      newValue = value;
    dictionary1[key] = newValue;
    if (oldValue == newValue)
      return;
    Events.InvokeStatChanged(stat, key, oldValue, newValue);
  }

  public int Add(int value, int add) => value + add;

  public int Max(int value, int max) => Mathf.Max(value, max);

  public Dictionary<string, int> Get(
    string stat,
    Dictionary<string, Dictionary<string, int>> source)
  {
    if (source != null && source.ContainsKey(stat))
    {
      Dictionary<string, int> dictionary = source[stat];
      if (dictionary != null)
        return dictionary;
    }
    return (Dictionary<string, int>) null;
  }

  public Dictionary<string, int> Get(string stat) => this.Get(stat, this.add);

  public int Get(string stat, int defaultValue)
  {
    Dictionary<string, int> dictionary = this.Get(stat, this.add);
    return dictionary == null || !dictionary.ContainsKey("") ? defaultValue : dictionary[""];
  }

  public int Get(string stat, string key, int defaultValue)
  {
    Dictionary<string, int> dictionary = this.Get(stat, this.add);
    return dictionary == null || !dictionary.ContainsKey(key) ? defaultValue : dictionary[key];
  }

  public int Best(string stat, int defaultValue)
  {
    Dictionary<string, int> dictionary = this.Get(stat, this.max);
    return dictionary == null ? defaultValue : dictionary.Values.Prepend<int>(0).Max();
  }

  public int Best(string stat, string key, int defaultValue)
  {
    Dictionary<string, int> dictionary = this.Get(stat, this.max);
    return dictionary == null || !dictionary.ContainsKey(key) ? defaultValue : dictionary[key];
  }

  public int Count(string stat)
  {
    Dictionary<string, int> dictionary = this.Get(stat, this.add);
    return dictionary == null ? 0 : dictionary.Values.Sum();
  }

  public void Set(string stat, int value) => this.Set(this.add, stat, "", value);

  public void Set(string stat, string key, int value) => this.Set(this.add, stat, key, value);

  public void SetBest(string stat, int value) => this.Set(this.max, stat, "", value);

  public void SetBest(string stat, string key, int value) => this.Set(this.max, stat, key, value);

  public void Set(
    Dictionary<string, Dictionary<string, int>> dict,
    string stat,
    string key,
    int value)
  {
    if (!dict.ContainsKey(stat))
      dict[stat] = new Dictionary<string, int>()
      {
        {
          key,
          value
        }
      };
    else
      dict[stat][key] = value;
  }

  public void Delete(string stat) => this.add.Remove(stat);

  public void DeleteBest(string stat) => this.max.Remove(stat);

  public CampaignStats Clone()
  {
    CampaignStats campaignStats = new CampaignStats()
    {
      time = this.time,
      hours = this.hours
    };
    if (this.add != null)
      campaignStats.add = this.add.ToDictionary<KeyValuePair<string, Dictionary<string, int>>, string, Dictionary<string, int>>((Func<KeyValuePair<string, Dictionary<string, int>>, string>) (a => a.Key), (Func<KeyValuePair<string, Dictionary<string, int>>, Dictionary<string, int>>) (a => a.Value.ToDictionary<KeyValuePair<string, int>, string, int>((Func<KeyValuePair<string, int>, string>) (b => b.Key), (Func<KeyValuePair<string, int>, int>) (b => b.Value))));
    if (this.max != null)
      campaignStats.max = this.max.ToDictionary<KeyValuePair<string, Dictionary<string, int>>, string, Dictionary<string, int>>((Func<KeyValuePair<string, Dictionary<string, int>>, string>) (a => a.Key), (Func<KeyValuePair<string, Dictionary<string, int>>, Dictionary<string, int>>) (a => a.Value.ToDictionary<KeyValuePair<string, int>, string, int>((Func<KeyValuePair<string, int>, string>) (b => b.Key), (Func<KeyValuePair<string, int>, int>) (b => b.Value))));
    return campaignStats;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CampaignTier
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Campaign Tier", menuName = "Campaign/Tier")]
public class CampaignTier : ScriptableObject
{
  public Vector2Int pointRange;
  public BattleData[] battlePool;
  public CampaignNodeType[] rewardPool;
}
﻿// Decompiled with JetBrains decompiler
// Type: CancelCardDragSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CancelCardDragSystem : GameSystem
{
  [SerializeField]
  public string input = "Back";

  public void Update()
  {
    if (InputSystem.Enabled && !InputSystem.reset && !InputSystem.IsButtonPressed("Back"))
      return;
    foreach (CardController cardController in Object.FindObjectsOfType<CardController>())
    {
      if ((bool) (Object) cardController.dragging)
        cardController.DragCancel();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CanvasGroupFader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

[RequireComponent(typeof (CanvasGroup))]
public class CanvasGroupFader : MonoBehaviour
{
  public CanvasGroup _canvasGroup;
  [SerializeField]
  public float fadeOutTime = 0.5f;
  [SerializeField]
  public LeanTweenType fadeOutEase = LeanTweenType.easeInOutQuad;
  [SerializeField]
  public bool removeInteractable = true;
  [SerializeField]
  public bool removeBlocksRaycast = true;
  [SerializeField]
  public bool disableAfter;
  [Header("Fade Out After Delay")]
  [SerializeField]
  public bool fadeOutAfter;
  [SerializeField]
  [ShowIf("fadeOutAfter")]
  public bool afterEnable;
  [SerializeField]
  [ShowIf("fadeOutAfter")]
  public float delay;

  public CanvasGroup canvasGroup => this._canvasGroup ?? (this._canvasGroup = this.GetComponent<CanvasGroup>());

  public void OnEnable()
  {
    if (!this.fadeOutAfter || !this.afterEnable)
      return;
    this.StartCoroutine(this.FadeOutAfter(this.delay));
  }

  public void OnDisable() => this.StopAllCoroutines();

  public IEnumerator FadeOutAfter(float delay)
  {
    yield return (object) new WaitForSeconds(delay);
    this.FadeOut();
  }

  public void FadeOut()
  {
    LeanTween.cancel(this.gameObject);
    LeanTween.alphaCanvas(this.canvasGroup, 0.0f, this.fadeOutTime).setEase(this.fadeOutEase);
    if (this.removeInteractable)
      this.canvasGroup.interactable = false;
    if (this.removeBlocksRaycast)
      this.canvasGroup.blocksRaycasts = false;
    if (!this.disableAfter)
      return;
    this.StartCoroutine(this.DisableAfter(this.fadeOutTime));
  }

  public IEnumerator DisableAfter(float delay)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    CanvasGroupFader canvasGroupFader = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      canvasGroupFader.gameObject.SetActive(false);
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) new WaitForSeconds(delay);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Card
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.UI;

public class Card : EntityDisplay
{
  [SerializeField]
  public Vector2 baseSize = new Vector2(740f, 1100f);
  public int frameLevel;
  [Required(null)]
  public Canvas canvas;
  [Required(null)]
  public CanvasGroup canvasGroup;
  [Required(null)]
  [BoxGroup("Text Elements")]
  public TextMeshProUGUI titleText;
  [Required(null)]
  [BoxGroup("Text Elements")]
  public TextMeshProUGUI descText;
  [Required(null)]
  [BoxGroup("Images")]
  public Image mainImage;
  [Required(null)]
  [BoxGroup("Images")]
  public Image backImage;
  [Required(null)]
  [BoxGroup("Images")]
  public Image backgroundImage;
  [Required(null)]
  [BoxGroup("Images")]
  public Image frameImage;
  [Required(null)]
  [BoxGroup("Images")]
  public CardFrameSetter frameSetter;
  [Required(null)]
  [SerializeField]
  public UINavigationItem uINavigationItem;
  [Required(null)]
  [SerializeField]
  public GameObject frontGroup;
  [Required(null)]
  [SerializeField]
  public GameObject backGroup;
  public UpgradeHolder charmHolder;
  public UpgradeHolder tokenHolder;
  public UpgradeHolder crownHolder;
  public ItemHolderPet itemHolderPet;
  public LargeUIScaleUpdater[] scalers;
  [BoxGroup("Idle Animation")]
  public CardIdleAnimation imageIdleAnimator;
  [BoxGroup("Idle Animation")]
  public CardIdleAnimation backgroundIdleAnimator;
  public int currentEffectBonus;
  public float currentEffectFactor;
  public bool currentSilenced;
  public HashSet<KeywordData> keywords = new HashSet<KeywordData>();
  public HashSet<CardData> mentionedCards;
  public bool hasScriptableImage;
  [SerializeField]
  public ScriptableCardImage scriptableImage;

  public void FlipUp()
  {
    this.backGroup.SetActive(false);
    this.frontGroup.SetActive(true);
  }

  public void FlipDown()
  {
    this.backGroup.SetActive(true);
    this.frontGroup.SetActive(false);
  }

  public override Canvas GetCanvas() => this.canvas;

  public override IEnumerator UpdateData(bool doPing = false)
  {
    Card card = this;
    card.name = card.entity.data.name;
    UnityEngine.Debug.Log((object) ("Updating Data for [" + card.name + "]"));
    card.entity.damage.current = card.entity.data.damage;
    card.entity.damage.max = card.entity.data.damage;
    card.entity.hp.current = card.entity.data.hp;
    card.entity.hp.max = card.entity.data.hp;
    card.entity.counter.current = card.entity.data.counter;
    card.entity.counter.max = card.entity.data.counter;
    card.entity.uses.current = card.entity.data.uses;
    card.entity.uses.max = card.entity.data.uses;
    card.entity.effectBonus = card.entity.data.effectBonus;
    card.entity.effectFactor = card.entity.data.effectFactor;
    card.backgroundImage.sprite = card.entity.data.backgroundSprite;
    Vector2 v = Vector2.one;
    if ((bool) (UnityEngine.Object) card.entity.data.mainSprite)
    {
      card.mainImage.sprite = card.entity.data.mainSprite;
      v = card.mainImage.sprite.rect.size / card.baseSize;
    }
    float num1 = v.Max();
    Transform transform1 = card.mainImage.transform;
    transform1.localScale = (Vector3) new Vector2(num1, num1);
    transform1.localPosition = (Vector3) new Vector2(0.0f, v.y - 1f);
    int num2 = !(bool) (UnityEngine.Object) card.entity.owner || card.entity.owner.team == 1 ? 1 : -1;
    transform1.SetScaleX((float) num2 * transform1.localScale.x);
    card.backgroundImage.transform.SetScaleX((float) num2 * card.backgroundImage.transform.localScale.x);
    if (card.hasScriptableImage)
    {
      foreach (Transform transform2 in transform1.parent)
      {
        if ((UnityEngine.Object) transform2.gameObject != (UnityEngine.Object) card.mainImage.gameObject)
          transform2.gameObject.Destroy();
      }
      if (!(bool) (UnityEngine.Object) card.entity.data.scriptableImagePrefab)
        card.mainImage.gameObject.SetActive(true);
    }
    if ((bool) (UnityEngine.Object) card.entity.data.scriptableImagePrefab)
    {
      card.hasScriptableImage = true;
      card.scriptableImage = UnityEngine.Object.Instantiate<ScriptableCardImage>(card.entity.data.scriptableImagePrefab, card.mainImage.transform.parent);
      card.scriptableImage.Assign(card.entity);
      Transform transform3 = card.scriptableImage.transform;
      transform3.localScale = (Vector3) ((Vector2) transform3.localScale * new Vector2(num1 * (float) num2, num1));
      card.scriptableImage.transform.localPosition += new Vector3(0.0f, v.y - 1f, 0.0f);
      card.mainImage.gameObject.SetActive(false);
    }
    card.SetName(card.entity.data.title);
    card.currentEffectBonus = card.entity.data.effectBonus;
    card.currentEffectFactor = card.entity.data.effectFactor;
    card.currentSilenced = card.entity.silenced;
    if (!card.entity.startingEffectsApplied)
    {
      card.entity.attackEffects = ((IEnumerable<CardData.StatusEffectStacks>) card.entity.data.attackEffects).Select<CardData.StatusEffectStacks, CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, CardData.StatusEffectStacks>) (a => a.Clone())).ToList<CardData.StatusEffectStacks>();
      card.entity.traits.Clear();
      foreach (CardData.TraitStacks trait in card.entity.data.traits)
        card.entity.traits.Add(new Entity.TraitStacks(trait.data, trait.count));
      CardData.StatusEffectStacks[] statusEffectStacksArray = card.entity.data.startWithEffects;
      for (int index = 0; index < statusEffectStacksArray.Length; ++index)
      {
        CardData.StatusEffectStacks statusEffectStacks = statusEffectStacksArray[index];
        yield return (object) StatusEffectSystem.Apply(card.entity, (Entity) null, statusEffectStacks.data, statusEffectStacks.count, applyEvenIfZero: true);
      }
      statusEffectStacksArray = (CardData.StatusEffectStacks[]) null;
      yield return (object) card.entity.UpdateTraits();
      if (card.entity.data.injuries != null)
      {
        foreach (CardData.StatusEffectStacks injury in card.entity.data.injuries)
          yield return (object) StatusEffectSystem.Apply(card.entity, (Entity) null, injury.data, injury.count);
      }
      card.entity.startingEffectsApplied = true;
    }
    card.SetDescription();
    if ((bool) (UnityEngine.Object) card.entity.data.idleAnimationProfile)
    {
      if ((bool) (UnityEngine.Object) card.imageIdleAnimator)
        card.imageIdleAnimator.entity = card.entity;
      if ((bool) (UnityEngine.Object) card.backgroundIdleAnimator)
        card.backgroundIdleAnimator.entity = card.entity;
    }
    card.charmHolder?.Clear();
    card.tokenHolder?.Clear();
    card.crownHolder?.Clear();
    List<CardUpgradeData> upgrades = card.entity.data.upgrades;
    if (upgrades != null && upgrades.Count > 0)
    {
      foreach (CardUpgradeData upgrade in card.entity.data.upgrades)
        upgrade.Display(card.entity);
    }
    yield return (object) card.\u003C\u003En__0(doPing);
  }

  public override IEnumerator UpdateDisplay(bool doPing = true)
  {
    Card card = this;
    yield return (object) card.\u003C\u003En__1(doPing);
    bool flag = card.entity.effectBonus != card.currentEffectBonus || (double) card.entity.effectFactor != (double) card.currentEffectFactor || card.entity.silenced != card.currentSilenced;
    if (flag || card.promptUpdateDescription)
    {
      card.SetDescription();
      card.promptUpdateDescription = false;
      if (flag)
      {
        card.currentEffectBonus = card.entity.effectBonus;
        card.currentEffectFactor = card.entity.effectFactor;
        card.currentSilenced = card.entity.silenced;
        yield return (object) StatusEffectSystem.EffectBonusChangedEvent(card.entity);
      }
    }
    if (card.hasScriptableImage)
      card.scriptableImage.UpdateEvent();
  }

  public void SetName() => this.SetName(this.entity.data.title);

  public void SetName(string name)
  {
    string str = name;
    if (this.entity.data.injuries.Count > 0)
      str = "<color=red>" + str + "</color>";
    this.titleText.text = str;
  }

  public void SetDescription()
  {
    string description = Card.GetDescription(this.entity);
    this.keywords = Text.GetKeywords(description);
    this.mentionedCards = Text.GetMentionedCards(description);
    string text = Text.Process(description, this.entity.effectBonus, this.entity.effectFactor, this.entity.data.cardType.descriptionColours);
    Card.AddInjuryText(ref text, this.entity.data);
    if (text.IsNullOrWhitespace())
    {
      LocalizedString flavourKey = this.entity.data.flavourKey;
      if (flavourKey != null && !flavourKey.IsEmpty)
        text = "<i><color=#" + this.entity.data.cardType.descriptionColours.flavourColour + ">" + this.entity.data.flavourKey.GetLocalizedString();
    }
    if (text.IsNullOrWhitespace())
      this.descText.text = "";
    else
      this.descText.text = "<color=#" + this.entity.data.cardType.descriptionColours.textColour + ">" + text;
  }

  public static string GetDescription(CardData data, bool silenced = false)
  {
    string text = "";
    Card.AddAttackEffectText(ref text, (ICollection<CardData.StatusEffectStacks>) data.attackEffects, silenced);
    Card.AddCustomCardText(ref text, data, silenced);
    Card.AddPassiveEffectText(ref text, (ICollection<CardData.StatusEffectStacks>) data.startWithEffects, silenced);
    Card.AddUpgradeText(ref text, data, silenced);
    Card.AddTraitText(ref text, data, silenced);
    return text;
  }

  public static string GetDescription(Entity entity)
  {
    string text = "";
    Card.AddAttackEffectText(ref text, (ICollection<CardData.StatusEffectStacks>) entity.attackEffects, entity.silenced);
    Card.AddCustomCardText(ref text, entity.data, entity.silenced);
    Card.AddPassiveEffectText(ref text, (ICollection<StatusEffectData>) entity.statusEffects, entity.silenced);
    Card.AddUpgradeText(ref text, entity.data, entity.silenced);
    Card.AddTraitText(ref text, entity);
    return text;
  }

  public static void AddAttackEffectText(
    ref string text,
    ICollection<CardData.StatusEffectStacks> attackEffects,
    bool silenced = false)
  {
    if (attackEffects.Count <= 0)
      return;
    Dictionary<string, string> dictionary = new Dictionary<string, string>();
    foreach (CardData.StatusEffectStacks attackEffect in (IEnumerable<CardData.StatusEffectStacks>) attackEffects)
    {
      string applyFormat = attackEffect.data.GetApplyFormat();
      if (!applyFormat.IsNullOrWhitespace() && !attackEffect.data.keyword.IsNullOrWhitespace())
      {
        if (dictionary.ContainsKey(applyFormat))
          dictionary[applyFormat] += string.Format(", <{0}><keyword={1}>", (object) attackEffect.count, (object) attackEffect.data.keyword);
        else
          dictionary[applyFormat] = string.Format("<{0}><keyword={1}>", (object) attackEffect.count, (object) attackEffect.data.keyword);
      }
      else if (!attackEffect.data.textKey.IsEmpty)
        dictionary.Add(attackEffect.data.GetDesc(attackEffect.count), "");
    }
    foreach (KeyValuePair<string, string> keyValuePair in dictionary)
    {
      if (!text.IsNullOrWhitespace())
        text += "\n";
      string str = keyValuePair.Key.Replace("{0}", keyValuePair.Value);
      text += silenced ? "<s>" + str + "</s>" : str;
    }
  }

  public static void AddCustomCardText(ref string text, CardData data, bool silenced = false)
  {
    if (!data.HasCustomText)
      return;
    if (!text.IsNullOrWhitespace())
      text += "\n";
    text += data.GetCustomText(silenced);
  }

  public static void AddPassiveEffectText(
    ref string text,
    ICollection<CardData.StatusEffectStacks> passiveEffects,
    bool silenced = false)
  {
    if (passiveEffects.Count <= 0)
      return;
    foreach (CardData.StatusEffectStacks passiveEffect in (IEnumerable<CardData.StatusEffectStacks>) passiveEffects)
    {
      if (passiveEffect.data.keyword.IsNullOrWhitespace() && passiveEffect.data.HasDesc)
      {
        if (!text.IsNullOrWhitespace())
          text += "\n";
        text += passiveEffect.data.GetDesc(passiveEffect.count, silenced);
      }
    }
  }

  public static void AddPassiveEffectText(
    ref string text,
    ICollection<StatusEffectData> passiveEffects,
    bool silenced = false)
  {
    if (passiveEffects.Count <= 0)
      return;
    foreach (StatusEffectData statusEffectData in (IEnumerable<StatusEffectData>) passiveEffects.OrderBy<StatusEffectData, int>((Func<StatusEffectData, int>) (a => a.textOrder)))
    {
      if (statusEffectData.keyword.IsNullOrWhitespace() && statusEffectData.HasDesc)
      {
        if (!text.IsNullOrWhitespace())
          text += "\n";
        text += statusEffectData.GetDesc(statusEffectData.count, silenced);
      }
    }
  }

  public static void AddUpgradeText(ref string text, CardData data, bool silenced = false)
  {
  }

  public static void AddTraitText(ref string text, CardData data, bool silenced = false)
  {
    if (data.traits == null || data.traits.Count <= 0)
      return;
    int count = data.traits.Count;
    string traitSeparator = Card.GetTraitSeparator(count);
    string str = "";
    for (int index = 0; index < count; ++index)
    {
      CardData.TraitStacks trait = data.traits[index];
      str += Card.GetTraitText(trait.data, trait.count, silenced);
      if (index < count - 1)
        str += traitSeparator;
    }
    if (str.IsNullOrWhitespace())
      return;
    text = text + "\n" + str;
  }

  public static void AddTraitText(ref string text, Entity entity)
  {
    if (entity.traits == null || entity.traits.Count <= 0)
      return;
    int count = entity.traits.Count;
    string traitSeparator = Card.GetTraitSeparator(count);
    string str = "";
    for (int index = 0; index < count; ++index)
    {
      Entity.TraitStacks trait = entity.traits[index];
      str += Card.GetTraitText(trait.data, trait.count, entity.silenced || trait.silenced);
      if (index < count - 1)
        str += traitSeparator;
    }
    if (str.IsNullOrWhitespace())
      return;
    text = text + "\n" + str;
  }

  public static string GetTraitSeparator(int traitCount) => traitCount <= 2 ? "\n" : ", ";

  public static string GetTraitText(TraitData trait, int count, bool silenced = false)
  {
    string lower = trait.keyword.name.ToLower();
    return !silenced ? string.Format("<keyword={0} {1}>", (object) lower, (object) count) : string.Format("<keyword={0} {1} silenced>", (object) lower, (object) count);
  }

  public static void AddInjuryText(ref string text, CardData data)
  {
    int count = data.injuries.Count;
    if (count <= 0)
      return;
    if (!text.IsNullOrWhitespace())
      text += "\n";
    text = text + "<color=red>" + MonoBehaviourSingleton<StringReference>.instance.injured.GetLocalizedString();
    if (count > 1)
      text += string.Format(" {0}", (object) count);
    text += "</color>";
  }

  public override void OnGetFromPool()
  {
    base.OnGetFromPool();
    this.imageIdleAnimator.OnGetFromPool();
    this.backgroundIdleAnimator.OnGetFromPool();
    foreach (LargeUIScaleUpdater scaler in this.scalers)
      scaler.PromptUpdate();
  }

  public override void OnReturnToPool()
  {
    base.OnReturnToPool();
    this.FlipUp();
    this.imageIdleAnimator.OnReturnToPool();
    this.backgroundIdleAnimator.OnReturnToPool();
    if ((bool) (UnityEngine.Object) this.crownHolder)
      this.crownHolder.Clear();
    if ((bool) (UnityEngine.Object) this.charmHolder)
      this.charmHolder.Clear();
    if ((bool) (UnityEngine.Object) this.tokenHolder)
      this.tokenHolder.Clear();
    this.itemHolderPet.gameObject.SetActive(false);
    this.canvasGroup.alpha = 1f;
    this.currentEffectBonus = 0;
    this.currentEffectFactor = 1f;
    this.currentSilenced = false;
    this.canvas.overrideSorting = false;
    if (!this.hasScriptableImage)
      return;
    foreach (Transform transform in this.mainImage.transform.parent)
    {
      if ((UnityEngine.Object) transform.gameObject != (UnityEngine.Object) this.mainImage.gameObject)
        transform.gameObject.Destroy();
    }
    this.mainImage.gameObject.SetActive(true);
    this.hasScriptableImage = false;
  }

  public void OnDrawGizmos()
  {
    Gizmos.color = Color.magenta;
    ulong num;
    if (!this.entity.data.TryGetCustomData<ulong>("splitOriginalId", out num, 0UL))
      return;
    foreach (Entity card in References.Battle.cards)
    {
      if ((long) card.data.id == (long) num)
      {
        Vector3 position = this.transform.position;
        Gizmos.DrawLine(position, card.transform.position);
        Gizmos.DrawCube(position, Vector3.one * 0.5f);
      }
    }
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public IEnumerator \u003C\u003En__0(bool doPing) => base.UpdateData(doPing);

  [CompilerGenerated]
  [DebuggerHidden]
  public IEnumerator \u003C\u003En__1(bool doPing) => base.UpdateDisplay(doPing);

  public enum PlayType
  {
    None,
    Play,
    Place,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimation
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public abstract class CardAnimation : ScriptableObject
{
  public virtual IEnumerator Routine(object data, float startDelay = 0.0f) => (IEnumerator) null;
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimationBombardRocket
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "BombardRocket", menuName = "Card Animation/Bombard Rocket")]
public class CardAnimationBombardRocket : CardAnimation
{
  [Header("Rocket")]
  [SerializeField]
  public BombardRocket rocketPrefab;
  [SerializeField]
  public float rocketDuration = 0.67f;
  [SerializeField]
  public Vector3 startPosOffset = new Vector3(0.0f, 10f, 0.0f);
  [SerializeField]
  public Vector3 endPosOffset = new Vector3(0.0f, 0.1f, 0.0f);
  [SerializeField]
  public AnimationCurve rocketMoveCurve;

  public override IEnumerator Routine(object data, float startDelay = 0.0f)
  {
    if (data is Vector3 vector3)
    {
      Vector3 to = vector3 + this.endPosOffset;
      BombardRocket rocket = Object.Instantiate<BombardRocket>(this.rocketPrefab, vector3 + this.startPosOffset, Quaternion.identity);
      LeanTween.move(rocket.gameObject, to, this.rocketDuration).setEase(this.rocketMoveCurve);
      Events.InvokeBombardRocketFall(rocket);
      yield return (object) new WaitForSeconds(this.rocketDuration);
      Events.InvokeBombardRocketExplode(rocket);
      rocket.Explode();
      rocket = (BombardRocket) null;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimationBombardRocketShoot
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "BombardRocketShoot", menuName = "Card Animation/Bombard Rocket Shoot")]
public class CardAnimationBombardRocketShoot : CardAnimation
{
  [Header("Shoot Particles")]
  [SerializeField]
  public ParticleSystem shootFxPrefab;
  [SerializeField]
  public Vector3 shootAngle = new Vector3(0.0f, 0.0f, 135f);
  [SerializeField]
  public Vector3 shootFxOffset = new Vector3(0.0f, 1f, 0.0f);
  [SerializeField]
  public float shootScreenShake = 1f;
  [Header("Recoil Animation")]
  [SerializeField]
  public Vector3 recoilOffset = new Vector3(1f, -1f, 0.0f);
  [SerializeField]
  public AnimationCurve recoilCurve;
  [SerializeField]
  public float recoilDuration = 1f;

  public override IEnumerator Routine(object data, float startDelay = 0.0f)
  {
    if (data is Entity entity)
    {
      ParticleSystem shootFx = UnityEngine.Object.Instantiate<ParticleSystem>(this.shootFxPrefab, entity.transform.position + this.shootFxOffset, Quaternion.Euler(this.shootAngle));
      Events.InvokeScreenShake(this.shootScreenShake, new float?(this.shootAngle.z + 180f));
      Events.InvokeBombardShoot(entity);
      CurveAnimator curveAnimator = entity.curveAnimator;
      if (curveAnimator != null)
      {
        double num = (double) curveAnimator.Move(this.recoilOffset, this.recoilCurve, duration: 1f);
      }
      yield return (object) new WaitUntil((Func<bool>) (() => !(bool) (UnityEngine.Object) shootFx));
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimationClunkerBossChange
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "ClunkerBossPhaseChange", menuName = "Card Animation/Clunker Boss Change")]
public class CardAnimationClunkerBossChange : CardAnimation
{
  [SerializeField]
  public Vector2Int explosionCountRange = new Vector2Int(3, 5);
  [SerializeField]
  public Vector2 explosionDelayRange = new Vector2(0.1f, 0.6f);
  [SerializeField]
  public ParticleSystem explosionStart;
  [SerializeField]
  public ParticleSystem explosion;
  [SerializeField]
  public ParticleSystem explosionEnd;
  [SerializeField]
  public float explosionPositionRandom = 1f;
  [SerializeField]
  public float duration = 1f;
  [SerializeField]
  public float rumbleAmount = 0.5f;
  [SerializeField]
  public float rumbleDurationIn = 0.5f;
  [SerializeField]
  public float rumbleDurationOut = 0.25f;

  public override IEnumerator Routine(object data, float startDelay = 0.0f)
  {
    if (data is Entity target)
    {
      SfxSystem.OneShot("event:/sfx/specific/boss_phase_change");
      float seconds = Mathf.Max(startDelay, this.duration);
      if ((double) this.rumbleAmount > 0.0)
        Events.InvokeScreenRumble(0.0f, this.rumbleAmount, 0.0f, this.rumbleDurationIn, Mathf.Max(0.0f, this.duration - this.rumbleDurationIn), this.rumbleDurationOut);
      if ((bool) (Object) this.explosionStart)
        this.Explode(this.explosionStart, target.transform.position + this.RandomOffset());
      int num1 = this.explosionCountRange.Random();
      global::Routine.Clump clump = new global::Routine.Clump();
      for (int index = 0; index < num1; ++index)
      {
        Vector3 position = target.transform.position + this.RandomOffset();
        clump.Add(this.ExplodeAfterDelay(seconds * this.explosionDelayRange.PettyRandom(), position));
      }
      clump.Add(Sequences.Wait(seconds));
      yield return (object) clump.WaitForEnd();
      this.Explode(this.explosionEnd, target.transform.position, 2f);
      CurveAnimator curveAnimator = target.curveAnimator;
      if (curveAnimator != null)
      {
        double num2 = (double) curveAnimator.Ping();
      }
    }
  }

  public Vector3 RandomOffset() => new Vector3(PettyRandom.Range(-1f, 1f), PettyRandom.Range(-1f, 1f), 0.0f).normalized * PettyRandom.Range(0.0f, this.explosionPositionRandom);

  public IEnumerator ExplodeAfterDelay(float delay, Vector3 position)
  {
    yield return (object) new WaitForSeconds(delay);
    this.Explode(this.explosion, position);
  }

  public void Explode(ParticleSystem prefab, Vector3 position, float screenShake = 1f)
  {
    Object.Instantiate<ParticleSystem>(prefab, position, Quaternion.identity);
    Events.InvokeScreenShake(screenShake);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimationFlyToBackpack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "FlyToBackpack", menuName = "Card Animation/Fly To Backpack")]
public class CardAnimationFlyToBackpack : CardAnimation
{
  [SerializeField]
  public AnimationCurve xCurve;
  [SerializeField]
  public AnimationCurve yCurve;
  [SerializeField]
  public AnimationCurve zCurve;
  [SerializeField]
  public AnimationCurve spinCurve;
  [SerializeField]
  public AnimationCurve scaleCurve;
  [SerializeField]
  public bool destroyOnEnd = true;
  [Header("Duration")]
  [SerializeField]
  public bool fixedDuration;
  [SerializeField]
  [ShowIf("fixedDuration")]
  public float duration = 0.5f;
  [SerializeField]
  [HideIf("fixedDuration")]
  public AnimationCurve durationToDistance;
  [Header("Glows")]
  [SerializeField]
  public AnimationCurve glowMain;
  [SerializeField]
  public Vector2 glowMainSize = new Vector2(4f, 6f);
  [SerializeField]
  public AnimationCurve glowExtra;
  [SerializeField]
  public int glowExtraCount = 4;
  [SerializeField]
  public Rect glowExtraArea = new Rect(-0.7f, -1.3f, 1.4f, 2.6f);
  [SerializeField]
  public Vector2 glowExtraSizeRange = new Vector2(2f, 3f);
  [SerializeField]
  public Vector2 glowExtraDelay = new Vector2(0.0f, 0.5f);
  [SerializeField]
  public Glow glowPrefab;
  [Header("Jump")]
  [SerializeField]
  public AnimationCurve yUpCurve;
  [SerializeField]
  public float yUpAmount = 0.25f;

  public override IEnumerator Routine(object data, float startDelay = 0.0f)
  {
    if (data is Entity entity)
    {
      Transform target = entity.transform;
      if (target != null)
      {
        yield return (object) new WaitForSeconds(startDelay);
        Deckpack deckpack = MonoBehaviourSingleton<Deckpack>.instance;
        if (deckpack != null)
        {
          target.SetParent(deckpack.transform, true);
          AngleWobbler[] wobblers = target.GetComponentsInChildren<AngleWobbler>();
          foreach (AngleWobbler angleWobbler in wobblers)
            angleWobbler.globalSpace = false;
          Vector3 start = target.localPosition;
          Vector3 offset = Vector3.zero - start;
          float t = 0.0f;
          float z = target.localEulerAngles.z;
          Vector3 scale = target.localScale;
          float dur = this.fixedDuration ? this.duration : this.durationToDistance.Evaluate(offset.WithZ(0.0f).magnitude);
          Object.Instantiate<Glow>(this.glowPrefab, target).SetColor(Color.white).SetPosition(Vector2.zero).SetSize(this.glowMainSize).Fade(this.glowMain, dur);
          for (int index = 0; index < this.glowExtraCount; ++index)
          {
            float delay = this.glowExtraDelay.PettyRandom();
            float duration = dur - delay;
            Object.Instantiate<Glow>(this.glowPrefab, target).RandomColor().SetPosition(this.glowExtraArea.RandomPosition()).SetSize(Vector2.one * this.glowExtraSizeRange.PettyRandom()).Fade(this.glowExtra, duration, delay);
          }
          yield return (object) null;
          while ((double) t < 1.0 && (bool) (Object) target)
          {
            t += Time.deltaTime / dur;
            target.localPosition = start + offset.Multiply(this.xCurve.Evaluate(t), this.yCurve.Evaluate(t), this.zCurve.Evaluate(t)) + Vector3.up * this.yUpCurve.Evaluate(t) * this.yUpAmount;
            target.localEulerAngles = target.localEulerAngles.WithZ(z + this.spinCurve.Evaluate(t));
            target.localScale = scale * this.scaleCurve.Evaluate(t);
            yield return (object) null;
          }
          if (this.destroyOnEnd && (bool) (Object) target)
          {
            entity.RemoveFromContainers();
            CardManager.ReturnToPool(entity);
            foreach (AngleWobbler angleWobbler in wobblers)
            {
              if ((bool) (Object) angleWobbler)
                angleWobbler.globalSpace = true;
            }
          }
          if ((bool) (Object) deckpack)
            deckpack.Ping();
          wobblers = (AngleWobbler[]) null;
          start = new Vector3();
          offset = new Vector3();
          scale = new Vector3();
        }
        deckpack = (Deckpack) null;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimationMinibossIntro
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Miniboss Intro", menuName = "Card Animation/Miniboss Intro")]
public class CardAnimationMinibossIntro : CardAnimation
{
  [SerializeField]
  public float rumbleAmount = 1f;
  [SerializeField]
  public float wobbleAmount = 1f;
  [SerializeField]
  public CurveProfile scaleTween;
  [SerializeField]
  public Vector3 scaleTo = new Vector3(1f, 1f, 1f);
  [SerializeField]
  public CurveProfile rotateTween;
  [SerializeField]
  public Vector3 rotateAmount = new Vector3(1f, 1f, 5f);

  public override IEnumerator Routine(object data, float startDelay = 0.0f)
  {
    if (data is Entity target)
    {
      yield return (object) new WaitForSeconds(startDelay);
      float seconds = Mathf.Max(this.scaleTween.duration, this.rotateTween.duration);
      Events.InvokeScreenRumble(0.0f, this.rumbleAmount, 0.0f, seconds * 0.5f, seconds * 0.5f, seconds * 0.5f);
      target.wobbler?.WobbleRandom(this.wobbleAmount);
      LeanTween.scale(target.gameObject, this.scaleTo, this.scaleTween.duration).setEase(this.scaleTween.curve);
      LeanTween.rotateLocal(target.gameObject, this.rotateAmount, this.rotateTween.duration).setEase(this.rotateTween.curve);
      yield return (object) new WaitForSeconds(seconds);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimationOverburn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Overburn", menuName = "Card Animation/Overburn")]
public class CardAnimationOverburn : CardAnimation
{
  public override IEnumerator Routine(object data, float startDelay = 0.0f)
  {
    if (data is Entity target)
    {
      yield return (object) new WaitForSeconds(startDelay);
      CurveAnimator curveAnimator = target.curveAnimator;
      if (curveAnimator != null)
      {
        double num = (double) curveAnimator.Scale(Vector3.one * 0.85f, Curves.Get("Buildup"), 0.67f);
        yield return (object) new WaitForSeconds(0.67f);
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimationPing
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Ping", menuName = "Card Animation/Ping")]
public class CardAnimationPing : CardAnimation
{
  [SerializeField]
  public bool waitForEnd;

  public override IEnumerator Routine(object data, float startDelay = 0.0f)
  {
    if (data is Entity target)
    {
      yield return (object) new WaitForSeconds(startDelay);
      CurveAnimator curveAnimator = target.curveAnimator;
      if (curveAnimator != null)
      {
        double num = (double) curveAnimator.Ping();
        if (this.waitForEnd)
          yield return (object) new WaitForSeconds(curveAnimator.pingDuration);
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimationProfile
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

[CreateAssetMenu(fileName = "CardAnimationProfile", menuName = "Card Animation Profile")]
public class CardAnimationProfile : ScriptableObject
{
  public float speedFactor;
  [Header("Movement")]
  public bool doMoveX;
  [ShowIf("doMoveX")]
  public AnimationCurve moveX;
  public bool doMoveY;
  [ShowIf("doMoveY")]
  public AnimationCurve moveY;
  public bool doMoveZ;
  [ShowIf("doMoveZ")]
  public AnimationCurve moveZ;
  public Vector3 moveAmount;
  [Header("Rotation")]
  public bool doRotateX;
  [ShowIf("doRotateX")]
  public AnimationCurve rotateX;
  public bool doRotateY;
  [ShowIf("doRotateY")]
  public AnimationCurve rotateY;
  public bool doRotateZ;
  [ShowIf("doRotateZ")]
  public AnimationCurve rotateZ;
  public Vector3 rotateAmount;
  [Header("Scale")]
  public bool doScaleX;
  [ShowIf("doScaleX")]
  public AnimationCurve ScaleX;
  public bool doScaleY;
  [ShowIf("doScaleY")]
  public AnimationCurve ScaleY;
  public bool doScaleZ;
  [ShowIf("doScaleZ")]
  public AnimationCurve ScaleZ;
  public Vector3 scaleAmount;
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimationPunch
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Punch", menuName = "Card Animation/Punch")]
public class CardAnimationPunch : CardAnimation
{
  [SerializeField]
  public AnimationCurve curve;
  [SerializeField]
  public float duration = 1f;
  [SerializeField]
  public float animationDistance = 2.5f;
  [SerializeField]
  public float hitPos = 0.22f;

  public override IEnumerator Routine(object data, float startDelay = 0.0f)
  {
    if (data is Trigger trigger)
    {
      yield return (object) new WaitForSeconds(startDelay);
      Vector3 zero = Vector3.zero;
      foreach (Hit hit in trigger.hits)
        zero += hit.target.transform.position;
      if (trigger.hits.Length != 0)
        zero /= (float) trigger.hits.Length;
      Vector3 offset = ((zero - trigger.entity.transform.position).normalized * this.animationDistance) with
      {
        z = -1f
      };
      double num = (double) trigger.entity.curveAnimator.Move(offset, this.curve, this.duration);
      yield return (object) Sequences.Wait(this.duration * this.hitPos);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardAnimationSupportive
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Supportive", menuName = "Card Animation/Supportive")]
public class CardAnimationSupportive : CardAnimation
{
  [SerializeField]
  public float hitPos = 0.2f;

  public override IEnumerator Routine(object data, float startDelay = 0.0f)
  {
    if (data is Trigger trigger)
    {
      yield return (object) new WaitForSeconds(startDelay);
      yield return (object) Sequences.Wait(trigger.entity.curveAnimator.Ping() * this.hitPos);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardCharm
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

public class CardCharm : UpgradeDisplay
{
  public Transform holder;
  public Vector3 movementInfluence = new Vector3(-1f, 0.5f, 0.0f);
  public float rotationMax = 90f;
  public Vector2 wobbleFactorRange = (Vector2) new Vector3(4.5f, 5.5f);
  public Vector2 wobbleDampingRange = new Vector2(0.9f, 0.95f);
  public Vector2 wobbleAccRange = new Vector2(0.65f, 0.75f);
  [SerializeField]
  [ReadOnly]
  public float wobbleFactor;
  [SerializeField]
  [ReadOnly]
  public float wobbleDamping;
  [SerializeField]
  [ReadOnly]
  public float wobbleAcc;
  public Vector3 prePosition;
  public float rotation;
  public float rotationVelocity;
  public float startingZAngle;

  public void Start()
  {
    this.wobbleFactor = this.wobbleFactorRange.PettyRandom();
    this.wobbleDamping = this.wobbleDampingRange.PettyRandom();
    this.wobbleAcc = this.wobbleAccRange.PettyRandom();
  }

  public void OnEnable()
  {
    if (!((Object) this.holder != (Object) null))
      return;
    this.prePosition = this.holder.position;
  }

  public void Update()
  {
    this.rotationVelocity -= this.rotation * this.wobbleAcc * Time.deltaTime;
    this.rotationVelocity = Delta.Multiply(this.rotationVelocity, this.wobbleDamping, Time.deltaTime);
    this.rotation += this.rotationVelocity * 200f * Time.deltaTime;
    this.transform.eulerAngles = new Vector3(0.0f, 0.0f, this.startingZAngle + this.rotation);
    Vector3 position = this.holder.position;
    this.Wobble(position - this.prePosition);
    this.prePosition = position;
  }

  public void Wobble(Vector3 movement) => this.rotation = Mathf.Clamp(this.rotation + Vector3.Scale(movement, this.movementInfluence).magnitude * this.wobbleFactor, -this.rotationMax, this.rotationMax);

  public void SetAngle(float angle) => this.startingZAngle = angle;

  public void StopWobble()
  {
    this.rotationVelocity = 0.0f;
    this.rotation = 0.0f;
    this.transform.eulerAngles = new Vector3(0.0f, 0.0f, this.startingZAngle);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardCharmDragHandler
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using FMODUnity;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

public class CardCharmDragHandler : MonoBehaviour
{
  [SerializeField]
  public bool canDragMidBattle = true;
  [SerializeField]
  public EventReference denySfxEvent;
  [SerializeField]
  public CardContainer[] assignmentContainers;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public UpgradeHolder dragHolder;
  [SerializeField]
  public UnityEvent onAssign;
  [SerializeField]
  public AssignCharmSequence assignSequence;
  [SerializeField]
  public bool instantAssign = true;
  public UpgradeDisplay dragging;
  public UpgradeHolder preHolder;
  public int preIndex;
  [CompilerGenerated]
  public bool \u003CIsDragging\u003Ek__BackingField;
  public Entity hoverEntity;
  public List<Entity> eligibleCards;
  public List<Entity> ineligibleCards;
  public readonly Routine.Clump flipClump = new Routine.Clump();

  public bool IsDragging
  {
    get => this.\u003CIsDragging\u003Ek__BackingField;
    set => this.\u003CIsDragging\u003Ek__BackingField = value;
  }

  public void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
    this.StopAllCoroutines();
  }

  public void LateUpdate()
  {
    if (!this.IsDragging)
      return;
    this.UpdatePosition();
    if (!InputSystem.IsButtonPressed("Back"))
      return;
    this.CancelDrag();
  }

  public void UpdatePosition()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
    {
      this.transform.position = Cursor3d.Position;
    }
    else
    {
      UINavigationItem currentNavigationItem = MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem;
      if (currentNavigationItem == null)
        return;
      this.transform.position = currentNavigationItem.Position.WithZ(Cursor3d.Position.z);
    }
  }

  public void Drag(UpgradeDisplay upgrade)
  {
    if (!this.canDragMidBattle && (bool) (Object) References.Battle && !References.Battle.ended)
    {
      SfxSystem.OneShot(this.denySfxEvent);
    }
    else
    {
      TouchInputModule.BlockScroll();
      this.preHolder = upgrade.GetComponentInParent<UpgradeHolder>();
      if ((bool) (Object) this.preHolder)
      {
        this.preIndex = this.preHolder.IndexOf(upgrade);
        this.preHolder.Remove(upgrade);
        this.preHolder.SetPositions();
      }
      this.dragHolder.Add(upgrade);
      this.dragHolder.SetPositions();
      this.UpdatePosition();
      global::Events.InvokeUpgradePickup(upgrade);
      this.dragging = upgrade;
      this.IsDragging = true;
      if (this.eligibleCards == null)
        this.eligibleCards = new List<Entity>();
      if (this.ineligibleCards == null)
        this.ineligibleCards = new List<Entity>();
      foreach (CardContainer assignmentContainer in this.assignmentContainers)
      {
        foreach (Entity card in assignmentContainer)
        {
          if (this.dragging.data.CanAssign(card))
          {
            this.eligibleCards.Add(card);
            card.flipper.FlipUp();
          }
          else
          {
            this.ineligibleCards.Add(card);
            card.flipper.flipped = true;
          }
        }
      }
      this.StopAllCoroutines();
      this.StartCoroutine(this.FlipCardsDown((IEnumerable<Entity>) this.ineligibleCards));
      NavigationState.Start((INavigationState) new NavigationStateAssignUpgrade(this.eligibleCards));
      this.cardController.canPress = false;
    }
  }

  public void Release(UpgradeDisplay upgrade)
  {
    if ((Object) this.dragging != (Object) upgrade)
      return;
    if ((bool) (Object) this.hoverEntity && this.eligibleCards != null && this.eligibleCards.Contains(this.hoverEntity))
    {
      this.dragHolder.Remove(this.dragging);
      Routine routine = new Routine(this.Assign(this.dragging, this.hoverEntity));
    }
    else
    {
      if ((bool) (Object) this.preHolder)
        this.ReturnToHolder();
      this.DragEnd();
    }
  }

  public void DragEnd()
  {
    TouchInputModule.UnblockScroll();
    this.dragging = (UpgradeDisplay) null;
    this.IsDragging = false;
    this.StopAllCoroutines();
    this.StartCoroutine(this.FlipCardsUp((IEnumerable<Entity>) this.ineligibleCards.ToArray()));
    this.eligibleCards = (List<Entity>) null;
    this.ineligibleCards = (List<Entity>) null;
    NavigationState.BackToPreviousState();
    this.cardController.canPress = true;
  }

  public void ReturnToHolder()
  {
    this.dragHolder.Remove(this.dragging);
    this.preHolder.Insert(this.preIndex >= 0 ? this.preIndex : 0, this.dragging);
    this.dragging.transform.localPosition = Vector3.zero;
    this.preHolder.SetPositions();
    global::Events.InvokeUpgradeDrop(this.dragging);
  }

  public void CancelDrag()
  {
    if (!this.IsDragging)
      return;
    CardCharmInteraction component = this.dragging.GetComponent<CardCharmInteraction>();
    if (component == null)
      return;
    component.CancelDrag();
    this.ReturnToHolder();
    this.DragEnd();
  }

  public IEnumerator FlipCardsDown(IEnumerable<Entity> cards)
  {
    this.flipClump.Clear();
    foreach (Entity card in cards)
      this.flipClump.Add(CardCharmDragHandler.FlipDown(card, PettyRandom.Range(0.0f, 0.2f)));
    yield return (object) this.flipClump.WaitForEnd();
  }

  public static IEnumerator FlipDown(Entity card, float delay)
  {
    yield return (object) new WaitForSeconds(delay);
    card.flipper.FlipDown(true);
  }

  public IEnumerator FlipCardsUp(IEnumerable<Entity> cards)
  {
    this.flipClump.Clear();
    foreach (Entity card in cards)
      this.flipClump.Add(CardCharmDragHandler.FlipUp(card, PettyRandom.Range(0.0f, 0.2f)));
    yield return (object) this.flipClump.WaitForEnd();
  }

  public static IEnumerator FlipUp(Entity card, float delay)
  {
    yield return (object) new WaitForSeconds(delay);
    card.flipper.FlipUp();
  }

  public IEnumerator Assign(UpgradeDisplay upgrade, Entity entity)
  {
    this.cardController.Disable();
    NavigationState.Start((INavigationState) new NavigationStateWait(true));
    CardUpgradeData upgradeData = upgrade.data;
    upgrade.gameObject.Destroy();
    if (this.instantAssign || upgradeData.type != CardUpgradeData.Type.Charm)
    {
      yield return (object) upgradeData.Assign(entity);
    }
    else
    {
      this.assignSequence.Assign(entity, upgradeData);
      yield return (object) this.assignSequence.Run();
    }
    this.cardController.Enable();
    NavigationState.BackToPreviousState();
    this.DragEnd();
    if ((bool) (Object) this.cardController.owner)
      this.cardController.owner.data.inventory.upgrades.Remove(upgradeData);
    this.onAssign?.Invoke();
  }

  public void EntityHover(Entity entity)
  {
    if (this.eligibleCards == null || !this.eligibleCards.Contains(entity))
      return;
    this.hoverEntity = entity;
  }

  public void EntityUnHover(Entity entity)
  {
    if (!((Object) this.hoverEntity == (Object) entity))
      return;
    this.hoverEntity = (Entity) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardCharmHolder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class CardCharmHolder : UpgradeHolder
{
  [SerializeField]
  public float angleAdd = 20f;
  [SerializeField]
  public Vector2 charmPivot = new Vector2(0.5f, 0.9f);
  [SerializeField]
  public Image ropeImage;

  public override void SetPositions()
  {
    int count = this.list.Count;
    float num = (float) -((double) (count - 1) * 0.5) * this.angleAdd;
    for (int index = 0; index < count; ++index)
    {
      if (this.list[index] is CardCharm cardCharm)
      {
        cardCharm.SetAngle(num + (float) index * this.angleAdd);
        cardCharm.transform.SetSiblingIndex(CardCharmHolder.CalculateSiblingIndex(index, count));
      }
    }
    this.ropeImage?.gameObject.SetActive(count > 0);
  }

  public static int CalculateSiblingIndex(int listIndex, int listLength)
  {
    float num1 = (float) (listLength - 1) * 0.5f;
    float f = (float) listIndex - num1;
    float num2 = Mathf.Sign(f);
    return Mathf.FloorToInt(num1 + f * -num2) * 2 + Mathf.Clamp((int) f, 0, 1);
  }

  public override void Add(UpgradeDisplay upgrade)
  {
    base.Add(upgrade);
    this.CharmAdded(upgrade);
  }

  public override void Insert(int index, UpgradeDisplay upgrade)
  {
    base.Insert(index, upgrade);
    this.CharmAdded(upgrade);
  }

  public void CharmAdded(UpgradeDisplay upgrade)
  {
    if (!(upgrade is CardCharm cardCharm))
      return;
    cardCharm.holder = this.transform;
    ((RectTransform) cardCharm.transform).pivot = this.charmPivot;
  }

  public override void Clear()
  {
    base.Clear();
    this.ropeImage?.gameObject.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardCharmInteraction
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

[RequireComponent(typeof (UpgradeDisplay))]
public class CardCharmInteraction : 
  MonoBehaviourRect,
  IPointerEnterHandler,
  IEventSystemHandler,
  IPointerExitHandler
{
  [SerializeField]
  public GameObject image;
  public CardCharmDragHandler dragHandler;
  public bool canHover;
  public bool canDrag;
  public bool hover;
  public bool preHover;
  public bool press;
  public bool drag;
  public Vector2 popUpOffset = new Vector2(0.0f, -1f);
  public UnityEvent<UpgradeDisplay> onHover;
  public UnityEvent<UpgradeDisplay> onUnHover;
  public UnityEvent<UpgradeDisplay> onDrag;
  public UnityEvent<UpgradeDisplay> onDragEnd;
  public UpgradeDisplay _upgradeDisplay;

  public UpgradeDisplay upgradeDisplay => this._upgradeDisplay ?? (this._upgradeDisplay = this.GetComponent<UpgradeDisplay>());

  public bool DragHandlerDragging => (bool) (Object) this.dragHandler && this.dragHandler.IsDragging;

  public void LateUpdate()
  {
    if (!this.press)
    {
      if (this.hover && InputSystem.IsSelectPressed())
      {
        this.press = true;
        if (this.preHover)
          this.Press();
      }
    }
    else if ((MonoBehaviourSingleton<Cursor3d>.instance.usingTouch ? (InputSystem.IsSelectReleased() ? 1 : 0) : (InputSystem.IsDynamicSelectReleased(this.drag) ? 1 : 0)) != 0)
    {
      this.Release();
      this.press = false;
      if (MonoBehaviourSingleton<Cursor3d>.instance.usingTouch)
        this.StartCoroutine(this.UpdateInputSystem());
    }
    this.preHover = this.hover;
  }

  public IEnumerator UpdateInputSystem()
  {
    yield return (object) null;
    if (this.upgradeDisplay is CardCharm upgradeDisplay)
      upgradeDisplay.StopWobble();
    yield return (object) null;
    global::Events.InvokeUpdateInputSystem(true);
  }

  public void OnPointerEnter(PointerEventData eventData) => this.Hover();

  public void OnPointerExit(PointerEventData eventData)
  {
    if (this.hover && this.press && !this.drag && MonoBehaviourSingleton<Cursor3d>.instance.usingTouch && (bool) (Object) this.dragHandler)
      this.StartDrag();
    else
      this.UnHover();
  }

  public void Press()
  {
    if (!this.canDrag || !this.hover)
      return;
    this.StartDrag();
  }

  public void Release()
  {
    if (!this.drag)
      return;
    this.StopDrag();
  }

  public void Hover()
  {
    if (!this.canHover || this.drag || this.DragHandlerDragging)
      return;
    if (!this.hover)
    {
      LeanTween.cancel(this.image);
      LeanTween.scale(this.image, Vector3.one * 1.1f, 0.33f).setEase(LeanTweenType.easeOutBack);
    }
    this.hover = true;
    this.onHover?.Invoke(this.upgradeDisplay);
    global::Events.InvokeUpgradeHover(this.upgradeDisplay);
    this.PopUpDescription();
  }

  public void UnHover()
  {
    if (!this.canHover || !this.hover)
      return;
    LeanTween.cancel(this.image);
    LeanTween.scale(this.image, Vector3.one, 0.2f).setEase(LeanTweenType.easeOutQuart);
    this.hover = false;
    this.onUnHover?.Invoke(this.upgradeDisplay);
    this.HideDescription();
  }

  public void StartDrag()
  {
    Debug.Log((object) ("Dragging Card Charm [" + this.name + "]"));
    this.drag = true;
    this.onDrag?.Invoke(this.upgradeDisplay);
    this.UnHover();
    this.upgradeDisplay.CanRaycast = false;
  }

  public void StopDrag()
  {
    Debug.Log((object) ("Dropping Card Charm [" + this.name + "]"));
    this.onDragEnd?.Invoke(this.upgradeDisplay);
    this.drag = false;
    this.upgradeDisplay.CanRaycast = true;
  }

  public void CancelDrag()
  {
    Debug.Log((object) ("Cancelling Card Charm Drag [" + this.name + "]"));
    this.drag = false;
    this.upgradeDisplay.CanRaycast = true;
  }

  public void PopUpDescription()
  {
    CardPopUp.AssignTo(this.rectTransform, this.popUpOffset.x, this.popUpOffset.y);
    CardPopUp.AddPanel(this.upgradeDisplay.data.name, this.upgradeDisplay.data.title, this.upgradeDisplay.data.text);
  }

  public void HideDescription() => CardPopUp.RemovePanel(this.upgradeDisplay.data.name);
}
﻿// Decompiled with JetBrains decompiler
// Type: CardContainer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Pool;

public class CardContainer : 
  MonoBehaviourRect,
  IPointerEnterHandler,
  IEventSystemHandler,
  IPointerExitHandler,
  IList<Entity>,
  ICollection<Entity>,
  IEnumerable<Entity>,
  IEnumerable
{
  [Required(null)]
  public RectTransform holder;
  public UINavigationItem nav;
  public List<CardContainer> shoveTo = new List<CardContainer>();
  public CardContainer _group;
  public readonly List<Entity> entities = new List<Entity>();
  public Character owner;
  public bool canBePlacedOn;
  public bool canPlayOn;
  public bool canHover = true;
  public int max;
  [CompilerGenerated]
  public int \u003CCount\u003Ek__BackingField;
  public Vector3 gap;
  public Vector3 childHoverOffset;
  [Header("Movement Tween")]
  public Vector2 movementDurRand = new Vector2(0.3f, 0.4f);
  public LeanTweenType movementEase = LeanTweenType.easeOutQuart;
  [Header("Scale Tween")]
  public Vector2 scaleDurRand = new Vector2(0.2f, 0.2f);
  public LeanTweenType scaleEase = LeanTweenType.easeOutQuart;
  [Header("Events")]
  public UnityEventEntity onAdd;
  public UnityEventEntity onRemove;
  public CardController _cc;
  [SerializeField]
  public bool poolCardsOnDestroy = true;

  public virtual CardContainer Group
  {
    get => !(bool) (UnityEngine.Object) this._group ? this : this._group;
    set => this._group = value;
  }

  public virtual int Count
  {
    get => this.\u003CCount\u003Ek__BackingField;
    set => this.\u003CCount\u003Ek__BackingField = value;
  }

  public virtual float CardScale => (float) ((double) this.holder.sizeDelta.y / 4.5 * 1.0);

  public bool Empty => this.Count <= 0;

  public CardController cc
  {
    get
    {
      if (!(bool) (UnityEngine.Object) this._cc)
        this._cc = CardController.Find(this.gameObject);
      return this._cc;
    }
  }

  public bool IsReadOnly => false;

  public virtual int ChildCount => this.holder.childCount;

  public static CardContainer[] FindAll()
  {
    CardContainer[] objectsOfType = UnityEngine.Object.FindObjectsOfType<CardContainer>();
    HashSet<CardContainer> cardContainerSet = GenericPool<HashSet<CardContainer>>.Get();
    cardContainerSet.Clear();
    foreach (CardContainer cardContainer in objectsOfType)
    {
      if ((UnityEngine.Object) cardContainer.Group != (UnityEngine.Object) cardContainer)
        cardContainerSet.AddIfNotNull<CardContainer>(cardContainer);
    }
    CardContainer[] array = cardContainerSet.ToArray<CardContainer>();
    GenericPool<HashSet<CardContainer>>.Release(cardContainerSet);
    return array;
  }

  public CardContainer[] GetSecondaryContainers(Entity entity)
  {
    List<CardContainer> toRelease = GenericPool<List<CardContainer>>.Get();
    toRelease.Clear();
    foreach (CardContainer cardContainer in CardContainer.FindAll())
    {
      if ((UnityEngine.Object) cardContainer != (UnityEngine.Object) this && cardContainer.Contains(entity))
        toRelease.Add(cardContainer);
    }
    CardContainer[] array = toRelease.ToArray();
    GenericPool<List<CardContainer>>.Release(toRelease);
    return array;
  }

  public virtual void AssignController(CardController controller) => this._cc = controller;

  public void Start()
  {
    this.nav = (UINavigationItem) null;
    this.CheckForNavigationItem(this.transform);
  }

  public void CheckForNavigationItem(Transform inTransform)
  {
    if ((bool) (UnityEngine.Object) inTransform.GetComponent<UINavigationItem>())
    {
      this.nav = inTransform.GetComponent<UINavigationItem>();
    }
    else
    {
      for (int index = 0; index < inTransform.childCount; ++index)
        this.CheckForNavigationItem(inTransform.GetChild(index));
    }
  }

  public void OnDestroy()
  {
    if (GameManager.End || !this.poolCardsOnDestroy)
      return;
    for (int index = this.entities.Count - 1; index >= 0; --index)
      CardManager.ReturnToPool(this.entities[index]);
  }

  public virtual void SetSize(int size, float cardScale) => this.max = size;

  public virtual void Add(Entity entity)
  {
    entity.transform.SetParent((Transform) this.holder);
    entity.AddTo(this);
    this.entities.Add(entity);
    ++this.Count;
    this.CardAdded(entity);
    this.onAdd.Invoke(entity);
  }

  public virtual void Insert(int index, Entity entity)
  {
    entity.transform.SetParent((Transform) this.holder);
    entity.AddTo(this);
    this.entities.Insert(index, entity);
    ++this.Count;
    entity.transform.SetSiblingIndex(index);
    this.CardAdded(entity);
    this.onAdd.Invoke(entity);
  }

  public virtual bool PushForwards(int fromIndex) => throw new NotImplementedException();

  public virtual bool PushBackwards(int fromIndex) => throw new NotImplementedException();

  public virtual void MoveChildrenForward() => throw new NotImplementedException();

  public virtual void Remove(Entity entity)
  {
    if (!entity.inCardPool)
      entity.transform.SetParent((Transform) null);
    entity.RemoveFrom(this);
    this.entities.Remove(entity);
    --this.Count;
    this.CardRemoved(entity);
    this.onRemove.Invoke(entity);
    Debug.Log((object) ("[" + entity.name + "] Removed From [" + this.name + "]"));
  }

  public virtual void RemoveAt(int index) => this.Remove(this[index]);

  public virtual Entity this[int index]
  {
    get => this.entities.Count <= index ? (Entity) null : this.entities[index];
    set => throw new NotImplementedException();
  }

  public virtual Entity GetTop() => this.entities.Count <= 0 ? (Entity) null : this.entities[this.entities.Count - 1];

  public virtual Vector3 GetChildPosition(Entity child) => Vector3.zero;

  public virtual Vector3 GetChildScale(Entity child) => Vector3.one * this.CardScale;

  public virtual Vector3 GetChildRotation(Entity child) => Vector3.zero;

  public virtual int GetChildDrawOrder(Entity child) => 0;

  public virtual void CardAdded(Entity entity)
  {
  }

  public virtual void CardRemoved(Entity entity)
  {
  }

  public bool IsPrimaryContainer(Entity entity) => (bool) (UnityEngine.Object) entity && entity.actualContainers.Count > 0 && (UnityEngine.Object) entity.actualContainers[0] == (UnityEngine.Object) this;

  [Button(null, EButtonEnableMode.Always)]
  public virtual void TweenChildPositions()
  {
    foreach (Entity entity in this.Where<Entity>((Func<Entity, bool>) (a => a.alive)))
      entity.TweenToContainer();
  }

  public virtual void SetChildPositions()
  {
    foreach (Entity child in this)
      this.SetChildPosition(child);
  }

  public virtual void TweenChildPosition(Entity child) => child.TweenToContainer();

  public virtual void SetChildPosition(Entity child)
  {
    child.transform.localPosition = this.GetChildPosition(child);
    child.transform.localScale = this.GetChildScale(child);
    child.transform.localEulerAngles = this.GetChildRotation(child);
  }

  public void OnPointerEnter(PointerEventData eventData)
  {
    if (!this.canHover)
      return;
    this.Hover();
  }

  public virtual void Hover()
  {
    if (!(bool) (UnityEngine.Object) this.cc)
      return;
    this.cc.HoverContainer(this);
  }

  public void OnPointerExit(PointerEventData eventData)
  {
    if (!this.canHover)
      return;
    this.UnHover();
  }

  public virtual void UnHover()
  {
    if (!(bool) (UnityEngine.Object) this.cc || !((UnityEngine.Object) this.cc.hoverContainer == (UnityEngine.Object) this))
      return;
    this.cc.UnHoverContainer();
  }

  public virtual int IndexOf(Entity item) => this.entities.IndexOf(item);

  public virtual void Clear()
  {
    for (int index = this.Count - 1; index >= 0; --index)
      this.RemoveAt(index);
  }

  public void DestroyAll()
  {
    foreach (Entity entity in this)
      CardManager.ReturnToPool(entity);
  }

  public void ClearAndDestroyAllImmediately()
  {
    Entity[] array = this.ToArray();
    this.Clear();
    foreach (Component component in array)
      component.gameObject.DestroyImmediate();
  }

  public virtual bool Contains(Entity item) => this.entities.Contains(item);

  public virtual Entity[] ToArray() => this.entities.ToArray();

  public void CopyTo(Entity[] array, int arrayIndex) => this.entities.CopyTo(array, arrayIndex);

  public bool System\u002ECollections\u002EGeneric\u002EICollection\u003CEntity\u003E\u002ERemove(
    Entity item)
  {
    throw new NotImplementedException();
  }

  public virtual IEnumerator<Entity> GetEnumerator() => (IEnumerator<Entity>) this.entities.GetEnumerator();

  IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();
}
﻿// Decompiled with JetBrains decompiler
// Type: CardContainerGrid
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;
using UnityEngine.UI;

public class CardContainerGrid : CardContainer
{
  [SerializeField]
  public bool fixedWidth;
  [SerializeField]
  public float minHeight;
  [SerializeField]
  public Vector2 cellSize = new Vector2(2.25f, 3.375f);
  [SerializeField]
  public Vector2 spacing = new Vector2(0.5f, 0.5f);
  [SerializeField]
  public int columnCount = 5;
  [SerializeField]
  public TextAlignment align = TextAlignment.Center;
  [Header("Sort Cards by Type")]
  [SerializeField]
  public bool sort;
  [Header("A lil randomness to card position/rotation")]
  [SerializeField]
  public Vector3 randomOffset;
  [SerializeField]
  public Vector3 randomRotation;

  public new void DestroyAll()
  {
    foreach (Entity entity in this.entities)
      CardManager.ReturnToPool(entity);
    this.entities.Clear();
    this.Count = 0;
  }

  public override void CardAdded(Entity entity)
  {
    base.CardAdded(entity);
    this.SetSize();
    this.Sort();
  }

  public override void CardRemoved(Entity entity)
  {
    base.CardRemoved(entity);
    this.SetSize();
    this.Sort();
  }

  public override float CardScale => this.cellSize.x / 3f;

  public override Vector3 GetChildPosition(Entity child)
  {
    int num1 = this.IndexOf(child);
    int num2 = num1 % this.columnCount;
    int rowIndex = Mathf.FloorToInt((float) (num1 / this.columnCount));
    int num3 = this.RowCount(rowIndex);
    float num4 = (float) ((double) num3 * (double) this.cellSize.x + (double) (num3 - 1) * (double) this.spacing.x);
    Vector2 sizeDelta = this.rectTransform.sizeDelta;
    Vector2 vector2_1 = new Vector2(-sizeDelta.x, sizeDelta.y) * 0.5f;
    switch (this.align)
    {
      case TextAlignment.Center:
        vector2_1.x = (float) (-(double) num4 * 0.5);
        break;
      case TextAlignment.Right:
        vector2_1.x = sizeDelta.x * 0.5f - num4;
        break;
    }
    vector2_1.x += this.cellSize.x * 0.5f + this.spacing.x;
    vector2_1.y -= this.cellSize.y * 0.5f + this.spacing.y;
    Vector2 vector2_2 = vector2_1;
    vector2_2.x += (float) ((double) num2 * (double) this.cellSize.x + (double) (num2 - 1) * (double) this.spacing.x);
    vector2_2.y -= (float) ((double) rowIndex * (double) this.cellSize.y + (double) (rowIndex - 1) * (double) this.spacing.y);
    return (Vector3) vector2_2 + Vector3.Scale(child.random3, this.randomOffset);
  }

  public int RowCount(int rowIndex) => Mathf.Clamp(this.Count - rowIndex * this.columnCount, 0, this.columnCount);

  public override Vector3 GetChildRotation(Entity child) => Vector3.Scale(child.random3, this.randomRotation);

  public void SetSize()
  {
    int columnCount = this.GetColumnCount();
    int rowCount = this.GetRowCount();
    float x = this.fixedWidth ? this.rectTransform.sizeDelta.x : (float) ((double) columnCount * (double) this.cellSize.x + (double) (columnCount - 1) * (double) this.spacing.x);
    float y = Mathf.Max(this.minHeight, (float) ((double) rowCount * (double) this.cellSize.y + (double) (rowCount - 1) * (double) this.spacing.y));
    LayoutElement component = this.GetComponent<LayoutElement>();
    if (component != null)
    {
      component.preferredWidth = x;
      component.preferredHeight = y;
    }
    else
      this.rectTransform.sizeDelta = new Vector2(x, y);
  }

  public void Sort()
  {
    if (!this.sort)
      return;
    this.entities.Sort((Comparison<Entity>) ((a, b) => a.data.cardType.sortPriority.CompareTo(b.data.cardType.sortPriority)));
  }

  public int GetColumnCount() => Mathf.Min(this.columnCount, this.Count);

  public int GetRowCount() => Mathf.CeilToInt((float) this.Count / (float) this.columnCount);
}
﻿// Decompiled with JetBrains decompiler
// Type: CardController
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

public class CardController : MonoBehaviour
{
  public Character owner;
  [ReadOnly]
  public GameObject hover;
  [ReadOnly]
  public Entity hoverEntity;
  [ReadOnly]
  public Entity dragging;
  [ReadOnly]
  public CardContainer hoverContainer;
  [ReadOnly]
  public CardSlot hoverSlot;
  public bool canHoverWhileDragging = true;
  [Range(0.0f, 1f)]
  public float dragLerp = 0.25f;
  public float hoverZ = -0.2f;
  public float dragZ = -1f;
  [Header("Hover Tween")]
  public float cardHoverScale = 1.33f;
  public LeanTweenType cardHoverEase = LeanTweenType.easeOutBack;
  public float cardHoverEaseDur = 0.33f;
  public LeanTweenType cardUnHoverEase = LeanTweenType.easeOutBack;
  public float cardUnHoverEaseDur = 0.33f;
  [Header("Draw Order")]
  public int hoverDrawOrder = 100;
  public int dragDrawOrder = 200;
  [Header("Interactables")]
  public bool interactWithInPlay = true;
  public bool interactWithNotInPlay = true;
  public bool canPress = true;
  public bool canPressAndHoverInSameFrame;
  public Vector3 draggingPositionPre;
  public int draggingLayerPre;
  public Entity pressEntity;
  public bool press;

  public static CardController Find(GameObject gameObject) => gameObject.GetComponentInParent<CardController>();

  public virtual bool AllowDynamicSelectRelease => InputSystem.AllowDynamicSelectRelease;

  public Vector3 CardHoverScale => new Vector3(this.cardHoverScale * 1f, this.cardHoverScale * 1f, 1f);

  public virtual void Update()
  {
    if (!this.press)
    {
      if (this.canPress && InputSystem.IsSelectPressed())
      {
        this.press = true;
        if (this.canPressAndHoverInSameFrame || !(bool) (Object) this.hoverEntity || this.hoverEntity.display.hover.WasHovering)
        {
          this.pressEntity = this.hoverEntity;
          this.Press();
          if ((bool) (Object) this.pressEntity)
            Events.InvokeEntitySelect(this.pressEntity);
        }
      }
    }
    else if (InputSystem.IsDynamicSelectReleased(this.AllowDynamicSelectRelease && (bool) (Object) this.dragging))
    {
      this.Release();
      this.pressEntity = (Entity) null;
      this.press = false;
    }
    if (!(bool) (Object) this.dragging)
      return;
    this.DragUpdate();
  }

  public void Enable() => this.enabled = true;

  public void OnEnable() => Events.InvokeCardControllerEnabled(this);

  public void Disable()
  {
    this.enabled = false;
    this.Release();
    this.UnHover();
  }

  public void OnDisable() => Events.InvokeCardControllerDisabled(this);

  public virtual void Press()
  {
  }

  public virtual void Release()
  {
  }

  public bool TryDrag(Entity entity)
  {
    if (!Events.CheckEntityDrag(entity))
      return false;
    this.Drag(entity);
    return true;
  }

  public void Drag(Entity entity)
  {
    this.dragging = entity;
    this.draggingLayerPre = this.dragging.gameObject.layer;
    this.dragging.gameObject.layer = LayerMask.NameToLayer("Default");
    entity.dragging = true;
    this.draggingPositionPre = this.dragging.transform.position;
    if (this.dragDrawOrder != 0)
      entity.DrawOrder = this.dragDrawOrder;
    Events.InvokeEntityDrag(entity);
  }

  public virtual void DragEnd()
  {
    Events.InvokeEntityRelease(this.dragging);
    this.dragging.gameObject.layer = this.draggingLayerPre;
    this.dragging.dragging = false;
    this.dragging = (Entity) null;
    this.press = false;
  }

  public virtual void DragUpdate()
  {
    this.DragUpdatePosition();
    Wobbler wobbler = this.dragging.wobbler;
    if (!(bool) (Object) wobbler)
      return;
    Vector3 position = this.dragging.transform.position;
    Vector3 movement = position - this.draggingPositionPre;
    wobbler.Wobble(movement);
    this.draggingPositionPre = position;
  }

  public virtual void DragCancel()
  {
    this.DragEnd();
    this.UnHover(this.dragging);
  }

  public virtual bool CanUseOn(Entity entity, Entity target) => (bool) (Object) entity && (bool) (Object) target && entity.data.playType == Card.PlayType.Play && !entity.targetMode.TargetRow && (entity.data.canPlayOnBoard && Battle.IsOnBoard(target) || entity.data.canPlayOnHand && target.containers.Contains<CardContainer>(entity.owner?.handContainer)) && (entity.data.canPlayOnFriendly && (Object) entity.owner == (Object) target.owner || entity.data.canPlayOnEnemy && (Object) entity.owner != (Object) target.owner) && entity.CanPlayOn(target);

  public Vector3 GetDragPosition() => (Cursor3d.Position - (this.dragging.offset.position - this.dragging.transform.position)).WithZ(this.dragZ);

  public virtual void DragUpdatePosition() => this.dragging.transform.position = Delta.Lerp(this.dragging.transform.position, this.GetDragPosition(), this.dragLerp, Time.deltaTime);

  public void Hover(Entity entity)
  {
    if ((bool) (Object) this.dragging && (!this.canHoverWhileDragging || !this.CanUseOn(this.dragging, entity)) || entity.StillExists() && (!entity.inPlay || !this.interactWithInPlay) && (entity.inPlay || !this.interactWithNotInPlay))
      return;
    if ((bool) (Object) this.hoverEntity && (Object) this.dragging != (Object) this.hoverEntity)
      this.UnHover(this.hoverEntity);
    if (!(bool) (Object) entity || !((Object) entity != (Object) this.dragging))
      return;
    this.hoverEntity = entity;
    this.TweenHover(entity);
    Events.InvokeEntityHover(entity);
  }

  public void UnHover(Entity entity)
  {
    if ((bool) (Object) this.dragging && !this.canHoverWhileDragging)
      return;
    if ((Object) this.hoverEntity == (Object) entity)
    {
      this.hoverEntity = (Entity) null;
      Events.InvokeEntityUnHover(entity);
    }
    if (!((Object) this.dragging != (Object) entity))
      return;
    this.TweenUnHover(entity);
  }

  public void UnHover()
  {
    if (!(bool) (Object) this.hoverEntity)
      return;
    this.UnHover(this.hoverEntity);
  }

  public void HoverContainer(CardContainer container)
  {
    this.UnHoverContainer();
    this.hoverContainer = container;
    Events.InvokeContainerHover(container);
  }

  public void UnHoverContainer()
  {
    if (!(bool) (Object) this.hoverContainer)
      return;
    Events.InvokeContainerUnHover(this.hoverContainer);
    this.hoverContainer = (CardContainer) null;
  }

  public void HoverSlot(CardSlot slot)
  {
    if ((bool) (Object) this.dragging && !this.dragging.CanPlayOn((CardContainer) slot))
      return;
    this.UnHoverSlot();
    this.hoverSlot = slot;
    Events.InvokeSlotHover(slot);
  }

  public void UnHoverSlot()
  {
    if (!(bool) (Object) this.hoverSlot)
      return;
    Events.InvokeSlotUnHover(this.hoverSlot);
    this.hoverSlot = (CardSlot) null;
  }

  public void TweenHover(
    Entity entity,
    bool doScale = true,
    bool doMove = true,
    bool doRotate = true,
    bool doDrawOrder = true)
  {
    GameObject gameObject = entity.offset.gameObject;
    LeanTween.cancel(gameObject);
    if (doScale)
      LeanTween.scale(gameObject, this.CardHoverScale, this.cardHoverEaseDur).setEase(this.cardHoverEase);
    if (doMove)
    {
      float y = 0.0f;
      Vector3 v = new Vector3(0.0f, y, 0.0f);
      if (entity.containers.Length != 0)
      {
        foreach (CardContainer container in entity.containers)
        {
          y -= container.GetChildPosition(entity).y / entity.transform.localScale.y;
          v += container.childHoverOffset;
        }
        v /= (float) entity.actualContainers.Count;
      }
      LeanTween.moveLocal(gameObject, v.WithZ(this.hoverZ), this.cardHoverEaseDur * 1.5f).setEase(LeanTweenType.easeOutQuart);
    }
    if (doRotate)
      LeanTween.rotateZ(gameObject, 0.0f, this.cardHoverEaseDur * 1.5f).setEase(LeanTweenType.easeOutQuart);
    if (doDrawOrder && this.hoverDrawOrder != 0)
      entity.DrawOrder = this.hoverDrawOrder;
    if (!(bool) (Object) entity.display || !(bool) (Object) entity.display.hover)
      return;
    entity.display.hover.hovering = true;
  }

  public void TweenUnHover(
    Entity entity,
    bool retainScale = false,
    bool retainPosition = false,
    bool retainRotation = false,
    bool retainDrawOrder = false)
  {
    GameObject gameObject = entity.offset.gameObject;
    LeanTween.cancel(gameObject);
    if (!retainScale)
      LeanTween.scale(gameObject, Vector3.one, this.cardUnHoverEaseDur).setEase(this.cardUnHoverEase);
    if (!retainPosition)
      LeanTween.moveLocal(gameObject, Vector3.zero, this.cardUnHoverEaseDur).setEase(this.cardUnHoverEase);
    if (!retainRotation)
      LeanTween.rotateLocal(gameObject, Vector3.zero, this.cardUnHoverEaseDur).setEase(this.cardUnHoverEase);
    if (!retainDrawOrder)
      entity.ResetDrawOrder();
    if (!(bool) (Object) entity.display || !(bool) (Object) entity.display.hover)
      return;
    entity.display.hover.hovering = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardControllerBattle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class CardControllerBattle : CardController
{
  public UINavigationItem useOnHandAnchor;

  public override void Press()
  {
    if (!(bool) (Object) this.pressEntity || !((Object) this.pressEntity.owner == (Object) this.owner))
      return;
    Debug.Log((object) ("Pressing [" + this.pressEntity.name + "]"));
    if (!this.TryDrag(this.pressEntity))
      return;
    this.UnHover(this.pressEntity);
    NavigationState.Start((INavigationState) new NavigationStateCard(this.pressEntity));
  }

  public override void DragUpdatePosition()
  {
    Vector3 target = this.GetDragPosition();
    if ((bool) (Object) this.hoverContainer && this.hoverContainer.canBePlacedOn && (Object) this.hoverContainer == (Object) this.owner.discardContainer && this.dragging.CanRecall())
    {
      this.dragging.transform.position = Delta.Lerp(this.dragging.transform.position, this.hoverContainer.transform.position - Vector3.Scale(this.dragging.offset.localPosition, this.dragging.transform.localScale), this.dragLerp, Time.deltaTime);
    }
    else
    {
      if (!(bool) (Object) this.dragging.data)
        return;
      if (this.dragging.data.playType == Card.PlayType.Play)
      {
        if (!this.dragging.NeedsTarget)
        {
          if ((bool) (Object) this.hoverContainer && this.dragging.containers.Length != 0 && (Object) this.hoverContainer == (Object) this.dragging.containers[0])
          {
            Vector3 positionFromContainers = this.dragging.GetPositionFromContainers();
            target = positionFromContainers + Vector3.ClampMagnitude(target - positionFromContainers, 0.2f);
          }
          this.dragging.transform.position = Delta.Lerp(this.dragging.transform.position, target, this.dragLerp, Time.deltaTime);
          return;
        }
        if (this.dragging.NeedsTarget)
        {
          Vector3 vector3 = this.dragging.GetPositionFromContainers();
          if ((!this.dragging.targetMode.TargetRow || !(bool) (Object) this.hoverContainer || !this.hoverContainer.canPlayOn) && (bool) (Object) this.hoverEntity && (Object) this.hoverEntity != (Object) this.dragging && this.hoverEntity.InHand())
          {
            Vector3 position = this.useOnHandAnchor.transform.position;
            vector3 = position.WithX((float) (((double) position.x + (double) target.x) / 2.0));
          }
          if (this.dragging.data.playOnSlot && this.dragging.CanPlayOn((CardContainer) this.hoverSlot))
          {
            Entity top = this.hoverSlot.GetTop();
            Dictionary<Entity, List<CardSlot>> shoveData;
            if (top != null && ShoveSystem.CanShove(top, this.dragging, out shoveData))
              ShoveSystem.ShowShove(this.hoverSlot, shoveData);
          }
          this.dragging.transform.position = Delta.Lerp(this.dragging.transform.position, vector3 + Vector3.ClampMagnitude(target - vector3, 0.2f), this.dragLerp, Time.deltaTime);
          return;
        }
      }
      if (ShoveSystem.Active)
        target = ShoveSystem.Position;
      else if (this.dragging.data.playType == Card.PlayType.Place && (bool) (Object) this.hoverSlot && (Object) ShoveSystem.Slot != (Object) this.hoverSlot && this.hoverSlot.canBePlacedOn && (Object) this.hoverSlot.owner == (Object) this.dragging.owner)
      {
        if (this.hoverSlot.Count < this.hoverSlot.max || this.dragging.actualContainers.Contains((CardContainer) this.hoverSlot))
        {
          target = this.hoverSlot.transform.position - Vector3.Scale(this.dragging.offset.localPosition, this.dragging.transform.localScale);
        }
        else
        {
          Dictionary<Entity, List<CardSlot>> shoveData;
          if (ShoveSystem.CanShove(this.hoverSlot.GetTop(), this.dragging, out shoveData))
          {
            target = this.hoverSlot.transform.position - Vector3.Scale(this.dragging.offset.localPosition, this.dragging.transform.localScale);
            ShoveSystem.ShowShove(this.hoverSlot, shoveData);
          }
        }
      }
      this.dragging.transform.position = Delta.Lerp(this.dragging.transform.position, target, this.dragLerp, Time.deltaTime);
    }
  }

  public override void DragCancel()
  {
    this.dragging.TweenToContainer();
    this.TweenUnHover(this.dragging);
    base.DragCancel();
  }

  public override void DragEnd()
  {
    base.DragEnd();
    NavigationState.BackToPreviousState();
  }

  public override void Release()
  {
    if (!(bool) (Object) this.dragging)
      return;
    bool retainPosition = false;
    bool retainRotation = false;
    bool retainScale = false;
    bool retainDrawOrder = false;
    if (this.enabled)
    {
      if (InputSwitcher.justSwitched)
        this.dragging.TweenToContainer();
      else if ((bool) (Object) this.hoverContainer && this.hoverContainer.canBePlacedOn && (Object) this.hoverContainer == (Object) this.owner.discardContainer && (Object) this.dragging.owner == (Object) this.owner)
      {
        if (this.dragging.CanRecall())
        {
          ActionMove action = new ActionMove(this.dragging, new CardContainer[1]
          {
            this.hoverContainer
          });
          if (Events.CheckAction((PlayAction) action))
          {
            Events.InvokeDiscard(this.dragging);
            if (Battle.IsOnBoard(this.dragging))
              this.owner.freeAction = true;
            ActionQueue.Add((PlayAction) action);
            ActionQueue.Add((PlayAction) new ActionEndTurn(this.owner));
            this.enabled = false;
            retainDrawOrder = true;
          }
        }
        this.hoverContainer.UnHover();
      }
      else
      {
        switch (this.dragging.data.playType)
        {
          case Card.PlayType.Play:
            if (!this.dragging.NeedsTarget)
            {
              if (!(bool) (Object) this.hoverContainer || !this.dragging.InContainer(this.hoverContainer))
              {
                ActionTrigger action = new ActionTrigger(this.dragging, this.owner.entity);
                if (Events.CheckAction((PlayAction) action))
                {
                  ActionQueue.Add((PlayAction) action);
                  ActionQueue.Add((PlayAction) new ActionReduceUses(this.dragging));
                  ActionQueue.Add((PlayAction) new ActionResetOffset(this.dragging));
                  ActionQueue.Add((PlayAction) new ActionEndTurn(this.owner));
                  this.enabled = false;
                  retainRotation = true;
                  retainDrawOrder = true;
                  this.dragging.RemoveFromContainers();
                  break;
                }
                break;
              }
              break;
            }
            if (this.dragging.data.playOnSlot)
            {
              CardContainer cardContainer = this.dragging.targetMode.TargetRow ? this.hoverContainer : (CardContainer) this.hoverSlot;
              if (this.dragging.CanPlayOn(cardContainer))
              {
                ActionTriggerAgainst action = new ActionTriggerAgainst(this.dragging, this.owner.entity, (Entity) null, cardContainer);
                if (Events.CheckAction((PlayAction) action))
                {
                  if (ShoveSystem.Active)
                    ShoveSystem.Fix = true;
                  ActionQueue.Add((PlayAction) action);
                  ActionQueue.Add((PlayAction) new ActionReduceUses(this.dragging));
                  ActionQueue.Add((PlayAction) new ActionResetOffset(this.dragging));
                  ActionQueue.Add((PlayAction) new ActionEndTurn(this.owner));
                  this.enabled = false;
                  retainPosition = true;
                  retainRotation = true;
                  retainDrawOrder = true;
                  break;
                }
                break;
              }
              break;
            }
            if (this.dragging.targetMode.TargetRow)
            {
              if (this.dragging.CanPlayOn(this.hoverContainer))
              {
                ActionTriggerAgainst action = new ActionTriggerAgainst(this.dragging, this.owner.entity, (Entity) null, this.hoverContainer);
                if (Events.CheckAction((PlayAction) action))
                {
                  ActionQueue.Add((PlayAction) action);
                  ActionQueue.Add((PlayAction) new ActionReduceUses(this.dragging));
                  ActionQueue.Add((PlayAction) new ActionResetOffset(this.dragging));
                  ActionQueue.Add((PlayAction) new ActionEndTurn(this.owner));
                  this.enabled = false;
                  retainPosition = true;
                  retainRotation = true;
                  retainDrawOrder = true;
                  break;
                }
                break;
              }
              break;
            }
            if ((bool) (Object) this.hoverEntity && (Object) this.hoverEntity != (Object) this.dragging)
            {
              ActionTriggerAgainst action = new ActionTriggerAgainst(this.dragging, this.owner.entity, this.hoverEntity, (CardContainer) null);
              if (Events.CheckAction((PlayAction) action))
              {
                ActionQueue.Add((PlayAction) action);
                ActionQueue.Add((PlayAction) new ActionReduceUses(this.dragging));
                ActionQueue.Add((PlayAction) new ActionResetOffset(this.dragging));
                ActionQueue.Add((PlayAction) new ActionEndTurn(this.owner));
                this.enabled = false;
                retainPosition = true;
                retainRotation = true;
                retainDrawOrder = true;
                break;
              }
              break;
            }
            break;
          case Card.PlayType.Place:
            if ((bool) (Object) this.hoverSlot && !this.dragging.actualContainers.Contains((CardContainer) this.hoverSlot) && this.hoverSlot.canBePlacedOn && (Object) this.hoverSlot.owner == (Object) this.dragging.owner)
            {
              if (this.hoverSlot.Count < this.hoverSlot.max)
              {
                ActionMove action = new ActionMove(this.dragging, new CardContainer[1]
                {
                  (CardContainer) this.hoverSlot
                });
                if (Events.CheckAction((PlayAction) action))
                {
                  bool flag = Battle.IsOnBoard(this.dragging) && Battle.IsOnBoard(this.hoverSlot.Group);
                  Events.InvokeEntityPlace(this.dragging, new CardContainer[1]
                  {
                    (CardContainer) this.hoverSlot
                  }, (flag ? 1 : 0) != 0);
                  ActionQueue.Add((PlayAction) action);
                  ActionQueue.Add((PlayAction) new ActionEndTurn(this.owner));
                  if (flag)
                    this.owner.freeAction = true;
                  this.enabled = false;
                  break;
                }
                break;
              }
              Dictionary<Entity, List<CardSlot>> shoveData;
              if (ShoveSystem.CanShove(this.hoverSlot.GetTop(), this.dragging, out shoveData))
              {
                ActionMove action = new ActionMove(this.dragging, new CardContainer[1]
                {
                  (CardContainer) this.hoverSlot
                });
                if (Events.CheckAction((PlayAction) action))
                {
                  bool flag = Battle.IsOnBoard(this.dragging) && Battle.IsOnBoard(this.hoverSlot.Group);
                  ShoveSystem.Fix = true;
                  Events.InvokeEntityPlace(this.dragging, new CardContainer[1]
                  {
                    (CardContainer) this.hoverSlot
                  }, (flag ? 1 : 0) != 0);
                  ActionQueue.Add((PlayAction) new ActionShove(shoveData));
                  ActionQueue.Add((PlayAction) action);
                  ActionQueue.Add((PlayAction) new ActionEndTurn(this.owner));
                  if (flag)
                    this.owner.freeAction = true;
                  this.enabled = false;
                  break;
                }
                break;
              }
              break;
            }
            break;
        }
      }
      if (ActionQueue.Empty)
        this.dragging.TweenToContainer();
    }
    this.TweenUnHover(this.dragging, retainScale, retainPosition, retainRotation, retainDrawOrder);
    this.DragEnd();
    this.UnHover();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardControllerCardOrganizer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CardControllerCardOrganizer : CardController
{
  [Header("Plane to store positions in")]
  [SerializeField]
  public CardPlane cardPlane;
  [Header("Snap To Grid")]
  [SerializeField]
  public Vector2 snapOffset;
  [SerializeField]
  public Vector2 snapSize = new Vector2(3.8f, 5.5f);

  public override void Press()
  {
    if (!(bool) (Object) this.pressEntity || !this.TryDrag(this.pressEntity))
      return;
    this.pressEntity.transform.SetAsLastSibling();
  }

  public override void Release()
  {
    if (!((Object) this.dragging != (Object) null))
      return;
    Vector3 position = (this.GetDragPosition() - this.dragging.transform.parent.position).WithZ(0.0f);
    if (Input.GetButton("Snap"))
      position = this.Snap(position);
    this.dragging.transform.localPosition = position;
    this.cardPlane?.StorePosition(this.dragging);
    this.dragging.gameObject.layer = this.draggingLayerPre;
    this.dragging.dragging = false;
    this.TweenUnHover(this.dragging);
    this.DragEnd();
  }

  public override void DragUpdatePosition()
  {
    Vector3 vector3 = (this.GetDragPosition() - this.dragging.transform.parent.position).WithZ(this.dragZ);
    if (Input.GetButton("Snap"))
      vector3 = this.Snap(vector3);
    this.dragging.transform.localPosition = Delta.Lerp(this.dragging.transform.localPosition, vector3, this.dragLerp, Time.deltaTime);
  }

  public Vector3 Snap(Vector3 position)
  {
    position.x = Mathf.Round((position.x + this.snapOffset.x) / this.snapSize.x) * this.snapSize.x - this.snapOffset.x;
    position.y = Mathf.Round((position.y + this.snapOffset.y) / this.snapSize.y) * this.snapSize.y - this.snapOffset.y;
    return position;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardControllerDeck
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class CardControllerDeck : CardController
{
  [SerializeField]
  public DeckDisplaySequence deckDisplaySequence;
  public CardContainer deckContainer;
  public CardContainer reserveContainer;
  [SerializeField]
  public DeckSelectSequence selectSequence;
  [SerializeField]
  public ScrollRect scrollRect;
  [SerializeField]
  public ContentSizeFitter contentSizeFitter;

  public override bool AllowDynamicSelectRelease => false;

  public override void Press()
  {
    if (!(bool) (Object) this.pressEntity)
      return;
    this.StartCoroutine(this.OpenMenu(this.pressEntity));
  }

  public IEnumerator OpenMenu(Entity entity)
  {
    CardControllerDeck cardControllerDeck = this;
    cardControllerDeck.Disable();
    cardControllerDeck.selectSequence.SetEntity(entity);
    if (!(bool) (Object) References.Battle)
    {
      if (cardControllerDeck.owner.data.inventory.deck.Contains(entity.data))
      {
        if (entity.data.cardType.canReserve)
          cardControllerDeck.selectSequence.AddMoveDown((UnityAction) (() => this.MoveToReserve(entity)));
      }
      else if (cardControllerDeck.owner.data.inventory.reserve.Contains(entity.data) && cardControllerDeck.owner.GetCompanionCount() < cardControllerDeck.owner.data.companionLimit)
        cardControllerDeck.selectSequence.AddMoveUp((UnityAction) (() => this.MoveToDeck(entity)));
    }
    yield return (object) cardControllerDeck.selectSequence.Run();
    cardControllerDeck.Enable();
  }

  public void MoveToDeck(Entity entity)
  {
    if (!entity.InContainerGroup(this.deckContainer))
    {
      entity.RemoveFromContainers();
      this.deckContainer.Add(entity);
    }
    if (!this.owner.data.inventory.deck.Contains(entity.data))
    {
      this.owner.data.inventory.reserve.Remove(entity.data);
      this.owner.data.inventory.deck.Add(entity.data);
    }
    this.reserveContainer.TweenChildPositions();
    this.deckContainer.TweenChildPositions();
    this.StartCoroutine(this.FixLayoutsRoutine());
  }

  public void MoveToReserve(Entity entity)
  {
    if (!entity.InContainerGroup(this.reserveContainer))
    {
      entity.RemoveFromContainers();
      this.reserveContainer.Add(entity);
    }
    if (!this.owner.data.inventory.reserve.Contains(entity.data))
    {
      this.owner.data.inventory.deck.Remove(entity.data);
      this.owner.data.inventory.reserve.Add(entity.data);
    }
    this.reserveContainer.TweenChildPositions();
    this.deckContainer.TweenChildPositions();
    this.StartCoroutine(this.FixLayoutsRoutine());
  }

  public IEnumerator FixLayoutsRoutine()
  {
    Vector2 scrollPosition = this.scrollRect.normalizedPosition;
    this.contentSizeFitter.enabled = false;
    yield return (object) null;
    this.contentSizeFitter.enabled = true;
    this.scrollRect.normalizedPosition = scrollPosition;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardControllerDragger
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CardControllerDragger : CardController
{
  [Header("Dragging")]
  public bool canDrag = true;
  public UnityEventEntity onDrag;
  public UnityEventEntity onRelease;
  public UnityEventEntity onCancel;

  public override void Press()
  {
    if (!this.canDrag || !(bool) (Object) this.pressEntity || !((Object) this.pressEntity.owner == (Object) this.owner) || !this.TryDrag(this.pressEntity))
      return;
    this.onDrag?.Invoke(this.pressEntity);
  }

  public override void DragCancel()
  {
    if (!(bool) (Object) this.dragging)
      return;
    this.onCancel?.Invoke(this.dragging);
    this.DragEnd();
  }

  public override void Release()
  {
    if (!(bool) (Object) this.dragging)
      return;
    this.onRelease?.Invoke(this.dragging);
    this.DragEnd();
  }

  public override void DragEnd()
  {
    this.dragging.TweenToContainer();
    this.TweenUnHover(this.dragging);
    base.DragEnd();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardControllerSelectCard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class CardControllerSelectCard : CardController
{
  [Header("Press Tween")]
  public float cardPressScaleFrom = 0.8f;
  public float cardPressScaleTo = 1f;
  public LeanTweenType cardPressEase = LeanTweenType.easeOutElastic;
  public float cardPressEaseDur = 1f;
  public float cardPressWobble = 1f;
  public UnityEventEntity pressEvent;
  public UnityEventEntity hoverEvent;
  public UnityEventEntity unHoverEvent;

  public override bool AllowDynamicSelectRelease => false;

  public new void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(this.CardHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.CardUnHover);
  }

  public new void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.CardHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.CardUnHover);
  }

  public override void Press()
  {
    if (!this.canPress || !(bool) (Object) this.pressEntity || this.pressEntity.inPlay)
      return;
    Debug.Log((object) ("Pressing [" + this.pressEntity.name + "]"));
    this.TweenHover(this.pressEntity);
    if ((double) this.cardPressEaseDur > 0.0)
      LeanTween.scale(this.pressEntity.offset.gameObject, Vector3.one * this.cardPressScaleTo, this.cardPressEaseDur).setFrom(Vector3.one * this.cardPressScaleFrom).setEase(this.cardPressEase);
    if ((double) this.cardPressWobble == 0.0)
      return;
    this.pressEntity.wobbler?.WobbleRandom(this.cardPressWobble);
  }

  public override void Release()
  {
    if (!(bool) (Object) this.pressEntity || !((Object) this.hoverEntity == (Object) this.pressEntity) || this.pressEntity.inPlay)
      return;
    Debug.Log((object) string.Format("[{0}] PRESSING [{1}]! :D", (object) this, (object) this.pressEntity));
    Entity pressEntity = this.pressEntity;
    this.pressEntity = (Entity) null;
    this.pressEvent.Invoke(pressEntity);
  }

  public void CardHover(Entity entity) => this.hoverEvent.Invoke(entity);

  public void CardUnHover(Entity entity) => this.unHoverEvent.Invoke(entity);
}
﻿// Decompiled with JetBrains decompiler
// Type: CardData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Serialization;

[CreateAssetMenu(fileName = "CardData", menuName = "Card Data")]
public class CardData : DataFile, ISaveable<CardSaveData>
{
  public static ulong idCurrent;
  [CompilerGenerated]
  public ulong \u003Cid\u003Ek__BackingField;
  [FormerlySerializedAs("title")]
  public string titleFallback;
  public string forceTitle;
  [TextArea]
  public string desc;
  public LocalizedString titleKey;
  public LocalizedString textKey;
  [SerializeField]
  public string textInsert;
  public string flavour;
  public LocalizedString flavourKey;
  public int value;
  public CardAnimationProfile idleAnimationProfile;
  public string[] greetMessages;
  public BloodProfile bloodProfile;
  [Header("Stats")]
  public bool hasAttack;
  public int damage;
  public bool hasHealth;
  public int hp;
  public int counter;
  [Header("Attacking")]
  public bool canBeHit;
  [Required(null)]
  public TargetMode targetMode;
  public CardData.StatusEffectStacks[] attackEffects;
  [Header("Assets")]
  [ShowAssetPreview(64, 64)]
  public Sprite mainSprite;
  [ShowAssetPreview(64, 64)]
  public Sprite backgroundSprite;
  [Header("Details")]
  public CardType cardType;
  [ShowIf("IsClunker")]
  public bool isEnemyClunker;
  public Card.PlayType playType;
  public bool needsTarget = true;
  public bool canPlayOnBoard = true;
  public bool canPlayOnHand = true;
  public bool canPlayOnFriendly = true;
  public bool canPlayOnEnemy = true;
  public bool playOnSlot;
  [ShowIf("DoesShove")]
  public bool canShoveToOtherRow = true;
  public CardData.PlayPosition defaultPlayPosition;
  public int uses;
  public CardData.StatusEffectStacks[] startWithEffects;
  public List<CardData.TraitStacks> traits;
  public TargetConstraint[] targetConstraints;
  [Space]
  [ReadOnly]
  public int effectBonus;
  [ReadOnly]
  public float effectFactor = 1f;
  public List<CardData.StatusEffectStacks> injuries;
  [ReadOnly]
  public List<CardUpgradeData> upgrades;
  [ReadOnly]
  public Vector3 random3;
  [ReadOnly]
  public int charmSlots = 3;
  [ReadOnly]
  public int tokenSlots = 1;
  [ReadOnly]
  public int crownSlots = 1;
  public ScriptableCardImage scriptableImagePrefab;
  [SerializeField]
  public CardScript[] createScripts;
  public Dictionary<string, object> customData;
  [CompilerGenerated]
  public CardData \u003Coriginal\u003Ek__BackingField;

  public ulong id
  {
    get => this.\u003Cid\u003Ek__BackingField;
    set => this.\u003Cid\u003Ek__BackingField = value;
  }

  public void SetId(ulong value)
  {
    this.id = value;
    if (this.id <= CardData.idCurrent)
      return;
    CardData.idCurrent = this.id;
  }

  public string title
  {
    get
    {
      if (!this.forceTitle.IsNullOrWhitespace())
        return this.forceTitle;
      LocalizedString titleKey = this.titleKey;
      return titleKey == null || titleKey.IsEmpty ? this.titleFallback : this.titleKey.GetLocalizedString();
    }
  }

  public bool HasCustomText => !this.textKey.IsEmpty;

  public string GetCustomText(bool silenced = false)
  {
    string customText = Text.GetEffectText(this.textKey, this.textInsert, this.attackEffects.Length != 0 ? this.attackEffects[0].count : (this.startWithEffects.Length != 0 ? this.startWithEffects[0].count : 0), silenced);
    for (int index = this.attackEffects.Length - 1; index >= 0; --index)
    {
      string oldValue = "{a" + index.ToString() + "}";
      if (customText.Contains(oldValue))
        customText = customText.Replace(oldValue, this.attackEffects[index].count.ToString());
    }
    for (int index = this.startWithEffects.Length - 1; index >= 0; --index)
    {
      string oldValue = "{s" + index.ToString() + "}";
      if (customText.Contains(oldValue))
        customText = customText.Replace(oldValue, this.startWithEffects[index].count.ToString());
    }
    return customText;
  }

  public bool IsClunker => this.cardType.name == "Clunker";

  public bool IsItem => this.playType == Card.PlayType.Play;

  public bool DoesShove
  {
    get
    {
      if (this.playType == Card.PlayType.Place)
        return true;
      return this.playType == Card.PlayType.Play && this.playOnSlot;
    }
  }

  public CardData original
  {
    get => this.\u003Coriginal\u003Ek__BackingField;
    set => this.\u003Coriginal\u003Ek__BackingField = value;
  }

  public bool HasCrown => (UnityEngine.Object) this.GetCrown() != (UnityEngine.Object) null;

  public CardUpgradeData GetCrown() => this.upgrades.Find((Predicate<CardUpgradeData>) (a => a.type == CardUpgradeData.Type.Crown));

  public void RemoveCrown() => this.GetCrown()?.UnAssign(this);

  public CardData Clone(bool runCreateScripts = true) => this.Clone(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)).normalized, CardData.idCurrent + 1UL, runCreateScripts);

  public CardData Clone(Vector3 random3, bool runCreateScripts = true) => this.Clone(random3, CardData.idCurrent + 1UL, runCreateScripts);

  public CardData Clone(Vector3 random3, ulong id, bool runCreateScripts = true)
  {
    CardData cardData1 = this.InstantiateKeepName<CardData>();
    cardData1.original = this;
    cardData1.SetId(id);
    cardData1.random3 = random3;
    CardData cardData2 = cardData1;
    Dictionary<string, object> customData = this.customData;
    Dictionary<string, object> dictionary = customData != null ? customData.ToDictionary<KeyValuePair<string, object>, string, object>((Func<KeyValuePair<string, object>, string>) (entry => entry.Key), (Func<KeyValuePair<string, object>, object>) (entry => entry.Value)) : (Dictionary<string, object>) null;
    cardData2.customData = dictionary;
    if (runCreateScripts)
    {
      cardData1.RunCreateScripts();
      Events.InvokeCardDataCreated(cardData1);
    }
    return cardData1;
  }

  public void RunCreateScripts()
  {
    if (this.createScripts == null || this.createScripts.Length == 0)
      return;
    UnityEngine.Random.State state = UnityEngine.Random.state;
    int num = Mathf.Abs(Mathf.RoundToInt(this.random3.x * 100000f));
    for (int index = 0; index < this.createScripts.Length; ++index)
    {
      UnityEngine.Random.InitState(num + index);
      this.createScripts[index].Run(this);
    }
    UnityEngine.Random.state = state;
  }

  public void SetCustomData(string key, object value)
  {
    if (this.customData == null)
      this.customData = new Dictionary<string, object>();
    this.customData[key] = value;
  }

  public bool TryGetCustomData<T>(string key, out T value, T defaultValue)
  {
    object obj1;
    if (this.customData != null && this.customData.TryGetValue(key, out obj1) && obj1 is T obj2)
    {
      value = obj2;
      return true;
    }
    value = defaultValue;
    return false;
  }

  public bool IsOffensive()
  {
    bool flag = this.damage > 0 || (bool) (UnityEngine.Object) this.original && this.original.damage > 0;
    if (!flag && ((IEnumerable<CardData.StatusEffectStacks>) this.attackEffects).Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (s => s.data.offensive)))
      flag = true;
    if (!flag && ((IEnumerable<CardData.StatusEffectStacks>) this.startWithEffects).Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (s => s.data.makesOffensive)))
      flag = true;
    return flag;
  }

  public CardSaveData Save() => new CardSaveData(this);

  public override int GetHashCode() => this.name.GetHashCode() ^ this.random3.GetHashCode() ^ this.id.GetHashCode();

  public enum PlayPosition
  {
    None,
    Friendly,
    Enemy,
    Hand,
    FriendlyRow,
    EnemyRow,
    Field,
    FriendlySlot,
    EnemySlot,
  }

  [Serializable]
  public class StatusEffectStacks : ISaveable<StatusEffectSaveData>
  {
    public StatusEffectData data;
    public int count;

    public StatusEffectStacks()
    {
    }

    public StatusEffectStacks(StatusEffectData data, int count)
    {
      this.data = data;
      this.count = count;
    }

    public StatusEffectSaveData Save() => new StatusEffectSaveData()
    {
      name = this.data.name,
      count = this.count
    };

    public static CardData.StatusEffectStacks[] Stack(
      IEnumerable<CardData.StatusEffectStacks> currentEffects,
      IEnumerable<CardData.StatusEffectStacks> newEffects)
    {
      List<CardData.StatusEffectStacks> source = new List<CardData.StatusEffectStacks>(currentEffects);
      foreach (CardData.StatusEffectStacks newEffect in newEffects)
      {
        CardData.StatusEffectStacks e = newEffect;
        CardData.StatusEffectStacks statusEffectStacks = source.FirstOrDefault<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) e.data));
        if (statusEffectStacks != null)
          statusEffectStacks.count += e.count;
        else
          source.Add(e);
      }
      return source.ToArray();
    }

    public override string ToString() => string.Format("{0} {1}", (object) this.count, (object) this.data.name);

    public CardData.StatusEffectStacks Clone() => new CardData.StatusEffectStacks(this.data, this.count);
  }

  [Serializable]
  public class TraitStacks : ISaveable<TraitSaveData>
  {
    public TraitData data;
    public int count;

    public TraitStacks(TraitData data, int count)
    {
      this.data = data;
      this.count = count;
    }

    public TraitStacks()
    {
    }

    public TraitSaveData Save() => new TraitSaveData()
    {
      name = this.data.name,
      count = this.count
    };

    public override string ToString() => string.Format("{0} {1}", (object) this.data.name, (object) this.count);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardDataList
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class CardDataList : 
  IList<CardData>,
  ICollection<CardData>,
  IEnumerable<CardData>,
  IEnumerable
{
  [SerializeField]
  public List<CardData> list = new List<CardData>();

  public IEnumerator<CardData> GetEnumerator() => (IEnumerator<CardData>) this.list.GetEnumerator();

  IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.list.GetEnumerator();

  public void Add(CardData item) => this.list.Add(item);

  public void Clear() => this.list.Clear();

  public bool Contains(CardData item)
  {
    if (!(bool) (UnityEngine.Object) item)
      return false;
    foreach (CardData cardData in this.list)
    {
      if ((long) cardData.id == (long) item.id)
        return true;
    }
    return false;
  }

  public void CopyTo(CardData[] array, int arrayIndex) => this.list.CopyTo(array, arrayIndex);

  public bool Remove(CardData item)
  {
    int index = this.IndexOf(item);
    if (index < 0)
      return false;
    this.list.RemoveAt(index);
    return true;
  }

  public int Count => this.list.Count;

  public bool IsReadOnly => false;

  public int IndexOf(CardData item)
  {
    if (!(bool) (UnityEngine.Object) item)
      return -1;
    for (int index = 0; index < this.list.Count; ++index)
    {
      if ((long) this.list[index].id == (long) item.id)
        return index;
    }
    return -1;
  }

  public void Insert(int index, CardData item) => this.list.Insert(index, item);

  public void RemoveAt(int index) => this.list.RemoveAt(index);

  public CardData this[int index]
  {
    get => this.list[index];
    set => this.list[index] = value;
  }

  public void Sort() => this.list.Sort();

  public void Sort(Comparison<CardData> comparison) => this.list.Sort(comparison);

  public void Sort(IComparer<CardData> comparer) => this.list.Sort(comparer);

  public void Sort(int index, int count, IComparer<CardData> comparer) => this.list.Sort(index, count, comparer);

  public List<CardData> FindAll(Predicate<CardData> predicate) => this.list.FindAll(predicate);
}
﻿// Decompiled with JetBrains decompiler
// Type: CardDeactivator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class CardDeactivator : MonoBehaviour
{
  public readonly List<GameObject> entities = new List<GameObject>();
  public readonly List<GameObject> toDisable = new List<GameObject>();
  public Camera _cam;

  public Camera cam => this._cam ?? (this._cam = Camera.main);

  public void OnEnable()
  {
    global::Events.OnEntityCreated += new UnityAction<Entity>(this.EntityCreated);
    global::Events.OnEntityDestroyed += new UnityAction<Entity>(this.EntityDestroyed);
  }

  public void OnDisable()
  {
    global::Events.OnEntityCreated -= new UnityAction<Entity>(this.EntityCreated);
    global::Events.OnEntityDestroyed -= new UnityAction<Entity>(this.EntityDestroyed);
  }

  public void EntityCreated(Entity entity) => this.entities.Add(entity.gameObject);

  public void EntityDestroyed(Entity entity) => this.entities.Remove(entity.gameObject);

  public void LateUpdate()
  {
    if (Transition.Running)
      return;
    foreach (GameObject entity in this.entities)
    {
      bool inView = this.cam.IsInCameraView(entity.transform.position, 0.1f);
      this.SetActiveness(entity.gameObject, inView);
    }
    for (int index = Mathf.CeilToInt((float) this.toDisable.Count * 0.1f) - 1; index >= 0; --index)
    {
      GameObject gameObject = this.toDisable[index];
      this.toDisable.RemoveAt(index);
      gameObject.gameObject.SetActive(false);
    }
  }

  public void SetActiveness(GameObject obj, bool inView)
  {
    if (inView)
    {
      if (obj.activeSelf && !this.toDisable.Contains(obj))
        return;
      obj.SetActive(true);
      this.toDisable.Remove(obj);
    }
    else
    {
      if (!obj.activeSelf || this.toDisable.Contains(obj))
        return;
      this.toDisable.Add(obj);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardDestroyed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CardDestroyed : FlyOffScreen, ICardDestroyed, IRemoveWhenPooled
{
  public AngleWobbler[] wobblers;

  public override void Begin()
  {
    this.wobblers = this.GetComponentsInChildren<AngleWobbler>();
    foreach (AngleWobbler wobbler in this.wobblers)
      wobbler.globalSpace = false;
  }

  public override void End() => this.Final();

  public void Final()
  {
    Object.Destroy((Object) this);
    CardManager.ReturnToPool(this.gameObject.GetComponent<Card>());
  }

  public void OnDisable()
  {
    foreach (AngleWobbler wobbler in this.wobblers)
      wobbler.globalSpace = true;
    this.wobblers = (AngleWobbler[]) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardDestroyedConsume
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using UnityEngine;
using UnityEngine.ResourceManagement.AsyncOperations;

public class CardDestroyedConsume : MonoBehaviour, ICardDestroyed, IRemoveWhenPooled
{
  public IEnumerator Start()
  {
    CardDestroyedConsume destroyedConsume = this;
    Entity entity = destroyedConsume.GetComponent<Entity>();
    AsyncOperationHandle<GameObject> handle = AddressableLoader.InstantiateAsync("CardBreakFX", entity.offset.position, Quaternion.identity, destroyedConsume.transform);
    SfxSystem.OneShot("event:/sfx/card/consume");
    yield return (object) handle;
    LeanTween.scale(destroyedConsume.gameObject, Vector3.one * 0.6f, 0.25f).setEase(LeanTweenType.easeInBack);
    yield return (object) new WaitForSeconds(0.25f);
    LeanTween.scale(destroyedConsume.gameObject, Vector3.one * 1.2f, 0.25f).setEase(LeanTweenType.easeInBack);
    yield return (object) new WaitForSeconds(0.15f);
    ParticleSystem ps = handle.Result.GetComponent<ParticleSystem>();
    if (ps != null)
    {
      ps.Play();
      if (entity.display is Card display)
      {
        CanvasGroup canvasGroup = display.canvasGroup;
        if (canvasGroup != null)
          LeanTween.alphaCanvas(canvasGroup, 0.0f, 0.1f);
      }
      yield return (object) new WaitUntil((Func<bool>) (() => !(bool) (UnityEngine.Object) ps || !ps.isPlaying));
    }
    // ISSUE: explicit non-virtual call
    __nonvirtual (destroyedConsume.Final());
  }

  public void Final()
  {
    UnityEngine.Object.Destroy((UnityEngine.Object) this);
    CardManager.ReturnToPool(this.gameObject.GetComponent<Card>());
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardDestroyedSacrifice
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CardDestroyedSacrifice : MonoBehaviour, ICardDestroyed, IRemoveWhenPooled
{
  public float dur = 0.5f;
  public const LeanTweenType ease = LeanTweenType.easeInBack;
  public Entity entity;

  public void Start()
  {
    this.entity = this.GetComponent<Entity>();
    this.entity.wobbler.WobbleRandom();
    Events.InvokeCameraAnimation("Droop");
    Events.InvokeScreenRumble(0.0f, 0.25f, 0.0f, 0.25f * this.dur, 0.5f * this.dur, 0.25f * this.dur);
    LeanTween.scale(this.gameObject, new Vector3(0.25f, 0.25f, 1f), this.dur).setEase(LeanTweenType.easeInBack).setOnComplete(new System.Action(this.Final));
    LeanTween.rotateY(this.gameObject, (float) 90.WithRandomSign(), this.dur).setEase(LeanTweenType.easeInBack);
    if (!(this.entity.display is Card display))
      return;
    CanvasGroup canvasGroup = display.canvasGroup;
    if (canvasGroup == null)
      return;
    LeanTween.alphaCanvas(canvasGroup, 0.0f, this.dur).setEase(LeanTweenType.easeInBack);
  }

  public void Final()
  {
    UnityEngine.Object.Destroy((UnityEngine.Object) this);
    CardManager.ReturnToPool(this.entity);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardDiscoverSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class CardDiscoverSystem : GameSystem
{
  public static CardDiscoverSystem instance;
  [SerializeField]
  public CardDiscoverSystem.PhaseChange[] phaseChanges;
  public List<string> discoveredCards;
  public List<string> discoveredCharms;

  public void OnEnable()
  {
    CardDiscoverSystem.instance = this;
    this.discoveredCards = SaveSystem.LoadProgressData<List<string>>("cardsDiscovered");
    if (this.discoveredCards == null)
      this.discoveredCards = new List<string>();
    this.discoveredCharms = SaveSystem.LoadProgressData<List<string>>("charmsDiscovered");
    if (this.discoveredCharms == null)
      this.discoveredCharms = new List<string>();
    global::Events.OnPreCampaignPopulate += new UnityAction(this.CampaignStart);
    global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnEntitySummoned += new UnityAction<Entity, Entity>(this.EntitySummoned);
    global::Events.OnEntityShowUnlocked += new UnityAction<Entity>(this.EntityShowUnlocked);
    global::Events.OnUpgradeGained += new UnityAction<CardUpgradeData>(this.UpgradeGained);
    global::Events.OnEntityEnterBackpack += new UnityAction<Entity>(this.EntityEnterBackpack);
  }

  public void OnDisable()
  {
    global::Events.OnPreCampaignPopulate -= new UnityAction(this.CampaignStart);
    global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnEntitySummoned -= new UnityAction<Entity, Entity>(this.EntitySummoned);
    global::Events.OnEntityShowUnlocked -= new UnityAction<Entity>(this.EntityShowUnlocked);
    global::Events.OnUpgradeGained -= new UnityAction<CardUpgradeData>(this.UpgradeGained);
    global::Events.OnEntityEnterBackpack -= new UnityAction<Entity>(this.EntityEnterBackpack);
  }

  public void CampaignStart()
  {
    foreach (CardData cardData in References.PlayerData.inventory.deck)
    {
      this.DiscoverCard(cardData);
      foreach (UnityEngine.Object upgrade in cardData.upgrades)
        this.DiscoverCharm(upgrade.name);
    }
  }

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    if (!(bool) (UnityEngine.Object) References.Battle || entity.owner.team != References.Battle.enemy.team)
      return;
    this.DiscoverCard(entity.data);
    this.DiscoverCard(((IEnumerable<CardDiscoverSystem.PhaseChange>) this.phaseChanges).FirstOrDefault<CardDiscoverSystem.PhaseChange>((Func<CardDiscoverSystem.PhaseChange, bool>) (a => a.phasedCardName == entity.data.name)).originalCardName);
  }

  public void EntitySummoned(Entity entity, Entity summonedBy) => this.DiscoverCard(entity.data);

  public void EntityShowUnlocked(Entity entity) => this.DiscoverCard(entity.data);

  public void UpgradeGained(CardUpgradeData upgradeData)
  {
    if (upgradeData.type != CardUpgradeData.Type.Charm)
      return;
    this.DiscoverCharm(upgradeData.name);
  }

  public void EntityEnterBackpack(Entity entity)
  {
    this.DiscoverCard(entity.data);
    foreach (CardUpgradeData upgrade in entity.data.upgrades)
    {
      if (upgrade.type == CardUpgradeData.Type.Charm)
        this.DiscoverCharm(upgrade.name);
    }
  }

  public void DiscoverCard(CardData cardData)
  {
    if (!cardData.cardType.discoverInJournal)
      return;
    this.DiscoverCard(cardData.name);
  }

  public void DiscoverCard(string cardDataName)
  {
    if (this.discoveredCards.Contains(cardDataName))
      return;
    this.discoveredCards.Add(cardDataName);
    SaveSystem.SaveProgressData<List<string>>("cardsDiscovered", this.discoveredCards);
  }

  public void DiscoverCharm(string charmName)
  {
    if (this.discoveredCharms.Contains(charmName))
      return;
    this.discoveredCharms.Add(charmName);
    SaveSystem.SaveProgressData<List<string>>("charmsDiscovered", this.discoveredCharms);
  }

  public static void CheckDiscoverCharm(string charmName) => CardDiscoverSystem.instance.DiscoverCharm(charmName);

  [Serializable]
  public struct PhaseChange
  {
    public string phasedCardName;
    public string originalCardName;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class CardDisplay : MonoBehaviour
{
  [SerializeField]
  public CardData data;
  public Card _card;

  public Card card => this._card ?? (this._card = this.GetComponent<Card>());

  public void Awake() => this.transform.localScale = Vector3.zero;

  public IEnumerator Start()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    CardDisplay cardDisplay = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      LeanTween.scale(cardDisplay.gameObject, Vector3.one, 0.3f).setEaseOutBack();
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    cardDisplay.card.entity.data = cardDisplay.data;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) cardDisplay.card.UpdateData(false);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardFrameSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CardFrameSetter : MonoBehaviour
{
  [SerializeField]
  public AddressableTieredSpriteLoader[] spriteSetters;
  public bool loaded;

  public void Load(int frameLevel)
  {
    if (this.loaded)
      return;
    foreach (AddressableTieredSpriteLoader spriteSetter in this.spriteSetters)
      spriteSetter.Load(frameLevel);
    this.loaded = true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardFramesSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Events;

public class CardFramesSystem : GameSystem
{
  public static CardFramesSystem instance;
  public Dictionary<string, int> frameLevels = new Dictionary<string, int>();
  public Dictionary<string, int> newFrameLevels = new Dictionary<string, int>();
  public bool show;

  public void OnEnable()
  {
    this.frameLevels = SaveSystem.LoadProgressData<Dictionary<string, int>>("frameLevels") ?? new Dictionary<string, int>();
    this.newFrameLevels = SaveSystem.LoadProgressData<Dictionary<string, int>>("newFrameLevels") ?? new Dictionary<string, int>();
    CardFramesSystem.instance = this;
    global::Events.OnCampaignEnd += new UnityAction<Campaign.Result, CampaignStats, PlayerData>(this.CampaignEnd);
    global::Events.OnSettingChanged += new UnityAction<string, object>(this.SettingChanged);
    this.show = Settings.Load<int>("SpecialCardFrames", 1) == 1;
  }

  public void OnDisable()
  {
    global::Events.OnCampaignEnd -= new UnityAction<Campaign.Result, CampaignStats, PlayerData>(this.CampaignEnd);
    global::Events.OnSettingChanged -= new UnityAction<string, object>(this.SettingChanged);
  }

  public void SettingChanged(string key, object value)
  {
    if (key != "SpecialCardFrames" || !(value is int num))
      return;
    this.show = num == 1;
  }

  public static int GetFrameLevel(string cardDataName)
  {
    if (!CardFramesSystem.instance.show)
      return 0;
    int frameLevel;
    CardFramesSystem.instance.frameLevels.TryGetValue(cardDataName, out frameLevel);
    return frameLevel;
  }

  public void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
  {
    if (result != Campaign.Result.Win)
      return;
    bool anyChange = false;
    if (CardFramesSystem.CheckTrueWin())
      this.SetFrameLevel(2, out anyChange);
    else
      this.SetFrameLevel(1, out anyChange);
    if (!anyChange)
      return;
    SaveSystem.SaveProgressData<Dictionary<string, int>>("frameLevels", this.frameLevels);
    SaveSystem.SaveProgressData<Dictionary<string, int>>("newFrameLevels", this.newFrameLevels);
  }

  public static bool CheckTrueWin() => SaveSystem.LoadCampaignData<bool>(Campaign.Data.GameMode, "trueWin", false);

  public void SetFrameLevel(int level, out bool anyChange)
  {
    anyChange = false;
    foreach (CardData cardData in References.PlayerData.inventory.deck)
    {
      if (this.TrySetFrameLevel(cardData, level))
        anyChange = true;
    }
  }

  public bool TrySetFrameLevel(CardData cardData, int level)
  {
    int num;
    if (cardData.cardType.miniboss || this.frameLevels.TryGetValue(cardData.name, out num) && num >= level)
      return false;
    this.frameLevels[cardData.name] = level;
    this.newFrameLevels[cardData.name] = level;
    return true;
  }

  public bool AnyNewFrames() => this.newFrameLevels.Count > 0;

  public IEnumerator DisplayNewFrames()
  {
    yield return (object) this.DisplayNewFrames(2);
    yield return (object) this.DisplayNewFrames(1);
    this.newFrameLevels.Clear();
    SaveSystem.SaveProgressData<Dictionary<string, int>>("newFrameLevels", this.newFrameLevels);
  }

  public IEnumerator DisplayNewFrames(int level)
  {
    string[] cards = this.GetNewCards(level);
    if (cards.Length != 0)
    {
      InputSystem.Disable();
      yield return (object) SceneManager.Load("CardFramesUnlocked", SceneType.Temporary);
      InputSystem.Enable();
      yield return (object) UnityEngine.Object.FindObjectOfType<CardFramesUnlockedSequence>().Run(level, cards);
      yield return (object) SceneManager.WaitUntilUnloaded("CardFramesUnlocked");
    }
  }

  public string[] GetNewCards(int level) => this.newFrameLevels.Where<KeyValuePair<string, int>>((Func<KeyValuePair<string, int>, bool>) (a => a.Value == level)).Select<KeyValuePair<string, int>, string>((Func<KeyValuePair<string, int>, string>) (a => a.Key)).ToArray<string>();
}
﻿// Decompiled with JetBrains decompiler
// Type: CardFramesUnlockedSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using TMPro;
using UnityEngine;
using UnityEngine.Localization;

public class CardFramesUnlockedSequence : MonoBehaviour
{
  [SerializeField]
  public LocalizedString chiseledFrameUnlocked;
  [SerializeField]
  public LocalizedString chiseledFramesUnlocked;
  [SerializeField]
  public LocalizedString goldFrameUnlocked;
  [SerializeField]
  public LocalizedString goldFramesUnlocked;
  [SerializeField]
  public TMP_Text text;
  [SerializeField]
  public CardHand container1;
  [SerializeField]
  public CardHand container2;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public GameObject group;
  [Header("Dynamic Positioning Based")]
  [SerializeField]
  public AnimationCurve angleAddBasedOnCount;
  [SerializeField]
  public AnimationCurve zPositionBasedOnCount;
  public const int splitTo2ndContainerThreshold = 3;
  public const float cardScale = 0.67f;

  public IEnumerator Run(int level, string[] cards)
  {
    this.text.text = (level == 1 ? (cards.Length > 1 ? this.chiseledFramesUnlocked : this.chiseledFrameUnlocked) : (cards.Length > 1 ? this.goldFramesUnlocked : this.goldFrameUnlocked)).GetLocalizedString().Format((object) cards.Length);
    yield return (object) this.CreateCards(cards);
  }

  public IEnumerator CreateCards(string[] cards)
  {
    this.SetScaleAndPosition(cards.Length);
    Routine.Clump clump = new Routine.Clump();
    int size = cards.Length > 3 ? Mathf.CeilToInt((float) cards.Length / 2f) : cards.Length;
    this.container1.SetSize(size, 0.67f);
    this.container2.SetSize(cards.Length - size, 0.67f);
    for (int index = 0; index < cards.Length; ++index)
    {
      string card = cards[index];
      CardHand cardHand = index < size ? this.container1 : this.container2;
      CardData cardData = AddressableLoader.Get<CardData>("CardData", card);
      if ((Object) cardData != (Object) null)
        clump.Add(this.CreateCard(cardData, (CardContainer) cardHand, false));
    }
    yield return (object) clump.WaitForEnd();
    this.group.SetActive(true);
    this.container1.SetChildPositions();
    this.container2.SetChildPositions();
  }

  public void SetScaleAndPosition(int numberOfCards)
  {
    float num1 = this.angleAddBasedOnCount.Evaluate((float) numberOfCards);
    float num2 = this.zPositionBasedOnCount.Evaluate((float) numberOfCards);
    this.container1.fanCircleAngleAdd = num1;
    this.container2.fanCircleAngleAdd = num1;
    this.container1.transform.localPosition = this.container1.transform.localPosition.WithZ(num2);
    this.container2.transform.localPosition = this.container2.transform.localPosition.WithZ(num2);
    if (numberOfCards > 3)
      return;
    this.container1.transform.localPosition = this.container1.transform.localPosition.WithY(0.0f);
  }

  public IEnumerator CreateCard(CardData cardData, CardContainer cardContainer, bool startFlipped)
  {
    Card card = CardManager.Get(cardData, this.cardController, (Character) null, false, true);
    if (startFlipped)
      card.entity.flipper.FlipDownInstant();
    cardContainer.Add(card.entity);
    yield return (object) card.UpdateData(false);
    if (startFlipped)
      card.entity.flipper.FlipUp(true);
  }

  public void End()
  {
    this.container1.DestroyAll();
    this.container2.DestroyAll();
    this.gameObject.SetActive(false);
    Routine routine = new Routine(SceneManager.Unload("CardFramesUnlocked"));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardHand
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using UnityEngine;

public class CardHand : CardContainer
{
  [SerializeField]
  public float fanCircleRadius = 20f;
  [SerializeField]
  public Vector3 fanCircleStartPos = new Vector3(0.0f, -20f, 0.0f);
  public bool staticAngleAdd;
  [ShowIf("staticAngleAdd")]
  public float fanCircleAngleAdd = 5f;
  [SerializeField]
  [DisableIf("staticAngleAdd")]
  public AnimationCurve fanCircleAngleAddCurve;
  [SerializeField]
  public bool dynamicGap;
  [SerializeField]
  [EnableIf("dynamicGap")]
  public AnimationCurve dynamicGapCurve;

  public override void TweenChildPosition(Entity child)
  {
    child.DrawOrder = this.GetChildDrawOrder(child);
    base.TweenChildPosition(child);
  }

  public override void SetSize(int size, float cardScale)
  {
    base.SetSize(size, cardScale);
    this.holder.sizeDelta = new Vector2((float) ((double) (3f * cardScale) * (double) size + (double) this.GetGap(size).x * (double) (size - 1)), 4.5f * cardScale);
  }

  public override Vector3 GetChildPosition(Entity child)
  {
    int childIndex = this.IndexOf(child);
    float radians = (float) (((double) this.GetAngle(childIndex) + 90.0) * (Math.PI / 180.0));
    Vector3 gap = this.GetGap(this.Count);
    return this.fanCircleStartPos + gap * ((float) (this.Count - 1) * 0.5f) - gap * (float) childIndex + (Vector3) Lengthdir.ToVector2(this.fanCircleRadius, radians);
  }

  public override Vector3 GetChildRotation(Entity child) => new Vector3(0.0f, 0.0f, this.GetAngle(this.IndexOf(child)));

  public Vector3 GetGap(int cardCount)
  {
    if (!this.dynamicGap || this.dynamicGapCurve.length <= 0)
      return this.gap;
    Keyframe keyframe = this.dynamicGapCurve[this.dynamicGapCurve.length - 1];
    float time = keyframe.time;
    return this.gap.WithX((double) cardCount > (double) time ? keyframe.value : this.dynamicGapCurve.Evaluate((float) cardCount));
  }

  public float GetAngleAdd()
  {
    if (this.fanCircleAngleAddCurve.length <= 0 || this.staticAngleAdd)
      return this.fanCircleAngleAdd;
    Keyframe keyframe = this.fanCircleAngleAddCurve[this.fanCircleAngleAddCurve.length - 1];
    return (double) this.Count <= (double) keyframe.time ? this.fanCircleAngleAddCurve.Evaluate((float) this.Count) : keyframe.value;
  }

  public float GetAngle(int childIndex)
  {
    float angleAdd = this.GetAngleAdd();
    return (float) (-(double) angleAdd * (double) (this.Count - 1) * 0.5 + (double) childIndex * (double) angleAdd);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardHover
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class CardHover : 
  MonoBehaviour,
  IPointerEnterHandler,
  IEventSystemHandler,
  IPointerExitHandler,
  IPointerAfterExitHandler
{
  [SerializeField]
  public bool IsMaster = true;
  [HideIf("IsMaster")]
  public CardHover master;
  [SerializeField]
  [ShowIf("IsMaster")]
  public GraphicRaycaster graphicRaycaster;
  [SerializeField]
  [ShowIf("IsMaster")]
  public Entity entity;
  [SerializeField]
  [ShowIf("IsMaster")]
  public bool disableWhileDragging = true;
  [SerializeField]
  [ShowIf("IsMaster")]
  public Flipper flipper;
  public UnityEvent onHover;
  public UnityEvent onUnHover;
  [Header("Pop up \"Keyword\" description(s) while mouse over")]
  [SerializeField]
  public CardPopUpTarget pop;
  [Header("Mouse Over This Element?")]
  [SerializeField]
  [ReadOnly]
  public bool mouseOver;
  [SerializeField]
  [ReadOnly]
  public int childMouseOverCount;
  public bool preMouseOver;
  [Header("Entity assigned as \"Hovering\"? (set by CardControllers)")]
  [ReadOnly]
  public bool hovering;
  [ShowIf("IsMaster")]
  public CardController controller;
  public bool hoverable = true;
  public bool dragging;
  public bool hasPop;
  [CompilerGenerated]
  public bool \u003CWasHovering\u003Ek__BackingField;

  public bool IsHovering => !this.IsMaster ? this.master.hovering : this.hovering;

  public bool IsHoverable => !this.IsMaster ? this.master.hoverable : this.hoverable;

  public bool IsMouseOver => this.mouseOver || this.childMouseOverCount > 0;

  public bool CanHover => this.enabled && (bool) (Object) this.controller && this.controller.enabled && !this.flipper.flipped && this.IsHoverable;

  public bool WasHovering
  {
    get => this.\u003CWasHovering\u003Ek__BackingField;
    set => this.\u003CWasHovering\u003Ek__BackingField = value;
  }

  public void Awake() => this.hasPop = (bool) (Object) this.pop;

  public void OnEnable()
  {
    this.hoverable = true;
    this.hovering = false;
    this.mouseOver = false;
    if (this.IsMaster)
      this.graphicRaycaster.enabled = true;
    global::Events.OnUpdateInputSystem += new UnityAction<bool>(this.UpdateInputSystem);
    global::Events.OnCardControllerEnabled += new UnityAction<CardController>(this.CardControllerEnabled);
  }

  public void OnDisable()
  {
    if (this.mouseOver && !this.IsMaster)
    {
      this.mouseOver = false;
      this.master.childMouseOverCount = Mathf.Max(0, this.master.childMouseOverCount - 1);
    }
    if (this.hasPop && (bool) (Object) this.pop && this.pop.popped)
      this.pop.UnPop();
    global::Events.OnUpdateInputSystem -= new UnityAction<bool>(this.UpdateInputSystem);
    global::Events.OnCardControllerEnabled -= new UnityAction<CardController>(this.CardControllerEnabled);
  }

  public void Update()
  {
    if (!this.hasPop || this.mouseOver && this.IsHovering)
      return;
    if ((bool) (Object) this.pop)
    {
      if (!this.pop.popped)
        return;
      this.pop.UnPop();
    }
    else
      this.hasPop = false;
  }

  public void LateUpdate()
  {
    this.WasHovering = this.IsHovering;
    if (this.IsMaster)
    {
      bool isMouseOver = this.IsMouseOver;
      if (isMouseOver && !this.preMouseOver)
        this.Hover();
      else if (!isMouseOver && this.preMouseOver)
        this.UnHover();
      this.preMouseOver = isMouseOver;
    }
    if (this.mouseOver && this.IsHovering && this.hasPop)
    {
      if ((bool) (Object) this.pop)
      {
        if (!this.pop.popped)
          this.pop.Pop();
      }
      else
        this.hasPop = false;
    }
    if (!this.IsMaster || !this.disableWhileDragging || this.entity.dragging == this.dragging)
      return;
    this.dragging = this.entity.dragging;
    if (this.dragging)
      this.Disable();
    else
      this.Enable();
  }

  public void UpdateInputSystem(bool forceTouch)
  {
    if (!this.IsMaster || !this.IsMouseOver)
      return;
    this.preMouseOver = false;
  }

  public void CardControllerEnabled(CardController controller)
  {
    if (!this.mouseOver || !((Object) controller == (Object) this.controller))
      return;
    controller.Hover(this.IsMaster ? this.entity : this.master.entity);
  }

  public void CheckHover()
  {
    if (!this.IsMouseOver || this.preMouseOver)
      return;
    this.Hover();
    this.preMouseOver = true;
  }

  public void CheckUnHover()
  {
    if (this.IsMouseOver || !this.preMouseOver)
      return;
    this.UnHover();
    this.preMouseOver = false;
  }

  public void Enable()
  {
    this.graphicRaycaster.enabled = true;
    global::Events.InvokeUpdateInputSystem(false);
  }

  public void Disable()
  {
    this.graphicRaycaster.enabled = false;
    this.ForceUnHover();
    global::Events.InvokeUpdateInputSystem(false);
  }

  public void SetHoverable(bool value)
  {
    this.hoverable = value;
    if (this.hoverable)
      return;
    this.ForceUnHover();
  }

  public void Hover()
  {
    if (!this.CanHover)
      return;
    this.controller.Hover(this.entity);
    this.onHover?.Invoke();
  }

  public void UnHover()
  {
    if (!this.enabled || !(bool) (Object) this.controller || !this.controller.enabled || !((Object) this.controller.hoverEntity == (Object) this.entity))
      return;
    this.controller.UnHover(this.entity);
    this.onUnHover?.Invoke();
  }

  public void ForceUnHover()
  {
    this.mouseOver = false;
    this.preMouseOver = false;
    this.UnHover();
  }

  public void OnPointerEnter(PointerEventData eventData)
  {
    if (this.mouseOver || !this.hoverable || !MonoBehaviourSingleton<Cursor3d>.instance.usingMouse && (bool) (Object) UINavigationSystem.ActiveNavigationLayer && !UINavigationSystem.ActiveNavigationLayer.forceHover)
      return;
    this.mouseOver = true;
    if (this.IsMaster)
    {
      this.CheckHover();
    }
    else
    {
      ++this.master.childMouseOverCount;
      this.master.CheckHover();
    }
  }

  public void OnPointerExit(PointerEventData eventData)
  {
    if (!this.mouseOver)
      return;
    this.mouseOver = false;
    if (this.IsMaster)
      return;
    this.master.childMouseOverCount = Mathf.Max(0, this.master.childMouseOverCount - 1);
  }

  public void OnPointerAfterExit(PointerEventData eventData)
  {
    if (this.IsMaster)
      this.CheckUnHover();
    else
      this.master.CheckUnHover();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardIconStack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class CardIconStack : CardContainer
{
  public Dictionary<Entity, RectTransform> activeIcons = new Dictionary<Entity, RectTransform>();
  public Queue<RectTransform> iconPool = new Queue<RectTransform>();
  public int iconCount;
  [SerializeField]
  public Vector3 randomAngleAmount = new Vector3(0.0f, 0.0f, 2f);
  public bool insertAtBottom;
  [SerializeField]
  public RectTransform iconPrefab;

  public override void SetSize(int size, float cardScale)
  {
    base.SetSize(size, cardScale);
    this.holder.sizeDelta = GameManager.CARD_SIZE * cardScale;
  }

  public override Vector3 GetChildPosition(Entity child)
  {
    this.IndexOf(child);
    return new Vector3(0.0f, 0.0f, 0.0f);
  }

  public override void Add(Entity entity)
  {
    if (this.insertAtBottom)
    {
      entity.transform.SetParent((Transform) this.holder);
      entity.AddTo((CardContainer) this);
      this.entities.Insert(0, entity);
      entity.transform.SetSiblingIndex(0);
      ++this.Count;
      this.CardAdded(entity);
      for (int index = 1; index < this.Count; ++index)
        this.TweenChildPosition(this.entities[index]);
    }
    else
      base.Add(entity);
  }

  public override Vector3 GetChildRotation(Entity child) => Vector3.zero;

  public override void CardAdded(Entity entity)
  {
    base.CardAdded(entity);
    entity.enabled = false;
    if ((Object) entity.flipper != (Object) null && !entity.flipper.flipped)
      entity.flipper.FlipDown();
    this.AddIcon(entity);
  }

  public override void CardRemoved(Entity entity) => this.RemoveIcon(entity);

  public void AddIcon(Entity entity)
  {
    this.activeIcons[entity] = this.GetIcon();
    this.UpdateIconPositions();
  }

  public void RemoveIcon(Entity entity)
  {
    RectTransform activeIcon = this.activeIcons[entity];
    if (!((Object) activeIcon != (Object) null))
      return;
    this.PoolIcon(activeIcon);
    this.activeIcons.Remove(entity);
  }

  public void UpdateIconPositions()
  {
    int count = this.Count;
    for (int index = 0; index < count; ++index)
    {
      Entity key = this[index];
      RectTransform activeIcon = this.activeIcons[key];
      activeIcon.SetSiblingIndex(index);
      activeIcon.localPosition = this.gap * (float) index;
      activeIcon.localEulerAngles = Vector3.Scale(key.random3, this.randomAngleAmount);
    }
  }

  public void PoolIcon(RectTransform icon)
  {
    icon.gameObject.SetActive(false);
    this.iconPool.Enqueue(icon);
  }

  public RectTransform GetIcon()
  {
    RectTransform icon;
    if (this.iconPool.Count > 0)
    {
      icon = this.iconPool.Dequeue();
    }
    else
    {
      icon = Object.Instantiate<RectTransform>(this.iconPrefab, this.transform);
      icon.name = string.Format("Icon {0}", (object) this.iconCount++);
    }
    icon.gameObject.SetActive(true);
    return icon;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardIdleAnimation
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using UnityEngine;

public class CardIdleAnimation : MonoBehaviourCacheTransform, IPoolable
{
  public CardAnimationProfile profile;
  public Entity _entity;
  public bool alwaysOn;
  public float strength = 1f;
  public float speedFactor = 1f;
  public float fadeInTime = 0.4f;
  public float fadeInStrength = 1f;
  public float speed;
  public float offset;
  public Vector3 basePosition;
  public Vector3 baseRotation;
  public Vector3 baseScale;
  [SerializeField]
  public CardAnimationProfile setProfile;
  [SerializeField]
  public CardIdleAnimation.Action currentAction;

  public Entity entity
  {
    get => this._entity;
    set
    {
      this._entity = value;
      this.SetProfile(this._entity.data.idleAnimationProfile);
    }
  }

  public void Awake()
  {
    this.basePosition = this.transform.localPosition;
    this.baseRotation = this.transform.localEulerAngles;
    this.baseScale = this.transform.localScale;
    this.speed = 1f / PettyRandom.Range(2f, 3f);
  }

  public void OnEnable()
  {
    if (!this.alwaysOn)
      return;
    this.StartAction(CardIdleAnimation.Action.FadeIn);
  }

  public void OnDisable()
  {
    if (this.alwaysOn)
      return;
    this.fadeInStrength = 0.0f;
    this.enabled = false;
    this.currentAction = CardIdleAnimation.Action.None;
  }

  public void Update()
  {
    if ((bool) (Object) this.profile && (double) this.strength != 0.0)
    {
      float time = (float) (((double) Time.timeSinceLevelLoad * (double) this.speed * (double) this.speedFactor + (double) this.offset) % 1.0);
      if (this.profile.doMoveX || this.profile.doMoveY || this.profile.doMoveZ)
        this.transform.localPosition = new Vector3(this.basePosition.x + (this.profile.doMoveX ? this.profile.moveX.Evaluate(time) * this.profile.moveAmount.x * this.strength * this.fadeInStrength : 0.0f), this.basePosition.y + (this.profile.doMoveY ? this.profile.moveY.Evaluate(time) * this.profile.moveAmount.y * this.strength * this.fadeInStrength : 0.0f), this.basePosition.z + (this.profile.doMoveZ ? this.profile.moveZ.Evaluate(time) * this.profile.moveAmount.z * this.strength * this.fadeInStrength : 0.0f));
      if (this.profile.doRotateX || this.profile.doRotateY || this.profile.doRotateZ)
        this.transform.localEulerAngles = new Vector3(this.baseRotation.x + (this.profile.doRotateX ? this.profile.rotateX.Evaluate(time) * this.profile.rotateAmount.x * this.strength * this.fadeInStrength : 0.0f), this.baseRotation.y + (this.profile.doRotateY ? this.profile.rotateY.Evaluate(time) * this.profile.rotateAmount.y * this.strength * this.fadeInStrength : 0.0f), this.baseRotation.z + (this.profile.doRotateZ ? this.profile.rotateZ.Evaluate(time) * this.profile.rotateAmount.z * this.strength * this.fadeInStrength : 0.0f));
      if (this.profile.doScaleX || this.profile.doScaleY || this.profile.doScaleZ)
        this.transform.localScale = new Vector3(this.baseScale.x + (this.profile.doScaleX ? this.profile.ScaleX.Evaluate(time) * this.profile.scaleAmount.x * this.strength * this.fadeInStrength : 0.0f), this.baseScale.y + (this.profile.doScaleY ? this.profile.ScaleY.Evaluate(time) * this.profile.scaleAmount.y * this.strength * this.fadeInStrength : 0.0f), this.baseScale.z + (this.profile.doScaleZ ? this.profile.ScaleZ.Evaluate(time) * this.profile.scaleAmount.z * this.strength * this.fadeInStrength : 0.0f));
    }
    if ((bool) (Object) this.setProfile)
    {
      this.SetProfile(this.setProfile);
      this.setProfile = (CardAnimationProfile) null;
    }
    if (this.currentAction == CardIdleAnimation.Action.None)
      return;
    this.RunAction();
  }

  public void SetSpeed(float speed, float speedFactor, float offset)
  {
    this.speed = speed;
    this.speedFactor = speedFactor;
    this.offset = offset;
  }

  public void SetProfile(CardAnimationProfile profile)
  {
    this.profile = profile;
    this.speed = ((bool) (Object) this._entity ? (float) (1.0 / (2.0 + (double) Mathf.Abs(this._entity.random3.x))) : 0.5f) * profile.speedFactor;
    this.offset = (bool) (Object) this._entity ? Mathf.Abs(this._entity.random3.y) : 0.0f;
  }

  public void StartAction(CardIdleAnimation.Action action)
  {
    this.currentAction = action;
    switch (action)
    {
      case CardIdleAnimation.Action.FadeIn:
        this.enabled = true;
        this.fadeInStrength = 0.0f;
        break;
      case CardIdleAnimation.Action.FadeOut:
        if (this.gameObject.activeInHierarchy)
          break;
        this.enabled = false;
        this.fadeInStrength = 0.0f;
        this.StartAction(CardIdleAnimation.Action.None);
        break;
    }
  }

  public void RunAction()
  {
    switch (this.currentAction)
    {
      case CardIdleAnimation.Action.FadeIn:
        if ((double) this.fadeInStrength < 1.0)
        {
          this.fadeInStrength += 1f / this.fadeInTime * Time.deltaTime;
          break;
        }
        this.fadeInStrength = 1f;
        this.StartAction(CardIdleAnimation.Action.None);
        break;
      case CardIdleAnimation.Action.FadeOut:
        if ((double) this.fadeInStrength > 0.0)
        {
          this.fadeInStrength -= 1f / this.fadeInTime * Time.deltaTime;
          break;
        }
        this.enabled = false;
        this.fadeInStrength = 0.0f;
        this.StartAction(CardIdleAnimation.Action.None);
        break;
    }
  }

  public void FadeIn() => this.StartAction(CardIdleAnimation.Action.FadeIn);

  public void FadeOut() => this.StartAction(CardIdleAnimation.Action.FadeOut);

  public void Clear()
  {
    this.fadeInStrength = 0.0f;
    this.currentAction = CardIdleAnimation.Action.None;
  }

  public void OnGetFromPool()
  {
  }

  public void OnReturnToPool() => this.Clear();

  public enum Action
  {
    None,
    FadeIn,
    FadeOut,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardInspector
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class CardInspector : MonoBehaviour
{
  [SerializeField]
  public bool animatePopUps = true;
  [SerializeField]
  public bool ignoreTimeScale;
  [SerializeField]
  public bool showHiddenKeywords = true;
  [SerializeField]
  [ShowIf("showHiddenKeywords")]
  public KeywordData injuredKeyword;
  [Header("Pop up panels")]
  [SerializeField]
  public RectTransform leftPopGroup;
  [SerializeField]
  public RectTransform leftOverflowPopGroup;
  [SerializeField]
  public RectTransform rightPopGroup;
  [SerializeField]
  public RectTransform rightOverflowPopGroup;
  [SerializeField]
  public RectTransform bottomPopGroup;
  [SerializeField]
  public RectTransform[] overflowOrder;
  [SerializeField]
  public CardPopUpPanel popUpPrefab;
  [SerializeField]
  public CardTooltip cardTooltipPrefab;
  [SerializeField]
  public LayoutGroup[] layoutsToFix;
  public readonly List<Tooltip> popups = new List<Tooltip>();
  public readonly List<KeywordData> currentPoppedKeywords = new List<KeywordData>();

  public void CreatePopups(Entity inspect)
  {
    Events.InvokeEntityHover(inspect);
    this.CreateIconPopups(inspect.display.healthLayoutGroup, (Transform) this.leftPopGroup);
    this.CreateIconPopups(inspect.display.damageLayoutGroup, (Transform) this.rightPopGroup);
    this.CreateIconPopups(inspect.display.counterLayoutGroup, (Transform) this.bottomPopGroup);
    if (inspect.display is Card display)
    {
      foreach (CardData mentionedCard in display.mentionedCards)
        this.Popup(mentionedCard, (Transform) this.rightPopGroup);
      foreach (KeywordData keyword in display.keywords)
        this.Popup(keyword, (Transform) this.rightPopGroup);
    }
    if (this.showHiddenKeywords)
    {
      foreach (StatusEffectData statusEffect in inspect.statusEffects)
      {
        foreach (KeywordData hiddenKeyword in statusEffect.hiddenKeywords)
          this.Popup(hiddenKeyword, (Transform) this.rightPopGroup);
      }
      List<CardData.StatusEffectStacks> injuries = inspect.data.injuries;
      if (injuries != null && injuries.Count > 0)
        this.Popup(this.injuredKeyword, (Transform) this.rightPopGroup);
    }
    CoroutineManager.Start(this.FixLayoutsAfterFrame());
  }

  public void CreateIconPopups(RectTransform iconLayoutGroup, Transform popGroup)
  {
    foreach (CardPopUpTarget componentsInChild in iconLayoutGroup.GetComponentsInChildren<CardPopUpTarget>())
    {
      foreach (KeywordData keyword in componentsInChild.keywords)
        this.Popup(keyword, popGroup);
    }
  }

  public void ClearPopups()
  {
    foreach (Component popup in this.popups)
      popup.gameObject.Destroy();
    this.popups.Clear();
    this.currentPoppedKeywords.Clear();
  }

  public IEnumerator FixLayoutsAfterFrame()
  {
    yield return (object) null;
    yield return (object) this.FixLayouts();
  }

  public IEnumerator FixLayouts()
  {
    CardInspector cardInspector = this;
    yield return (object) null;
    foreach (LayoutGroup layoutGroup in cardInspector.layoutsToFix)
    {
      switch (layoutGroup)
      {
        case VerticalLayoutGroup layout1:
          layout1.FitToChildren();
          break;
        case HorizontalLayoutGroup layout2:
          layout2.FitToChildren();
          break;
      }
    }
    if (cardInspector.CheckOverflow(cardInspector.bottomPopGroup))
      yield return (object) cardInspector.FixLayouts();
  }

  public bool CheckOverflow(params RectTransform[] checkCollide)
  {
    for (int index = 0; index < this.overflowOrder.Length - 1; ++index)
    {
      RectTransform target = this.overflowOrder[index];
      if (target.childCount > 0 && CardInspector.CheckCollide(target, (IEnumerable<RectTransform>) checkCollide))
      {
        Transform child = target.GetChild(target.childCount - 1);
        child.SetParent((Transform) this.overflowOrder[index + 1]);
        child.SetSiblingIndex(0);
        return true;
      }
    }
    return false;
  }

  public static bool CheckCollide(RectTransform target, IEnumerable<RectTransform> checks)
  {
    foreach (RectTransform check in checks)
    {
      if (CardInspector.RectOverlap(target, check))
      {
        Debug.Log((object) string.Format("[{0}] Overlaps [{1}]", (object) target.rect, (object) check.rect));
        return true;
      }
    }
    return false;
  }

  public static bool RectOverlap(RectTransform a, RectTransform b)
  {
    Vector3 position1 = a.position;
    Vector2 size1 = a.rect.size;
    Vector2 pivot1 = a.pivot;
    Rect rect = new Rect(position1.x - pivot1.x * size1.x, position1.y - pivot1.y * size1.y, size1.x, size1.y);
    Vector3 position2 = b.position;
    Vector2 size2 = b.rect.size;
    Vector2 pivot2 = b.pivot;
    Rect other = new Rect(position2.x - pivot2.x * size2.x, position2.y - pivot2.y * size2.y, size2.x, size2.y);
    return rect.Overlaps(other);
  }

  public CardPopUpPanel Popup(KeywordData keyword, Transform group)
  {
    if (this.currentPoppedKeywords.Contains(keyword))
      return (CardPopUpPanel) null;
    CardPopUpPanel panel = Object.Instantiate<CardPopUpPanel>(this.popUpPrefab, group);
    panel.gameObject.name = keyword.name;
    panel.animate = this.animatePopUps;
    panel.ignoreTimeScale = this.ignoreTimeScale;
    panel.Set(keyword);
    Events.InvokePopupPanelCreated(keyword, panel);
    this.currentPoppedKeywords.Add(keyword);
    this.popups.Add((Tooltip) panel);
    foreach (KeywordData keyword1 in Text.GetKeywords(keyword.body))
    {
      CardPopUpPanel cardPopUpPanel = this.Popup(keyword1, group);
      panel.children.AddIfNotNull<Tooltip>((Tooltip) cardPopUpPanel);
    }
    return panel;
  }

  public CardTooltip Popup(CardData cardData, Transform group)
  {
    CardTooltip cardTooltip = Object.Instantiate<CardTooltip>(this.cardTooltipPrefab, group);
    cardTooltip.gameObject.name = cardData.name;
    cardTooltip.animate = this.animatePopUps;
    cardTooltip.ignoreTimeScale = this.ignoreTimeScale;
    cardTooltip.Set(cardData);
    this.popups.Add((Tooltip) cardTooltip);
    foreach (KeywordData keyword in cardTooltip.keywords)
    {
      CardPopUpPanel cardPopUpPanel = this.Popup(keyword, group);
      cardTooltip.children.AddIfNotNull<Tooltip>((Tooltip) cardPopUpPanel);
    }
    return cardTooltip;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardLane
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CardLane : CardContainer
{
  [Range(-1f, 1f)]
  public int dir = -1;

  public override void SetSize(int size, float cardScale)
  {
    base.SetSize(size, cardScale);
    this.holder.sizeDelta = new Vector2((float) ((double) (3f * cardScale) * (double) size + (double) this.gap.x * (double) (size - 1)), 4.5f * cardScale);
  }

  public override Vector3 GetChildPosition(Entity child)
  {
    int num1 = this.IndexOf(child);
    float num2 = 3f * this.CardScale;
    double cardScale = (double) this.CardScale;
    float num3 = this.holder.sizeDelta.x * 0.5f;
    float num4 = (float) ((double) this.max * (double) num2 * 0.5 + (double) (this.max - 1) * (double) this.gap.x * 0.5);
    float num5 = (float) ((double) -this.max * (double) this.gap.y * 0.5);
    float num6 = (float) ((double) -this.max * (double) this.gap.z * 0.5);
    int num7 = (double) num4 > (double) num3 ? 1 : 0;
    if (num7 != 0)
      num4 = num3;
    float num8 = num4 * 2f;
    float num9 = num4 * (float) this.dir + num2 * 0.5f * (float) -this.dir;
    float num10 = this.gap.x;
    if (num7 != 0)
      num10 = (num8 - num2 * (float) this.Count) / (float) Mathf.Max(1, this.Count - 1);
    float num11 = (num2 + num10) * (float) -this.dir;
    double x = (double) num9 + (double) num11 * (double) num1;
    float num12 = num5 + this.gap.y * (float) num1;
    float num13 = num6 + this.gap.z * (float) num1;
    double y = (double) num12;
    double z = (double) num13;
    return new Vector3((float) x, (float) y, (float) z);
  }

  public void SetDirection(int dir) => this.dir = dir;
}
﻿// Decompiled with JetBrains decompiler
// Type: CardManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Pool;
using UnityEngine.ResourceManagement.AsyncOperations;

public class CardManager : MonoBehaviourSingleton<CardManager>
{
  public static readonly Dictionary<string, GameObject> cardIcons = new Dictionary<string, GameObject>();
  public static readonly Vector3 startPos = new Vector3(-99f, -99f, 0.0f);
  public static readonly Dictionary<string, ObjectPool<Card>> cardPools = new Dictionary<string, ObjectPool<Card>>();
  public static bool init = false;
  public AsyncOperationHandle<IList<GameObject>> cardIconLoadHandle;
  public const float SCALE = 1f;
  public const float HOVER_SCALE = 1f;

  public IEnumerator Start()
  {
    CardManager cardManager = this;
    Transform t = cardManager.transform;
    foreach (CardType cardType in AddressableLoader.GetGroup<CardType>("CardType"))
    {
      AsyncOperationHandle<GameObject> handle = Addressables.LoadAssetAsync<GameObject>((object) cardType.prefabRef);
      yield return (object) handle;
      GameObject prefab = handle.Result;
      for (int index = 0; index < 3; ++index)
        CardManager.cardPools.Add(string.Format("{0}{1}", (object) cardType.name, (object) index), new ObjectPool<Card>((Func<Card>) (() => UnityEngine.Object.Instantiate<GameObject>(prefab, CardManager.startPos, (Quaternion) quaternion.identity, t).GetComponent<Card>()), (Action<Card>) (card =>
        {
          card.OnGetFromPool();
          card.entity.OnGetFromPool();
          card.transform.position = CardManager.startPos;
          card.transform.localRotation = Quaternion.identity;
          card.transform.localScale = Vector3.one;
          card.gameObject.SetActive(true);
        }), closure_3 ?? (closure_3 = (Action<Card>) (card =>
        {
          card.transform.SetParent(t);
          card.OnReturnToPool();
          card.entity.OnReturnToPool();
          Events.InvokeCardPooled(card);
          card.gameObject.SetActive(false);
        })), (Action<Card>) (card => UnityEngine.Object.Destroy((UnityEngine.Object) card.gameObject)), false, maxSize: 20));
      handle = new AsyncOperationHandle<GameObject>();
    }
    cardManager.LoadCardIcons();
    CardManager.init = true;
  }

  public void LoadCardIcons()
  {
    if (this.cardIconLoadHandle.IsValid())
      Addressables.Release<IList<GameObject>>(this.cardIconLoadHandle);
    Debug.Log((object) "CardManager Loading Card Icon Prefabs");
    this.cardIconLoadHandle = Addressables.LoadAssetsAsync<GameObject>((object) "CardIcons", (Action<GameObject>) null);
    foreach (GameObject gameObject in (IEnumerable<GameObject>) this.cardIconLoadHandle.WaitForCompletion())
    {
      if ((UnityEngine.Object) gameObject != (UnityEngine.Object) null)
      {
        StatusIcon component = gameObject.GetComponent<StatusIcon>();
        if (component != null)
          CardManager.cardIcons[component.type] = gameObject;
      }
    }
    Debug.Log((object) string.Format("{0} icons loaded", (object) CardManager.cardIcons.Count));
  }

  public static Card Get(
    CardData data,
    CardController controller,
    Character owner,
    bool inPlay,
    bool isPlayerCard)
  {
    int frameLevel = isPlayerCard ? CardFramesSystem.GetFrameLevel(data.name) : 0;
    Card card = CardManager.cardPools[string.Format("{0}{1}", (object) data.cardType.name, (object) frameLevel)].Get();
    card.frameLevel = frameLevel;
    card.entity.data = data;
    card.entity.inPlay = inPlay;
    card.hover.controller = controller;
    card.entity.owner = owner;
    card.frameSetter.Load(frameLevel);
    Events.InvokeEntityCreated(card.entity);
    return card;
  }

  public static bool ReturnToPool(Entity entity)
  {
    if (entity.display is Card display)
      return CardManager.ReturnToPool(entity, display);
    UnityEngine.Object.Destroy((UnityEngine.Object) entity.gameObject);
    return false;
  }

  public static bool ReturnToPool(Card card) => CardManager.ReturnToPool(card.entity, card);

  public static bool ReturnToPool(Entity entity, Card card)
  {
    if (GameManager.End || entity.inCardPool)
      return false;
    if (!entity.returnToPool)
      UnityEngine.Object.Destroy((UnityEngine.Object) entity.gameObject);
    CardManager.cardPools[string.Format("{0}{1}", (object) entity.data.cardType.name, (object) card.frameLevel)].Release(card);
    return true;
  }

  public static StatusIcon NewStatusIcon(string type, Transform iconParent)
  {
    StatusIcon statusIcon = (StatusIcon) null;
    if (CardManager.cardIcons.ContainsKey(type))
      statusIcon = UnityEngine.Object.Instantiate<GameObject>(CardManager.cardIcons[type], iconParent).GetComponent<StatusIcon>();
    return statusIcon;
  }

  public static void ReturnToPoolNextFrame(Card card) => MonoBehaviourSingleton<CardManager>.instance.StartCoroutine(CardManager.ReturnToPoolNextFrameRoutine(card));

  public static IEnumerator ReturnToPoolNextFrameRoutine(Card card)
  {
    yield return (object) null;
    CardManager.ReturnToPool(card);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardOrganizer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class CardOrganizer : MonoBehaviour
{
  [SerializeField]
  public Canvas canvas;
  [SerializeField]
  public CardContainer cardHolder;
  [SerializeField]
  public CardController cardController;
  [Header("Card Grid")]
  [SerializeField]
  public int gridColumns = 8;
  [SerializeField]
  public Vector2 gridSpacing;
  public Vector2 startPos;
  public bool inspecting;

  public static string filePath => Application.streamingAssetsPath + "/Cards.json";

  public Vector2 GetCellSize() => GameManager.CARD_SIZE + this.gridSpacing;

  public void OnEnable()
  {
    global::Events.OnInspect += new UnityAction<Entity>(this.InspectStart);
    global::Events.OnInspectEnd += new UnityAction<Entity>(this.InspectEnd);
  }

  public void OnDisable()
  {
    global::Events.OnInspect -= new UnityAction<Entity>(this.InspectStart);
    global::Events.OnInspectEnd -= new UnityAction<Entity>(this.InspectEnd);
  }

  public void InspectStart(Entity entity) => this.inspecting = true;

  public void InspectEnd(Entity entity) => this.inspecting = false;

  public IEnumerator Start()
  {
    if (GameManager.Ready)
    {
      yield return (object) AddressableLoader.LoadGroup("CardData");
      List<CardData> cardDataList = AddressableLoader.GetGroup<CardData>("CardData");
      int num1 = Mathf.RoundToInt((float) (cardDataList.Count / this.gridColumns));
      int num2 = Mathf.Min(this.gridColumns, cardDataList.Count);
      float num3 = (float) ((double) num2 * 3.0 + (double) (num2 - 1) * (double) this.gridSpacing.x);
      float num4 = (float) ((double) num1 * 4.5 + (double) (num1 - 1) * (double) this.gridSpacing.y);
      this.startPos.x = (float) (-(double) num3 / 2.0 + 1.5);
      this.startPos.y = (float) ((double) num4 / 2.0 - 2.25);
      yield return (object) this.Load();
      List<Entity> list = this.cardHolder.GetComponentsInChildren<Entity>().ToList<Entity>();
      Routine.Clump clump = new Routine.Clump();
      for (int index = 0; index < cardDataList.Count; ++index)
      {
        CardData cardData = cardDataList[index];
        if (!list.Exists((Predicate<Entity>) (a => a.data.name == cardData.name)))
        {
          Vector2 cardPos = this.GetCardPos(index);
          clump.Add(this.CreateCard(cardData, cardPos));
        }
      }
      yield return (object) clump.WaitForEnd();
      Transition.End();
      cardDataList = (List<CardData>) null;
    }
  }

  public Vector2 GetCardPos(int cardIndex)
  {
    int num = Mathf.FloorToInt((float) (cardIndex / this.gridColumns));
    return new Vector2(this.startPos.x + (float) (cardIndex % this.gridColumns) * (3f + this.gridSpacing.x), this.startPos.y - (float) num * (4.5f + this.gridSpacing.y));
  }

  public IEnumerator CreateCard(CardData cardData, Vector2 pos)
  {
    Card card = CardManager.Get(cardData.Clone(), this.cardController, (Character) null, false, true);
    card.entity.returnToPool = false;
    yield return (object) card.UpdateData(false);
    card.entity.transform.localPosition = pos.WithZ(0.0f);
    this.cardHolder.Add(card.entity);
  }

  public void OnDestroy()
  {
    if (!GameManager.Ready)
      return;
    this.Save();
  }

  public void Update()
  {
    if (this.inspecting)
      return;
    if (Input.GetKeyDown(KeyCode.D) && Input.GetKey(KeyCode.LeftControl))
    {
      Entity hover = this.GetHover();
      if ((bool) (UnityEngine.Object) hover)
      {
        this.cardController.UnHover();
        Routine routine = new Routine(this.CreateCard(hover.data, (Vector2) (hover.transform.localPosition + new Vector3(0.25f, -0.25f))));
        Debug.Log((object) ("Duplicating [" + hover.name + "]"));
      }
      else
        Debug.Log((object) "Nothing to duplicate!");
    }
    if (!Input.GetKeyDown(KeyCode.Delete))
      return;
    Entity target = this.GetHover();
    if ((bool) (UnityEngine.Object) target)
    {
      if (((IEnumerable<Entity>) this.cardHolder.GetComponentsInChildren<Entity>(true)).Count<Entity>((Func<Entity, bool>) (a => a.data.name == target.data.name)) > 1)
      {
        Debug.Log((object) ("Deleting [" + target.name + "]"));
        this.cardController.UnHover();
        UnityEngine.Object.Destroy((UnityEngine.Object) target.gameObject);
      }
      else
      {
        Debug.Log((object) ("Cannot delete [" + target.name + "]"));
        target.wobbler?.WobbleRandom();
      }
    }
    else
      Debug.Log((object) "Nothing to delete!");
  }

  public Entity GetHover() => this.cardController.dragging ?? this.cardController.hoverEntity;

  public void Save()
  {
    Debug.Log((object) string.Format("[{0}] SAVING DATA", (object) this));
    File.WriteAllText(CardOrganizer.filePath, JsonUtility.ToJson((object) new CardOrganizer.Data(this.cardHolder.GetComponentsInChildren<Entity>(true))));
    Debug.Log((object) "Done!");
  }

  public IEnumerator Load()
  {
    CardOrganizer cardOrganizer = this;
    Debug.Log((object) string.Format("[{0}] LOADING DATA", (object) cardOrganizer));
    if (File.Exists(CardOrganizer.filePath))
    {
      CardOrganizer.Data data = JsonUtility.FromJson<CardOrganizer.Data>(File.ReadAllText(CardOrganizer.filePath));
      Routine.Clump clump = new Routine.Clump();
      foreach (CardOrganizer.Data.Card card in data.cards)
      {
        CardData result;
        if (AddressableLoader.TryGet<CardData>("CardData", card.cardDataName, out result))
          clump.Add(cardOrganizer.CreateCard(result, new Vector2(card.posX, card.posY)));
      }
      yield return (object) clump.WaitForEnd();
    }
    else
      Debug.Log((object) ("[" + CardOrganizer.filePath + "] does not exist..."));
  }

  [Serializable]
  public class Data
  {
    public CardOrganizer.Data.Card[] cards;

    public Data(params Entity[] entities)
    {
      List<CardOrganizer.Data.Card> cardList = new List<CardOrganizer.Data.Card>();
      foreach (Entity entity in entities)
        cardList.Add(new CardOrganizer.Data.Card(entity));
      this.cards = cardList.ToArray();
    }

    [Serializable]
    public class Card
    {
      public string cardDataName;
      public float posX;
      public float posY;

      public Card(Entity entity)
      {
        this.cardDataName = entity.data.name;
        this.posX = entity.transform.localPosition.x;
        this.posY = entity.transform.localPosition.y;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardPlane
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class CardPlane : CardContainer
{
  public readonly Dictionary<Entity, Vector3> positions = new Dictionary<Entity, Vector3>();

  public override float CardScale => 1f;

  public override void Add(Entity entity)
  {
    base.Add(entity);
    this.StorePosition(entity);
  }

  public override void Insert(int index, Entity entity)
  {
    base.Insert(index, entity);
    this.StorePosition(entity);
  }

  public override void Remove(Entity entity)
  {
    base.Remove(entity);
    this.FreePosition(entity);
  }

  public override Vector3 GetChildPosition(Entity child) => !this.positions.ContainsKey(child) ? Vector3.zero : this.positions[child];

  public void StorePosition(Entity entity) => this.positions[entity] = entity.transform.localPosition;

  public void FreePosition(Entity entity) => this.positions.Remove(entity);
}
﻿// Decompiled with JetBrains decompiler
// Type: CardPocket
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class CardPocket : CardContainer
{
  [SerializeField]
  public Transform slideInPosition;
  [SerializeField]
  public AnimationCurve slideCurve;
  [SerializeField]
  public float slideDuration = 0.5f;
  [SerializeField]
  public float slideDelay = 0.5f;
  [SerializeField]
  public Vector3 randomAngleAmount = new Vector3(0.0f, 0.0f, 1f);
  [SerializeField]
  public CardPocketInteraction interaction;
  [SerializeField]
  public CardContainer[] skipAnimationFromContainers;
  public readonly Dictionary<Entity, CardPocket.PositionHandler> positions = new Dictionary<Entity, CardPocket.PositionHandler>();

  public override void AssignController(CardController controller)
  {
    base.AssignController(controller);
    this.GetComponentInChildren<ToggleBasedOnCardController>(true)?.AssignCardController(controller);
  }

  public void Update()
  {
    foreach (KeyValuePair<Entity, CardPocket.PositionHandler> position in this.positions)
    {
      if (!position.Value.IsFinished)
        position.Value.Update(Time.deltaTime);
    }
  }

  public override void SetSize(int size, float cardScale)
  {
    base.SetSize(size, cardScale);
    this.holder.sizeDelta = GameManager.CARD_SIZE * cardScale;
  }

  public override Vector3 GetChildPosition(Entity child) => this.positions[child].GetPosition();

  public override Vector3 GetChildRotation(Entity child) => Vector3.Scale(child.random3, this.randomAngleAmount);

  public Vector3 GetFinalChildPosition(Entity child)
  {
    int num1 = this.IndexOf(child);
    float num2 = 0.0f;
    float num3 = 0.0f;
    double x = 0.0 + (double) this.gap.x * (double) num1;
    float num4 = num2 + this.gap.y * (float) num1;
    float num5 = num3 + this.gap.z * (float) num1;
    double y = (double) num4;
    double z = (double) num5;
    return new Vector3((float) x, (float) y, (float) z);
  }

  public override void Hover()
  {
    base.Hover();
    if (!(bool) (Object) this.interaction)
      return;
    this.interaction.Hover();
  }

  public override void UnHover()
  {
    base.UnHover();
    if (!(bool) (Object) this.interaction)
      return;
    this.interaction.UnHover();
  }

  public override void CardAdded(Entity entity)
  {
    base.CardAdded(entity);
    entity.enabled = false;
    if ((bool) (Object) entity.uINavigationItem)
    {
      entity.uINavigationItem.isSelectable = false;
      entity.uINavigationItem.enabled = false;
    }
    if ((bool) (Object) entity.flipper)
      entity.flipper.FlipDown();
    CardPocket.PositionHandler positionHandler = new CardPocket.PositionHandler(this, entity, this.slideInPosition.localPosition, this.GetFinalChildPosition(entity), this.slideCurve, this.slideDuration, this.slideDelay);
    this.positions.Add(entity, positionHandler);
    if (entity.preContainers == null || entity.preContainers.Length == 0)
    {
      positionHandler.Skip();
    }
    else
    {
      foreach (CardContainer preContainer in entity.preContainers)
      {
        if (this.skipAnimationFromContainers.Contains<CardContainer>(preContainer))
        {
          positionHandler.Skip();
          break;
        }
      }
    }
  }

  public override void CardRemoved(Entity entity)
  {
    base.CardRemoved(entity);
    if ((bool) (Object) entity.uINavigationItem)
    {
      entity.uINavigationItem.isSelectable = true;
      entity.uINavigationItem.enabled = true;
    }
    this.positions.Remove(entity);
  }

  public class PositionHandler
  {
    public readonly CardPocket pocket;
    public readonly Entity entity;
    public readonly Vector3 startPosition;
    public readonly Vector3 positionChange;
    public readonly AnimationCurve curve;
    public readonly float duration;
    public float delay;
    public float t;

    public bool IsFinished => (double) this.t >= (double) this.duration;

    public PositionHandler(
      CardPocket pocket,
      Entity entity,
      Vector3 fromPosition,
      Vector3 toPosition,
      AnimationCurve slideCurve,
      float slideDuration,
      float slideDelay)
    {
      this.pocket = pocket;
      this.entity = entity;
      this.startPosition = fromPosition;
      this.positionChange = toPosition - fromPosition;
      this.curve = slideCurve;
      this.duration = slideDuration;
      this.delay = slideDelay;
      this.t = 0.0f;
    }

    public Vector3 GetPosition() => this.startPosition + this.positionChange * this.curve.Evaluate(this.t / this.duration);

    public void Skip()
    {
      this.t = this.duration;
      this.Update(0.0f);
    }

    public void Update(float delta)
    {
      if ((double) this.delay > 0.0)
      {
        this.delay -= delta;
        if ((double) this.delay > 0.0)
          return;
        Events.InvokeEntityEnterPocket(this.entity, this.pocket);
      }
      else
      {
        this.t += delta;
        this.entity.transform.localPosition = this.GetPosition();
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardPocketInteraction
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class CardPocketInteraction : MonoBehaviour
{
  [SerializeField]
  public UINavigationItem nav;
  [SerializeField]
  public GameObject root;
  [SerializeField]
  public UnityEvent onClick;
  [SerializeField]
  public UnityEvent onPress;
  [SerializeField]
  public UnityEvent onRelease;
  [SerializeField]
  public UnityEvent onHover;
  [SerializeField]
  public UnityEvent onUnHover;
  public bool interactable = true;
  [SerializeField]
  public bool defaultAnimations = true;
  public bool hover;
  public bool hovered;
  public bool press;
  public bool pressed;

  public void SetInteractable(bool value) => this.interactable = value;

  public bool IsInteractable
  {
    get
    {
      if (!this.interactable)
        return false;
      return (Object) this.nav == (Object) null || this.nav.enabled;
    }
  }

  public void Update()
  {
    if (this.hover)
    {
      if (!this.hovered)
      {
        this.hovered = true;
        if (this.defaultAnimations)
        {
          LeanTween.cancel(this.root);
          LeanTween.scale(this.root, Vector3.one * 1.1f, 0.2f).setEase(LeanTweenType.easeOutBack);
        }
        this.onHover?.Invoke();
      }
    }
    else if (this.hovered)
    {
      this.hovered = false;
      if (this.defaultAnimations)
      {
        LeanTween.cancel(this.root);
        LeanTween.scale(this.root, Vector3.one, 0.1f).setEase(LeanTweenType.easeOutQuart);
      }
      this.onUnHover?.Invoke();
    }
    if (this.press)
    {
      if (!this.pressed)
      {
        this.pressed = true;
        if (this.defaultAnimations)
        {
          LeanTween.cancel(this.root);
          LeanTween.scale(this.root, Vector3.one, 0.1f).setEase(LeanTweenType.easeOutQuart);
        }
        this.onPress?.Invoke();
      }
    }
    else if (this.pressed)
    {
      this.pressed = false;
      this.onRelease?.Invoke();
      if (this.hover)
      {
        if (this.defaultAnimations)
        {
          LeanTween.cancel(this.root);
          LeanTween.scale(this.root, Vector3.one * 1.1f, 0.1f).setEase(LeanTweenType.easeOutQuart);
        }
        this.onClick?.Invoke();
      }
      else
      {
        if (this.defaultAnimations)
        {
          LeanTween.cancel(this.root);
          LeanTween.scale(this.root, Vector3.one, 0.1f).setEase(LeanTweenType.easeOutQuart);
        }
        if ((Object) MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem == (Object) this.nav)
          this.Hover();
      }
    }
    if (!this.press)
    {
      if (!this.hover || !InputSystem.IsSelectPressed())
        return;
      this.Press();
    }
    else
    {
      if (InputSystem.IsSelectHeld())
        return;
      this.Release();
    }
  }

  public void Hover() => this.hover = this.IsInteractable;

  public void UnHover() => this.hover = false;

  public void Press() => this.press = this.IsInteractable;

  public void Release() => this.press = false;
}
﻿// Decompiled with JetBrains decompiler
// Type: CardPocketSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UI;

public class CardPocketSequence : UISequence
{
  [Header("Custom Values")]
  public CardController cardController;
  public Image background;
  public CardContainer container;
  [SerializeField]
  public Vector2 shuffleDelay = new Vector2(0.01f, 0.02f);
  [SerializeField]
  public GameObject backButton;
  [Header("Initial card position/rotation offset")]
  [SerializeField]
  public Vector3 randomOffset;
  [SerializeField]
  public Vector3 randomRotation;
  public readonly List<CardPocketSequence.Card> cards = new List<CardPocketSequence.Card>();

  public void AddCards(CardContainer from)
  {
    foreach (Entity entity in from)
      this.cards.Add(new CardPocketSequence.Card(entity));
    foreach (CardPocketSequence.Card card in (IEnumerable<CardPocketSequence.Card>) this.cards.OrderBy<CardPocketSequence.Card, float>((Func<CardPocketSequence.Card, float>) (_ => PettyRandom.Range(0.0f, 1f))))
    {
      card.Take();
      CardHover hover = card.entity.display?.hover;
      if (hover != null)
        hover.controller = this.cardController;
      this.container.Add(card.entity);
    }
  }

  public IEnumerator ReturnCards()
  {
    foreach (CardPocketSequence.Card card in this.cards)
    {
      card.Return();
      card.ReturnTween();
    }
    this.cards.Clear();
    yield break;
  }

  public override IEnumerator Run()
  {
    CardPocketSequence cardPocketSequence = this;
    cardPocketSequence.cardController.enabled = false;
    cardPocketSequence.gameObject.SetActive(true);
    Routine.Clump clump = new Routine.Clump();
    foreach (Entity entity in (IEnumerable<Entity>) cardPocketSequence.container.OrderBy<Entity, float>((Func<Entity, float>) (_ => PettyRandom.Range(0.0f, 1f))))
    {
      clump.Add(cardPocketSequence.MoveCard(entity));
      yield return (object) Sequences.Wait(cardPocketSequence.shuffleDelay.PettyRandom());
    }
    cardPocketSequence.backButton.SetActive(true);
    yield return (object) clump.WaitForEnd();
    cardPocketSequence.cardController.enabled = true;
    yield return (object) new WaitUntil(new Func<bool>(cardPocketSequence.\u003CRun\u003Eb__10_0));
    cardPocketSequence.promptEnd = false;
    cardPocketSequence.cardController.UnHover();
    cardPocketSequence.backButton.SetActive(false);
    cardPocketSequence.cardController.enabled = false;
    foreach (CardPocketSequence.Card card in cardPocketSequence.cards)
      card.Reset();
    yield return (object) cardPocketSequence.ReturnCards();
    cardPocketSequence.gameObject.SetActive(false);
  }

  public IEnumerator MoveCard(Entity entity)
  {
    this.Move(entity, true);
    yield return (object) Sequences.Wait(PettyRandom.Range(0.01f, 0.3f));
    entity.flipper.FlipUp();
    entity.enabled = true;
  }

  public void FixPosition(Entity entity) => this.Move(entity, false);

  public void Move(Entity entity, bool includeRandomness)
  {
    if (!((UnityEngine.Object) entity.transform.parent == (UnityEngine.Object) this.container.holder))
      return;
    Vector3 childPosition = this.container.GetChildPosition(entity);
    Vector3 childRotation = this.container.GetChildRotation(entity);
    Vector3 childScale = this.container.GetChildScale(entity);
    if (includeRandomness)
    {
      Vector3 a = PettyRandom.Vector3();
      childPosition += Vector3.Scale(a, this.randomOffset);
      childRotation += Vector3.Scale(a, this.randomRotation);
    }
    LeanTween.cancel(entity.gameObject);
    LeanTween.moveLocal(entity.gameObject, childPosition, this.container.movementDurRand.PettyRandom()).setEase(this.container.movementEase);
    LeanTween.rotateLocal(entity.gameObject, childRotation, this.container.movementDurRand.PettyRandom()).setEase(this.container.movementEase);
    LeanTween.scale(entity.gameObject, childScale, this.container.scaleDurRand.PettyRandom()).setEase(this.container.scaleEase);
  }

  public void OpenFrom(Transform transform) => SfxSystem.OneShot((double) transform.position.x > 0.0 ? "event:/sfx/inventory/deck_opening_right" : "event:/sfx/inventory/deck_opening_left");

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__10_0() => this.promptEnd;

  public class Card
  {
    public readonly Entity entity;
    public CardContainer[] preContainers;
    public CardController preController;
    public bool preInPlay;
    public bool preEnabled;

    public Card(Entity entity) => this.entity = entity;

    public void Reset()
    {
      this.entity.inPlay = this.preInPlay;
      this.entity.enabled = this.preEnabled;
    }

    public void Take()
    {
      this.preContainers = this.entity.containers;
      this.preController = this.entity.display?.hover?.controller;
      this.preInPlay = this.entity.inPlay;
      this.preEnabled = this.entity.enabled;
      this.entity.RemoveFromContainers();
      this.entity.inPlay = false;
    }

    public void Return()
    {
      this.entity.RemoveFromContainers();
      this.entity.enabled = this.preEnabled;
      foreach (CardContainer preContainer in this.preContainers)
        preContainer.Add(this.entity);
      CardHover hover = this.entity.display?.hover;
      if (hover != null)
        hover.controller = this.preController;
      this.entity.inPlay = this.preInPlay;
    }

    public void ReturnTween() => this.entity.TweenToContainer();

    public override string ToString() => this.entity.name;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardPoolReturner
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class CardPoolReturner : MonoBehaviour
{
  [SerializeField]
  public string[] scenesToIgnore;

  public void OnEnable() => global::Events.OnSceneUnload += new UnityAction<Scene>(this.SceneUnload);

  public void OnDisable() => global::Events.OnSceneUnload -= new UnityAction<Scene>(this.SceneUnload);

  public void SceneUnload(Scene scene)
  {
    if (this.scenesToIgnore.Contains<string>(scene.name))
      return;
    StopWatch.Start();
    int num = 0;
    foreach (GameObject rootGameObject in scene.GetRootGameObjects())
    {
      foreach (Card componentsInChild in rootGameObject.GetComponentsInChildren<Card>())
      {
        if (componentsInChild.entity.returnToPool && CardManager.ReturnToPool(componentsInChild))
          ++num;
      }
    }
    Debug.Log((object) string.Format("[{0}] Cards returned to pool from [{1}] ({2}ms)", (object) num, (object) scene.name, (object) StopWatch.Stop()));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardPopUp
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.UI;

public class CardPopUp : MonoBehaviourRectSingleton<CardPopUp>
{
  [SerializeField]
  public Canvas canvas;
  [SerializeField]
  public RectTransform bounds;
  [SerializeField]
  public RectTransform boundingBox;
  [SerializeField]
  public RectTransform layout;
  [SerializeField]
  public ContentSizeFitter sizeFitter;
  [SerializeField]
  public float gap = 0.05f;
  [SerializeField]
  [Range(-1f, 1f)]
  public float posX = 1f;
  [SerializeField]
  [Range(-1f, 1f)]
  public float posY;
  [Header("Tooltip Prefabs")]
  [SerializeField]
  public AssetReferenceGameObject keywordTooltipPrefab;
  [SerializeField]
  public int keywordTooltipInitialPool = 1;
  [SerializeField]
  public AssetReferenceGameObject cardTooltipPrefab;
  [SerializeField]
  public int cardTooltipInitialPool = 1;
  public readonly Dictionary<string, Tooltip> activePanels = new Dictionary<string, Tooltip>();
  public RectTransform follow;
  public readonly List<Tooltip> pool = new List<Tooltip>();
  public bool ignoreTimeScale;

  public void Awake()
  {
    for (int index = 0; index < this.keywordTooltipInitialPool; ++index)
      this.PoolPanel((Tooltip) this.keywordTooltipPrefab.InstantiateAsync((Transform) this.layout).WaitForCompletion().GetComponent<CardPopUpPanel>());
    for (int index = 0; index < this.cardTooltipInitialPool; ++index)
      this.PoolPanel((Tooltip) this.cardTooltipPrefab.InstantiateAsync((Transform) this.layout).WaitForCompletion().GetComponent<CardTooltip>());
  }

  public void Update()
  {
    if ((bool) (UnityEngine.Object) this.follow)
    {
      Vector2 vector2_1 = this.follow.sizeDelta * (Vector2) this.follow.lossyScale * this.follow.pivot;
      Vector2 vector2_2 = this.layout.sizeDelta * (Vector2) this.layout.lossyScale * this.layout.pivot;
      this.rectTransform.position = this.ApplyLimits(this.follow.position + new Vector3((vector2_1.x + vector2_2.x + this.gap) * this.posX, (vector2_1.y + vector2_2.y + this.gap) * this.posY, 0.0f));
    }
    else
      CardPopUp.Clear();
  }

  public static void SetCanvasLayer(string layerName, int orderInLayer)
  {
    MonoBehaviourRectSingleton<CardPopUp>.instance.canvas.sortingLayerName = layerName;
    MonoBehaviourRectSingleton<CardPopUp>.instance.canvas.sortingOrder = orderInLayer;
  }

  public static void SetIgnoreTimeScale(bool ignore) => MonoBehaviourRectSingleton<CardPopUp>.instance.ignoreTimeScale = ignore;

  public static void Reset()
  {
    CardPopUp.SetCanvasLayer("PopUp", 0);
    CardPopUp.SetIgnoreTimeScale(false);
  }

  public static void AssignToCard(Card card)
  {
    MonoBehaviourRectSingleton<CardPopUp>.instance.follow = card.canvas.transform as RectTransform;
    MonoBehaviourRectSingleton<CardPopUp>.instance.posX = 1f;
    MonoBehaviourRectSingleton<CardPopUp>.instance.posY = 0.0f;
  }

  public static void AssignTo(RectTransform rect, float posX, float posY)
  {
    MonoBehaviourRectSingleton<CardPopUp>.instance.follow = rect;
    MonoBehaviourRectSingleton<CardPopUp>.instance.posX = posX;
    MonoBehaviourRectSingleton<CardPopUp>.instance.posY = posY;
  }

  public static CardPopUpPanel AddPanel(string name, string title, string body)
  {
    if (MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.ContainsKey(name))
      return (CardPopUpPanel) null;
    CardPopUpPanel panel = MonoBehaviourRectSingleton<CardPopUp>.instance.GetPanel<CardPopUpPanel>();
    panel.gameObject.name = name;
    panel.ignoreTimeScale = MonoBehaviourRectSingleton<CardPopUp>.instance.ignoreTimeScale;
    panel.Set(title, body);
    MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.Add(name, (Tooltip) panel);
    foreach (KeywordData keyword in Text.GetKeywords(body))
    {
      CardPopUpPanel cardPopUpPanel = CardPopUp.AddPanel(keyword);
      panel.children.AddIfNotNull<Tooltip>((Tooltip) cardPopUpPanel);
    }
    return panel;
  }

  public static CardPopUpPanel AddPanel(KeywordData keyword, string forceBody = null)
  {
    if (MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.ContainsKey(keyword.name))
      return (CardPopUpPanel) null;
    CardPopUpPanel panel = MonoBehaviourRectSingleton<CardPopUp>.instance.GetPanel<CardPopUpPanel>();
    panel.gameObject.name = keyword.name;
    panel.ignoreTimeScale = MonoBehaviourRectSingleton<CardPopUp>.instance.ignoreTimeScale;
    panel.Set(keyword, forceBody);
    Events.InvokePopupPanelCreated(keyword, panel);
    MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.Add(keyword.name, (Tooltip) panel);
    foreach (KeywordData keyword1 in Text.GetKeywords(keyword.body))
    {
      CardPopUpPanel cardPopUpPanel = CardPopUp.AddPanel(keyword1);
      panel.children.AddIfNotNull<Tooltip>((Tooltip) cardPopUpPanel);
    }
    return panel;
  }

  public static CardTooltip AddPanel(CardData cardData)
  {
    CardTooltip panel = MonoBehaviourRectSingleton<CardPopUp>.instance.GetPanel<CardTooltip>();
    panel.gameObject.name = cardData.name;
    panel.Set(cardData);
    MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.Add(cardData.name, (Tooltip) panel);
    foreach (KeywordData keyword in panel.keywords)
    {
      CardPopUpPanel cardPopUpPanel = CardPopUp.AddPanel(keyword);
      panel.children.AddIfNotNull<Tooltip>((Tooltip) cardPopUpPanel);
    }
    return panel;
  }

  public static void RemovePanel(string name)
  {
    Tooltip panel;
    if (MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.TryGetValue(name, out panel))
    {
      foreach (UnityEngine.Object child in panel.children)
        CardPopUp.RemovePanel(child.name);
      MonoBehaviourRectSingleton<CardPopUp>.instance.PoolPanel(panel);
      MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.Remove(name);
    }
    else
      Debug.Log((object) ("Panel [" + name + "] does not exist (CardPopUp)"));
    MonoBehaviourRectSingleton<CardPopUp>.instance.StartFixLayouts();
  }

  public T GetPanel<T>() where T : Tooltip
  {
    Tooltip panel = this.pool.FirstOrDefault<Tooltip>((Func<Tooltip, bool>) (a => a is T));
    if (!(bool) (UnityEngine.Object) panel)
      panel = !(typeof (T) == typeof (CardTooltip)) ? (Tooltip) this.keywordTooltipPrefab.InstantiateAsync((Transform) this.layout).WaitForCompletion().GetComponent<CardPopUpPanel>() : (Tooltip) this.cardTooltipPrefab.InstantiateAsync((Transform) this.layout).WaitForCompletion().GetComponent<CardTooltip>();
    else
      this.pool.RemoveAt(this.pool.IndexOf(panel));
    panel.gameObject.SetActive(true);
    panel.transform.SetAsLastSibling();
    return panel as T;
  }

  public void PoolPanel(Tooltip panel)
  {
    panel.children.Clear();
    panel.gameObject.SetActive(false);
    this.pool.Add(panel);
  }

  public static void Clear()
  {
    foreach (KeyValuePair<string, Tooltip> activePanel in MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels)
      activePanel.Value.gameObject.Destroy();
    MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.Clear();
    MonoBehaviourRectSingleton<CardPopUp>.instance.follow = (RectTransform) null;
  }

  public void StartFixLayouts()
  {
    if (!(bool) (UnityEngine.Object) this.sizeFitter)
      return;
    this.StopAllCoroutines();
    this.StartCoroutine(this.FixLayouts());
  }

  public IEnumerator FixLayouts()
  {
    yield return (object) null;
    this.sizeFitter.enabled = false;
    yield return (object) null;
    this.sizeFitter.enabled = true;
  }

  public Vector3 ApplyLimits(Vector3 pos)
  {
    Vector2 max = Vector2.Scale(Vector2.Scale(this.bounds.sizeDelta, this.bounds.pivot) - Vector2.Scale(this.boundingBox.sizeDelta, this.boundingBox.pivot), (Vector2) this.rectTransform.lossyScale);
    return ((Vector2) pos).Clamp(-max, max).WithZ(pos.z);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardPopUpPanel
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class CardPopUpPanel : Tooltip
{
  [Header("Text")]
  [SerializeField]
  public float titleSize = 0.3f;
  [SerializeField]
  public float iconSize = 0.275f;
  [SerializeField]
  public float bodySize = 0.25f;
  [SerializeField]
  public float noteSize = 0.21f;
  [SerializeField]
  public TextMeshProUGUI textElement;
  [SerializeField]
  public Fitter fitter;
  public static readonly Color defaultTitleColor = new Color(1f, 0.7921569f, 0.3411765f, 1f);
  public static readonly Color defaultBodyColor = Color.white;
  public static readonly Color defaultNoteColor = new Color(0.65f, 0.65f, 0.65f);
  public string titleText;
  public string bodyText;
  public string noteText;

  public string text => this.textElement.text;

  public void Set(
    string iconName,
    string iconTintHex,
    string title,
    Color titleColour,
    string body,
    Color bodyColour,
    Sprite panelSprite,
    Color panelColor)
  {
    this.SetRoutine(iconName, iconTintHex, title, titleColour, body, bodyColour, "", Color.white, panelSprite, panelColor);
  }

  public void Set(
    string iconName,
    string iconTintHex,
    string title,
    Color titleColour,
    string body,
    Color bodyColour)
  {
    this.SetRoutine(iconName, iconTintHex, title, titleColour, body, bodyColour, "", Color.white, this.defaultPanelSprite, this.defaultPanelColor);
  }

  public void Set(string title, string body) => this.Set(title, CardPopUpPanel.defaultTitleColor, body, CardPopUpPanel.defaultBodyColor);

  public void Set(string title, Color titleColour, string body, Color bodyColour) => this.SetRoutine("", "", title, titleColour, body, bodyColour, "", Color.white, this.defaultPanelSprite, this.defaultPanelColor);

  public void Set(string text, Color textColour) => this.SetRoutine("", "", "", Color.white, text, textColour, "", Color.white, this.defaultPanelSprite, this.defaultPanelColor);

  public void Set(KeywordData keyword, string forceBody = null)
  {
    string title = keyword.HasTitle ? keyword.title : "";
    string body = forceBody ?? keyword.body;
    this.SetRoutine(keyword.iconName, keyword.iconTintHex, title, keyword.titleColour, body, keyword.bodyColour, keyword.note, keyword.noteColour, keyword.panelSprite, keyword.panelColor);
  }

  public void SetRoutine(
    string iconName,
    string iconTintHex,
    string title,
    Color titleColour,
    string body,
    Color bodyColour,
    string note,
    Color noteColour,
    Sprite panelSprite,
    Color panelColor)
  {
    this.SetTitle(title, titleColour, iconName, iconTintHex);
    this.SetBody(body, bodyColour);
    this.SetNote(note, noteColour);
    this.BuildTextElement();
    this.panel.sprite = (bool) (UnityEngine.Object) panelSprite ? panelSprite : this.defaultPanelSprite;
    this.panel.color = (bool) (UnityEngine.Object) panelSprite ? panelColor : this.defaultPanelColor;
    if ((bool) (UnityEngine.Object) this.fitter)
    {
      LeanTween.cancel(this.gameObject);
      this.transform.localScale = Vector3.one;
      this.canvasGroup.alpha = 0.0f;
      this.fitter.Fit(new System.Action(((Tooltip) this).Ping));
    }
    else
      this.Ping();
  }

  public void SetTitle(string title, Color titleColour, string iconName, string iconTintHex)
  {
    this.titleText = "";
    if (!title.IsNullOrWhitespace())
      this.titleText += string.Format("<size={0}><#{1}>{2}", (object) this.titleSize, (object) titleColour.ToHexRGBA(), (object) Text.Process(title));
    if (iconName.IsNullOrWhitespace())
      return;
    if (!iconTintHex.IsNullOrWhitespace())
      this.titleText += string.Format("<size={0}><sprite name=\"{1}\" color=#{2}></size>", (object) this.iconSize, (object) iconName, (object) iconTintHex);
    else
      this.titleText += string.Format("<size={0}><sprite name=\"{1}\"></size>", (object) this.iconSize, (object) iconName);
  }

  public void AddToTitle(string text, bool newline = true)
  {
    if (this.titleText.IsNullOrWhitespace())
    {
      this.SetTitle(text, CardPopUpPanel.defaultTitleColor, "", "");
    }
    else
    {
      if (newline)
        this.titleText += "\n";
      this.titleText += Text.Process(text);
    }
  }

  public void SetBody(string body, Color bodyColour)
  {
    this.bodyText = "";
    if (body.IsNullOrWhitespace())
      return;
    this.bodyText = string.Format("<size={0}><#{1}>{2}", (object) this.bodySize, (object) bodyColour.ToHexRGBA(), (object) Text.Process(body));
  }

  public void AddToBody(string text, bool newline = true)
  {
    if (this.bodyText.IsNullOrWhitespace())
    {
      this.SetBody(text, CardPopUpPanel.defaultBodyColor);
    }
    else
    {
      if (newline)
        this.bodyText += "\n";
      this.bodyText += Text.Process(text);
    }
  }

  public void SetNote(string note, Color noteColour)
  {
    this.noteText = "";
    if (note.IsNullOrWhitespace())
      return;
    this.noteText = string.Format("<size={0}><#{1}>{2}", (object) this.noteSize, (object) noteColour.ToHexRGBA(), (object) note);
  }

  public void AddToNote(string text, bool newline = true)
  {
    if (this.noteText.IsNullOrWhitespace())
    {
      this.SetNote(text, CardPopUpPanel.defaultNoteColor);
    }
    else
    {
      if (newline)
        this.noteText += "\n";
      this.noteText += text;
    }
  }

  public void BuildTextElement()
  {
    string titleText = this.titleText;
    if (!this.bodyText.IsNullOrWhitespace())
    {
      if (!titleText.IsNullOrWhitespace())
        titleText += "<line-height=96%>\n</line-height>";
      titleText += this.bodyText;
    }
    if (!this.noteText.IsNullOrWhitespace())
    {
      if (!titleText.IsNullOrWhitespace())
        titleText += "<line-height=96%>\n</line-height>";
      titleText += this.noteText;
    }
    this.textElement.text = titleText;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardPopUpTarget
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections.Generic;
using UnityEngine;

public class CardPopUpTarget : MonoBehaviourRect
{
  [SerializeField]
  [ReadOnly]
  public bool popped;
  [SerializeField]
  public Card card;
  [HideIf("IsCard")]
  public KeywordData[] keywords;
  [SerializeField]
  [HideIf("IsCard")]
  [Range(-1f, 1f)]
  public float posX = 1f;
  [SerializeField]
  [HideIf("IsCard")]
  [Range(-1f, 1f)]
  public float posY;
  public readonly HashSet<string> current = new HashSet<string>();

  public bool IsCard => (Object) this.card != (Object) null;

  public void Pop()
  {
    if (this.IsCard)
    {
      CardPopUp.AssignToCard(this.card);
      if (this.card.mentionedCards != null)
      {
        foreach (CardData mentionedCard in this.card.mentionedCards)
        {
          if (this.current.Add(mentionedCard.name))
            CardPopUp.AddPanel(mentionedCard);
        }
      }
      if (this.card.keywords != null)
      {
        foreach (KeywordData keyword in this.card.keywords)
        {
          if (this.current.Add(keyword.name))
            CardPopUp.AddPanel(keyword);
        }
      }
    }
    else if (this.keywords.Length != 0)
    {
      CardPopUp.AssignTo(this.rectTransform, this.posX, this.posY);
      foreach (KeywordData keyword in this.keywords)
      {
        if (this.current.Add(keyword.name))
          CardPopUp.AddPanel(keyword);
      }
    }
    this.popped = true;
  }

  public void UnPop()
  {
    if (this.current.Count > 0)
    {
      foreach (string name in this.current)
        CardPopUp.RemovePanel(name);
      this.current.Clear();
    }
    this.popped = false;
  }

  public void OnDisable() => this.current.Clear();
}
﻿// Decompiled with JetBrains decompiler
// Type: CardRotator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;

[RequireComponent(typeof (Card))]
public class CardRotator : MonoBehaviour
{
  [SerializeField]
  [Required(null)]
  [OnValueChanged("DataChanged")]
  public CardData data;
  [SerializeField]
  public float rotateSpeed;
  [SerializeField]
  public Vector3 rotateAmount;
  [SerializeField]
  public bool startFlippedDown = true;
  public Entity entity;
  public Card card;
  public float internalRotateSpeed = 1f;
  public float t;

  public IEnumerator Start()
  {
    CardRotator cardRotator = this;
    cardRotator.entity = cardRotator.GetComponent<Entity>();
    cardRotator.entity.data = cardRotator.data;
    cardRotator.card = cardRotator.GetComponent<Card>();
    yield return (object) cardRotator.card.UpdateData(false);
    if (cardRotator.startFlippedDown)
    {
      cardRotator.entity.flipper.FlipDownInstant();
      cardRotator.internalRotateSpeed = 0.0f;
      cardRotator.transform.localEulerAngles = Vector3.zero;
    }
  }

  public void Update()
  {
    this.t += Time.deltaTime * this.rotateSpeed * this.internalRotateSpeed;
    this.transform.localEulerAngles = this.rotateAmount * Mathf.Sin(this.t);
  }

  public void DataChanged()
  {
    if (Application.isEditor)
      return;
    this.StartCoroutine(this.UpdateData(this.data));
  }

  public IEnumerator UpdateData(CardData data)
  {
    this.entity.data = data;
    yield return (object) this.entity.ClearStatuses();
    this.card.ClearStatusIcons();
    yield return (object) this.card.UpdateData(false);
  }

  [Button(null, EButtonEnableMode.Always)]
  public void Flip()
  {
    if (this.entity.flipper.flipped)
      this.StartCoroutine(this.FlipUpRoutine());
    else
      this.StartCoroutine(this.FlipDownRoutine());
  }

  public IEnumerator FlipUpRoutine()
  {
    CardRotator cardRotator = this;
    cardRotator.entity.flipper.FlipUp();
    float dur = cardRotator.entity.flipper.flipUpDurationRand.y;
    yield return (object) Sequences.Wait(dur / 2f);
    cardRotator.entity.wobbler.WobbleRandom();
    yield return (object) Sequences.Wait(dur / 2f);
    LeanTween.value(0.0f, 1f, 1f).setOnUpdate(new Action<float>(cardRotator.\u003CFlipUpRoutine\u003Eb__13_0));
  }

  public IEnumerator FlipDownRoutine()
  {
    CardRotator cardRotator = this;
    cardRotator.entity.flipper.FlipDown();
    float dur = cardRotator.entity.flipper.flipUpDurationRand.y;
    yield return (object) Sequences.Wait(dur / 2f);
    cardRotator.entity.wobbler.WobbleRandom();
    yield return (object) Sequences.Wait(dur / 2f);
    LeanTween.value(1f, 0.0f, 1f).setOnUpdate(new Action<float>(cardRotator.\u003CFlipDownRoutine\u003Eb__14_0));
  }

  [CompilerGenerated]
  public void \u003CFlipUpRoutine\u003Eb__13_0(float a) => this.internalRotateSpeed = a;

  [CompilerGenerated]
  public void \u003CFlipDownRoutine\u003Eb__14_0(float a) => this.internalRotateSpeed = a;
}
﻿// Decompiled with JetBrains decompiler
// Type: CardSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[Serializable]
public class CardSaveData : ILoadable<CardData>
{
  public ulong id;
  public string name;
  public string title;
  public int hp;
  public int damage;
  public int counter;
  public Vector3 random3;
  public CardUpgradeSaveData[] upgrades;
  public StatusEffectSaveData[] attackEffects;
  public StatusEffectSaveData[] startWithEffects;
  public TraitSaveData[] traits;
  public StatusEffectSaveData[] injuries;
  public Dictionary<string, object> customData;

  public CardSaveData()
  {
  }

  public CardSaveData(CardData cardData)
  {
    this.id = cardData.id;
    this.name = cardData.name;
    this.title = cardData.forceTitle;
    this.hp = cardData.hp;
    this.damage = cardData.damage;
    this.counter = cardData.counter;
    this.random3 = cardData.random3;
    this.upgrades = cardData.upgrades.SaveArray<CardUpgradeData, CardUpgradeSaveData>();
    this.attackEffects = cardData.attackEffects.SaveArray<CardData.StatusEffectStacks, StatusEffectSaveData>();
    this.startWithEffects = cardData.startWithEffects.SaveArray<CardData.StatusEffectStacks, StatusEffectSaveData>();
    this.traits = cardData.traits.SaveArray<CardData.TraitStacks, TraitSaveData>();
    this.injuries = cardData.injuries.SaveArray<CardData.StatusEffectStacks, StatusEffectSaveData>();
    this.customData = cardData.customData;
    if (!(bool) (UnityEngine.Object) cardData.original || !((UnityEngine.Object) cardData.cardType != (UnityEngine.Object) cardData.original.cardType))
      return;
    if (this.customData == null)
      this.customData = new Dictionary<string, object>();
    this.customData["OverrideCardType"] = (object) cardData.cardType.name;
  }

  public CardData Peek() => AddressableLoader.Get<CardData>("CardData", this.name);

  public CardData Load() => this.Load(true);

  public CardData Load(bool keepId)
  {
    CardData cardData1 = AddressableLoader.Get<CardData>("CardData", this.name);
    int num = !(bool) (UnityEngine.Object) cardData1 ? 1 : 0;
    CardData cardData2 = num != 0 ? (keepId ? MissingCardSystem.GetCloneWithId(this.name, this.random3, this.id) : MissingCardSystem.GetClone(this.name)) : (keepId ? cardData1.Clone(this.random3, this.id, false) : cardData1.Clone(this.random3, false));
    cardData2.customData = this.customData;
    cardData2.attackEffects = this.attackEffects.LoadArray<CardData.StatusEffectStacks, StatusEffectSaveData>();
    cardData2.startWithEffects = this.startWithEffects.LoadArray<CardData.StatusEffectStacks, StatusEffectSaveData>();
    cardData2.traits = this.traits.LoadList<CardData.TraitStacks, TraitSaveData>();
    cardData2.injuries = this.injuries.LoadList<CardData.StatusEffectStacks, StatusEffectSaveData>();
    if (num == 0)
      cardData2.forceTitle = this.title;
    cardData2.hp = this.hp;
    cardData2.damage = this.damage;
    cardData2.counter = this.counter;
    if (cardData2.customData != null && cardData2.customData.ContainsKey("OverrideCardType"))
      cardData2.cardType = AddressableLoader.Get<CardType>("CardType", cardData2.customData.Get<string>("OverrideCardType"));
    CardUpgradeSaveData[] upgrades = this.upgrades;
    if (upgrades != null && upgrades.Length > 0)
    {
      cardData2.upgrades = this.upgrades.LoadList<CardUpgradeData, CardUpgradeSaveData>();
      if (cardData2.upgrades.Any<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => a.becomesTargetedCard)))
      {
        cardData2.hasAttack = true;
        if (cardData2.playType == Card.PlayType.None)
          cardData2.playType = Card.PlayType.Play;
        cardData2.needsTarget = true;
      }
    }
    return cardData2;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScript
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public abstract class CardScript : ScriptableObject
{
  public virtual void Run(CardData target)
  {
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptAddAttackEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Add Attack Effect", menuName = "Card Scripts/Add Attack Effect")]
public class CardScriptAddAttackEffect : CardScript
{
  [SerializeField]
  public StatusEffectData effect;
  [SerializeField]
  public Vector2Int countRange;

  public override void Run(CardData target) => target.attackEffects = target.attackEffects.With<CardData.StatusEffectStacks>(new CardData.StatusEffectStacks(this.effect, this.countRange.Random()));
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptAddPassiveEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Add Passive Effect", menuName = "Card Scripts/Add Passive Effect")]
public class CardScriptAddPassiveEffect : CardScript
{
  [SerializeField]
  public StatusEffectData effect;
  [SerializeField]
  public Vector2Int countRange;

  public override void Run(CardData target) => target.startWithEffects = target.startWithEffects.With<CardData.StatusEffectStacks>(new CardData.StatusEffectStacks(this.effect, this.countRange.Random()));
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptAddRandomBoost
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Add Random Boost", menuName = "Card Scripts/Add Boost")]
public class CardScriptAddRandomBoost : CardScript
{
  [SerializeField]
  public Vector2Int boostRange;

  public override void Run(CardData target)
  {
    int num = this.boostRange.Random();
    if (num == 0)
      return;
    foreach (CardData.StatusEffectStacks attackEffect in target.attackEffects)
      attackEffect.count = Mathf.Max(1, attackEffect.count + num);
    foreach (CardData.StatusEffectStacks startWithEffect in target.startWithEffects)
    {
      if (!startWithEffect.data.visible)
        startWithEffect.count = Mathf.Max(1, startWithEffect.count + num);
    }
    foreach (CardData.TraitStacks trait in target.traits)
    {
      if (trait.data.keyword.canStack)
        trait.count = Mathf.Max(1, trait.count + num);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptAddRandomCounter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Add Random Counter", menuName = "Card Scripts/Add Counter")]
public class CardScriptAddRandomCounter : CardScript
{
  [SerializeField]
  public Vector2Int counterRange;

  public override void Run(CardData target)
  {
    if (target.counter < 1)
      return;
    target.counter += this.counterRange.Random();
    target.counter = Mathf.Max(1, target.counter);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptAddRandomDamage
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Add Random Damage", menuName = "Card Scripts/Add Damage")]
public class CardScriptAddRandomDamage : CardScript
{
  [SerializeField]
  public Vector2Int damageRange;

  public override void Run(CardData target)
  {
    if (!target.hasAttack)
      return;
    target.damage += this.damageRange.Random();
    target.damage = Mathf.Max(0, target.damage);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptAddRandomHealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Add Random Health", menuName = "Card Scripts/Add Health")]
public class CardScriptAddRandomHealth : CardScript
{
  [SerializeField]
  public Vector2Int healthRange;

  public override void Run(CardData target)
  {
    if (!target.hasHealth)
      return;
    target.hp += this.healthRange.Random();
    target.hp = Mathf.Max(1, target.hp);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptAddTrait
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Add Trait", menuName = "Card Scripts/Add Trait")]
public class CardScriptAddTrait : CardScript
{
  [SerializeField]
  public TraitData trait;
  [SerializeField]
  public Vector2Int countRange;
  [SerializeField]
  public bool @override = true;

  public override void Run(CardData target)
  {
    for (int index = target.traits.Count - 1; index >= 0; --index)
    {
      CardData.TraitStacks trait = target.traits[index];
      if (this.trait.overrides.Contains<TraitData>(trait.data))
      {
        if (this.@override)
        {
          target.traits.RemoveAt(index);
          Debug.Log((object) ("[" + this.trait.name + "] overrides [" + trait.data.name + "]"));
        }
        else
        {
          Debug.Log((object) ("Cannot add [" + this.trait.name + "] because of [" + trait.data.name + "]"));
          return;
        }
      }
    }
    target.traits.Add(new CardData.TraitStacks()
    {
      data = this.trait,
      count = this.countRange.Random()
    });
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptBecomeBasicItemCard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Become Basic Item Card", menuName = "Card Scripts/Become Basic Item Card")]
public class CardScriptBecomeBasicItemCard : CardScript
{
  public override void Run(CardData target)
  {
    target.playType = Card.PlayType.Play;
    target.needsTarget = true;
    target.canPlayOnBoard = true;
    target.canPlayOnHand = false;
    target.canPlayOnFriendly = true;
    target.canPlayOnEnemy = true;
    target.playOnSlot = false;
    target.defaultPlayPosition = CardData.PlayPosition.None;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptBoostAttackEffectsOrAttack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Boost Attack Effects Or Damage", menuName = "Card Scripts/Boost Attack Effects Or Damage")]
public class CardScriptBoostAttackEffectsOrAttack : CardScript
{
  [SerializeField]
  public Vector2Int range = new Vector2Int(2, 2);
  [SerializeField]
  public float reducePerCharm = 0.5f;

  public override void Run(CardData target)
  {
    int f1 = this.range.Random();
    List<CardUpgradeData> upgrades = target.upgrades;
    if (upgrades != null && upgrades.Count > 0)
    {
      float f2 = (float) f1;
      foreach (CardUpgradeData upgrade in target.upgrades)
      {
        if (upgrade.type == CardUpgradeData.Type.Charm)
        {
          f2 -= this.reducePerCharm;
          if ((double) f2 <= 0.0)
            break;
        }
      }
      f1 = Mathf.CeilToInt(f2);
    }
    if (f1 <= 0)
      return;
    int num = (int) Mathf.Sign((float) f1);
    if (target.attackEffects.Length != 0)
    {
      while (f1 > 0)
      {
        foreach (CardData.StatusEffectStacks attackEffect in target.attackEffects)
        {
          attackEffect.count = Mathf.Max(1, attackEffect.count + num);
          if (--f1 <= 0)
            break;
        }
      }
    }
    else
    {
      if (!target.hasAttack)
        return;
      target.damage += f1;
      target.damage = Mathf.Max(0, target.damage);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptGiveUpgrade
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Give Upgrade", menuName = "Card Scripts/Give Upgrade")]
public class CardScriptGiveUpgrade : CardScript
{
  [SerializeField]
  public CardUpgradeData upgradeData;

  public override void Run(CardData target)
  {
    if (!((Object) this.upgradeData != (Object) null))
      return;
    this.upgradeData.Clone().Assign(target);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptLeader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Leader", menuName = "Card Scripts/Leader")]
public class CardScriptLeader : CardScript
{
  [SerializeField]
  public CharacterType[] characterTypeOptions;
  [SerializeField]
  public LeaderProfileData[] leaderProfileOptions;

  public override void Run(CardData target)
  {
    CharacterType type = this.characterTypeOptions.RandomItem<CharacterType>();
    CharacterData characterData = new CharacterData()
    {
      race = type.race,
      gender = type.gender
    };
    LeaderProfileData leaderProfileData = this.leaderProfileOptions.RandomItem<LeaderProfileData>();
    leaderProfileData.Apply(type);
    target.backgroundSprite = leaderProfileData.GetRandomBackground();
    characterData.Randomize(type);
    leaderProfileData.UnApply(type);
    target.forceTitle = characterData.title;
    target.SetCustomData("CharacterData", (object) characterData);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptModifyCharmSlots
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Modify Upgrade Slots", menuName = "Card Scripts/Modify Upgrade Slots")]
public class CardScriptModifyCharmSlots : CardScript
{
  [SerializeField]
  public int addCharmSlots;

  public override void Run(CardData target)
  {
    if (this.addCharmSlots == 0)
      return;
    object obj;
    if (target.customData != null && target.customData.TryGetValue("extraCharmSlots", out obj) && obj is int num)
      target.customData["extraCharmSlots"] = (object) (num + this.addCharmSlots);
    else
      target.SetCustomData("extraCharmSlots", (object) this.addCharmSlots);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptMultiplyHealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Multiply Health", menuName = "Card Scripts/Multiply Health")]
public class CardScriptMultiplyHealth : CardScript
{
  [SerializeField]
  public float multiply;
  [SerializeField]
  public bool roundUp;

  public override void Run(CardData target)
  {
    target.hp = this.roundUp ? Mathf.CeilToInt((float) target.hp * this.multiply) : Mathf.RoundToInt((float) target.hp * this.multiply);
    target.hp = Mathf.Max(1, target.hp);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptMultiplyPassiveEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Multiply Passive Effect", menuName = "Card Scripts/Multiply Passive Effect")]
public class CardScriptMultiplyPassiveEffect : CardScript
{
  [SerializeField]
  public StatusEffectData effect;
  [SerializeField]
  public float multiply = 1f;

  public override void Run(CardData target)
  {
    foreach (CardData.StatusEffectStacks startWithEffect in target.startWithEffects)
    {
      if (startWithEffect.data.name == this.effect.name)
        startWithEffect.count = Mathf.RoundToInt((float) startWithEffect.count * this.multiply);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptRemoveAttackEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(fileName = "Remove Attack Effect", menuName = "Card Scripts/Remove Attack Effect")]
public class CardScriptRemoveAttackEffect : CardScript
{
  [SerializeField]
  public bool removeAll;
  [SerializeField]
  [HideIf("removeAll")]
  public StatusEffectData[] toRemove;

  public override void Run(CardData target)
  {
    if (this.removeAll)
    {
      target.attackEffects = Array.Empty<CardData.StatusEffectStacks>();
    }
    else
    {
      List<CardData.StatusEffectStacks> list = target.attackEffects.ToList<CardData.StatusEffectStacks>();
      list.RemoveAll((Predicate<CardData.StatusEffectStacks>) (a => this.toRemove.Contains<StatusEffectData>(a.data)));
      target.attackEffects = list.ToArray();
    }
  }

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__2_0(CardData.StatusEffectStacks a) => this.toRemove.Contains<StatusEffectData>(a.data);
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptRemovePassiveEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(fileName = "Remove Passive Effect", menuName = "Card Scripts/Remove Passive Effect")]
public class CardScriptRemovePassiveEffect : CardScript
{
  [SerializeField]
  public bool removeAll;
  [SerializeField]
  [HideIf("removeAll")]
  public StatusEffectData[] toRemove;
  [SerializeField]
  [ShowIf("removeAll")]
  public bool excludingStatusEffects;
  [SerializeField]
  [ShowIf("removeAll")]
  public StatusEffectData[] excluding;
  [SerializeField]
  [ShowIf("removeAll")]
  public string[] excludingTypes;
  [InfoBox("if set to ZERO it will remove all stacks", EInfoBoxType.Normal)]
  [SerializeField]
  public int reduceStacks;

  public override void Run(CardData target)
  {
    List<CardData.StatusEffectStacks> list = target.startWithEffects.ToList<CardData.StatusEffectStacks>();
    if (this.removeAll)
    {
      for (int index = list.Count - 1; index >= 0; --index)
      {
        CardData.StatusEffectStacks statusEffectStacks = list[index];
        if (!this.Exclude(statusEffectStacks.data) && (!this.excludingStatusEffects || !statusEffectStacks.data.isStatus))
        {
          statusEffectStacks.count -= this.reduceStacks;
          if (this.reduceStacks <= 0 || statusEffectStacks.count <= 0)
            list.RemoveAt(index);
        }
      }
    }
    else if (this.reduceStacks <= 0)
    {
      list.RemoveAll((Predicate<CardData.StatusEffectStacks>) (a => this.toRemove.Contains<StatusEffectData>(a.data)));
    }
    else
    {
      for (int index = list.Count - 1; index >= 0; --index)
      {
        CardData.StatusEffectStacks statusEffectStacks = list[index];
        if (this.toRemove.Contains<StatusEffectData>(statusEffectStacks.data))
        {
          statusEffectStacks.count -= this.reduceStacks;
          if (statusEffectStacks.count <= 0)
            list.RemoveAt(index);
        }
      }
    }
    target.startWithEffects = list.ToArray();
  }

  public bool Exclude(StatusEffectData effectData)
  {
    if (this.excluding.Contains<StatusEffectData>(effectData))
      return true;
    return !effectData.type.IsNullOrEmpty() && this.excludingTypes.Contains<string>(effectData.type);
  }

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__6_0(CardData.StatusEffectStacks a) => this.toRemove.Contains<StatusEffectData>(a.data);
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptRemoveTrait
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(fileName = "Remove Trait", menuName = "Card Scripts/Remove Trait")]
public class CardScriptRemoveTrait : CardScript
{
  [SerializeField]
  public bool removeAll;
  [SerializeField]
  [HideIf("removeAll")]
  public TraitData[] toRemove;
  [SerializeField]
  [ShowIf("removeAll")]
  public TraitData[] excluding;

  public override void Run(CardData target)
  {
    if (this.removeAll)
    {
      target.traits = target.traits.Where<CardData.TraitStacks>((Func<CardData.TraitStacks, bool>) (a => this.excluding.Contains<TraitData>(a.data))).ToList<CardData.TraitStacks>();
    }
    else
    {
      List<CardData.TraitStacks> list = target.traits.ToList<CardData.TraitStacks>();
      list.RemoveAll((Predicate<CardData.TraitStacks>) (a => this.toRemove.Contains<TraitData>(a.data)));
      target.traits = list.ToList<CardData.TraitStacks>();
    }
  }

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__3_0(CardData.TraitStacks a) => this.excluding.Contains<TraitData>(a.data);

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__3_1(CardData.TraitStacks a) => this.toRemove.Contains<TraitData>(a.data);
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptReplaceAttackWithApply
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Replace Attack With Apply", menuName = "Card Scripts/Replace Attack With Apply")]
public class CardScriptReplaceAttackWithApply : CardScript
{
  [SerializeField]
  public StatusEffectData effect;

  public override void Run(CardData target)
  {
    if (!target.hasAttack || target.damage <= 0)
      return;
    CardData.StatusEffectStacks[] newEffects = new CardData.StatusEffectStacks[1]
    {
      new CardData.StatusEffectStacks(this.effect, target.damage)
    };
    target.attackEffects = CardData.StatusEffectStacks.Stack((IEnumerable<CardData.StatusEffectStacks>) target.attackEffects, (IEnumerable<CardData.StatusEffectStacks>) newEffects);
    target.damage = 0;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptRoundHealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

[CreateAssetMenu(fileName = "Round Health", menuName = "Card Scripts/Round Health")]
public class CardScriptRoundHealth : CardScript
{
  [SerializeField]
  [HideIf("floor")]
  public bool ceil = true;
  [SerializeField]
  [HideIf("ceil")]
  public bool floor;
  [SerializeField]
  public int round = 10;

  public override void Run(CardData target)
  {
    float f = (float) target.hp / (float) this.round;
    target.hp = !this.ceil ? (!this.floor ? Mathf.RoundToInt(f) * this.round : Mathf.FloorToInt(f) * this.round) : Mathf.CeilToInt(f) * this.round;
    target.hp = Mathf.Max(1, target.hp);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardScriptSwapEffectsBasedOn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Swap Effects Based On", menuName = "Card Scripts/Swap Effects Based On")]
public class CardScriptSwapEffectsBasedOn : CardScript
{
  [SerializeField]
  public StatusEffectData statusA;
  [SerializeField]
  public StatusEffectData statusB;

  public override void Run(CardData target)
  {
    foreach (CardData.StatusEffectStacks attackEffect in target.attackEffects)
    {
      if (attackEffect.data.type == this.statusA.type)
        attackEffect.data = this.statusB;
      else if (attackEffect.data.type == this.statusB.type)
        attackEffect.data = this.statusA;
      else if (attackEffect.data is StatusEffectInstantDoubleX data)
        CardScriptSwapEffectsBasedOn.TrySwap(data, attackEffect, this.statusA, this.statusB);
    }
    foreach (CardData.StatusEffectStacks startWithEffect in target.startWithEffects)
    {
      switch (startWithEffect.data)
      {
        case StatusEffectApplyXWhenYAppliedTo effect1:
          CardScriptSwapEffectsBasedOn.TrySwap(effect1, startWithEffect, this.statusA, this.statusB);
          break;
        case StatusEffectApplyXWhenYAppliedToAlly effect2:
          CardScriptSwapEffectsBasedOn.TrySwap(effect2, startWithEffect, this.statusA, this.statusB);
          break;
        case StatusEffectApplyXWhenYAppliedToSelf effect3:
          CardScriptSwapEffectsBasedOn.TrySwap(effect3, startWithEffect, this.statusA, this.statusB);
          break;
        case StatusEffectApplyX effect4:
          CardScriptSwapEffectsBasedOn.TrySwap(effect4, startWithEffect, this.statusA, this.statusB);
          break;
        case StatusEffectBonusDamageEqualToX effect5:
          CardScriptSwapEffectsBasedOn.TrySwap(effect5, startWithEffect, this.statusA, this.statusB);
          break;
      }
    }
  }

  public static bool Swap(
    CardData.StatusEffectStacks stacks,
    StatusEffectData a,
    StatusEffectData b)
  {
    string assetName = stacks.data.name.Replace(a.name, b.name);
    StatusEffectData statusEffectData = AddressableLoader.Get<StatusEffectData>("StatusEffectData", assetName);
    if ((bool) (Object) statusEffectData)
    {
      stacks.data = statusEffectData;
      return true;
    }
    Debug.LogError((object) ("[" + assetName + "] effect does not exist! Cannot swap effect [" + stacks.data.name + "] :("));
    return false;
  }

  public static void TrySwap(
    StatusEffectInstantDoubleX effect,
    CardData.StatusEffectStacks stacks,
    StatusEffectData a,
    StatusEffectData b)
  {
    if (!(bool) (Object) effect.statusToDouble)
      return;
    if (effect.statusToDouble.type == a.type)
    {
      CardScriptSwapEffectsBasedOn.Swap(stacks, a, b);
    }
    else
    {
      if (!(effect.statusToDouble.type == b.type))
        return;
      CardScriptSwapEffectsBasedOn.Swap(stacks, b, a);
    }
  }

  public static void TrySwap(
    StatusEffectApplyX effect,
    CardData.StatusEffectStacks stacks,
    StatusEffectData a,
    StatusEffectData b)
  {
    if (!(bool) (Object) effect.effectToApply)
      return;
    if (effect.effectToApply.type == a.type)
    {
      CardScriptSwapEffectsBasedOn.Swap(stacks, a, b);
    }
    else
    {
      if (!(effect.effectToApply.type == b.type))
        return;
      CardScriptSwapEffectsBasedOn.Swap(stacks, b, a);
    }
  }

  public static void TrySwap(
    StatusEffectApplyXWhenYAppliedTo effect,
    CardData.StatusEffectStacks stacks,
    StatusEffectData a,
    StatusEffectData b)
  {
    if (effect.whenAppliedType == a.type || (bool) (Object) effect.effectToApply && effect.effectToApply.type == a.type)
    {
      CardScriptSwapEffectsBasedOn.Swap(stacks, a, b);
    }
    else
    {
      if (!(effect.whenAppliedType == b.type) && (!(bool) (Object) effect.effectToApply || !(effect.effectToApply.type == b.type)))
        return;
      CardScriptSwapEffectsBasedOn.Swap(stacks, b, a);
    }
  }

  public static void TrySwap(
    StatusEffectApplyXWhenYAppliedToAlly effect,
    CardData.StatusEffectStacks stacks,
    StatusEffectData a,
    StatusEffectData b)
  {
    if (effect.whenAppliedType == a.type || (bool) (Object) effect.effectToApply && effect.effectToApply.type == a.type)
    {
      CardScriptSwapEffectsBasedOn.Swap(stacks, a, b);
    }
    else
    {
      if (!(effect.whenAppliedType == b.type) && (!(bool) (Object) effect.effectToApply || !(effect.effectToApply.type == b.type)))
        return;
      CardScriptSwapEffectsBasedOn.Swap(stacks, b, a);
    }
  }

  public static void TrySwap(
    StatusEffectApplyXWhenYAppliedToSelf effect,
    CardData.StatusEffectStacks stacks,
    StatusEffectData a,
    StatusEffectData b)
  {
    if (effect.whenAppliedType == a.type || (bool) (Object) effect.effectToApply && effect.effectToApply.type == a.type)
    {
      CardScriptSwapEffectsBasedOn.Swap(stacks, a, b);
    }
    else
    {
      if (!(effect.whenAppliedType == b.type) && (!(bool) (Object) effect.effectToApply || !(effect.effectToApply.type == b.type)))
        return;
      CardScriptSwapEffectsBasedOn.Swap(stacks, b, a);
    }
  }

  public static void TrySwap(
    StatusEffectBonusDamageEqualToX effect,
    CardData.StatusEffectStacks stacks,
    StatusEffectData a,
    StatusEffectData b)
  {
    if (effect.effectType == a.type)
    {
      CardScriptSwapEffectsBasedOn.Swap(stacks, a, b);
    }
    else
    {
      if (!(effect.effectType == b.type))
        return;
      CardScriptSwapEffectsBasedOn.Swap(stacks, b, a);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardSelector
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CardSelector : MonoBehaviour
{
  public Character character;
  public UnityEventEntity selectEvent;

  public void TakeCard(Entity entity)
  {
    if (!(bool) (Object) this.character || !(bool) (Object) entity.data)
      return;
    Debug.Log((object) ("CardSelector → adding [" + entity.data.name + "] to " + this.character.name + "'s deck"));
    this.character.data.inventory.deck.Add(entity.data);
    this.MoveCardToDeck(entity);
    this.selectEvent.Invoke(entity);
  }

  public void TakeFirstCard(CardContainer cardContainer)
  {
    if (cardContainer.Count <= 0)
      return;
    this.TakeCard(cardContainer.GetTop());
  }

  public void MoveCardToDeck(Entity entity)
  {
    Events.InvokeEntityEnterBackpack(entity);
    entity.transform.parent = this.character.entity.display.transform;
    entity.display?.hover?.Disable();
    Routine routine = new Routine(AssetLoader.Lookup<CardAnimation>("CardAnimations", "FlyToBackpack").Routine((object) entity));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardSlot
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CardSlot : CardContainer
{
  [SerializeField]
  public SpriteRenderer icon;
  public Color originalIconColor;

  public void Awake() => this.originalIconColor = this.icon.color;

  public override void SetSize(int size, float cardScale)
  {
    base.SetSize(size, cardScale);
    this.holder.sizeDelta = GameManager.CARD_SIZE * cardScale;
  }

  public override void CardAdded(Entity entity) => this.FadeOutIcon();

  public override void CardRemoved(Entity entity)
  {
    if (!this.Empty)
      return;
    this.FadeInIcon();
  }

  public void ForceHover() => this.cc?.HoverSlot(this);

  public void ForceUnHover()
  {
    if (!((Object) this.cc != (Object) null) || !((Object) this.cc.hoverSlot == (Object) this))
      return;
    this.cc.UnHoverSlot();
  }

  public override void Hover()
  {
    if (!this.canHover || !((Object) this.cc != (Object) null))
      return;
    this.cc.HoverSlot(this);
  }

  public override void UnHover()
  {
    if (!this.canHover || !((Object) this.cc != (Object) null) || !((Object) this.cc.hoverSlot == (Object) this))
      return;
    this.cc.UnHoverSlot();
  }

  public void FadeOutIcon()
  {
    LeanTween.cancel(this.icon.gameObject);
    LeanTween.color(this.icon.gameObject, this.originalIconColor.With(alpha: 0.0f), 0.33f);
  }

  public void FadeInIcon()
  {
    LeanTween.cancel(this.icon.gameObject);
    LeanTween.color(this.icon.gameObject, this.originalIconColor, 0.33f);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardSlotLane
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class CardSlotLane : CardContainer
{
  public List<CardSlot> slots;
  [Required(null)]
  public CardSlot slotPrefab;
  [Required(null)]
  public HorizontalLayoutGroup layout;
  public bool autoMoveForwards = true;

  public override void SetSize(int size, float cardScale)
  {
    base.SetSize(size, cardScale);
    Routine routine = new Routine(this.SetSizeRoutine(size, cardScale));
  }

  public IEnumerator SetSizeRoutine(int size, float cardScale)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    CardSlotLane cardSlotLane = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      cardSlotLane.holder.sizeDelta = ((RectTransform) cardSlotLane.layout.transform).sizeDelta;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    cardSlotLane.CreateSlots(size);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) null;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override void MoveChildrenForward()
  {
    for (int index1 = 1; index1 < this.max; ++index1)
    {
      CardSlot slot1 = this.slots[index1];
      Entity top = slot1.GetTop();
      if ((bool) (UnityEngine.Object) top && top.positionPriority > 0)
      {
        int num = 0;
        List<CardSlot> cardSlotList = new List<CardSlot>()
        {
          slot1
        };
        if (top.height > 1)
        {
          foreach (CardContainer secondaryContainer in slot1.GetSecondaryContainers(top))
          {
            if (secondaryContainer is CardSlot cardSlot && secondaryContainer.Group is CardSlotLane)
              cardSlotList.Add(cardSlot);
          }
        }
        for (int index2 = index1 - 1; index2 >= 0; --index2)
        {
          bool flag = true;
          foreach (CardContainer cardContainer in cardSlotList)
          {
            if (!(cardContainer.Group as CardSlotLane).slots[index2].Empty)
            {
              flag = false;
              break;
            }
          }
          if (flag)
            ++num;
          else
            break;
        }
        if (num > 0)
        {
          if (cardSlotList.Count > 1)
          {
            foreach (CardSlot cardSlot in cardSlotList)
            {
              if (cardSlot.IsPrimaryContainer(top))
              {
                cardSlotList.Remove(cardSlot);
                cardSlotList.Insert(0, cardSlot);
                break;
              }
            }
          }
          for (int index3 = cardSlotList.Count - 1; index3 >= 0; --index3)
          {
            CardSlot cardSlot = cardSlotList[index3];
            CardSlotLane group = cardSlot.Group as CardSlotLane;
            CardSlot slot2 = group.slots[group.slots.IndexOf(cardSlot) - num];
            cardSlot.Remove(top);
            Entity entity = top;
            slot2.Add(entity);
          }
        }
      }
    }
    for (int index4 = this.max - 2; index4 >= 0; --index4)
    {
      CardSlot slot3 = this.slots[index4];
      Entity top = slot3.GetTop();
      if ((bool) (UnityEngine.Object) top && top.positionPriority < 0)
      {
        int num = 0;
        List<CardSlot> cardSlotList = new List<CardSlot>()
        {
          slot3
        };
        if (top.height > 1)
        {
          foreach (CardContainer secondaryContainer in slot3.GetSecondaryContainers(top))
          {
            if (secondaryContainer is CardSlot cardSlot && secondaryContainer.Group is CardSlotLane)
              cardSlotList.Add(cardSlot);
          }
        }
        for (int index5 = index4 + 1; index5 < this.max; ++index5)
        {
          bool flag = true;
          foreach (CardContainer cardContainer in cardSlotList)
          {
            if (!(cardContainer.Group as CardSlotLane).slots[index5].Empty)
            {
              flag = false;
              break;
            }
          }
          if (flag)
            ++num;
          else
            break;
        }
        if (num > 0)
        {
          if (cardSlotList.Count > 1)
          {
            foreach (CardSlot cardSlot in cardSlotList)
            {
              if (cardSlot.IsPrimaryContainer(top))
              {
                cardSlotList.Remove(cardSlot);
                cardSlotList.Insert(0, cardSlot);
                break;
              }
            }
          }
          for (int index6 = cardSlotList.Count - 1; index6 >= 0; --index6)
          {
            CardSlot cardSlot = cardSlotList[index6];
            CardSlotLane group = cardSlot.Group as CardSlotLane;
            CardSlot slot4 = group.slots[group.slots.IndexOf(cardSlot) + num];
            cardSlot.Remove(top);
            Entity entity = top;
            slot4.Add(entity);
          }
        }
      }
    }
  }

  public override int Count
  {
    get
    {
      int count = 0;
      foreach (CardSlot slot in this.slots)
        count += slot.Count;
      return count;
    }
    set => base.Count = value;
  }

  public void SetDirection(int direction) => this.layout.reverseArrangement = direction == 1;

  public void CreateSlots(int count)
  {
    this.layout.transform.DestroyAllChildren();
    this.slots.Clear();
    CardSlot cardSlot1 = (CardSlot) null;
    for (int index = 0; index < count; ++index)
    {
      CardSlot cardSlot2 = UnityEngine.Object.Instantiate<CardSlot>(this.slotPrefab, this.layout.transform);
      cardSlot2.name = string.Format("{0} [Slot {1}]", (object) this.name, (object) (index + 1));
      cardSlot2.owner = this.owner;
      cardSlot2.Group = (CardContainer) this;
      this.slots.Add(cardSlot2);
      if ((bool) (UnityEngine.Object) cardSlot1)
      {
        cardSlot1.shoveTo.Add((CardContainer) cardSlot2);
        cardSlot2.shoveTo.Add((CardContainer) cardSlot1);
      }
      cardSlot1 = cardSlot2;
    }
  }

  public override void Add(Entity entity)
  {
    if (this.Count >= this.max)
      return;
    if (entity.positionPriority >= 0)
    {
      for (int index1 = 0; index1 < this.max; ++index1)
      {
        CardSlot slot = this.slots[index1];
        Entity top1 = slot.GetTop();
        if (!(bool) (UnityEngine.Object) top1)
        {
          slot.Add(entity);
          break;
        }
        if (top1.positionPriority < entity.positionPriority)
        {
          bool flag = true;
          for (int index2 = index1 + 1; index2 < this.max; ++index2)
          {
            Entity top2 = this.slots[index2].GetTop();
            if ((bool) (UnityEngine.Object) top2 && top2.positionPriority >= entity.positionPriority)
            {
              flag = false;
              break;
            }
          }
          if (flag)
          {
            this.Insert(index1, entity);
            break;
          }
        }
      }
    }
    else
    {
      for (int index = this.max - 1; index >= 0; --index)
      {
        CardSlot slot = this.slots[index];
        Entity top = slot.GetTop();
        if (!(bool) (UnityEngine.Object) top)
        {
          slot.Add(entity);
          break;
        }
        if (top.positionPriority <= entity.positionPriority)
        {
          this.Insert(index, entity);
          break;
        }
      }
    }
  }

  public override void Insert(int index, Entity entity)
  {
    if (this.Count >= this.max)
      return;
    CardSlot slot = this.slots[index];
    if ((bool) (UnityEngine.Object) slot && slot.Empty)
    {
      slot.Add(entity);
    }
    else
    {
      bool flag = this.PushForwards(index);
      if (!flag)
        flag = this.PushBackwards(index);
      if (!flag)
        return;
      slot.Add(entity);
    }
  }

  public override bool PushForwards(int fromIndex)
  {
    int num = this.CanPush(fromIndex) ? 1 : 0;
    if (num == 0)
      return num != 0;
    this.GetPushData(fromIndex).Execute();
    return num != 0;
  }

  public override bool PushBackwards(int fromIndex)
  {
    int num = this.CanPush(fromIndex, 1) ? 1 : 0;
    if (num == 0)
      return num != 0;
    this.GetPushData(fromIndex, 1).Execute();
    return num != 0;
  }

  public bool CanPush(int fromIndex, int direction = -1)
  {
    bool flag = true;
    Entity top = this.slots[fromIndex].GetTop();
    if ((bool) (UnityEngine.Object) top)
    {
      foreach (CardContainer container in top.containers)
      {
        if (container is CardSlotLane cardSlotLane)
        {
          int fromIndex1 = cardSlotLane.IndexOf(top) + direction;
          if (fromIndex1 >= 0 && fromIndex1 < cardSlotLane.max)
          {
            if (!cardSlotLane.CanPush(fromIndex1, direction))
            {
              flag = false;
              break;
            }
          }
          else
          {
            flag = false;
            break;
          }
        }
        else
        {
          flag = false;
          break;
        }
      }
    }
    return flag;
  }

  public CardSlotLane.PushData GetPushData(int fromIndex, int direction = -1)
  {
    CardSlotLane.PushData pushData = new CardSlotLane.PushData();
    Entity top = this.slots[fromIndex].GetTop();
    if ((bool) (UnityEngine.Object) top)
    {
      foreach (CardContainer container in top.containers)
      {
        if (container is CardSlotLane cardSlotLane)
        {
          int num = cardSlotLane.IndexOf(top) + direction;
          if (num >= 0 && num < cardSlotLane.max)
          {
            CardSlot slot = cardSlotLane.slots[num];
            pushData.Add(top, (CardContainer) slot);
            pushData.Add(cardSlotLane.GetPushData(num, direction));
          }
        }
      }
    }
    return pushData;
  }

  public override void Remove(Entity entity)
  {
    foreach (CardSlot slot in this.slots)
    {
      if (slot.Count > 0 && (UnityEngine.Object) slot[0] == (UnityEngine.Object) entity)
        slot.Remove(entity);
    }
  }

  public override void RemoveAt(int index)
  {
    CardSlot slot = this.slots[index];
    if (!(bool) (UnityEngine.Object) slot || slot.Empty)
      return;
    slot.RemoveAt(0);
  }

  public override Entity this[int index]
  {
    get
    {
      int skips = this.GetSkips(index);
      for (int index1 = index + skips; index1 < this.max; ++index1)
      {
        CardSlot slot = this.slots[index1];
        if ((UnityEngine.Object) slot != (UnityEngine.Object) null && !slot.Empty)
          return slot[0];
      }
      return (Entity) null;
    }
    set => throw new NotImplementedException();
  }

  public int GetSkips(int upToIndex)
  {
    int skips = 0;
    for (int index = 0; index <= upToIndex; ++index)
    {
      CardSlot slot = this.slots[index];
      if ((UnityEngine.Object) slot == (UnityEngine.Object) null || slot.Empty)
        ++skips;
    }
    return skips;
  }

  public override Entity GetTop()
  {
    if (this.max <= 0)
      return (Entity) null;
    return this.slots[0].Empty ? (Entity) null : this.slots[0][0];
  }

  public override int IndexOf(Entity item)
  {
    for (int index = 0; index < this.max; ++index)
    {
      if (this.slots[index].Contains(item))
        return index;
    }
    return -1;
  }

  public override bool Contains(Entity item) => this.slots.Any<CardSlot>((Func<CardSlot, bool>) (slot => slot.Contains(item)));

  public override Entity[] ToArray()
  {
    List<Entity> entityList = new List<Entity>();
    foreach (CardSlot slot in this.slots)
    {
      if (slot.Count > 0)
        entityList.Add(slot[0]);
    }
    return entityList.ToArray();
  }

  public override IEnumerator<Entity> GetEnumerator()
  {
    foreach (CardContainer slot in this.slots)
    {
      foreach (Entity entity in slot)
        yield return entity;
    }
  }

  public class PushData
  {
    public readonly Dictionary<Entity, List<CardContainer>> dict = new Dictionary<Entity, List<CardContainer>>();

    public void Add(CardSlotLane.PushData other)
    {
      foreach (KeyValuePair<Entity, List<CardContainer>> keyValuePair in other.dict)
        this.Add(keyValuePair.Key, keyValuePair.Value);
    }

    public void Add(Entity entity, CardContainer container)
    {
      if (this.dict.ContainsKey(entity))
        this.dict[entity].Add(container);
      else
        this.dict[entity] = new List<CardContainer>()
        {
          container
        };
    }

    public void Add(Entity entity, List<CardContainer> containers)
    {
      if (this.dict.ContainsKey(entity))
        this.dict[entity].AddRange((IEnumerable<CardContainer>) containers);
      else
        this.dict[entity] = containers;
    }

    public void Execute()
    {
      foreach (KeyValuePair<Entity, List<CardContainer>> keyValuePair in this.dict)
        keyValuePair.Key.RemoveFromContainers();
      foreach (KeyValuePair<Entity, List<CardContainer>> keyValuePair in this.dict)
      {
        foreach (CardContainer cardContainer in keyValuePair.Value)
          cardContainer.Add(keyValuePair.Key);
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardStack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CardStack : CardContainer
{
  [SerializeField]
  public Vector3 randomAngleAmount = new Vector3(0.0f, 0.0f, 2f);
  public bool insertAtBottom;
  public bool flipOnAdd = true;

  public override void SetSize(int size, float cardScale)
  {
    base.SetSize(size, cardScale);
    this.holder.sizeDelta = GameManager.CARD_SIZE * cardScale;
  }

  public override Vector3 GetChildPosition(Entity child)
  {
    int num1 = this.IndexOf(child);
    float num2 = 0.0f;
    float num3 = 0.0f;
    double x = 0.0 + (double) this.gap.x * (double) num1;
    float num4 = num2 + this.gap.y * (float) num1;
    float num5 = num3 + this.gap.z * (float) num1;
    double y = (double) num4;
    double z = (double) num5;
    return new Vector3((float) x, (float) y, (float) z);
  }

  public override void Add(Entity entity)
  {
    if (this.insertAtBottom)
    {
      entity.transform.SetParent((Transform) this.holder);
      entity.AddTo((CardContainer) this);
      this.entities.Insert(0, entity);
      entity.transform.SetSiblingIndex(0);
      ++this.Count;
      this.CardAdded(entity);
      for (int index = 1; index < this.Count; ++index)
        this.TweenChildPosition(this.entities[index]);
    }
    else
      base.Add(entity);
  }

  public override Vector3 GetChildRotation(Entity child) => Vector3.Scale(child.random3, this.randomAngleAmount);

  public override void CardAdded(Entity entity)
  {
    base.CardAdded(entity);
    entity.enabled = false;
    if (!this.flipOnAdd || !(bool) (Object) entity.flipper)
      return;
    entity.flipper.FlipDown();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardTooltip
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.UI;

public class CardTooltip : Tooltip
{
  [Header("Card Elements")]
  [SerializeField]
  public TMP_Text titleElement;
  [SerializeField]
  public TMP_Text descElement;
  [SerializeField]
  public Image cardArt;
  [SerializeField]
  public Image textBox;
  [SerializeField]
  public Image nameTag;
  [SerializeField]
  public Transform healthIconGroup;
  [SerializeField]
  public Transform damageIconGroup;
  [SerializeField]
  public Transform counterIconGroup;
  [SerializeField]
  public Transform crownIconGroup;
  public readonly Dictionary<string, Transform> iconGroups = new Dictionary<string, Transform>();
  public HashSet<KeywordData> keywords;

  public void Awake()
  {
    if ((Object) this.healthIconGroup != (Object) null)
      this.iconGroups["health"] = this.healthIconGroup;
    if ((Object) this.damageIconGroup != (Object) null)
      this.iconGroups["damage"] = this.damageIconGroup;
    if ((Object) this.counterIconGroup != (Object) null)
      this.iconGroups["counter"] = this.counterIconGroup;
    if (!((Object) this.crownIconGroup != (Object) null))
      return;
    this.iconGroups["crown"] = this.crownIconGroup;
  }

  public void Set(CardData data)
  {
    this.healthIconGroup.DestroyAllChildren();
    this.damageIconGroup.DestroyAllChildren();
    this.counterIconGroup.DestroyAllChildren();
    this.crownIconGroup.DestroyAllChildren();
    this.cardArt.sprite = data.mainSprite;
    this.textBox.sprite = data.cardType.textBoxSprite;
    this.nameTag.sprite = data.cardType.nameTagSprite;
    this.titleElement.text = data.title;
    string description = Card.GetDescription(data);
    this.keywords = Text.GetKeywords(description);
    string str = Text.Process(description, 0, 1f, data.cardType.descriptionColours);
    if (str.IsNullOrWhitespace())
    {
      LocalizedString flavourKey = data.flavourKey;
      if (flavourKey != null && !flavourKey.IsEmpty)
      {
        string localizedString = data.flavourKey.GetLocalizedString();
        str = "<i><color=#" + data.cardType.descriptionColours.flavourColour + ">" + localizedString;
      }
    }
    this.descElement.text = str;
    if (data.hasHealth)
      this.CreateIcon("health", "health", data.hp);
    if (data.hasAttack)
      this.CreateIcon("damage", "damage", data.damage);
    if (data.counter > 0)
      this.CreateIcon("counter", "counter", data.counter);
    foreach (CardData.StatusEffectStacks startWithEffect in data.startWithEffects)
    {
      if (startWithEffect.data.visible && !startWithEffect.data.iconGroupName.IsNullOrWhitespace())
        this.CreateIcon(startWithEffect.data.type, startWithEffect.data.iconGroupName, startWithEffect.count);
    }
    this.Ping();
  }

  public void CreateIcon(string type, string iconGroupName, int value) => CardManager.NewStatusIcon(type, this.iconGroups[iconGroupName]).SetValue(new Stat(value), false);
}
﻿// Decompiled with JetBrains decompiler
// Type: CardType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Localization;

[CreateAssetMenu(fileName = "CardType", menuName = "Card Type")]
public class CardType : DataFile
{
  public int sortPriority;
  [ShowAssetPreview(64, 64)]
  public Sprite icon;
  public AssetReference prefabRef;
  [Header("Details")]
  public Sprite textBoxSprite;
  public Sprite nameTagSprite;
  [SerializeField]
  public LocalizedString titleKey;
  public bool canDie;
  public bool canTakeCrown;
  public bool canRecall;
  public bool canReserve;
  public bool item;
  public bool unit;
  public string tag;
  public bool miniboss;
  public bool discoverInJournal;
  [Header("Colours")]
  public Text.ColourProfileHex descriptionColours;

  public override bool Equals(object other) => other is CardType cardType ? this.name == cardType.name : base.Equals(other);

  public string title => this.titleKey.GetLocalizedString();
}
﻿// Decompiled with JetBrains decompiler
// Type: CardUINavigationItem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class CardUINavigationItem : UINavigationItem
{
  public CardHover cardHover;
  public Entity entity;

  public void Update() => this.isSelectable = !this.entity.flipper.flipped;
}
﻿// Decompiled with JetBrains decompiler
// Type: CardUnlockSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Localization;

public class CardUnlockSequence : MonoBehaviour
{
  [SerializeField]
  public Transform cardHolder;
  [SerializeField]
  public float duration = 2f;
  [SerializeField]
  public string waitForPress = "Select";
  [SerializeField]
  public ParticleSystem burstParticleSystem;
  [SerializeField]
  public LocalizedString titleKey;
  [SerializeField]
  public LocalizedString promptKey;

  public IEnumerator Run(Entity card, CardContainer endContainer)
  {
    CardUnlockSequence cardUnlockSequence = this;
    Events.InvokeEntityShowUnlocked(card);
    cardUnlockSequence.gameObject.SetActive(true);
    CinemaBarSystem.In();
    CinemaBarSystem.Top.SetPrompt(cardUnlockSequence.titleKey.GetLocalizedString(), "");
    CinemaBarSystem.Bottom.SetPrompt(cardUnlockSequence.promptKey.GetLocalizedString(), "Select");
    CinemaBarSystem.SetSortingLayer("UI2");
    Transform transform = card.transform;
    transform.SetParent(cardUnlockSequence.cardHolder);
    transform.localPosition = Vector3.zero;
    cardUnlockSequence.burstParticleSystem.Play();
    transform.localScale = new Vector3(2f, 0.0f, 1f);
    LeanTween.scale(transform.gameObject, Vector3.one, 1.5f).setEase(LeanTweenType.easeOutElastic);
    yield return (object) new WaitForSeconds(cardUnlockSequence.duration);
    if (!cardUnlockSequence.waitForPress.IsNullOrWhitespace())
      yield return (object) new WaitUntil(new Func<bool>(cardUnlockSequence.\u003CRun\u003Eb__6_0));
    CinemaBarSystem.Clear();
    CinemaBarSystem.Out();
    if ((UnityEngine.Object) endContainer != (UnityEngine.Object) null)
    {
      endContainer.Add(card);
      endContainer.TweenChildPositions();
    }
    cardUnlockSequence.gameObject.SetActive(false);
  }

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__6_0() => InputSystem.IsButtonPressed(this.waitForPress);
}
﻿// Decompiled with JetBrains decompiler
// Type: CardUpgradeData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Localization;

[CreateAssetMenu(fileName = "CardUpgradeData", menuName = "Card Upgrade Data")]
public class CardUpgradeData : DataFile, ISaveable<CardUpgradeSaveData>
{
  public int tier;
  [SerializeField]
  public LocalizedString titleKey;
  [SerializeField]
  public LocalizedString textKey;
  [ShowAssetPreview(64, 64)]
  public Sprite image;
  public CardUpgradeData.Type type;
  public CardData.StatusEffectStacks[] attackEffects;
  public CardData.StatusEffectStacks[] effects;
  public CardData.TraitStacks[] giveTraits;
  public CardScript[] scripts;
  public bool becomesTargetedCard;
  public bool canBeRemoved;
  [Header("Constraints for applying this to a card")]
  [SerializeField]
  public TargetConstraint[] targetConstraints;
  [Header("Stat Changes")]
  public int damage;
  public int hp;
  public int counter;
  public int uses;
  public int effectBonus;
  [Header("Set Exact Stats")]
  public bool setDamage;
  public bool setHp;
  public bool setCounter;
  public bool setUses;
  public List<CardData.StatusEffectStacks> effectsAffected;
  public List<CardData.TraitStacks> traitsAffected;
  public List<CardData.StatusEffectStacks> attackEffectsApplied;
  public List<CardData.StatusEffectStacks> startWithEffectsApplied;
  public int damageChange;
  public int hpChange;
  public int counterChange;
  public int usesChange;

  public string title => this.titleKey.GetLocalizedString();

  public string text => this.textKey.GetLocalizedString();

  public void Assign(CardData cardData)
  {
    int damage = cardData.damage;
    int hp = cardData.hp;
    int counter = cardData.counter;
    int uses = cardData.uses;
    if (this.becomesTargetedCard)
    {
      cardData.hasAttack = true;
      if (cardData.playType == Card.PlayType.None)
        cardData.playType = Card.PlayType.Play;
      cardData.needsTarget = true;
    }
    cardData.damage = this.setDamage ? this.damage : cardData.damage + this.damage;
    cardData.hp = this.setHp ? this.hp : cardData.hp + this.hp;
    cardData.counter = this.setCounter ? this.counter : cardData.counter + this.counter;
    cardData.uses = this.setUses ? this.uses : cardData.uses + this.uses;
    cardData.damage = Mathf.Max(0, cardData.damage);
    cardData.hp = Mathf.Max(0, cardData.hp);
    cardData.counter = Mathf.Max(0, cardData.counter);
    cardData.uses = Mathf.Max(0, cardData.uses);
    this.damageChange = cardData.damage - damage;
    this.hpChange = cardData.hp - hp;
    this.counterChange = cardData.counter - counter;
    this.usesChange = cardData.uses - uses;
    foreach (CardScript script in this.scripts)
      script.Run(cardData);
    if (this.effectBonus != 0)
    {
      this.effectsAffected = new List<CardData.StatusEffectStacks>();
      foreach (CardData.StatusEffectStacks attackEffect in cardData.attackEffects)
      {
        if (attackEffect.data.isStatus || attackEffect.data.stackable)
        {
          attackEffect.count = Mathf.Max(0, attackEffect.count + this.effectBonus);
          this.effectsAffected.Add(attackEffect);
        }
      }
      foreach (CardData.StatusEffectStacks startWithEffect in cardData.startWithEffects)
      {
        if (startWithEffect.data.canBeBoosted)
        {
          startWithEffect.count = Mathf.Max(0, startWithEffect.count + this.effectBonus);
          this.effectsAffected.Add(startWithEffect);
        }
      }
      this.traitsAffected = new List<CardData.TraitStacks>();
      foreach (CardData.TraitStacks trait in cardData.traits)
      {
        if (trait.data.keyword.canStack)
        {
          trait.count = Mathf.Max(0, trait.count + this.effectBonus);
          this.traitsAffected.Add(trait);
        }
      }
    }
    if (this.attackEffects.Length != 0)
    {
      this.attackEffectsApplied = new List<CardData.StatusEffectStacks>();
      List<CardData.StatusEffectStacks> list = cardData.attackEffects.ToList<CardData.StatusEffectStacks>();
      for (int index = this.attackEffects.Length - 1; index >= 0; --index)
      {
        CardData.StatusEffectStacks e = this.attackEffects[index];
        if (list.Exists((Predicate<CardData.StatusEffectStacks>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) e.data)))
          list.Find((Predicate<CardData.StatusEffectStacks>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) e.data)).count += e.count;
        else
          list.Add(e);
        this.attackEffectsApplied.Add(e);
      }
      cardData.attackEffects = list.ToArray();
    }
    if (this.effects.Length != 0)
    {
      this.startWithEffectsApplied = new List<CardData.StatusEffectStacks>();
      List<CardData.StatusEffectStacks> list = cardData.startWithEffects.ToList<CardData.StatusEffectStacks>();
      for (int index = this.effects.Length - 1; index >= 0; --index)
      {
        CardData.StatusEffectStacks e = this.effects[index];
        if (list.Exists((Predicate<CardData.StatusEffectStacks>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) e.data)))
          list.Find((Predicate<CardData.StatusEffectStacks>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) e.data)).count += e.count;
        else
          list.Add(e);
        this.startWithEffectsApplied.Add(e);
      }
      cardData.startWithEffects = list.ToArray();
    }
    foreach (CardData.TraitStacks giveTrait in this.giveTraits)
    {
      bool flag = false;
      foreach (CardData.TraitStacks trait in cardData.traits)
      {
        if (trait.data.Equals((object) giveTrait.data))
        {
          trait.count += giveTrait.count;
          flag = true;
          break;
        }
      }
      if (!flag)
        cardData.traits.Add(new CardData.TraitStacks()
        {
          data = giveTrait.data,
          count = giveTrait.count
        });
    }
    cardData.upgrades.Add(this);
  }

  public IEnumerator Assign(Entity entity)
  {
    CardUpgradeData upgradeData = this;
    Events.InvokeUpgradeAssign(entity, upgradeData);
    upgradeData.Assign(entity.data);
    yield return (object) entity.ClearStatuses();
    if (entity.display is Card display)
      yield return (object) display.UpdateData(false);
  }

  public void UnAssign(CardData assignedTo)
  {
    assignedTo.damage -= this.damageChange;
    assignedTo.hp -= this.hpChange;
    assignedTo.counter -= this.counterChange;
    assignedTo.uses -= this.usesChange;
    if (this.effectBonus != 0)
    {
      foreach (CardData.StatusEffectStacks statusEffectStacks in this.effectsAffected)
        statusEffectStacks.count -= this.effectBonus;
      this.effectsAffected = (List<CardData.StatusEffectStacks>) null;
      foreach (CardData.TraitStacks traitStacks in this.traitsAffected)
        traitStacks.count -= this.effectBonus;
      this.traitsAffected = (List<CardData.TraitStacks>) null;
    }
    if (this.attackEffectsApplied != null && this.attackEffectsApplied.Count > 0)
    {
      List<CardData.StatusEffectStacks> list = assignedTo.attackEffects.ToList<CardData.StatusEffectStacks>();
      for (int index = this.attackEffectsApplied.Count - 1; index >= 0; --index)
      {
        CardData.StatusEffectStacks e = this.attackEffectsApplied[index];
        CardData.StatusEffectStacks statusEffectStacks = list.Find((Predicate<CardData.StatusEffectStacks>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) e.data));
        statusEffectStacks.count -= e.count;
        if (statusEffectStacks.count <= 0)
          list.Remove(e);
      }
    }
    if (this.startWithEffectsApplied != null && this.startWithEffectsApplied.Count > 0)
    {
      List<CardData.StatusEffectStacks> list = assignedTo.startWithEffects.ToList<CardData.StatusEffectStacks>();
      for (int index = this.startWithEffectsApplied.Count - 1; index >= 0; --index)
      {
        CardData.StatusEffectStacks e = this.startWithEffectsApplied[index];
        CardData.StatusEffectStacks statusEffectStacks = list.Find((Predicate<CardData.StatusEffectStacks>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) e.data));
        statusEffectStacks.count -= e.count;
        if (statusEffectStacks.count <= 0)
          list.Remove(e);
      }
      assignedTo.startWithEffects = list.ToArray();
      this.startWithEffectsApplied = (List<CardData.StatusEffectStacks>) null;
    }
    assignedTo.upgrades.Remove(this);
  }

  public bool CanAssign(Entity card)
  {
    CardData data = card.data;
    if (this.damage != 0 && !data.hasAttack || this.hp != 0 && !data.hasHealth || this.counter != 0 && data.counter <= 0)
      return false;
    foreach (CardData.TraitStacks traitStacks in ((IEnumerable<CardData.TraitStacks>) this.giveTraits).Where<CardData.TraitStacks>((Func<CardData.TraitStacks, bool>) (t => !t.data.keyword.canStack)))
    {
      CardData.TraitStacks t = traitStacks;
      if (data.traits.Any<CardData.TraitStacks>((Func<CardData.TraitStacks, bool>) (a => a.data.name == t.data.name)))
        return false;
    }
    foreach (TargetConstraint targetConstraint in this.targetConstraints)
    {
      if (!targetConstraint.Check(card))
        return false;
    }
    switch (this.type)
    {
      case CardUpgradeData.Type.Charm:
        int count = data.upgrades.FindAll((Predicate<CardUpgradeData>) (a => a.type == this.type)).Count;
        int charmSlots = data.charmSlots;
        if (data.customData != null)
          charmSlots += data.customData.Get<int>("extraCharmSlots", 0);
        int num = charmSlots;
        if (count >= num)
          return false;
        break;
      case CardUpgradeData.Type.Token:
        if (data.upgrades.FindAll((Predicate<CardUpgradeData>) (a => a.type == this.type)).Count >= data.tokenSlots)
          return false;
        break;
      case CardUpgradeData.Type.Crown:
        if (data.upgrades.FindAll((Predicate<CardUpgradeData>) (a => a.type == this.type)).Count >= data.crownSlots)
          return false;
        break;
    }
    return true;
  }

  public bool CanAssign(CardData cardData)
  {
    if (this.damage != 0 && !cardData.hasAttack || this.hp != 0 && !cardData.hasHealth || this.counter != 0 && cardData.counter <= 0)
      return false;
    foreach (CardData.TraitStacks traitStacks in ((IEnumerable<CardData.TraitStacks>) this.giveTraits).Where<CardData.TraitStacks>((Func<CardData.TraitStacks, bool>) (t => !t.data.keyword.canStack)))
    {
      CardData.TraitStacks t = traitStacks;
      if (cardData.traits.Any<CardData.TraitStacks>((Func<CardData.TraitStacks, bool>) (a => a.data.Equals((object) t.data))))
        return false;
    }
    foreach (TargetConstraint targetConstraint in this.targetConstraints)
    {
      if (!targetConstraint.Check(cardData))
        return false;
    }
    switch (this.type)
    {
      case CardUpgradeData.Type.Charm:
        if (cardData.upgrades.FindAll((Predicate<CardUpgradeData>) (a => a.type == this.type)).Count >= cardData.charmSlots)
          return false;
        break;
      case CardUpgradeData.Type.Token:
        if (cardData.upgrades.FindAll((Predicate<CardUpgradeData>) (a => a.type == this.type)).Count >= cardData.tokenSlots)
          return false;
        break;
      case CardUpgradeData.Type.Crown:
        if (cardData.upgrades.FindAll((Predicate<CardUpgradeData>) (a => a.type == this.type)).Count >= cardData.crownSlots)
          return false;
        break;
    }
    return true;
  }

  public void Display(Entity entity)
  {
    if (this.type == CardUpgradeData.Type.None || !(entity.display is Card display))
      return;
    switch (this.type)
    {
      case CardUpgradeData.Type.Charm:
        if (!(bool) (UnityEngine.Object) display.charmHolder)
          break;
        display.charmHolder.Create(this);
        display.charmHolder.SetPositions();
        break;
      case CardUpgradeData.Type.Token:
        if (!(bool) (UnityEngine.Object) display.tokenHolder)
          break;
        display.tokenHolder.Create(this);
        display.tokenHolder.SetPositions();
        break;
      case CardUpgradeData.Type.Crown:
        if (!(bool) (UnityEngine.Object) display.crownHolder)
          break;
        display.crownHolder.Create(this);
        display.crownHolder.SetPositions();
        break;
    }
  }

  public CardUpgradeData Clone() => this.InstantiateKeepName<CardUpgradeData>();

  public CardUpgradeSaveData Save() => new CardUpgradeSaveData(this.name);

  [CompilerGenerated]
  public bool \u003CCanAssign\u003Eb__37_2(CardUpgradeData a) => a.type == this.type;

  [CompilerGenerated]
  public bool \u003CCanAssign\u003Eb__37_3(CardUpgradeData a) => a.type == this.type;

  [CompilerGenerated]
  public bool \u003CCanAssign\u003Eb__37_4(CardUpgradeData a) => a.type == this.type;

  [CompilerGenerated]
  public bool \u003CCanAssign\u003Eb__38_2(CardUpgradeData a) => a.type == this.type;

  [CompilerGenerated]
  public bool \u003CCanAssign\u003Eb__38_3(CardUpgradeData a) => a.type == this.type;

  [CompilerGenerated]
  public bool \u003CCanAssign\u003Eb__38_4(CardUpgradeData a) => a.type == this.type;

  public enum Type
  {
    None,
    Charm,
    Token,
    Crown,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CardUpgradeSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Serializable]
public class CardUpgradeSaveData : ILoadable<CardUpgradeData>
{
  public string name;

  public CardUpgradeSaveData()
  {
  }

  public CardUpgradeSaveData(string name) => this.name = name;

  public CardUpgradeData Load() => AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", this.name)?.Clone();
}
﻿// Decompiled with JetBrains decompiler
// Type: CardViewer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CardViewer : MonoBehaviour
{
  [SerializeField]
  public Transform cardHolder;
  [SerializeField]
  public CardData startingData;
  [SerializeField]
  public InspectSystem inspectSystem;
  public int current;
  public List<CardData> cards;

  public void Start()
  {
    this.cards = AddressableLoader.GetGroup<CardData>("CardData").Where<CardData>((Func<CardData, bool>) (a => a.cardType.name != "Leader" && a.cardType.name != "Boss" && a.mainSprite.name != "Nothing")).ToList<CardData>();
    this.Set(this.startingData);
  }

  public void Update()
  {
    if (Input.GetKeyDown(KeyCode.LeftArrow))
    {
      this.Set(-1);
    }
    else
    {
      if (!Input.GetKeyDown(KeyCode.RightArrow))
        return;
      this.Set(1);
    }
  }

  public void Set(CardData data)
  {
    this.current = this.cards.IndexOf(data);
    this.StopAllCoroutines();
    this.StartCoroutine(this.SetRoutine(data));
  }

  public IEnumerator SetRoutine(CardData data)
  {
    this.cardHolder.DestroyAllChildren();
    Card card = CardManager.Get(data, (CardController) null, (Character) null, false, false);
    card.entity.returnToPool = false;
    yield return (object) card.UpdateData(false);
    card.transform.SetParent(this.cardHolder);
    card.imageIdleAnimator.FadeIn();
    card.imageIdleAnimator.SetSpeed(1f, 0.636619747f, 0.0f);
    card.backgroundIdleAnimator.FadeIn();
    card.backgroundIdleAnimator.SetSpeed(1f, 0.636619747f, 0.0f);
    Transform transform = card.transform;
    transform.localPosition = Vector3.zero;
    transform.localEulerAngles = Vector3.zero;
    transform.localScale = Vector3.one;
    if ((bool) (UnityEngine.Object) this.inspectSystem)
    {
      Events.InvokeEntityHover(card.entity);
      this.inspectSystem.ClearPopups();
      this.inspectSystem.inspect = card.entity;
      this.inspectSystem.CreatePopups();
    }
  }

  public void Set(int change)
  {
    int index = (this.current + change) % this.cards.Count;
    if (index < 0)
      index += this.cards.Count;
    this.Set(this.cards[index]);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization;

[CreateAssetMenu(menuName = "Town/Challenge", fileName = "Challenge")]
public class ChallengeData : DataFile
{
  public bool hidden;
  public LocalizedString titleKey;
  public LocalizedString textKey;
  public LocalizedString rewardKey;
  public int goal;
  public ChallengeListener listener;
  public Sprite icon;
  public ChallengeData[] requires;
  public UnlockData reward;

  public string text => this.textKey.GetLocalizedString();

  public string rewardText => this.rewardKey.GetLocalizedString();
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeDisplayCreator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

public class ChallengeDisplayCreator : MonoBehaviour
{
  public ChallengeData challenge;
  [SerializeField]
  public ChallengeProgressDisplay displayPrefab;
  [SerializeField]
  public bool checkOnEnable = true;

  public void OnEnable()
  {
    if (!this.checkOnEnable)
      return;
    this.Check();
  }

  public void Check()
  {
    if (!(bool) (UnityEngine.Object) this.challenge || !this.challenge.reward.IsActive || !(bool) (UnityEngine.Object) this.displayPrefab)
      return;
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>("completedChallenges", (List<string>) null) ?? new List<string>();
    if (stringList.Contains(this.challenge.name))
      return;
    foreach (ChallengeData require in this.challenge.requires)
    {
      if (!stringList.Contains(require.name))
        return;
    }
    List<ChallengeProgress> source = SaveSystem.LoadProgressData<List<ChallengeProgress>>("challengeProgress", (List<ChallengeProgress>) null);
    ChallengeProgress challengeProgress = source != null ? source.FirstOrDefault<ChallengeProgress>((Func<ChallengeProgress, bool>) (a => a.challengeName == this.challenge.name)) : (ChallengeProgress) null;
    int currentValue = challengeProgress != null ? challengeProgress.currentValue : 0;
    ChallengeProgressDisplay challengeProgressDisplay = UnityEngine.Object.Instantiate<ChallengeProgressDisplay>(this.displayPrefab, this.transform);
    challengeProgressDisplay.Assign(this.challenge);
    challengeProgressDisplay.SetFill((float) currentValue, this.challenge.goal);
  }

  [CompilerGenerated]
  public bool \u003CCheck\u003Eb__4_0(ChallengeProgress a) => a.challengeName == this.challenge.name;
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeEntry
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;
using UnityEngine.Localization.Components;
using UnityEngine.UI;

public class ChallengeEntry : MonoBehaviour
{
  [SerializeField]
  public LocalizeStringEvent text;
  [SerializeField]
  public TMP_Text progressText;
  [SerializeField]
  public LocalizeStringEvent rewardText;
  [SerializeField]
  public Image background;
  [SerializeField]
  public Image rewardIcon;
  public ChallengeData challenge;

  public void Assign(ChallengeData challenge, bool completed)
  {
    this.challenge = challenge;
    this.text.StringReference = challenge.textKey;
    if (completed && (bool) (Object) this.rewardText)
      this.rewardText.StringReference = challenge.rewardKey;
    if (!(bool) (Object) this.rewardIcon)
      return;
    this.rewardIcon.sprite = challenge.icon;
  }

  public void SetProgress(int progress) => this.progressText.text = string.Format("{0}/{1}", (object) progress, (object) this.challenge.goal);

  public void SetText(string str)
  {
    TMP_Text component = this.text.GetComponent<TMP_Text>();
    if (component == null)
      return;
    component.text = str.Format((object) this.challenge.listener.target);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeListDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ChallengeListDisplay : MonoBehaviour
{
  [SerializeField]
  public ChallengeListDisplayBuilder builder;
  [SerializeField]
  public GameObject loadingWidget;
  public bool loadingWidgetActive;

  public void OnEnable()
  {
    this.loadingWidget.SetActive(this.builder.running);
    this.loadingWidgetActive = this.loadingWidget.activeSelf;
  }

  public void Update()
  {
    if (!this.loadingWidgetActive || this.builder.running)
      return;
    this.loadingWidget.SetActive(false);
    this.loadingWidgetActive = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeListDisplayBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.AddressableAssets;

public class ChallengeListDisplayBuilder : MonoBehaviour
{
  [SerializeField]
  public Transform tempGroup;
  [SerializeField]
  public Transform finalGroup;
  [SerializeField]
  public AssetReferenceGameObject inProgressPrefab;
  [SerializeField]
  public AssetReferenceGameObject completedPrefab;
  [SerializeField]
  public AssetReferenceGameObject lockedPrefab;
  public readonly CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();
  public CancellationToken cancellationToken;
  public Transform[] progress;
  [CompilerGenerated]
  public bool \u003Crunning\u003Ek__BackingField;

  public bool running
  {
    get => this.\u003Crunning\u003Ek__BackingField;
    set => this.\u003Crunning\u003Ek__BackingField = value;
  }

  public void Awake() => this.cancellationToken = this.cancellationTokenSource.Token;

  public async void OnEnable()
  {
    if (this.running)
    {
      this.cancellationTokenSource.Cancel();
      while (this.running)
        await Task.Yield();
    }
    await this.Build();
  }

  public async Task Build()
  {
    this.running = true;
    List<ChallengeData> completedChallenges;
    List<ChallengeData> lockedChallenges;
    List<ChallengeProgress> challengeProgress;
    List<ChallengeData> inProgressChallenges;
    this.GetChallengeLists(out inProgressChallenges, out completedChallenges, out lockedChallenges, out challengeProgress);
    this.finalGroup.DestroyAllChildren();
    this.progress = new Transform[inProgressChallenges.Count + completedChallenges.Count + lockedChallenges.Count];
    int challengeIndex = 0;
    foreach (ChallengeData challengeData in inProgressChallenges)
    {
      ChallengeData challenge = challengeData;
      if (!this.cancellationToken.IsCancellationRequested)
      {
        List<ChallengeProgress> source = challengeProgress;
        ChallengeProgress progressAmount = source != null ? source.FirstOrDefault<ChallengeProgress>((Func<ChallengeProgress, bool>) (a => a.challengeName == challenge.name)) : (ChallengeProgress) null;
        await this.CreateInProgressEntry(challengeIndex++, challenge, progressAmount);
      }
      else
        break;
    }
    foreach (ChallengeData challengeData in completedChallenges)
    {
      if (!this.cancellationToken.IsCancellationRequested)
        await this.CreateCompletedEntry(challengeIndex++, challengeData);
      else
        break;
    }
    foreach (ChallengeData challengeData in lockedChallenges)
    {
      if (!this.cancellationToken.IsCancellationRequested)
        await this.CreateLockedEntry(challengeIndex++);
      else
        break;
    }
    foreach (Transform transform in this.progress)
    {
      if (!this.cancellationToken.IsCancellationRequested)
        transform.SetParent(this.finalGroup);
      else
        break;
    }
    this.progress = (Transform[]) null;
    this.tempGroup.DestroyAllChildren();
    this.running = false;
    completedChallenges = (List<ChallengeData>) null;
    lockedChallenges = (List<ChallengeData>) null;
    challengeProgress = (List<ChallengeProgress>) null;
  }

  public void GetChallengeLists(
    out List<ChallengeData> inProgressChallenges,
    out List<ChallengeData> completedChallenges,
    out List<ChallengeData> lockedChallenges,
    out List<ChallengeProgress> challengeProgress)
  {
    IEnumerable<ChallengeData> allChallenges = ChallengeSystem.GetAllChallenges();
    ChallengeSystem objectOfType1 = UnityEngine.Object.FindObjectOfType<ChallengeSystem>();
    bool flag1 = (UnityEngine.Object) objectOfType1 != (UnityEngine.Object) null;
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>(nameof (completedChallenges)) ?? new List<string>();
    if (flag1)
      stringList.AddRange(objectOfType1.saveRequired.Select<ChallengeData, string>((Func<ChallengeData, string>) (a => a.name)));
    ref List<ChallengeProgress> local = ref challengeProgress;
    ChallengeProgressSystem objectOfType2 = UnityEngine.Object.FindObjectOfType<ChallengeProgressSystem>();
    List<ChallengeProgress> challengeProgressList = objectOfType2 != null ? objectOfType2.progress : SaveSystem.LoadProgressData<List<ChallengeProgress>>(nameof (challengeProgress));
    local = challengeProgressList;
    completedChallenges = new List<ChallengeData>();
    lockedChallenges = new List<ChallengeData>();
    inProgressChallenges = flag1 ? objectOfType1.activeChallenges : new List<ChallengeData>();
    foreach (ChallengeData challengeData in allChallenges)
    {
      ChallengeData challenge = challengeData;
      if (stringList.Contains(challenge.name))
        completedChallenges.Add(challenge);
      else if (flag1)
      {
        if (challenge.hidden || !(bool) (UnityEngine.Object) inProgressChallenges.FirstOrDefault<ChallengeData>((Func<ChallengeData, bool>) (a => a.name == challenge.name)))
          lockedChallenges.Add(challenge);
      }
      else
      {
        bool flag2 = !challenge.hidden;
        if (flag2)
        {
          foreach (ChallengeData require in challenge.requires)
          {
            if (!stringList.Contains(require.name))
            {
              flag2 = false;
              break;
            }
          }
        }
        if (!flag2)
          lockedChallenges.Add(challenge);
        else
          inProgressChallenges.Add(challenge);
      }
    }
  }

  public async Task CreateInProgressEntry(
    int challengeIndex,
    ChallengeData challengeData,
    ChallengeProgress progressAmount)
  {
    GameObject task = await this.inProgressPrefab.InstantiateAsync(this.tempGroup).Task;
    this.progress[challengeIndex] = task.transform;
    if (this.cancellationToken.IsCancellationRequested)
      return;
    ChallengeEntry component = task.GetComponent<ChallengeEntry>();
    if (component == null)
      return;
    component.Assign(challengeData, false);
    ChallengeEntry challengeEntry = component;
    ChallengeProgress challengeProgress = progressAmount;
    int currentValue = challengeProgress != null ? challengeProgress.currentValue : 0;
    challengeEntry.SetProgress(currentValue);
  }

  public async Task CreateCompletedEntry(int challengeIndex, ChallengeData challengeData)
  {
    GameObject task = await this.completedPrefab.InstantiateAsync(this.tempGroup).Task;
    this.progress[challengeIndex] = task.transform;
    if (this.cancellationToken.IsCancellationRequested)
      return;
    task.GetComponent<ChallengeEntry>()?.Assign(challengeData, true);
  }

  public async Task CreateLockedEntry(int challengeIndex)
  {
    GameObject task = await this.lockedPrefab.InstantiateAsync(this.tempGroup).Task;
    this.progress[challengeIndex] = task.transform;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeListener
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

[CreateAssetMenu(fileName = "Challenge Listener", menuName = "Town/Challenge Listener")]
public class ChallengeListener : DataFile
{
  public ChallengeListener.CheckType checkType;
  public string stat;
  public bool hasKey;
  [ShowIf("hasKey")]
  public string key;
  public int target;

  public virtual bool Check(string stat, string key)
  {
    if (!(stat == this.stat))
      return false;
    return !this.hasKey || key == this.key;
  }

  public virtual bool CheckComplete(CampaignStats stats) => stats.Get(this.stat, this.hasKey ? this.key : "", 0) >= this.target;

  public virtual void Set(string challengeName, int oldValue, int newValue) => ChallengeListener.Add(challengeName, newValue - oldValue);

  public static void Add(string challengeName, int value) => ChallengeProgressSystem.AddProgress(challengeName, value);

  public enum CheckType
  {
    MidRun,
    EndOfRun,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeListenerHighest
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Challenge Listener Highest", menuName = "Town/Challenge Listener Highest")]
public class ChallengeListenerHighest : ChallengeListener
{
  public override void Set(string challengeName, int oldValue, int newValue)
  {
    if (newValue < this.target)
      return;
    ChallengeListener.Add(challengeName, 1);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeProgress
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Serializable]
public class ChallengeProgress
{
  public string challengeName;
  public int currentValue;
  public int originalValue;

  public ChallengeProgress()
  {
  }

  public ChallengeProgress(string challengeName, int value)
  {
    this.challengeName = challengeName;
    this.currentValue = value;
    this.originalValue = value;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeProgressDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ChallengeProgressDisplay : MonoBehaviour
{
  public TMP_Text text;
  public TMP_Text progressText;
  public ImageSprite icon;
  public ImageSprite back;
  public Image fill;
  public UnityEngine.Animator animator;

  public void Assign(ChallengeData challengeData)
  {
    this.text.text = string.Format(challengeData.text, (object) challengeData.goal);
    this.icon.SetSprite(challengeData.icon);
  }

  public void SetRewardText(ChallengeData challengeData) => this.text.text = challengeData.rewardText;

  public void SetFill(float current, int target)
  {
    this.fill.fillAmount = current / (float) target;
    this.progressText.text = string.Format("{0}/{1}", (object) Mathf.RoundToInt(current), (object) target);
  }

  public void SetRemainingText(ChallengeData challengeData, float current)
  {
    int num = Mathf.RoundToInt(current);
    this.text.text = string.Format(challengeData.text, (object) (challengeData.goal - num));
  }

  public void SetColor(Color color)
  {
    this.text.color = color;
    this.progressText.color = color;
    this.fill.color = color;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeProgressSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

public class ChallengeProgressSequence : MonoBehaviour
{
  [SerializeField]
  public ChallengeProgressDisplay progressPrefab;
  [SerializeField]
  public ChallengeProgressSequence.Profile[] profiles;
  [SerializeField]
  public Transform progressGroup;
  public readonly List<ChallengeProgressDisplay> panels = new List<ChallengeProgressDisplay>();
  [CompilerGenerated]
  public bool \u003Crunning\u003Ek__BackingField;

  public bool running
  {
    get => this.\u003Crunning\u003Ek__BackingField;
    set => this.\u003Crunning\u003Ek__BackingField = value;
  }

  public IEnumerator Start()
  {
    this.running = true;
    ChallengeProgressSystem objectOfType = UnityEngine.Object.FindObjectOfType<ChallengeProgressSystem>();
    if (objectOfType != null)
    {
      List<ChallengeProgress> progress1 = objectOfType.progress;
      if (progress1 != null)
      {
        foreach (ChallengeProgress progress2 in progress1.Where<ChallengeProgress>((Func<ChallengeProgress, bool>) (a => a.currentValue > a.originalValue)))
        {
          yield return (object) this.AddDisplay(progress2);
          yield return (object) new WaitForSeconds(0.5f);
        }
      }
    }
    this.running = false;
  }

  public IEnumerator AddDisplay(ChallengeProgress progress)
  {
    ChallengeProgressDisplay panel = UnityEngine.Object.Instantiate<ChallengeProgressDisplay>(this.progressPrefab, this.progressGroup);
    this.panels.Insert(0, panel);
    this.UpdatePanelPositions();
    ChallengeData challengeData = AddressableLoader.Get<ChallengeData>("ChallengeData", progress.challengeName);
    panel.Assign(challengeData);
    panel.SetFill((float) progress.originalValue, challengeData.goal);
    yield return (object) new WaitForSeconds(0.5f);
    int fillTo = Mathf.Min(challengeData.goal, progress.currentValue);
    float num = Mathf.Lerp(Mathf.Clamp((float) fillTo / (float) challengeData.goal, 0.0f, 1f) * 2f, 1f, 0.5f);
    Events.InvokeProgressStart((float) progress.originalValue / (float) challengeData.goal);
    panel.animator.SetBool("Increasing", true);
    LeanTween.value(panel.gameObject, (float) progress.originalValue, (float) fillTo, num).setEaseOutQuad().setOnUpdate((Action<float>) (a =>
    {
      panel.SetFill(a, challengeData.goal);
      panel.SetRemainingText(challengeData, a);
    }));
    yield return (object) new WaitForSeconds(num);
    panel.animator.SetBool("Increasing", false);
    Events.InvokeProgressStop();
    if (fillTo >= challengeData.goal)
    {
      Events.InvokeProgressDing();
      panel.animator.SetTrigger("Ping");
      panel.SetRewardText(challengeData);
      yield return (object) new WaitForSeconds(1.5f);
    }
  }

  public void UpdatePanelPositions()
  {
    float y = 0.0f;
    int a = 0;
    foreach (ChallengeProgressDisplay panel in this.panels)
    {
      ChallengeProgressSequence.Profile profile = this.profiles[Mathf.Min(a, this.profiles.Length - 1)];
      panel.SetColor(profile.color);
      if (a > 0)
      {
        LeanTween.cancel(panel.gameObject);
        LeanTween.moveLocal(panel.gameObject, new Vector3(0.0f, y, 0.0f), 0.2f).setEase(LeanTweenType.easeOutQuint);
        LeanTween.scale(panel.gameObject, Vector3.one * profile.scale, 0.2f).setEase(LeanTweenType.easeOutQuint);
        panel.icon.gameObject.SetActive(false);
        panel.back.gameObject.SetActive(false);
        panel.progressText.gameObject.SetActive(false);
      }
      y -= 1.3f * profile.scale;
      ++a;
    }
  }

  [Serializable]
  public struct Profile
  {
    public float scale;
    public Color color;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeProgressSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Events;

public class ChallengeProgressSystem : GameSystem
{
  public static ChallengeProgressSystem instance;
  public List<ChallengeProgress> progress;
  public bool saveRequired;

  public void Awake() => ChallengeProgressSystem.instance = this;

  public void OnEnable()
  {
    global::Events.OnCampaignSaved += new UnityAction(this.CheckSave);
    global::Events.OnCampaignLoaded += new UnityAction(this.Load);
    ChallengeProgressSystem.instance.progress = ChallengeProgressSystem.LoadProgress();
  }

  public void OnDisable()
  {
    global::Events.OnCampaignSaved -= new UnityAction(this.CheckSave);
    global::Events.OnCampaignLoaded -= new UnityAction(this.Load);
  }

  public static int GetProgress(string challengeName)
  {
    List<ChallengeProgress> progress = ChallengeProgressSystem.instance.progress;
    ChallengeProgress challengeProgress = progress != null ? progress.FirstOrDefault<ChallengeProgress>((Func<ChallengeProgress, bool>) (a => a.challengeName == challengeName)) : (ChallengeProgress) null;
    return challengeProgress == null ? 0 : challengeProgress.currentValue;
  }

  public static void AddProgress(string challengeName, int add)
  {
    ChallengeProgress challengeProgress1 = ChallengeProgressSystem.instance.progress.FirstOrDefault<ChallengeProgress>((Func<ChallengeProgress, bool>) (a => a.challengeName == challengeName));
    if (challengeProgress1 == null)
    {
      List<ChallengeProgress> source = SaveSystem.LoadProgressData<List<ChallengeProgress>>("challengeProgress", (List<ChallengeProgress>) null);
      ChallengeProgress challengeProgress2 = source != null ? source.FirstOrDefault<ChallengeProgress>((Func<ChallengeProgress, bool>) (a => a.challengeName == challengeName)) : (ChallengeProgress) null;
      challengeProgress1 = challengeProgress2 == null ? new ChallengeProgress(challengeName, 0) : new ChallengeProgress(challengeName, challengeProgress2.currentValue);
      ChallengeProgressSystem.instance.progress.Add(challengeProgress1);
    }
    ChallengeProgressSystem.instance.saveRequired = true;
    challengeProgress1.currentValue += add;
  }

  public static List<ChallengeProgress> LoadProgress()
  {
    List<ChallengeProgress> challengeProgressList = SaveSystem.LoadProgressData<List<ChallengeProgress>>("challengeProgress", new List<ChallengeProgress>());
    foreach (ChallengeProgress challengeProgress in challengeProgressList)
      challengeProgress.originalValue = challengeProgress.currentValue;
    return challengeProgressList;
  }

  public void CheckSave()
  {
    if (!this.saveRequired)
      return;
    if (Campaign.Data.GameMode.doSave)
      SaveSystem.SaveCampaignData<List<ChallengeProgress>>(Campaign.Data.GameMode, "challengeProgress", this.progress);
    SaveSystem.SaveProgressData<List<ChallengeProgress>>("challengeProgress", this.progress);
    this.saveRequired = false;
  }

  public void Load()
  {
    this.progress = ChallengeProgressSystem.LoadProgress();
    List<ChallengeProgress> challengeProgressList = SaveSystem.LoadCampaignData<List<ChallengeProgress>>(Campaign.Data.GameMode, "challengeProgress", (List<ChallengeProgress>) null);
    if (challengeProgressList == null)
      return;
    foreach (ChallengeProgress challengeProgress1 in challengeProgressList)
    {
      ChallengeProgress inCampaignData = challengeProgress1;
      ChallengeProgress challengeProgress2 = this.progress.FirstOrDefault<ChallengeProgress>((Func<ChallengeProgress, bool>) (a => a.challengeName == inCampaignData.challengeName));
      if (challengeProgress2 != null && inCampaignData.currentValue >= challengeProgress2.currentValue)
        challengeProgress2.originalValue = inCampaignData.originalValue;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeShrineSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;

public class ChallengeShrineSequence : BuildingSequenceWithUnlocks<ChallengeShrineSequence>
{
  public void Start() => this._OnStart();

  public void OnEnable()
  {
    List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
    Dictionary<string, string> dictionary = MetaprogressionSystem.Get<Dictionary<string, string>>("charms");
    for (int index = 0; index < this.challengeStones.Length; ++index)
    {
      ChallengeStone challengeStone = this.challengeStones[index];
      if (unlockedList.Contains(challengeStone.challenge.reward.name))
      {
        string str = dictionary[challengeStone.challenge.reward.name];
        CardUpgradeData upgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", str);
        challengeStone.Open(upgradeData);
        CardDiscoverSystem.CheckDiscoverCharm(str);
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeStone
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization.Components;
using UnityEngine.UI;

public class ChallengeStone : MonoBehaviour
{
  public ChallengeData challenge;
  [SerializeField]
  public GameObject door;
  [SerializeField]
  public CardCharmHolder charmHolder;
  [SerializeField]
  public UINavigationItem navItem;
  [SerializeField]
  public LocalizeStringEvent title;
  [SerializeField]
  public LocalizeStringEvent text;
  public static readonly Vector2 popUpOffset = new Vector2(1f, 0.0f);
  public static readonly Vector4 raycastPadding = new Vector4(0.0f, 0.0f, 0.0f, 0.0f);

  public void OnEnable()
  {
    if (!(bool) (Object) this.challenge)
      return;
    this.title.StringReference = this.challenge.titleKey;
    if (this.challenge.hidden)
      return;
    this.text.StringReference = this.challenge.textKey;
  }

  public void Open(CardUpgradeData upgradeData)
  {
    this.navItem.enabled = false;
    this.door.SetActive(false);
    UpgradeDisplay upgradeDisplay = this.charmHolder.Create(upgradeData);
    Image component1 = upgradeDisplay.GetComponent<Image>();
    if (component1 != null)
      component1.raycastPadding = ChallengeStone.raycastPadding;
    CardCharmInteraction component2 = upgradeDisplay.GetComponent<CardCharmInteraction>();
    if (component2 != null)
    {
      component2.popUpOffset = ChallengeStone.popUpOffset;
      component2.canDrag = false;
    }
    if (!this.challenge.hidden)
      return;
    this.text.StringReference = this.challenge.textKey;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChallengeSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Events;

public class ChallengeSystem : GameSystem
{
  public List<ChallengeData> activeChallenges;
  public List<ChallengeData> saveRequired;

  public void OnEnable()
  {
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>("completedChallenges", (List<string>) null) ?? new List<string>();
    this.activeChallenges = new List<ChallengeData>();
    foreach (ChallengeData allChallenge in ChallengeSystem.GetAllChallenges())
    {
      if (!stringList.Contains(allChallenge.name))
      {
        bool flag = true;
        foreach (ChallengeData require in allChallenge.requires)
        {
          if (!stringList.Contains(require.name))
          {
            flag = false;
            break;
          }
        }
        if (flag)
          this.activeChallenges.Add(allChallenge);
      }
    }
    global::Events.OnStatChanged += new UnityAction<string, string, int, int>(this.StatChanged);
    global::Events.OnOverallStatsSaved += new UnityAction<CampaignStats>(this.OverallStatsChanged);
    global::Events.OnCampaignSaved += new UnityAction(this.CheckSave);
  }

  public void OnDisable()
  {
    global::Events.OnStatChanged -= new UnityAction<string, string, int, int>(this.StatChanged);
    global::Events.OnOverallStatsSaved -= new UnityAction<CampaignStats>(this.OverallStatsChanged);
    global::Events.OnCampaignSaved -= new UnityAction(this.CheckSave);
  }

  public void StatChanged(string stat, string key, int oldValue, int newValue)
  {
    for (int index = this.activeChallenges.Count - 1; index >= 0; --index)
    {
      ChallengeData activeChallenge = this.activeChallenges[index];
      ChallengeListener listener = activeChallenge.listener;
      if (listener.checkType == ChallengeListener.CheckType.MidRun && listener.Check(stat, key))
      {
        listener.Set(activeChallenge.name, oldValue, newValue);
        if (ChallengeProgressSystem.GetProgress(activeChallenge.name) >= activeChallenge.goal)
        {
          this.activeChallenges.RemoveAt(index);
          this.saveRequired.Add(activeChallenge);
        }
      }
    }
  }

  public void OverallStatsChanged(CampaignStats stats)
  {
    bool flag = false;
    for (int index = this.activeChallenges.Count - 1; index >= 0; --index)
    {
      ChallengeData activeChallenge = this.activeChallenges[index];
      ChallengeListener listener = activeChallenge.listener;
      if (listener.checkType == ChallengeListener.CheckType.EndOfRun && listener.CheckComplete(stats))
      {
        ChallengeProgressSystem.AddProgress(activeChallenge.name, 1);
        if (ChallengeProgressSystem.GetProgress(activeChallenge.name) >= activeChallenge.goal)
        {
          this.activeChallenges.RemoveAt(index);
          this.saveRequired.Add(activeChallenge);
          flag = true;
        }
      }
    }
    if (!flag)
      return;
    this.CheckSave();
  }

  public void CheckSave()
  {
    if (this.saveRequired.Count <= 0)
      return;
    List<string> stringList1 = SaveSystem.LoadProgressData<List<string>>("completedChallenges", (List<string>) null) ?? new List<string>();
    List<string> stringList2 = SaveSystem.LoadProgressData<List<string>>("townNew", (List<string>) null) ?? new List<string>();
    List<string> stringList3 = SaveSystem.LoadProgressData<List<string>>("unlocked", (List<string>) null) ?? new List<string>();
    foreach (ChallengeData challengeData in this.saveRequired)
    {
      stringList1.Add(challengeData.name);
      stringList2.Add(challengeData.reward.name);
      stringList3.Add(challengeData.reward.name);
      global::Events.InvokeChallengeCompletedSaved(challengeData);
    }
    SaveSystem.SaveProgressData<List<string>>("completedChallenges", stringList1);
    SaveSystem.SaveProgressData<List<string>>("townNew", stringList2);
    SaveSystem.SaveProgressData<List<string>>("unlocked", stringList3);
    this.saveRequired.Clear();
  }

  public static IEnumerable<ChallengeData> GetAllChallenges() => AddressableLoader.GetGroup<ChallengeData>("ChallengeData").Where<ChallengeData>((Func<ChallengeData, bool>) (a => a.reward.IsActive));
}
﻿// Decompiled with JetBrains decompiler
// Type: ChangePhaseAnimationSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UI;

public class ChangePhaseAnimationSystem : GameSystem
{
  [SerializeField]
  public Transform container;
  [SerializeField]
  public float zoomAmount = 3f;
  [SerializeField]
  public Image fade;
  [SerializeField]
  public Color fadeColor;
  [SerializeField]
  public Color flashColor;
  [SerializeField]
  public Image flash;
  [SerializeField]
  public AnimationCurve flashCurve;
  public float slowmo = 0.1f;
  public float durationIn = 0.3f;
  public float durationOut = 0.9f;
  public readonly List<ChangePhaseAnimationSystem.Target> targets = new List<ChangePhaseAnimationSystem.Target>();

  public void Assign(Entity target)
  {
    this.targets.Add(new ChangePhaseAnimationSystem.Target(target));
    target.transform.SetParent(this.container, true);
    target.ResetDrawOrder();
  }

  public void ClearFocus()
  {
    foreach (ChangePhaseAnimationSystem.Target target in this.targets)
    {
      if ((bool) (UnityEngine.Object) target.entity && (bool) (UnityEngine.Object) target.entity.transform && (bool) (UnityEngine.Object) target.previousParent)
        target.entity.transform.SetParent(target.previousParent);
    }
    this.targets.Clear();
  }

  public void RemoveTarget(Entity entity)
  {
    for (int index = this.targets.Count - 1; index >= 0; --index)
    {
      if ((UnityEngine.Object) this.targets[index].entity == (UnityEngine.Object) entity)
        this.targets.RemoveAt(index);
    }
  }

  public void Flash()
  {
    ScreenFlashSystem.SetDrawOrder("ParticlesFront", 0);
    ScreenFlashSystem.SetColour(this.flashColor);
    ScreenFlashSystem.Run(0.2f);
  }

  public IEnumerator Focus(Entity target)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    ChangePhaseAnimationSystem phaseAnimationSystem = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      LeanTween.value(phaseAnimationSystem.gameObject, Time.timeScale, 1f, 0.25f).setEase(LeanTweenType.linear).setOnUpdate(new Action<float>(Events.InvokeTimeScaleChange));
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    phaseAnimationSystem.Assign(target);
    HitFlashSystem.Remove(target);
    LeanTween.value(phaseAnimationSystem.gameObject, Time.timeScale, phaseAnimationSystem.slowmo, 0.05f).setEase(LeanTweenType.linear).setOnUpdate(new Action<float>(Events.InvokeTimeScaleChange));
    LeanTween.value(phaseAnimationSystem.gameObject, Time.timeScale, 1f, 0.25f).setDelay(phaseAnimationSystem.durationIn).setEase(LeanTweenType.linear).setOnUpdate(new Action<float>(Events.InvokeTimeScaleChange));
    LeanTween.value(phaseAnimationSystem.gameObject, phaseAnimationSystem.fade.color.a, phaseAnimationSystem.fadeColor.a, phaseAnimationSystem.durationIn).setEase(LeanTweenType.easeInOutQuint).setOnUpdate(new Action<float>(phaseAnimationSystem.\u003CFocus\u003Eb__15_0));
    Vector3 to = target.transform.position.WithZ(phaseAnimationSystem.zoomAmount);
    LeanTween.cancel(References.MinibossCameraMover.gameObject);
    LeanTween.move(References.MinibossCameraMover.gameObject, to, Mathf.Min(phaseAnimationSystem.durationIn, 0.4f)).setEase(LeanTweenType.easeOutBack);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) Sequences.Wait(phaseAnimationSystem.durationIn);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public IEnumerator UnFocus()
  {
    ChangePhaseAnimationSystem phaseAnimationSystem = this;
    yield return (object) Sequences.Wait(0.1f);
    LeanTween.moveLocal(References.MinibossCameraMover.gameObject, Vector3.zero, phaseAnimationSystem.durationOut).setEase(LeanTweenType.easeOutBack);
    LeanTween.value(phaseAnimationSystem.gameObject, phaseAnimationSystem.fade.color.a, 0.0f, 0.25f).setEase(LeanTweenType.easeInOutQuart).setOnUpdate(new Action<float>(phaseAnimationSystem.\u003CUnFocus\u003Eb__16_0));
    yield return (object) Sequences.Wait(phaseAnimationSystem.durationOut);
    phaseAnimationSystem.ClearFocus();
    PauseMenu.Unblock();
    DeckpackBlocker.Unblock();
  }

  [CompilerGenerated]
  public void \u003CFocus\u003Eb__15_0(float a) => this.fade.color = this.fade.color.With(alpha: a);

  [CompilerGenerated]
  public void \u003CUnFocus\u003Eb__16_0(float a) => this.fade.color = this.fade.color.With(alpha: a);

  public class Target
  {
    public Entity entity;
    public Transform previousParent;

    public Target(Entity entity)
    {
      this.entity = entity;
      this.previousParent = entity.transform.parent;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Character
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using UnityEngine;

public class Character : MonoBehaviour, ISaveable<CharacterSaveData>
{
  public PlayerData data;
  public string title;
  public int team = 1;
  public Entity entity;
  [HorizontalLine(2f, EColor.Gray)]
  public CardContainer drawContainer;
  public CardContainer handContainer;
  public CardContainer discardContainer;
  public CardContainer reserveContainer;
  public bool freeAction;
  public bool endTurn;
  public bool autoTriggerUnits = true;

  public void Assign(PlayerData data) => this.data = data;

  public int GetCompanionCount() => this.data.inventory.deck.FindAll((Predicate<CardData>) (a => a.cardType.name == "Friendly")).Count;

  public void GainGold(int amount)
  {
    if (!(bool) (UnityEngine.Object) this.data?.inventory)
      return;
    this.data.inventory.AddGold(amount);
    this.entity.PromptUpdate();
  }

  public void SpendGold(int amount)
  {
    if (!(bool) (UnityEngine.Object) this.data?.inventory)
      return;
    this.data.inventory.gold -= amount;
    this.entity.PromptUpdate();
    Events.InvokeSpendGold(amount);
  }

  [Button("Gain 10 Gold", EButtonEnableMode.Always)]
  public void Gain10Gold() => this.GainGold(10);

  [Button("Gain 100 Gold", EButtonEnableMode.Always)]
  public void Gain100Gold() => this.GainGold(100);

  public CharacterSaveData Save() => new CharacterSaveData(this);

  public override bool Equals(object other) => other is Character character && this.team == character.team;
}
﻿// Decompiled with JetBrains decompiler
// Type: CharacterAvatar
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using Unity.Collections;
using UnityEngine;
using UnityEngine.UI;

public class CharacterAvatar : MonoBehaviour
{
  public AvatarPart root;
  public Texture2D paletteTexture;
  public Material recolourMaterial;
  public Material recolourMaterialCopy;

  public void OnDestroy()
  {
    if ((bool) (UnityEngine.Object) this.paletteTexture)
      UnityEngine.Object.Destroy((UnityEngine.Object) this.paletteTexture);
    if (!(bool) (UnityEngine.Object) this.recolourMaterialCopy)
      return;
    UnityEngine.Object.Destroy((UnityEngine.Object) this.recolourMaterialCopy);
  }

  public void UpdateDisplay(CharacterData data)
  {
    CharacterType type = AssetLoader.Lookup<CharacterType>("CharacterTypes", data.race + data.gender);
    if (!(bool) (UnityEngine.Object) type)
      return;
    Transform anchor1 = this.root.GetAnchor("body");
    if (anchor1 == null)
      return;
    anchor1.DestroyAllChildren();
    UnityEngine.Object.Destroy((UnityEngine.Object) this.paletteTexture);
    GameObject prefab1 = CharacterAvatar.GetPrefab(type, "Body", data.bodyIndex);
    if (!(bool) (UnityEngine.Object) prefab1)
      return;
    GameObject gameObject1 = UnityEngine.Object.Instantiate<GameObject>(prefab1, anchor1);
    Transform transform = gameObject1.transform;
    transform.localScale = (Vector3) ((Vector2) transform.localScale * data.bodyScale);
    AvatarPart component1 = gameObject1.GetComponent<AvatarPart>();
    if (component1 != null)
    {
      GameObject prefab2 = CharacterAvatar.GetPrefab(type, "Head", data.headIndex);
      if ((bool) (UnityEngine.Object) prefab2)
      {
        Transform anchor2 = component1.GetAnchor("head");
        if (anchor2 != null)
        {
          GameObject gameObject2 = UnityEngine.Object.Instantiate<GameObject>(prefab2, anchor2);
          gameObject2.transform.localScale = (Vector3) ((Vector2) gameObject2.transform.localScale * data.headScale / (Vector2) gameObject1.transform.localScale);
          AvatarPart component2 = gameObject2.GetComponent<AvatarPart>();
          if (component2 != null)
          {
            Sprite sprite1 = CharacterAvatar.GetSprite(type, "Mouth", data.mouthIndex);
            Sprite sprite2 = CharacterAvatar.GetSprite(type, "Nose", data.noseIndex);
            Sprite sprite3 = CharacterAvatar.GetSprite(type, "Eyebrows", data.eyebrowIndex);
            Sprite sprite4 = CharacterAvatar.GetSprite(type, "Ears", data.earIndex);
            Sprite sprite5 = CharacterAvatar.GetSprite(type, "HairTop", data.hairTopIndex);
            Sprite sprite6 = CharacterAvatar.GetSprite(type, "HairBack", data.hairBackIndex);
            Sprite sprite7 = CharacterAvatar.GetSprite(type, "Beard", data.beardIndex);
            Sprite sprite8 = CharacterAvatar.GetSprite(type, "Markings", data.markingsIndex);
            CharacterAvatar.SetSprite(type, component2, "mouth", sprite1, data.mouthScale);
            CharacterAvatar.SetSprite(type, component2, "nose", sprite2, data.noseScale);
            CharacterAvatar.SetSprite(type, component2, "eyebrows", sprite3, data.eyebrowScale);
            CharacterAvatar.SetSprite(type, component2, "ears", sprite4, data.earScale);
            CharacterAvatar.SetSprite(type, component2, "hairtop", sprite5, data.hairScale);
            CharacterAvatar.SetSprite(type, component2, "hairback", sprite6, data.hairScale);
            CharacterAvatar.SetSprite(type, component2, "beard", sprite7, Vector2.one);
            CharacterAvatar.SetSprite(type, component2, "markings", sprite8, Vector2.one);
            GameObject prefab3 = CharacterAvatar.GetPrefab(type, "Eyes", data.eyesIndex);
            if ((bool) (UnityEngine.Object) prefab3)
            {
              Transform anchor3 = component2.GetAnchor("eyes");
              if (anchor3 != null)
                UnityEngine.Object.Instantiate<GameObject>(prefab3, anchor3);
            }
          }
        }
      }
      GameObject prefab4 = CharacterAvatar.GetPrefab(type, "Weapon1", data.weapon1Index);
      if (prefab4 != null)
      {
        Transform anchor4 = component1.GetAnchor("weapon1");
        if (anchor4 != null)
        {
          UnityEngine.Object.Instantiate<GameObject>(prefab4, anchor4);
          goto label_16;
        }
      }
      GameObject prefab5 = CharacterAvatar.GetPrefab(type, "Weapon2", data.weapon2Index);
      if (prefab5 != null)
      {
        Transform anchor5 = component1.GetAnchor("weapon2");
        if (anchor5 != null)
          UnityEngine.Object.Instantiate<GameObject>(prefab5, anchor5);
      }
    }
label_16:
    Texture2D texture2D = new Texture2D(25, 1, TextureFormat.RGBA32, false);
    texture2D.filterMode = FilterMode.Point;
    this.paletteTexture = texture2D;
    NativeArray<Color32> rawTextureData = this.paletteTexture.GetRawTextureData<Color32>();
    ColorSet colorSet1 = CharacterAvatar.GetColorSet(type, "ClothingColour", data.clothingColorIndex);
    ColorSet colorSet2 = CharacterAvatar.GetColorSet(type, "HairColour", data.hairColorIndex);
    ColorSet colorSet3 = CharacterAvatar.GetColorSet(type, "EyeColour", data.eyeColorIndex);
    ColorSet colorSet4 = CharacterAvatar.GetColorSet(type, "SkinColour", data.skinColorIndex);
    ColorSet colorSet5 = CharacterAvatar.GetColorSet(type, "MarkingColour", data.markingsColorIndex);
    CharacterAvatar.SetTexturePixels(type, this.paletteTexture, rawTextureData, 0, colorSet1);
    CharacterAvatar.SetTexturePixels(type, this.paletteTexture, rawTextureData, 4, colorSet2);
    CharacterAvatar.SetTexturePixels(type, this.paletteTexture, rawTextureData, 13, colorSet3);
    CharacterAvatar.SetTexturePixels(type, this.paletteTexture, rawTextureData, 14, colorSet4);
    CharacterAvatar.SetTexturePixels(type, this.paletteTexture, rawTextureData, 17, colorSet5);
    this.paletteTexture.Apply();
    if ((bool) (UnityEngine.Object) this.recolourMaterialCopy)
      UnityEngine.Object.Destroy((UnityEngine.Object) this.recolourMaterialCopy);
    this.recolourMaterialCopy = UnityEngine.Object.Instantiate<Material>(this.recolourMaterial);
    this.recolourMaterialCopy.SetTexture("_PaletteTex", (Texture) this.paletteTexture);
    foreach (Image componentsInChild in this.GetComponentsInChildren<Image>())
    {
      if (!componentsInChild.TryGetComponent<Mask>(out Mask _))
        componentsInChild.material = this.recolourMaterialCopy;
    }
  }

  public static GameObject GetPrefab(CharacterType type, string name, int index)
  {
    if (index >= 0)
    {
      CharacterType.PrefabGroup prefabGroup = ((IEnumerable<CharacterType.PrefabGroup>) type.prefabs).FirstOrDefault<CharacterType.PrefabGroup>((Func<CharacterType.PrefabGroup, bool>) (a => a.name == name));
      if (prefabGroup != null)
        return prefabGroup.collection[index];
    }
    return (GameObject) null;
  }

  public static Sprite GetSprite(CharacterType type, string name, int index)
  {
    if (index >= 0)
    {
      CharacterType.SpriteGroup spriteGroup = ((IEnumerable<CharacterType.SpriteGroup>) type.sprites).FirstOrDefault<CharacterType.SpriteGroup>((Func<CharacterType.SpriteGroup, bool>) (a => a.name == name));
      if (spriteGroup != null)
        return spriteGroup.collection[index];
    }
    return (Sprite) null;
  }

  public static ColorSet GetColorSet(CharacterType type, string name, int index)
  {
    if (index >= 0)
    {
      CharacterType.ColorSetGroup colorSetGroup = ((IEnumerable<CharacterType.ColorSetGroup>) type.colorSets).FirstOrDefault<CharacterType.ColorSetGroup>((Func<CharacterType.ColorSetGroup, bool>) (a => a.name == name));
      if (colorSetGroup != null)
        return colorSetGroup.collection[index];
    }
    return (ColorSet) null;
  }

  public static void SetSprite(
    CharacterType type,
    AvatarPart part,
    string partName,
    Sprite sprite,
    Vector2 scale)
  {
    AvatarPart.Part part1 = part.Get(partName);
    if (!(bool) (UnityEngine.Object) sprite)
      part1.Disable();
    else
      part1.Set(sprite, scale);
  }

  public static void SetSprite(
    CharacterType type,
    AvatarPart part,
    Sprite sprite,
    Vector2 scale,
    params string[] partNames)
  {
    foreach (string partName in partNames)
    {
      AvatarPart.Part part1 = part.Get(partName);
      if (!(bool) (UnityEngine.Object) sprite)
        part1.Disable();
      else
        part1.Set(sprite, scale);
    }
  }

  public static void SetTexturePixels(
    CharacterType type,
    Texture2D texture,
    NativeArray<Color32> data,
    int startX,
    ColorSet colorSet)
  {
    foreach (Color color in colorSet.set)
    {
      Color32 color32 = (Color32) color;
      data[startX++] = color32;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CharacterAvatarMoveToCard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CharacterAvatarMoveToCard : MonoBehaviour
{
  [SerializeField]
  public Vector3 inCardPosition;
  [SerializeField]
  public Vector3 inCardRotation;
  [SerializeField]
  public Vector3 inCardScale;

  public void MoveToCard(Card card)
  {
    this.transform.SetParent(card.mainImage.transform);
    this.transform.localPosition = this.inCardPosition;
    this.transform.localEulerAngles = this.inCardRotation;
    this.transform.localScale = this.inCardScale;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CharacterData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[Serializable]
public class CharacterData
{
  public string title;
  public string race;
  public string gender;
  [Header("Part Indices")]
  public int headIndex;
  public int bodyIndex;
  public int weapon1Index;
  public int weapon2Index;
  public int eyesIndex;
  public int mouthIndex;
  public int noseIndex;
  public int eyebrowIndex;
  public int earIndex;
  public int hairBackIndex;
  public int hairTopIndex;
  public int beardIndex;
  public int markingsIndex;
  public int clothingColorIndex;
  public int hairColorIndex;
  public int eyeColorIndex;
  public int skinColorIndex;
  public int markingsColorIndex;
  [Header("Scale")]
  public Vector2 bodyScale = Vector2.one;
  public Vector2 headScale = Vector2.one;
  public Vector2 eyeScale = Vector2.one;
  public Vector2 eyebrowScale = Vector2.one;
  public Vector2 noseScale = Vector2.one;
  public Vector2 mouthScale = Vector2.one;
  public Vector2 earScale = Vector2.one;
  public Vector2 hairScale = Vector2.one;

  public void Randomize(
    CharacterType type,
    bool lockTitle = false,
    bool lockBody = false,
    bool lockHead = false,
    bool lockEyes = false,
    bool lockEyebrows = false,
    bool lockMouth = false,
    bool lockNose = false,
    bool lockEars = false,
    bool lockHair = false,
    bool lockHairBack = false,
    bool lockBeard = false,
    bool lockHairColour = false,
    bool lockEyeColour = false,
    bool lockSkinColour = false,
    bool lockClothingColour = false,
    bool lockWeapon = false,
    bool lockMarkings = false,
    bool lockMarkingsColour = false)
  {
    if (!lockTitle)
      this.title = Names.Pull(this.race, this.gender);
    this.SetRandomPrefab(lockBody, type, "Body", ref this.bodyIndex);
    this.SetRandomPrefab(lockHead, type, "Head", ref this.headIndex);
    this.SetRandomPrefab(lockWeapon, type, "Weapon1", ref this.weapon1Index);
    this.SetRandomPrefab(lockWeapon, type, "Weapon2", ref this.weapon2Index);
    this.SetRandomPrefab(lockEyes, type, "Eyes", ref this.eyesIndex);
    this.SetRandomSprite(lockEyebrows, type, "Eyebrows", ref this.eyebrowIndex);
    this.SetRandomSprite(lockMouth, type, "Mouth", ref this.mouthIndex);
    this.SetRandomSprite(lockNose, type, "Nose", ref this.noseIndex);
    this.SetRandomSprite(lockEars, type, "Ears", ref this.earIndex);
    this.SetRandomSprite(lockHair, type, "HairTop", ref this.hairTopIndex);
    this.SetRandomSprite(lockHairBack, type, "HairBack", ref this.hairBackIndex);
    this.SetRandomSprite(lockBeard, type, "Beard", ref this.beardIndex);
    this.SetRandomSprite(lockMarkings, type, "Markings", ref this.markingsIndex);
    this.SetRandomColorSet(lockHairColour, type, "HairColour", ref this.hairColorIndex);
    this.SetRandomColorSet(lockEyeColour, type, "EyeColour", ref this.eyeColorIndex);
    this.SetRandomColorSet(lockSkinColour, type, "SkinColour", ref this.skinColorIndex);
    this.SetRandomColorSet(lockClothingColour, type, "ClothingColour", ref this.clothingColorIndex);
    this.SetRandomColorSet(lockMarkingsColour, type, "MarkingColour", ref this.markingsColorIndex);
    this.SetScale(false, type, "Body", ref this.bodyScale);
    this.SetScale(false, type, "Head", ref this.headScale);
    this.SetScale(false, type, "Eyes", ref this.eyeScale);
    this.SetScale(false, type, "Mouth", ref this.mouthScale);
    this.SetScale(false, type, "Nose", ref this.noseScale);
    this.SetScale(false, type, "Eyebrows", ref this.eyebrowScale);
    this.SetScale(false, type, "Ears", ref this.earScale);
    this.SetScale(false, type, "Hair", ref this.hairScale);
  }

  public void SetRandomPrefab(bool locked, CharacterType type, string name, ref int index)
  {
    if (locked)
      return;
    CharacterType.PrefabGroup prefabGroup = ((IEnumerable<CharacterType.PrefabGroup>) type.prefabs).FirstOrDefault<CharacterType.PrefabGroup>((Func<CharacterType.PrefabGroup, bool>) (a => a.name == name));
    if (prefabGroup == null)
      return;
    index = prefabGroup.collection.RandomIndex();
  }

  public void SetRandomSprite(bool locked, CharacterType type, string name, ref int index)
  {
    if (locked)
      return;
    CharacterType.SpriteGroup spriteGroup = ((IEnumerable<CharacterType.SpriteGroup>) type.sprites).FirstOrDefault<CharacterType.SpriteGroup>((Func<CharacterType.SpriteGroup, bool>) (a => a.name == name));
    if (spriteGroup == null)
      return;
    index = spriteGroup.collection.RandomIndex();
  }

  public void SetRandomColorSet(bool locked, CharacterType type, string name, ref int index)
  {
    if (locked)
      return;
    CharacterType.ColorSetGroup colorSetGroup = ((IEnumerable<CharacterType.ColorSetGroup>) type.colorSets).FirstOrDefault<CharacterType.ColorSetGroup>((Func<CharacterType.ColorSetGroup, bool>) (a => a.name == name));
    if (colorSetGroup == null)
      return;
    index = colorSetGroup.collection.RandomIndex();
  }

  public void SetScale(bool locked, CharacterType type, string name, ref Vector2 scale)
  {
    if (locked)
      return;
    CharacterType.ScaleRange scaleRange = ((IEnumerable<CharacterType.ScaleRange>) type.scales).FirstOrDefault<CharacterType.ScaleRange>((Func<CharacterType.ScaleRange, bool>) (a => a.name == name));
    if (scaleRange == null)
      return;
    scale = scaleRange.Convert();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CharacterDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using UnityEngine;

public class CharacterDisplay : EntityDisplay
{
  [SerializeField]
  public int team = 1;
  public GoldDisplay goldDisplay;
  [Space]
  public DeckDisplay deckDisplay;
  public HandOverlay handOverlay;
  public int currentEffectBonus;
  public float currentEffectFactor;
  public Character _character;

  public bool IsDeckpackOpen => Deckpack.IsOpen || this.deckDisplay.companionLimitSequence.gameObject.activeSelf;

  public Character character
  {
    get
    {
      if (!(bool) (UnityEngine.Object) this._character)
        this._character = this.entity.GetComponent<Character>();
      return this._character;
    }
  }

  public static void FindAndAssign(Character character)
  {
    foreach (CharacterDisplay characterDisplay in UnityEngine.Object.FindObjectsOfType<CharacterDisplay>())
    {
      if (!(bool) (UnityEngine.Object) characterDisplay.entity && characterDisplay.team == character.team)
      {
        characterDisplay.Assign(character);
        return;
      }
    }
    throw new Exception("Could not find CharacterDisplay for Character [" + character.name + "]");
  }

  public void Assign(Character character)
  {
    Debug.Log((object) string.Format("[{0}] assigned to {1}", (object) character.name, (object) this));
    this.entity = character.entity;
    this.deckDisplay?.SetOwner(character);
    this.handOverlay?.SetOwner(character);
    character.entity.display = (EntityDisplay) this;
    character.entity.PromptUpdate();
  }

  public void UnAssign() => this.entity = (Entity) null;

  public override IEnumerator UpdateDisplay(bool doPingIcons = true)
  {
    CharacterDisplay characterDisplay = this;
    characterDisplay.ClearStatusIcons();
    if ((bool) (UnityEngine.Object) characterDisplay.goldDisplay && (bool) (UnityEngine.Object) characterDisplay.character)
      characterDisplay.goldDisplay.Set(characterDisplay.character.data.inventory.gold.Value);
    if (characterDisplay.entity.effectBonus != characterDisplay.currentEffectBonus || (double) characterDisplay.entity.effectFactor != (double) characterDisplay.currentEffectFactor)
    {
      characterDisplay.currentEffectBonus = characterDisplay.entity.effectBonus;
      characterDisplay.currentEffectFactor = characterDisplay.entity.effectFactor;
      yield return (object) StatusEffectSystem.EffectBonusChangedEvent(characterDisplay.entity);
    }
  }

  public void ToggleInventory()
  {
    if (Deckpack.IsOpen)
    {
      Deckpack.Close();
      this.deckDisplay.displaySequence.End();
    }
    else
    {
      Deckpack.Open();
      this.deckDisplay.displaySequence.Begin();
    }
  }

  public void OpenInventory()
  {
    if (Deckpack.IsOpen)
      return;
    this.ToggleInventory();
  }

  public void CloseInventory()
  {
    if (!Deckpack.IsOpen)
      return;
    this.ToggleInventory();
  }

  [Button(null, EButtonEnableMode.Always)]
  public void ForceUpdateDisplay() => this.StartCoroutine(this.UpdateDisplay(true));
}
﻿// Decompiled with JetBrains decompiler
// Type: CharacterExt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;

public static class CharacterExt
{
  public static void OrderNextCards(this Character character, string[] nextCardNames)
  {
    CardContainer drawContainer = character.drawContainer;
    List<Entity> entityList = new List<Entity>();
    foreach (string nextCardName in nextCardNames)
    {
      string cardName = nextCardName;
      Entity entity = drawContainer.FirstOrDefault<Entity>((Func<Entity, bool>) (a => a.name == cardName));
      if ((UnityEngine.Object) entity != (UnityEngine.Object) null)
      {
        entityList.Insert(0, entity);
        drawContainer.Remove(entity);
      }
    }
    foreach (Entity entity in entityList)
      drawContainer.Add(entity);
    drawContainer.TweenChildPositions();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CharacterRewards
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

public class CharacterRewards : MonoBehaviour
{
  public readonly Dictionary<string, CharacterRewards.Pool> poolLookup = new Dictionary<string, CharacterRewards.Pool>();

  public void Populate(ClassData classData)
  {
    this.poolLookup.Clear();
    foreach (RewardPool rewardPool in classData.rewardPools)
      this.Add(rewardPool);
  }

  public void Add(RewardPool rewardPool)
  {
    if (!this.poolLookup.ContainsKey(rewardPool.type))
      this.poolLookup[rewardPool.type] = new CharacterRewards.Pool();
    for (int index = 0; index < rewardPool.copies; ++index)
    {
      this.poolLookup[rewardPool.type].Add((IEnumerable<DataFile>) rewardPool.list);
      Debug.Log((object) string.Format("Character Reward Pool [{0}] Populated with [{1}] items from [{2}]", (object) rewardPool.type, (object) rewardPool.list.Count, (object) rewardPool.name));
    }
  }

  public List<DataFile> GetItemsInPool(string name)
  {
    CharacterRewards.Pool pool;
    return this.poolLookup.TryGetValue(name, out pool) ? pool.list : (List<DataFile>) null;
  }

  public void Add(string poolName, IEnumerable<DataFile> items)
  {
    if (!this.poolLookup.ContainsKey(poolName))
      this.poolLookup[poolName] = new CharacterRewards.Pool();
    this.poolLookup[poolName].Add(items);
  }

  public void RemoveLockedCards()
  {
    List<UnlockData> remainingUnlocks = MetaprogressionSystem.GetRemainingUnlocks();
    CharacterRewards.Pool pool1;
    if (this.poolLookup.TryGetValue("Items", out pool1))
    {
      List<string> lockedItems = MetaprogressionSystem.GetLockedItems(remainingUnlocks);
      Debug.Log((object) ("Locked Items: [" + string.Join(", ", (IEnumerable<string>) lockedItems) + "]"));
      pool1.Remove((IEnumerable<string>) lockedItems);
    }
    CharacterRewards.Pool pool2;
    if (this.poolLookup.TryGetValue("Units", out pool2))
    {
      List<string> lockedCompanions = MetaprogressionSystem.GetLockedCompanions(remainingUnlocks);
      Debug.Log((object) ("Locked Companions: [" + string.Join(", ", (IEnumerable<string>) lockedCompanions) + "]"));
      pool2.Remove((IEnumerable<string>) lockedCompanions);
    }
    CharacterRewards.Pool pool3;
    if (!this.poolLookup.TryGetValue("Charms", out pool3))
      return;
    List<string> lockedCharms = MetaprogressionSystem.GetLockedCharms(remainingUnlocks);
    Debug.Log((object) ("Locked Charms: [" + string.Join(", ", (IEnumerable<string>) lockedCharms) + "]"));
    pool3.Remove((IEnumerable<string>) lockedCharms);
  }

  public void RemoveCardsFromStartingDeck()
  {
    HashSet<string> stringSet1 = new HashSet<string>();
    HashSet<string> stringSet2 = new HashSet<string>();
    foreach (CardData cardData in References.PlayerData.inventory.deck)
    {
      switch (cardData.cardType.name)
      {
        case "Friendly":
          stringSet2.Add(cardData.name);
          continue;
        case "Item":
        case "Clunker":
          stringSet1.Add(cardData.name);
          continue;
        default:
          continue;
      }
    }
    if (stringSet1.Count > 0)
    {
      Debug.Log((object) ("Removing Items: [" + string.Join(", ", (IEnumerable<string>) stringSet1) + "]"));
      (this.poolLookup.ContainsKey("Items") ? this.poolLookup["Items"] : (CharacterRewards.Pool) null)?.Remove((IEnumerable<string>) stringSet1);
    }
    if (stringSet2.Count <= 0)
      return;
    Debug.Log((object) ("Removing Units: [" + string.Join(", ", (IEnumerable<string>) stringSet2) + "]"));
    (this.poolLookup.ContainsKey("Units") ? this.poolLookup["Units"] : (CharacterRewards.Pool) null)?.Remove((IEnumerable<string>) stringSet2);
  }

  public void RemoveCompanionsInFinalBossBattle()
  {
    CharacterRewards.Pool pool = (CharacterRewards.Pool) null;
    CardSaveData[] cardSaveDataArray = SaveSystem.LoadProgressData<CardSaveData[]>("finalBossDeck", (CardSaveData[]) null);
    if (cardSaveDataArray == null)
      return;
    foreach (CardSaveData cardSaveData in cardSaveDataArray)
    {
      CardData cardData = cardSaveData.Peek();
      if ((bool) (UnityEngine.Object) cardData && cardData.cardType.name == "Friendly")
      {
        Debug.Log((object) ("Removing [" + cardData.name + "]"));
        if (pool == null)
          pool = this.poolLookup.ContainsKey("Units") ? this.poolLookup["Units"] : (CharacterRewards.Pool) null;
        pool?.Remove(cardData.name);
      }
    }
  }

  public T Pull<T>(object pulledBy, string poolName) where T : DataFile => this.Pull<T>(pulledBy, poolName, 1)[0];

  public T[] Pull<T>(object pulledBy, string poolName, int itemCount, bool allowDuplicates = false) where T : DataFile
  {
    List<DataFile> source = Events.PullRewards(pulledBy, poolName, ref itemCount);
    if (this.poolLookup.ContainsKey(poolName))
    {
      CharacterRewards.Pool pool = this.poolLookup[poolName];
      if (source.Count > 0)
      {
        foreach (DataFile dataFile in source)
          pool.PullOut(dataFile);
      }
      if (itemCount > 0)
        source.AddRange((IEnumerable<DataFile>) pool.Pull(itemCount, allowDuplicates));
    }
    return source.Cast<T>().ToArray<T>();
  }

  public T[] Pull<T>(
    object pulledBy,
    string poolName,
    int itemCount,
    bool allowDuplicates,
    Predicate<DataFile> match)
    where T : DataFile
  {
    List<DataFile> source = Events.PullRewards(pulledBy, poolName, ref itemCount);
    if (this.poolLookup.ContainsKey(poolName))
    {
      CharacterRewards.Pool pool = this.poolLookup[poolName];
      if (source.Count > 0)
      {
        foreach (DataFile dataFile in source)
          pool.PullOut(dataFile);
      }
      if (itemCount > 0)
        source.AddRange((IEnumerable<DataFile>) pool.Pull(itemCount, allowDuplicates, match));
    }
    return source.Cast<T>().ToArray<T>();
  }

  public T[] GetFromOriginalList<T>(
    object pulledBy,
    string poolName,
    int itemCount,
    bool allowDuplicates)
    where T : DataFile
  {
    List<DataFile> source = Events.PullRewards(pulledBy, poolName, ref itemCount);
    if (this.poolLookup.ContainsKey(poolName))
    {
      CharacterRewards.Pool pool = this.poolLookup[poolName];
      if (itemCount > 0)
        source.AddRange((IEnumerable<DataFile>) pool.GetFromOriginalList(itemCount, allowDuplicates));
    }
    return source.Cast<T>().ToArray<T>();
  }

  public T[] GetFromOriginalList<T>(
    object pulledBy,
    string poolName,
    int itemCount,
    bool allowDuplicates,
    Predicate<DataFile> match)
    where T : DataFile
  {
    List<DataFile> source = Events.PullRewards(pulledBy, poolName, ref itemCount);
    if (this.poolLookup.ContainsKey(poolName))
    {
      CharacterRewards.Pool pool = this.poolLookup[poolName];
      if (itemCount > 0)
        source.AddRange((IEnumerable<DataFile>) pool.GetFromOriginalList(itemCount, allowDuplicates, match));
    }
    return source.Cast<T>().ToArray<T>();
  }

  public void PullOut(string poolName, IEnumerable<DataFile> items)
  {
    CharacterRewards.Pool pool;
    if (!this.poolLookup.TryGetValue(poolName, out pool))
      return;
    pool.PullOut(items);
  }

  public void PullOut(string poolName, DataFile item)
  {
    CharacterRewards.Pool pool;
    if (!this.poolLookup.TryGetValue(poolName, out pool))
      return;
    pool.PullOut(item);
  }

  public class Pool
  {
    [CompilerGenerated]
    public List<DataFile> \u003Clist\u003Ek__BackingField;
    public readonly List<DataFile> current = new List<DataFile>();

    public List<DataFile> list
    {
      get => this.\u003Clist\u003Ek__BackingField;
      set => this.\u003Clist\u003Ek__BackingField = value;
    }

    public void Add(DataFile item)
    {
      if (this.list == null)
      {
        List<DataFile> dataFileList;
        this.list = dataFileList = new List<DataFile>();
      }
      this.list.Add(item);
    }

    public void Add(IEnumerable<DataFile> content)
    {
      if (this.list == null)
      {
        List<DataFile> dataFileList;
        this.list = dataFileList = new List<DataFile>();
      }
      this.list.AddRange(content);
    }

    public void Remove(IEnumerable<string> itemNames)
    {
      foreach (string itemName in itemNames)
        this.Remove(itemName);
    }

    public void Remove(string itemName) => Debug.Log((object) string.Format("Removed [{0}] instances of [{1}]", (object) this.list.RemoveAll((Predicate<DataFile>) (a => a.name == itemName)), (object) itemName));

    public void PullOut(IEnumerable<DataFile> items)
    {
      this.CheckPopulate();
      foreach (DataFile dataFile in items)
        this.current.Remove(dataFile);
    }

    public void PullOut(DataFile item)
    {
      this.CheckPopulate();
      this.current.Remove(item);
    }

    public DataFile Pull()
    {
      this.CheckPopulate();
      DataFile dataFile = this.current[0];
      this.current.RemoveAt(0);
      return dataFile;
    }

    public DataFile[] Pull(int itemCount, bool allowDuplicates = false)
    {
      List<DataFile> dataFileList = new List<DataFile>();
      while (dataFileList.Count < itemCount)
      {
        this.CheckPopulate();
        for (int index = 0; index < this.current.Count; ++index)
        {
          DataFile dataFile = this.current[index];
          if (allowDuplicates || !dataFileList.Contains(dataFile))
          {
            dataFileList.Add(dataFile);
            this.current.RemoveAt(index);
            break;
          }
        }
      }
      return dataFileList.ToArray();
    }

    public DataFile[] Pull(int itemCount, bool allowDuplicates, Predicate<DataFile> match)
    {
      List<DataFile> dataFileList = new List<DataFile>();
      while (dataFileList.Count < itemCount)
      {
        this.CheckPopulate();
        List<DataFile> all = this.current.FindAll(match);
        if (all.Count <= 0)
        {
          this.Populate();
          all = this.current.FindAll(match);
          if (all.Count <= 0)
            break;
        }
        foreach (DataFile dataFile in all)
        {
          if (allowDuplicates || !dataFileList.Contains(dataFile))
          {
            dataFileList.Add(dataFile);
            this.current.RemoveAt(this.current.IndexOf(dataFile));
            if (dataFileList.Count >= itemCount)
              break;
          }
        }
      }
      return dataFileList.ToArray();
    }

    public DataFile[] GetFromOriginalList(int itemCount, bool allowDuplicates)
    {
      List<DataFile> dataFileList = new List<DataFile>();
      while (dataFileList.Count < itemCount)
      {
        foreach (DataFile dataFile in (IEnumerable<DataFile>) this.list.InRandomOrder<DataFile>())
        {
          if (allowDuplicates || !dataFileList.Contains(dataFile))
          {
            dataFileList.Add(dataFile);
            if (dataFileList.Count >= itemCount)
              break;
          }
        }
      }
      return dataFileList.ToArray();
    }

    public DataFile[] GetFromOriginalList(
      int itemCount,
      bool allowDuplicates,
      Predicate<DataFile> match)
    {
      List<DataFile> dataFileList = new List<DataFile>();
      while (dataFileList.Count < itemCount)
      {
        List<DataFile> all = this.current.FindAll(match);
        if (all.Count > 0)
        {
          foreach (DataFile dataFile in (IEnumerable<DataFile>) all.InRandomOrder<DataFile>())
          {
            if (allowDuplicates || !dataFileList.Contains(dataFile))
            {
              dataFileList.Add(dataFile);
              if (dataFileList.Count >= itemCount)
                break;
            }
          }
        }
        else
          break;
      }
      return dataFileList.ToArray();
    }

    public void CheckPopulate()
    {
      if (this.current.Count > 0)
        return;
      this.Populate();
    }

    public void Populate() => this.current.AddRange((IEnumerable<DataFile>) this.list.InRandomOrder<DataFile>());
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CharacterSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public class CharacterSaveData : ILoadable<Character>
{
  public string name;
  public string title;
  public int team;
  public ClassSaveData classData;
  public InventorySaveData inventoryData;
  [Header("Stats")]
  public int handSize = 6;
  public int redrawBell = 4;
  public int companionLimit = 3;
  public float enemyGoldFactor = 1f;
  public float comboGoldFactor = 1f;

  public CharacterSaveData()
  {
  }

  public CharacterSaveData(Character character)
  {
    this.name = character.name;
    this.title = character.title;
    this.team = character.team;
    this.classData = character.data.classData.Save();
    this.inventoryData = character.data.inventory.Save();
    this.handSize = character.data.handSize;
    this.redrawBell = character.data.redrawBell;
    this.companionLimit = character.data.companionLimit;
    this.enemyGoldFactor = character.data.enemyGoldFactor;
    this.comboGoldFactor = character.data.comboGoldFactor;
  }

  public Character Load()
  {
    PlayerData data = this.LoadPlayerData();
    data.handSize = this.handSize;
    data.redrawBell = this.redrawBell;
    data.companionLimit = this.companionLimit;
    data.enemyGoldFactor = this.enemyGoldFactor;
    data.comboGoldFactor = this.comboGoldFactor;
    Character character = UnityEngine.Object.Instantiate<Character>(data.classData.characterPrefab);
    character.name = this.name;
    character.title = this.title;
    character.team = this.team;
    character.Assign(data);
    return character;
  }

  public PlayerData LoadPlayerData() => new PlayerData(this.classData.Load(), this.inventoryData.Load());
}
﻿// Decompiled with JetBrains decompiler
// Type: CharacterSelectScreen
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Components;
using UnityEngine.UI;

public class CharacterSelectScreen : MonoBehaviour
{
  [SerializeField]
  public int options = 3;
  [SerializeField]
  public int differentTribes = 3;
  public List<Character> characters;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardContainer leaderCardContainer;
  [SerializeField]
  public GameObject backButton;
  [SerializeField]
  public SelectTribe tribeSelection;
  [SerializeField]
  public SelectLeader leaderSelection;
  [SerializeField]
  public SelectStartingPet petSelection;
  [SerializeField]
  public InspectNewUnitSequence selectionSequence;
  [Header("Title")]
  [SerializeField]
  public GameObject title;
  [SerializeField]
  public LocalizeStringEvent titleText;
  [SerializeField]
  public LocalizedString titleTribeKey;
  [SerializeField]
  public LocalizedString titleLeaderKey;
  [SerializeField]
  public LocalizedString titlePetKey;
  [SerializeField]
  public Image titleUnderline;
  [SerializeField]
  public Sprite underlineTribeSprite;
  [SerializeField]
  public Sprite underlineLeaderSprite;
  [SerializeField]
  public Sprite underlinePetSprite;
  [Header("Hard Mode Modifiers")]
  [SerializeField]
  public HardModeModifierDisplay modifierDisplay;
  [SerializeField]
  public UnlockModifierSequence modifierUnlockSequence;
  [Header("Tribe Flags")]
  [SerializeField]
  public Transform flagGroup;
  [SerializeField]
  public TribeFlagDisplay flagBase;
  [SerializeField]
  public Vector3 flagOffset = new Vector3(0.0f, -4f);
  [SerializeField]
  public TribeDisplaySequence tribeDisplay;
  public readonly List<GameObject> flags = new List<GameObject>();
  public int seed;
  public bool loadingToCampaign;
  public List<ClassData> unlockedClassesForThisGameMode;
  public const bool selectTribe = true;

  public void OnEnable() => this.loadingToCampaign = false;

  public IEnumerator Start()
  {
    this.leaderSelection.SetSeed(Campaign.Data.Seed);
    List<ClassData> lockedClasses = MetaprogressionSystem.GetLockedClasses();
    Debug.Log((object) ("Locked Classes: [" + string.Join<ClassData>(", ", (IEnumerable<ClassData>) lockedClasses) + "]"));
    this.unlockedClassesForThisGameMode = new List<ClassData>((IEnumerable<ClassData>) Campaign.Data.GameMode.classes);
    this.unlockedClassesForThisGameMode.RemoveMany<ClassData>((ICollection<ClassData>) lockedClasses);
    Debug.Log((object) ("Available Classes For [" + Campaign.Data.GameMode.name + "]: [" + string.Join<ClassData>(", ", (IEnumerable<ClassData>) this.unlockedClassesForThisGameMode) + "]"));
    if (this.unlockedClassesForThisGameMode.Count > 1)
    {
      this.tribeSelection.SetAvailableTribes(this.unlockedClassesForThisGameMode);
      this.tribeSelection.Run();
      this.title.SetActive(true);
      this.titleText.StringReference = this.titleTribeKey;
      this.titleUnderline.sprite = this.underlineTribeSprite;
    }
    else
    {
      this.leaderSelection.Run(this.unlockedClassesForThisGameMode);
      yield return (object) this.leaderSelection.GenerateLeaders(true);
      this.leaderSelection.FlipUpLeadersInstant();
      this.title.SetActive(true);
      this.titleText.StringReference = this.titleLeaderKey;
      this.titleUnderline.sprite = this.underlineLeaderSprite;
    }
    yield return (object) Sequences.Wait(0.1f);
    yield return (object) this.petSelection.SetUp();
    if (this.modifierDisplay.gameObject.activeSelf)
      this.modifierDisplay.Populate();
    this.backButton.gameObject.SetActive(Campaign.Data.GameMode.canGoBack);
    Transition.End();
    if (NewFinalBossChecker.Check())
    {
      this.cardController.Disable();
      yield return (object) NewFinalBossChecker.Run();
      this.cardController.Enable();
    }
  }

  public void Continue()
  {
    if (this.leaderSelection.current == null || this.loadingToCampaign)
      return;
    if (this.petSelection.running)
      this.petSelection.Stop();
    if (this.petSelection.selectedPetIndex < 0 && this.petSelection.CanRun)
    {
      if (this.selectionSequence.IsRunning)
      {
        this.selectionSequence.UnsetUnit();
        this.selectionSequence.End();
        this.cardController.Enable();
      }
      this.petSelection.Run(this.leaderSelection.current.entity);
      this.SetTitlePet();
    }
    else
      this.StartCoroutine(this.ContinueRoutine(this.leaderSelection.current));
  }

  public IEnumerator ContinueRoutine(SelectLeader.Character selected)
  {
    this.loadingToCampaign = true;
    this.petSelection.Gain(this.leaderSelection.current.data);
    this.leaderSelection.current.AddLeaderToInventory();
    References.PlayerData = selected.data;
    yield return (object) JournalAddNameSequence.LoadAndRun(this.leaderSelection.current.entity.data, false);
    yield return (object) Events.InvokeCampaignInit();
    Campaign.Begin();
    Routine routine = new Routine(Transition.To(Campaign.Data.GameMode.sceneAfterSelection));
  }

  public void SetTitleTribe()
  {
    this.title.SetActive(true);
    this.titleText.StringReference = this.titleTribeKey;
    this.titleUnderline.sprite = this.underlineTribeSprite;
  }

  public void SetTitleLeader()
  {
    this.title.SetActive(true);
    this.titleText.StringReference = this.titleLeaderKey;
    this.titleUnderline.sprite = this.underlineLeaderSprite;
  }

  public void SetTitlePet() => this.title.SetActive(false);

  public void Back()
  {
    if (this.leaderSelection.running)
    {
      if (this.unlockedClassesForThisGameMode.Count > 1)
      {
        this.leaderSelection.Cancel();
        this.tribeSelection.SetAvailableTribes(this.unlockedClassesForThisGameMode);
        this.tribeSelection.Run();
        this.tribeSelection.RevealAnimation();
        this.SetTitleTribe();
      }
      else
        this.ReturnToMenu();
    }
    else if (this.petSelection.running)
    {
      this.petSelection.Cancel();
      this.leaderSelection.Return();
      this.SetTitleLeader();
    }
    else
      this.ReturnToMenu();
  }

  public void ReturnToMenu()
  {
    Routine routine = new Routine(Transition.To(SaveSystem.LoadProgressData<int>("tutorialProgress", 0) == 0 ? "MainMenu" : "Town"));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CharacterType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[CreateAssetMenu(fileName = "CharacterType", menuName = "Character/Type")]
public class CharacterType : ScriptableObject
{
  public string race;
  public string gender;
  public CharacterType.PrefabGroup[] prefabs;
  public CharacterType.SpriteGroup[] sprites;
  public CharacterType.ColorSetGroup[] colorSets;
  public CharacterType.ScaleRange[] scales;

  [Serializable]
  public class PrefabGroup
  {
    public string name;
    public PrefabCollection collection;
  }

  [Serializable]
  public class SpriteGroup
  {
    public string name;
    public SpriteCollection collection;
  }

  [Serializable]
  public class ColorSetGroup
  {
    public string name;
    public ColorSetCollection collection;
  }

  [Serializable]
  public class ScaleRange
  {
    public string name;
    public bool lockRatio;
    public Vector2 xRange;
    public Vector2 yRange;

    public Vector2 Convert()
    {
      if (!this.lockRatio)
        return new Vector2(this.xRange.Random(), this.yRange.Random());
      double num = (double) this.xRange.Random();
      return new Vector2((float) num, (float) num);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CharmMachine
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class CharmMachine : MonoBehaviour
{
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public CardPopUpTarget pop;
  public bool running;
  public bool hover;

  public bool CanRun() => !this.running && this.enabled;

  public IEnumerator Run()
  {
    this.running = true;
    this.UnHover();
    this.animator.SetBool("EyesOpen", true);
    Events.InvokeScreenShake(0.2f);
    this.animator.SetTrigger("Rumble");
    SfxSystem.OneShot("event:/sfx/location/shop/charm_rumble");
    yield return (object) Sequences.Wait(0.1f);
    this.animator.SetBool("OpenMouth", true);
    yield return (object) Sequences.Wait(0.35f);
    this.animator.SetTrigger("DropCharm");
    SfxSystem.OneShot("event:/sfx/location/shop/charm_drop");
    yield return (object) Sequences.Wait(1f);
    this.animator.SetBool("OpenMouth", false);
    this.animator.SetBool("EyesOpen", false);
    this.running = false;
  }

  public void Hover()
  {
    if (this.hover || !this.enabled || this.running)
      return;
    this.hover = true;
    this.animator.SetBool(nameof (Hover), this.hover);
    this.animator.SetBool("EyesOpen", this.hover);
    this.pop.Pop();
  }

  public void UnHover()
  {
    if (!this.hover)
      return;
    this.hover = false;
    this.animator.SetBool("Hover", this.hover);
    this.animator.SetBool("EyesOpen", this.hover);
    this.pop.UnPop();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CheckAchievements
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Steamworks;
using Steamworks.Data;
using System.Collections.Generic;
using UnityEngine;

public class CheckAchievements : MonoBehaviour
{
  public static readonly Dictionary<string, string> AchievementChallenge = new Dictionary<string, string>()
  {
    {
      "ACHIEVEMENT_0",
      "Challenge Charm 1"
    },
    {
      "ACHIEVEMENT_1",
      "Challenge Charm 2"
    },
    {
      "ACHIEVEMENT_2",
      "Challenge Charm 3"
    },
    {
      "ACHIEVEMENT_3",
      "Challenge Charm 4"
    },
    {
      "ACHIEVEMENT_4",
      "Challenge Charm 5"
    },
    {
      "ACHIEVEMENT_5",
      "Challenge Charm 6"
    },
    {
      "ACHIEVEMENT_6",
      "Challenge Charm 7"
    },
    {
      "ACHIEVEMENT_7",
      "Challenge Charm 8"
    },
    {
      "ACHIEVEMENT_8",
      "Challenge Charm 9"
    },
    {
      "ACHIEVEMENT_9",
      "Challenge Charm 10"
    },
    {
      "ACHIEVEMENT_10",
      "Challenge Charm 11"
    },
    {
      "ACHIEVEMENT_11",
      "Challenge Charm 12"
    },
    {
      "ACHIEVEMENT_12",
      "Challenge Charm 13"
    },
    {
      "ACHIEVEMENT_13",
      "Challenge Charm 14"
    },
    {
      "ACHIEVEMENT_14",
      "Challenge Charm 15"
    },
    {
      "ACHIEVEMENT_15",
      "Challenge Charm 16"
    }
  };

  public void Start()
  {
    if (!SteamManager.init)
      return;
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>("completedChallenges");
    Debug.Log((object) "Steam Achievements:");
    foreach (Achievement achievement in SteamUserStats.Achievements)
    {
      Debug.Log((object) string.Format("→ {0} ({1})", (object) achievement.Name, (object) achievement.State));
      if (!achievement.State)
      {
        string str = CheckAchievements.AchievementChallenge[achievement.Identifier];
        Debug.Log((object) ("-→ Requires [" + str + "]"));
        if (stringList != null && stringList.Contains(str))
          AchievementsSystem.Achieve(achievement.Identifier);
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChooseNewCardSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.UI;

public class ChooseNewCardSequence : UISequence
{
  public Character owner;
  public RectTransform background;
  public float cardFlipDelay = 0.5f;
  public float cardFlipPauseBetween = 0.25f;
  [SerializeField]
  public GameObject cardGroupLayout;
  [SerializeField]
  public GameObject skipButtonLayout;
  public CardController cardController;
  public CardContainer cardContainer;
  public CardSelector cardSelector;
  [SerializeField]
  public Button skipButton;
  [SerializeField]
  public bool canSkip;
  [SerializeField]
  public int skipGold = 20;
  [SerializeField]
  public TweenUI endTween;

  public override IEnumerator Run()
  {
    ChooseNewCardSequence chooseNewCardSequence = this;
    chooseNewCardSequence.cardGroupLayout.SetActive(false);
    if ((bool) (Object) chooseNewCardSequence.skipButtonLayout)
      chooseNewCardSequence.skipButtonLayout.SetActive(false);
    if ((bool) (Object) chooseNewCardSequence.background)
      chooseNewCardSequence.background.gameObject.SetActive(false);
    yield return (object) Sequences.Wait(chooseNewCardSequence.startDelay);
    chooseNewCardSequence.gameObject.SetActive(true);
    if ((bool) (Object) chooseNewCardSequence.background)
    {
      chooseNewCardSequence.background.gameObject.SetActive(true);
      chooseNewCardSequence.background.localScale = Vector3.zero;
      yield return (object) null;
      chooseNewCardSequence.background.LeanScale(Vector3.one, 1f).setEase(LeanTweenType.easeOutElastic);
      yield return (object) Sequences.Wait(0.25f);
    }
    chooseNewCardSequence.cardGroupLayout.SetActive(true);
    if (chooseNewCardSequence.canSkip && (bool) (Object) chooseNewCardSequence.skipButtonLayout)
      chooseNewCardSequence.skipButtonLayout.SetActive(true);
    yield return (object) Sequences.Wait(chooseNewCardSequence.cardFlipDelay);
    if ((bool) (Object) chooseNewCardSequence.cardContainer)
    {
      int dir = Dead.Random.Sign();
      int cardCount = chooseNewCardSequence.cardContainer.Count;
      for (int i = 0; i < cardCount; ++i)
      {
        chooseNewCardSequence.cardContainer[dir == 1 ? i : cardCount - 1 - i].flipper.FlipUp();
        yield return (object) Sequences.Wait(chooseNewCardSequence.cardFlipPauseBetween);
      }
    }
    while (!chooseNewCardSequence.promptEnd)
      yield return (object) null;
    chooseNewCardSequence.cardController.Disable();
    if ((bool) (Object) chooseNewCardSequence.skipButton)
      chooseNewCardSequence.skipButton.interactable = false;
    if ((bool) (Object) chooseNewCardSequence.background)
      chooseNewCardSequence.background.LeanScale(Vector3.zero, chooseNewCardSequence.tweenOutDur).setEase(LeanTweenType.easeInBack);
    if ((bool) (Object) chooseNewCardSequence.endTween)
    {
      chooseNewCardSequence.endTween.Fire();
      yield return (object) new WaitForSeconds(chooseNewCardSequence.endTween.GetDuration());
    }
    foreach (Entity entity in chooseNewCardSequence.cardContainer)
    {
      if ((bool) (Object) entity && (bool) (Object) entity.gameObject)
        CardManager.ReturnToPool(entity);
    }
    yield return (object) SceneManager.WaitUntilUnloaded("CardCombine");
    chooseNewCardSequence.gameObject.SetActive(false);
  }

  public void Skip()
  {
    if (this.skipGold > 0 && (bool) (Object) this.owner?.data?.inventory)
      Events.InvokeDropGold(this.skipGold, "SkipReward", this.owner, this.skipButton.transform.position);
    this.cardController.Disable();
    this.End();
    this.skipButton.interactable = false;
  }

  public void TakeFirstCard()
  {
    if (this.promptEnd)
      return;
    this.cardSelector.TakeFirstCard(this.cardContainer);
    this.cardController.Disable();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChooseNewCompanion
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ChooseNewCompanion : UISequence
{
  [SerializeField]
  public UISequence sequence;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardContainer cardContainer;
  [SerializeField]
  public int rewardOptions = 3;
  [Header("Banners")]
  [SerializeField]
  public RectTransform topBanner;
  [SerializeField]
  public RectTransform bottomBanner;
  [SerializeField]
  public RectTransform background;
  [SerializeField]
  public Vector2 bannerTweenDur = new Vector2(0.9f, 1.1f);
  [SerializeField]
  public LeanTweenType bannerTweenEase = LeanTweenType.easeOutBounce;
  [SerializeField]
  public Vector2 bannerTweenOutDur = new Vector2(0.3f, 0.4f);
  [SerializeField]
  public LeanTweenType bannerTweenOutEase = LeanTweenType.easeInBack;
  public CardData[] storedRewards;

  public override IEnumerator Run()
  {
    ChooseNewCompanion chooseNewCompanion = this;
    chooseNewCompanion.Populate();
    chooseNewCompanion.gameObject.SetActive(true);
    if ((Object) chooseNewCompanion.background != (Object) null)
    {
      chooseNewCompanion.background.gameObject.SetActive(true);
      chooseNewCompanion.background.localScale = Vector3.zero;
      yield return (object) null;
      chooseNewCompanion.background.LeanScale(Vector3.one, 1f).setEase(LeanTweenType.easeOutElastic);
      yield return (object) Sequences.Wait(0.25f);
    }
    if ((Object) chooseNewCompanion.topBanner != (Object) null)
    {
      chooseNewCompanion.topBanner.gameObject.SetActive(true);
      Vector3 localPosition = chooseNewCompanion.topBanner.localPosition;
      chooseNewCompanion.topBanner.localPosition = localPosition.WithY(localPosition.y + 5f);
      LeanTween.cancel(chooseNewCompanion.topBanner.gameObject);
      LeanTween.moveLocal(chooseNewCompanion.topBanner.gameObject, localPosition, chooseNewCompanion.bannerTweenDur.PettyRandom()).setEase(chooseNewCompanion.bannerTweenEase);
    }
    if ((Object) chooseNewCompanion.bottomBanner != (Object) null)
    {
      chooseNewCompanion.bottomBanner.gameObject.SetActive(true);
      Vector3 localPosition = chooseNewCompanion.bottomBanner.localPosition;
      chooseNewCompanion.bottomBanner.localPosition = localPosition.WithY(localPosition.y - 5f);
      LeanTween.cancel(chooseNewCompanion.bottomBanner.gameObject);
      LeanTween.moveLocal(chooseNewCompanion.bottomBanner.gameObject, localPosition, chooseNewCompanion.bannerTweenDur.PettyRandom()).setEase(chooseNewCompanion.bannerTweenEase);
    }
    chooseNewCompanion.sequence.gameObject.SetActive(true);
    yield return (object) chooseNewCompanion.sequence.Run();
    if ((Object) chooseNewCompanion.background != (Object) null)
    {
      chooseNewCompanion.background.LeanScale(Vector3.zero, chooseNewCompanion.tweenOutDur).setEase(LeanTweenType.easeInBack);
      yield return (object) Sequences.Wait(chooseNewCompanion.tweenOutDur);
    }
    if ((Object) chooseNewCompanion.topBanner != (Object) null)
    {
      LeanTween.cancel(chooseNewCompanion.topBanner.gameObject);
      LeanTween.moveLocal(chooseNewCompanion.topBanner.gameObject, chooseNewCompanion.topBanner.localPosition.WithY(chooseNewCompanion.topBanner.localPosition.y + 5f), chooseNewCompanion.bannerTweenOutDur.PettyRandom()).setEase(chooseNewCompanion.bannerTweenOutEase);
    }
    if ((Object) chooseNewCompanion.bottomBanner != (Object) null)
    {
      LeanTween.cancel(chooseNewCompanion.bottomBanner.gameObject);
      LeanTween.moveLocal(chooseNewCompanion.bottomBanner.gameObject, chooseNewCompanion.bottomBanner.localPosition.WithY(chooseNewCompanion.bottomBanner.localPosition.y - 5f), chooseNewCompanion.bannerTweenOutDur.PettyRandom()).setEase(chooseNewCompanion.bannerTweenOutEase);
    }
  }

  public void Populate()
  {
    Character player = References.Player;
    this.cardSelector.character = player;
    this.cardController.owner = player;
    if (this.storedRewards == null || this.storedRewards.Length == 0)
    {
      this.storedRewards = player.GetComponent<CharacterRewards>().Pull<CardData>((object) this, "Units", this.rewardOptions);
      Debug.Log((object) ("Unit Reward Options: [" + string.Join<CardData>(", ", (IEnumerable<CardData>) this.storedRewards) + "]"));
    }
    this.cardContainer.SetSize(this.storedRewards.Length, 0.8f);
    this.cardContainer.owner = player;
    Routine.Clump clump = new Routine.Clump();
    foreach (CardData storedReward in this.storedRewards)
    {
      Card card = CardManager.Get(storedReward.Clone(), this.cardController, player, false, true);
      card.entity.flipper.FlipDownInstant();
      this.cardContainer.Add(card.entity);
      clump.Add(card.UpdateData(false));
    }
    foreach (Entity child in this.cardContainer)
    {
      Transform transform = child.transform;
      transform.localPosition = this.cardContainer.GetChildPosition(child);
      transform.localScale = this.cardContainer.GetChildScale(child);
      transform.localEulerAngles = this.cardContainer.GetChildRotation(child);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ChooseSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System.Collections;
using UnityEngine;

public class ChooseSequence : UISequence
{
  public RectTransform background;

  public override IEnumerator Run()
  {
    ChooseSequence chooseSequence = this;
    UIAnchors anchors = chooseSequence.GetComponent<UIAnchors>();
    foreach (UIAnchors.AnchorPoint anchorPoint in anchors.list)
    {
      anchorPoint.Deactivate();
      anchorPoint.SetUp();
    }
    chooseSequence.background.gameObject.SetActive(false);
    yield return (object) Sequences.Wait(chooseSequence.startDelay);
    chooseSequence.gameObject.SetActive(true);
    chooseSequence.background.gameObject.SetActive(true);
    chooseSequence.background.localScale = Vector3.zero;
    yield return (object) null;
    chooseSequence.background.LeanScale(Vector3.one, 1f).setEase(LeanTweenType.easeOutElastic);
    yield return (object) Sequences.Wait(0.25f);
    int c = anchors.Count;
    for (int i = 0; i < c; ++i)
    {
      anchors.Activate(i);
      yield return (object) null;
      chooseSequence.StartCoroutine(anchors.Reveal(i));
    }
    chooseSequence.StartCoroutine(anchors.UpdatePositions());
    while (!chooseSequence.promptEnd)
      yield return (object) null;
    chooseSequence.background.LeanScale(Vector3.zero, chooseSequence.tweenOutDur).setEase(LeanTweenType.easeInBack);
    for (int anchorIndex = 0; anchorIndex < c; ++anchorIndex)
    {
      float delay = PettyRandom.Range(0.0f, chooseSequence.delayBetween);
      chooseSequence.StartCoroutine(anchors.UnReveal(anchorIndex, delay));
    }
    yield return (object) Sequences.Wait(chooseSequence.tweenInDur + chooseSequence.delayBetween);
    chooseSequence.gameObject.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CinemaBarShower
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Localization;

public class CinemaBarShower : MonoBehaviour
{
  [SerializeField]
  public bool showOnEnable;
  [Header("Sorting Order")]
  [SerializeField]
  public bool setSortingOrder;
  [SerializeField]
  [ShowIf("setSortingOrder")]
  public string sortingLayer = "CinemaBars";
  [SerializeField]
  [ShowIf("setSortingOrder")]
  public int orderInLayer;
  [Header("Top Bar")]
  [SerializeField]
  public bool topText;
  [SerializeField]
  [ShowIf("topText")]
  public LocalizedString topScript;
  [SerializeField]
  [ShowIf("topText")]
  public LocalizedString topPrompt;
  [SerializeField]
  [ShowIf("topText")]
  public string topAction;
  [Header("Bottom Bar")]
  [SerializeField]
  public bool bottomText;
  [SerializeField]
  [ShowIf("bottomText")]
  public LocalizedString bottomScript;
  [SerializeField]
  [ShowIf("bottomText")]
  public LocalizedString bottomPrompt;
  [SerializeField]
  [ShowIf("bottomText")]
  public string bottomAction;

  public void OnEnable()
  {
    if (!this.showOnEnable)
      return;
    this.Show();
  }

  public void Show()
  {
    CinemaBarSystem.In();
    CinemaBarSystem.SetSortingLayer(this.sortingLayer, this.orderInLayer);
    if (this.topText)
    {
      if (!this.topScript.IsEmpty)
        CinemaBarSystem.Top.SetScript(this.topScript.GetLocalizedString());
      else if (!this.topPrompt.IsEmpty)
        CinemaBarSystem.Top.SetPrompt(this.topPrompt.GetLocalizedString(), this.topAction);
    }
    if (!this.bottomText)
      return;
    if (!this.bottomScript.IsEmpty)
    {
      CinemaBarSystem.Bottom.SetScript(this.bottomScript.GetLocalizedString());
    }
    else
    {
      if (this.bottomPrompt.IsEmpty)
        return;
      CinemaBarSystem.Bottom.SetPrompt(this.bottomPrompt.GetLocalizedString(), this.bottomAction);
    }
  }

  public void Hide()
  {
    CinemaBarSystem.Clear();
    CinemaBarSystem.Out();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CinemaBarSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class CinemaBarSystem : GameSystem
{
  public static CinemaBarSystem _instance;
  [SerializeField]
  public Canvas canvas;
  [SerializeField]
  public CinemaBarSystem.Section top;
  [SerializeField]
  public CinemaBarSystem.Section bottom;
  public static CinemaBarSystem.Section Top;
  public static CinemaBarSystem.Section Bottom;
  public const float from = -1.5f;
  public const float to = 0.4f;
  public const float inDur = 0.5f;
  public const LeanTweenType inEase = LeanTweenType.easeOutBack;
  public const float outDur = 0.2f;
  public const LeanTweenType outEase = LeanTweenType.easeInQuad;

  public static CinemaBarSystem instance => CinemaBarSystem._instance ?? (CinemaBarSystem._instance = UnityEngine.Object.FindObjectOfType<CinemaBarSystem>(true));

  public void Awake()
  {
    CinemaBarSystem.Top = this.top;
    CinemaBarSystem.Bottom = this.bottom;
  }

  public void OnEnable() => global::Events.OnCampaignFinal += new UnityAction(CinemaBarSystem.CampaignFinal);

  public void OnDisable() => global::Events.OnCampaignFinal -= new UnityAction(CinemaBarSystem.CampaignFinal);

  public static void CampaignFinal()
  {
    CinemaBarSystem.Clear();
    CinemaBarSystem.OutInstant();
  }

  public static void Clear()
  {
    CinemaBarSystem.instance.StopAllCoroutines();
    CinemaBarSystem.Top.Clear();
    CinemaBarSystem.Bottom.Clear();
  }

  public static void SetScript(string text, bool typewriterAnimation)
  {
    string str = "";
    if (text.Contains("|"))
    {
      int length = text.IndexOf('|');
      str = text.Substring(0, length);
      text = text.Substring(length + 1);
    }
    CinemaBarSystem.Top.script.text = str;
    CinemaBarSystem.Bottom.script.text = text;
    CinemaBarSystem.instance.StopAllCoroutines();
    if (!typewriterAnimation)
      return;
    CinemaBarSystem.instance.StartCoroutine(CinemaBarSystem.Typewrite());
  }

  public static IEnumerator Typewrite()
  {
    if (!CinemaBarSystem.Top.script.text.IsNullOrWhitespace())
    {
      CinemaBarSystem.Bottom.script.maxVisibleCharacters = 0;
      yield return (object) CinemaBarSystem.Top.typewriter.Write();
      yield return (object) new WaitForSeconds(1f);
    }
    yield return (object) CinemaBarSystem.Bottom.typewriter.Write();
  }

  public static bool IsActive() => CinemaBarSystem.instance.gameObject.activeSelf;

  public static void In()
  {
    GameObject gameObject = CinemaBarSystem.instance.gameObject;
    gameObject.SetActive(true);
    CinemaBarSystem.Clear();
    LeanTween.cancel(gameObject);
    CinemaBarSystem.SetPosition(-1.5f);
    LeanTween.value(gameObject, -1.5f, 0.4f, 0.5f).setEase(LeanTweenType.easeOutBack).setOnUpdate(new Action<float>(CinemaBarSystem.SetPosition));
  }

  public static void InInstant()
  {
    GameObject gameObject = CinemaBarSystem.instance.gameObject;
    gameObject.SetActive(true);
    CinemaBarSystem.Clear();
    LeanTween.cancel(gameObject);
    CinemaBarSystem.SetPosition(0.4f);
  }

  public static void Out()
  {
    if ((UnityEngine.Object) CinemaBarSystem.instance == (UnityEngine.Object) null || (UnityEngine.Object) CinemaBarSystem.instance.gameObject == (UnityEngine.Object) null || !CinemaBarSystem.instance.gameObject.activeSelf)
      return;
    LeanTween.cancel(CinemaBarSystem.instance.gameObject);
    CinemaBarSystem.SetPosition(0.4f);
    LeanTween.value(CinemaBarSystem.instance.gameObject, 0.4f, -1.5f, 0.2f).setEase(LeanTweenType.easeInQuad).setOnUpdate(new Action<float>(CinemaBarSystem.SetPosition)).setOnComplete((System.Action) (() =>
    {
      CinemaBarSystem.ResetSortingLayer();
      CinemaBarSystem.instance.gameObject.SetActive(false);
    }));
  }

  public static void OutInstant()
  {
    if (!(bool) (UnityEngine.Object) CinemaBarSystem.instance || !(bool) (UnityEngine.Object) CinemaBarSystem.instance.gameObject || !CinemaBarSystem.instance.gameObject.activeSelf)
      return;
    LeanTween.cancel(CinemaBarSystem.instance.gameObject);
    CinemaBarSystem.SetPosition(-1.5f);
    CinemaBarSystem.ResetSortingLayer();
    CinemaBarSystem.instance.gameObject.SetActive(false);
  }

  public static void SetSortingLayer(string name, int orderInLayer = 0)
  {
    CinemaBarSystem.instance.canvas.sortingLayerName = name;
    CinemaBarSystem.instance.canvas.sortingOrder = orderInLayer;
  }

  public static void ResetSortingLayer() => CinemaBarSystem.SetSortingLayer("CinemaBars");

  public static void SetPosition(float value)
  {
    CinemaBarSystem.Top.transform.anchoredPosition = CinemaBarSystem.Top.transform.anchoredPosition.WithY(-value);
    CinemaBarSystem.Bottom.transform.anchoredPosition = CinemaBarSystem.Bottom.transform.anchoredPosition.WithY(value);
  }

  public class State
  {
    public readonly bool wasActive;
    public readonly string topScript;
    public readonly string topPrompt;
    public readonly string topPromptAction;
    public readonly string bottomScript;
    public readonly string bottomPrompt;
    public readonly string bottomPromptAction;
    public readonly string sortingLayerName;
    public readonly int sortingOrderInLayer;

    public State()
    {
      this.wasActive = CinemaBarSystem.IsActive();
      this.topScript = CinemaBarSystem.Top.script.text;
      this.topPrompt = CinemaBarSystem.Top.prompt.text;
      this.topPromptAction = CinemaBarSystem.Top.buttonImage.actionName;
      this.bottomScript = CinemaBarSystem.Bottom.script.text;
      this.bottomPrompt = CinemaBarSystem.Bottom.prompt.text;
      this.bottomPromptAction = CinemaBarSystem.Bottom.buttonImage.actionName;
      this.sortingLayerName = CinemaBarSystem.instance.canvas.sortingLayerName;
      this.sortingOrderInLayer = CinemaBarSystem.instance.canvas.sortingOrder;
    }

    public void Restore()
    {
      bool flag = CinemaBarSystem.IsActive();
      if (flag && !this.wasActive)
        CinemaBarSystem.Out();
      else if (!flag && this.wasActive)
        CinemaBarSystem.In();
      CinemaBarSystem.Top.SetScript(this.topScript);
      CinemaBarSystem.Top.SetPrompt(this.topPrompt, this.topPromptAction);
      CinemaBarSystem.Bottom.SetScript(this.bottomScript);
      CinemaBarSystem.Bottom.SetPrompt(this.bottomPrompt, this.bottomPromptAction);
      CinemaBarSystem.SetSortingLayer(this.sortingLayerName, this.sortingOrderInLayer);
    }
  }

  [Serializable]
  public class Section
  {
    public RectTransform transform;
    public TMP_Text prompt;
    public ControllerButtonImage buttonImage;
    public TMP_Text script;
    public TextTypewrite typewriter;

    public void SetPrompt(string text, string actionName)
    {
      this.prompt.text = text;
      this.buttonImage.Set(actionName);
    }

    public void RemovePrompt() => this.SetPrompt("", "");

    public void SetScript(string text) => this.script.text = text;

    public void RemoveScript() => this.SetScript("");

    public void Clear()
    {
      this.SetPrompt("", "");
      this.SetScript("");
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ClassData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using NaughtyAttributes;
using UnityEngine;

[CreateAssetMenu(fileName = "New Class", menuName = "Character/Class")]
public class ClassData : DataFile, ISaveable<ClassSaveData>
{
  public UnlockData requiresUnlock;
  public Inventory startingInventory;
  public CardData[] leaders;
  public Character characterPrefab;
  public RewardPool[] rewardPools;
  public EventReference selectSfxEvent;
  [ShowAssetPreview(64, 64)]
  public Sprite flag;

  public ClassSaveData Save() => new ClassSaveData(this.name);

  public override string ToString() => this.name;
}
﻿// Decompiled with JetBrains decompiler
// Type: ClassSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Serializable]
public class ClassSaveData : ILoadable<ClassData>
{
  public string name;

  public ClassSaveData()
  {
  }

  public ClassSaveData(string name) => this.name = name;

  public ClassData Load() => AddressableLoader.Get<ClassData>("ClassData", this.name);
}
﻿// Decompiled with JetBrains decompiler
// Type: ClickParticleSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ClickParticleSystem : GameSystem
{
  [SerializeField]
  public ParticleSystem fxPrefab;
  [SerializeField]
  public Transform group;
  public readonly List<ParticleSystem> pool = new List<ParticleSystem>();

  public void Update()
  {
    if (!InputSystem.IsSelectPressed())
      return;
    this.Pop();
  }

  public void Pop()
  {
    ParticleSystem ps = this.Get();
    ps.transform.position = Cursor3d.PositionWithZ;
    ps.Play(true);
    this.StartCoroutine(this.ReturnToPoolWhenFinished(ps));
  }

  public IEnumerator ReturnToPoolWhenFinished(ParticleSystem ps)
  {
    while (ps.isPlaying)
      yield return (object) null;
    ps.gameObject.SetActive(false);
    this.pool.Add(ps);
  }

  public ParticleSystem Get()
  {
    if (this.pool.Count <= 0)
      return Object.Instantiate<ParticleSystem>(this.fxPrefab, this.group);
    ParticleSystem particleSystem = this.pool[0];
    this.pool.RemoveAt(0);
    particleSystem.gameObject.SetActive(true);
    return particleSystem;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CloudMovement
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using UnityEngine;

public class CloudMovement : MonoBehaviour
{
  public Transform mover;
  public float speed = 0.1f;
  public float width = 20f;

  public void Awake() => this.mover.localPosition = this.mover.localPosition with
  {
    x = PettyRandom.Range(-this.width, this.width)
  };

  public void Update()
  {
    Vector3 localPosition = this.mover.localPosition;
    localPosition.x += this.speed * Time.deltaTime;
    if ((double) localPosition.x > (double) this.width)
      localPosition.x = -this.width;
    else if ((double) localPosition.x < -(double) this.width)
      localPosition.x = this.width;
    this.mover.localPosition = localPosition;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CollectionModifier
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[CreateAssetMenu(fileName = "CollectionModifier", menuName = "Character/Collection Modifier")]
public class CollectionModifier : ScriptableObject
{
  public CollectionModifier.Modify[] list;

  [Serializable]
  public struct Modify
  {
    public int index;
    public float addWeight;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Collection`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public class Collection<T> : ScriptableObject where T : class
{
  public float nullWeight;
  [SerializeField]
  public Collection<T>.Entry<T>[] weightedList;

  public T this[int index] => this.weightedList[index].value;

  public void AddWeight(int index, float weight) => this.weightedList[index].weight += weight;

  public T RandomItem()
  {
    int index = this.RandomIndex();
    return index >= 0 ? this.weightedList[index].value : default (T);
  }

  public virtual int RandomIndex()
  {
    int num1 = -1;
    if (this.weightedList.Length != 0)
    {
      float nullWeight = this.nullWeight;
      foreach (Collection<T>.Entry<T> weighted in this.weightedList)
      {
        if ((double) weighted.weight > 0.0)
          nullWeight += weighted.weight;
      }
      if ((double) nullWeight > 0.0)
      {
        float num2 = UnityEngine.Random.value * nullWeight;
        if ((double) num2 >= (double) this.nullWeight)
        {
          float num3 = num2 - this.nullWeight;
          for (int index = 0; index < this.weightedList.Length; ++index)
          {
            Collection<T>.Entry<T> weighted = this.weightedList[index];
            if ((double) weighted.weight > 0.0)
            {
              if ((double) num3 < (double) weighted.weight)
              {
                num1 = index;
                break;
              }
              num3 -= weighted.weight;
            }
          }
        }
      }
    }
    return num1;
  }

  [Serializable]
  public struct Entry<T1>
  {
    public T1 value;
    public float weight;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ColorSet
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public class ColorSet
{
  public Color[] set;

  public Color this[int index] => this.set[index];
}
﻿// Decompiled with JetBrains decompiler
// Type: ColorSetCollection
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "ColorSetCollection", menuName = "Character/Color Set Collection")]
public class ColorSetCollection : Collection<ColorSet>
{
}
﻿// Decompiled with JetBrains decompiler
// Type: ColourFader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof (Graphic))]
public class ColourFader : MonoBehaviour
{
  public Graphic _graphic;
  [SerializeField]
  public ColourFader.Colour[] colours;
  [SerializeField]
  public float duration;
  public Color targetColour;
  public float fadeAmount;
  public float fadeDuration;

  public Graphic graphic => this._graphic ?? (this._graphic = this.GetComponent<Graphic>());

  public void FadeToColour(string name)
  {
    foreach (ColourFader.Colour colour in this.colours)
    {
      if (colour.name == name)
      {
        this.FadeToColour(colour.colour);
        break;
      }
    }
  }

  public void FadeToColour(Color colour)
  {
    this.fadeAmount = 0.0f;
    this.fadeDuration = this.duration;
    this.targetColour = colour;
  }

  public void Update()
  {
    if ((double) this.fadeAmount >= (double) this.fadeDuration)
      return;
    this.fadeAmount += Time.deltaTime * this.fadeDuration;
    this.graphic.color = Color.Lerp(this.graphic.color, this.targetColour, this.fadeAmount);
  }

  [Serializable]
  public struct Colour
  {
    public string name;
    public Color colour;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CombineCardSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.UI;

public class CombineCardSequence : MonoBehaviour
{
  [SerializeField]
  public Fader fader;
  [SerializeField]
  public Graphic flash;
  [SerializeField]
  public AnimationCurve flashCurve;
  [SerializeField]
  public AnimationCurve bounceCurve;
  [SerializeField]
  public Transform group;
  [SerializeField]
  public Transform pointPrefab;
  [SerializeField]
  public ParticleSystem ps;
  [SerializeField]
  public LocalizedString titleKey;
  [SerializeField]
  public LocalizedString continueKey;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public ParticleSystem hitPs;
  [SerializeField]
  public GameObject combinedFx;
  [SerializeField]
  public Transform finalEntityParent;
  public readonly List<Transform> points = new List<Transform>();
  public const float cardScale = 0.8f;
  public const float finalCardScale = 1f;

  public IEnumerator Run(string[] cardsToCombine, string resultingCard)
  {
    CardData[] cards = new CardData[cardsToCombine.Length];
    CardData cardDataClone = AddressableLoader.GetCardDataClone(resultingCard);
    for (int index = 0; index < cardsToCombine.Length; ++index)
    {
      string cardName = cardsToCombine[index];
      CardData cardData = References.PlayerData.inventory.deck.FirstOrDefault<CardData>((Func<CardData, bool>) (a => a.name == cardName));
      if ((bool) (UnityEngine.Object) cardData)
        cards[index] = cardData;
    }
    yield return (object) this.Run(cards, cardDataClone);
  }

  public IEnumerator Run(CardData[] cards, CardData finalCard)
  {
    CombineCardSequence combineCardSequence = this;
    CinemaBarSystem.State cinemaBarState = new CinemaBarSystem.State();
    PauseMenu.Block();
    CinemaBarSystem.SetSortingLayer("UI2", 100);
    CinemaBarSystem.In();
    Entity[] entities = combineCardSequence.CreateEntities(cards);
    Entity finalEntity = combineCardSequence.CreateFinalEntity(finalCard);
    Routine.Clump clump = new Routine.Clump();
    foreach (Entity entity in entities)
      clump.Add(entity.display.UpdateData());
    clump.Add(finalEntity.display.UpdateData());
    clump.Add(Sequences.Wait(0.5f));
    yield return (object) clump.WaitForEnd();
    foreach (MonoBehaviourCacheTransform behaviourCacheTransform in entities)
      behaviourCacheTransform.transform.localScale = Vector3.one * 0.8f;
    foreach (Entity entity in entities)
      References.PlayerData.inventory.deck.Remove(entity.data);
    References.PlayerData.inventory.deck.Add(finalEntity.data);
    combineCardSequence.fader.In();
    Vector3 zero = Vector3.zero;
    foreach (Entity entity in entities)
      zero += entity.transform.position;
    Vector3 vector3 = zero / (float) entities.Length;
    combineCardSequence.group.position = vector3;
    foreach (Entity entity in entities)
    {
      Transform p = UnityEngine.Object.Instantiate<Transform>(combineCardSequence.pointPrefab, entity.transform.position, Quaternion.identity, combineCardSequence.group);
      p.gameObject.SetActive(true);
      entity.transform.SetParent(p);
      combineCardSequence.points.Add(p);
      LeanTween.alphaCanvas(((Card) entity.display).canvasGroup, 1f, 0.4f).setEaseInQuad();
    }
    foreach (Transform point in combineCardSequence.points)
      LeanTween.moveLocal(point.gameObject, point.localPosition.normalized, 0.4f).setEaseInQuart();
    yield return (object) new WaitForSeconds(0.4f);
    combineCardSequence.Flash(0.5f);
    Events.InvokeScreenShake();
    foreach (Entity entity in entities)
      entity.wobbler.WobbleRandom();
    combineCardSequence.hitPs.Play();
    foreach (Transform point in combineCardSequence.points)
      LeanTween.moveLocal(point.gameObject, point.localPosition.normalized * 3f, 1f).setEase(combineCardSequence.bounceCurve);
    LeanTween.moveLocal(combineCardSequence.group.gameObject, new Vector3(0.0f, 0.0f, -2f), 1f).setEaseInOutQuad();
    LeanTween.rotateZ(combineCardSequence.group.gameObject, Dead.PettyRandom.Range(160f, 180f), 1f).setOnUpdateVector3(new Action<Vector3>(combineCardSequence.\u003CRun\u003Eb__17_0)).setEaseInOutQuad();
    yield return (object) new WaitForSeconds(1f);
    combineCardSequence.Flash();
    Events.InvokeScreenShake();
    if ((bool) (UnityEngine.Object) combineCardSequence.ps)
      combineCardSequence.ps.Play();
    combineCardSequence.combinedFx.SetActive(true);
    finalEntity.transform.position = Vector3.zero;
    foreach (Entity entity in entities)
      CardManager.ReturnToPool(entity);
    combineCardSequence.group.transform.localRotation = Quaternion.identity;
    double num = (double) finalEntity.curveAnimator.Ping();
    finalEntity.wobbler.WobbleRandom();
    CinemaBarSystem.Top.SetScript(combineCardSequence.titleKey.GetLocalizedString());
    CinemaBarSystem.Bottom.SetPrompt(combineCardSequence.continueKey.GetLocalizedString(), "Select");
    while (!InputSystem.IsButtonPressed("Select"))
      yield return (object) null;
    cinemaBarState.Restore();
    CinemaBarSystem.SetSortingLayer("CinemaBars");
    combineCardSequence.fader.gameObject.Destroy();
    combineCardSequence.cardSelector.character = References.Player;
    combineCardSequence.cardSelector.MoveCardToDeck(finalEntity);
    PauseMenu.Unblock();
  }

  public Entity[] CreateEntities(CardData[] cardDatas)
  {
    Entity[] entities = new Entity[cardDatas.Length];
    float num1 = (double) DeadExtensions.PettyRandom.value > 0.5 ? DeadExtensions.PettyRandom.Range(-45f, 45f) : DeadExtensions.PettyRandom.Range(135f, 225f);
    float num2 = 360f / (float) cardDatas.Length;
    for (int index = 0; index < cardDatas.Length; ++index)
    {
      Card card = CardManager.Get(cardDatas[index], (CardController) null, (Character) null, false, true);
      entities[index] = card.entity;
      Vector2 vector2 = Lengthdir.ToVector2(10f, num1 * ((float) Math.PI / 180f)) + Dead.PettyRandom.Vector2() * 1f;
      card.transform.position = (Vector3) vector2;
      card.transform.localScale = Vector3.zero;
      card.transform.SetParent(this.group);
      card.canvasGroup.alpha = 0.0f;
      num1 += num2;
    }
    return entities;
  }

  public Entity CreateFinalEntity(CardData cardData)
  {
    Card card = CardManager.Get(cardData, (CardController) null, (Character) null, false, true);
    card.transform.localScale = Vector3.one * 1f;
    card.transform.SetParent(this.finalEntityParent);
    return card.entity;
  }

  public void Flash(float intensity = 1f, float duration = 0.15f)
  {
    GameObject gameObject = this.flash.gameObject;
    gameObject.SetActive(true);
    LeanTween.cancel(gameObject);
    LeanTween.value(gameObject, 0.0f, intensity, duration).setEase(this.flashCurve).setOnUpdate((Action<float>) (a => this.flash.color = this.flash.color.With(alpha: a))).setOnComplete((System.Action) (() => this.flash.gameObject.SetActive(false)));
  }

  [CompilerGenerated]
  public void \u003CRun\u003Eb__17_0(Vector3 a)
  {
    foreach (Component point in this.points)
      point.transform.eulerAngles = Vector3.zero;
  }

  [CompilerGenerated]
  public void \u003CFlash\u003Eb__20_0(float a) => this.flash.color = this.flash.color.With(alpha: a);

  [CompilerGenerated]
  public void \u003CFlash\u003Eb__20_1() => this.flash.gameObject.SetActive(false);
}
﻿// Decompiled with JetBrains decompiler
// Type: CombineCardSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class CombineCardSystem : GameSystem
{
  [SerializeField]
  public string combineSceneName;
  [SerializeField]
  public CombineCardSystem.Combo[] combos;

  public void OnEnable() => global::Events.OnEntityEnterBackpack += new UnityAction<Entity>(this.EntityEnterBackpack);

  public void OnDisable() => global::Events.OnEntityEnterBackpack -= new UnityAction<Entity>(this.EntityEnterBackpack);

  public void EntityEnterBackpack(Entity entity)
  {
    foreach (CombineCardSystem.Combo combo in this.combos)
    {
      if (combo.cardNames.Contains<string>(entity.data.name) && combo.AllCardsInDeck(References.PlayerData.inventory.deck))
      {
        this.StopAllCoroutines();
        this.StartCoroutine(this.CombineSequence(combo));
        break;
      }
    }
  }

  public IEnumerator CombineSequence(CombineCardSystem.Combo combo)
  {
    CombineCardSequence combineSequence = (CombineCardSequence) null;
    yield return (object) SceneManager.Load(this.combineSceneName, SceneType.Temporary, (Action<Scene>) (scene => combineSequence = scene.FindObjectOfType<CombineCardSequence>()));
    if ((bool) (UnityEngine.Object) combineSequence)
      yield return (object) combineSequence.Run(combo.cardNames, combo.resultingCardName);
    yield return (object) SceneManager.Unload(this.combineSceneName);
  }

  [Serializable]
  public struct Combo
  {
    public string[] cardNames;
    public string resultingCardName;

    public bool AllCardsInDeck(CardDataList deck)
    {
      bool flag = true;
      foreach (string cardName in this.cardNames)
      {
        if (!this.HasCard(cardName, deck))
        {
          flag = false;
          break;
        }
      }
      return flag;
    }

    public bool HasCard(string cardName, CardDataList deck)
    {
      foreach (UnityEngine.Object @object in deck)
      {
        if (@object.name == cardName)
          return true;
      }
      return false;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CombineSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UI;

public class CombineSystem : GameSystem
{
  public static CombineSystem instance;
  [SerializeField]
  public Fader fader;
  [SerializeField]
  public Graphic flash;
  [SerializeField]
  public AnimationCurve flashCurve;
  [SerializeField]
  public AnimationCurve bounceCurve;
  [SerializeField]
  public Transform group;
  [SerializeField]
  public Transform pointPrefab;
  [SerializeField]
  public ParticleSystem ps;
  public readonly List<Transform> points = new List<Transform>();
  public readonly Dictionary<Entity, Transform> originalParents = new Dictionary<Entity, Transform>();

  public void Awake() => CombineSystem.instance = this;

  public IEnumerator Combine(Entity[] entities, Entity finalEntity)
  {
    CombineSystem combineSystem = this;
    combineSystem.fader.In();
    Vector3 zero = Vector3.zero;
    foreach (Entity entity in entities)
      zero += entity.transform.position;
    Vector3 vector3 = zero / (float) entities.Length;
    combineSystem.group.position = vector3;
    foreach (Entity entity in entities)
    {
      Transform p = UnityEngine.Object.Instantiate<Transform>(combineSystem.pointPrefab, entity.transform.position, Quaternion.identity, combineSystem.group);
      p.gameObject.SetActive(true);
      combineSystem.originalParents[entity] = entity.transform.parent;
      entity.transform.SetParent(p);
      combineSystem.points.Add(p);
    }
    foreach (Transform point in combineSystem.points)
      LeanTween.moveLocal(point.gameObject, point.localPosition.normalized * 0.5f, 0.4f).setEaseInBack();
    yield return (object) new WaitForSeconds(0.4f);
    combineSystem.Flash(0.5f);
    Events.InvokeScreenShake();
    foreach (Entity entity in entities)
      entity.wobbler.WobbleRandom();
    foreach (Transform point in combineSystem.points)
      LeanTween.moveLocal(point.gameObject, point.localPosition.normalized * 3f, 1f).setEase(combineSystem.bounceCurve);
    LeanTween.moveLocal(combineSystem.group.gameObject, new Vector3(0.0f, 0.0f, -2f), 1f).setEaseInOutQuad();
    LeanTween.rotateZ(combineSystem.group.gameObject, PettyRandom.Range(160f, 180f), 1f).setOnUpdateVector3(new Action<Vector3>(combineSystem.\u003CCombine\u003Eb__11_0)).setEaseInOutQuad();
    yield return (object) new WaitForSeconds(1f);
    combineSystem.Flash();
    Events.InvokeScreenShake();
    if ((UnityEngine.Object) combineSystem.ps != (UnityEngine.Object) null)
      combineSystem.ps.Play();
    finalEntity.data = finalEntity.data.Clone(finalEntity.data.random3, finalEntity.data.id, false);
    finalEntity.data.forceTitle = finalEntity.data.title;
    Routine.Clump clump = new Routine.Clump();
    foreach (Entity entity in entities.Without<Entity>(finalEntity))
    {
      finalEntity.data.forceTitle += entity.data.title;
      clump.Add(CombineSystem.Combine(entity, finalEntity));
    }
    yield return (object) clump.WaitForEnd();
    foreach (Entity.TraitStacks traitStacks in finalEntity.traits.Where<Entity.TraitStacks>((Func<Entity.TraitStacks, bool>) (a => a.data.name == "Build")))
      traitStacks.count = 0;
    yield return (object) StatusEffectSystem.BuildEvent(finalEntity);
    yield return (object) finalEntity.UpdateTraits();
    double num = (double) finalEntity.curveAnimator.Ping();
    finalEntity.wobbler.WobbleRandom();
    finalEntity.counter.current = finalEntity.counter.max;
    finalEntity.alive = false;
    yield return (object) finalEntity.display.UpdateData();
    yield return (object) finalEntity.UpdateTraits();
    finalEntity.alive = true;
    yield return (object) StatusEffectSystem.EntityEnableEvent(finalEntity);
    combineSystem.fader.Out();
    yield return (object) new WaitForSeconds(1f);
    foreach (KeyValuePair<Entity, Transform> keyValuePair in combineSystem.originalParents.Where<KeyValuePair<Entity, Transform>>((Func<KeyValuePair<Entity, Transform>, bool>) (pair => (bool) (UnityEngine.Object) pair.Key && (bool) (UnityEngine.Object) pair.Value)))
    {
      keyValuePair.Key.transform.SetParent(keyValuePair.Value);
      keyValuePair.Key.TweenToContainer();
      keyValuePair.Key.wobbler.WobbleRandom();
    }
    combineSystem.originalParents.Clear();
    foreach (Component component in combineSystem.points.Where<Transform>((Func<Transform, bool>) (p => (bool) (UnityEngine.Object) p)))
      UnityEngine.Object.Destroy((UnityEngine.Object) component.gameObject);
    combineSystem.points.Clear();
    combineSystem.group.transform.localEulerAngles = Vector3.zero;
  }

  public static IEnumerator Combine(Entity entity, Entity inTo)
  {
    if (!inTo.data.hasAttack)
      inTo.data.hasAttack = entity.data.hasAttack;
    if (!inTo.data.hasHealth)
      inTo.data.hasHealth = entity.data.hasHealth;
    inTo.data.damage += entity.data.damage;
    inTo.data.hp += entity.data.hp;
    inTo.data.counter = Mathf.Max(inTo.data.counter, entity.data.counter);
    inTo.attackEffects = CardData.StatusEffectStacks.Stack((IEnumerable<CardData.StatusEffectStacks>) inTo.attackEffects, (IEnumerable<CardData.StatusEffectStacks>) entity.attackEffects).ToList<CardData.StatusEffectStacks>();
    List<StatusEffectData> statusEffectDataList = entity.statusEffects.Clone<StatusEffectData>();
    foreach (Entity.TraitStacks trait in entity.traits)
    {
      foreach (StatusEffectData passiveEffect in trait.passiveEffects)
        statusEffectDataList.Remove(passiveEffect);
      int count = trait.count - trait.tempCount;
      if (count > 0)
        inTo.GainTrait(trait.data, count);
    }
    Events.InvokeScreenShake();
    Routine.Clump clump = new Routine.Clump();
    foreach (StatusEffectData effectData in statusEffectDataList)
      clump.Add(StatusEffectSystem.Apply(inTo, effectData.applier, effectData, effectData.count));
    yield return (object) clump.WaitForEnd();
    entity.RemoveFromContainers();
    CardManager.ReturnToPool(entity);
  }

  public void Flash(float intensity = 1f, float duration = 0.1f)
  {
    this.flash.gameObject.SetActive(true);
    LeanTween.cancel(this.flash.gameObject);
    LeanTween.value(this.flash.gameObject, 0.0f, intensity, duration).setEase(this.flashCurve).setOnUpdate((Action<float>) (a => this.flash.color = this.flash.color.With(alpha: a))).setOnComplete((System.Action) (() => this.flash.gameObject.SetActive(false)));
  }

  [CompilerGenerated]
  public void \u003CCombine\u003Eb__11_0(Vector3 a)
  {
    foreach (Component point in this.points)
      point.transform.eulerAngles = Vector3.zero;
  }

  [CompilerGenerated]
  public void \u003CFlash\u003Eb__13_0(float a) => this.flash.color = this.flash.color.With(alpha: a);

  [CompilerGenerated]
  public void \u003CFlash\u003Eb__13_1() => this.flash.gameObject.SetActive(false);
}
﻿// Decompiled with JetBrains decompiler
// Type: CompanionLimitSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.UI;

public class CompanionLimitSequence : UISequence
{
  [SerializeField]
  public LocalizedString textKey;
  [SerializeField]
  public string overColourHex = "f66";
  [SerializeField]
  public string underColourHex = "fff";
  [SerializeField]
  public TMP_Text title;
  public Character owner;
  public CardController controller;
  public GameObject background;
  public GameObject container;
  public CardContainer activeContainer;
  public CardContainer reserveContainer;
  public Transform continueButtonHolder;
  public Button continueButton;

  public override IEnumerator Run()
  {
    CompanionLimitSequence companionLimitSequence = this;
    companionLimitSequence.continueButton.interactable = true;
    Routine.Clump clump = new Routine.Clump();
    foreach (CardData data in companionLimitSequence.owner.data.inventory.deck)
    {
      if (data.cardType.name == "Friendly")
        clump.Add(companionLimitSequence.CreateCard(companionLimitSequence.activeContainer, data));
    }
    foreach (CardData data in companionLimitSequence.owner.data.inventory.reserve)
    {
      if (data.cardType.name == "Friendly")
        clump.Add(companionLimitSequence.CreateCard(companionLimitSequence.reserveContainer, data));
    }
    clump.Add(Sequences.Wait(companionLimitSequence.startDelay));
    yield return (object) clump.WaitForEnd();
    companionLimitSequence.SetPositions();
    companionLimitSequence.Resolve();
    companionLimitSequence.background.transform.localScale = new Vector3(0.1f, 0.1f, 1f);
    companionLimitSequence.container.transform.localScale = Vector3.one * 0.5f;
    companionLimitSequence.gameObject.SetActive(true);
    LeanTween.cancel(companionLimitSequence.background);
    LeanTween.scale(companionLimitSequence.background, Vector3.one, companionLimitSequence.tweenInDur).setEase(companionLimitSequence.tweenInEase);
    LeanTween.cancel(companionLimitSequence.container);
    LeanTween.scale(companionLimitSequence.container, Vector3.one, companionLimitSequence.tweenInDur).setEase(companionLimitSequence.tweenInEase);
    yield return (object) Sequences.Wait(companionLimitSequence.tweenInDur);
    yield return (object) new WaitUntil(new Func<bool>(companionLimitSequence.\u003CRun\u003Eb__12_0));
    companionLimitSequence.promptEnd = false;
    LeanTween.cancel(companionLimitSequence.background);
    LeanTween.scale(companionLimitSequence.background, Vector3.zero, companionLimitSequence.tweenOutDur).setEase(companionLimitSequence.tweenOutEase);
    LeanTween.cancel(companionLimitSequence.container);
    LeanTween.scale(companionLimitSequence.container, Vector3.zero, companionLimitSequence.tweenOutDur).setEase(companionLimitSequence.tweenOutEase);
    yield return (object) Sequences.Wait(companionLimitSequence.tweenOutDur);
    CompanionLimitSequence.DestroyCards(companionLimitSequence.activeContainer);
    CompanionLimitSequence.DestroyCards(companionLimitSequence.reserveContainer);
    companionLimitSequence.gameObject.SetActive(false);
  }

  public IEnumerator CreateCard(CardContainer container, CardData data)
  {
    Card card = CardManager.Get(data, this.controller, this.owner, false, true);
    container.Add(card.entity);
    container.SetSize(container.Count, 0.67f);
    yield return (object) card.UpdateData(false);
  }

  public void Move(Entity entity)
  {
    if (entity.InContainerGroup(this.activeContainer))
    {
      this.MoveToReserve(entity);
    }
    else
    {
      if (!entity.InContainerGroup(this.reserveContainer))
        return;
      this.MoveToDeck(entity);
    }
  }

  public void MoveToDeck(Entity entity)
  {
    if (!entity.InContainerGroup(this.activeContainer))
    {
      entity.RemoveFromContainers();
      this.activeContainer.Add(entity);
    }
    if (!this.owner.data.inventory.deck.Contains(entity.data))
    {
      this.owner.data.inventory.reserve.Remove(entity.data);
      this.owner.data.inventory.deck.Add(entity.data);
    }
    this.Resolve();
    this.UpdatePositions();
  }

  public void MoveToReserve(Entity entity)
  {
    if (!entity.InContainerGroup(this.reserveContainer))
    {
      entity.RemoveFromContainers();
      this.reserveContainer.Add(entity);
    }
    if (!this.owner.data.inventory.reserve.Contains(entity.data))
    {
      this.owner.data.inventory.deck.Remove(entity.data);
      this.owner.data.inventory.reserve.Add(entity.data);
    }
    this.Resolve();
    this.UpdatePositions();
  }

  public void Toggle()
  {
    if (!this.gameObject.activeSelf)
      this.Begin();
    else
      this.Continue();
  }

  public void Continue()
  {
    this.promptEnd = true;
    this.continueButton.interactable = false;
  }

  public void Resolve()
  {
    int count = this.activeContainer.Count;
    bool flag = count > this.owner.data.companionLimit;
    this.title.text = string.Format(this.textKey.GetLocalizedString(), (object) count, (object) this.owner.data.companionLimit, flag ? (object) this.overColourHex : (object) this.underColourHex);
    this.continueButtonHolder.gameObject.SetActive(!flag);
  }

  public void SetPositions()
  {
    this.activeContainer.SetSize(this.activeContainer.Count, 0.67f);
    this.reserveContainer.SetSize(this.reserveContainer.Count, 0.67f);
    this.activeContainer.SetChildPositions();
    this.reserveContainer.SetChildPositions();
  }

  public void UpdatePositions()
  {
    this.activeContainer.SetSize(this.activeContainer.Count, 0.67f);
    this.reserveContainer.SetSize(this.reserveContainer.Count, 0.67f);
    this.activeContainer.TweenChildPositions();
    this.reserveContainer.TweenChildPositions();
  }

  public static void DestroyCards(CardContainer container)
  {
    foreach (Entity entity in container)
      CardManager.ReturnToPool(entity);
    container.Clear();
  }

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__12_0() => this.promptEnd;
}
﻿// Decompiled with JetBrains decompiler
// Type: CompanionRecoverSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UI;

public class CompanionRecoverSequence : UISequence
{
  public Character owner;
  [SerializeField]
  public TweenUI revealTween;
  [SerializeField]
  public TweenUI hideTween;
  [SerializeField]
  public CardContainer container;
  [SerializeField]
  public CardController controller;
  [SerializeField]
  public Button continueButton;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float cardScale = 0.75f;

  public void OnEnable()
  {
    this.continueButton.interactable = true;
    this.controller.Enable();
  }

  public void OnDisable() => this.Clear();

  public IEnumerator CreateCards(IEnumerable<CardData> cards)
  {
    Routine.Clump clump = new Routine.Clump();
    foreach (CardData card in cards)
      clump.Add(this.CreateCard(card));
    yield return (object) clump.WaitForEnd();
  }

  public IEnumerator CreateCard(CardData data)
  {
    Card card = CardManager.Get(data, this.controller, this.owner, false, true);
    this.container.Add(card.entity);
    this.container.max = this.container.Count;
    yield return (object) card.UpdateData(false);
  }

  public void Clear()
  {
    foreach (Entity entity in this.container)
      CardManager.ReturnToPool(entity);
    this.container.Clear();
  }

  public CardData[] FindRecoveries()
  {
    List<CardData> cardDataList = new List<CardData>();
    foreach (CardData cardData in this.owner.data.inventory.deck.Where<CardData>(new Func<CardData, bool>(CompanionRecoverSequence.IsInjured)))
      cardDataList.Add(cardData);
    foreach (CardData cardData in this.owner.data.inventory.reserve.Where<CardData>(new Func<CardData, bool>(CompanionRecoverSequence.IsInjured)))
      cardDataList.Add(cardData);
    Debug.Log((object) ("Injured companions: [" + string.Join<CardData>(", ", (IEnumerable<CardData>) cardDataList) + "]"));
    CardData[] injuriesThisBattle = InjurySystem.GetInjuriesThisBattle();
    if (injuriesThisBattle.Length != 0)
    {
      cardDataList.RemoveMany<CardData>((ICollection<CardData>) injuriesThisBattle);
      Debug.Log((object) ("[" + string.Join(", ", (object[]) injuriesThisBattle) + "] cannot recover since they died last battle!"));
    }
    return cardDataList.ToArray();
  }

  public static bool IsInjured(CardData card) => card.injuries != null && card.injuries.Count > 0;

  public override IEnumerator Run()
  {
    CompanionRecoverSequence companionRecoverSequence = this;
    CardData[] recoveries = companionRecoverSequence.FindRecoveries();
    if (recoveries.Length != 0)
    {
      companionRecoverSequence.Clear();
      CompanionRecoverSequence.RemoveInjuries((IEnumerable<CardData>) recoveries);
      Routine.Clump clump = new Routine.Clump();
      yield return (object) companionRecoverSequence.CreateCards((IEnumerable<CardData>) recoveries);
      clump.Add(Sequences.Wait(companionRecoverSequence.startDelay));
      yield return (object) clump.WaitForEnd();
      companionRecoverSequence.container.SetChildPositions();
      companionRecoverSequence.gameObject.SetActive(true);
      yield return (object) Sequences.Wait(companionRecoverSequence.revealTween.GetDuration());
      yield return (object) new WaitUntil(new Func<bool>(companionRecoverSequence.\u003CRun\u003Eb__14_0));
      companionRecoverSequence.hideTween.Fire();
      companionRecoverSequence.promptEnd = false;
    }
  }

  public static void RemoveInjuries(IEnumerable<CardData> targets)
  {
    foreach (CardData target in targets)
      target.injuries.Clear();
  }

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__14_0() => this.promptEnd;
}
﻿// Decompiled with JetBrains decompiler
// Type: Config
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public class Config : MonoBehaviourSingleton<Config>
{
  [SerializeField]
  public TextAsset configFile;
  public static Config.Data _data;

  public static Config.Data data => Config._data ?? (Config._data = JsonUtility.FromJson<Config.Data>(MonoBehaviourSingleton<Config>.instance.configFile.text));

  public override void Awake()
  {
    base.Awake();
    Debug.Log((object) (string.Format(Config.data.versionFormat, (object) Config.data.versionNotation) + " Build: " + Config.data.version));
  }

  [Serializable]
  public class Data
  {
    public string version;
    public string versionNotation;
    public string versionFormat;
    public bool beta;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Console
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using Deadpan.Enums.Engine.Components.Modding;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.ResourceManagement.AsyncOperations;

public class Console : MonoBehaviourSingleton<Console>
{
  [SerializeField]
  public KeyCode[] toggle = new KeyCode[2]
  {
    KeyCode.BackQuote,
    KeyCode.F12
  };
  [SerializeField]
  public KeyCode takePredict = KeyCode.Tab;
  [SerializeField]
  public Color logColor;
  [SerializeField]
  public Color logErrorColor;
  [SerializeField]
  public string unknownCommandFormat = "Unknown Command: {0}";
  [SerializeField]
  public Canvas canvas;
  [SerializeField]
  public TMP_InputField input;
  [SerializeField]
  public TMP_Text textPrefab;
  [SerializeField]
  public Transform log;
  [SerializeField]
  public GameObject helpWindow;
  [SerializeField]
  public TMP_Text helpText;
  [SerializeField]
  public ConsoleArgsDisplay argsDisplay;
  [Header("Saving Commands")]
  [SerializeField]
  public KeyCode[] saveKeys = new KeyCode[8]
  {
    KeyCode.F1,
    KeyCode.F2,
    KeyCode.F3,
    KeyCode.F4,
    KeyCode.F5,
    KeyCode.F6,
    KeyCode.F7,
    KeyCode.F8
  };
  [SerializeField]
  public string saveFileName = "commands.sav";
  [SerializeField]
  public string[] savedCommands;
  public static readonly List<string> previous = new List<string>();
  public int preIndex;
  public static List<Console.Command> commands;
  public static bool active;
  public static Entity hover;
  public static CardSlot slotHover;
  public bool promptUpdatePredict;

  public void Start()
  {
    this.LoadCommands();
    this.canvas.gameObject.SetActive(false);
    Console.Commands();
    this.PopulateHelp();
    this.helpWindow.SetActive(false);
    this.StartCoroutine(this.UpdatePredictRoutine());
  }

  public IEnumerator UpdatePredictRoutine()
  {
    while (true)
    {
      if (this.promptUpdatePredict)
      {
        this.promptUpdatePredict = false;
        yield return (object) this.PredictArgsRoutine(this.input.text);
      }
      yield return (object) null;
    }
  }

  public void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(Console.Hover);
    global::Events.OnSlotHover += new UnityAction<CardSlot>(Console.SlotHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(Console.Hover);
    global::Events.OnSlotHover -= new UnityAction<CardSlot>(Console.SlotHover);
  }

  public static void Hover(Entity entity) => Console.hover = entity;

  public static void SlotHover(CardSlot slot) => Console.slotHover = slot;

  public void Update()
  {
    if (this.CheckToggle())
      return;
    if (Console.active)
    {
      if (Input.GetKeyDown(KeyCode.Escape))
      {
        this.Toggle();
      }
      else
      {
        if (this.CheckTakePredict())
          return;
        this.CheckScrollPrevious();
        this.CheckRunCommand();
        this.CheckSaveCommand();
        this.KeepFocus();
      }
    }
    else
      this.CheckRunSavedCommands();
  }

  public bool CheckToggle()
  {
    if (!((IEnumerable<KeyCode>) this.toggle).Any<KeyCode>(new Func<KeyCode, bool>(Input.GetKeyDown)))
      return false;
    this.Toggle();
    return true;
  }

  public bool CheckTakePredict()
  {
    if (!Input.GetKeyDown(this.takePredict) || this.argsDisplay.Count <= 0)
      return false;
    Console.Command exactCommand = Console.GetExactCommand(this.input.text.TrimStart());
    this.input.text = exactCommand == null ? this.argsDisplay.TopCommand : exactCommand.id + " " + this.argsDisplay.TopArgument;
    this.input.MoveToEndOfLine(false, false);
    return true;
  }

  public void CheckScrollPrevious()
  {
    if (Input.GetKeyDown(KeyCode.UpArrow))
    {
      if (Console.previous.Count > 0)
      {
        this.preIndex = Mathf.Min(this.preIndex + 1, Console.previous.Count - 1);
        this.input.text = Console.previous[this.preIndex];
      }
      this.input.MoveToEndOfLine(false, false);
    }
    else
    {
      if (!Input.GetKeyDown(KeyCode.DownArrow))
        return;
      if (Console.previous.Count > 0)
      {
        this.preIndex = Mathf.Max(this.preIndex - 1, 0);
        this.input.text = Console.previous[this.preIndex];
      }
      this.input.MoveToEndOfLine(false, false);
    }
  }

  public void CheckRunCommand()
  {
    if (!Input.GetKeyDown(KeyCode.Return))
      return;
    string text = this.input.text.Trim();
    if (text.Length <= 0)
      return;
    Routine routine = new Routine(Console.HandleCommand(text));
    this.input.text = "";
    this.preIndex = -1;
  }

  public void CheckSaveCommand()
  {
    for (int index = 0; index < this.saveKeys.Length; ++index)
    {
      KeyCode saveKey = this.saveKeys[index];
      if (Input.GetKeyDown(saveKey))
      {
        string str = this.input.text.Trim();
        if (str.Length > 0)
        {
          this.savedCommands[index] = str;
          Console.Log(string.Format("Command '{0}' Saved to {1}", (object) str, (object) saveKey));
          this.SaveCommands();
          this.input.text = "";
          this.preIndex = -1;
        }
        else if (this.savedCommands.Length > index)
        {
          string savedCommand = this.savedCommands[index];
          if (savedCommand.Length > 0)
          {
            Routine routine = new Routine(Console.HandleCommand(savedCommand));
            this.input.text = "";
            this.preIndex = -1;
          }
        }
      }
    }
  }

  public void KeepFocus()
  {
    if (this.input.isFocused)
      return;
    EventSystem current = EventSystem.current;
    if (current == null)
      return;
    current.SetSelectedGameObject(this.input.gameObject, (BaseEventData) null);
    this.input.OnPointerClick(new PointerEventData(current));
  }

  public void CheckRunSavedCommands()
  {
    int num = Mathf.Min(this.saveKeys.Length, this.savedCommands.Length);
    for (int index = 0; index < num; ++index)
    {
      if (Input.GetKeyDown(this.saveKeys[index]))
      {
        string savedCommand = this.savedCommands[index];
        if (savedCommand.Length > 0)
        {
          Routine routine = new Routine(Console.HandleCommand(savedCommand));
        }
      }
    }
  }

  public static void Commands() => Console.commands = new List<Console.Command>()
  {
    (Console.Command) new Console.CommandHelp(),
    (Console.Command) new Console.CommandGainCard(),
    (Console.Command) new Console.CommandGainUpgrade(),
    (Console.Command) new Console.CommandGainGold(),
    (Console.Command) new Console.CommandSetHealth(),
    (Console.Command) new Console.CommandSetAttack(),
    (Console.Command) new Console.CommandSetCounter(),
    (Console.Command) new Console.CommandAddStatus(),
    (Console.Command) new Console.CommandAddUpgrade(),
    (Console.Command) new Console.CommandHit(),
    (Console.Command) new Console.CommandKill(),
    (Console.Command) new Console.CommandKillAll(),
    (Console.Command) new Console.CommandDestroy(),
    (Console.Command) new Console.CommandDestroyAll(),
    (Console.Command) new Console.CommandSpawn(),
    (Console.Command) new Console.CommandBattleWin(),
    (Console.Command) new Console.CommandBattleLose(),
    (Console.Command) new Console.CommandBattleSkip(),
    (Console.Command) new Console.CommandBattleAuto(),
    (Console.Command) new Console.CommandSkipTurn(),
    (Console.Command) new Console.CommandMapJump(),
    (Console.Command) new Console.CommandMapInfo(),
    (Console.Command) new Console.CommandSystemDisable(),
    (Console.Command) new Console.CommandSystemEnable(),
    (Console.Command) new Console.CommandGameSpeed(),
    (Console.Command) new Console.CommandSetSaveProfile(),
    (Console.Command) new Console.CommandVolume(),
    (Console.Command) new Console.CommandVolume("Music"),
    (Console.Command) new Console.CommandVolume("Sfx"),
    (Console.Command) new Console.CommandVolume("Ambience"),
    (Console.Command) new Console.CommandToggleHUD(),
    (Console.Command) new Console.CommandToggleFps(),
    (Console.Command) new Console.CommandToggleHandOverlay(),
    (Console.Command) new Console.CommandCursor(),
    (Console.Command) new Console.CommandReroll(),
    (Console.Command) new Console.CommandRepeat(),
    (Console.Command) new Console.CommandPrompt(),
    (Console.Command) new Console.CommandPromptHide(),
    (Console.Command) new Console.CommandErrorTest(),
    (Console.Command) new Console.CommandPanSpeed(),
    (Console.Command) new Console.CommandNextBattle(),
    (Console.Command) new Console.CommandProgressGain(),
    (Console.Command) new Console.CommandProgressReset(),
    (Console.Command) new Console.CommandScreenshot(),
    (Console.Command) new Console.CommandBlood(),
    (Console.Command) new Console.CommandRunFinalBossScript(),
    (Console.Command) new Console.CommandDailyReset(),
    (Console.Command) new Console.CommandDailyOffset(),
    (Console.Command) new Console.CommandEncrypt(),
    (Console.Command) new Console.CommandDecrypt(),
    (Console.Command) new Console.CommandDisplay(),
    (Console.Command) new Console.LoadModCommand(),
    (Console.Command) new Console.UnLoadModCommand(),
    (Console.Command) new Console.PublishMod()
  };

  public void SaveCommands() => File.WriteAllLines(Application.persistentDataPath + "\\" + this.saveFileName, this.savedCommands);

  public void LoadCommands()
  {
    string path = Application.persistentDataPath + "\\" + this.saveFileName;
    if (File.Exists(path))
    {
      this.savedCommands = File.ReadAllLines(path);
    }
    else
    {
      this.savedCommands = new string[this.saveKeys.Length];
      this.savedCommands[0] = "repeat";
    }
  }

  public static IEnumerator HandleCommand(string text)
  {
    Debug.Log((object) text);
    bool commandFound = false;
    if (Console.commands == null)
      Console.Commands();
    for (int index = Console.commands.Count - 1; index >= 0; --index)
    {
      Console.Command command = Console.commands[index];
      if (text.StartsWith(command.id))
      {
        commandFound = true;
        string args = text.Replace(command.id, "").Trim();
        command.success = true;
        if (command.IsRoutine)
          yield return (object) command.Routine(args);
        else
          command.Run(args);
        if (command.success && command.logOnSuccess)
        {
          Console.Log(text);
          break;
        }
        break;
      }
      command = (Console.Command) null;
    }
    if (!commandFound)
      Console.LogError(string.Format(MonoBehaviourSingleton<Console>.instance.unknownCommandFormat, (object) text));
    Console.previous.Insert(0, text);
  }

  public static void Log(string text)
  {
    TMP_Text tmpText = UnityEngine.Object.Instantiate<TMP_Text>(MonoBehaviourSingleton<Console>.instance.textPrefab, MonoBehaviourSingleton<Console>.instance.log);
    tmpText.text = text;
    tmpText.color = MonoBehaviourSingleton<Console>.instance.logColor;
    tmpText.gameObject.SetActive(true);
  }

  public static void LogError(string text)
  {
    TMP_Text tmpText = UnityEngine.Object.Instantiate<TMP_Text>(MonoBehaviourSingleton<Console>.instance.textPrefab, MonoBehaviourSingleton<Console>.instance.log);
    tmpText.text = text;
    tmpText.color = MonoBehaviourSingleton<Console>.instance.logErrorColor;
    tmpText.gameObject.SetActive(true);
  }

  public void PredictArgs() => this.promptUpdatePredict = true;

  public IEnumerator PredictArgsRoutine(string text)
  {
    text = text.TrimStart();
    if (text.Length > 0)
    {
      yield return (object) new WaitForEndOfFrame();
      yield return (object) null;
      Console.Command[] array1 = Console.commands.Where<Console.Command>((Func<Console.Command, bool>) (a => a.id.StartsWith(text))).ToArray<Console.Command>();
      int length = array1.Length;
      Bounds bounds = this.input.textComponent.textBounds;
      float x = 10f;
      if (length > 0)
      {
        this.argsDisplay.Show();
        this.argsDisplay.DisplayCommands(((IEnumerable<Console.Command>) array1).OrderByDescending<Console.Command, int>((Func<Console.Command, int>) (a => a.id.Length)).ToArray<Console.Command>());
        this.argsDisplay.MoveTo(x);
      }
      else
      {
        Console.Command exactCommand = Console.GetExactCommand(text);
        if (exactCommand != null)
        {
          string args = text.Replace(exactCommand.id + " ", "");
          yield return (object) exactCommand.GetArgOptions(args);
          if (exactCommand.predictedArgs != null && exactCommand.predictedArgs.Length != 0)
          {
            this.argsDisplay.Show();
            string[] array2 = ((IEnumerable<string>) exactCommand.predictedArgs).Where<string>((Func<string, bool>) (a => string.Equals(a, args, StringComparison.CurrentCultureIgnoreCase))).ToArray<string>();
            if (array2.Length != 0)
              this.argsDisplay.DisplayArgs(array2);
            else
              this.argsDisplay.DisplayArgs(((IEnumerable<string>) exactCommand.predictedArgs).OrderByDescending<string, int>((Func<string, int>) (a => a.Length)).ToArray<string>());
            this.argsDisplay.MoveTo(x + 10f + bounds.size.x);
          }
          else
            this.argsDisplay.Hide();
        }
        else
          this.argsDisplay.Hide();
        exactCommand = (Console.Command) null;
      }
      bounds = new Bounds();
    }
    else
      this.argsDisplay.Hide();
    yield return (object) null;
  }

  public static Console.Command GetExactCommand(string text) => Console.commands.FirstOrDefault<Console.Command>((Func<Console.Command, bool>) (a => text.StartsWith(a.id + " ")));

  public void Toggle()
  {
    Console.active = !Console.active;
    this.canvas.gameObject.SetActive(Console.active);
    if (Console.active)
    {
      this.preIndex = -1;
      InputSystem.Disable();
    }
    else
    {
      this.input.text = "";
      InputSystem.Enable();
    }
  }

  public static void ToggleHelp() => MonoBehaviourSingleton<Console>.instance.helpWindow.SetActive(!MonoBehaviourSingleton<Console>.instance.helpWindow.activeSelf);

  public void PopulateHelp()
  {
    string str1 = "";
    foreach (Console.Command command in Console.commands)
    {
      if (!command.hidden)
      {
        string str2 = command.format;
        if (command.desc.Length > 0)
          str2 = str2 + " <i><#fffd>" + command.desc + "</color></i>";
        str1 = str1 + str2 + "\n";
      }
    }
    this.helpText.text = str1.TrimEnd();
  }

  public abstract class Command
  {
    public bool success;
    [CompilerGenerated]
    public string \u003CfailMessage\u003Ek__BackingField;
    public string[] predictedArgs;

    public virtual string id => "";

    public virtual string desc => "";

    public virtual string format => this.id;

    public virtual bool hidden => false;

    public virtual bool logOnSuccess => true;

    public string failMessage
    {
      get => this.\u003CfailMessage\u003Ek__BackingField;
      set => this.\u003CfailMessage\u003Ek__BackingField = value;
    }

    public virtual bool IsRoutine => false;

    public virtual void Run(string args)
    {
    }

    public virtual IEnumerator Routine(string args) => (IEnumerator) null;

    public virtual IEnumerator GetArgOptions(string currentArgs) => (IEnumerator) null;

    public void Fail(string message)
    {
      this.success = false;
      this.failMessage = this.failMessage;
      Console.LogError(message);
    }

    public void FailCannotUse() => this.Fail("Cannot use [" + this.id + "] command here");

    public bool TryGetPlayer(out Character player, bool doFail = true)
    {
      player = (Character) null;
      if (!(bool) (UnityEngine.Object) Campaign.instance)
      {
        if (doFail)
          this.FailCannotUse();
        return false;
      }
      player = References.Player;
      if ((bool) (UnityEngine.Object) player)
        return true;
      if (doFail)
        this.FailCannotUse();
      return false;
    }

    public static string[] Split(string text) => text.Length <= 0 ? new string[1]
    {
      ""
    } : text.Split(new char[1]{ ' ' }, StringSplitOptions.RemoveEmptyEntries);
  }

  public class CommandHelp : Console.Command
  {
    public override string id => "help";

    public override bool hidden => true;

    public override bool logOnSuccess => false;

    public override void Run(string args) => Console.ToggleHelp();
  }

  public class CommandRepeat : Console.Command
  {
    public override string id => "repeat";

    public override string format => "repeat <times>";

    public override bool logOnSuccess => false;

    public override void Run(string args)
    {
      if (Console.previous.Count <= 0)
        return;
      int result = 1;
      if (args.Length > 0)
        int.TryParse(args, out result);
      Routine routine = new Routine(Console.CommandRepeat.Repeat(Console.previous[0], result));
    }

    public static IEnumerator Repeat(string command, int repeats)
    {
      while (repeats > 0)
      {
        --repeats;
        yield return (object) Console.HandleCommand(command);
      }
    }
  }

  public class CommandGainCard : Console.Command
  {
    public override string id => "gain card";

    public override string format => "gain card <name>";

    public override bool IsRoutine => true;

    public override IEnumerator Routine(string args)
    {
      Console.CommandGainCard commandGainCard = this;
      if (args.Length > 0)
      {
        Character player;
        if (commandGainCard.TryGetPlayer(out player))
        {
          yield return (object) AddressableLoader.LoadGroup("CardData");
          IEnumerable<CardData> source = AddressableLoader.GetGroup<CardData>("CardData").Where<CardData>((Func<CardData, bool>) (a => string.Equals(a.name, args, StringComparison.CurrentCultureIgnoreCase)));
          if (source.Any<CardData>())
          {
            CardData cardData = source.First<CardData>();
            if (cardData != null)
            {
              CardData data = cardData.Clone();
              player.data.inventory.deck.Add(data);
              if ((bool) (UnityEngine.Object) Battle.instance && (bool) (UnityEngine.Object) player.handContainer)
              {
                Card card = CardManager.Get(data, Battle.instance.playerCardController, player, true, true);
                card.entity.flipper.FlipDownInstant();
                card.transform.localPosition = new Vector3(-100f, 0.0f, 0.0f);
                yield return (object) card.UpdateData(false);
                player.handContainer.Add(card.entity);
                player.handContainer.TweenChildPositions();
                ActionQueue.Add((PlayAction) new ActionReveal(card.entity));
                ActionQueue.Add((PlayAction) new ActionRunEnableEvent(card.entity));
                yield return (object) ActionQueue.Wait();
                card = (Card) null;
                goto label_7;
              }
              else
                goto label_7;
            }
          }
          commandGainCard.Fail("Card [" + args + "] does not exist!");
        }
label_7:
        player = (Character) null;
      }
      else
        commandGainCard.Fail("You must provide a card name");
    }

    public override IEnumerator GetArgOptions(string currentArgs)
    {
      Console.CommandGainCard commandGainCard = this;
      yield return (object) AddressableLoader.LoadGroup("CardData");
      IEnumerable<CardData> source = AddressableLoader.GetGroup<CardData>("CardData").Where<CardData>((Func<CardData, bool>) (a => a.name.ToLower().Contains(currentArgs.ToLower())));
      commandGainCard.predictedArgs = source.Select<CardData, string>((Func<CardData, string>) (cardData => cardData.name)).ToArray<string>();
    }
  }

  public class CommandGainUpgrade : Console.Command
  {
    public override string id => "gain upgrade";

    public override string format => "gain upgrade <name>";

    public override bool IsRoutine => true;

    public override IEnumerator Routine(string args)
    {
      Console.CommandGainUpgrade commandGainUpgrade = this;
      if (args.Length > 0)
      {
        Character player;
        if (commandGainUpgrade.TryGetPlayer(out player, false))
        {
          yield return (object) AddressableLoader.LoadGroup("CardUpgradeData");
          try
          {
            player.data.inventory.upgrades.Add(AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData").First<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => string.Equals(a.name, args, StringComparison.CurrentCultureIgnoreCase))).Clone());
          }
          catch
          {
            commandGainUpgrade.Fail("Upgrade [" + args + "] does not exist!");
          }
        }
        else
        {
          GameObject withTag = GameObject.FindWithTag("CharmHolder");
          CardCharmHolder cardCharmHolder;
          if (withTag != null)
          {
            cardCharmHolder = withTag.GetComponent<CardCharmHolder>();
            if (cardCharmHolder != null)
            {
              yield return (object) AddressableLoader.LoadGroup("CardUpgradeData");
              try
              {
                cardCharmHolder.Create(AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData").First<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => string.Equals(a.name, args, StringComparison.CurrentCultureIgnoreCase))).Clone());
                cardCharmHolder.SetPositions();
              }
              catch
              {
                commandGainUpgrade.Fail("Upgrade [" + args + "] does not exist!");
              }
            }
          }
          cardCharmHolder = (CardCharmHolder) null;
        }
        player = (Character) null;
      }
      else
        commandGainUpgrade.Fail("You must provide an upgrade name");
    }

    public override IEnumerator GetArgOptions(string currentArgs)
    {
      Console.CommandGainUpgrade commandGainUpgrade = this;
      yield return (object) AddressableLoader.LoadGroup("CardUpgradeData");
      IEnumerable<CardUpgradeData> cardUpgradeDatas = AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData").Where<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => a.name.ToLower().Contains(currentArgs.ToLower())));
      List<string> stringList = new List<string>();
      foreach (CardUpgradeData cardUpgradeData in cardUpgradeDatas)
        stringList.Add(cardUpgradeData.name);
      commandGainUpgrade.predictedArgs = stringList.ToArray();
    }
  }

  public class CommandGainGold : Console.Command
  {
    public override string id => "gain blings";

    public override string format => "gain blings <amount>";

    public override void Run(string args)
    {
      int result = 10;
      if (args.Length > 0 && !int.TryParse(args, out result))
      {
        this.Fail("Invalid amount! (" + args + ")");
      }
      else
      {
        Character player;
        if (!this.TryGetPlayer(out player))
          return;
        player.GainGold(result);
      }
    }
  }

  public class CommandSpawn : Console.Command
  {
    public override string id => "spawn";

    public override string format => "spawn <unit>";

    public override bool IsRoutine => true;

    public override IEnumerator Routine(string args)
    {
      Console.CommandSpawn commandSpawn = this;
      if (!(bool) (UnityEngine.Object) References.Battle)
        commandSpawn.Fail("Must be in battle to use this command");
      else if (args.Length <= 0)
        commandSpawn.Fail("You must provide a card name");
      else if (!(bool) (UnityEngine.Object) Console.slotHover)
        commandSpawn.Fail("You must hover over a slot to use this command");
      else if (!Console.slotHover.Empty)
      {
        commandSpawn.Fail("That slot is not empty!");
      }
      else
      {
        yield return (object) AddressableLoader.LoadGroup("CardData");
        IEnumerable<CardData> source = AddressableLoader.GetGroup<CardData>("CardData").Where<CardData>((Func<CardData, bool>) (a => a.cardType.unit && string.Equals(a.name, args, StringComparison.CurrentCultureIgnoreCase)));
        if (source.Any<CardData>())
        {
          CardData cardData = source.First<CardData>();
          if (cardData != null)
          {
            Card card = CardManager.Get(cardData.Clone(), References.Battle.playerCardController, Console.slotHover.owner, true, Console.slotHover.owner.team == References.Player.team);
            card.entity.flipper.FlipDownInstant();
            card.transform.localPosition = new Vector3(-100f, 0.0f, 0.0f);
            yield return (object) card.UpdateData(false);
            Console.slotHover.Add(card.entity);
            Console.slotHover.TweenChildPositions();
            ActionQueue.Add((PlayAction) new ActionReveal(card.entity));
            ActionQueue.Add((PlayAction) new ActionRunEnableEvent(card.entity));
            yield return (object) ActionQueue.Wait();
            card = (Card) null;
            yield break;
          }
        }
        commandSpawn.Fail("Card [" + args + "] does not exist!");
      }
    }

    public override IEnumerator GetArgOptions(string currentArgs)
    {
      Console.CommandSpawn commandSpawn = this;
      yield return (object) AddressableLoader.LoadGroup("CardData");
      IEnumerable<CardData> source = AddressableLoader.GetGroup<CardData>("CardData").Where<CardData>((Func<CardData, bool>) (a => a.cardType.unit && a.name.ToLower().Contains(currentArgs.ToLower())));
      commandSpawn.predictedArgs = source.Select<CardData, string>((Func<CardData, string>) (cardData => cardData.name)).ToArray<string>();
    }
  }

  public class CommandBattleWin : Console.Command
  {
    public override string id => "battle win";

    public override void Run(string args)
    {
      if ((UnityEngine.Object) Battle.instance == (UnityEngine.Object) null)
        this.FailCannotUse();
      else if (Battle.instance.phase == Battle.Phase.End)
        this.Fail("The battle is already over!");
      else
        Battle.instance.PlayerWin();
    }
  }

  public class CommandBattleLose : Console.Command
  {
    public override string id => "battle lose";

    public override void Run(string args)
    {
      if ((UnityEngine.Object) Battle.instance == (UnityEngine.Object) null)
        this.FailCannotUse();
      else if (Battle.instance.phase == Battle.Phase.End)
        this.Fail("The battle is already over!");
      else
        Battle.instance.EnemyWin();
    }
  }

  public class CommandBattleSkip : Console.Command
  {
    public override string id => "battle skip";

    public override string desc => "to next wave";

    public override void Run(string args)
    {
      if ((UnityEngine.Object) Battle.instance == (UnityEngine.Object) null)
        this.FailCannotUse();
      else if (Battle.instance.phase == Battle.Phase.End)
      {
        this.Fail("The battle is already over!");
      }
      else
      {
        foreach (Entity entity in Battle.GetCardsOnBoard(Battle.instance.enemy))
        {
          entity.RemoveFromContainers();
          CardManager.ReturnToPool(entity);
        }
        ActionQueue.Add((PlayAction) new ActionEndTurn(Battle.instance.player));
        Battle.instance.playerCardController.Disable();
        CardPopUp.Clear();
      }
    }
  }

  public class CommandBattleAuto : Console.Command
  {
    public override string id => "battle auto";

    public override string desc => "play out the rest of the battle automatically";

    public override void Run(string args)
    {
      if (!(bool) (UnityEngine.Object) References.Battle)
        this.FailCannotUse();
      else if (References.Battle.phase == Battle.Phase.End)
        this.Fail("The battle is already over!");
      else
        References.Battle.auto = !References.Battle.auto;
    }
  }

  public class CommandSkipTurn : Console.Command
  {
    public override string id => "skip turn";

    public override void Run(string args)
    {
      if ((UnityEngine.Object) Battle.instance == (UnityEngine.Object) null)
        this.FailCannotUse();
      else if (Battle.instance.phase == Battle.Phase.End)
      {
        this.Fail("The battle is already over!");
      }
      else
      {
        ActionQueue.Add((PlayAction) new ActionEndTurn(Battle.instance.player));
        Battle.instance.playerCardController.Disable();
        CardPopUp.Clear();
      }
    }
  }

  public class CommandSetHealth : Console.Command
  {
    public override string id => "set health";

    public override string format => "set health <value>";

    public override void Run(string args)
    {
      if (args.Length < 1)
        this.Fail("You must provide a value");
      else if ((UnityEngine.Object) Console.hover == (UnityEngine.Object) null)
      {
        this.Fail("Please hover over a card to use this command");
      }
      else
      {
        int result;
        if (!int.TryParse(args, out result) || result <= 0)
          this.Fail("Invalid value! (" + args + ")");
        else if (!Console.hover.enabled || !Console.hover.data.hasHealth)
        {
          this.Fail("Cannot use on this card");
        }
        else
        {
          Console.hover.hp.current = result;
          Console.hover.hp.max = Mathf.Max(Console.hover.hp.max, Console.hover.hp.current);
          Console.hover.PromptUpdate();
        }
      }
    }
  }

  public class CommandSetAttack : Console.Command
  {
    public override string id => "set attack";

    public override string format => "set attack <value>";

    public override void Run(string args)
    {
      if (args.Length < 1)
        this.Fail("You must provide a value");
      else if ((UnityEngine.Object) Console.hover == (UnityEngine.Object) null)
      {
        this.Fail("Please hover over a card to use this command");
      }
      else
      {
        int result;
        if (!int.TryParse(args, out result) || result <= 0)
          this.Fail("Invalid value! (" + args + ")");
        else if (!Console.hover.enabled || !Console.hover.data.hasAttack)
        {
          this.Fail("Cannot use on this card");
        }
        else
        {
          Console.hover.damage.current = result;
          Console.hover.damage.max = result;
          Console.hover.PromptUpdate();
        }
      }
    }
  }

  public class CommandSetCounter : Console.Command
  {
    public override string id => "set counter";

    public override string format => "set counter <value>";

    public override void Run(string args)
    {
      if (args.Length < 1)
        this.Fail("You must provide a value");
      else if ((UnityEngine.Object) Console.hover == (UnityEngine.Object) null)
      {
        this.Fail("Please hover over a card to use this command");
      }
      else
      {
        int result;
        if (!int.TryParse(args, out result) || result <= 0)
          this.Fail("Invalid value! (" + args + ")");
        else if (!Console.hover.enabled || !Console.hover.data.hasAttack)
        {
          this.Fail("Cannot use on this card");
        }
        else
        {
          Console.hover.counter.current = result;
          Console.hover.counter.max = Mathf.Max(Console.hover.counter.max, result);
          Console.hover.PromptUpdate();
        }
      }
    }
  }

  public class CommandAddStatus : Console.Command
  {
    public override string id => "add status";

    public override string format => "add status <name>";

    public override bool IsRoutine => true;

    public override IEnumerator Routine(string args)
    {
      Console.CommandAddStatus commandAddStatus = this;
      if (args.Length > 0)
      {
        if ((UnityEngine.Object) Console.hover != (UnityEngine.Object) null)
        {
          if (Console.hover.enabled)
          {
            string[] strArray = Console.Command.Split(args);
            string statusName = strArray[0];
            int count = 1;
            if (strArray.Length > 1)
              int.TryParse(strArray[1], out count);
            yield return (object) AddressableLoader.LoadGroup("StatusEffectData");
            IEnumerable<StatusEffectData> source = AddressableLoader.GetGroup<StatusEffectData>("StatusEffectData").Where<StatusEffectData>((Func<StatusEffectData, bool>) (a => a.visible && !a.name.Contains(' ') && string.Equals(a.name, statusName, StringComparison.CurrentCultureIgnoreCase)));
            if (source.Any<StatusEffectData>())
            {
              StatusEffectData effectData = source.First<StatusEffectData>();
              if (effectData != null)
              {
                yield return (object) StatusEffectSystem.Apply(Console.hover, (Entity) null, effectData, count);
                goto label_9;
              }
            }
            commandAddStatus.Fail("StatusEffect [" + statusName + "] does not exist!");
label_9:;
          }
          else
            commandAddStatus.Fail("Cannot use on that card");
        }
        else
          commandAddStatus.Fail("Please hover over a card to use this command");
      }
      else
        commandAddStatus.Fail("You must provide a StatusEffect name");
    }

    public override IEnumerator GetArgOptions(string currentArgs)
    {
      Console.CommandAddStatus commandAddStatus = this;
      yield return (object) AddressableLoader.LoadGroup("StatusEffectData");
      IEnumerable<StatusEffectData> source = AddressableLoader.GetGroup<StatusEffectData>("StatusEffectData").Where<StatusEffectData>((Func<StatusEffectData, bool>) (a => a.visible && !a.name.Contains(' ') && a.name.ToLower().Contains(currentArgs.ToLower())));
      commandAddStatus.predictedArgs = source.Select<StatusEffectData, string>((Func<StatusEffectData, string>) (effectData => effectData.name)).ToArray<string>();
    }
  }

  public class CommandAddUpgrade : Console.Command
  {
    public override string id => "add upgrade";

    public override string format => "add upgrade <name>";

    public override bool IsRoutine => true;

    public override IEnumerator Routine(string args)
    {
      Console.CommandAddUpgrade commandAddUpgrade = this;
      if (args.Length > 0)
      {
        if ((UnityEngine.Object) Console.hover != (UnityEngine.Object) null)
        {
          yield return (object) AddressableLoader.LoadGroup("CardUpgradeData");
          IEnumerable<CardUpgradeData> source = AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData").Where<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => a.name.ToLower() == args.ToLower()));
          if (source.Any<CardUpgradeData>())
          {
            CardUpgradeData cardUpgradeData = source.First<CardUpgradeData>();
            if (cardUpgradeData != null)
            {
              if (cardUpgradeData.CanAssign(Console.hover))
              {
                yield return (object) cardUpgradeData.Clone().Assign(Console.hover);
                yield break;
              }
              else
              {
                commandAddUpgrade.Fail("Upgrade [" + cardUpgradeData.name + "] cannot be assigned to [" + Console.hover.data.title + "]");
                yield break;
              }
            }
          }
          commandAddUpgrade.Fail("Upgrade [" + args + "] does not exist!");
        }
        else
          commandAddUpgrade.Fail("Please hover over a card to use this command");
      }
      else
        commandAddUpgrade.Fail("You must provide an upgrade name");
    }

    public override IEnumerator GetArgOptions(string currentArgs)
    {
      Console.CommandAddUpgrade commandAddUpgrade = this;
      yield return (object) AddressableLoader.LoadGroup("CardUpgradeData");
      IEnumerable<CardUpgradeData> source = AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData").Where<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => a.name.ToLower().Contains(currentArgs.ToLower())));
      commandAddUpgrade.predictedArgs = source.Select<CardUpgradeData, string>((Func<CardUpgradeData, string>) (upgradeData => upgradeData.name)).ToArray<string>();
    }
  }

  public class CommandDestroy : Console.Command
  {
    public override string id => "destroy";

    public override void Run(string args)
    {
      if ((UnityEngine.Object) Console.hover == (UnityEngine.Object) null)
        this.Fail("Please hover over a card to use this command");
      else if (!Console.hover.enabled)
      {
        this.Fail("Cannot destroy this card");
      }
      else
      {
        Console.hover.RemoveFromContainers();
        CardManager.ReturnToPool(Console.hover);
        CardPopUp.Clear();
      }
    }
  }

  public class CommandDestroyAll : Console.Command
  {
    public override string id => "destroy all";

    public override void Run(string args)
    {
      if ((UnityEngine.Object) Battle.instance == (UnityEngine.Object) null)
      {
        this.Fail("Must be in battle to use this command");
      }
      else
      {
        foreach (Entity entity in Battle.GetCardsOnBoard(Battle.instance.enemy))
        {
          entity.RemoveFromContainers();
          CardManager.ReturnToPool(entity);
        }
        ActionQueue.Add((PlayAction) new ActionEndTurn(Battle.instance.player));
        Battle.instance.playerCardController.Disable();
        CardPopUp.Clear();
      }
    }
  }

  public class CommandHit : Console.Command
  {
    public override string id => "hit";

    public override string format => "hit <damage>";

    public override bool IsRoutine => true;

    public override IEnumerator Routine(string args)
    {
      Console.CommandHit commandHit = this;
      if (!(bool) (UnityEngine.Object) Console.hover)
      {
        commandHit.Fail("Please hover over a card to use this command");
      }
      else
      {
        int result = 1;
        if (args.Length > 0)
          int.TryParse(args, out result);
        Character player = References.Player;
        if (player != null && (bool) (UnityEngine.Object) player.entity)
          yield return (object) new Hit(player.entity, Console.hover, result)
          {
            canRetaliate = false
          }.Process();
        else
          commandHit.FailCannotUse();
      }
    }
  }

  public class CommandKill : Console.Command
  {
    public override string id => "kill";

    public override void Run(string args)
    {
      if ((UnityEngine.Object) Console.hover == (UnityEngine.Object) null)
        this.Fail("Please hover over a card to use this command");
      else if (!Console.hover.enabled)
      {
        this.Fail("Cannot kill this card");
      }
      else
      {
        Console.hover.forceKill = true;
        Console.hover.PromptUpdate();
      }
    }
  }

  public class CommandKillAll : Console.Command
  {
    public override string id => "kill all";

    public override void Run(string args)
    {
      if ((UnityEngine.Object) Battle.instance == (UnityEngine.Object) null)
      {
        this.Fail("Must be in battle to use this command");
      }
      else
      {
        foreach (Entity entity in Battle.GetCardsOnBoard(Battle.instance.enemy))
        {
          entity.forceKill = true;
          entity.PromptUpdate();
        }
        ActionQueue.Add((PlayAction) new ActionEndTurn(Battle.instance.player));
        Battle.instance.playerCardController.Disable();
      }
    }
  }

  public class CommandReroll : Console.Command
  {
    public override string id => "reroll";

    public override string desc => "new leaders, or card rewards";

    public override void Run(string args)
    {
      foreach (IRerollable rerollable in UnityEngine.Object.FindObjectsOfType<MonoBehaviour>().OfType<IRerollable>())
      {
        Debug.Log((object) string.Format("Rerolling [{0}]", (object) rerollable));
        if (rerollable.Reroll())
          return;
      }
      this.Fail("Nothing to reroll");
    }
  }

  public class CommandSystemDisable : Console.Command
  {
    public override string id => "system disable";

    public override string format => "system disable <name>";

    public override void Run(string args)
    {
      if (args.Length <= 0)
      {
        this.Fail("You must provide a system name");
      }
      else
      {
        System.Type type = System.Type.GetType(args + ",Assembly-CSharp");
        if (type == (System.Type) null)
        {
          this.Fail("System '" + args + "' not found! (it's case sensitive)");
        }
        else
        {
          MonoBehaviour objectOfType = UnityEngine.Object.FindObjectOfType(type) as MonoBehaviour;
          if ((UnityEngine.Object) objectOfType == (UnityEngine.Object) null)
          {
            this.Fail("System '" + args + "' does not exist!");
          }
          else
          {
            if (!objectOfType.enabled)
              this.Fail("'" + args + "' is already disabled");
            objectOfType.enabled = false;
          }
        }
      }
    }

    public override IEnumerator GetArgOptions(string currentArgs)
    {
      Console.CommandSystemDisable commandSystemDisable = this;
      yield return (object) null;
      IEnumerable<GameSystem> source = ((IEnumerable<GameSystem>) UnityEngine.Object.FindObjectsOfType<GameSystem>()).Where<GameSystem>((Func<GameSystem, bool>) (a => a.enabled && a.GetType().ToString().ToLower().Contains(currentArgs.ToLower())));
      commandSystemDisable.predictedArgs = source.Select<GameSystem, string>((Func<GameSystem, string>) (s => s.GetType().ToString())).ToArray<string>();
    }
  }

  public class CommandSystemEnable : Console.Command
  {
    public override string id => "system enable";

    public override string format => "system enable <name>";

    public override void Run(string args)
    {
      if (args.Length <= 0)
      {
        this.Fail("You must provide a system name");
      }
      else
      {
        System.Type type = System.Type.GetType(args + ",Assembly-CSharp");
        if (type == (System.Type) null)
        {
          this.Fail("System '" + args + "' not found! (it's case sensitive)");
        }
        else
        {
          MonoBehaviour objectOfType = UnityEngine.Object.FindObjectOfType(type) as MonoBehaviour;
          if ((UnityEngine.Object) objectOfType == (UnityEngine.Object) null)
          {
            this.Fail("System '" + args + "' does not exist!");
          }
          else
          {
            if (objectOfType.enabled)
              this.Fail("'" + args + "' is already enabled");
            objectOfType.enabled = true;
          }
        }
      }
    }

    public override IEnumerator GetArgOptions(string currentArgs)
    {
      Console.CommandSystemEnable commandSystemEnable = this;
      yield return (object) null;
      IEnumerable<GameSystem> source = ((IEnumerable<GameSystem>) UnityEngine.Object.FindObjectsOfType<GameSystem>()).Where<GameSystem>((Func<GameSystem, bool>) (a => !a.enabled && a.GetType().ToString().ToLower().Contains(currentArgs.ToLower())));
      commandSystemEnable.predictedArgs = source.Select<GameSystem, string>((Func<GameSystem, string>) (s => s.GetType().ToString())).ToArray<string>();
    }
  }

  public class CommandGameSpeed : Console.Command
  {
    public override string id => "gamespeed";

    public override string format => "gamespeed <value>";

    public override void Run(string args)
    {
      if (args.Length <= 0)
      {
        this.Fail("You must provide a value (1 = normal speed, 2 = double speed, 0.5 = half speed)");
      }
      else
      {
        float result;
        if (float.TryParse(args, out result) && (double) result >= 0.0)
          global::Events.InvokeTimeScaleChange(result);
        else
          this.Fail("Invalid value! (" + args + ")");
      }
    }
  }

  public class CommandMapJump : Console.Command
  {
    public override string id => "map jump";

    public override string desc => "to the selected map node";

    public override void Run(string args)
    {
      MapNode[] objectsOfType = UnityEngine.Object.FindObjectsOfType<MapNode>();
      if (objectsOfType.Length == 0)
      {
        this.FailCannotUse();
      }
      else
      {
        MapNode node = ((IEnumerable<MapNode>) objectsOfType).FirstOrDefault<MapNode>((Func<MapNode, bool>) (n => n.IsHovered));
        if ((UnityEngine.Object) node == (UnityEngine.Object) null)
        {
          this.Fail("You must be hovering over a map node");
        }
        else
        {
          Character player = References.Player;
          if (player != null)
          {
            MapNew.MoveTo(player, node);
            if (!node.campaignNode.type.canSkip)
              node.campaignNode.SetCleared();
            node.map.Continue(true);
          }
          else
            this.Fail("Player does not exist!");
        }
      }
    }
  }

  public class CommandMapInfo : Console.Command
  {
    public override string id => "map info";

    public override string format => "map info";

    public override bool IsRoutine => false;

    public override void Run(string args)
    {
      MapNode[] objectsOfType = UnityEngine.Object.FindObjectsOfType<MapNode>();
      if (objectsOfType.Length == 0)
      {
        this.FailCannotUse();
      }
      else
      {
        MapNode mapNode = ((IEnumerable<MapNode>) objectsOfType).FirstOrDefault<MapNode>((Func<MapNode, bool>) (n => n.IsHovered));
        if (!(bool) (UnityEngine.Object) mapNode)
        {
          this.Fail("You must be hovering over a map node");
        }
        else
        {
          Debug.Log((object) string.Format("[{0} {1}] info:", (object) mapNode.campaignNode.name, (object) mapNode.campaignNode.id));
          foreach (KeyValuePair<string, object> keyValuePair in mapNode.campaignNode.data)
          {
            switch (keyValuePair.Value)
            {
              case ICollection<string> values:
                Debug.Log((object) (keyValuePair.Key + ": " + string.Join(", ", (IEnumerable<string>) values)));
                continue;
              case SaveCollection<string> saveCollection:
                Debug.Log((object) (keyValuePair.Key + ": " + string.Join(", ", saveCollection.collection)));
                continue;
              default:
                Debug.Log((object) string.Format("{0}: {1}", (object) keyValuePair.Key, keyValuePair.Value));
                continue;
            }
          }
        }
      }
    }
  }

  public class CommandSetSaveProfile : Console.Command
  {
    public override string id => "save profile";

    public override string format => "save profile <name>";

    public override string desc => "switch save profile";

    public override void Run(string args)
    {
      if ((UnityEngine.Object) Campaign.instance == (UnityEngine.Object) null)
        SaveSystem.SetProfile(args);
      else
        this.Fail("Cannot switch save profile here!");
    }
  }

  public class CommandVolume : Console.Command
  {
    public readonly string busName;
    public readonly string internalId = "volume";
    public readonly string internalFormat = "volume <0-1>";

    public override string id => this.internalId;

    public override string format => this.internalFormat;

    public CommandVolume(string busName = "Master")
    {
      string lower = busName.ToLower();
      this.busName = lower == "sfx" ? "SFX" : lower.ToUpperFirstLetter();
      if (!(lower != "master"))
        return;
      this.internalId = "volume " + lower;
      this.internalFormat = this.internalId + " <0-1>";
    }

    public override void Run(string args)
    {
      if (args.Length <= 0)
      {
        this.Fail("You must provide a value between 0 and 1");
      }
      else
      {
        float result;
        if (float.TryParse(args, out result))
          AudioSettingsSystem.Volume(this.busName, result);
        else
          this.Fail("Invalid value! (" + args + ")");
      }
    }
  }

  public abstract class CommandOptions : Console.Command
  {
    public override string format => this.id + " <" + string.Join("/", this.options) + ">";

    public virtual string[] options => new string[2]
    {
      "on",
      "off"
    };

    public override IEnumerator GetArgOptions(string currentArgs)
    {
      // ISSUE: reference to a compiler-generated field
      int num = this.\u003C\u003E1__state;
      Console.CommandOptions commandOptions = this;
      if (num != 0)
      {
        if (num != 1)
          return false;
        // ISSUE: reference to a compiler-generated field
        this.\u003C\u003E1__state = -1;
        return false;
      }
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      commandOptions.predictedArgs = ((IEnumerable<string>) commandOptions.options).Where<string>((Func<string, bool>) (a => a.Contains(currentArgs.ToLower()))).ToArray<string>();
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E2__current = (object) null;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = 1;
      return true;
    }
  }

  public abstract class CommandToggle : Console.CommandOptions
  {
    public override void Run(string args)
    {
      switch (args.ToLower())
      {
        case "on":
          this.TurnOn();
          break;
        case "off":
          this.TurnOff();
          break;
        default:
          this.Fail("You must enter either 'on' or 'off'");
          break;
      }
    }

    public virtual void TurnOn()
    {
    }

    public virtual void TurnOff()
    {
    }
  }

  public class CommandToggleHUD : Console.CommandToggle
  {
    public override string id => "hud";

    public override void TurnOn() => Settings.Save<float>("HudAlpha", 1f);

    public override void TurnOff() => Settings.Save<float>("HudAlpha", 0.0f);
  }

  public class CommandToggleFps : Console.CommandToggle
  {
    public override string id => "fps";

    public override void TurnOn() => Settings.Save<bool>("ShowFps", true);

    public override void TurnOff() => Settings.Save<bool>("ShowFps", false);
  }

  public class CommandCursor : Console.CommandOptions
  {
    public override string id => "cursor";

    public override string[] options => new string[3]
    {
      "off",
      "game",
      "system"
    };

    public override void Run(string args)
    {
      switch (args)
      {
        case "off":
          CustomCursor.visible = false;
          CustomCursor.UpdateState();
          break;
        case "game":
          CustomCursor.visible = true;
          CustomCursor.SetStyle("default");
          CustomCursor.UpdateState();
          break;
        case "system":
          CustomCursor.visible = true;
          CustomCursor.SetStyle("system");
          CustomCursor.UpdateState();
          break;
        default:
          this.Fail("Invalid cursor option");
          break;
      }
    }
  }

  public class CommandToggleHandOverlay : Console.CommandToggle
  {
    public override string id => "handoverlay";

    public override void TurnOn() => Settings.Save<bool>("HideHandOverlay", false);

    public override void TurnOff() => Settings.Save<bool>("HideHandOverlay", true);
  }

  public class CommandPrompt : Console.Command
  {
    public override string id => "prompt";

    public override string format => "prompt <anchor> <x> <y> <maxWidth> <text>";

    public override void Run(string args)
    {
      List<string> list = args.Split(' ', StringSplitOptions.None).ToList<string>();
      if (list.Count <= 4)
        return;
      Prompt.Anchor result1;
      float result2;
      float result3;
      float result4;
      if (Enum.TryParse<Prompt.Anchor>(list[0].ToUpperFirstLetter(), out result1) && float.TryParse(list[1], out result2) && float.TryParse(list[2], out result3) && float.TryParse(list[3], out result4))
      {
        list.RemoveRange(0, 4);
        string.Join(" ", (IEnumerable<string>) list);
        PromptSystem.Create(result1, result2, result3, result4);
      }
      else
        this.Fail("Invalid arguments");
    }
  }

  public class CommandPromptHide : Console.Command
  {
    public override string id => "prompthide";

    public override void Run(string args) => PromptSystem.Hide();
  }

  public class CommandErrorTest : Console.Command
  {
    public override string id => "errortest";

    public override string format => "errortest <message>";

    public override void Run(string args)
    {
      MonoBehaviourSingleton<Console>.instance.Toggle();
      throw new Exception(args);
    }
  }

  public class CommandPanSpeed : Console.Command
  {
    public override string id => "pan speed";

    public override string format => "pan speed <value (default 5)>";

    public override void Run(string args)
    {
      if (UnityEngine.Object.FindObjectOfType<Scroller>() != null)
      {
        List<string> list = args.Split(' ', StringSplitOptions.None).ToList<string>();
        if (list.Count > 0 && float.TryParse(list[0], out float _))
          return;
        this.Fail("Please enter a value");
      }
      else
        this.Fail("You must be in the town scene to use this command");
    }
  }

  public class CommandNextBattle : Console.Command
  {
    public override string id => "next battle";

    public override string format => "next battle <battle>";

    public override bool IsRoutine => true;

    public override IEnumerator Routine(string args)
    {
      Console.CommandNextBattle commandNextBattle = this;
      Campaign campaign = References.Campaign;
      if (campaign != null)
      {
        if (args.Length > 0)
        {
          yield return (object) AddressableLoader.LoadGroup("BattleData");
          BattleData battleData = AddressableLoader.GetGroup<BattleData>("BattleData").FirstOrDefault<BattleData>((Func<BattleData, bool>) (a => string.Equals(a.name, args.Trim(), StringComparison.CurrentCultureIgnoreCase)));
          if ((bool) (UnityEngine.Object) battleData)
          {
            int num = campaign.nodes.IndexOf(Campaign.FindCharacterNode(References.Player));
            CampaignNode campaignNode = (CampaignNode) null;
            for (int index = num; index < campaign.nodes.Count; ++index)
            {
              CampaignNode node = campaign.nodes[index];
              if (!node.cleared && node.type.isBattle)
              {
                campaignNode = node;
                break;
              }
            }
            if (campaignNode != null)
              campaignNode.data = new Dictionary<string, object>()
              {
                ["battle"] = (object) battleData.name,
                ["waves"] = (object) battleData.generationScript.Run(battleData, 1000)
              };
            else
              commandNextBattle.Fail("There are no more battles!");
          }
          else
            commandNextBattle.Fail("Battle [" + args + "] does not exist!");
        }
        else
          commandNextBattle.Fail("You must provide a battle name");
      }
      else
        commandNextBattle.Fail("You must be mid-run to use this command");
    }

    public override IEnumerator GetArgOptions(string currentArgs)
    {
      Console.CommandNextBattle commandNextBattle = this;
      yield return (object) AddressableLoader.LoadGroup("BattleData");
      IEnumerable<BattleData> source = AddressableLoader.GetGroup<BattleData>("BattleData").Where<BattleData>((Func<BattleData, bool>) (a => a.name.ToLower().Contains(currentArgs.ToLower())));
      commandNextBattle.predictedArgs = source.Select<BattleData, string>((Func<BattleData, string>) (upgradeData => upgradeData.name)).ToArray<string>();
    }
  }

  public class CommandProgressGain : Console.Command
  {
    public override string id => "progress gain";

    public override string format => "progress gain <amount>";

    public override bool IsRoutine => false;

    public override void Run(string args)
    {
      MetaprogressSequence objectOfType = UnityEngine.Object.FindObjectOfType<MetaprogressSequence>();
      if ((UnityEngine.Object) objectOfType == (UnityEngine.Object) null)
        this.Fail("You must be on the end screen to use this command");
      else if (objectOfType.running)
      {
        this.Fail("Wait for current progress sequence to end please");
      }
      else
      {
        float result;
        if (float.TryParse(args.Trim(), out result))
          objectOfType.StartCoroutine(objectOfType.Sequence(new float?(result)));
        else
          this.Fail("Invalid progress amount");
      }
    }
  }

  public class CommandProgressReset : Console.Command
  {
    public override string id => "progress reset";

    public override bool IsRoutine => false;

    public override void Run(string args) => SaveSystem.DeleteProgress();
  }

  public class LoadModCommand : Console.Command
  {
    public override string format => "loadmod modguid";

    public override string id => "loadmod";

    public override bool IsRoutine => false;

    public override void Run(string args)
    {
      string str = args.Split(' ', StringSplitOptions.None)[0];
      foreach (WildfrostMod mod in Bootstrap.Mods)
      {
        if (mod.GUID == str)
        {
          mod.ModLoad();
          break;
        }
      }
    }
  }

  public class PublishMod : Console.Command
  {
    public override string format => "publish modguid";

    public override string id => "publish";

    public override bool IsRoutine => false;

    public override async void Run(string args)
    {
      string str = args.Split(' ', StringSplitOptions.None)[0];
      foreach (WildfrostMod mod in Bootstrap.Mods)
      {
        if (mod.GUID == str)
        {
          mod.UpdateOrPublishWorkshop();
          break;
        }
      }
    }
  }

  public class UnLoadModCommand : Console.Command
  {
    public override string format => "unloadmod modguid";

    public override string id => "unloadmod";

    public override bool IsRoutine => false;

    public override void Run(string args)
    {
      string str = args.Split(' ', StringSplitOptions.None)[0];
      foreach (WildfrostMod mod in Bootstrap.Mods)
      {
        if (mod.GUID == str)
        {
          mod.ModUnload();
          break;
        }
      }
    }
  }

  public class CommandScreenshot : Console.Command
  {
    public override string id => "screenshot";

    public override bool IsRoutine => false;

    public override void Run(string args)
    {
      string path = Application.persistentDataPath + "/Screenshots";
      if (!System.IO.Directory.Exists(path))
        System.IO.Directory.CreateDirectory(path);
      string[] files = System.IO.Directory.GetFiles(path, "screen*.png");
      int a = 0;
      foreach (string str in files)
      {
        string[] separator = new string[1]{ "screen" };
        int result;
        if (int.TryParse(str.Split(separator, StringSplitOptions.None)[1].Replace(".png", ""), out result))
          a = Mathf.Max(a, result);
      }
      ScreenCapture.CaptureScreenshot(string.Format("{0}/screen{1}.png", (object) path, (object) (a + 1)));
    }
  }

  public class CommandBlood : Console.Command
  {
    public readonly Dictionary<string, string> colours = new Dictionary<string, string>()
    {
      {
        "red",
        "#E04141"
      },
      {
        "berry",
        "#FD557E"
      },
      {
        "black",
        "#222929"
      },
      {
        "blue",
        "#639FF1"
      },
      {
        "green",
        "#B8CC4B"
      },
      {
        "purple",
        "#392463"
      },
      {
        "pink",
        "#FE69FF"
      },
      {
        "snow",
        "#A9D5E9"
      }
    };

    public override string id => "blood";

    public override string format => "blood <color> <amount>";

    public override bool IsRoutine => true;

    public override IEnumerator Routine(string args)
    {
      string[] strArray = args.Split(' ', StringSplitOptions.None);
      string htmlString1 = strArray.Length != 0 ? (this.colours.ContainsKey(strArray[0]) ? this.colours[strArray[0]] : strArray[0]) : "";
      int result = 1;
      if (strArray.Length > 1)
        int.TryParse(strArray[1].Trim(), out result);
      if (result < 1)
        result = 1;
      float num = Mathf.Min((float) (result - 1) * 0.05f, 1f);
      Color color;
      ref Color local = ref color;
      bool htmlString2 = ColorUtility.TryParseHtmlString(htmlString1, out local);
      Routine.Clump clump = new Routine.Clump();
      for (int index = 0; index < result; ++index)
      {
        Vector3 pos = Cursor3d.Position + PettyRandom.Vector3() * num;
        clump.Add(Console.CommandBlood.Create(pos, htmlString2, color));
      }
      yield return (object) clump.WaitForEnd();
    }

    public static IEnumerator Create(Vector3 pos, bool setColor, Color color)
    {
      AsyncOperationHandle<GameObject> handle = AddressableLoader.InstantiateAsync("SplatterParticle", pos, Quaternion.identity);
      yield return (object) handle;
      if (setColor && (bool) (UnityEngine.Object) handle.Result)
      {
        SplatterParticle component = handle.Result.GetComponent<SplatterParticle>();
        if (component != null)
          component.color = color;
      }
    }

    public override IEnumerator GetArgOptions(string currentArgs)
    {
      // ISSUE: reference to a compiler-generated field
      int num = this.\u003C\u003E1__state;
      Console.CommandBlood commandBlood = this;
      if (num != 0)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      commandBlood.predictedArgs = commandBlood.colours.Keys.Where<string>((Func<string, bool>) (a => a.Contains(currentArgs.ToLower()))).ToArray<string>();
      return false;
    }
  }

  public class CommandRunFinalBossScript : Console.Command
  {
    public override string id => "finalbosstest";

    public override bool IsRoutine => false;

    public override void Run(string args)
    {
      PlayerData playerData = References.PlayerData;
      if (playerData != null)
        FinalBossDeckGenerationSystem.SetNewBoss(playerData);
      else
        this.Fail("Cannot use this command here");
    }
  }

  public class CommandDailyReset : Console.Command
  {
    public override string id => "daily reset";

    public override bool IsRoutine => false;

    public override void Run(string args) => SaveSystem.DeleteProgressData("dailyPlayed");
  }

  public class CommandDailyOffset : Console.Command
  {
    public override string id => "daily offset";

    public override string format => "daily offset <days>";

    public override bool IsRoutine => false;

    public override void Run(string args)
    {
      int result;
      if (int.TryParse(args, out result))
      {
        DailyFetcher.DayOffset = result;
        UnityEngine.Object.FindObjectOfType<BalloonSequence>()?.Close();
      }
      else
        this.Fail("Pls provide number of offset days");
    }
  }

  public class CommandEncrypt : Console.Command
  {
    public override string id => "encrypt";

    public override string format => "encrypt";

    public override bool IsRoutine => false;

    public override void Run(string args)
    {
      Console.CommandEncrypt.Encrypt("Save.sav");
      Console.CommandEncrypt.Encrypt("Campaign.sav");
      Console.CommandEncrypt.Encrypt("CampaignDemo.sav");
      Console.CommandEncrypt.Encrypt("CampaignDaily.sav");
      Console.CommandEncrypt.Encrypt("Stats.sav");
      Console.CommandEncrypt.Encrypt("History.sav");
    }

    public static void Encrypt(string fileName)
    {
      string filePath = SaveSystem.folderName + "/Decrypt/" + fileName;
      if (ES3.FileExists(filePath, ES3Settings.defaultSettings))
      {
        ES3.SaveRaw(ES3.LoadRawBytes(filePath, ES3Settings.defaultSettings), SaveSystem.folderName + "/" + fileName, SaveSystem.settings);
        Debug.Log((object) ("Re-encrypted [" + fileName + "]"));
      }
      else
        Debug.Log((object) ("[" + filePath + "] does not exist!"));
    }
  }

  public class CommandDecrypt : Console.Command
  {
    public override string id => "decrypt";

    public override string format => "decrypt";

    public override bool IsRoutine => false;

    public override void Run(string args)
    {
      Console.CommandDecrypt.Decrypt("Save.sav");
      Console.CommandDecrypt.Decrypt("Campaign.sav");
      Console.CommandDecrypt.Decrypt("CampaignDemo.sav");
      Console.CommandDecrypt.Decrypt("CampaignDaily.sav");
      Console.CommandDecrypt.Decrypt("CampaignTutorial.sav");
      Console.CommandDecrypt.Decrypt("Stats.sav");
      Console.CommandDecrypt.Decrypt("History.sav");
    }

    public static void Decrypt(string fileName)
    {
      string filePath1 = SaveSystem.folderName + "/" + fileName;
      if (ES3.FileExists(filePath1, SaveSystem.settings))
      {
        byte[] bytes = ES3.LoadRawBytes(filePath1, SaveSystem.settings);
        string str = SaveSystem.folderName + "/Decrypt/" + fileName;
        string filePath2 = str;
        ES3Settings defaultSettings = ES3Settings.defaultSettings;
        ES3.SaveRaw(bytes, filePath2, defaultSettings);
        Debug.Log((object) ("Decrypted [" + fileName + "] to [" + str + "]"));
      }
      else
        Debug.Log((object) ("[" + filePath1 + "] does not exist!"));
    }
  }

  public class CommandDisplay : Console.Command
  {
    public override string id => "resolution";

    public override string format => "resolution <width> <height>";

    public override bool IsRoutine => false;

    public override void Run(string args)
    {
      string[] strArray = args.Split(' ', StringSplitOptions.None);
      int result1;
      int result2;
      if (strArray.Length > 1 && int.TryParse(strArray[0].Trim(), out result1) && int.TryParse(strArray[1].Trim(), out result2))
        ScreenSystem.SetResolutionWindowed(result1, result2);
      else
        this.Fail("Incorrect format. Should be written as \"resolution <width> <height>\"");
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ConsoleArgsDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;

public class ConsoleArgsDisplay : MonoBehaviourRect
{
  [SerializeField]
  public TMP_Text textPrefab;
  [SerializeField]
  public int poolStartSize = 20;
  [SerializeField]
  public int maxItems = 30;
  public Queue<TMP_Text> pool = new Queue<TMP_Text>();
  public List<TMP_Text> outOfPool = new List<TMP_Text>();
  public Console.Command[] commands;
  public string[] current;
  public Vector2 targetPos;

  public int Count => this.current.Length;

  public string TopArgument => ((IEnumerable<string>) this.current).Last<string>();

  public string TopCommand => ((IEnumerable<Console.Command>) this.commands).Last<Console.Command>().id + (((IEnumerable<Console.Command>) this.commands).Last<Console.Command>().format != ((IEnumerable<Console.Command>) this.commands).Last<Console.Command>().id ? " " : "");

  public void Awake()
  {
    this.targetPos = this.rectTransform.anchoredPosition;
    for (int index = 0; index < this.poolStartSize; ++index)
      this.pool.Enqueue(UnityEngine.Object.Instantiate<TMP_Text>(this.textPrefab, this.transform));
  }

  public void Update() => this.rectTransform.anchoredPosition = Delta.Lerp(this.rectTransform.anchoredPosition, this.targetPos, 0.1f, Time.deltaTime);

  public void Show() => this.gameObject.SetActive(true);

  public void Hide() => this.gameObject.SetActive(false);

  public void MoveTo(float x) => this.targetPos = this.targetPos.WithX(x);

  public void DisplayCommands(Console.Command[] commands)
  {
    string[] array = ((IEnumerable<Console.Command>) commands).Select<Console.Command, string>((Func<Console.Command, string>) (a => a.format)).ToArray<string>();
    if (this.current != null && ((IEnumerable<string>) array).SequenceEqual<string>((IEnumerable<string>) this.current))
      return;
    this.Create(array);
    this.current = array;
    this.commands = commands;
  }

  public void DisplayArgs(string[] items)
  {
    if (this.current != null && ((IEnumerable<string>) items).SequenceEqual<string>((IEnumerable<string>) this.current))
      return;
    this.Create(items);
    this.current = items;
  }

  public void Clear()
  {
    foreach (TMP_Text inst in this.outOfPool)
      this.Pool(inst);
    this.outOfPool.Clear();
  }

  public void Create(string[] items)
  {
    this.Clear();
    int index = items.Length - 1;
    while (index >= 0 && this.Create(items[index]))
      --index;
  }

  public bool Create(string item)
  {
    bool flag = false;
    if (this.outOfPool.Count < this.maxItems + 1)
    {
      TMP_Text tmpText = this.pool.Count > 0 ? this.pool.Dequeue() : UnityEngine.Object.Instantiate<TMP_Text>(this.textPrefab, this.transform);
      if (this.outOfPool.Count < this.maxItems)
      {
        tmpText.text = item;
        tmpText.transform.SetAsLastSibling();
        flag = true;
      }
      else
      {
        tmpText.text = "...";
        tmpText.transform.SetAsLastSibling();
      }
      tmpText.gameObject.SetActive(true);
      this.outOfPool.Add(tmpText);
    }
    return flag;
  }

  public void Pool(TMP_Text inst)
  {
    this.pool.Enqueue(inst);
    inst.gameObject.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ConsoleLog
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class ConsoleLog : MonoBehaviour
{
  [SerializeField]
  public TMP_Text textAsset;
  [SerializeField]
  public AnimationCurve fadeCurve;
  [SerializeField]
  public float fadeDuration = 4f;
  public float fade;

  public void OnEnable() => this.fade = 0.0f;

  public void Update()
  {
    this.fade += Time.deltaTime;
    if ((double) this.fade > (double) this.fadeDuration)
      this.gameObject.Destroy();
    else
      this.textAsset.color = this.textAsset.color.With(alpha: this.fadeCurve.Evaluate(this.fade / this.fadeDuration));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ContinueScreen
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization.Settings;

public class ContinueScreen : MonoBehaviour
{
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardContainer cardContainer;
  [SerializeField]
  public ModifierDisplay modifierDisplay;
  [SerializeField]
  public TMP_Text titleText;
  [SerializeField]
  public TMP_Text dateText;
  [SerializeField]
  public TMP_Text progressText;
  [SerializeField]
  public Menu menu;
  [SerializeField]
  public GameObject backButton;
  [SerializeField]
  public GameObject continueButton;
  [SerializeField]
  public HelpPanelShower giveUpHelpShower;
  [SerializeField]
  public GameObject missingDataDisplay;
  public CampaignSaveData data;
  public bool closing;

  public IEnumerator Start()
  {
    bool flag = true;
    List<CardData> cardDataList = (List<CardData>) null;
    try
    {
      if (SaveSystem.CampaignExists(Campaign.Data.GameMode))
      {
        if (SaveSystem.CampaignDataExists(Campaign.Data.GameMode, "data"))
        {
          this.data = SaveSystem.LoadCampaignData<CampaignSaveData>(Campaign.Data.GameMode, "data");
          global::Events.InvokeCampaignLoaded();
          string s = SaveSystem.LoadCampaignData<string>(Campaign.Data.GameMode, "startDate");
          if (s != null)
          {
            this.dateText.gameObject.SetActive(true);
            this.dateText.text = DateTime.ParseExact(s, "dd/MM/yyyy", (IFormatProvider) GameManager.CultureInfo).ToString("D", (IFormatProvider) LocalizationSettings.SelectedLocale.Identifier.CultureInfo);
          }
          bool mainGameMode = Campaign.Data.GameMode.mainGameMode;
          string[] modifiers = this.data.modifiers;
          if (modifiers == null || modifiers.Length <= 0)
          {
            this.modifierDisplay.gameObject.SetActive(false);
          }
          else
          {
            foreach (string modifier in this.data.modifiers)
            {
              GameModifierData data = AddressableLoader.Get<GameModifierData>("GameModifierData", modifier);
              if ((UnityEngine.Object) data != (UnityEngine.Object) null)
                this.modifierDisplay.CreateIcon(data, mainGameMode);
            }
          }
          cardDataList = this.data.characters[this.data.playerId].inventoryData.deck.LoadList<CardData, CardSaveData>();
          this.continueButton.SetActive(true);
        }
      }
    }
    catch (NullReferenceException ex)
    {
      flag = false;
      Debug.LogWarning((object) ex);
    }
    if (flag)
    {
      this.CheckMissingData(this.data);
      Routine.Clump clump = new Routine.Clump();
      List<Entity> cards = new List<Entity>();
      foreach (CardData data in cardDataList)
      {
        Card card = CardManager.Get(data, this.cardController, (Character) null, false, true);
        card.hover.enabled = false;
        cards.Add(card.entity);
        clump.Add(card.UpdateData(false));
      }
      yield return (object) clump.WaitForEnd();
      foreach (Entity entity in cards)
        entity.display.hover.enabled = true;
      cards.Sort((Comparison<Entity>) ((a, b) => a.data.cardType.sortPriority.CompareTo(b.data.cardType.sortPriority)));
      this.cardContainer.max = cards.Count;
      for (int index = cards.Count - 1; index >= 0; --index)
        this.cardContainer.Add(cards[index]);
      this.cardContainer.SetChildPositions();
      this.backButton.gameObject.SetActive(Campaign.Data.GameMode.canGoBack);
      cards = (List<Entity>) null;
    }
    else
    {
      Debug.LogWarning((object) "Failed to load campaign save...");
      SaveSystem.DeleteCampaign(Campaign.Data.GameMode);
      global::Events.InvokeCampaignDeleted();
      Campaign.Data = new CampaignData(Campaign.Data.GameMode);
      Routine routine = new Routine(Sequences.SceneChange(Campaign.Data.GameMode.startScene));
    }
  }

  public void Continue()
  {
    if (this.closing)
      return;
    this.closing = true;
    this.menu.GoTo("Campaign");
  }

  public void PromptGiveUp()
  {
    if (this.closing)
      return;
    this.giveUpHelpShower.Show();
    this.giveUpHelpShower.AddButton(0, HelpPanelSystem.ButtonType.Positive, new UnityAction(this.GiveUp));
    this.giveUpHelpShower.AddButton(1, HelpPanelSystem.ButtonType.Negative, (UnityAction) null);
  }

  public void GiveUp()
  {
    if (this.closing)
      return;
    this.closing = true;
    CampaignSaveData campaignSaveData = SaveSystem.LoadCampaignData<CampaignSaveData>(Campaign.Data.GameMode, "data");
    CharacterSaveData character = campaignSaveData.characters[campaignSaveData.playerId];
    if (character != null)
      global::Events.InvokeCampaignEnd(Campaign.Result.Restart, SaveSystem.LoadCampaignData<CampaignStats>(Campaign.Data.GameMode, "stats"), character.LoadPlayerData());
    SaveSystem.DeleteCampaign(Campaign.Data.GameMode);
    global::Events.InvokeCampaignDeleted();
    this.StartCoroutine(this.GiveUpSequence());
  }

  public IEnumerator GiveUpSequence()
  {
    if (global::Settings.Load<bool>("showJournalNameOnEnd", false))
      yield return (object) JournalVoidNameSequence.LoadAndRun(false);
    else
      JournalNameHistory.MostRecentNameKilled();
    Campaign.Data = new CampaignData(Campaign.Data.GameMode);
    this.ForceClose();
  }

  public void Close()
  {
    if (this.closing)
      return;
    this.ForceClose();
  }

  public void ForceClose()
  {
    this.closing = true;
    Routine routine = new Routine(SceneManager.Unload("ContinueRun"));
  }

  public void CheckMissingData(CampaignSaveData data)
  {
    if (!this.HasMissingData(data))
      return;
    this.continueButton.SetActive(false);
    this.missingDataDisplay.SetActive(true);
  }

  public bool HasMissingData(CampaignSaveData data)
  {
    CharacterSaveData character = data.characters[data.playerId];
    if (MissingCardSystem.HasMissingData(character.inventoryData.deck) || MissingCardSystem.HasMissingData(character.inventoryData.reserve))
      return true;
    foreach (CampaignNodeSaveData node1 in data.nodes)
    {
      if (!node1.cleared)
      {
        CampaignNode node2 = node1.Load();
        if (node2.type.HasMissingData(node2))
          return true;
      }
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ControllerButtonImage
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

[RequireComponent(typeof (Image))]
public class ControllerButtonImage : MonoBehaviour
{
  [SerializeField]
  public bool deactivateIfNull = true;
  [SerializeField]
  public bool disableIfNull;
  public Image image;
  [CompilerGenerated]
  public string \u003CactionName\u003Ek__BackingField;

  public string actionName
  {
    get => this.\u003CactionName\u003Ek__BackingField;
    set => this.\u003CactionName\u003Ek__BackingField = value;
  }

  public void OnEnable()
  {
    this.image = this.GetComponent<Image>();
    global::Events.OnButtonStyleChanged += new UnityAction(this.ButtonStyleChanged);
  }

  public void OnDisable() => global::Events.OnButtonStyleChanged -= new UnityAction(this.ButtonStyleChanged);

  public void Set(string actionName)
  {
    this.actionName = actionName;
    Sprite sprite = ControllerButtonSystem.Get(actionName);
    if (this.deactivateIfNull)
      this.gameObject.SetActive((bool) (Object) sprite);
    if (this.disableIfNull)
      this.image.enabled = (bool) (Object) sprite;
    if (!(bool) (Object) sprite)
      return;
    this.image.sprite = sprite;
  }

  public void ButtonStyleChanged()
  {
    if (this.actionName.IsNullOrWhitespace())
      return;
    this.Set(this.actionName);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ControllerButtonSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Rewired;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;

public class ControllerButtonSystem : GameSystem
{
  public static ControllerButtonSystem instance;
  public static JoystickButtonStyle style;
  [SerializeField]
  public JoystickButtonStyle defaultControllerStyle;
  [SerializeField]
  public JoystickButtonStyle mouseStyle;
  [SerializeField]
  public JoystickButtonStyle touchStyle;
  [SerializeField]
  public JoystickButtonStyle[] styles;

  public void Awake() => ControllerButtonSystem.instance = this;

  public void OnEnable() => global::Events.OnControllerSwitched += new UnityAction(ControllerButtonSystem.ControllerSwitched);

  public void OnDisable() => global::Events.OnControllerSwitched -= new UnityAction(ControllerButtonSystem.ControllerSwitched);

  public static void ControllerSwitched()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      return;
    ControllerButtonSystem.SetControllerStyle();
  }

  public static void SetMouseStyle()
  {
    ControllerButtonSystem.style = ControllerButtonSystem.instance.mouseStyle;
    global::Events.InvokeButtonStyleChanged();
  }

  public static void SetTouchStyle()
  {
    ControllerButtonSystem.style = ControllerButtonSystem.instance.touchStyle;
    global::Events.InvokeButtonStyleChanged();
  }

  public static void SetControllerStyle()
  {
    Player playerController = RewiredControllerManager.GetPlayerController(0);
    Controller controller = (Controller) null;
    double num = -1.0;
    foreach (Joystick joystick in (IEnumerable<Joystick>) playerController.controllers.Joysticks)
    {
      double lastTimeActive = joystick.GetLastTimeActive();
      if (lastTimeActive > num)
      {
        num = lastTimeActive;
        controller = (Controller) joystick;
      }
    }
    if (controller == null)
      return;
    ControllerButtonSystem.style = ((IEnumerable<JoystickButtonStyle>) ControllerButtonSystem.instance.styles).FirstOrDefault<JoystickButtonStyle>((Func<JoystickButtonStyle, bool>) (a => a.guids.Contains<Guid>(controller.hardwareTypeGuid)));
    if (ControllerButtonSystem.style == null)
      ControllerButtonSystem.style = ControllerButtonSystem.instance.defaultControllerStyle;
    Debug.LogWarning((object) ("ControllerButtonStyle Set: [" + ControllerButtonSystem.style.name + "]"));
    global::Events.InvokeButtonStyleChanged();
  }

  public static Sprite Get(string action)
  {
    if (action.IsNullOrWhitespace())
      return (Sprite) null;
    Player playerController = RewiredControllerManager.GetPlayerController(0);
    return ControllerButtonSystem.style.GetElement(playerController, action).buttonSprite;
  }

  public static JoystickButtonStyle.ElementButton GetElement(Player player, string actionName) => ControllerButtonSystem.style.GetElement(player, actionName);

  public static string ProcessActionTags(LocalizedString key, bool preferTextActions = true) => ControllerButtonSystem.ProcessActionTags(key.GetLocalizedString(), preferTextActions);

  public static string ProcessActionTags(string text, bool preferTextActions)
  {
    Player playerController = RewiredControllerManager.GetPlayerController(0);
    int startIndex = 0;
    do
    {
      startIndex = text.IndexOf("<action=", startIndex);
      if (startIndex >= 0)
      {
        int count = text.IndexOf('>', startIndex) - startIndex + 1;
        string actionName = text.Substring(startIndex + 8, count - 9);
        Debug.Log((object) ("Action: " + actionName));
        text = text.Remove(startIndex, count);
        JoystickButtonStyle.ElementButton element = ControllerButtonSystem.style.GetElement(playerController, actionName);
        if (element != null)
        {
          if (element.textKey.IsEmpty || !preferTextActions)
          {
            string name = element.buttonSprite.name;
            Debug.Log((object) ("Button Sprite Index for [" + actionName + "]: " + name));
            text = text.Insert(startIndex, "<sprite name=" + name + ">");
          }
          else
          {
            string text1 = element.text;
            Debug.Log((object) ("Button Key Name for [" + actionName + "]: " + text1));
            text = text.Insert(startIndex, text1);
          }
        }
        else
          Debug.Log((object) "No element using that action! (or action doesn't exist...)");
      }
      else
        break;
    }
    while (startIndex >= 0);
    return text;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ControllerInputSwitcher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ControllerInputSwitcher : BaseInputSwitcher
{
  public override bool CheckSwitchTo()
  {
    if (!this.canSwitchTo || Console.active)
      return false;
    return (double) Mathf.Abs(InputSystem.GetAxisDelta("Move Vertical")) > 0.0 || (double) Mathf.Abs(InputSystem.GetAxisDelta("Move Horizontal")) > 0.0;
  }

  public override void SwitchTo()
  {
    this.gameObject.SetActive(true);
    MonoBehaviourSingleton<Cursor3d>.instance.usingMouse = false;
    MonoBehaviourSingleton<Cursor3d>.instance.usingTouch = false;
    VirtualPointer.Show();
    CustomCursor.UpdateState();
    UINavigationDefaultSystem.SetStartingItem();
    ControllerButtonSystem.SetControllerStyle();
    InputSystem.mainPlayer.controllers.Mouse.enabled = false;
    RewiredControllerManager.instance.AssignNextPlayer(InputSystem.mainPlayer.id);
    InputSystem.AllowDynamicSelectRelease = true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CopyRectTransform
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

public class CopyRectTransform : MonoBehaviourRect
{
  [SerializeField]
  public RectTransform target;
  [SerializeField]
  [ShowIf("hasTarget")]
  public bool onEnable;
  [SerializeField]
  [ShowIf("hasTarget")]
  public bool onUpdate = true;
  [SerializeField]
  [ShowIf("hasTarget")]
  public bool onValidate;
  [SerializeField]
  [ShowIf("hasTarget")]
  public bool copyPosition = true;
  [SerializeField]
  [ShowIf("hasTarget")]
  public bool copyRotation = true;
  [SerializeField]
  [ShowIf("hasTarget")]
  public bool copySize;
  [SerializeField]
  [ShowIf("hasTarget")]
  public bool copyPivot;
  [SerializeField]
  [ShowIf("hasTarget")]
  public bool copyScale = true;
  [SerializeField]
  [ShowIf("hasTargetAndCopyScale")]
  public bool invertScale;

  public bool hasTarget => (Object) this.target != (Object) null;

  public bool hasTargetAndCopyScale => this.hasTarget && this.copyScale;

  public void OnEnable()
  {
    if (!this.onEnable)
      return;
    this.Copy();
  }

  public void LateUpdate()
  {
    if (!this.onUpdate)
      return;
    this.Copy();
  }

  [Button("Update", EButtonEnableMode.Always)]
  public void Copy()
  {
    if (!this.hasTarget)
      return;
    if (this.copyPosition)
      this.rectTransform.position = this.target.position;
    if (this.copyRotation)
      this.rectTransform.rotation = this.target.rotation;
    if (this.copySize)
      this.rectTransform.sizeDelta = this.target.sizeDelta;
    if (this.copyPivot)
      this.rectTransform.pivot = this.target.pivot;
    if (!this.copyScale)
      return;
    this.rectTransform.localScale = this.invertScale ? this.target.localScale.Invert() : this.target.localScale;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CoroutineManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class CoroutineManager : MonoBehaviour
{
  public static CoroutineManager instance;

  public static void InstanceCheck()
  {
    if ((bool) (Object) CoroutineManager.instance)
      return;
    CoroutineManager.instance = Object.FindObjectOfType<CoroutineManager>();
    if ((bool) (Object) CoroutineManager.instance)
      return;
    CoroutineManager.instance = new GameObject(nameof (CoroutineManager)).AddComponent<CoroutineManager>();
  }

  public static CoroutineManager.State Create(IEnumerator coroutine)
  {
    CoroutineManager.InstanceCheck();
    return new CoroutineManager.State(coroutine);
  }

  public static void Start(IEnumerator coroutine)
  {
    CoroutineManager.InstanceCheck();
    CoroutineManager.instance.StartCoroutine(coroutine);
  }

  public class State
  {
    public IEnumerator coroutine;
    public bool running;
    public bool paused;
    public bool stopped;

    public event CoroutineManager.State.FinishedHandler Finished;

    public bool IsRunning => this.running;

    public bool IsPaused => this.paused;

    public State(IEnumerator coroutine) => this.coroutine = coroutine;

    public void Pause() => this.paused = true;

    public void Unpause() => this.paused = false;

    public void Start()
    {
      this.running = true;
      CoroutineManager.instance.StartCoroutine(this.CallWrapper());
    }

    public void Stop()
    {
      this.stopped = true;
      this.running = false;
    }

    public IEnumerator CallWrapper()
    {
      yield return (object) null;
      IEnumerator e = this.coroutine;
      while (this.running)
      {
        if (this.paused)
          yield return (object) null;
        else if (e != null && e.MoveNext())
          yield return e.Current;
        else
          this.running = false;
      }
      CoroutineManager.State.FinishedHandler finished = this.Finished;
      if (finished != null)
        finished(this.stopped);
    }

    public delegate void FinishedHandler(bool manualStop);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CounterImminentDisplaySystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class CounterImminentDisplaySystem : GameSystem
{
  [SerializeField]
  public bool disableCardAnimationHover = true;
  [SerializeField]
  public bool disableIconAnimationHover = true;
  public List<Entity> currentImminent = new List<Entity>();
  public List<Entity> currentHover = new List<Entity>();

  public void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
    global::Events.OnEntityDisplayUpdated += new UnityAction<Entity>(this.EntityCheck);
    global::Events.OnEntityEnabled += new UnityAction<Entity>(this.EntityCheck);
    global::Events.OnEntityDisabled += new UnityAction<Entity>(this.EntityDisabled);
    global::Events.OnInspect += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnInspectEnd += new UnityAction<Entity>(this.EntityUnHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
    global::Events.OnEntityDisplayUpdated -= new UnityAction<Entity>(this.EntityCheck);
    global::Events.OnEntityEnabled -= new UnityAction<Entity>(this.EntityCheck);
    global::Events.OnEntityDisabled -= new UnityAction<Entity>(this.EntityDisabled);
    global::Events.OnInspect -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnInspectEnd -= new UnityAction<Entity>(this.EntityUnHover);
  }

  public void EntityHover(Entity entity)
  {
    if (!((Object) entity != (Object) null))
      return;
    this.currentHover.Add(entity);
    if (!this.currentImminent.Contains(entity))
      return;
    if (this.disableCardAnimationHover)
      this.SetCardAnimation(entity, false);
    if (!this.disableIconAnimationHover)
      return;
    this.SetCounterIconAnimation(entity, false);
  }

  public void EntityUnHover(Entity entity)
  {
    if (!((Object) entity != (Object) null))
      return;
    this.currentHover.Remove(entity);
    if (!entity.enabled || !this.currentImminent.Contains(entity))
      return;
    if (this.disableCardAnimationHover)
      this.SetCardAnimation(entity, true);
    if (!this.disableIconAnimationHover)
      return;
    this.SetCounterIconAnimation(entity, true);
  }

  public void EntityDisabled(Entity entity)
  {
    if (!this.currentImminent.Contains(entity))
      return;
    this.currentImminent.Remove(entity);
    this.SetCardAnimation(entity, false);
    this.SetCounterIconAnimation(entity, false);
  }

  public void SetCardAnimation(Entity entity, bool enable)
  {
    if (!((Object) entity.imminentAnimation != (Object) null))
      return;
    if (enable)
      entity.imminentAnimation.FadeIn();
    else
      entity.imminentAnimation.FadeOut();
  }

  public void SetCounterIconAnimation(Entity entity, bool enable)
  {
    if (!((Object) entity.display.counterIcon != (Object) null) || !(entity.display.counterIcon is StatusIconCounter counterIcon))
      return;
    CardIdleAnimation imminentAnimation = counterIcon.imminentAnimation;
    if (!((Object) imminentAnimation != (Object) null))
      return;
    if (enable)
      imminentAnimation.FadeIn();
    else
      imminentAnimation.FadeOut();
  }

  public void EntityCheck(Entity entity)
  {
    if (!entity.enabled)
      return;
    if (!this.currentImminent.Contains(entity))
    {
      if (!this.Imminent(entity))
        return;
      this.currentImminent.Add(entity);
      this.SetCardAnimation(entity, true);
      this.SetCounterIconAnimation(entity, true);
    }
    else
    {
      if (this.Imminent(entity))
        return;
      this.currentImminent.Remove(entity);
      this.SetCardAnimation(entity, false);
      this.SetCounterIconAnimation(entity, false);
    }
  }

  public bool Imminent(Entity entity) => !entity.IsSnowed && entity.counter.current == 1;
}
﻿// Decompiled with JetBrains decompiler
// Type: CreateCardAnimation
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CreateCardAnimation : MonoBehaviour
{
  public virtual IEnumerator Run(Entity entity, params CardData.StatusEffectStacks[] withEffects)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    CreateCardAnimation createCardAnimation = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      createCardAnimation.gameObject.Destroy();
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) CreateCardAnimation.GainEffects(entity, (IEnumerable<CardData.StatusEffectStacks>) withEffects);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public IEnumerator DestroyOnEnd(ParticleSystem ps)
  {
    CreateCardAnimation createCardAnimation = this;
    yield return (object) new WaitUntil((Func<bool>) (() => !(bool) (UnityEngine.Object) this || !(bool) (UnityEngine.Object) ps || !ps.isPlaying));
    if ((bool) (UnityEngine.Object) createCardAnimation && (bool) (UnityEngine.Object) createCardAnimation.gameObject)
      createCardAnimation.gameObject.Destroy();
  }

  public static IEnumerator GainEffects(
    Entity entity,
    IEnumerable<CardData.StatusEffectStacks> withEffects)
  {
    Routine.Clump clump = new Routine.Clump();
    foreach (CardData.StatusEffectStacks withEffect in withEffects)
      clump.Add(StatusEffectSystem.Apply(entity, (Entity) null, withEffect.data, withEffect.count));
    yield return (object) clump.WaitForEnd();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CreatedByLookup
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;

public static class CreatedByLookup
{
  public static bool requiresRebuild = true;
  public static readonly Dictionary<string, string> lookup = new Dictionary<string, string>();

  public static bool TryGetCreatedBy(string cardDataName, out string parentCardDataName)
  {
    if (CreatedByLookup.requiresRebuild)
    {
      CreatedByLookup.Clear();
      CreatedByLookup.Build();
    }
    string str;
    if (CreatedByLookup.lookup.TryGetValue(cardDataName, out str))
    {
      parentCardDataName = str;
      return true;
    }
    parentCardDataName = cardDataName;
    return false;
  }

  public static void TryGetCreatedByRoot(string cardDataName, out string rootCardDataName)
  {
    rootCardDataName = cardDataName;
    do
      ;
    while (CreatedByLookup.TryGetCreatedBy(rootCardDataName, out rootCardDataName));
  }

  public static void Clear() => CreatedByLookup.lookup.Clear();

  public static void Build()
  {
    CreatedByLookup.Add("Dregg", "Egg");
    CreatedByLookup.Add("TailsOne", "TailsTwo");
    CreatedByLookup.Add("TailsTwo", "TailsThree");
    CreatedByLookup.Add("TailsThree", "TailsFour");
    CreatedByLookup.Add("TailsFour", "TailsFive");
    CreatedByLookup.Add("Beepop", "BeepopMask");
    CreatedByLookup.Add("Plep", "JunjunMask");
    CreatedByLookup.Add("Fallow", "FallowMask");
    CreatedByLookup.Add("Tigris", "TigrisMask");
    CreatedByLookup.Add("Leech", "Leecher");
    CreatedByLookup.Add("Pigeon", "PigeonCage");
    CreatedByLookup.Add("Sheepopper", "PopPopper");
    CreatedByLookup.requiresRebuild = false;
  }

  public static void Add(string cardDataName, string parentCardDataName) => CreatedByLookup.lookup.Add(cardDataName, parentCardDataName);
}
﻿// Decompiled with JetBrains decompiler
// Type: CreateLeaderDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class CreateLeaderDisplay : MonoBehaviour
{
  [SerializeField]
  public TweenUI startTween;
  [SerializeField]
  public float cardScale = 1f;

  public IEnumerator Start()
  {
    CreateLeaderDisplay createLeaderDisplay = this;
    Card card = CardManager.Get(References.LeaderData, (CardController) null, References.Player, false, true);
    card.entity.returnToPool = false;
    Transform transform = card.transform;
    transform.localScale = Vector3.one * createLeaderDisplay.cardScale;
    card.entity.flipper.FlipUpInstant();
    card.hover.Disable();
    card.entity.uINavigationItem.enabled = false;
    transform.SetParent(createLeaderDisplay.transform);
    transform.localPosition = Vector3.zero;
    transform.localRotation = Quaternion.identity;
    card.entity.wobbler.WobbleRandom();
    yield return (object) card.UpdateData(false);
    if ((bool) (Object) createLeaderDisplay.startTween)
      createLeaderDisplay.startTween.Fire();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CrownHolder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using UnityEngine;

public class CrownHolder : UpgradeHolder
{
  [SerializeField]
  public float gap = 0.3f;
  [SerializeField]
  public float angleRange = 1f;
  [SerializeField]
  public float xRange = 0.02f;
  [SerializeField]
  public float xMax = 0.1f;
  public int seed;

  public void Awake() => this.seed = PettyRandom.Range(10000, 9999999);

  public override void SetPositions()
  {
    UnityEngine.Random.State state = UnityEngine.Random.state;
    UnityEngine.Random.InitState(this.seed);
    Vector2 zero1 = Vector2.zero;
    Vector3 zero2 = Vector3.zero;
    foreach (RectTransform rectTransform in this.transform)
    {
      rectTransform.anchoredPosition = zero1;
      rectTransform.localEulerAngles = zero2;
      float num1 = UnityEngine.Random.Range(-1f, 1f);
      float num2 = zero1.x + num1 * this.xRange;
      if ((double) num2 > (double) this.xMax || (double) num2 < -(double) this.xMax)
        num1 *= -1f;
      zero1 += new Vector2(num1 * this.xRange, this.gap);
      zero2.z += num1 * this.angleRange;
    }
    UnityEngine.Random.state = state;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CrownHolderShop
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class CrownHolderShop : MonoBehaviour
{
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public GameObject crown;
  [SerializeField]
  public Image crownImage;
  [SerializeField]
  public Image crownWhiteImage;
  [SerializeField]
  public Image interaction;
  [SerializeField]
  public Vector2 popUpOffset = new Vector2(0.7f, 0.25f);
  public CardUpgradeData crownData;
  public string popUpName;
  public string popUpTitle;
  public string popUpBody;
  public bool hover;
  public bool _hasCrown = true;

  public bool hasCrown
  {
    get => this._hasCrown;
    set
    {
      this._hasCrown = value;
      this.crown.SetActive(value);
      this.interaction.enabled = value;
    }
  }

  public void SetCrownData(CardUpgradeData crownData)
  {
    this.crownData = crownData;
    this.crownImage.sprite = crownData.image;
    this.crownWhiteImage.sprite = crownData.image;
    this.popUpName = crownData.name;
    this.popUpTitle = crownData.title;
    this.popUpBody = crownData.text;
  }

  public CardUpgradeData GetCrownData() => this.crownData;

  public bool CanTake() => this._hasCrown && this.enabled;

  public void Hover()
  {
    if (this.hover || !this.CanTake())
      return;
    this.hover = true;
    this.animator.SetBool(nameof (Hover), this.hover);
    CardPopUp.AssignTo(this.interaction.rectTransform, this.popUpOffset.x, this.popUpOffset.y);
    CardPopUp.AddPanel(this.popUpName, this.popUpTitle, this.popUpBody);
  }

  public void UnHover()
  {
    if (!this.hover)
      return;
    this.hover = false;
    this.animator.SetBool("Hover", this.hover);
    CardPopUp.RemovePanel(this.popUpName);
  }

  public void TakeCrown() => this.hasCrown = false;
}
﻿// Decompiled with JetBrains decompiler
// Type: Cursor3d
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Runtime.CompilerServices;
using UnityEngine;

public class Cursor3d : MonoBehaviourSingleton<Cursor3d>
{
  public Camera _cam;
  public LayerMask layerMask;
  public bool usingMouse = true;
  public bool usingTouch;
  public GameObject mouseObj;
  public bool showVirtualPointerState = true;
  [CompilerGenerated]
  public static Vector3 \u003CPosition\u003Ek__BackingField;
  [CompilerGenerated]
  public static Vector3 \u003CPositionWithZ\u003Ek__BackingField;
  public static readonly Vector3 offset = new Vector3(0.0f, 0.0f, -1f);
  public readonly RaycastHit[] hits = new RaycastHit[1];

  public Camera cam => this._cam ?? (this._cam = Camera.main);

  public static Vector3 Position
  {
    get => Cursor3d.\u003CPosition\u003Ek__BackingField;
    set => Cursor3d.\u003CPosition\u003Ek__BackingField = value;
  }

  public static Vector3 PositionWithZ
  {
    get => Cursor3d.\u003CPositionWithZ\u003Ek__BackingField;
    set => Cursor3d.\u003CPositionWithZ\u003Ek__BackingField = value;
  }

  public void OnEnable() => CustomCursor.UpdateState();

  public void Update()
  {
    if (!this.usingMouse || Physics.RaycastNonAlloc(this.cam.ScreenPointToRay(InputSystem.MousePosition + Cursor3d.offset), this.hits, 1000f, (int) this.layerMask) <= 0)
      return;
    this.SetPosition(this.hits[0].point);
  }

  public Vector2 GetScreenPoint() => (Vector2) this.cam.WorldToScreenPoint(this.transform.position);

  public void SetPosition(Vector3 position)
  {
    this.transform.position = position;
    Cursor3d.PositionWithZ = position;
    Cursor3d.Position = Cursor3d.PositionWithZ.WithZ(0.0f);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CursorDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class CursorDisplay : MonoBehaviourRect
{
  [SerializeField]
  public TouchInputModule inputModule;
  [SerializeField]
  public RectTransform pre;
  [SerializeField]
  public TMP_Text text;

  public void LateUpdate()
  {
    Vector2 mousePosition = this.inputModule.MousePosition;
    Vector2 lastMousePosition = this.inputModule.LastMousePosition;
    this.rectTransform.position = (Vector3) mousePosition;
    if ((bool) (Object) this.text)
    {
      Vector2 mouseMove = this.inputModule.MouseMove;
      this.text.text = string.Format("({0}, {1})\n", (object) Mathf.RoundToInt(mousePosition.x), (object) Mathf.RoundToInt(mousePosition.y)) + string.Format("({0}, {1})\n", (object) Mathf.RoundToInt(lastMousePosition.x), (object) Mathf.RoundToInt(lastMousePosition.y)) + string.Format("({0}, {1})\n", (object) Mathf.RoundToInt(mouseMove.x), (object) Mathf.RoundToInt(mouseMove.y)) + string.Format("Hovering: {0}\n", (object) this.inputModule.Hover) + string.Format("Pressing: {0}", (object) this.inputModule.Press);
    }
    if (!(bool) (Object) this.pre)
      return;
    this.pre.position = (Vector3) lastMousePosition;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Curve
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public struct Curve
{
  public string name;
  public AnimationCurve curve;
}
﻿// Decompiled with JetBrains decompiler
// Type: CurveAnimator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Runtime.CompilerServices;
using UnityEngine;

public class CurveAnimator : MonoBehaviourCacheTransform, IPoolable
{
  public static readonly Vector3 rotationInfluence = new Vector3(5f, 7f, 2f);
  public static readonly float rotationDurationMod = 1.5f;
  public static readonly float moveAnimationDur = 0.667f;
  public float pingDuration = 0.667f;
  public Vector3 pingScale = Vector3.one * 1.25f;
  public Vector3 pingMove = Vector3.back;
  public bool active;

  public float Move(Vector3 offset, AnimationCurve curve, float rotationAmount = 1f, float duration = 0.667f)
  {
    this.CancelTween();
    if ((bool) (UnityEngine.Object) this.gameObject)
    {
      this.active = true;
      LeanTween.moveLocal(this.gameObject, offset, duration).setEase(curve).setOnComplete((System.Action) (() => this.active = false));
      if ((double) rotationAmount != 0.0)
      {
        double num = (double) this.Rotate(new Vector3(offset.y * CurveAnimator.rotationInfluence.x, -offset.x * CurveAnimator.rotationInfluence.y, -offset.x * CurveAnimator.rotationInfluence.z) * rotationAmount, curve, duration * CurveAnimator.rotationDurationMod);
      }
    }
    return duration;
  }

  public float Rotate(Vector3 offset, AnimationCurve curve, float duration)
  {
    LeanTween.rotateLocal(this.gameObject, offset, duration).setEase(curve);
    return duration;
  }

  public float Scale(Vector3 offset, AnimationCurve curve, float duration)
  {
    this.CancelTween();
    LeanTween.scale(this.gameObject, offset, duration).setEase(curve);
    return duration;
  }

  public float Ping()
  {
    if ((bool) (UnityEngine.Object) this.gameObject)
    {
      this.CancelTween();
      this.active = true;
      AnimationCurve easeCurve = Curves.Get(nameof (Ping));
      LeanTween.moveLocal(this.gameObject, this.pingMove, this.pingDuration).setEase(easeCurve).setOnComplete((System.Action) (() => this.active = false));
      LeanTween.scale(this.gameObject, this.pingScale, this.pingDuration).setEase(easeCurve);
      Events.InvokeEntityPing(this.gameObject);
    }
    return this.pingDuration;
  }

  public void CancelTween()
  {
    if (!(bool) (UnityEngine.Object) this.gameObject)
      return;
    LeanTween.cancel(this.gameObject);
    this.transform.localPosition = Vector3.zero;
    this.transform.localEulerAngles = Vector3.zero;
    this.transform.localScale = Vector3.one;
  }

  public void OnGetFromPool()
  {
  }

  public void OnReturnToPool()
  {
    this.CancelTween();
    this.active = false;
  }

  [CompilerGenerated]
  public void \u003CMove\u003Eb__7_0() => this.active = false;

  [CompilerGenerated]
  public void \u003CPing\u003Eb__10_0() => this.active = false;
}
﻿// Decompiled with JetBrains decompiler
// Type: CurvedLinePoint
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class CurvedLinePoint : MonoBehaviour
{
  [HideInInspector]
  public bool showGizmo = true;
  [HideInInspector]
  public float gizmoSize = 0.1f;
  [HideInInspector]
  public Color gizmoColor = new Color(1f, 0.0f, 0.0f, 0.5f);

  public void OnDrawGizmos()
  {
    if (!this.showGizmo)
      return;
    Gizmos.color = this.gizmoColor;
    Gizmos.DrawSphere(this.transform.position, this.gizmoSize);
  }

  public void OnDrawGizmosSelected()
  {
    CurvedLineRenderer component = this.transform.parent.GetComponent<CurvedLineRenderer>();
    if (!((Object) component != (Object) null))
      return;
    component.Update();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CurvedLineRenderer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[RequireComponent(typeof (LineRenderer))]
public class CurvedLineRenderer : MonoBehaviour
{
  public float lineSegmentSize = 0.1f;
  public float lineWidth = 0.1f;
  public bool autoUpdate;
  public bool promptUpdate;
  [Header("Gizmos")]
  public bool showGizmos = true;
  public float gizmoSize = 0.1f;
  public Color gizmoColor = new Color(1f, 0.0f, 0.0f, 0.5f);
  public CurvedLinePoint[] linePoints = new CurvedLinePoint[0];
  public Vector3[] linePositions = new Vector3[0];
  public Vector3[] linePositionsOld = new Vector3[0];

  public void Update()
  {
    if (!this.autoUpdate && !this.promptUpdate)
      return;
    this.UpdatePoints();
    this.promptUpdate = false;
  }

  public void UpdatePoints()
  {
    this.GetPoints();
    this.SetPointsToLine();
  }

  public void GetPoints()
  {
    this.linePoints = this.GetComponentsInChildren<CurvedLinePoint>();
    this.linePositions = new Vector3[this.linePoints.Length];
    for (int index = 0; index < this.linePoints.Length; ++index)
      this.linePositions[index] = this.linePoints[index].transform.localPosition;
  }

  public void SetPointsToLine()
  {
    if (this.linePositionsOld.Length != this.linePositions.Length)
      this.linePositionsOld = new Vector3[this.linePositions.Length];
    bool flag = false;
    for (int index = 0; index < this.linePositions.Length; ++index)
    {
      if (this.linePositions[index] != this.linePositionsOld[index])
        flag = true;
    }
    if (!flag)
      return;
    LineRenderer component = this.GetComponent<LineRenderer>();
    Vector3[] positions = LineSmoother.SmoothLine(this.linePositions, this.lineSegmentSize);
    component.positionCount = positions.Length;
    component.SetPositions(positions);
    component.startWidth = this.lineWidth;
    component.endWidth = this.lineWidth;
  }

  public void OnDrawGizmosSelected() => this.Update();

  public void OnDrawGizmos()
  {
    if (this.linePoints.Length == 0)
      this.GetPoints();
    foreach (CurvedLinePoint linePoint in this.linePoints)
    {
      linePoint.showGizmo = this.showGizmos;
      linePoint.gizmoSize = this.gizmoSize;
      linePoint.gizmoColor = this.gizmoColor;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CurveProfile
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public struct CurveProfile
{
  public AnimationCurve curve;
  public float duration;
}
﻿// Decompiled with JetBrains decompiler
// Type: Curves
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class Curves : MonoBehaviourSingleton<Curves>
{
  public List<Curve> list;

  public static AnimationCurve Get(string name) => MonoBehaviourSingleton<Curves>.instance.list.First<Curve>((Func<Curve, bool>) (a => a.name == name)).curve;
}
﻿// Decompiled with JetBrains decompiler
// Type: CustomCursor
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;

public class CustomCursor : MonoBehaviourSingleton<CustomCursor>
{
  public CursorMode cursorMode;
  public CustomCursor.Style[] styles;
  public string currentStyle = "default";
  public Dictionary<string, CustomCursor.Style> styleLookup;
  public static bool visible = true;

  public override void Awake()
  {
    base.Awake();
    CustomCursor.SetStyle(this.currentStyle);
  }

  public CustomCursor.Style Get(string styleName)
  {
    CustomCursor.Style style1 = (CustomCursor.Style) null;
    if (this.styleLookup == null)
    {
      this.styleLookup = new Dictionary<string, CustomCursor.Style>();
      foreach (CustomCursor.Style style2 in this.styles)
      {
        this.styleLookup[style2.name] = style2;
        if (style2.name == styleName)
          style1 = style2;
      }
    }
    else
      style1 = this.styleLookup[styleName];
    return style1;
  }

  public void Set(CustomCursor.Style style)
  {
    MonoBehaviourSingleton<CustomCursor>.instance.currentStyle = style.name;
    Cursor.SetCursor(style.sprite, style.hotSpot, MonoBehaviourSingleton<CustomCursor>.instance.cursorMode);
  }

  public static void SetStyle(string styleName)
  {
    CustomCursor.Style style = MonoBehaviourSingleton<CustomCursor>.instance.Get(styleName);
    if (style == null)
      return;
    MonoBehaviourSingleton<CustomCursor>.instance.Set(style);
  }

  public void OnApplicationFocus(bool focus)
  {
    if (focus)
      CustomCursor.UpdateState();
    else
      Cursor.SetCursor((Texture2D) null, Vector2.zero, CursorMode.Auto);
  }

  public static void UpdateState()
  {
    if (CustomCursor.visible && ((UnityEngine.Object) MonoBehaviourSingleton<Cursor3d>.instance == (UnityEngine.Object) null || MonoBehaviourSingleton<Cursor3d>.instance.usingMouse))
    {
      Cursor.visible = true;
      CustomCursor.SetStyle(MonoBehaviourSingleton<CustomCursor>.instance.currentStyle);
    }
    else
      Cursor.visible = false;
  }

  [Serializable]
  public class Style
  {
    public string name;
    public Texture2D sprite;
    public Vector2 hotSpot;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CustomEventSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.EventSystems;

public class CustomEventSystem : MonoBehaviour
{
  [SerializeField]
  public GameObject current;
  [SerializeField]
  public GameObject press;
  public readonly PointerEventData buttonData = new PointerEventData((EventSystem) null);

  public void Update()
  {
    if (!(bool) (Object) this.press)
    {
      if (!InputSystem.IsSelectPressed() || !(bool) (Object) this.current)
        return;
      this.Press(this.current);
    }
    else
    {
      if (InputSystem.IsSelectHeld())
        return;
      this.Release(this.press);
    }
  }

  public void Hover(GameObject obj)
  {
    this.current = obj;
    ExecuteEvents.ExecuteHierarchy<IPointerEnterHandler>(obj, (BaseEventData) this.buttonData, ExecuteEvents.pointerEnterHandler);
  }

  public void Unhover(GameObject obj)
  {
    if ((bool) (Object) this.current && this.current.Equals((object) obj))
      this.current = (GameObject) null;
    ExecuteEvents.ExecuteHierarchy<IPointerExitHandler>(obj, (BaseEventData) this.buttonData, ExecuteEvents.pointerExitHandler);
  }

  public void Press(GameObject obj)
  {
    this.press = obj;
    ExecuteEvents.ExecuteHierarchy<IPointerDownHandler>(obj, (BaseEventData) this.buttonData, ExecuteEvents.pointerDownHandler);
  }

  public void Release(GameObject obj)
  {
    ExecuteEvents.ExecuteHierarchy<IPointerUpHandler>(obj, (BaseEventData) this.buttonData, ExecuteEvents.pointerUpHandler);
    if ((bool) (Object) obj && (bool) (Object) this.current && obj.Equals((object) this.current))
      ExecuteEvents.ExecuteHierarchy<IPointerClickHandler>(obj, (BaseEventData) this.buttonData, ExecuteEvents.pointerClickHandler);
    this.press = (GameObject) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: CustomInputModule
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class CustomInputModule : StandaloneInputModule
{
  public static readonly List<GameObject> unhoverCache = new List<GameObject>();
  public static readonly Vector2 offscreen = new Vector2(-1000f, -1000f);

  public override void OnEnable()
  {
    base.OnEnable();
    global::Events.OnCardControllerEnabled += new UnityAction<CardController>(this.CardControllerEnabled);
  }

  public override void OnDisable()
  {
    base.OnDisable();
    global::Events.OnCardControllerEnabled -= new UnityAction<CardController>(this.CardControllerEnabled);
  }

  public void CardControllerEnabled(CardController controller) => this.ForceSetMousePosition(CustomInputModule.offscreen);

  public void ForceSetMousePosition(Vector2 position)
  {
    PointerInputModule.MouseState dataWithPosition = this.GetMousePointerEventDataWithPosition(position);
    PointerInputModule.MouseButtonEventData eventData = dataWithPosition.GetButtonState(PointerEventData.InputButton.Left).eventData;
    this.ProcessMousePress(eventData);
    this.ProcessMove(eventData.buttonData);
    this.ProcessDrag(eventData.buttonData);
    this.ProcessMousePress(dataWithPosition.GetButtonState(PointerEventData.InputButton.Right).eventData);
    this.ProcessDrag(dataWithPosition.GetButtonState(PointerEventData.InputButton.Right).eventData.buttonData);
    this.ProcessMousePress(dataWithPosition.GetButtonState(PointerEventData.InputButton.Middle).eventData);
    this.ProcessDrag(dataWithPosition.GetButtonState(PointerEventData.InputButton.Middle).eventData.buttonData);
    if (Mathf.Approximately(eventData.buttonData.scrollDelta.sqrMagnitude, 0.0f))
      return;
    ExecuteEvents.ExecuteHierarchy<IScrollHandler>(ExecuteEvents.GetEventHandler<IScrollHandler>(eventData.buttonData.pointerCurrentRaycast.gameObject), (BaseEventData) eventData.buttonData, ExecuteEvents.scrollHandler);
  }

  public PointerInputModule.MouseState GetMousePointerEventDataWithPosition(Vector2 forcePosition)
  {
    PointerEventData data1;
    int num = this.GetPointerData(-1, out data1, true) ? 1 : 0;
    data1.Reset();
    if (num != 0)
      data1.position = forcePosition;
    if (Cursor.lockState == CursorLockMode.Locked)
    {
      data1.position = new Vector2(-1f, -1f);
      data1.delta = Vector2.zero;
    }
    else
    {
      data1.delta = forcePosition - data1.position;
      data1.position = forcePosition;
    }
    data1.scrollDelta = this.input.mouseScrollDelta;
    data1.button = PointerEventData.InputButton.Left;
    this.eventSystem.RaycastAll(data1, this.m_RaycastResultCache);
    RaycastResult firstRaycast = BaseInputModule.FindFirstRaycast(this.m_RaycastResultCache);
    data1.pointerCurrentRaycast = firstRaycast;
    this.m_RaycastResultCache.Clear();
    PointerEventData data2;
    this.GetPointerData(-2, out data2, true);
    data2.Reset();
    this.CopyFromTo(data1, data2);
    data2.button = PointerEventData.InputButton.Right;
    PointerEventData data3;
    this.GetPointerData(-3, out data3, true);
    data3.Reset();
    this.CopyFromTo(data1, data3);
    data3.button = PointerEventData.InputButton.Middle;
    PointerInputModule.MouseState dataWithPosition = new PointerInputModule.MouseState();
    dataWithPosition.SetButtonState(PointerEventData.InputButton.Left, this.StateForMouseButton(0), data1);
    dataWithPosition.SetButtonState(PointerEventData.InputButton.Right, this.StateForMouseButton(1), data2);
    dataWithPosition.SetButtonState(PointerEventData.InputButton.Middle, this.StateForMouseButton(2), data3);
    return dataWithPosition;
  }

  public override void ProcessMove(PointerEventData pointerEvent)
  {
    GameObject gameObject = Cursor.lockState == CursorLockMode.Locked ? (GameObject) null : pointerEvent.pointerCurrentRaycast.gameObject;
    CustomInputModule.CustomHandlePointerExitAndEnter(pointerEvent, gameObject);
  }

  public static void CustomHandlePointerExitAndEnter(
    PointerEventData currentPointerData,
    GameObject newEnterTarget)
  {
    if ((Object) newEnterTarget == (Object) null || (Object) currentPointerData.pointerEnter == (Object) null)
    {
      int count = currentPointerData.hovered.Count;
      for (int index = 0; index < count; ++index)
      {
        GameObject target = currentPointerData.hovered[index];
        ExecuteEvents.Execute<IPointerExitHandler>(target, (BaseEventData) currentPointerData, ExecuteEvents.pointerExitHandler);
        CustomInputModule.unhoverCache.Add(target);
      }
      currentPointerData.hovered.Clear();
      if ((Object) newEnterTarget == (Object) null)
      {
        currentPointerData.pointerEnter = (GameObject) null;
        return;
      }
    }
    if ((Object) currentPointerData.pointerEnter == (Object) newEnterTarget && (bool) (Object) newEnterTarget)
      return;
    GameObject commonRoot = BaseInputModule.FindCommonRoot(currentPointerData.pointerEnter, newEnterTarget);
    if ((Object) currentPointerData.pointerEnter != (Object) null)
    {
      for (Transform transform = currentPointerData.pointerEnter.transform; (Object) transform != (Object) null && (!((Object) commonRoot != (Object) null) || !((Object) commonRoot.transform == (Object) transform)); transform = transform.parent)
      {
        ExecuteEvents.Execute<IPointerExitHandler>(transform.gameObject, (BaseEventData) currentPointerData, ExecuteEvents.pointerExitHandler);
        currentPointerData.hovered.Remove(transform.gameObject);
        CustomInputModule.unhoverCache.Add(transform.gameObject);
      }
    }
    currentPointerData.pointerEnter = newEnterTarget;
    if ((Object) newEnterTarget != (Object) null)
    {
      for (Transform transform = newEnterTarget.transform; (Object) transform != (Object) null && (Object) transform.gameObject != (Object) commonRoot; transform = transform.parent)
      {
        ExecuteEvents.Execute<IPointerEnterHandler>(transform.gameObject, (BaseEventData) currentPointerData, ExecuteEvents.pointerEnterHandler);
        currentPointerData.hovered.Add(transform.gameObject);
      }
    }
    foreach (GameObject gameObject in CustomInputModule.unhoverCache)
    {
      if ((bool) (Object) gameObject)
        gameObject.GetComponent<IPointerAfterExitHandler>()?.OnPointerAfterExit(currentPointerData);
    }
    CustomInputModule.unhoverCache.Clear();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DailyFetcher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Runtime.CompilerServices;

public static class DailyFetcher
{
  public static int DayOffset;
  [CompilerGenerated]
  public static bool \u003Cfetched\u003Ek__BackingField;
  public static DateTime dateTime;

  public static bool fetched
  {
    get => DailyFetcher.\u003Cfetched\u003Ek__BackingField;
    set => DailyFetcher.\u003Cfetched\u003Ek__BackingField = value;
  }

  public static IEnumerator FetchDateTime()
  {
    DailyFetcher.dateTime = DateTime.Now.AddDays((double) DailyFetcher.DayOffset);
    DailyFetcher.fetched = true;
    yield break;
  }

  public static void CancelFetch() => DailyFetcher.fetched = false;

  public static void SetContinueDateTime() => DailyFetcher.dateTime = DateTime.ParseExact(SaveSystem.LoadCampaignData<string>(Campaign.Data.GameMode, "startDate", ""), "dd/MM/yyyy", (IFormatProvider) GameManager.CultureInfo);

  public static DateTime GetDateTime() => DailyFetcher.dateTime;

  public static DateTime GetNextDateTime() => DailyFetcher.dateTime.Date.AddDays(1.0);

  public static int GetSeed()
  {
    DateTime dateTime = DailyFetcher.GetDateTime();
    int result;
    int.TryParse(string.Format("{0:yyMMdd}{1:D3}", (object) dateTime, (object) dateTime.DayOfYear), out result);
    return result;
  }

  public static string GetDate() => DailyFetcher.GetDateTime().ToString("dd/MM/yyyy");

  public static string GetLeaderboardName() => DailyFetcher.GetLeaderboardName(DailyFetcher.GetDateTime());

  public static string GetLeaderboardName(DateTime dateTime) => DailyFetcher.GetLeaderboardName(dateTime.ToString("dd/MM/yyyy"));

  public static string GetLeaderboardName(string dateString) => "Daily-" + dateString;

  public static bool CanPlay()
  {
    string str = SaveSystem.LoadProgressData<string>("dailyPlayed", (string) null);
    DateTime result;
    return str.IsNullOrWhitespace() || !DateTime.TryParse(str, out result) || !DailyFetcher.SameDay(DailyFetcher.GetDateTime(), result);
  }

  public static bool SameDay(DateTime a, DateTime b) => a.Year == b.Year && a.DayOfYear == b.DayOfYear;
}
﻿// Decompiled with JetBrains decompiler
// Type: DailyGenerator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class DailyGenerator : MonoBehaviour
{
  [SerializeField]
  public Script[] deckRandomizers;
  [SerializeField]
  public GameModifierData[] goodModifiers;
  [SerializeField]
  public GameModifierData[] badModifiers;
  [SerializeField]
  public GameModifierData[] neutralModifiers;
  [HideInInspector]
  public bool running;

  public IEnumerator Run(int seed, GameMode gameMode)
  {
    this.running = true;
    UnityEngine.Random.InitState(seed);
    Names.Reset();
    ClassData classData = gameMode.classes.RandomItem<ClassData>();
    References.PlayerData = new PlayerData(classData, classData.startingInventory.Clone());
    CardData cardData1 = AddressableLoader.Get<CardData>("CardData", MetaprogressionSystem.Get<List<string>>("pets").RandomItem<string>()).Clone();
    References.PlayerData.inventory.deck.Insert(0, cardData1);
    CardData cardData2 = classData.leaders.RandomItem<CardData>().Clone();
    References.PlayerData.inventory.deck.Insert(0, cardData2);
    Campaign.Data = new CampaignData(gameMode, seed)
    {
      GameMode = gameMode,
      GameVersion = Config.data.version,
      Seed = seed
    };
    yield return (object) this.deckRandomizers.RandomItem<Script>().Run();
    int num1 = UnityEngine.Random.Range(-100, 0);
    foreach (CardData cardData3 in References.PlayerData.inventory.deck)
    {
      num1 += cardData3.value - 25;
      if (cardData3.upgrades != null)
        num1 += cardData3.upgrades.Count * 50;
    }
    Debug.Log((object) string.Format("Daily Generator → Deck Value: {0}", (object) num1));
    int num2 = 0;
    List<GameModifierData> list1 = ((IEnumerable<GameModifierData>) this.badModifiers).InRandomOrder<GameModifierData>().ToList<GameModifierData>();
    for (int index = 0; index < 2; ++index)
    {
      GameModifierData modifier = list1.FirstOrDefault<GameModifierData>((Func<GameModifierData, bool>) (a => a.visible));
      if ((bool) (UnityEngine.Object) modifier)
      {
        list1.Remove(modifier);
        ModifierSystem.AddModifier(Campaign.Data, modifier);
        num1 += modifier.value;
        Debug.Log((object) string.Format("Daily Generator → Adding [{0}] Modifier. New Deck Value: {1}", (object) modifier.name, (object) num1));
        ++num2;
      }
      else
        break;
    }
    List<GameModifierData> list2 = ((IEnumerable<GameModifierData>) this.goodModifiers).InRandomOrder<GameModifierData>().ToList<GameModifierData>();
    for (int index = 0; index < 1; ++index)
    {
      GameModifierData modifier = list2.FirstOrDefault<GameModifierData>((Func<GameModifierData, bool>) (a => a.visible));
      if ((bool) (UnityEngine.Object) modifier)
      {
        list2.Remove(modifier);
        ModifierSystem.AddModifier(Campaign.Data, modifier);
        num1 += modifier.value;
        Debug.Log((object) string.Format("Daily Generator → Adding [{0}] Modifier. New Deck Value: {1}", (object) modifier.name, (object) num1));
        ++num2;
      }
      else
        break;
    }
    while (num2 < 6 && Mathf.Abs(num1) > 20)
    {
      List<GameModifierData> source = num1 <= 0 || list1.Count <= 0 ? list2 : list1;
      if (source.Count > 0)
      {
        GameModifierData modifier = source.FirstOrDefault<GameModifierData>((Func<GameModifierData, bool>) (a => !a.visible));
        if ((bool) (UnityEngine.Object) modifier)
        {
          source.Remove(modifier);
          ModifierSystem.AddModifier(Campaign.Data, modifier);
          num1 += modifier.value;
          Debug.Log((object) string.Format("Daily Generator → Adding [{0}] Modifier. New Deck Value: {1}", (object) modifier.name, (object) num1));
          ++num2;
          if (num2 >= 3 && (double) UnityEngine.Random.Range(0.0f, 1f) < 0.5)
            break;
        }
        else
          break;
      }
      else
        break;
    }
    yield return (object) Events.InvokeCampaignInit();
    this.running = false;
  }

  public IEnumerator Test(GameMode gameMode, int days = 730)
  {
    Debug.Log((object) string.Format("Daily Generator → Testing {0} Days", (object) days));
    int dayOffset = DailyFetcher.DayOffset;
    Dictionary<GameModifierData, int> modifiers = new Dictionary<GameModifierData, int>();
    foreach (GameModifierData goodModifier in this.goodModifiers)
      modifiers[goodModifier] = 0;
    foreach (GameModifierData badModifier in this.badModifiers)
      modifiers[badModifier] = 0;
    foreach (GameModifierData neutralModifier in this.neutralModifiers)
      modifiers[neutralModifier] = 0;
    int total = 0;
    for (int i = 0; i < days; ++i)
    {
      DailyFetcher.DayOffset = dayOffset + i;
      yield return (object) DailyFetcher.FetchDateTime();
      yield return (object) this.Run(DailyFetcher.GetSeed(), gameMode);
      foreach (GameModifierData modifier in Campaign.Data.Modifiers)
      {
        modifiers[modifier]++;
        ++total;
      }
    }
    DailyFetcher.DayOffset = dayOffset;
    yield return (object) DailyFetcher.FetchDateTime();
    Debug.Log((object) "Daily Generator → Results:");
    foreach (KeyValuePair<GameModifierData, int> keyValuePair in modifiers)
      Debug.Log((object) string.Format("{0} Count: {1} ({2}%)", (object) keyValuePair.Key.name, (object) keyValuePair.Value, (object) Mathf.RoundToInt((float) ((double) keyValuePair.Value / (double) total * 100.0))));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DailyTimer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class DailyTimer : MonoBehaviour
{
  [SerializeField]
  public TMP_Text textElement;
  [SerializeField]
  public UnityEvent action;
  public int secondsRemaining;
  public float secondTimer;

  public void OnEnable()
  {
    DateTime dateTime = DailyFetcher.GetDateTime();
    float totalSeconds = (float) (DailyFetcher.GetNextDateTime() - dateTime).TotalSeconds;
    this.secondsRemaining = Mathf.FloorToInt(totalSeconds);
    this.secondTimer = totalSeconds - (float) this.secondsRemaining;
    this.UpdateText();
  }

  public void Update()
  {
    this.secondTimer -= Time.deltaTime;
    if ((double) this.secondTimer >= 0.0)
      return;
    for (; (double) this.secondTimer < 0.0; ++this.secondTimer)
      --this.secondsRemaining;
    if (this.secondsRemaining <= 0)
      this.action?.Invoke();
    this.UpdateText();
  }

  public void UpdateText()
  {
    TimeSpan timeSpan = TimeSpan.FromSeconds((double) Mathf.Max(0, this.secondsRemaining));
    this.textElement.text = string.Format("{0:D2}:{1:D2}:{2:D2}", (object) timeSpan.Hours, (object) timeSpan.Minutes, (object) timeSpan.Seconds);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DataFile
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Deadpan.Enums.Engine.Components.Modding;
using System;
using UnityEngine;

public class DataFile : ScriptableObject
{
  [NonSerialized]
  public WildfrostMod ModAdded;

  public override bool Equals(object other)
  {
    UnityEngine.Object object1 = other as UnityEngine.Object;
    UnityEngine.Object object2 = (UnityEngine.Object) this;
    return object1.GetInstanceID() == object2.GetInstanceID();
  }

  public override int GetHashCode() => this.name.GetHashCode();
}
﻿// Decompiled with JetBrains decompiler
// Type: DateTextSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Globalization;
using TMPro;
using UnityEngine;
using UnityEngine.Localization.Settings;

public class DateTextSetter : MonoBehaviour
{
  [SerializeField]
  public TMP_Text textElement;

  public void OnEnable() => this.SetText(0);

  public void SetText(int dayOffset)
  {
    CultureInfo cultureInfo = LocalizationSettings.SelectedLocale.Identifier.CultureInfo;
    this.textElement.text = DailyFetcher.GetDateTime().AddDays((double) dayOffset).ToString("D", (IFormatProvider) cultureInfo);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DeadweightAfterBossModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class DeadweightAfterBossModifierSystem : GameSystem
{
  [SerializeField]
  public string cardDataName = "Deadweight";
  [SerializeField]
  public ChooseNewCardSequence gainCardSequencePrefab;

  public void OnEnable() => global::Events.OnBattleWin += new UnityAction(this.BattleWin);

  public void OnDisable() => global::Events.OnBattleWin -= new UnityAction(this.BattleWin);

  public void BattleWin()
  {
    if (!Campaign.FindCharacterNode(References.Player).type.isBoss)
      return;
    ActionQueue.Add((PlayAction) new ActionSequence(this.GainCardRoutine(AddressableLoader.Get<CardData>("CardData", this.cardDataName))));
  }

  public IEnumerator GainCardRoutine(CardData cardData)
  {
    CardData data = cardData.Clone();
    ChooseNewCardSequence sequence = Object.Instantiate<ChooseNewCardSequence>(this.gainCardSequencePrefab, References.Player.entity.display.transform);
    CardSelector componentInChildren = sequence.GetComponentInChildren<CardSelector>();
    if (componentInChildren != null)
    {
      componentInChildren.character = References.Player;
      componentInChildren.selectEvent.AddListener(new UnityAction<Entity>(global::Events.InvokeEntityChosen));
    }
    sequence.owner = References.Player;
    sequence.cardController.owner = References.Player;
    Card card = CardManager.Get(data, sequence.cardController, References.Player, false, true);
    card.entity.flipper.FlipDownInstant();
    sequence.cardContainer.Add(card.entity);
    yield return (object) card.UpdateData(false);
    card.transform.localPosition = Vector3.down;
    card.entity.wobbler.WobbleRandom();
    sequence.cardContainer.TweenChildPositions();
    global::Events.InvokeEntityOffered(card.entity);
    yield return (object) sequence.Run();
    sequence.gameObject.Destroy();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DeathSfxSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using FMODUnity;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class DeathSfxSystem : GameSystem
{
  [SerializeField]
  public float globalChance = 0.1f;
  [SerializeField]
  public float globalChanceAdd = 0.02f;
  [SerializeField]
  public DeathSfxSystem.Profile[] profiles;
  public float currentGlobalChance;
  public readonly Dictionary<string, Tuple<DeathSfxSystem.Profile, float>> profileLookup = new Dictionary<string, Tuple<DeathSfxSystem.Profile, float>>();

  public void OnEnable()
  {
    this.currentGlobalChance = this.globalChance;
    global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);
    this.profileLookup.Clear();
    foreach (DeathSfxSystem.Profile profile in this.profiles)
    {
      foreach (DeathSfxSystem.CardRef card in profile.cards)
        this.profileLookup[card.card.name] = new Tuple<DeathSfxSystem.Profile, float>(profile, card.pitchShift);
    }
  }

  public void OnDisable() => global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    Tuple<DeathSfxSystem.Profile, float> tuple;
    if (!this.profileLookup.TryGetValue(entity.data.name, out tuple))
      return;
    DeathSfxSystem.Profile profile = tuple.Item1;
    float num1 = tuple.Item2;
    if (!this.CheckChance(profile.chance))
      return;
    int num2 = (int) SfxSystem.OneShot(profile.eventReference).setPitch(1f + num1);
  }

  public bool CheckChance(float chance)
  {
    if ((double) PettyRandom.Range(0.0f, 1f) < (double) chance * (double) this.currentGlobalChance)
    {
      this.currentGlobalChance = this.globalChance;
      return true;
    }
    this.currentGlobalChance += this.globalChanceAdd;
    return false;
  }

  [Serializable]
  public class Profile
  {
    public EventReference eventReference;
    public DeathSfxSystem.CardRef[] cards;
    public float chance;
  }

  [Serializable]
  public class CardRef
  {
    public CardData card;
    public float pitchShift;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DeathSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class DeathSystem : GameSystem
{
  public void OnEnable() => global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);

  public void OnDisable() => global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    if (!(bool) (Object) entity || !(entity.display is Card display) || display.GetComponent<ICardDestroyed>() != null)
      return;
    if (deathType != DeathType.Sacrifice)
    {
      if (deathType != DeathType.Consume)
        this.Destroy(display);
      else
        this.Consume(display);
    }
    else
      this.Sacrifice(display);
  }

  public void Destroy(Card card)
  {
    CardDestroyed cardDestroyed = card.gameObject.AddComponent<CardDestroyed>();
    cardDestroyed.canvasGroup = card.canvasGroup;
    cardDestroyed.Knockback(card.entity.lastHit);
    card.transform.parent = this.transform;
  }

  public void Sacrifice(Card card)
  {
    card.gameObject.AddComponent<CardDestroyedSacrifice>();
    card.transform.parent = this.transform;
  }

  public void Consume(Card card)
  {
    card.gameObject.AddComponent<CardDestroyedConsume>();
    card.transform.parent = this.transform;
  }

  public static bool KilledByOwnTeam(Entity entity) => entity.lastHit != null && (bool) (Object) entity.lastHit.owner && entity.lastHit.owner.team == entity.owner.team && (Object) entity.lastHit.attacker != (Object) entity;
}
﻿// Decompiled with JetBrains decompiler
// Type: DeathType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public enum DeathType
{
  Normal,
  Sacrifice,
  Consume,
  Eaten,
}
﻿// Decompiled with JetBrains decompiler
// Type: DebugMenu
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class DebugMenu : MonoBehaviour
{
  [SerializeField]
  public GameObject menu;
  [SerializeField]
  public float holdTime = 2f;
  [SerializeField]
  public TMP_Text resultText;
  public float currentHoldTime;
  public bool active;

  public void Update()
  {
    if (this.active)
      return;
    if (DebugMenu.CheckMouse() || DebugMenu.CheckController())
    {
      this.currentHoldTime += Time.unscaledDeltaTime;
      if ((double) this.currentHoldTime <= (double) this.holdTime)
        return;
      this.Activate();
    }
    else
      this.currentHoldTime = 0.0f;
  }

  public static bool CheckMouse()
  {
    if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      return false;
    return Input.GetKey(KeyCode.Space) || Input.GetKey(KeyCode.Mouse2);
  }

  public static bool CheckController()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      return false;
    if (InputSystem.IsButtonHeld("Backpack") && InputSystem.IsButtonHeld("Redraw Bell"))
      return true;
    return InputSystem.IsButtonHeld("Up") && InputSystem.IsButtonHeld("Down");
  }

  public void Activate()
  {
    this.active = true;
    this.menu.gameObject.SetActive(true);
    this.resultText.text = "";
  }

  public void Deactivate()
  {
    this.active = false;
    this.menu.gameObject.SetActive(false);
  }

  public void DeleteSave()
  {
    int num = SaveSystem.LoadProgressData<int>("tutorialProgress", 0);
    string str = SaveSystem.LoadProgressData<string>("version", "0");
    SaveSystem.DeleteProgress();
    SaveSystem.DeleteCampaign(AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal"));
    SaveSystem.SaveProgressData<int>("tutorialProgress", num);
    SaveSystem.SaveProgressData<string>("version", str);
    this.resultText.text = "Save Data Deleted!";
  }

  public void ResetTutorial()
  {
    SaveSystem.DeleteProgressData("tutorialProgress");
    this.resultText.text = "Tutorial Reset!";
  }

  public void RunCommand(string command)
  {
    Routine routine = new Routine(Console.HandleCommand(command));
    this.resultText.text = command;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DeckDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class DeckDisplay : MonoBehaviour
{
  [SerializeField]
  public Character owner;
  public DeckDisplaySequence displaySequence;
  public CompanionLimitSequence companionLimitSequence;
  public CompanionRecoverSequence companionRecoverSequence;
  [SerializeField]
  public CardController[] cardControllers;
  [SerializeField]
  public CardContainer[] cardContainers;
  public UINavigationItem backButtonNavigationItem;

  public void SetOwner(Character owner)
  {
    this.owner = owner;
    this.displaySequence.owner = owner;
    foreach (CardController cardController in this.cardControllers)
      cardController.owner = owner;
    foreach (CardContainer cardContainer in this.cardContainers)
      cardContainer.owner = owner;
    if ((Object) this.companionLimitSequence != (Object) null)
      this.companionLimitSequence.owner = owner;
    if (!((Object) this.companionRecoverSequence != (Object) null))
      return;
    this.companionRecoverSequence.owner = owner;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DeckDisplayGroup
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using TMPro;
using UnityEngine;

public class DeckDisplayGroup : MonoBehaviour
{
  public TextMeshProUGUI titleElement;
  public CardContainerGrid[] grids;
  [SerializeField]
  public CardController cardController;

  public IEnumerator CreateCard(CardData data)
  {
    Card card = CardManager.Get(data, this.cardController, (Character) null, false, true);
    this.AddCard(card);
    yield return (object) card.UpdateData(false);
  }

  public CardContainerGrid GetGrid(Card card) => this.GetGrid(card.entity.data);

  public CardContainerGrid GetGrid(CardData cardData) => this.grids.Length <= 1 || !(cardData.cardType.tag == "Friendly") ? this.grids[0] : this.grids[1];

  public void AddCard(Card card)
  {
    CardContainerGrid grid = this.GetGrid(card);
    grid.Add(card.entity);
    card.entity.owner = grid.owner;
  }

  public void InsertCard(int index, Card card)
  {
    CardContainerGrid grid = this.GetGrid(card);
    grid.Insert(index, card.entity);
    card.entity.owner = grid.owner;
  }

  public void RemoveCard(Card card) => this.GetGrid(card).Remove(card.entity);

  public void UpdatePositions()
  {
    foreach (CardContainer grid in this.grids)
      grid.SetChildPositions();
  }

  public void Clear()
  {
    foreach (CardContainerGrid grid in this.grids)
      grid.DestroyAll();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DeckDisplaySequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UI;

public class DeckDisplaySequence : UISequence
{
  public Character owner;
  public Transform background;
  public RectTransform container;
  public DeckDisplayGroup activeCardsGroup;
  public DeckDisplayGroup reserveCardsGroup;
  [SerializeField]
  public CardCharmHolder charmHolder;
  [SerializeField]
  public CrownHolder crownHolder;
  [SerializeField]
  public CardCharmDragHandler charmDragHandler;
  [SerializeField]
  public RectTransform borderLeft;
  [SerializeField]
  public RectTransform borderRight;
  [SerializeField]
  public ScrollRect scrollRect;
  [SerializeField]
  public CardController cardController;

  public override IEnumerator Run()
  {
    DeckDisplaySequence deckDisplaySequence = this;
    yield return (object) Sequences.Wait(deckDisplaySequence.startDelay);
    deckDisplaySequence.container.localScale = Vector3.one;
    StopWatch.Start();
    Routine.Clump clump = new Routine.Clump();
    deckDisplaySequence.activeCardsGroup.Clear();
    foreach (CardData data in deckDisplaySequence.owner.data.inventory.deck)
      clump.Add(deckDisplaySequence.activeCardsGroup.CreateCard(data));
    yield return (object) clump.WaitForEnd();
    deckDisplaySequence.activeCardsGroup.UpdatePositions();
    deckDisplaySequence.reserveCardsGroup.Clear();
    foreach (CardData data in deckDisplaySequence.owner.data.inventory.reserve)
      clump.Add(deckDisplaySequence.reserveCardsGroup.CreateCard(data));
    yield return (object) clump.WaitForEnd();
    deckDisplaySequence.reserveCardsGroup.UpdatePositions();
    deckDisplaySequence.charmHolder.Clear();
    deckDisplaySequence.crownHolder.Clear();
    foreach (CardUpgradeData upgrade in deckDisplaySequence.owner.data.inventory.upgrades)
    {
      switch (upgrade.type)
      {
        case CardUpgradeData.Type.Charm:
          deckDisplaySequence.charmHolder.Create(upgrade);
          continue;
        case CardUpgradeData.Type.Crown:
          deckDisplaySequence.crownHolder.Create(upgrade);
          continue;
        default:
          continue;
      }
    }
    deckDisplaySequence.charmHolder.SetPositions();
    deckDisplaySequence.crownHolder.SetPositions();
    Debug.Log((object) string.Format("DECK CARDS CREATED ({0}ms)", (object) StopWatch.Stop()));
    deckDisplaySequence.background.transform.localScale = Vector3.one;
    deckDisplaySequence.container.transform.localScale = Vector3.one * 0.5f;
    deckDisplaySequence.gameObject.SetActive(true);
    deckDisplaySequence.cardController.Enable();
    yield return (object) deckDisplaySequence.FixLayoutsRoutine();
    LeanTween.cancel(deckDisplaySequence.background.gameObject);
    LeanTween.scale(deckDisplaySequence.background.gameObject, new Vector3(60f, 60f, 1f), 1.5f).setEase(deckDisplaySequence.tweenInEase);
    LeanTween.cancel(deckDisplaySequence.container.gameObject);
    LeanTween.scale(deckDisplaySequence.container.gameObject, Vector3.one, deckDisplaySequence.tweenInDur).setEase(deckDisplaySequence.tweenInEase);
    float time = 0.5f;
    LeanTweenType easeType = LeanTweenType.easeOutBack;
    float delay = 0.1f;
    float borderFrom = 4f;
    LeanTween.cancel(deckDisplaySequence.borderLeft);
    deckDisplaySequence.borderLeft.anchoredPosition3D = new Vector3(-borderFrom, 0.0f, 0.0f);
    LeanTween.move(deckDisplaySequence.borderLeft, new Vector3(-0.7f, 0.0f, 0.0f), time).setEase(easeType).setDelay(delay);
    LeanTween.cancel(deckDisplaySequence.borderRight);
    deckDisplaySequence.borderRight.anchoredPosition3D = new Vector3(borderFrom, 0.0f, 0.0f);
    LeanTween.move(deckDisplaySequence.borderRight, new Vector3(0.7f, 0.0f, 0.0f), time).setEase(easeType).setDelay(delay);
    yield return (object) null;
    deckDisplaySequence.scrollRect.normalizedPosition = new Vector2(0.5f, 1f);
    yield return (object) new WaitUntil(new Func<bool>(deckDisplaySequence.\u003CRun\u003Eb__12_0));
    deckDisplaySequence.promptEnd = false;
    deckDisplaySequence.cardController.Disable();
    if (deckDisplaySequence.charmDragHandler.IsDragging)
      deckDisplaySequence.charmDragHandler.CancelDrag();
    foreach (CardCharmInteraction componentsInChild in deckDisplaySequence.charmHolder.GetComponentsInChildren<CardCharmInteraction>())
    {
      componentsInChild.UnHover();
      componentsInChild.canHover = false;
    }
    foreach (CardCharmInteraction componentsInChild in deckDisplaySequence.crownHolder.GetComponentsInChildren<CardCharmInteraction>())
    {
      componentsInChild.UnHover();
      componentsInChild.canHover = false;
    }
    NavigationState.Start((INavigationState) new NavigationStateWait(true));
    LeanTween.cancel(deckDisplaySequence.background.gameObject);
    LeanTween.scale(deckDisplaySequence.background.gameObject, Vector3.zero, deckDisplaySequence.tweenOutDur).setEase(deckDisplaySequence.tweenOutEase);
    LeanTween.cancel(deckDisplaySequence.container.gameObject);
    LeanTween.scale(deckDisplaySequence.container.gameObject, Vector3.zero, deckDisplaySequence.tweenOutDur).setEase(deckDisplaySequence.tweenOutEase);
    LeanTween.cancel(deckDisplaySequence.borderLeft);
    LeanTween.move(deckDisplaySequence.borderLeft, new Vector3(-borderFrom, 0.0f, 0.0f), deckDisplaySequence.tweenOutDur).setEase(deckDisplaySequence.tweenOutEase);
    LeanTween.cancel(deckDisplaySequence.borderRight);
    LeanTween.move(deckDisplaySequence.borderRight, new Vector3(borderFrom, 0.0f, 0.0f), deckDisplaySequence.tweenOutDur).setEase(deckDisplaySequence.tweenOutEase);
    yield return (object) Sequences.Wait(deckDisplaySequence.tweenOutDur);
    deckDisplaySequence.activeCardsGroup.Clear();
    deckDisplaySequence.reserveCardsGroup.Clear();
    deckDisplaySequence.charmHolder.Clear();
    deckDisplaySequence.crownHolder.Clear();
    NavigationState.BackToPreviousState();
    deckDisplaySequence.gameObject.SetActive(false);
  }

  public IEnumerator FixLayoutsRoutine()
  {
    yield return (object) ((RectTransform) this.activeCardsGroup.transform.parent).FixLayoutGroup();
  }

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__12_0() => this.promptEnd;
}
﻿// Decompiled with JetBrains decompiler
// Type: Deckpack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class Deckpack : MonoBehaviourSingleton<Deckpack>
{
  public UnityEngine.Animator animator;
  [SerializeField]
  public Button button;
  public bool open;

  public static bool IsOpen => MonoBehaviourSingleton<Deckpack>.instance.open;

  public static void Open()
  {
    Events.InvokeDeckpackOpen();
    MonoBehaviourSingleton<Deckpack>.instance.animator.SetBool(nameof (Open), true);
    MonoBehaviourSingleton<Deckpack>.instance.open = true;
  }

  public static void Close()
  {
    Events.InvokeDeckpackClose();
    MonoBehaviourSingleton<Deckpack>.instance.animator.SetBool("Open", false);
    MonoBehaviourSingleton<Deckpack>.instance.open = false;
  }

  public void Ping() => this.animator.SetTrigger(nameof (Ping));
}
﻿// Decompiled with JetBrains decompiler
// Type: DeckpackBlocker
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class DeckpackBlocker : MonoBehaviour
{
  public static uint open;

  public void OnEnable() => DeckpackBlocker.Block();

  public void OnDisable() => DeckpackBlocker.Unblock();

  public static void Block()
  {
    if (DeckpackBlocker.open++ != 0U)
      return;
    DeckpackBlocker.SetButtonsInteractable(false);
    InputSystem.reset = true;
  }

  public static void Unblock()
  {
    if (--DeckpackBlocker.open != 0U)
      return;
    DeckpackBlocker.SetButtonsInteractable(true);
    InputSystem.reset = true;
  }

  public static void SetButtonsInteractable(bool interactable)
  {
    foreach (GameObject gameObject in GameObject.FindGameObjectsWithTag("Deckpack Interaction"))
    {
      Selectable component = gameObject.GetComponent<Selectable>();
      if (component != null)
        component.interactable = interactable;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DeckSelectSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class DeckSelectSequence : UISequence
{
  [SerializeField]
  public UnityEvent onEnable;
  [SerializeField]
  public UnityEvent onDisable;
  [Header("Custom Values")]
  [SerializeField]
  public Transform cardHolder;
  [SerializeField]
  public CanvasGroup fade;
  [SerializeField]
  public float fadeInTime = 0.1f;
  [SerializeField]
  public float fadeOutTime = 0.1f;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public RenameCompanionSequence renameSequence;
  [SerializeField]
  public CrownHolder crownHolder;
  [Header("Buttons")]
  [SerializeField]
  public GameObject buttonGroup;
  [SerializeField]
  public TweenUI buttonShowTween;
  [SerializeField]
  public TweenUI buttonHideTween;
  [SerializeField]
  public GameObject renameButton;
  [SerializeField]
  public GameObject takeCrownButton;
  [SerializeField]
  public GameObject moveDownButton;
  [SerializeField]
  public Button moveDownButtonButton;
  [SerializeField]
  public GameObject moveUpButton;
  [SerializeField]
  public Button moveUpButtonButton;
  [Header("Movement")]
  [SerializeField]
  public float entityScale = 0.75f;
  [SerializeField]
  public float moveWobble = 1.5f;
  [SerializeField]
  public AnimationCurve moveCurve;
  [SerializeField]
  public float moveDur = 0.5f;
  public Entity entity;
  public Transform entityPreParent;
  public bool promptRename;

  public void SetEntity(Entity entity, bool canRename = true)
  {
    this.entity = entity;
    this.renameButton.SetActive((bool) (Object) entity & canRename);
    this.takeCrownButton.SetActive((bool) (Object) entity && DeckSelectSequence.EntityHasRemovableCrown(entity.data) && entity.data.cardType.canTakeCrown && (!(bool) (Object) References.Battle || References.Battle.ended));
    this.moveDownButton.SetActive(false);
    this.moveUpButton.SetActive(false);
  }

  public static bool EntityHasRemovableCrown(CardData cardData)
  {
    CardUpgradeData crown = cardData.GetCrown();
    return (bool) (Object) crown && crown.canBeRemoved;
  }

  public void AddMoveDown(UnityAction callback)
  {
    this.moveDownButton.SetActive(true);
    this.moveDownButtonButton.onClick.RemoveAllListeners();
    this.moveDownButtonButton.onClick.AddListener(callback);
    this.moveDownButtonButton.onClick.AddListener((UnityAction) (() =>
    {
      this.End();
      this.entity = (Entity) null;
    }));
  }

  public void AddMoveUp(UnityAction callback)
  {
    this.moveUpButton.SetActive(true);
    this.moveUpButtonButton.onClick.RemoveAllListeners();
    this.moveUpButtonButton.onClick.AddListener(callback);
    this.moveUpButtonButton.onClick.AddListener((UnityAction) (() =>
    {
      this.End();
      this.entity = (Entity) null;
    }));
  }

  public void Rename() => this.promptRename = true;

  public void TakeCrown()
  {
    CardUpgradeData crown = this.entity.data.GetCrown();
    if (crown == null)
      return;
    this.entity.data.RemoveCrown();
    if (this.entity.display is Card display && display.crownHolder is CrownHolder crownHolder)
      crownHolder.Remove(crown);
    References.PlayerData.inventory.upgrades.Add(crown);
    this.crownHolder.Create(crown);
    this.crownHolder.SetPositions();
  }

  public override void End() => this.promptEnd = true;

  public override IEnumerator Run()
  {
    DeckSelectSequence deckSelectSequence = this;
    deckSelectSequence.onEnable?.Invoke();
    deckSelectSequence.buttonGroup.SetActive(false);
    yield return (object) Sequences.Wait(deckSelectSequence.startDelay);
    deckSelectSequence.gameObject.SetActive(true);
    if ((double) deckSelectSequence.moveWobble != 0.0)
      deckSelectSequence.entity.wobbler?.WobbleRandom(deckSelectSequence.moveWobble);
    deckSelectSequence.entityPreParent = deckSelectSequence.entity.transform.parent;
    deckSelectSequence.entity.transform.SetParent(deckSelectSequence.cardHolder, true);
    LeanTween.cancel(deckSelectSequence.entity.gameObject);
    LeanTween.moveLocal(deckSelectSequence.entity.gameObject, Vector3.zero, deckSelectSequence.moveDur).setEase(deckSelectSequence.moveCurve);
    LeanTween.rotateLocal(deckSelectSequence.entity.gameObject, Vector3.zero, deckSelectSequence.moveDur).setEase(deckSelectSequence.moveCurve);
    LeanTween.scale(deckSelectSequence.entity.gameObject, Vector3.one * deckSelectSequence.entityScale, deckSelectSequence.moveDur).setEase(deckSelectSequence.moveCurve);
    global::Events.InvokeEntityFocus(deckSelectSequence.entity);
    deckSelectSequence.fade.gameObject.SetActive(true);
    deckSelectSequence.fade.alpha = 0.0f;
    deckSelectSequence.fade.LeanAlpha(1f, deckSelectSequence.fadeInTime);
    deckSelectSequence.fade.blocksRaycasts = true;
    deckSelectSequence.buttonGroup.SetActive(true);
    deckSelectSequence.buttonShowTween?.Fire();
    bool protectEnd = true;
    int protectEndCount = 5;
    while (!deckSelectSequence.promptEnd | protectEnd)
    {
      if (deckSelectSequence.promptRename)
      {
        deckSelectSequence.renameSequence.SetUnit(deckSelectSequence.entity);
        yield return (object) deckSelectSequence.renameSequence.Run();
        deckSelectSequence.promptRename = false;
      }
      yield return (object) null;
      if (protectEnd)
      {
        deckSelectSequence.promptEnd = false;
        --protectEndCount;
        if (protectEndCount <= 0)
          protectEnd = false;
      }
    }
    deckSelectSequence.promptEnd = false;
    if ((Object) deckSelectSequence.entity != (Object) null)
    {
      deckSelectSequence.entity.transform.SetParent(deckSelectSequence.entityPreParent, true);
      foreach (CardContainer container in deckSelectSequence.entity.containers)
        container.TweenChildPositions();
      if ((double) deckSelectSequence.moveWobble != 0.0)
        deckSelectSequence.entity.wobbler?.WobbleRandom(deckSelectSequence.moveWobble);
    }
    deckSelectSequence.fade.LeanAlpha(0.0f, deckSelectSequence.fadeOutTime);
    deckSelectSequence.fade.blocksRaycasts = false;
    deckSelectSequence.onDisable?.Invoke();
    deckSelectSequence.gameObject.SetActive(false);
  }

  [CompilerGenerated]
  public void \u003CAddMoveDown\u003Eb__27_0()
  {
    this.End();
    this.entity = (Entity) null;
  }

  [CompilerGenerated]
  public void \u003CAddMoveUp\u003Eb__28_0()
  {
    this.End();
    this.entity = (Entity) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DefeatSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System;
using System.Collections;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

public class DefeatSequence : MonoBehaviour
{
  [SerializeField]
  public EventReference music;
  [SerializeField]
  public float startDelay;
  [SerializeField]
  public GameObject restartButton;
  [SerializeField]
  public GameObject scoresButton;
  [SerializeField]
  public GameObject defeatLayout;
  [SerializeField]
  public GameObject winLayout;
  [SerializeField]
  public GameObject vanquishedLayout;
  [SerializeField]
  public GameObject statsLayout;
  [SerializeField]
  public GameObject leaderDisplayLayout;
  [SerializeField]
  public GameObject challengeLayout;
  [SerializeField]
  public GameObject progressLayout;
  [SerializeField]
  public GameObject scoresLayout;
  [SerializeField]
  public GameObject buttonsLayout;
  [SerializeField]
  public LayoutLink[] titlePanels;
  [SerializeField]
  public ChallengeProgressSequence challengeSequence;
  [SerializeField]
  public MetaprogressSequence progressSequence;
  [SerializeField]
  public ScoreSequence scoreSequence;
  [SerializeField]
  public string endCreditsScene = "CreditsEnd";
  [SerializeField]
  public WinMusic winMusic;
  [Header("Temporary win help panel")]
  [SerializeField]
  public HelpPanelShower gameWinHelp;
  [SerializeField]
  public ParticleSystem gameWinPS;
  public bool active;

  public IEnumerator Start()
  {
    bool flag = (UnityEngine.Object) References.Battle.winner == (UnityEngine.Object) References.Battle.player;
    if (!flag)
      MusicSystem.StartMusic(this.music);
    this.active = true;
    this.restartButton.SetActive(!flag && Campaign.Data.GameMode.canRestart);
    this.scoresButton.SetActive(Campaign.Data.GameMode.submitScore);
    yield return (object) this.Routine();
  }

  public IEnumerator Routine()
  {
    DefeatSequence defeatSequence = this;
    yield return (object) new WaitForSeconds(defeatSequence.startDelay);
    foreach (LayoutLink titlePanel in defeatSequence.titlePanels)
      titlePanel.offset = new Vector3(0.0f, 0.0f, -4f);
    if ((UnityEngine.Object) References.Battle.winner == (UnityEngine.Object) References.Battle.player)
    {
      if (SaveSystem.LoadCampaignData<bool>(Campaign.Data.GameMode, "trueWin", false))
      {
        yield return (object) SceneManager.Load(defeatSequence.endCreditsScene, SceneType.Temporary);
        yield return (object) SceneManager.WaitUntilUnloaded(defeatSequence.endCreditsScene);
      }
      defeatSequence.winMusic.Play();
      defeatSequence.gameWinPS.Play();
      if (SaveSystem.LoadCampaignData<bool>(Campaign.Data.GameMode, "trueWin", false))
        defeatSequence.vanquishedLayout.SetActive(true);
      else
        defeatSequence.winLayout.SetActive(true);
    }
    else
      defeatSequence.defeatLayout.SetActive(true);
    yield return (object) new WaitForSeconds(1f);
    foreach (LayoutLink titlePanel in defeatSequence.titlePanels)
      titlePanel.offset = Vector3.zero;
    if (Campaign.Data.GameMode.showStats)
    {
      defeatSequence.statsLayout.SetActive(true);
      defeatSequence.leaderDisplayLayout.SetActive(true);
    }
    ChallengeProgressSystem objectOfType = UnityEngine.Object.FindObjectOfType<ChallengeProgressSystem>();
    if (objectOfType != null && objectOfType.progress != null && objectOfType.progress.Count<ChallengeProgress>((Func<ChallengeProgress, bool>) (a => a.currentValue > a.originalValue)) > 0)
    {
      defeatSequence.challengeLayout.SetActive(true);
      yield return (object) new WaitForSeconds(1f);
      yield return (object) new WaitUntil(new Func<bool>(defeatSequence.\u003CRoutine\u003Eb__23_1));
    }
    global::Routine.Clump clump = new global::Routine.Clump();
    if (Campaign.Data.GameMode.submitScore)
    {
      defeatSequence.scoresLayout.SetActive(true);
      yield return (object) new WaitForSeconds(1f);
      clump.Add((IEnumerator) new WaitUntil(new Func<bool>(defeatSequence.\u003CRoutine\u003Eb__23_2)));
    }
    yield return (object) clump.WaitForEnd();
    defeatSequence.buttonsLayout.SetActive(true);
  }

  public void GoTo(string sceneName)
  {
    if (!this.active)
      return;
    this.active = false;
    global::Routine routine = new global::Routine(Sequences.EndCampaign(sceneName));
  }

  public void QuickRestart()
  {
    if (!this.active)
      return;
    Campaign.Data = new CampaignData(Campaign.Data.GameMode);
    global::Routine routine = new global::Routine(Sequences.EndCampaign("CharacterSelect"));
    this.active = false;
  }

  public void Exit()
  {
    if (!this.active)
      return;
    this.active = false;
    if ((UnityEngine.Object) References.Campaign != (UnityEngine.Object) null)
      References.Campaign.Final();
    GameManager.Quit();
  }

  [CompilerGenerated]
  public bool \u003CRoutine\u003Eb__23_1() => !this.challengeSequence.running;

  [CompilerGenerated]
  public bool \u003CRoutine\u003Eb__23_2() => !this.scoreSequence.running;
}
﻿// Decompiled with JetBrains decompiler
// Type: Delta
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public static class Delta
{
  public static readonly float targetFps = 60f;

  public static float Multiply(float current, float multiply, float delta) => current * Mathf.Pow(multiply, delta * Delta.targetFps);

  public static Vector2 Multiply(Vector2 current, float multiply, float delta) => current * Mathf.Pow(multiply, delta * Delta.targetFps);

  public static Vector2 Multiply(Vector2 current, Vector3 multiply, float delta)
  {
    float p = delta * Delta.targetFps;
    return new Vector2(current.x * Mathf.Pow(multiply.x, p), current.y * Mathf.Pow(multiply.y, p));
  }

  public static Vector3 Multiply(Vector3 current, float multiply, float delta) => current * Mathf.Pow(multiply, delta * Delta.targetFps);

  public static Vector3 Multiply(Vector3 current, Vector3 multiply, float delta)
  {
    float p = delta * Delta.targetFps;
    double x = (double) current.x * (double) Mathf.Pow(multiply.x, p);
    float num1 = current.y * Mathf.Pow(multiply.y, p);
    float num2 = current.z * Mathf.Pow(multiply.z, p);
    double y = (double) num1;
    double z = (double) num2;
    return new Vector3((float) x, (float) y, (float) z);
  }

  public static float Lerp(float current, float target, float amount, float delta) => Mathf.Lerp(current, target, 1f - Mathf.Pow(1f - amount, delta * Delta.targetFps));

  public static Vector2 Lerp(Vector2 current, Vector2 target, float amount, float delta) => Vector2.Lerp(current, target, 1f - Mathf.Pow(1f - amount, delta * Delta.targetFps));

  public static Vector3 Lerp(Vector3 current, Vector3 target, float amount, float delta) => Vector3.Lerp(current, target, 1f - Mathf.Pow(1f - amount, delta * Delta.targetFps));

  public static Quaternion Lerp(Quaternion current, Quaternion target, float amount, float delta) => Quaternion.Lerp(current, target, 1f - Mathf.Pow(1f - amount, delta * Delta.targetFps));

  public static Vector3 LerpAngle(Vector3 current, Vector3 target, float amount, float delta)
  {
    float t = 1f - Mathf.Pow(1f - amount, delta * Delta.targetFps);
    double x = (double) Mathf.LerpAngle(current.x, target.x, t);
    float num1 = Mathf.LerpAngle(current.y, target.y, t);
    float num2 = Mathf.LerpAngle(current.z, target.z, t);
    double y = (double) num1;
    double z = (double) num2;
    return new Vector3((float) x, (float) y, (float) z);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DemoEndSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class DemoEndSequence : MonoBehaviour
{
  [SerializeField]
  public GameObject[] pages;
  [SerializeField]
  public Image[] pageBlips;
  [SerializeField]
  public Sprite blipActive;
  [SerializeField]
  public Sprite blipInactive;
  [SerializeField]
  public OpenURL openURL;
  [SerializeField]
  public TweenUI nextPageTween;
  [SerializeField]
  public TweenUI previousPageTween;
  public int currentPage;
  public bool active = true;

  public void Awake()
  {
    for (int index = 0; index < this.transform.childCount; ++index)
    {
      if (this.transform.GetChild(index).gameObject.activeSelf)
      {
        this.currentPage = index;
        break;
      }
    }
    if (!(bool) (Object) MonoBehaviourSingleton<Deckpack>.instance || !Deckpack.IsOpen)
      return;
    Deckpack.Close();
  }

  public void NextPage()
  {
    if (!this.active)
      return;
    this.ClosePage(this.currentPage);
    ++this.currentPage;
    if (this.currentPage >= this.pages.Length)
      this.currentPage = 0;
    this.OpenPage(this.currentPage);
    this.nextPageTween.Fire();
  }

  public void PreviousPage()
  {
    if (!this.active)
      return;
    this.ClosePage(this.currentPage);
    --this.currentPage;
    if (this.currentPage < 0)
      this.currentPage = this.pages.Length - 1;
    this.OpenPage(this.currentPage);
    this.previousPageTween.Fire();
  }

  public void Wishlist()
  {
    if (!this.active)
      return;
    this.openURL.Open();
  }

  public void Close()
  {
    if (!this.active)
      return;
    this.active = false;
    Routine routine = new Routine(SceneManager.Unload("DemoEnd"));
  }

  public void OpenPage(int number)
  {
    this.pages[number].SetActive(true);
    this.pageBlips[number].sprite = this.blipActive;
  }

  public void ClosePage(int number)
  {
    this.pages[this.currentPage].SetActive(false);
    this.pageBlips[this.currentPage].sprite = this.blipInactive;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Dice
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

public class Dice : MonoBehaviour
{
  public int value = -1;
  [SerializeField]
  public Rigidbody2D rb;
  [SerializeField]
  public SpriteRenderer spriteRenderer;
  [SerializeField]
  public Vector2 throwSpeed = new Vector2(20f, 40f);
  [SerializeField]
  public Vector2 spinAmount = new Vector2(4f, 6f);
  [SerializeField]
  public Vector2 drag = new Vector2(5f, 6f);
  [Header("Faces")]
  [SerializeField]
  public Sprite[] faceSprites;
  [SerializeField]
  public int[] faceValues = new int[6]{ 1, 2, 3, 4, 5, 6 };

  public void Roll()
  {
    int index = Dead.Random.Range(0, this.faceValues.Length - 1);
    this.value = this.faceValues[index];
    this.spriteRenderer.sprite = this.faceSprites[index];
  }

  [Button(null, EButtonEnableMode.Always)]
  public void Throw()
  {
    foreach (Dice dice in Object.FindObjectsOfType<Dice>())
    {
      Vector3 normalized = (Vector3.zero - dice.transform.position).normalized;
      dice.Throw((Vector2) normalized);
    }
  }

  public void Throw(Vector2 direction)
  {
    this.rb.drag = this.drag.Random();
    this.rb.angularDrag = this.drag.Random();
    this.rb.velocity = direction * this.throwSpeed.Random();
    this.rb.angularVelocity = this.rb.velocity.magnitude * this.spinAmount.Random();
    this.Roll();
  }

  public void DisableCollisions() => this.rb.simulated = false;
}
﻿// Decompiled with JetBrains decompiler
// Type: DictionaryExt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;

public static class DictionaryExt
{
  public static T[] GetSaveCollection<T>(this Dictionary<string, object> dict, string key) => ((SaveCollection<T>) dict[key]).collection;
}
﻿// Decompiled with JetBrains decompiler
// Type: DisableForReleaseBuild
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class DisableForReleaseBuild : MonoBehaviour
{
  [SerializeField]
  public bool disableGameObject = true;
  [SerializeField]
  public bool disableComponent;

  public void OnEnable()
  {
    if (this.disableGameObject)
      this.gameObject.SetActive(false);
    if (!this.disableComponent)
      return;
    this.enabled = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DisableIf
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class DisableIf : MonoBehaviour
{
  [SerializeField]
  public bool not;
  [SerializeField]
  public bool RELEASE;
  [SerializeField]
  public bool DEMO;
  [SerializeField]
  public bool CHALLENGES;
  [SerializeField]
  public bool BATTLE_LOG;
  [SerializeField]
  public bool ANALYTICS;
  [SerializeField]
  public bool JOURNAL_PAGES;
  [SerializeField]
  public bool HARD_MODE;
  [SerializeField]
  public bool CANNOT_EXIT;
  [SerializeField]
  public bool BETA;
  [SerializeField]
  public bool NEW_FROST_BELLS;
  [SerializeField]
  public bool destroy;

  public void OnEnable()
  {
    bool flag = false;
    if (this.RELEASE)
      flag = true;
    if (this.CHALLENGES)
      flag = true;
    if (this.BATTLE_LOG)
      flag = true;
    if (this.JOURNAL_PAGES)
      flag = true;
    if (this.NEW_FROST_BELLS)
      flag = true;
    if ((!this.not || flag) && !(!this.not & flag))
      return;
    this.Disable();
  }

  public void Disable()
  {
    if (this.destroy)
      this.gameObject.DestroyImmediate();
    else
      this.gameObject.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DisableWhenDeckpackOpened
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class DisableWhenDeckpackOpened : MonoBehaviour
{
  [SerializeField]
  public Behaviour[] components;
  [SerializeField]
  public GameObject[] gameObjects;

  public void OnEnable()
  {
    global::Events.OnDeckpackOpen += new UnityAction(this.Open);
    global::Events.OnDeckpackClose += new UnityAction(this.Close);
  }

  public void OnDisable()
  {
    global::Events.OnDeckpackOpen -= new UnityAction(this.Open);
    global::Events.OnDeckpackClose -= new UnityAction(this.Close);
  }

  public void Open()
  {
    foreach (Behaviour component in this.components)
      component.enabled = false;
    foreach (GameObject gameObject in this.gameObjects)
      gameObject.SetActive(false);
  }

  public void Close()
  {
    foreach (Behaviour component in this.components)
      component.enabled = true;
    foreach (GameObject gameObject in this.gameObjects)
      gameObject.SetActive(true);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DiscardDisplaySystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class DiscardDisplaySystem : GameSystem
{
  [SerializeField]
  public Transform display;
  [SerializeField]
  public TweenUI showTween;
  [SerializeField]
  public TweenUI hideTween;
  public Entity entityDrag;
  public CardContainer hoverDiscardContainer;
  public bool draggingCanDiscard;

  public void OnEnable()
  {
    global::Events.OnEntityDrag += new UnityAction<Entity>(this.EntityDrag);
    global::Events.OnEntityRelease += new UnityAction<Entity>(this.EntityRelease);
    global::Events.OnContainerHover += new UnityAction<CardContainer>(this.ContainerHover);
    global::Events.OnContainerUnHover += new UnityAction<CardContainer>(this.ContainerUnHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityDrag -= new UnityAction<Entity>(this.EntityDrag);
    global::Events.OnEntityRelease -= new UnityAction<Entity>(this.EntityRelease);
    global::Events.OnContainerHover -= new UnityAction<CardContainer>(this.ContainerHover);
    global::Events.OnContainerUnHover -= new UnityAction<CardContainer>(this.ContainerUnHover);
  }

  public void EntityDrag(Entity entity)
  {
    this.entityDrag = entity;
    this.draggingCanDiscard = entity.CanRecall();
  }

  public void EntityRelease(Entity entity)
  {
    if (!((Object) this.entityDrag == (Object) entity))
      return;
    this.entityDrag = (Entity) null;
    this.Hide();
  }

  public void ContainerHover(CardContainer container)
  {
    if (!((Object) this.entityDrag != (Object) null) || !this.draggingCanDiscard || !((Object) container != (Object) null) || !((Object) this.entityDrag.owner != (Object) null) || !((Object) container == (Object) this.entityDrag.owner.discardContainer))
      return;
    this.hoverDiscardContainer = container;
    this.display.position = container.transform.position;
    this.Show();
  }

  public void ContainerUnHover(CardContainer container)
  {
    if (!((Object) this.hoverDiscardContainer == (Object) container))
      return;
    this.hoverDiscardContainer = (CardContainer) null;
    this.Hide();
  }

  public void Show()
  {
    this.display.gameObject.SetActive(true);
    this.showTween?.Fire();
  }

  public void Hide() => this.StartCoroutine(this.HideRoutine());

  public IEnumerator HideRoutine()
  {
    if ((Object) this.hideTween != (Object) null)
    {
      this.hideTween.Fire();
      yield return (object) Sequences.Wait(this.hideTween.GetDuration());
    }
    this.display.gameObject.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Discarder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class Discarder : MonoBehaviour
{
  public void Discard(Entity entity)
  {
    CoroutineManager.Start(Discarder.ClearStatusEffects(entity));
    entity.counter.current = entity.counter.max;
    entity.uses.current = entity.uses.max;
    entity.PromptUpdate();
  }

  public static IEnumerator ClearStatusEffects(Entity entity)
  {
    Debug.Log((object) string.Format("DISCARDER → Clearing Status Effects [{0}]", (object) entity));
    for (int i = entity.statusEffects.Count - 1; i >= 0; --i)
    {
      StatusEffectData statusEffect = entity.statusEffects[i];
      if ((bool) (Object) statusEffect && statusEffect.removeOnDiscard)
        yield return (object) statusEffect.Remove();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DiscardHealSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;

public class DiscardHealSystem : GameSystem
{
  [SerializeField]
  public int healAmount = 5;
  [SerializeField]
  public LocalizedString healTextKey;
  [SerializeField]
  public Vector3 healPopupOffset = Vector3.up;

  public void OnEnable() => global::Events.OnDiscard += new UnityAction<Entity>(this.Discard);

  public void OnDisable() => global::Events.OnDiscard -= new UnityAction<Entity>(this.Discard);

  public void Discard(Entity entity)
  {
    ActionDiscardEffect action = new ActionDiscardEffect(entity, this.healAmount);
    if (!global::Events.CheckAction((PlayAction) action))
      return;
    ActionQueue.Add((PlayAction) action);
    if (!entity.data.hasHealth)
      return;
    Vector3 position = entity.transform.position + this.healPopupOffset;
    string text = "<size=0.5>" + string.Format(this.healTextKey.GetLocalizedString(), (object) this.healAmount);
    FloatingText.Create(position).SetText(text).SetSortingLayer("PopUp", 10).Animate("Spring").Fade("Smooth");
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DoubleGoblingGoldModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class DoubleGoblingGoldModifierSystem : GameSystem
{
  public const float multiplier = 2f;

  public void OnEnable() => global::Events.OnCardDataCreated += new UnityAction<CardData>(DoubleGoblingGoldModifierSystem.CardDataCreated);

  public void OnDisable() => global::Events.OnCardDataCreated -= new UnityAction<CardData>(DoubleGoblingGoldModifierSystem.CardDataCreated);

  public static void CardDataCreated(CardData cardData)
  {
    if (!(cardData.name == "Gobling"))
      return;
    CardData.StatusEffectStacks startWithEffect = cardData.startWithEffects[1];
    startWithEffect.count = Mathf.RoundToInt((float) startWithEffect.count * 2f);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DrainLeaderAfterBattleSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class DrainLeaderAfterBattleSystem : GameSystem
{
  [SerializeField]
  public int[] modifyAfterBattleTier = new int[1]{ 5 };
  [SerializeField]
  public CardScript modifyScript;
  [SerializeField]
  public bool modifyLeader;
  [SerializeField]
  [HideIf("modifyLeader")]
  public int modifyCardIndex;
  [SerializeField]
  public ModifyCardSequence sequencePrefab;

  public void OnEnable() => global::Events.OnBattleWinPreRewards += new UnityAction(this.BattleWinPreRewards);

  public void OnDisable() => global::Events.OnBattleWinPreRewards -= new UnityAction(this.BattleWinPreRewards);

  public void BattleWinPreRewards()
  {
    if (!this.modifyAfterBattleTier.Contains<int>(Campaign.FindCharacterNode(References.Player).tier))
      return;
    ActionQueue.Add((PlayAction) new ActionSequence(this.ModifyCardRoutine(this.modifyLeader ? References.LeaderData : References.PlayerData.inventory.deck[this.modifyCardIndex])));
  }

  public IEnumerator ModifyCardRoutine(CardData cardToModify)
  {
    ModifyCardSequence sequence = Object.Instantiate<ModifyCardSequence>(this.sequencePrefab, References.Player.entity.display.transform);
    yield return (object) sequence.Run(cardToModify, this.modifyScript);
    sequence.gameObject.Destroy();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DrainLeaderModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class DrainLeaderModifierSystem : GameSystem
{
  public const int addHealth = -1;

  public void OnEnable() => global::Events.PostBattle += new UnityAction<CampaignNode>(this.PostBattle);

  public void OnDisable() => global::Events.PostBattle -= new UnityAction<CampaignNode>(this.PostBattle);

  public void PostBattle(CampaignNode campaignNode)
  {
    CardData cardData = References.PlayerData.inventory.deck.FirstOrDefault<CardData>((Func<CardData, bool>) (a => a.cardType.miniboss));
    if (!(bool) (UnityEngine.Object) cardData || cardData.hp <= 1)
      return;
    int hp = cardData.hp;
    cardData.hp = Mathf.Max(1, cardData.hp - 1);
    Debug.Log((object) string.Format("[{0}] draining leader health ({1} → {2})", (object) this, (object) hp, (object) cardData.hp));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DrawExtraWhenRedrawNotChargedSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class DrawExtraWhenRedrawNotChargedSystem : MonoBehaviour
{
  public const int extraDraw = 3;
  public RedrawBellSystem _redrawBellSystem;

  public RedrawBellSystem redrawBellSystem => this._redrawBellSystem ?? (this._redrawBellSystem = Object.FindObjectOfType<RedrawBellSystem>());

  public void OnEnable() => Events.OnGetHandSize += new Events.UnityActionRef<int>(this.GetHandSize);

  public void OnDisable() => Events.OnGetHandSize -= new Events.UnityActionRef<int>(this.GetHandSize);

  public void GetHandSize(ref int handSize)
  {
    if (this.redrawBellSystem.IsCharged)
      return;
    handSize += 3;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DropGoldSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class DropGoldSystem : GameSystem
{
  [SerializeField]
  public float goldFactor = 0.02f;
  [SerializeField]
  public int goldPerUpgrade = 5;
  [SerializeField]
  public bool dropGoldOnFlee = true;

  public void OnEnable()
  {
    global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnEntityFlee += new UnityAction<Entity>(this.EntityFlee);
  }

  public void OnDisable()
  {
    global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnEntityFlee -= new UnityAction<Entity>(this.EntityFlee);
  }

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    if (deathType != DeathType.Normal)
      return;
    this.TryDropGold(entity, "Kill");
  }

  public void EntityFlee(Entity entity)
  {
    if (!this.dropGoldOnFlee)
      return;
    this.TryDropGold(entity, "Flee");
  }

  public void TryDropGold(Entity entity, string source)
  {
    if ((bool) (Object) entity.owner && entity.owner.team == References.Player.team)
      return;
    int goldToDrop = this.GetGoldToDrop(entity);
    if (goldToDrop <= 0)
      return;
    global::Events.InvokeDropGold(goldToDrop, source, References.Player, entity.transform.position);
  }

  public int GetGoldToDrop(Entity entity)
  {
    int num = Mathf.RoundToInt((float) entity.data.value * this.goldFactor * References.PlayerData.enemyGoldFactor);
    int goldToDrop = num > 0 ? Mathf.Max(0, num + Mathf.RoundToInt(entity.data.random3.z)) : 0;
    if (entity.data.upgrades != null)
      goldToDrop += entity.data.upgrades.Count * this.goldPerUpgrade;
    return goldToDrop;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DynamicReactionTutorialSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

public class DynamicReactionTutorialSystem : GameSystem
{
  public void OnEnable()
  {
    Events.OnCampaignGenerated += new Events.AsyncAction(DynamicReactionTutorialSystem.CampaignGenerated);
    if (!SaveSystem.LoadProgressData<bool>("dynamicReactionTutorial", false) && !(Campaign.Data.GameMode.name != "GameModeNormal"))
      return;
    this.enabled = false;
  }

  public void OnDisable() => Events.OnCampaignGenerated -= new Events.AsyncAction(DynamicReactionTutorialSystem.CampaignGenerated);

  public static Task CampaignGenerated()
  {
    CampaignNode campaignNode = References.Campaign.nodes.FirstOrDefault<CampaignNode>((Func<CampaignNode, bool>) (a => a.type.isBattle));
    object obj;
    if (campaignNode != null && campaignNode.data.TryGetValue("waves", out obj) && obj is SaveCollection<BattleWaveManager.WaveData> saveCollection && saveCollection.Count > 0)
    {
      BattleWaveManager.WaveData waveData = saveCollection[0];
      if (waveData != null)
      {
        string[] strArray = new string[1]{ "Smackgoon" };
        string[] array = new string[5]
        {
          "Chungoon",
          "Grouchy",
          "Snoolf",
          "Snowbo",
          "NakedGnome"
        };
        bool flag = false;
        for (int index = 0; index < waveData.Count; ++index)
        {
          string cardName = waveData.GetCardName(index);
          if (strArray.Contains<string>(cardName))
          {
            flag = true;
            break;
          }
        }
        if (!flag)
        {
          for (int index = 0; index < waveData.Count; ++index)
          {
            string cardName = waveData.GetCardName(index);
            if (array.Contains<string>(cardName) && waveData is BattleWaveManager.WaveDataBasic waveDataBasic)
            {
              BattleWaveManager.Card card = waveDataBasic.Get(index);
              card.cardName = strArray.RandomItem<string>();
              card.upgradeNames = (List<string>) null;
              break;
            }
          }
        }
      }
    }
    return Task.CompletedTask;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DynamicTutorialSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;

public class DynamicTutorialSystem : GameSystem
{
  [SerializeField]
  public DynamicTutorialSystem.Tutorial redrawTutorial;
  [SerializeField]
  public DynamicTutorialSystem.Tutorial moveTutorial;
  [SerializeField]
  public DynamicTutorialSystem.Tutorial recallTutorial;
  [SerializeField]
  public DynamicTutorialSystem.Tutorial aimlessTutorial;
  [SerializeField]
  public DynamicTutorialSystem.Tutorial reactionTutorial;
  public DynamicTutorialSystem.Tutorial[] tutorials;
  public bool aimlessTutorialDone;
  public bool reactionTutorialDone;
  public Entity aimlessEnemy;
  public Entity reactionEnemy;

  public void OnEnable()
  {
    this.tutorials = new DynamicTutorialSystem.Tutorial[5]
    {
      this.redrawTutorial,
      this.moveTutorial,
      this.recallTutorial,
      this.aimlessTutorial,
      this.reactionTutorial
    };
    foreach (DynamicTutorialSystem.Tutorial tutorial in this.tutorials)
      tutorial.Load();
    this.aimlessTutorialDone = SaveSystem.LoadProgressData<bool>("dynamicAimlessTutorial", false);
    this.reactionTutorialDone = SaveSystem.LoadProgressData<bool>("dynamicReactionTutorial", false);
    global::Events.OnEntityPlace += new UnityAction<Entity, CardContainer[], bool>(this.EntityPlace);
    global::Events.OnDiscard += new UnityAction<Entity>(this.Discard);
    global::Events.OnRedrawBellHit += new UnityAction<RedrawBellSystem>(this.RedrawBellHit);
    global::Events.OnBattleTurnStart += new UnityAction<int>(this.TurnStart);
    global::Events.OnBattleTurnEnd += new UnityAction<int>(this.TurnEnd);
    global::Events.OnCampaignSaved += new UnityAction(this.Save);
  }

  public void OnDisable()
  {
    global::Events.OnEntityPlace -= new UnityAction<Entity, CardContainer[], bool>(this.EntityPlace);
    global::Events.OnDiscard -= new UnityAction<Entity>(this.Discard);
    global::Events.OnRedrawBellHit -= new UnityAction<RedrawBellSystem>(this.RedrawBellHit);
    global::Events.OnBattleTurnStart -= new UnityAction<int>(this.TurnStart);
    global::Events.OnBattleTurnEnd -= new UnityAction<int>(this.TurnEnd);
    global::Events.OnCampaignSaved -= new UnityAction(this.Save);
  }

  public void EntityPlace(Entity entity, CardContainer[] slots, bool freeMove)
  {
    if (!freeMove || entity.owner.team != References.Player.team)
      return;
    this.moveTutorial.actionDoneThisTurn = true;
    this.moveTutorial.ResetCount();
  }

  public void Discard(Entity entity)
  {
    if (!entity.data.hasHealth)
      return;
    this.recallTutorial.actionDoneThisTurn = true;
    this.recallTutorial.ResetCount();
  }

  public void RedrawBellHit(RedrawBellSystem redrawBellSystem)
  {
    if (redrawBellSystem.IsCharged)
      return;
    this.redrawTutorial.actionDoneThisTurn = true;
    this.redrawTutorial.ResetCount();
  }

  public void TurnStart(int turnCount)
  {
    foreach (DynamicTutorialSystem.Tutorial tutorial in this.tutorials)
    {
      if (tutorial.shown)
      {
        tutorial.Hide();
        break;
      }
    }
  }

  public void TurnEnd(int turnCount)
  {
    foreach (DynamicTutorialSystem.Tutorial tutorial in this.tutorials)
      tutorial.CheckIncreaseCount();
    if (References.Battle.ended || this.CheckAimlessTutorial(turnCount) || this.CheckReactionTutorial(turnCount) || this.CheckMoveTutorial() || this.CheckRedrawTutorial())
      return;
    this.CheckRecallTutorial();
  }

  public bool CheckAimlessTutorial(int turnCount)
  {
    if (this.aimlessTutorialDone)
      return false;
    if (turnCount == 0)
    {
      this.aimlessEnemy = Battle.GetCardsOnBoard(References.Battle.enemy).FirstOrDefault<Entity>((Func<Entity, bool>) (a => a.data.traits.Any<CardData.TraitStacks>((Func<CardData.TraitStacks, bool>) (t => t.data.name == "Aimless"))));
      return false;
    }
    if (!(bool) (UnityEngine.Object) this.aimlessEnemy || !this.aimlessEnemy.IsAliveAndExists() || this.aimlessEnemy.counter.current != 1)
      return false;
    this.aimlessTutorial.Show((object) this.aimlessEnemy.data.title);
    SaveSystem.SaveProgressData<bool>("dynamicAimlessTutorial", true);
    this.aimlessTutorialDone = true;
    return true;
  }

  public bool CheckReactionTutorial(int turnCount)
  {
    if (this.reactionTutorialDone || turnCount != 0)
      return false;
    this.reactionEnemy = Battle.GetCardsOnBoard(References.Battle.enemy).FirstOrDefault<Entity>((Func<Entity, bool>) (a => a.statusEffects.Any<StatusEffectData>((Func<StatusEffectData, bool>) (s => s.isReaction))));
    if (!(bool) (UnityEngine.Object) this.reactionEnemy)
      return false;
    this.reactionTutorial.Show((object) this.reactionEnemy.data.title);
    SaveSystem.SaveProgressData<bool>("dynamicReactionTutorial", true);
    this.reactionTutorialDone = true;
    return true;
  }

  public bool CheckRecallTutorial()
  {
    if (this.recallTutorial.Check())
    {
      foreach (Entity entity in Battle.GetCardsOnBoard(References.Battle.player))
      {
        if (entity.data.hasHealth && (double) entity.hp.current <= (double) entity.hp.max * 0.5 && entity.CanRecall())
        {
          this.recallTutorial.Show();
          PromptSystem.Prompt.SetEmotePosition(Prompt.Emote.Position.Above, 2f);
          return true;
        }
      }
    }
    return false;
  }

  public bool CheckRedrawTutorial()
  {
    if (!this.redrawTutorial.Check() || References.Battle.turnCount != 0 || Battle.GetCardsOnBoard(References.Battle.player).Count != 1)
      return false;
    foreach (Entity entity in References.Battle.player.handContainer)
    {
      if (entity.data.counter > 0)
        return false;
    }
    int num = References.Battle.player.handContainer.max - References.Battle.player.handContainer.Count;
    int count = References.Battle.player.drawContainer.Count;
    for (int index1 = 0; index1 < num; ++index1)
    {
      int index2 = count - 1 - index1;
      if (index2 >= 0 && References.Battle.player.drawContainer[index2].data.counter > 0)
        return false;
    }
    this.redrawTutorial.Show();
    PromptSystem.Prompt.SetEmotePosition(Prompt.Emote.Position.Above, 1.5f, forceFlip: 1f);
    return true;
  }

  public bool CheckMoveTutorial()
  {
    if (this.moveTutorial.Check())
    {
      bool flag = false;
      foreach (Entity entity in Battle.GetCardsOnBoard(References.Battle.player))
      {
        if (entity.statusEffects.All<StatusEffectData>((Func<StatusEffectData, bool>) (a => a.name != "Unmovable")))
        {
          flag = true;
          break;
        }
      }
      if (flag)
      {
        this.moveTutorial.Show();
        return true;
      }
    }
    return false;
  }

  public void Save()
  {
    foreach (DynamicTutorialSystem.Tutorial tutorial in this.tutorials)
      tutorial.Save();
  }

  [Serializable]
  public class Tutorial
  {
    public bool onlyShowOnce;
    public int turnsRequired;
    public int resetOffset = -50;
    public string saveString;
    public LocalizedString stringRef;
    public Prompt.Anchor promptAnchor;
    public Vector2 promptPosition;
    public float promptWidth;
    public Prompt.Emote.Type promptEmote;
    public int flipEmote = 1;
    [CompilerGenerated]
    public int \u003Ccurrent\u003Ek__BackingField;
    [CompilerGenerated]
    public bool \u003CcurrentBool\u003Ek__BackingField;
    [CompilerGenerated]
    public bool \u003Cshown\u003Ek__BackingField;
    [CompilerGenerated]
    public bool \u003CactionDoneThisTurn\u003Ek__BackingField;

    public int current
    {
      get => this.\u003Ccurrent\u003Ek__BackingField;
      set => this.\u003Ccurrent\u003Ek__BackingField = value;
    }

    public bool currentBool
    {
      get => this.\u003CcurrentBool\u003Ek__BackingField;
      set => this.\u003CcurrentBool\u003Ek__BackingField = value;
    }

    public bool shown
    {
      get => this.\u003Cshown\u003Ek__BackingField;
      set => this.\u003Cshown\u003Ek__BackingField = value;
    }

    public bool actionDoneThisTurn
    {
      get => this.\u003CactionDoneThisTurn\u003Ek__BackingField;
      set => this.\u003CactionDoneThisTurn\u003Ek__BackingField = value;
    }

    public void ResetCount()
    {
      this.current = this.resetOffset;
      if (!this.shown)
        return;
      this.Hide();
    }

    public void Load()
    {
      if (this.onlyShowOnce)
        return;
      this.current = SaveSystem.LoadProgressData<int>(this.saveString, 0);
    }

    public void Save()
    {
      if (this.onlyShowOnce)
        return;
      SaveSystem.SaveProgressData<int>(this.saveString, this.current);
    }

    public void CheckIncreaseCount()
    {
      if (this.onlyShowOnce)
        return;
      if (!this.actionDoneThisTurn)
        ++this.current;
      this.actionDoneThisTurn = false;
    }

    public bool Check() => this.current >= this.turnsRequired;

    public void Show(params object[] args)
    {
      this.shown = true;
      PromptSystem.Create(this.promptAnchor, this.promptPosition, this.promptWidth, this.promptEmote);
      PromptSystem.Prompt.SetEmotePosition(Prompt.Emote.Position.Above, forceFlip: (float) this.flipEmote);
      if (args.Length != 0)
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => string.Format(this.stringRef.GetLocalizedString(), args)));
      else
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => this.stringRef.GetLocalizedString()));
      this.current = 0;
    }

    public void Hide()
    {
      this.shown = false;
      PromptSystem.Hide();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: DynamicWaveBellTutorialSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;

public class DynamicWaveBellTutorialSystem : GameSystem
{
  public LocalizedString helpKey;
  public Prompt.Emote.Type emote = Prompt.Emote.Type.Explain;
  public LocalizedString buttonKey;
  public Sprite helpSprite;

  public void OnEnable()
  {
    global::Events.OnWaveDeployerPostCountDown += new UnityAction<int>(this.WaveDeployerCountDown);
    if (!SaveSystem.LoadProgressData<bool>("dynamicWaveBellTutorial", false))
      return;
    this.enabled = false;
  }

  public void OnDisable() => global::Events.OnWaveDeployerPostCountDown -= new UnityAction<int>(this.WaveDeployerCountDown);

  public void WaveDeployerCountDown(int counter)
  {
    if (counter <= 0 || Battle.GetCardsOnBoard(References.Battle.enemy).Count != 0)
      return;
    this.ShowHelp();
  }

  public void ShowHelp()
  {
    HelpPanelSystem.Show(this.helpKey);
    HelpPanelSystem.SetEmote(this.emote);
    HelpPanelSystem.SetImage(2f, 2f, this.helpSprite);
    HelpPanelSystem.SetBackButtonActive(false);
    HelpPanelSystem.AddButton(HelpPanelSystem.ButtonType.Positive, this.buttonKey, "Select", new UnityAction(this.End));
  }

  public void End()
  {
    SaveSystem.SaveProgressData<bool>("dynamicWaveBellTutorial", true);
    this.enabled = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EnableIfSetting
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

public class EnableIfSetting : MonoBehaviour
{
  [SerializeField]
  public string key;
  [SerializeField]
  public EnableIfSetting.Type type;
  [SerializeField]
  [ShowIf("TypeBool")]
  public bool expectedBool = true;
  [SerializeField]
  [ShowIf("TypeBool")]
  public bool defaultBool;
  [SerializeField]
  [ShowIf("TypeString")]
  public string expectedString;
  [SerializeField]
  [ShowIf("TypeString")]
  public string defaultString;
  [SerializeField]
  [ShowIf("TypeInt")]
  public string expectedInt;
  [SerializeField]
  [ShowIf("TypeInt")]
  public string defaultInt;
  [SerializeField]
  [ShowIf("TypeFloatMin")]
  public float minFloat;
  [SerializeField]
  [ShowIf("TypeFloatMax")]
  public float maxFloat;
  [SerializeField]
  [ShowIf("TypeFloat")]
  public float defaultFloat;

  public bool TypeBool => this.type == EnableIfSetting.Type.Bool;

  public bool TypeString => this.type == EnableIfSetting.Type.String;

  public bool TypeInt => this.type == EnableIfSetting.Type.Int;

  public bool TypeFloat
  {
    get
    {
      EnableIfSetting.Type type = this.type;
      return (type == EnableIfSetting.Type.FloatMin ? 0 : (type != EnableIfSetting.Type.FloatMax ? 1 : 0)) == 0;
    }
  }

  public bool TypeFloatMin => this.type == EnableIfSetting.Type.FloatMin;

  public bool TypeFloatMax => this.type == EnableIfSetting.Type.FloatMax;

  public void Awake()
  {
    switch (this.type)
    {
      case EnableIfSetting.Type.Bool:
        this.gameObject.SetActive(Settings.Load<bool>(this.key, this.defaultBool) == this.expectedBool);
        break;
      case EnableIfSetting.Type.String:
        this.gameObject.SetActive(Settings.Load<string>(this.key, this.defaultString) == this.expectedString);
        break;
      case EnableIfSetting.Type.Int:
        this.gameObject.SetActive(Settings.Load<string>(this.key, this.defaultInt) == this.expectedInt);
        break;
      case EnableIfSetting.Type.FloatMin:
        this.gameObject.SetActive((double) Settings.Load<float>(this.key, this.defaultFloat) >= (double) this.minFloat);
        break;
      case EnableIfSetting.Type.FloatMax:
        this.gameObject.SetActive((double) Settings.Load<float>(this.key, this.defaultFloat) <= (double) this.maxFloat);
        break;
    }
  }

  public enum Type
  {
    Bool,
    String,
    Int,
    FloatMin,
    FloatMax,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EndTransition
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using UnityEngine;

public class EndTransition : MonoBehaviour
{
  [SerializeField]
  public bool destroyObject;

  public IEnumerator Start()
  {
    EndTransition endTransition = this;
    yield return (object) new WaitUntil((Func<bool>) (() => SceneManager.HasNoActiveJobs));
    Transition.End();
    if (endTransition.destroyObject)
      UnityEngine.Object.Destroy((UnityEngine.Object) endTransition.gameObject);
    else
      UnityEngine.Object.Destroy((UnityEngine.Object) endTransition);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Entity
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

public class Entity : MonoBehaviourCacheTransform, IPoolable
{
  public bool inPlay = true;
  public CardData _data;
  public EntityDisplay display;
  public int height = 1;
  public bool paused;
  [HorizontalLine(2f, EColor.Gray)]
  public Wobbler wobbler;
  public Flipper flipper;
  public UINavigationItem uINavigationItem;
  public CurveAnimator curveAnimator;
  public CardIdleAnimation imminentAnimation;
  [Required(null)]
  public Transform offset;
  [HorizontalLine(2f, EColor.Gray)]
  [ReadOnly]
  public bool dragging;
  [ReadOnly]
  public int blockRecall;
  [SerializeField]
  [ReadOnly]
  public List<CardContainer> _containers;
  public CardContainer[] _preContainers;
  public bool alive = true;
  public Character owner;
  public SplatterSurface splatterSurface;
  public bool inCardPool;
  public bool returnToPool = true;
  [HorizontalLine(2f, EColor.Gray)]
  public List<CardData.StatusEffectStacks> attackEffects;
  public List<StatusEffectData> statusEffects;
  public Stat damage;
  public SafeInt tempDamage;
  public Stat hp;
  public Stat counter;
  public Stat uses;
  public int effectBonus;
  public float effectFactor = 1f;
  [ReadOnly]
  public Hit lastHit;
  public bool promptUpdate;
  [ReadOnly]
  public Vector3 random3;
  public bool forceKill;
  public TargetMode targetMode;
  public int positionPriority = 1;
  [ReadOnly]
  public bool startingEffectsApplied;
  [HideInInspector]
  public Entity triggeredBy;
  public int cannotBeHitCount;
  public int silenceCount;
  public readonly List<Entity.TraitStacks> traits = new List<Entity.TraitStacks>();
  public Canvas canvas;
  public int traitUpdateRunning;

  public CardData data
  {
    get => this._data;
    set
    {
      this._data = value;
      if (!(bool) (UnityEngine.Object) this._data)
        return;
      if (!this._data.canBeHit)
        ++this.cannotBeHitCount;
      this.targetMode = this._data.targetMode;
    }
  }

  public CardContainer[] containers
  {
    get
    {
      List<CardContainer> containers = this._containers;
      return containers == null ? (CardContainer[]) null : containers.Select<CardContainer, CardContainer>((Func<CardContainer, CardContainer>) (c => c.Group)).ToArray<CardContainer>();
    }
  }

  public List<CardContainer> actualContainers => this._containers;

  public CardContainer[] preContainers
  {
    get
    {
      CardContainer[] preContainers = this._preContainers;
      return preContainers == null ? (CardContainer[]) null : ((IEnumerable<CardContainer>) preContainers).Select<CardContainer, CardContainer>((Func<CardContainer, CardContainer>) (c => c.Group)).ToArray<CardContainer>();
    }
  }

  public CardContainer[] preActualContainers => this._preContainers;

  public void AddTo(CardContainer container) => this._containers.Add(container);

  public void RemoveFrom(CardContainer container) => this._containers.Remove(container);

  public bool NeedsTarget => this.targetMode.NeedsTarget && this.data.needsTarget;

  public bool canBeHit => this.cannotBeHitCount <= 0;

  public bool silenced => this.silenceCount > 0;

  public int DrawOrder
  {
    get
    {
      if (!(bool) (UnityEngine.Object) this.canvas && (bool) (UnityEngine.Object) this.display)
        this.canvas = this.display.GetCanvas();
      return !((UnityEngine.Object) this.canvas != (UnityEngine.Object) null) ? 0 : this.canvas.sortingOrder;
    }
    set
    {
      if (!(bool) (UnityEngine.Object) this.canvas && (bool) (UnityEngine.Object) this.display)
        this.canvas = this.display.GetCanvas();
      if (!(bool) (UnityEngine.Object) this.canvas)
        return;
      this.canvas.overrideSorting = !value.Equals(0);
      if (!this.canvas.overrideSorting)
        return;
      this.canvas.sortingOrder = value;
      Canvas componentInParent = this.GetComponentInParent<Canvas>();
      if (!(bool) (UnityEngine.Object) componentInParent)
        return;
      this.canvas.sortingLayerID = componentInParent.sortingLayerID;
    }
  }

  public List<Entity> GetAllAllies()
  {
    List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(this.owner);
    cardsOnBoard.Remove(this);
    return cardsOnBoard;
  }

  public List<Entity> GetAllies()
  {
    List<Entity> allies = new List<Entity>();
    foreach (CardContainer row in Battle.instance.GetRows(this.owner))
    {
      for (int index = 0; index < row.Count; ++index)
      {
        Entity entity = row[index];
        if ((UnityEngine.Object) entity != (UnityEngine.Object) this)
          allies.Add(entity);
      }
    }
    return allies;
  }

  public List<Entity> GetAlliesInRow()
  {
    List<Entity> alliesInRow = new List<Entity>();
    foreach (CardContainer container in this.containers)
    {
      for (int index = 0; index < container.Count; ++index)
      {
        Entity entity = container[index];
        if ((UnityEngine.Object) entity != (UnityEngine.Object) this)
          alliesInRow.Add(entity);
      }
    }
    return alliesInRow;
  }

  public List<Entity> GetAlliesInRow(int rowIndex)
  {
    List<Entity> alliesInRow = new List<Entity>();
    foreach (Entity entity in References.Battle.GetRow(this.owner, rowIndex))
    {
      if ((UnityEngine.Object) entity != (UnityEngine.Object) this)
        alliesInRow.Add(entity);
    }
    return alliesInRow;
  }

  public List<Entity> GetAllEnemies() => Battle.GetCardsOnBoard(Battle.GetOpponent(this.owner));

  public List<Entity> GetEnemies()
  {
    List<Entity> enemies = new List<Entity>();
    List<CardContainer> cardContainerList = new List<CardContainer>();
    foreach (KeyValuePair<Character, List<CardContainer>> row in Battle.instance.rows)
    {
      if ((UnityEngine.Object) row.Key != (UnityEngine.Object) this.owner)
        cardContainerList.AddRange((IEnumerable<CardContainer>) Battle.instance.GetRows(row.Key));
    }
    foreach (CardContainer cardContainer in cardContainerList)
    {
      foreach (Entity entity in cardContainer)
      {
        if ((UnityEngine.Object) entity != (UnityEngine.Object) this && !enemies.Contains(entity))
          enemies.Add(entity);
      }
    }
    return enemies;
  }

  public List<Entity> GetEnemiesInRow(int rowIndex)
  {
    List<Entity> enemiesInRow = new List<Entity>();
    if (this.containers != null && rowIndex >= 0)
    {
      List<CardContainer> cardContainerList = new List<CardContainer>();
      foreach (KeyValuePair<Character, List<CardContainer>> row in Battle.instance.rows)
      {
        if ((UnityEngine.Object) row.Key != (UnityEngine.Object) this.owner)
          cardContainerList.Add(Battle.instance.GetRow(row.Key, rowIndex));
      }
      foreach (CardContainer cardContainer in cardContainerList)
      {
        foreach (Entity entity in cardContainer)
          enemiesInRow.Add(entity);
      }
    }
    return enemiesInRow;
  }

  public StatusEffectData FindStatus(string type) => this.statusEffects.Find((Predicate<StatusEffectData>) (a => a.type == type));

  public StatusEffectData FindStatus(StatusEffectData dataType) => this.statusEffects.Find((Predicate<StatusEffectData>) (a => a.name == dataType.name));

  public IEnumerator ClearStatuses()
  {
    for (int i = this.statusEffects.Count - 1; i >= 0; --i)
      yield return (object) this.statusEffects[i].Remove();
    this.statusEffects.Clear();
    this.startingEffectsApplied = false;
  }

  public int SnowAmount()
  {
    StatusEffectData status = this.FindStatus("snow");
    return !(bool) (UnityEngine.Object) status ? 0 : status.count;
  }

  public bool IsSnowed => this.SnowAmount() > 0;

  public Vector3 GetScaleFromContainers()
  {
    if (this.containers == null || this.containers.Length == 0)
      return Vector3.one;
    Vector3 zero = Vector3.zero;
    foreach (CardContainer container in this.containers)
      zero += container.GetChildScale(this);
    return zero / (float) this._containers.Count;
  }

  public Vector3 GetPositionFromContainers()
  {
    Vector3 zero = Vector3.zero;
    foreach (CardContainer container in this.containers)
      zero += container.transform.position + container.GetChildPosition(this);
    return zero / (float) this._containers.Count;
  }

  public void RemoveFromContainers()
  {
    LeanTween.cancel(this.gameObject);
    this._preContainers = this.actualContainers.ToArray();
    foreach (CardContainer container in this.containers)
    {
      if ((bool) (UnityEngine.Object) container)
        container.Remove(this);
    }
  }

  public void ResetDrawOrder()
  {
    int a = 0;
    foreach (CardContainer container in this.containers)
      a = Mathf.Max(a, container.GetChildDrawOrder(this));
    this.DrawOrder = a;
  }

  public bool InHand() => (bool) (UnityEngine.Object) this.owner && (bool) (UnityEngine.Object) this.owner.handContainer && this._containers.Count == 1 && (UnityEngine.Object) this.containers[0] == (UnityEngine.Object) this.owner.handContainer;

  public bool InContainer(CardContainer container)
  {
    foreach (UnityEngine.Object actualContainer in this.actualContainers)
    {
      if (actualContainer == (UnityEngine.Object) container)
        return true;
    }
    return false;
  }

  public bool InContainerGroup(CardContainer container)
  {
    foreach (UnityEngine.Object container1 in this.containers)
    {
      if (container1 == (UnityEngine.Object) container)
        return true;
    }
    return false;
  }

  public void Awake() => this.random3 = PettyRandom.Vector3();

  public void Update()
  {
    if (!this.promptUpdate || !this.enabled)
      return;
    this.promptUpdate = false;
    if ((bool) (UnityEngine.Object) this.display)
      CoroutineManager.Start(!this.display.init ? this.display.UpdateData() : this.display.UpdateDisplay());
    if (!this.alive || !this.ReadyToDie())
      return;
    this.forceKill = false;
    CoroutineManager.Start(this.Kill());
  }

  public bool ReadyToDie()
  {
    if (this.forceKill)
      return true;
    return this.hp.current <= 0 && (!(bool) (UnityEngine.Object) this.data || (bool) (UnityEngine.Object) this.data && this.data.cardType.canDie) && !this.statusEffects.Exists((Predicate<StatusEffectData>) (a => a.preventDeath));
  }

  public IEnumerator Reset()
  {
    yield return (object) this.ClearStatuses();
    if (this.display is Card display)
      yield return (object) display.UpdateData(false);
  }

  [Button(null, EButtonEnableMode.Always)]
  public void PromptUpdate() => this.promptUpdate = true;

  public bool CanPlayOn(Entity target, bool ignoreRowCheck = false)
  {
    if (this.data.playOnSlot || !this.NeedsTarget || this.targetMode.TargetRow && !ignoreRowCheck || (UnityEngine.Object) target == (UnityEngine.Object) this || this.damage.current + this.tempDamage.Value > 0 && !target.canBeHit || !this.targetMode.CanTarget(target))
      return false;
    bool flag = this.owner.team == target.owner.team;
    if (!this.data.canPlayOnEnemy && !flag || !this.data.canPlayOnFriendly & flag || !this.data.canPlayOnHand && target.containers.Contains<CardContainer>(this.owner.handContainer) || !this.data.canPlayOnBoard && Battle.IsOnBoard(target))
      return false;
    TargetConstraint[] targetConstraints = this.data.targetConstraints;
    return (targetConstraints == null || targetConstraints.Length <= 0 || !((IEnumerable<TargetConstraint>) this.data.targetConstraints).Any<TargetConstraint>((Func<TargetConstraint, bool>) (c => !c.Check(target)))) && (this.damage.max > 0 || !this.attackEffects.Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (s => !s.data.CanPlayOn(target))));
  }

  public bool CanPlayOn(CardContainer container, bool ignoreRowCheck = false)
  {
    if (!(bool) (UnityEngine.Object) container)
      return false;
    if ((UnityEngine.Object) container == (UnityEngine.Object) this.owner.discardContainer && this.CanRecall())
      return true;
    switch (this.data.playType)
    {
      case Card.PlayType.Play:
        if (!this.NeedsTarget || !container.canPlayOn)
          return false;
        if (this.targetMode.TargetRow && !ignoreRowCheck)
        {
          if (container is CardSlotLane && this.data.canPlayOnBoard && (!this.data.playOnSlot || container.Count < container.max))
          {
            if (!this.data.playOnSlot)
            {
              Entity[] targets = this.targetMode.GetTargets(this, (Entity) null, container);
              if (targets == null || targets.Length <= 0)
                return false;
            }
            return !((UnityEngine.Object) container.owner == (UnityEngine.Object) this.owner) ? this.data.canPlayOnEnemy : this.data.canPlayOnFriendly;
          }
        }
        else if (this.data.playOnSlot && container is CardSlot && this.data.canPlayOnBoard && container.Group is CardSlotLane group1)
        {
          if (!container.Empty)
          {
            if (this.owner.team != container.owner.team)
              return false;
            int count = group1.Count;
            int max = group1.max;
            if (this.data.canShoveToOtherRow)
            {
              foreach (CardContainer cardContainer in group1.shoveTo)
              {
                count += cardContainer.Count;
                max += cardContainer.max;
              }
            }
            if (count >= max)
              return false;
          }
          return !((UnityEngine.Object) group1.owner == (UnityEngine.Object) this.owner) ? this.data.canPlayOnEnemy : this.data.canPlayOnFriendly;
        }
        return false;
      case Card.PlayType.Place:
        if (!(container is CardSlot cardSlot) || !container.canBePlacedOn || !((UnityEngine.Object) container.owner == (UnityEngine.Object) this.owner))
          return false;
        switch (this.positionPriority)
        {
          case -1:
          case 2:
            return cardSlot.Group is CardSlotLane group2 && group2.slots.IndexOf(cardSlot) == (this.positionPriority == -1 ? group2.slots.Count - 1 : 0);
          default:
            return true;
        }
      default:
        return false;
    }
  }

  public IEnumerator Kill(DeathType deathType = DeathType.Normal)
  {
    Entity entity = this;
    if (entity.alive)
    {
      entity.alive = false;
      if ((bool) (UnityEngine.Object) entity.display && (bool) (UnityEngine.Object) entity.display.hover)
        entity.display.hover.Disable();
      LeanTween.cancel(entity.gameObject);
      Routine.Clump clump = new Routine.Clump();
      clump.Add(StatusEffectSystem.EntityDestroyedEvent(entity, deathType));
      yield return (object) null;
      entity.RemoveFromContainers();
      entity.transform.SetParent((Transform) null);
      Events.InvokeEntityKilled(entity, deathType);
      yield return (object) clump.WaitForEnd();
      clump = (Routine.Clump) null;
    }
  }

  public void OnDisable() => Events.InvokeEntityDisabled(this);

  public void OnDestroy()
  {
    Events.InvokeEntityDisabled(this);
    Events.InvokeEntityDestroyed(this);
    if (this.statusEffects.Count <= 0)
      return;
    Debug.Log((object) string.Format("[{0}] Destroyed! Removing [{1}] status effects...", (object) this, (object) this.statusEffects.Count));
    foreach (StatusEffectData statusEffectData in this.statusEffects.Where<StatusEffectData>((Func<StatusEffectData, bool>) (status => (bool) (UnityEngine.Object) status)))
      statusEffectData.Destroy();
    this.statusEffects.Clear();
  }

  public Entity.TraitStacks GainTrait(TraitData traitData, int count, bool temporary = false)
  {
    Entity.TraitStacks traitStacks1 = this.traits.FirstOrDefault<Entity.TraitStacks>((Func<Entity.TraitStacks, bool>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) traitData));
    if (traitStacks1 != null)
    {
      traitStacks1.count += count;
      if (temporary)
        traitStacks1.tempCount += count;
      this.traits.Remove(traitStacks1);
      this.traits.Add(traitStacks1);
      return traitStacks1;
    }
    Entity.TraitStacks traitStacks2 = new Entity.TraitStacks(traitData, count, temporary);
    this.traits.Add(traitStacks2);
    return traitStacks2;
  }

  public IEnumerator UpdateTraits(Entity.TraitStacks moveToFront = null)
  {
    Entity entity = this;
    if (entity.traitUpdateRunning > 0)
    {
      yield return (object) new WaitUntil(new Func<bool>(entity.\u003CUpdateTraits\u003Eb__95_0));
      if (!entity.IsAliveAndExists())
        yield break;
    }
    ++entity.traitUpdateRunning;
    if (moveToFront != null)
    {
      entity.traits.Remove(moveToFront);
      entity.traits.Insert(0, moveToFront);
    }
    int i;
    for (i = entity.traits.Count - 1; i >= 0; --i)
    {
      Entity.TraitStacks trait = entity.traits[i];
      if (trait.count <= 0)
      {
        Debug.Log((object) ("> [" + entity.name + " " + trait.data.name + "] Removed! Removing effects [" + string.Join<StatusEffectData>(", ", (IEnumerable<StatusEffectData>) trait.passiveEffects) + "]"));
        entity.traits.RemoveAt(i);
        yield return (object) trait.DisableEffects();
      }
    }
    foreach (Entity.TraitStacks trait in entity.traits)
      trait.silenceCount = 0;
    for (int index1 = entity.traits.Count - 1; index1 >= 0; --index1)
    {
      Entity.TraitStacks trait1 = entity.traits[index1];
      TraitData[] overrides = trait1.data.overrides;
      if (overrides != null && overrides.Length > 0)
      {
        for (int index2 = index1 - 1; index2 >= 0; --index2)
        {
          Entity.TraitStacks trait2 = entity.traits[index2];
          if (trait1.data.overrides.Contains<TraitData>(trait2.data))
            ++trait2.silenceCount;
        }
      }
    }
    foreach (Entity.TraitStacks traitStacks in entity.traits.Where<Entity.TraitStacks>((Func<Entity.TraitStacks, bool>) (a => a.MustDisable)))
    {
      Debug.Log((object) ("> [" + entity.name + " " + traitStacks.data.name + "] Silenced! Removing effects [" + string.Join<StatusEffectData>(", ", (IEnumerable<StatusEffectData>) traitStacks.passiveEffects) + "]"));
      yield return (object) traitStacks.DisableEffects();
    }
    Entity.TraitStacks t;
    foreach (Entity.TraitStacks traitStacks in entity.traits.Where<Entity.TraitStacks>((Func<Entity.TraitStacks, bool>) (a => a.ReadyToInit || a.MustEnable)))
    {
      t = traitStacks;
      yield return (object) t.EnableEffects(entity);
      Debug.Log((object) ("> [" + entity.name + " " + t.data.name + "] Enabled! Adding effects [" + string.Join<StatusEffectData>(", ", (IEnumerable<StatusEffectData>) t.passiveEffects) + "]"));
      t = (Entity.TraitStacks) null;
    }
    foreach (Entity.TraitStacks traitStacks in entity.traits.Where<Entity.TraitStacks>((Func<Entity.TraitStacks, bool>) (a => a.StacksRemoved)))
    {
      t = traitStacks;
      i = t.init - t.count;
      yield return (object) t.RemoveEffectStacks(entity, i);
      Debug.Log((object) string.Format("> [{0} {1}] Removing {2} Stacks of effects [{3}]", (object) entity.name, (object) t.data.name, (object) i, (object) string.Join<StatusEffectData>(", ", (IEnumerable<StatusEffectData>) t.passiveEffects)));
      t = (Entity.TraitStacks) null;
    }
    --entity.traitUpdateRunning;
  }

  public void OnGetFromPool()
  {
    this.inCardPool = false;
    this.wobbler.OnGetFromPool();
    this.flipper.OnGetFromPool();
    this.curveAnimator.OnGetFromPool();
    this.splatterSurface.OnGetFromPool();
    this.offset.localScale = Vector3.one;
    this.offset.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
    this._preContainers = (CardContainer[]) null;
  }

  public void OnReturnToPool()
  {
    this.inCardPool = true;
    Events.InvokeEntityDisabled(this);
    Events.InvokeEntityDestroyed(this);
    if (this.statusEffects.Count > 0)
    {
      Debug.Log((object) string.Format("[{0}] Destroyed! Removing [{1}] status effects...", (object) this, (object) this.statusEffects.Count));
      foreach (StatusEffectData statusEffect in this.statusEffects)
      {
        if ((bool) (UnityEngine.Object) statusEffect)
          statusEffect.Destroy();
      }
      this.statusEffects.Clear();
    }
    if (this.GetComponent<IRemoveWhenPooled>() is MonoBehaviour component)
      UnityEngine.Object.Destroy((UnityEngine.Object) component);
    this.enabled = false;
    this.dragging = false;
    this.blockRecall = 0;
    this.alive = true;
    this.attackEffects.Clear();
    this.statusEffects.Clear();
    this.traits.Clear();
    this.effectBonus = 0;
    this.effectFactor = 1f;
    this.tempDamage.Value = 0;
    this.forceKill = false;
    this.startingEffectsApplied = false;
    this.cannotBeHitCount = 0;
    this.silenceCount = 0;
    this._containers.Clear();
    this.lastHit = (Hit) null;
    this.wobbler.OnReturnToPool();
    this.flipper.OnReturnToPool();
    this.curveAnimator.OnReturnToPool();
    this.splatterSurface.OnReturnToPool();
    this.positionPriority = 1;
    this.promptUpdate = false;
    this.triggeredBy = (Entity) null;
    this.uINavigationItem.enabled = true;
    LeanTween.cancel(this.gameObject);
  }

  [CompilerGenerated]
  public bool \u003CUpdateTraits\u003Eb__95_0() => this.traitUpdateRunning <= 0;

  [Serializable]
  public class TraitStacks
  {
    public TraitData data;
    public int count;
    public int silenceCount;
    public int tempCount;
    public int init;
    public bool effectsDisabled;
    public readonly List<StatusEffectData> passiveEffects = new List<StatusEffectData>();

    public bool silenced => this.silenceCount > 0;

    public bool ReadyToInit => this.init < this.count && !this.silenced;

    public bool MustDisable => this.init == this.count && this.silenced && !this.effectsDisabled;

    public bool MustEnable => this.init == this.count && !this.silenced && this.effectsDisabled;

    public bool StacksRemoved => this.count < this.init;

    public TraitStacks(TraitData data, int count, bool temporary = false)
    {
      this.data = data;
      this.count = count;
      if (!temporary)
        return;
      this.tempCount = count;
    }

    public IEnumerator DisableEffects()
    {
      foreach (StatusEffectData passiveEffect in this.passiveEffects)
        yield return (object) passiveEffect.Remove();
      this.passiveEffects.Clear();
      this.effectsDisabled = true;
      this.init = 0;
    }

    public IEnumerator EnableEffects(Entity entity)
    {
      int stacks = this.count - this.init;
      yield return (object) this.AddEffectStacks(entity, stacks);
    }

    public IEnumerator AddEffectStacks(Entity entity, int stacks)
    {
      Entity.TraitStacks traitStacks = this;
      StatusEffectData[] statusEffectDataArray = traitStacks.data.effects;
      for (int index = 0; index < statusEffectDataArray.Length; ++index)
        yield return (object) StatusEffectSystem.Apply(entity, (Entity) null, statusEffectDataArray[index], stacks, true, new Action<StatusEffectData>(traitStacks.\u003CAddEffectStacks\u003Eb__20_0));
      statusEffectDataArray = (StatusEffectData[]) null;
      traitStacks.effectsDisabled = false;
      traitStacks.init += stacks;
    }

    public IEnumerator RemoveEffectStacks(Entity entity, int removeStacks)
    {
      StatusEffectData[] statusEffectDataArray = this.data.effects;
      for (int index = 0; index < statusEffectDataArray.Length; ++index)
      {
        StatusEffectData status = entity.FindStatus(statusEffectDataArray[index]);
        if ((bool) (UnityEngine.Object) status)
          yield return (object) status.RemoveStacks(removeStacks, true);
      }
      statusEffectDataArray = (StatusEffectData[]) null;
      this.init -= removeStacks;
    }

    [CompilerGenerated]
    public void \u003CAddEffectStacks\u003Eb__20_0(StatusEffectData a) => this.passiveEffects.Add(a);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EntityDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public abstract class EntityDisplay : MonoBehaviourCacheTransform, IPoolable
{
  public Entity entity;
  public CardHover hover;
  [BoxGroup("Icon Groups")]
  public RectTransform healthLayoutGroup;
  [BoxGroup("Icon Groups")]
  public RectTransform damageLayoutGroup;
  [BoxGroup("Icon Groups")]
  public RectTransform counterLayoutGroup;
  [BoxGroup("Icon Groups")]
  public RectTransform crownLayoutGroup;
  public Dictionary<string, RectTransform> iconGroups;
  public StatusIcon healthIcon;
  public StatusIcon damageIcon;
  public StatusIcon counterIcon;
  public StatusIcon reactionIcon;
  [ReadOnly]
  public bool init;
  public bool promptUpdateDescription;

  public virtual void Awake()
  {
    this.iconGroups = new Dictionary<string, RectTransform>();
    if ((UnityEngine.Object) this.healthLayoutGroup != (UnityEngine.Object) null)
      this.iconGroups["health"] = this.healthLayoutGroup;
    if ((UnityEngine.Object) this.damageLayoutGroup != (UnityEngine.Object) null)
      this.iconGroups["damage"] = this.damageLayoutGroup;
    if ((UnityEngine.Object) this.counterLayoutGroup != (UnityEngine.Object) null)
      this.iconGroups["counter"] = this.counterLayoutGroup;
    if (!((UnityEngine.Object) this.crownLayoutGroup != (UnityEngine.Object) null))
      return;
    this.iconGroups["crown"] = this.crownLayoutGroup;
  }

  public virtual void Reset() => this.init = false;

  public virtual IEnumerator UpdateData(bool doPing = false)
  {
    yield return (object) this.UpdateDisplay(doPing);
    this.init = true;
    Events.InvokeEntityDataUpdated(this.entity);
  }

  public virtual IEnumerator UpdateDisplay(bool doPing = true)
  {
    if ((bool) (UnityEngine.Object) this.healthLayoutGroup)
    {
      if (!(bool) (UnityEngine.Object) this.healthIcon)
      {
        if (this.entity.hp.max > 0 || this.entity.hp.current > 0 || (bool) (UnityEngine.Object) this.entity.data && this.entity.data.hasHealth)
          this.healthIcon = this.SetStatusIcon("health", "health", this.entity.hp, doPing);
      }
      else
        EntityDisplay.UpdateStatusIcon(this.healthIcon, this.entity.hp, doPing);
    }
    if ((bool) (UnityEngine.Object) this.damageLayoutGroup)
    {
      if (!(bool) (UnityEngine.Object) this.damageIcon)
      {
        if (this.entity.damage.max > 0 || this.entity.damage.current + this.entity.tempDamage > 0 || (bool) (UnityEngine.Object) this.entity.data && this.entity.data.hasAttack)
          this.damageIcon = this.SetStatusIcon("damage", "damage", this.entity.damage + this.entity.tempDamage, doPing);
      }
      else
        EntityDisplay.UpdateStatusIcon(this.damageIcon, this.entity.damage + this.entity.tempDamage, doPing);
    }
    if ((bool) (UnityEngine.Object) this.counterLayoutGroup)
    {
      if (!(bool) (UnityEngine.Object) this.counterIcon)
      {
        if (this.entity.counter.max > 0)
          this.counterIcon = this.SetStatusIcon("counter", "counter", this.entity.counter, doPing);
      }
      else
        EntityDisplay.UpdateStatusIcon(this.counterIcon, this.entity.counter, doPing);
      if (!(bool) (UnityEngine.Object) this.reactionIcon)
      {
        if (this.entity.statusEffects.Any<StatusEffectData>((Func<StatusEffectData, bool>) (a => a.isReaction)))
          this.reactionIcon = this.SetStatusIcon("reaction", "counter", Stat.Default, doPing);
      }
      else
        EntityDisplay.UpdateStatusIcon(this.reactionIcon, Stat.Default, doPing);
    }
    foreach (StatusEffectData statusEffect in this.entity.statusEffects)
    {
      if (statusEffect.visible && !statusEffect.iconGroupName.IsNullOrEmpty())
        this.SetStatusIcon(statusEffect.type, statusEffect.iconGroupName, new Stat(statusEffect.count, 0), doPing);
    }
    foreach (KeyValuePair<string, RectTransform> iconGroup in this.iconGroups)
    {
      foreach (Component component1 in (Transform) iconGroup.Value)
      {
        StatusIcon component2 = component1.GetComponent<StatusIcon>();
        if ((bool) (UnityEngine.Object) component2)
          component2.CheckRemove();
      }
    }
    Events.InvokeEntityDisplayUpdated(this.entity);
    yield return (object) null;
  }

  public virtual Canvas GetCanvas() => (Canvas) null;

  public StatusIcon FindStatusIcon(string type)
  {
    StatusIcon statusIcon = (StatusIcon) null;
    foreach (KeyValuePair<string, RectTransform> iconGroup in this.iconGroups)
    {
      foreach (Component component1 in (Transform) iconGroup.Value)
      {
        StatusIcon component2 = component1.GetComponent<StatusIcon>();
        if ((bool) (UnityEngine.Object) component2 && component2.type == type)
        {
          statusIcon = component2;
          break;
        }
      }
      if ((bool) (UnityEngine.Object) statusIcon)
        break;
    }
    return statusIcon;
  }

  public StatusIcon SetStatusIcon(string type, string iconGroupName, Stat value, bool doPing = true)
  {
    StatusIcon icon = this.FindStatusIcon(type);
    if ((bool) (UnityEngine.Object) icon)
    {
      EntityDisplay.UpdateStatusIcon(icon, value, doPing);
    }
    else
    {
      icon = CardManager.NewStatusIcon(type, (Transform) this.iconGroups[iconGroupName]);
      if (!(bool) (UnityEngine.Object) icon)
      {
        Debug.LogError((object) ("Status Icon for [" + type + "] NOT FOUND!"));
      }
      else
      {
        if ((bool) (UnityEngine.Object) this.hover)
        {
          CardHover component = icon.GetComponent<CardHover>();
          component.master = this.hover;
          component.enabled = true;
        }
        icon.Assign(this.entity);
        icon.SetValue(value, doPing);
        if (doPing)
        {
          icon.CreateEvent();
          Events.InvokeStatusIconCreated(icon);
        }
      }
    }
    return icon;
  }

  public static void UpdateStatusIcon(StatusIcon icon, Stat value, bool doPing = true) => icon.SetValue(value, doPing);

  public void RemoveStatusIcon(string type, string iconGroupName)
  {
    StatusIcon statusIcon = this.FindStatusIcon(type);
    if (!((UnityEngine.Object) statusIcon != (UnityEngine.Object) null))
      return;
    statusIcon.Destroy();
  }

  public void ClearStatusIcons()
  {
    foreach (KeyValuePair<string, RectTransform> iconGroup in this.iconGroups)
      iconGroup.Value.DestroyAllChildren();
  }

  public virtual void OnGetFromPool()
  {
    this.init = false;
    this.promptUpdateDescription = false;
  }

  public virtual void OnReturnToPool() => this.ClearStatusIcons();
}
﻿// Decompiled with JetBrains decompiler
// Type: EntityExt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Linq;
using UnityEngine;
using UnityEngine.EventSystems;

public static class EntityExt
{
  public static Vector3 GetContainerWorldPosition(this Entity entity)
  {
    Vector3 zero = Vector3.zero;
    if (entity.actualContainers.Count > 0)
    {
      foreach (CardContainer actualContainer in entity.actualContainers)
        zero += actualContainer.holder.position + actualContainer.GetChildPosition(entity);
      zero /= (float) entity.actualContainers.Count;
    }
    return zero;
  }

  public static Vector3 GetContainerLocalPosition(this Entity entity)
  {
    Vector3 containerLocalPosition = Vector3.zero;
    if (entity.actualContainers.Count > 0)
    {
      Vector3 zero = Vector3.zero;
      foreach (CardContainer actualContainer in entity.actualContainers)
        zero += actualContainer.holder.position + actualContainer.GetChildPosition(entity);
      containerLocalPosition = zero / (float) entity.actualContainers.Count - entity.actualContainers[0].holder.position;
    }
    return containerLocalPosition;
  }

  public static Vector3 GetContainerWorldRotation(this Entity entity)
  {
    Vector3 containerWorldRotation = Vector3.zero;
    if (entity.actualContainers.Count > 0)
    {
      foreach (CardContainer actualContainer in entity.actualContainers)
        containerWorldRotation += actualContainer.GetChildRotation(entity);
      containerWorldRotation = containerWorldRotation / (float) entity.actualContainers.Count + entity.actualContainers[0].holder.eulerAngles;
    }
    return containerWorldRotation;
  }

  public static Vector3 GetContainerLocalRotation(this Entity entity)
  {
    Vector3 zero = Vector3.zero;
    if (entity.actualContainers.Count > 0)
    {
      foreach (CardContainer actualContainer in entity.actualContainers)
        zero += actualContainer.GetChildRotation(entity);
      zero /= (float) entity.actualContainers.Count;
    }
    return zero;
  }

  public static Vector3 GetContainerScale(this Entity entity)
  {
    Vector3 zero = Vector3.zero;
    if (entity.actualContainers.Count > 0)
    {
      foreach (CardContainer actualContainer in entity.actualContainers)
        zero += actualContainer.GetChildScale(entity);
      zero /= (float) entity.actualContainers.Count;
    }
    return zero;
  }

  public static void TweenToContainer(this Entity entity)
  {
    int count = entity.actualContainers.Count;
    if (count <= 0)
      return;
    CardContainer actualContainer1 = entity.actualContainers[0];
    if (count > 1)
    {
      Vector3 zero1 = Vector3.zero;
      Vector3 zero2 = Vector3.zero;
      Vector3 zero3 = Vector3.zero;
      foreach (CardContainer actualContainer2 in entity.actualContainers)
      {
        zero1 += actualContainer2.GetChildScale(entity);
        zero2 += actualContainer2.GetChildRotation(entity);
        zero3 += actualContainer2.holder.position + actualContainer2.GetChildPosition(entity);
      }
      Vector3 to1 = zero1 / (float) count;
      Vector3 to2 = zero2 / (float) count;
      Vector3 position = zero3 / (float) count;
      Vector3 to3 = actualContainer1.holder.InverseTransformPoint(position) * -1f;
      LeanTween.cancel(entity.gameObject);
      LeanTween.scale(entity.gameObject, to1, actualContainer1.scaleDurRand.PettyRandom()).setEase(actualContainer1.scaleEase);
      LeanTween.rotateLocal(entity.gameObject, to2, actualContainer1.movementDurRand.PettyRandom()).setEase(actualContainer1.movementEase);
      LeanTween.moveLocal(entity.gameObject, to3, actualContainer1.movementDurRand.PettyRandom()).setEase(actualContainer1.movementEase);
    }
    else
    {
      Vector3 childScale = actualContainer1.GetChildScale(entity);
      Vector3 childRotation = actualContainer1.GetChildRotation(entity);
      Vector3 childPosition = actualContainer1.GetChildPosition(entity);
      LeanTween.cancel(entity.gameObject);
      LeanTween.scale(entity.gameObject, childScale, actualContainer1.scaleDurRand.PettyRandom()).setEase(actualContainer1.scaleEase);
      LeanTween.rotateLocal(entity.gameObject, childRotation, actualContainer1.movementDurRand.PettyRandom()).setEase(actualContainer1.movementEase);
      LeanTween.moveLocal(entity.gameObject, childPosition, actualContainer1.movementDurRand.PettyRandom()).setEase(actualContainer1.movementEase);
    }
  }

  public static void ForceUnHover(this Entity entity)
  {
    EntityDisplay display = entity.display;
    if (!(display is Card))
      return;
    CardHover hover = display.hover;
    if (hover == null)
      return;
    hover.OnPointerExit((PointerEventData) null);
    hover.ForceUnHover();
  }

  public static bool IsOffensive(this Entity entity)
  {
    bool flag = entity.data.hasAttack || entity.damage.max > 0 || entity.damage.current + entity.tempDamage.Value > 0 || entity.data.original.damage > 0;
    if (!flag && entity.attackEffects.Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (s => s.data.offensive)))
      flag = true;
    if (!flag && entity.statusEffects.Any<StatusEffectData>((Func<StatusEffectData, bool>) (s => s.makesOffensive)))
      flag = true;
    return flag;
  }

  public static bool CanRecall(this Entity entity) => entity.data.cardType.canRecall && entity.blockRecall <= 0 && (bool) (UnityEngine.Object) References.Battle && Battle.IsOnBoard(entity);

  public static bool StillExists(this Entity entity) => (bool) (UnityEngine.Object) entity && !entity.inCardPool;

  public static bool IsAliveAndExists(this Entity entity) => (bool) (UnityEngine.Object) entity && !entity.inCardPool && entity.alive;

  public static bool HasAnyCharms(this Entity entity) => entity.data.upgrades != null && entity.data.upgrades.Any<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => a.type == CardUpgradeData.Type.Charm));
}
﻿// Decompiled with JetBrains decompiler
// Type: EnumContainerExample
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using BetaJester.EnumGenerator;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class EnumContainerExample : MonoBehaviour, IEnumContainer
{
  public List<ObjectInfo> objectInfos = new List<ObjectInfo>();

  public BetaJester.EnumGenerator.EnumInfo[] GetEnums() => new BetaJester.EnumGenerator.EnumInfo[1]
  {
    new BetaJester.EnumGenerator.EnumInfo()
    {
      _name = "ObjectType",
      _values = this.objectInfos.Select<ObjectInfo, string>((Func<ObjectInfo, string>) (x => x.objectName)).ToArray<string>()
    }
  };
}
﻿// Decompiled with JetBrains decompiler
// Type: BetaJester.EnumGenerator.EnumCreator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;

namespace BetaJester.EnumGenerator
{
  public class EnumCreator : MonoBehaviour
  {
    public bool isPerScene = true;
    public static char whiteSpaceReplacement = '_';
    public string namespaceName = "ExampleTeam";
    [Tooltip("Must start with Assets/")]
    public string filePathOverride = "Assets/";
    public EnumInfo[] enumInfo;
    public GameObject[] enumContainers;
    public List<EnumCreator.EnumValRef> createdValues = new List<EnumCreator.EnumValRef>();

    public static T StringToEnum<T>(string value, T defaultValue) where T : struct, IConvertible
    {
      if (!typeof (T).IsEnum)
        throw new ArgumentException("T must be an enumerated type");
      if (string.IsNullOrEmpty(value))
        return defaultValue;
      string str = value.Replace(' ', EnumCreator.whiteSpaceReplacement);
      foreach (T obj in Enum.GetValues(typeof (T)))
      {
        if (obj.ToString().ToLower().Equals(str.Trim().ToLower()))
          return obj;
      }
      return defaultValue;
    }

    public static string EnumToString<T>(T value) => Enum.GetName(typeof (T), (object) value).Replace(EnumCreator.whiteSpaceReplacement, ' ');

    [Serializable]
    public struct EnumValRef
    {
      public string enumName;
      public string enumVal;
      public int enumIntVal;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BetaJester.EnumGenerator.EnumInfo
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

namespace BetaJester.EnumGenerator
{
  [Serializable]
  public struct EnumInfo
  {
    public string _name;
    public string[] _values;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ErrorHandlerSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using NaughtyAttributes;
using System;
using System.IO;
using TMPro;
using UnityEngine;

public class ErrorHandlerSystem : GameSystem
{
  [SerializeField]
  public bool displayErrors = true;
  [SerializeField]
  [ShowIf("displayErrors")]
  public GameObject errorDisplay;
  [SerializeField]
  [ShowIf("displayErrors")]
  public TMP_InputField errorText;
  [SerializeField]
  [ShowIf("displayErrors")]
  public bool freezeTimeScale = true;
  [SerializeField]
  [ShowIf("displayErrors")]
  public EventReference sfxEvent;
  [SerializeField]
  public bool showPersistentMessage = true;
  [SerializeField]
  [ShowIf("showPersistentMessage")]
  public GameObject persistentMessage;
  public const string format = "\n\n[{0}] {1}\n{2}";
  public float timeScalePre = 1f;
  public static int errorCount;

  public static string path => Application.persistentDataPath + "/Errors.log";

  public void OnEnable() => Application.logMessageReceived += new Application.LogCallback(this.HandleLog);

  public void OnDisable() => Application.logMessageReceived -= new Application.LogCallback(this.HandleLog);

  public void HandleLog(string log, string stacktrace, LogType type)
  {
    if (type != LogType.Exception)
      return;
    ++ErrorHandlerSystem.errorCount;
    using (StreamWriter streamWriter = new StreamWriter(ErrorHandlerSystem.path, true))
      streamWriter.WriteLine("\n\n[{0}] {1}\n{2}", (object) DateTime.Now, (object) log, (object) stacktrace);
    if (this.displayErrors)
    {
      this.ShowError(log + "\n" + stacktrace);
    }
    else
    {
      if (!this.showPersistentMessage)
        return;
      this.ShowPersistentMessage();
    }
  }

  public void ShowError(string text)
  {
    this.errorDisplay.SetActive(true);
    this.errorText.text = text;
    if (this.freezeTimeScale)
    {
      this.timeScalePre = Time.timeScale;
      Time.timeScale = 0.0f;
    }
    SfxSystem.OneShot(this.sfxEvent.Guid);
  }

  public void HideError()
  {
    this.errorDisplay.SetActive(false);
    Time.timeScale = this.timeScalePre;
    if (!this.showPersistentMessage || ErrorHandlerSystem.errorCount <= 0)
      return;
    this.ShowPersistentMessage();
  }

  public void ExitGame() => GameManager.Quit();

  public void ShowPersistentMessage() => this.persistentMessage.SetActive(true);

  public void HidePersistentMessage() => this.persistentMessage.SetActive(false);
}
﻿// Decompiled with JetBrains decompiler
// Type: EventManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class EventManager : MonoBehaviour
{
  public static EventManager instance;
  public Transform eventRoutineHolder;
  [SerializeField]
  public TweenUI enterTween;

  public void Awake() => EventManager.instance = this;

  public static Transform EventRoutineHolder => EventManager.instance.eventRoutineHolder;

  public void OnEnable()
  {
    if (!GameManager.Ready)
      return;
    CinemaBarSystem.InInstant();
    this.enterTween.Fire();
  }

  public void OnDisable() => CinemaBarSystem.OutInstant();
}
﻿// Decompiled with JetBrains decompiler
// Type: EventRoutine
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EventRoutine : SceneRoutine
{
  public Character _player;
  public CampaignNode node;

  public Character player => this._player ?? (this._player = References.Player);

  public Dictionary<string, object> data => this.node.data;

  public virtual IEnumerator Populate() => (IEnumerator) null;

  public void CheckAddUpgrades(int cardIndex, CardData cardDataClone)
  {
    string key = string.Format("upgrades{0}", (object) cardIndex);
    if (!this.node.data.ContainsKey(key))
      return;
    foreach (string save in this.node.data.GetSaveCollection<string>(key))
    {
      CardUpgradeData cardUpgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", save);
      if ((bool) (Object) cardUpgradeData)
        cardUpgradeData.Clone().Assign(cardDataClone);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EventRoutineCharm
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Localization;

public class EventRoutineCharm : EventRoutine
{
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public OpenCharmBlockSequence openSequence;
  [SerializeField]
  public Transform charmBlock;
  [SerializeField]
  public LocalizedString takeKey;
  [SerializeField]
  public SfxLoop loop;
  public bool routineActive;

  public void Open(BaseEventData eventData)
  {
    if (eventData is PointerEventData pointerEventData && pointerEventData.button != PointerEventData.InputButton.Left || this.data.Get<bool>("open") || this.routineActive)
      return;
    this.StartCoroutine(this.OpenRoutine());
  }

  public IEnumerator OpenRoutine()
  {
    EventRoutineCharm eventRoutineCharm = this;
    eventRoutineCharm.node.cleared = true;
    DeckpackBlocker.Block();
    CinemaBarSystem.Clear();
    Events.InvokeScreenShake(0.25f);
    Events.InvokeScreenRumble(0.0f, 0.25f, 0.0f, 0.05f, 0.2f, 0.3f);
    SfxSystem.OneShot("event:/sfx/location/charm/rumble");
    eventRoutineCharm.data["open"] = (object) true;
    eventRoutineCharm.routineActive = true;
    yield return (object) Sequences.Wait(0.1f);
    eventRoutineCharm.animator.SetTrigger("OpenMouth");
    yield return (object) Sequences.Wait(0.35f);
    eventRoutineCharm.animator.SetTrigger("DropCharm");
    SfxSystem.OneShot("event:/sfx/location/charm/drop");
    yield return (object) Sequences.Wait(1f);
    eventRoutineCharm.animator.SetBool("Zoom", true);
    eventRoutineCharm.routineActive = false;
  }

  public override IEnumerator Populate()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    EventRoutineCharm eventRoutineCharm = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    eventRoutineCharm.animator.SetBool("OpenMouth", eventRoutineCharm.data.Get<bool>("open"));
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) null;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override IEnumerator Run()
  {
    EventRoutineCharm eventRoutineCharm = this;
    CinemaBarSystem.Top.SetPrompt(eventRoutineCharm.takeKey.GetLocalizedString(), "Select");
    eventRoutineCharm.loop.Play();
    yield return (object) new WaitUntil(new Func<bool>(eventRoutineCharm.\u003CRun\u003Eb__9_0));
    yield return (object) Sequences.Wait(0.15f);
    CardUpgradeData charmData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", eventRoutineCharm.data.Get<string>("charm")).Clone();
    eventRoutineCharm.openSequence.SetCharm(charmData, eventRoutineCharm.charmBlock);
    eventRoutineCharm.openSequence.SetCharacter(eventRoutineCharm.player);
    eventRoutineCharm.charmBlock.gameObject.SetActive(false);
    yield return (object) eventRoutineCharm.openSequence.Run();
    DeckpackBlocker.Unblock();
    eventRoutineCharm.loop.Stop();
    CinemaBarSystem.Clear();
  }

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__9_0() => this.data.Get<bool>("open") && !this.routineActive;
}
﻿// Decompiled with JetBrains decompiler
// Type: EventRoutineCharmShop
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class EventRoutineCharmShop : EventRoutine
{
  [SerializeField]
  public ShopPriceManager priceManager;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardContainer cardContainer;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public CardCharmHolder[] holders;
  [SerializeField]
  public GainCharmSequence gainCharmSequence;
  [SerializeField]
  public Talker talker;
  public const float speechBubDelay = 1f;
  public float speechBubTimer;
  public ShopItem currentHover;
  public readonly List<ShopItem> items = new List<ShopItem>();
  public bool promptEnd;

  public void PromptEnd() => this.promptEnd = true;

  public void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
  }

  public void EntityHover(Entity entity)
  {
    ShopItem component = entity.GetComponent<ShopItem>();
    if (component == null)
      return;
    this.Hover(component);
  }

  public void EntityUnHover(Entity entity)
  {
    ShopItem component = entity.GetComponent<ShopItem>();
    if (component == null)
      return;
    this.UnHover(component);
  }

  public void Update()
  {
    if ((double) this.speechBubTimer <= 0.0)
      return;
    this.speechBubTimer -= Time.deltaTime;
  }

  public override IEnumerator Populate()
  {
    EventRoutineCharmShop routineCharmShop = this;
    EventRoutineCharmShop.Data shopData = routineCharmShop.data.Get<EventRoutineCharmShop.Data>("data");
    routineCharmShop.cardContainer.SetSize(shopData.cards.Count, 0.8f);
    foreach (EventRoutineCharmShop.UpgradedCard card1 in shopData.cards)
    {
      CardData cardData = AddressableLoader.Get<CardData>("CardData", card1.cardDataName).Clone();
      if (card1.upgradeNames != null)
      {
        foreach (string upgradeName in card1.upgradeNames)
        {
          CardUpgradeData cardUpgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", upgradeName);
          if ((bool) (UnityEngine.Object) cardUpgradeData)
            cardUpgradeData.Clone().Assign(cardData);
        }
      }
      Card card2 = CardManager.Get(cardData, routineCharmShop.cardController, routineCharmShop.player, false, true);
      routineCharmShop.cardContainer.Add(card2.entity);
      ShopItem target = card2.entity.gameObject.AddComponent<ShopItem>();
      routineCharmShop.priceManager.Add(target, ShopPrice.Position.Bottom).SetPrice(card1.price, card1.priceFactor);
      yield return (object) card2.UpdateData(false);
    }
    routineCharmShop.cardContainer.SetChildPositions();
    foreach (EventRoutineCharmShop.CharmShopItemData charmShopItemData in shopData.items)
    {
      CardUpgradeData upgradeDataClone = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", charmShopItemData.upgradeDataName).Clone();
      routineCharmShop.CreateUpgrade(upgradeDataClone, charmShopItemData.price, charmShopItemData.priceFactor);
    }
    foreach (EventRoutineCharmShop.UpgradedCard card3 in shopData.cards)
    {
      EventRoutineCharmShop.UpgradedCard card = card3;
      if (card.purchased)
      {
        Entity entity = routineCharmShop.cardContainer.First<Entity>((Func<Entity, bool>) (a => a.data.name == card.cardDataName));
        if ((bool) (UnityEngine.Object) entity)
        {
          routineCharmShop.priceManager.Remove(entity.GetComponent<ShopItem>());
          entity.RemoveFromContainers();
          CardManager.ReturnToPool(entity);
        }
      }
    }
    for (int index = 0; index < routineCharmShop.items.Count; ++index)
    {
      if (shopData.items[index].purchased)
        routineCharmShop.items[index].gameObject.Destroy();
    }
  }

  public override IEnumerator Run()
  {
    EventRoutineCharmShop routineCharmShop = this;
    int num = routineCharmShop.data.Get<int>("enterCount", 0) + 1;
    routineCharmShop.data["enterCount"] = (object) num;
    if (num == 1)
    {
      routineCharmShop.talker.Say("greet", PettyRandom.Range(0.5f, 1f));
      foreach (Entity entity in routineCharmShop.cardContainer)
        global::Events.InvokeEntityOffered(entity);
    }
    routineCharmShop.cardController.owner = routineCharmShop.player;
    routineCharmShop.cardContainer.owner = routineCharmShop.player;
    routineCharmShop.cardSelector.character = routineCharmShop.player;
    while (!routineCharmShop.promptEnd)
      yield return (object) null;
    if (routineCharmShop.data.Get<EventRoutineCharmShop.Data>("data").items.Count<EventRoutineCharmShop.CharmShopItemData>((Func<EventRoutineCharmShop.CharmShopItemData, bool>) (i => !i.purchased)) <= 0)
      routineCharmShop.node.SetCleared();
    routineCharmShop.cardController.enabled = false;
    routineCharmShop.cardSelector.enabled = false;
    foreach (ShopItem shopItem in routineCharmShop.items)
    {
      if ((bool) (UnityEngine.Object) shopItem)
      {
        CardCharmInteraction component = shopItem.GetComponent<CardCharmInteraction>();
        if (component != null)
        {
          component.canHover = false;
          component.canDrag = false;
        }
      }
    }
    if (routineCharmShop.player.entity.display is CharacterDisplay display && (bool) (UnityEngine.Object) display.goldDisplay)
      display.goldDisplay.HideChange();
  }

  public void Bub(string speechType, params object[] inserts)
  {
    if ((double) this.speechBubTimer > 0.0)
      return;
    this.talker.Say(speechType, 0.0f, inserts);
    this.speechBubTimer = 1f;
  }

  public void TryBuy(Entity entity)
  {
    ShopItem component = entity.GetComponent<ShopItem>();
    if (component == null)
      return;
    int price = component.GetPrice();
    if (this.player.data.inventory.gold.Value - price >= 0)
    {
      SfxSystem.OneShot("event:/sfx/location/shop/buying");
      this.priceManager.Remove(component);
      this.player.SpendGold(price);
      this.cardSelector.TakeCard(entity);
      this.data.Get<EventRoutineCharmShop.Data>("data").cards.Find((Predicate<EventRoutineCharmShop.UpgradedCard>) (a => a.cardDataName == entity.data.name)).purchased = true;
      global::Events.InvokeShopItemPurchase(component);
      this.talker.Say("thanks", 0.0f);
    }
    else
      this.Bub("no");
  }

  public void TryBuy(ShopItem item)
  {
    int price = item.GetPrice();
    if (this.player.data.inventory.gold.Value - price >= 0)
    {
      int index = this.items.IndexOf(item);
      SfxSystem.OneShot("event:/sfx/location/shop/buying");
      this.player.SpendGold(price);
      this.priceManager.Remove(item);
      UpgradeDisplay componentInChildren = this.holders[index].GetComponentInChildren<UpgradeDisplay>();
      if (componentInChildren == null)
        return;
      componentInChildren.gameObject.Destroy();
      this.data.Get<EventRoutineCharmShop.Data>("data").items[index].purchased = true;
      this.gainCharmSequence.SetCharm(componentInChildren.data);
      this.gainCharmSequence.SetCharacter(this.player);
      this.StartCoroutine(this.gainCharmSequence.Run());
      global::Events.InvokeShopItemPurchase(item);
      this.talker.Say("thanks", 0.0f);
    }
    else
      this.Bub("no");
  }

  public void Hover(ShopItem item)
  {
    if ((bool) (UnityEngine.Object) this.currentHover)
      this.UnHover(this.currentHover);
    this.currentHover = item;
    if (this.player.entity.display is CharacterDisplay display && (bool) (UnityEngine.Object) display.goldDisplay && (bool) (UnityEngine.Object) this.priceManager.Get(item))
    {
      int price = item.GetPrice();
      if (price <= this.player.data.inventory.gold)
        display.goldDisplay.ShowChange(-price);
    }
    global::Events.InvokeShopItemHover(item);
  }

  public void UnHover(ShopItem item)
  {
    if (!((UnityEngine.Object) this.currentHover == (UnityEngine.Object) item))
      return;
    this.currentHover = (ShopItem) null;
    if (this.player.entity.display is CharacterDisplay display && (bool) (UnityEngine.Object) display.goldDisplay)
      display.goldDisplay.HideChange();
    global::Events.InvokeShopItemUnHover(item);
  }

  public void CreateUpgrade(CardUpgradeData upgradeDataClone, int price, float priceFactor)
  {
    CardCharmHolder cardCharmHolder = ((IEnumerable<CardCharmHolder>) this.holders).FirstOrDefault<CardCharmHolder>((Func<CardCharmHolder, bool>) (a => a.transform.childCount == 0));
    if (!(bool) (UnityEngine.Object) cardCharmHolder)
      return;
    UpgradeDisplay upgradeDisplay = cardCharmHolder.Create(upgradeDataClone);
    ShopItem shopItem = upgradeDisplay.gameObject.AddComponent<ShopItem>();
    this.items.Add(shopItem);
    ShopPrice shopPrice = this.priceManager.Add(shopItem, ShopPrice.Position.Bottom);
    shopPrice.SetPrice(price, priceFactor);
    shopPrice.SetOffset(new Vector3(0.0f, -1.5f, 0.0f));
    shopPrice.scaleWithTarget = 0.0f;
    shopPrice.scaleOffsetWithTarget = 0.0f;
    CardCharmInteraction component = upgradeDisplay.GetComponent<CardCharmInteraction>();
    component.popUpOffset = new Vector2(1f, -0.25f);
    component.onHover.AddListener((UnityAction<UpgradeDisplay>) (_ => this.Hover(shopItem)));
    component.onUnHover.AddListener((UnityAction<UpgradeDisplay>) (_ => this.UnHover(shopItem)));
    component.onDrag.AddListener((UnityAction<UpgradeDisplay>) (_ => this.TryBuy(shopItem)));
  }

  [Serializable]
  public class Data
  {
    public List<EventRoutineCharmShop.UpgradedCard> cards;
    public List<EventRoutineCharmShop.CharmShopItemData> items;
  }

  [Serializable]
  public class UpgradedCard
  {
    public string cardDataName;
    public string[] upgradeNames;
    public int price;
    public float priceFactor;
    public bool purchased;
  }

  [Serializable]
  public class CharmShopItemData
  {
    public string upgradeDataName;
    public int price;
    public float priceFactor;
    public bool purchased;

    public CharmShopItemData()
    {
    }

    public CharmShopItemData(string upgradeDataName, int price, float priceFactor = 1f)
    {
      this.upgradeDataName = upgradeDataName;
      this.price = Mathf.RoundToInt((float) price * priceFactor);
      this.priceFactor = priceFactor;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EventRoutineClunkShop
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class EventRoutineClunkShop : EventRoutine
{
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public ShopPriceManager priceManager;
  [SerializeField]
  public CardContainer[] cardContainers;
  [SerializeField]
  public CardCharmHolder[] charmHolders;
  [SerializeField]
  public GainCharmSequence gainCharmSequence;
  public ShopItem currentHover;
  public bool promptEnd;

  public void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
  }

  public void EntityHover(Entity entity)
  {
    ShopItem component = entity.GetComponent<ShopItem>();
    if (component == null)
      return;
    this.Hover(component);
  }

  public void EntityUnHover(Entity entity)
  {
    ShopItem component = entity.GetComponent<ShopItem>();
    if (component == null)
      return;
    this.UnHover(component);
  }

  public override IEnumerator Run()
  {
    EventRoutineClunkShop routineClunkShop = this;
    routineClunkShop.cardController.owner = routineClunkShop.player;
    routineClunkShop.cardSelector.character = routineClunkShop.player;
    routineClunkShop.cardController.enabled = true;
    routineClunkShop.cardSelector.enabled = true;
    while (!routineClunkShop.promptEnd)
      yield return (object) null;
    routineClunkShop.promptEnd = false;
    routineClunkShop.cardController.enabled = false;
    routineClunkShop.cardSelector.enabled = false;
  }

  public override IEnumerator Populate()
  {
    EventRoutineClunkShop routineClunkShop1 = this;
    CinemaBarSystem.Clear();
    routineClunkShop1.UnPopulate();
    EventRoutineClunkShop.Data shopData = routineClunkShop1.data.Get<EventRoutineClunkShop.Data>("shopData");
    int cardCount = shopData.cards.Count;
    for (int i = 0; i < cardCount; ++i)
    {
      EventRoutineClunkShop.CardItem item = shopData.cards[i];
      if (!item.purchased)
      {
        CardContainer container = routineClunkShop1.cardContainers.Length > i ? routineClunkShop1.cardContainers[i] : (CardContainer) null;
        if ((bool) (UnityEngine.Object) container)
        {
          container.SetSize(1, 0.67f);
          Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", item.dataName).Clone(), routineClunkShop1.cardController, routineClunkShop1.player, false, true);
          yield return (object) card.UpdateData(false);
          container.Add(card.entity);
          container.SetChildPositions();
          ShopItem target = card.gameObject.AddComponent<ShopItem>();
          routineClunkShop1.priceManager.Add(target, ShopPrice.Position.Bottom).SetPrice(item.price, item.priceFactor);
          container = (CardContainer) null;
          card = (Card) null;
        }
        else
          break;
      }
      item = (EventRoutineClunkShop.CardItem) null;
    }
    int count = shopData.charms.Count;
    for (int index = 0; index < count; ++index)
    {
      EventRoutineClunkShop.CharmItem charm1 = shopData.charms[index];
      if (!charm1.purchased)
      {
        EventRoutineClunkShop routineClunkShop = routineClunkShop1;
        CardCharmHolder charmHolder = routineClunkShop1.charmHolders.Length > index ? routineClunkShop1.charmHolders[index] : (CardCharmHolder) null;
        if ((UnityEngine.Object) charmHolder == (UnityEngine.Object) null)
          break;
        CardUpgradeData upgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", charm1.dataName).Clone();
        UpgradeDisplay charm = charmHolder.Create(upgradeData);
        charmHolder.SetPositions();
        ShopItem shopItem = charm.gameObject.AddComponent<ShopItem>();
        CardCharmInteraction orAdd = charm.gameObject.GetOrAdd<CardCharmInteraction>();
        orAdd.canHover = true;
        orAdd.canDrag = true;
        orAdd.onHover.AddListener((UnityAction<UpgradeDisplay>) (a => routineClunkShop.Hover(shopItem)));
        orAdd.onUnHover.AddListener((UnityAction<UpgradeDisplay>) (a => routineClunkShop.UnHover(shopItem)));
        orAdd.onDrag.AddListener((UnityAction<UpgradeDisplay>) (a => routineClunkShop.TryBuyCharm(charm as CardCharm)));
        orAdd.popUpOffset = new Vector2(0.8f, -0.3f);
        routineClunkShop1.priceManager.Add(shopItem, ShopPrice.Position.Top).SetPrice(charm1.price, charm1.priceFactor);
      }
    }
  }

  public void UnPopulate()
  {
    foreach (CardContainer cardContainer in this.cardContainers)
    {
      cardContainer.DestroyAll();
      cardContainer.Clear();
    }
    foreach (UpgradeHolder charmHolder in this.charmHolders)
      charmHolder.Clear();
    this.priceManager.Clear();
  }

  public bool TryBuy(ShopItem item)
  {
    bool flag = false;
    int price = item.GetPrice();
    if (this.player.data.inventory.gold >= price)
    {
      SfxSystem.OneShot("event:/sfx/location/shop/buying");
      this.priceManager.Remove(item);
      this.player.SpendGold(price);
      global::Events.InvokeShopItemPurchase(item);
      flag = true;
    }
    return flag;
  }

  public void TryBuy(Entity entity)
  {
    ShopItem component = entity.GetComponent<ShopItem>();
    if (component == null || !this.TryBuy(component))
      return;
    this.data.Get<EventRoutineClunkShop.Data>("shopData").cards.Find((Predicate<EventRoutineClunkShop.CardItem>) (a => a.dataName == entity.data.name)).purchased = true;
    this.cardSelector.TakeCard(entity);
  }

  public void TryBuyCharm(CardCharm charm)
  {
    ShopItem component = charm.GetComponent<ShopItem>();
    if (component == null || !this.TryBuy(component))
      return;
    this.data.Get<EventRoutineClunkShop.Data>("shopData").charms.Find((Predicate<EventRoutineClunkShop.CharmItem>) (a => a.dataName == charm.data.name)).purchased = true;
    this.gainCharmSequence.SetCharacter(this.player);
    this.gainCharmSequence.SetCharm(charm.data);
    this.gainCharmSequence.Begin();
    charm.gameObject.Destroy();
  }

  public void Hover(ShopItem item)
  {
    if (this.player.entity.display is CharacterDisplay display && (UnityEngine.Object) display.goldDisplay != (UnityEngine.Object) null && (UnityEngine.Object) this.priceManager.Get(item) != (UnityEngine.Object) null)
    {
      int price = item.GetPrice();
      if (price <= this.player.data.inventory.gold)
      {
        this.currentHover = item;
        display.goldDisplay.ShowChange(-price);
      }
    }
    global::Events.InvokeShopItemHover(item);
  }

  public void UnHover(ShopItem item)
  {
    if (!((UnityEngine.Object) this.currentHover == (UnityEngine.Object) item))
      return;
    if (this.player.entity.display is CharacterDisplay display && (UnityEngine.Object) display.goldDisplay != (UnityEngine.Object) null)
      display.goldDisplay.HideChange();
    this.currentHover = (ShopItem) null;
    global::Events.InvokeShopItemUnHover(item);
  }

  public void End()
  {
    this.promptEnd = true;
    this.cardController.enabled = false;
  }

  [Serializable]
  public class Data
  {
    public List<EventRoutineClunkShop.CardItem> cards = new List<EventRoutineClunkShop.CardItem>();
    public List<EventRoutineClunkShop.CharmItem> charms = new List<EventRoutineClunkShop.CharmItem>();
  }

  [Serializable]
  public abstract class Item
  {
    public int price;
    public float priceFactor = 1f;
    public bool purchased;
  }

  [Serializable]
  public class CardItem : EventRoutineClunkShop.Item
  {
    public string dataName;

    public CardItem()
    {
    }

    public CardItem(CardData cardData, float priceFactor = 1f)
    {
      this.dataName = cardData.name;
      this.price = Mathf.RoundToInt((float) cardData.value * priceFactor);
    }
  }

  [Serializable]
  public class CharmItem : EventRoutineClunkShop.Item
  {
    public string dataName;

    public CharmItem()
    {
    }

    public CharmItem(string upgradeDataName, int price, float priceFactor = 1f)
    {
      this.dataName = upgradeDataName;
      this.price = price;
      price = Mathf.RoundToInt((float) price * priceFactor);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EventRoutineCompanion
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Localization;

public class EventRoutineCompanion : EventRoutine, IRerollable
{
  [SerializeField]
  public ChooseNewCardSequence sequence;
  [SerializeField]
  public InspectNewUnitSequence inspectSequence;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public CardContainer cardContainer;
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public ParticleSystem chunkParticles;
  [SerializeField]
  public ParticleSystem chunkBigParticles;
  [SerializeField]
  public ParticleSystem breakFx;
  [SerializeField]
  public LocalizedString breakKey;
  [SerializeField]
  public LocalizedString chooseKey;
  [SerializeField]
  public SfxLoop loop1;
  [SerializeField]
  public SfxLoop loop2;
  public bool analyticsEventSent;

  public bool broken => this.data.Get<int>("damage") > 3;

  public void Hit(BaseEventData eventData)
  {
    if (eventData is PointerEventData pointerEventData && pointerEventData.button != PointerEventData.InputButton.Left || this.broken)
      return;
    this.data["damage"] = (object) (this.data.Get<int>("damage") + 1);
    this.UpdateAnimator();
    this.TakeHit();
  }

  public void UpdateAnimator()
  {
    this.animator.SetInteger("Damage", this.data.Get<int>("damage"));
    this.animator.SetBool("Broken", this.broken);
  }

  public void TakeHit()
  {
    this.animator.SetTrigger("Hit");
    if (this.broken)
    {
      Events.InvokeScreenShake(5f);
      if ((UnityEngine.Object) this.chunkParticles != (UnityEngine.Object) null)
        this.chunkParticles.Play();
      if ((UnityEngine.Object) this.chunkBigParticles != (UnityEngine.Object) null)
        this.chunkBigParticles.Play();
      if ((UnityEngine.Object) this.breakFx != (UnityEngine.Object) null)
        this.breakFx.Play();
      ScreenFlashSystem.SetDrawOrder("Transition", 0);
      ScreenFlashSystem.SetColour(Color.white.WithAlpha(0.45f));
      ScreenFlashSystem.Run(0.175f);
      CinemaBarSystem.Top.SetPrompt(this.chooseKey.GetLocalizedString(), "Select");
      SfxSystem.OneShot("event:/sfx/location/travelers/break");
    }
    else
    {
      Events.InvokeScreenShake();
      if ((UnityEngine.Object) this.chunkParticles != (UnityEngine.Object) null)
        this.chunkParticles.Play();
      SfxSystem.OneShot("event:/sfx/location/travelers/hit");
    }
  }

  public override IEnumerator Populate()
  {
    EventRoutineCompanion routineCompanion = this;
    string[] saveCollection = routineCompanion.data.GetSaveCollection<string>("cards");
    routineCompanion.cardContainer.SetSize(saveCollection.Length, 0.8f);
    Routine.Clump clump = new Routine.Clump();
    for (int cardIndex = 0; cardIndex < saveCollection.Length; ++cardIndex)
    {
      CardData cardData = AddressableLoader.Get<CardData>("CardData", saveCollection[cardIndex]).Clone();
      routineCompanion.CheckAddUpgrades(cardIndex, cardData);
      Card card = CardManager.Get(cardData, routineCompanion.cardController, routineCompanion.player, false, true);
      if (!routineCompanion.cardContainer.gameObject.activeInHierarchy)
        card.entity.flipper.FlipDownInstant();
      routineCompanion.cardContainer.Add(card.entity);
      clump.Add(card.UpdateData(false));
    }
    yield return (object) clump.WaitForEnd();
    foreach (Entity child in routineCompanion.cardContainer)
    {
      Transform transform = child.transform;
      transform.localPosition = routineCompanion.cardContainer.GetChildPosition(child);
      transform.localScale = routineCompanion.cardContainer.GetChildScale(child);
      transform.localEulerAngles = routineCompanion.cardContainer.GetChildRotation(child);
    }
    routineCompanion.UpdateAnimator();
    if (routineCompanion.broken)
      CinemaBarSystem.Clear();
    else
      CinemaBarSystem.Top.SetPrompt(routineCompanion.breakKey.GetLocalizedString(), "Select");
  }

  public override IEnumerator Run()
  {
    EventRoutineCompanion routineCompanion = this;
    routineCompanion.cardController.owner = routineCompanion.player;
    routineCompanion.cardSelector.character = routineCompanion.player;
    routineCompanion.loop1.Play();
    bool loop2Started = false;
    while (!routineCompanion.broken)
    {
      if (!loop2Started && routineCompanion.data.Get<int>("damage") > 2)
      {
        routineCompanion.loop2.Play();
        loop2Started = true;
      }
      yield return (object) null;
    }
    routineCompanion.loop1.Stop();
    routineCompanion.loop2.Stop();
    if (!routineCompanion.analyticsEventSent)
    {
      foreach (Entity entity in routineCompanion.cardContainer)
        Events.InvokeEntityOffered(entity);
      routineCompanion.analyticsEventSent = true;
    }
    yield return (object) Sequences.Wait(0.3f);
    yield return (object) routineCompanion.sequence.Run();
    CinemaBarSystem.Clear();
    routineCompanion.node.SetCleared();
  }

  public void TrySelect(Entity entity)
  {
    ActionSelect action = new ActionSelect(entity, (Action<Entity>) (e =>
    {
      this.inspectSequence.SetUnit(entity);
      this.inspectSequence.Begin();
      this.cardController.enabled = false;
      this.cardController.UnHover(entity);
    }));
    if (!Events.CheckAction((PlayAction) action))
      return;
    ActionQueue.Add((PlayAction) action);
  }

  public void TrySkip()
  {
    ActionSelect action = new ActionSelect((Entity) null, (Action<Entity>) (e => this.sequence.Skip()));
    if (!Events.CheckAction((PlayAction) action))
      return;
    ActionQueue.Add((PlayAction) action);
  }

  public void CardSelected(Entity entity)
  {
    this.sequence.End();
    this.cardController.enabled = false;
    Events.InvokeEntityChosen(entity);
  }

  public bool Reroll()
  {
    if (!this.cardContainer.gameObject.activeInHierarchy || !this.cardSelector.enabled || InspectSystem.IsActive())
      return false;
    InspectNewUnitSequence objectOfType = UnityEngine.Object.FindObjectOfType<InspectNewUnitSequence>();
    if (objectOfType != null && objectOfType.gameObject.activeSelf)
      return false;
    this.data["cards"] = (object) ((IList<CardData>) this.cardController.owner.GetComponent<CharacterRewards>().Pull<CardData>((object) this.node, "Units", this.data.GetSaveCollection<string>("cards").Length)).ToSaveCollectionOfNames<CardData>();
    foreach (Entity entity in this.cardContainer)
      CardManager.ReturnToPool(entity);
    this.cardContainer.Clear();
    this.StartCoroutine(this.Populate());
    CardPopUp.Clear();
    return true;
  }

  [CompilerGenerated]
  public void \u003CTrySkip\u003Eb__22_0(Entity e) => this.sequence.Skip();
}
﻿// Decompiled with JetBrains decompiler
// Type: EventRoutineCopyItem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.UI;

public class EventRoutineCopyItem : EventRoutine
{
  public CardContainer cardContainer;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public CardType[] canCopyCardTypes;
  [SerializeField]
  public LocalizedString promptKey;
  [SerializeField]
  public LocalizedString confirmPromptKey;
  [SerializeField]
  public TweenUI moveToSide;
  [SerializeField]
  public TweenUI moveToCentre;
  [SerializeField]
  public Transform toCopyAnchor;
  [SerializeField]
  public Talker talker;
  public Button backButton;
  public bool cardsCreated;
  public bool promptOpenGrid;
  public bool promptCloseGrid;
  public bool promptCopy;
  public Entity toCopy;
  public int toCopyOriginalIndex;
  public Entity copyEntity;
  public bool promptEnd;
  public bool gridOpen;

  public override IEnumerator Run()
  {
    EventRoutineCopyItem eventRoutineCopyItem = this;
    int num = eventRoutineCopyItem.data.Get<int>("enterCount") + 1;
    eventRoutineCopyItem.data["enterCount"] = (object) num;
    eventRoutineCopyItem.cardController.owner = eventRoutineCopyItem.player;
    eventRoutineCopyItem.cardSelector.character = eventRoutineCopyItem.player;
    eventRoutineCopyItem.cardContainer.owner = eventRoutineCopyItem.player;
    CinemaBarSystem.Top.SetPrompt(eventRoutineCopyItem.promptKey.GetLocalizedString(), "Select");
    eventRoutineCopyItem.promptOpenGrid = true;
    while (!eventRoutineCopyItem.promptEnd || eventRoutineCopyItem.promptCopy)
    {
      if (eventRoutineCopyItem.promptOpenGrid)
      {
        eventRoutineCopyItem.promptOpenGrid = false;
        if (!eventRoutineCopyItem.gridOpen)
          yield return (object) eventRoutineCopyItem.OpenGrid();
      }
      else if (eventRoutineCopyItem.promptCloseGrid)
      {
        eventRoutineCopyItem.promptCloseGrid = false;
        if (eventRoutineCopyItem.gridOpen)
          yield return (object) eventRoutineCopyItem.CloseGrid();
      }
      else if (eventRoutineCopyItem.promptCopy)
      {
        yield return (object) eventRoutineCopyItem.CopyRoutine();
        eventRoutineCopyItem.promptCopy = false;
      }
      yield return (object) null;
    }
    CinemaBarSystem.Clear();
    if (eventRoutineCopyItem.data.Get<int>("canCopy") <= 0)
      eventRoutineCopyItem.node.SetCleared();
  }

  public IEnumerator OpenGrid()
  {
    this.gridOpen = true;
    this.cardController.Enable();
    if (!this.cardsCreated)
    {
      this.cardsCreated = true;
      Routine.Clump clump = new Routine.Clump();
      clump.Add(this.CreateCards());
      clump.Add(Sequences.Wait(0.2f));
      yield return (object) clump.WaitForEnd();
    }
    this.cardContainer.gameObject.SetActive(true);
    this.cardContainer.transform.localScale = Vector3.one * 0.5f;
    LeanTween.scale(this.cardContainer.gameObject, Vector3.one, 1.25f).setEase(LeanTweenType.easeOutElastic);
  }

  public IEnumerator CreateCards()
  {
    EventRoutineCopyItem eventRoutineCopyItem = this;
    Routine.Clump clump = new Routine.Clump();
    List<CardData> cardDataList = new List<CardData>();
    foreach (CardData cardData in eventRoutineCopyItem.player.data.inventory.deck)
    {
      if (eventRoutineCopyItem.canCopyCardTypes.Contains<CardType>(cardData.cardType))
        cardDataList.Add(cardData);
    }
    foreach (CardData cardData in eventRoutineCopyItem.player.data.inventory.reserve)
    {
      if (eventRoutineCopyItem.canCopyCardTypes.Contains<CardType>(cardData.cardType))
        cardDataList.Add(cardData);
    }
    foreach (CardData data in cardDataList)
    {
      Card card = CardManager.Get(data, eventRoutineCopyItem.cardController, eventRoutineCopyItem.player, false, true);
      eventRoutineCopyItem.cardContainer.Add(card.entity);
      clump.Add(card.UpdateData(false));
    }
    yield return (object) clump.WaitForEnd();
    eventRoutineCopyItem.cardContainer.SetChildPositions();
  }

  public IEnumerator CloseGrid()
  {
    // ISSUE: reference to a compiler-generated field
    int num1 = this.\u003C\u003E1__state;
    EventRoutineCopyItem eventRoutineCopyItem = this;
    if (num1 != 0)
    {
      if (num1 != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    eventRoutineCopyItem.gridOpen = false;
    float num2 = 0.3f;
    LeanTween.scale(eventRoutineCopyItem.cardContainer.gameObject, Vector3.zero, num2).setEase(LeanTweenType.easeInBack).setOnComplete(new System.Action(eventRoutineCopyItem.\u003CCloseGrid\u003Eb__23_0));
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) new WaitForSeconds(num2);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public void Copy(Entity entity)
  {
    if ((UnityEngine.Object) this.toCopy == (UnityEngine.Object) entity)
    {
      this.promptCopy = true;
      this.copyEntity = entity;
      this.End();
    }
    else
    {
      if ((bool) (UnityEngine.Object) this.toCopy)
        return;
      this.moveToCentre.Fire();
      this.toCopy = entity;
      this.toCopyOriginalIndex = this.cardContainer.IndexOf(entity);
      this.cardContainer.Remove(entity);
      entity.transform.SetParent(this.toCopyAnchor);
      LeanTween.moveLocal(entity.gameObject, Vector3.zero, 0.33f).setEaseOutQuart();
      this.promptCloseGrid = true;
      CinemaBarSystem.Top.SetPrompt(this.confirmPromptKey.GetLocalizedString(), "Select");
    }
  }

  public IEnumerator CopyRoutine()
  {
    EventRoutineCopyItem eventRoutineCopyItem = this;
    eventRoutineCopyItem.backButton.interactable = false;
    int num = eventRoutineCopyItem.data.Get<int>("canCopy") - 1;
    eventRoutineCopyItem.data["canCopy"] = (object) num;
    if (num <= 0)
      eventRoutineCopyItem.PromptCloseGrid();
    CardData data = eventRoutineCopyItem.copyEntity.data.Clone(false);
    data.upgrades.RemoveAll((Predicate<CardUpgradeData>) (a => a.type == CardUpgradeData.Type.Crown));
    Card card = CardManager.Get(data, eventRoutineCopyItem.cardController, eventRoutineCopyItem.player, false, true);
    yield return (object) card.UpdateData(false);
    card.transform.position = eventRoutineCopyItem.copyEntity.transform.position;
    eventRoutineCopyItem.cardSelector.TakeCard(card.entity);
    eventRoutineCopyItem.promptCloseGrid = true;
    yield return (object) new WaitForSeconds(0.5f);
  }

  public void Back()
  {
    if ((bool) (UnityEngine.Object) this.toCopy)
    {
      this.promptOpenGrid = true;
      this.cardContainer.Insert(this.toCopyOriginalIndex, this.toCopy);
      this.toCopy = (Entity) null;
      this.cardContainer.SetChildPositions();
      this.moveToSide.Fire();
      CinemaBarSystem.Top.SetPrompt(this.promptKey.GetLocalizedString(), "Select");
    }
    else
      this.End();
  }

  public void PromptCloseGrid() => this.promptCloseGrid = true;

  public void End()
  {
    this.promptEnd = true;
    this.backButton.interactable = false;
    this.cardController.Disable();
  }

  [CompilerGenerated]
  public void \u003CCloseGrid\u003Eb__23_0() => this.cardContainer.gameObject.SetActive(false);
}
﻿// Decompiled with JetBrains decompiler
// Type: EventRoutineCurseItems
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using FMODUnity;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Localization;

public class EventRoutineCurseItems : EventRoutine
{
  [SerializeField]
  public ChooseNewCardSequence sequence;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public CardContainer cardContainer;
  [SerializeField]
  public Transform curseCardContainer;
  [SerializeField]
  public LocalizedString chooseKey;
  [SerializeField]
  public float cardScale = 0.8f;
  [SerializeField]
  public GameObject backButton;
  [SerializeField]
  public Talker talker;
  [SerializeField]
  public EventReference takeSfxEvent;
  public bool analyticsEventSent;
  public readonly List<Entity> cards = new List<Entity>();
  public readonly List<Entity> curses = new List<Entity>();

  public override IEnumerator Populate()
  {
    EventRoutineCurseItems routineCurseItems = this;
    Routine.Clump clump = new Routine.Clump();
    string[] saveCollection = routineCurseItems.data.GetSaveCollection<string>("cards");
    routineCurseItems.cardContainer.SetSize(saveCollection.Length, routineCurseItems.cardScale);
    for (int cardIndex = 0; cardIndex < saveCollection.Length; ++cardIndex)
    {
      CardData cardData = AddressableLoader.Get<CardData>("CardData", saveCollection[cardIndex]).Clone();
      routineCurseItems.CheckAddUpgrades(cardIndex, cardData);
      Card card = CardManager.Get(cardData, routineCurseItems.cardController, routineCurseItems.player, false, true);
      routineCurseItems.cards.Add(card.entity);
      card.entity.flipper.FlipDownInstant();
      routineCurseItems.cardContainer.Add(card.entity);
      clump.Add(card.UpdateData(false));
    }
    foreach (string save in routineCurseItems.data.GetSaveCollection<string>("curses"))
    {
      if (save != null)
      {
        Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", save).Clone(), routineCurseItems.cardController, routineCurseItems.player, false, true);
        card.entity.uINavigationItem.enabled = false;
        routineCurseItems.curses.Add(card.entity);
        card.transform.SetParent(routineCurseItems.curseCardContainer);
        clump.Add(card.UpdateData(false));
        card.entity.flipper.FlipDownInstant();
      }
      else
        routineCurseItems.curses.Add((Entity) null);
    }
    yield return (object) clump.WaitForEnd();
    for (int index = 0; index < routineCurseItems.cardContainer.Count; ++index)
    {
      Entity child = routineCurseItems.cardContainer[index];
      Transform transform1 = child.transform;
      transform1.localPosition = routineCurseItems.cardContainer.GetChildPosition(child);
      transform1.localScale = routineCurseItems.cardContainer.GetChildScale(child);
      transform1.localEulerAngles = routineCurseItems.cardContainer.GetChildRotation(child);
      Entity curse = routineCurseItems.curses[index];
      if ((bool) (UnityEngine.Object) curse)
      {
        Transform transform2 = curse.transform;
        transform2.position = transform1.position;
        transform2.localScale = Vector3.one * 0.85f;
        transform2.localEulerAngles = new Vector3(0.0f, 0.0f, -UnityEngine.Random.Range(5f, 10f));
      }
    }
  }

  public override IEnumerator Run()
  {
    EventRoutineCurseItems routineCurseItems = this;
    int num = routineCurseItems.data.Get<int>("enterCount", 0) + 1;
    routineCurseItems.data["enterCount"] = (object) num;
    if (num == 1)
      routineCurseItems.talker.Say("greet", PettyRandom.Range(0.5f, 1f));
    routineCurseItems.sequence.owner = routineCurseItems.player;
    routineCurseItems.cardController.owner = routineCurseItems.player;
    routineCurseItems.cardSelector.character = routineCurseItems.player;
    CinemaBarSystem.Top.SetScript(routineCurseItems.chooseKey.GetLocalizedString());
    if (!routineCurseItems.data.Get<bool>("analyticsEventSent", false))
    {
      foreach (Entity entity in routineCurseItems.cardContainer)
        Events.InvokeEntityOffered(entity);
      routineCurseItems.data["analyticsEventSent"] = (object) true;
    }
    yield return (object) routineCurseItems.sequence.Run();
    CinemaBarSystem.Clear();
    if (routineCurseItems.data.Get<SaveCollection<string>>("cards").Count <= 0)
      routineCurseItems.node.SetCleared();
  }

  public void TrySelect(Entity entity)
  {
    ActionSelect action = new ActionSelect(entity, (Action<Entity>) (e => this.StartCoroutine(this.TakeCard(entity))));
    if (!Events.CheckAction((PlayAction) action))
      return;
    ActionQueue.Add((PlayAction) action);
  }

  public IEnumerator TakeCard(Entity entity)
  {
    EventRoutineCurseItems routineCurseItems = this;
    SfxSystem.OneShot(routineCurseItems.takeSfxEvent);
    routineCurseItems.cardController.Disable();
    routineCurseItems.backButton.SetActive(false);
    int index = routineCurseItems.cards.IndexOf(entity);
    Transform transform1 = entity.transform;
    Entity curse = routineCurseItems.curses[index];
    if ((bool) (UnityEngine.Object) curse)
    {
      Transform transform2 = curse.transform;
      transform2.position = transform1.position;
      transform2.localScale = Vector3.one * routineCurseItems.cardScale;
      transform2.localRotation = Quaternion.identity;
      curse.gameObject.SetActive(true);
      curse.flipper.FlipDownInstant();
    }
    routineCurseItems.cards.RemoveAt(index);
    SaveCollection<string> saveCollection1 = routineCurseItems.data.Get<SaveCollection<string>>("cards");
    saveCollection1.Remove(index);
    routineCurseItems.data["cards"] = (object) saveCollection1;
    routineCurseItems.curses.RemoveAt(index);
    SaveCollection<string> saveCollection2 = routineCurseItems.data.Get<SaveCollection<string>>("curses");
    saveCollection2.Remove(index);
    routineCurseItems.data["curses"] = (object) saveCollection2;
    routineCurseItems.cardSelector.TakeCard(entity);
    Events.InvokeEntityChosen(entity);
    routineCurseItems.talker.Say("thanks", 0.0f, (object) entity.data.title);
    if ((bool) (UnityEngine.Object) curse)
    {
      yield return (object) new WaitForSeconds(0.5f);
      curse.flipper.FlipUp();
      yield return (object) new WaitForSeconds(0.5f);
      routineCurseItems.cardSelector.TakeCard(curse);
      Events.InvokeEntityChosen(curse);
    }
    yield return (object) new WaitForSeconds(0.3f);
    routineCurseItems.cardController.Enable();
    routineCurseItems.backButton.SetActive(true);
  }

  public void Back()
  {
    this.cardContainer.DestroyAll();
    this.cardContainer.Clear();
    this.cards.Clear();
    foreach (Entity curse in this.curses)
    {
      if ((bool) (UnityEngine.Object) curse)
        CardManager.ReturnToPool(curse);
    }
    this.curses.Clear();
    this.sequence.End();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EventRoutineGnomeShop
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class EventRoutineGnomeShop : EventRoutine, IRerollable
{
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public CardContainer cardContainer;
  [SerializeField]
  public ShopPriceManager priceManager;
  [SerializeField]
  public ShopItem bell;
  [SerializeField]
  public float cardScale = 0.8f;
  public Entity currentCard;
  public bool promptReroll;
  public bool promptEnd;

  public override IEnumerator Populate()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    EventRoutineGnomeShop routineGnomeShop = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    EventRoutineGnomeShop.Data shopData = routineGnomeShop.data.Get<EventRoutineGnomeShop.Data>("data");
    routineGnomeShop.priceManager.Add(routineGnomeShop.bell, ShopPrice.Position.Bottom).SetPrice(shopData.price);
    routineGnomeShop.cardContainer.SetSize(1, routineGnomeShop.cardScale);
    string nextCard = routineGnomeShop.GetNextCard(shopData);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) routineGnomeShop.CreateCard(nextCard);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override IEnumerator Run()
  {
    EventRoutineGnomeShop routineGnomeShop = this;
    routineGnomeShop.cardController.owner = routineGnomeShop.player;
    routineGnomeShop.cardContainer.owner = routineGnomeShop.player;
    routineGnomeShop.cardSelector.character = routineGnomeShop.player;
    routineGnomeShop.currentCard.flipper.FlipUp();
    while (!routineGnomeShop.promptEnd)
    {
      if (routineGnomeShop.promptReroll)
      {
        yield return (object) routineGnomeShop.RerollRoutine();
        routineGnomeShop.promptReroll = false;
      }
      else
        yield return (object) null;
    }
  }

  public void TakeCard()
  {
    this.cardSelector.TakeCard(this.currentCard);
    this.cardController.Disable();
    Events.InvokeEntityChosen(this.currentCard);
    this.priceManager.Remove(this.bell);
    Button component = this.bell.GetComponent<Button>();
    if (component != null)
      component.interactable = false;
    this.promptEnd = true;
    this.node.SetCleared();
  }

  public string GetNextCard(EventRoutineGnomeShop.Data shopData)
  {
    EventRoutineGnomeShop.Data data = shopData;
    if (data.cards == null)
      data.cards = new List<string>();
    if (shopData.cards.Count <= 0)
    {
      UnityEngine.Random.InitState(this.node.seed);
      for (int index = 0; index < shopData.cyclesThroughPool; ++index)
      {
        double num = (double) UnityEngine.Random.Range(0.0f, 1f);
      }
      foreach (string str in shopData.pool)
        shopData.cards.Insert(UnityEngine.Random.Range(0, shopData.cards.Count), str);
      ++shopData.cyclesThroughPool;
    }
    string card = shopData.cards[0];
    shopData.cards.RemoveAt(0);
    return card;
  }

  public IEnumerator CreateCard(string cardDataName)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    EventRoutineGnomeShop routineGnomeShop = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      routineGnomeShop.cardContainer.SetChildPositions();
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", cardDataName).Clone(), routineGnomeShop.cardController, routineGnomeShop.player, false, true);
    routineGnomeShop.currentCard = card.entity;
    card.transform.position = new Vector3(-999f, 0.0f, 0.0f);
    card.entity.flipper.FlipDownInstant();
    routineGnomeShop.cardContainer.Add(card.entity);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) card.UpdateData(false);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public void HitBell()
  {
    if (this.promptEnd || this.promptReroll)
      return;
    int price = this.bell.GetPrice();
    if (this.player.data.inventory.gold.Value - price < 0)
      return;
    SfxSystem.OneShot("event:/sfx/location/shop/buying");
    this.player.SpendGold(price);
    Events.InvokeShopItemPurchase(this.bell);
    this.Reroll();
    this.priceManager.Remove(this.bell);
  }

  public bool Reroll()
  {
    this.promptReroll = true;
    return true;
  }

  public IEnumerator RerollRoutine()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    EventRoutineGnomeShop routineGnomeShop = this;
    EventRoutineGnomeShop.Data shopData;
    Entity preCard;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      CardManager.ReturnToPool(preCard);
      routineGnomeShop.currentCard.flipper.FlipUp();
      shopData.price += shopData.priceAdd;
      routineGnomeShop.priceManager.Add(routineGnomeShop.bell, ShopPrice.Position.Bottom).SetPrice(shopData.price);
      InputSystem.Enable();
      routineGnomeShop.cardController.Enable();
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    routineGnomeShop.cardController.Disable();
    InputSystem.Disable();
    routineGnomeShop.currentCard.flipper.FlipDown();
    routineGnomeShop.currentCard.RemoveFromContainers();
    shopData = routineGnomeShop.data.Get<EventRoutineGnomeShop.Data>("data");
    string nextCard = routineGnomeShop.GetNextCard(shopData);
    preCard = routineGnomeShop.currentCard;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) routineGnomeShop.CreateCard(nextCard);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  [Serializable]
  public class Data
  {
    public string[] pool;
    public List<string> cards;
    public int price;
    public int priceAdd;
    public int cyclesThroughPool;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EventRoutineInjuredCompanion
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EventRoutineInjuredCompanion : EventRoutine
{
  [SerializeField]
  public ChooseNewCardSequence sequence;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardContainer cardContainer;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public InspectNewUnitSequence inspectSequence;
  [SerializeField]
  public StatusEffectData injuryEffect;
  [SerializeField]
  public SpriteRenderer[] bloodSplats;
  [SerializeField]
  public PromptShower tutorialPrompt;
  [SerializeField]
  public GameObject missingDataDisplay;

  public override IEnumerator Populate()
  {
    EventRoutineInjuredCompanion injuredCompanion = this;
    CardSaveData cardSaveData = injuredCompanion.data.Get<CardSaveData>("cardSaveData");
    if (!MissingCardSystem.IsMissing(cardSaveData))
    {
      CardData cardData = cardSaveData.Load(false);
      injuredCompanion.AddInjuryIfNecessary(cardData);
      cardData.upgrades.RemoveWhere<CardUpgradeData>((Predicate<CardUpgradeData>) (a => a.type == CardUpgradeData.Type.Crown));
      yield return (object) injuredCompanion.CreateCard(cardData);
    }
    else
    {
      injuredCompanion.missingDataDisplay.SetActive(true);
      injuredCompanion.End();
    }
  }

  public void AddInjuryIfNecessary(CardData cardData)
  {
    CardData cardData1 = cardData;
    if (cardData1.injuries == null)
      cardData1.injuries = new List<CardData.StatusEffectStacks>();
    if (cardData.injuries.Count > 0)
      return;
    cardData.injuries.Add(new CardData.StatusEffectStacks(this.injuryEffect, 1));
  }

  public override IEnumerator Run()
  {
    EventRoutineInjuredCompanion injuredCompanion = this;
    CinemaBarSystem.In();
    if (injuredCompanion.cardContainer.Count > 0)
      injuredCompanion.tutorialPrompt.Show((object) injuredCompanion.cardContainer[0].data.title);
    yield return (object) Sequences.Wait(0.1f);
    yield return (object) injuredCompanion.sequence.Run();
    CinemaBarSystem.Clear();
    injuredCompanion.node.SetCleared();
  }

  public IEnumerator CreateCard(CardData cardDataClone)
  {
    EventRoutineInjuredCompanion injuredCompanion = this;
    injuredCompanion.cardSelector.character = injuredCompanion.player;
    injuredCompanion.cardController.owner = injuredCompanion.player;
    injuredCompanion.cardContainer.SetSize(1, 0.8f);
    injuredCompanion.cardContainer.owner = injuredCompanion.player;
    Card card = CardManager.Get(cardDataClone, injuredCompanion.cardController, injuredCompanion.player, false, true);
    card.entity.flipper.FlipDownInstant();
    injuredCompanion.cardContainer.Add(card.entity);
    injuredCompanion.SetBloodSplatColours(card.entity);
    yield return (object) card.UpdateData(false);
    foreach (Entity child in injuredCompanion.cardContainer)
    {
      Transform transform = child.transform;
      transform.localPosition = injuredCompanion.cardContainer.GetChildPosition(child);
      transform.localScale = injuredCompanion.cardContainer.GetChildScale(child);
      transform.localEulerAngles = injuredCompanion.cardContainer.GetChildRotation(child);
    }
  }

  public void SetBloodSplatColours(Entity entity)
  {
    Color bloodColour = UnityEngine.Object.FindObjectOfType<SplatterSystem>().GetBloodColour(entity);
    foreach (SpriteRenderer bloodSplat in this.bloodSplats)
      bloodSplat.color = bloodColour;
  }

  public void TrySelect(Entity entity)
  {
    ActionSelect action = new ActionSelect(entity, (Action<Entity>) (e =>
    {
      this.inspectSequence.SetUnit(entity);
      this.inspectSequence.Begin();
      this.cardController.enabled = false;
      this.cardController.UnHover(entity);
    }));
    if (!Events.CheckAction((PlayAction) action))
      return;
    ActionQueue.Add((PlayAction) action);
  }

  public void CardSelected(Entity entity)
  {
    Events.InvokeEntityChosen(entity);
    this.End();
  }

  public void End()
  {
    this.sequence.End();
    this.cardController.enabled = false;
    this.tutorialPrompt.Hide();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EventRoutineMuncher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Localization;
using UnityEngine.UI;

public class EventRoutineMuncher : EventRoutine
{
  [SerializeField]
  public UnityEngine.Animator muncherAnimator;
  [SerializeField]
  public TweenUI muncherMoveToSide;
  [SerializeField]
  public TweenUI muncherMoveToMid;
  public CardContainer cardContainer;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardType[] canEatCardTypes;
  [SerializeField]
  public LocalizedString initialPromptKey;
  [SerializeField]
  public LocalizedString feedPromptKey;
  [SerializeField]
  public ParticleSystem munchParticles;
  public Button backButton;
  [Header("Speech Bubs")]
  [SerializeField]
  public Talker talker;
  [SerializeField]
  public Vector2 sayDelay = new Vector2(0.8f, 1f);
  [SerializeField]
  public float greetingChance = 1f;
  [SerializeField]
  public float explainChance = 1f;
  public bool hoveringMuncher;
  public bool promptOpenGrid;
  public bool promptCloseGrid;
  public bool promptEnd;
  public bool gridOpen;

  public override IEnumerator Run()
  {
    EventRoutineMuncher eventRoutineMuncher = this;
    int num = eventRoutineMuncher.data.Get<int>("enterCount") + 1;
    eventRoutineMuncher.data["enterCount"] = (object) num;
    eventRoutineMuncher.cardController.owner = eventRoutineMuncher.player;
    eventRoutineMuncher.cardContainer.owner = eventRoutineMuncher.player;
    eventRoutineMuncher.UpdatePrompt();
    SfxSystem.OneShot("event:/sfx/location/muncher/enter");
    if ((double) UnityEngine.Random.value <= (double) eventRoutineMuncher.greetingChance && num == 1)
      eventRoutineMuncher.StartCoroutine(eventRoutineMuncher.SayGreeting());
    while (!eventRoutineMuncher.promptEnd)
    {
      if (eventRoutineMuncher.promptOpenGrid)
      {
        eventRoutineMuncher.promptOpenGrid = false;
        if (!eventRoutineMuncher.gridOpen && eventRoutineMuncher.data.Get<int>("canEat") > 0)
        {
          eventRoutineMuncher.data["openCount"] = (object) (eventRoutineMuncher.data.Get<int>("openCount") + 1);
          eventRoutineMuncher.gridOpen = true;
          if ((double) UnityEngine.Random.value <= (double) eventRoutineMuncher.greetingChance)
            eventRoutineMuncher.StartCoroutine(eventRoutineMuncher.SayExplain());
          yield return (object) eventRoutineMuncher.OpenGrid();
        }
      }
      else if (eventRoutineMuncher.promptCloseGrid)
      {
        eventRoutineMuncher.promptCloseGrid = false;
        if (eventRoutineMuncher.gridOpen)
        {
          eventRoutineMuncher.gridOpen = false;
          yield return (object) eventRoutineMuncher.CloseGrid();
        }
      }
      yield return (object) null;
    }
    CinemaBarSystem.Clear();
    if (eventRoutineMuncher.data.Get<int>("canEat") <= 0)
      eventRoutineMuncher.node.SetCleared();
  }

  public IEnumerator SayGreeting()
  {
    EventRoutineMuncher eventRoutineMuncher = this;
    yield return (object) new WaitForSeconds(eventRoutineMuncher.sayDelay.Random());
    if (eventRoutineMuncher.data.Get<int>("openCount") <= 0)
      eventRoutineMuncher.talker.Say("greet", 0.0f);
  }

  public IEnumerator SayExplain()
  {
    EventRoutineMuncher eventRoutineMuncher = this;
    yield return (object) new WaitForSeconds(eventRoutineMuncher.sayDelay.Random());
    if (eventRoutineMuncher.data.Get<int>("openCount") == 1)
      eventRoutineMuncher.talker.Say("explain", 0.0f);
  }

  public IEnumerator OpenGrid()
  {
    SfxSystem.OneShot("event:/sfx/location/muncher/slide_right");
    CinemaBarSystem.Clear();
    this.muncherMoveToSide.Fire();
    this.cardController.Enable();
    Routine.Clump clump = new Routine.Clump();
    clump.Add(this.CreateCards());
    clump.Add(Sequences.Wait(0.2f));
    yield return (object) clump.WaitForEnd();
    this.cardContainer.gameObject.SetActive(true);
    this.cardContainer.transform.localScale = Vector3.one * 0.5f;
    LeanTween.scale(this.cardContainer.gameObject, Vector3.one, 1.25f).setEase(LeanTweenType.easeOutElastic);
    this.UpdatePrompt();
  }

  public IEnumerator CreateCards()
  {
    EventRoutineMuncher eventRoutineMuncher = this;
    Routine.Clump clump = new Routine.Clump();
    List<CardData> cardDataList = new List<CardData>();
    foreach (CardData cardData in eventRoutineMuncher.player.data.inventory.deck)
    {
      if (eventRoutineMuncher.canEatCardTypes.Contains<CardType>(cardData.cardType))
        cardDataList.Add(cardData);
    }
    foreach (CardData cardData in eventRoutineMuncher.player.data.inventory.reserve)
    {
      if (eventRoutineMuncher.canEatCardTypes.Contains<CardType>(cardData.cardType))
        cardDataList.Add(cardData);
    }
    foreach (CardData data in cardDataList)
    {
      Card card = CardManager.Get(data, eventRoutineMuncher.cardController, eventRoutineMuncher.player, false, true);
      eventRoutineMuncher.cardContainer.Add(card.entity);
      clump.Add(card.UpdateData(false));
    }
    yield return (object) clump.WaitForEnd();
    eventRoutineMuncher.cardContainer.SetChildPositions();
  }

  public IEnumerator CloseGrid()
  {
    EventRoutineMuncher eventRoutineMuncher = this;
    eventRoutineMuncher.UpdatePrompt();
    eventRoutineMuncher.cardController.Disable();
    float num = 0.5f;
    LeanTween.scale(eventRoutineMuncher.cardContainer.gameObject, Vector3.zero, num).setEase(LeanTweenType.easeInBack).setOnComplete(new System.Action(eventRoutineMuncher.\u003CCloseGrid\u003Eb__24_0));
    yield return (object) new WaitForSeconds(num);
    yield return (object) null;
    SfxSystem.OneShot("event:/sfx/location/muncher/slide_left");
    eventRoutineMuncher.muncherMoveToMid.Fire();
  }

  public void UpdatePrompt()
  {
    if (this.data.Get<int>("canEat") > 0)
    {
      if (this.gridOpen)
        CinemaBarSystem.Top.SetPrompt(this.feedPromptKey.GetLocalizedString(), "Select");
      else
        CinemaBarSystem.Top.SetPrompt(this.initialPromptKey.GetLocalizedString(), "Select");
    }
    else
      CinemaBarSystem.Clear();
  }

  public void PromptOpenGrid(BaseEventData eventData)
  {
    if (eventData is PointerEventData pointerEventData && pointerEventData.button != PointerEventData.InputButton.Left)
      return;
    this.promptOpenGrid = true;
  }

  public void PromptCloseGrid() => this.promptCloseGrid = true;

  public void End() => this.promptEnd = true;

  public void HoverMuncher() => this.hoveringMuncher = true;

  public void UnHoverMuncher() => this.hoveringMuncher = false;

  public void DragCardStart(Entity entity)
  {
    this.muncherAnimator.SetBool("DraggingCard", true);
    Events.InvokeMuncherDrag();
    NavigationState.Start((INavigationState) new NavigationStateMuncher(this));
  }

  public void DragCardEnd(Entity entity)
  {
    this.muncherAnimator.SetBool("DraggingCard", false);
    NavigationState.BackToPreviousState();
    Events.InvokeMuncherDragCancel();
    this.cardController.hoverEntity = (Entity) null;
  }

  public void TryEatIfHovering(Entity entity)
  {
    if (!this.hoveringMuncher || !this.TryEat(entity))
      return;
    Events.InvokeMuncherFeed(entity);
  }

  public bool TryEat(Entity entity)
  {
    if (this.data.Get<int>("canEat") <= 0 || !this.canEatCardTypes.Contains<CardType>(entity.data.cardType))
      return false;
    this.Eat(entity);
    return true;
  }

  public void Eat(Entity entity)
  {
    if (entity.owner.data.inventory.deck.RemoveWhere<CardData>((Predicate<CardData>) (a => (long) entity.data.id == (long) a.id)))
      Debug.Log((object) ("[" + entity.data.name + "] Removed From [" + this.player.name + "] deck"));
    else if (entity.owner.data.inventory.reserve.RemoveWhere<CardData>((Predicate<CardData>) (a => (long) entity.data.id == (long) a.id)))
      Debug.Log((object) ("[" + entity.data.name + "] Removed From [" + this.player.name + "] reserve"));
    int num1 = this.data.Get<int>("canEat") - 1;
    this.data["canEat"] = (object) num1;
    if (num1 <= 0)
    {
      this.PromptCloseGrid();
      this.talker.Say("full", 0.0f);
    }
    else
    {
      int num2 = this.data.Get<int>("thankCount") + 1;
      this.data["thankCount"] = (object) num2;
      if (num2 < 1)
        this.talker.Say("thanks", 0.0f);
    }
    entity.RemoveFromContainers();
    if (num1 > 0)
      this.cardContainer.TweenChildPositions();
    CardManager.ReturnToPool(entity);
    this.muncherAnimator.SetTrigger("Munch");
    Events.InvokeScreenShake(0.5f);
    this.munchParticles.Play();
  }

  [CompilerGenerated]
  public void \u003CCloseGrid\u003Eb__24_0()
  {
    foreach (Entity entity in this.cardContainer)
      CardManager.ReturnToPool(entity);
    this.cardContainer.Clear();
    this.cardContainer.gameObject.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Events
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Deadpan.Enums.Engine.Components.Modding;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public static class Events
{
  public static event UnityAction<Scene> OnSceneLoaded;

  public static void InvokeSceneLoaded(Scene scene)
  {
    UnityAction<Scene> onSceneLoaded = global::Events.OnSceneLoaded;
    if (onSceneLoaded == null)
      return;
    onSceneLoaded(scene);
  }

  public static event UnityAction<Scene> OnSceneChanged;

  public static void InvokeSceneChanged(Scene scene)
  {
    UnityAction<Scene> onSceneChanged = global::Events.OnSceneChanged;
    if (onSceneChanged == null)
      return;
    onSceneChanged(scene);
  }

  public static event UnityAction<Scene> OnSceneUnload;

  public static void InvokeSceneUnload(Scene scene)
  {
    UnityAction<Scene> onSceneUnload = global::Events.OnSceneUnload;
    if (onSceneUnload == null)
      return;
    onSceneUnload(scene);
  }

  public static event UnityAction OnBackToMainMenu;

  public static void InvokeBackToMainMenu()
  {
    UnityAction onBackToMainMenu = global::Events.OnBackToMainMenu;
    if (onBackToMainMenu == null)
      return;
    onBackToMainMenu();
  }

  public static event UnityAction<Entity> OnEntityCreated;

  public static void InvokeEntityCreated(Entity entity)
  {
    UnityAction<Entity> onEntityCreated = global::Events.OnEntityCreated;
    if (onEntityCreated == null)
      return;
    onEntityCreated(entity);
  }

  public static event UnityAction<Entity> OnEntityDataUpdated;

  public static void InvokeEntityDataUpdated(Entity entity)
  {
    UnityAction<Entity> entityDataUpdated = global::Events.OnEntityDataUpdated;
    if (entityDataUpdated == null)
      return;
    entityDataUpdated(entity);
  }

  public static event UnityAction<Entity> OnEntityDestroyed;

  public static void InvokeEntityDestroyed(Entity entity)
  {
    UnityAction<Entity> onEntityDestroyed = global::Events.OnEntityDestroyed;
    if (onEntityDestroyed == null)
      return;
    onEntityDestroyed(entity);
  }

  public static event UnityAction<Card> OnCardPooled;

  public static void InvokeCardPooled(Card card)
  {
    UnityAction<Card> onCardPooled = global::Events.OnCardPooled;
    if (onCardPooled == null)
      return;
    onCardPooled(card);
  }

  public static event UnityAction<Entity> OnEntityEnabled;

  public static void InvokeEntityEnabled(Entity entity)
  {
    UnityAction<Entity> onEntityEnabled = global::Events.OnEntityEnabled;
    if (onEntityEnabled == null)
      return;
    onEntityEnabled(entity);
  }

  public static event UnityAction<Entity> OnEntityDisabled;

  public static void InvokeEntityDisabled(Entity entity)
  {
    UnityAction<Entity> onEntityDisabled = global::Events.OnEntityDisabled;
    if (onEntityDisabled == null)
      return;
    onEntityDisabled(entity);
  }

  public static event UnityAction<Entity, DeathType> OnEntityKilled;

  public static void InvokeEntityKilled(Entity entity, DeathType deathType)
  {
    UnityAction<Entity, DeathType> onEntityKilled = global::Events.OnEntityKilled;
    if (onEntityKilled == null)
      return;
    onEntityKilled(entity, deathType);
  }

  public static event UnityAction<Entity> OnEntityFlee;

  public static void InvokeEntityFlee(Entity entity)
  {
    UnityAction<Entity> onEntityFlee = global::Events.OnEntityFlee;
    if (onEntityFlee == null)
      return;
    onEntityFlee(entity);
  }

  public static event UnityAction<Entity> OnEntityHover;

  public static void InvokeEntityHover(Entity entity)
  {
    UnityAction<Entity> onEntityHover = global::Events.OnEntityHover;
    if (onEntityHover == null)
      return;
    onEntityHover(entity);
  }

  public static event UnityAction<Entity> OnEntityUnHover;

  public static void InvokeEntityUnHover(Entity entity)
  {
    UnityAction<Entity> onEntityUnHover = global::Events.OnEntityUnHover;
    if (onEntityUnHover == null)
      return;
    onEntityUnHover(entity);
  }

  public static event UnityAction<Entity> OnEntitySelect;

  public static void InvokeEntitySelect(Entity entity)
  {
    UnityAction<Entity> onEntitySelect = global::Events.OnEntitySelect;
    if (onEntitySelect == null)
      return;
    onEntitySelect(entity);
  }

  public static event global::Events.UnityActionRef<Entity, bool> OnCheckEntityDrag;

  public static bool CheckEntityDrag(Entity entity)
  {
    bool flag = true;
    global::Events.UnityActionRef<Entity, bool> onCheckEntityDrag = global::Events.OnCheckEntityDrag;
    if (onCheckEntityDrag != null)
      onCheckEntityDrag(ref entity, ref flag);
    return flag;
  }

  public static event UnityAction<Entity> OnEntityDrag;

  public static void InvokeEntityDrag(Entity entity)
  {
    UnityAction<Entity> onEntityDrag = global::Events.OnEntityDrag;
    if (onEntityDrag == null)
      return;
    onEntityDrag(entity);
  }

  public static event UnityAction<Entity> OnEntityRelease;

  public static void InvokeEntityRelease(Entity entity)
  {
    UnityAction<Entity> onEntityRelease = global::Events.OnEntityRelease;
    if (onEntityRelease == null)
      return;
    onEntityRelease(entity);
  }

  public static event UnityAction<Entity> OnEntityOffered;

  public static void InvokeEntityOffered(Entity entity)
  {
    UnityAction<Entity> onEntityOffered = global::Events.OnEntityOffered;
    if (onEntityOffered == null)
      return;
    onEntityOffered(entity);
  }

  public static event UnityAction<Entity> OnEntityChosen;

  public static void InvokeEntityChosen(Entity entity)
  {
    UnityAction<Entity> onEntityChosen = global::Events.OnEntityChosen;
    if (onEntityChosen == null)
      return;
    onEntityChosen(entity);
  }

  public static event UnityAction<Entity> OnEntityShowUnlocked;

  public static void InvokeEntityShowUnlocked(Entity entity)
  {
    UnityAction<Entity> entityShowUnlocked = global::Events.OnEntityShowUnlocked;
    if (entityShowUnlocked == null)
      return;
    entityShowUnlocked(entity);
  }

  public static event global::Events.UnityActionRef<Entity, bool> OnCheckEntityShove;

  public static bool CheckEntityShove(Entity entity)
  {
    bool flag = true;
    global::Events.UnityActionRef<Entity, bool> checkEntityShove = global::Events.OnCheckEntityShove;
    if (checkEntityShove != null)
      checkEntityShove(ref entity, ref flag);
    return flag;
  }

  public static event UnityAction<Entity> OnPreProcessTrigger;

  public static void InvokePreProcessTrigger(Entity entity)
  {
    UnityAction<Entity> preProcessTrigger = global::Events.OnPreProcessTrigger;
    if (preProcessTrigger == null)
      return;
    preProcessTrigger(entity);
  }

  public static event global::Events.UnityActionRef<Trigger> OnEntityPreTrigger;

  public static void InvokeEntityPreTrigger(ref Trigger trigger)
  {
    global::Events.UnityActionRef<Trigger> entityPreTrigger = global::Events.OnEntityPreTrigger;
    if (entityPreTrigger == null)
      return;
    entityPreTrigger(ref trigger);
  }

  public static event global::Events.UnityActionRef<Trigger> OnEntityTrigger;

  public static void InvokeEntityTrigger(ref Trigger trigger)
  {
    global::Events.UnityActionRef<Trigger> onEntityTrigger = global::Events.OnEntityTrigger;
    if (onEntityTrigger == null)
      return;
    onEntityTrigger(ref trigger);
  }

  public static event global::Events.UnityActionRef<Trigger> OnEntityTriggered;

  public static void InvokeEntityTriggered(ref Trigger trigger)
  {
    global::Events.UnityActionRef<Trigger> onEntityTriggered = global::Events.OnEntityTriggered;
    if (onEntityTriggered == null)
      return;
    onEntityTriggered(ref trigger);
  }

  public static event UnityAction<Entity> OnEntityMove;

  public static void InvokeEntityMove(Entity entity)
  {
    UnityAction<Entity> onEntityMove = global::Events.OnEntityMove;
    if (onEntityMove == null)
      return;
    onEntityMove(entity);
  }

  public static event UnityAction<Entity, CardContainer[], bool> OnEntityPlace;

  public static void InvokeEntityPlace(Entity entity, CardContainer[] containers, bool freeMove)
  {
    UnityAction<Entity, CardContainer[], bool> onEntityPlace = global::Events.OnEntityPlace;
    if (onEntityPlace == null)
      return;
    onEntityPlace(entity, containers, freeMove);
  }

  public static event UnityAction<Entity> OnDiscard;

  public static void InvokeDiscard(Entity entity)
  {
    UnityAction<Entity> onDiscard = global::Events.OnDiscard;
    if (onDiscard == null)
      return;
    onDiscard(entity);
  }

  public static event UnityAction<Hit> OnEntityHit;

  public static void InvokeEntityHit(Hit hit)
  {
    UnityAction<Hit> onEntityHit = global::Events.OnEntityHit;
    if (onEntityHit == null)
      return;
    onEntityHit(hit);
  }

  public static event UnityAction<Hit> OnEntityPostHit;

  public static void InvokeEntityPostHit(Hit hit)
  {
    UnityAction<Hit> onEntityPostHit = global::Events.OnEntityPostHit;
    if (onEntityPostHit == null)
      return;
    onEntityPostHit(hit);
  }

  public static event UnityAction<Hit> OnEntityDodge;

  public static void InvokeEntityDodge(Hit hit)
  {
    UnityAction<Hit> onEntityDodge = global::Events.OnEntityDodge;
    if (onEntityDodge == null)
      return;
    onEntityDodge(hit);
  }

  public static event UnityAction<Entity> OnEntityFlipUp;

  public static void InvokeEntityFlipUp(Entity entity)
  {
    UnityAction<Entity> onEntityFlipUp = global::Events.OnEntityFlipUp;
    if (onEntityFlipUp == null)
      return;
    onEntityFlipUp(entity);
  }

  public static event UnityAction<Entity> OnEntityFlipDown;

  public static void InvokeEntityFlipDown(Entity entity)
  {
    UnityAction<Entity> onEntityFlipDown = global::Events.OnEntityFlipDown;
    if (onEntityFlipDown == null)
      return;
    onEntityFlipDown(entity);
  }

  public static event UnityAction<StatusIcon> OnStatusIconCreated;

  public static void InvokeStatusIconCreated(StatusIcon icon)
  {
    UnityAction<StatusIcon> statusIconCreated = global::Events.OnStatusIconCreated;
    if (statusIconCreated == null)
      return;
    statusIconCreated(icon);
  }

  public static event UnityAction<StatusIcon, Stat, Stat> OnStatusIconChanged;

  public static void InvokeStatusIconChanged(StatusIcon icon, Stat previousValue, Stat newValue)
  {
    UnityAction<StatusIcon, Stat, Stat> statusIconChanged = global::Events.OnStatusIconChanged;
    if (statusIconChanged == null)
      return;
    statusIconChanged(icon, previousValue, newValue);
  }

  public static event UnityAction<Entity> OnEntityDisplayUpdated;

  public static void InvokeEntityDisplayUpdated(Entity entity)
  {
    UnityAction<Entity> entityDisplayUpdated = global::Events.OnEntityDisplayUpdated;
    if (entityDisplayUpdated == null)
      return;
    entityDisplayUpdated(entity);
  }

  public static event UnityAction<Entity> OnEntityFocus;

  public static void InvokeEntityFocus(Entity entity)
  {
    UnityAction<Entity> onEntityFocus = global::Events.OnEntityFocus;
    if (onEntityFocus == null)
      return;
    onEntityFocus(entity);
  }

  public static event UnityAction<Entity, CardPocket> OnEntityEnterPocket;

  public static void InvokeEntityEnterPocket(Entity card, CardPocket pocket)
  {
    UnityAction<Entity, CardPocket> entityEnterPocket = global::Events.OnEntityEnterPocket;
    if (entityEnterPocket == null)
      return;
    entityEnterPocket(card, pocket);
  }

  public static event UnityAction<Entity> OnEntityEnterBackpack;

  public static void InvokeEntityEnterBackpack(Entity entity)
  {
    UnityAction<Entity> entityEnterBackpack = global::Events.OnEntityEnterBackpack;
    if (entityEnterBackpack == null)
      return;
    entityEnterBackpack(entity);
  }

  public static event UnityAction<Entity> OnEntityChangePhase;

  public static void InvokeEntityChangePhase(Entity entity)
  {
    UnityAction<Entity> entityChangePhase = global::Events.OnEntityChangePhase;
    if (entityChangePhase == null)
      return;
    entityChangePhase(entity);
  }

  public static event UnityAction<Entity> OnNoomlinShow;

  public static void InvokeNoomlinShow(Entity entity)
  {
    UnityAction<Entity> onNoomlinShow = global::Events.OnNoomlinShow;
    if (onNoomlinShow == null)
      return;
    onNoomlinShow(entity);
  }

  public static event UnityAction<Entity> OnNoomlinUsed;

  public static void InvokeNoomlinUsed(Entity entity)
  {
    UnityAction<Entity> onNoomlinUsed = global::Events.OnNoomlinUsed;
    if (onNoomlinUsed == null)
      return;
    onNoomlinUsed(entity);
  }

  public static event UnityAction<Entity> OnEntityFlipComplete;

  public static void InvokeEntityFlipComplete(Entity entity)
  {
    UnityAction<Entity> entityFlipComplete = global::Events.OnEntityFlipComplete;
    if (entityFlipComplete == null)
      return;
    entityFlipComplete(entity);
  }

  public static event UnityAction<Entity, Entity> OnEntitySummoned;

  public static void InvokeEntitySummoned(Entity entity, Entity summonedBy)
  {
    UnityAction<Entity, Entity> onEntitySummoned = global::Events.OnEntitySummoned;
    if (onEntitySummoned == null)
      return;
    onEntitySummoned(entity, summonedBy);
  }

  public static event UnityAction<GameObject> OnEntityPing;

  public static void InvokeEntityPing(GameObject obj)
  {
    UnityAction<GameObject> onEntityPing = global::Events.OnEntityPing;
    if (onEntityPing == null)
      return;
    onEntityPing(obj);
  }

  public static event global::Events.UnityActionRef<Entity, int> OnCheckRecycleAmount;

  public static void CheckRecycleAmount(Entity entity, ref int amount)
  {
    global::Events.UnityActionRef<Entity, int> checkRecycleAmount = global::Events.OnCheckRecycleAmount;
    if (checkRecycleAmount == null)
      return;
    checkRecycleAmount(ref entity, ref amount);
  }

  public static event UnityAction<CardContainer> OnContainerHover;

  public static void InvokeContainerHover(CardContainer container)
  {
    UnityAction<CardContainer> onContainerHover = global::Events.OnContainerHover;
    if (onContainerHover == null)
      return;
    onContainerHover(container);
  }

  public static event UnityAction<CardContainer> OnContainerUnHover;

  public static void InvokeContainerUnHover(CardContainer container)
  {
    UnityAction<CardContainer> containerUnHover = global::Events.OnContainerUnHover;
    if (containerUnHover == null)
      return;
    containerUnHover(container);
  }

  public static event UnityAction<CardSlot> OnSlotHover;

  public static void InvokeSlotHover(CardSlot slot)
  {
    UnityAction<CardSlot> onSlotHover = global::Events.OnSlotHover;
    if (onSlotHover == null)
      return;
    onSlotHover(slot);
  }

  public static event UnityAction<CardSlot> OnSlotUnHover;

  public static void InvokeSlotUnHover(CardSlot slot)
  {
    UnityAction<CardSlot> onSlotUnHover = global::Events.OnSlotUnHover;
    if (onSlotUnHover == null)
      return;
    onSlotUnHover(slot);
  }

  public static event UnityAction<PlayAction> OnActionQueued;

  public static void InvokeActionQueued(PlayAction action)
  {
    UnityAction<PlayAction> onActionQueued = global::Events.OnActionQueued;
    if (onActionQueued == null)
      return;
    onActionQueued(action);
  }

  public static event UnityAction<PlayAction> OnActionPerform;

  public static void InvokeActionPerform(PlayAction action)
  {
    UnityAction<PlayAction> onActionPerform = global::Events.OnActionPerform;
    if (onActionPerform == null)
      return;
    onActionPerform(action);
  }

  public static event UnityAction<PlayAction> OnActionFinished;

  public static void InvokeActionFinished(PlayAction action)
  {
    UnityAction<PlayAction> onActionFinished = global::Events.OnActionFinished;
    if (onActionFinished == null)
      return;
    onActionFinished(action);
  }

  public static event global::Events.UnityActionRef<PlayAction, bool> OnCheckAction;

  public static bool CheckAction(PlayAction action)
  {
    bool flag = true;
    global::Events.UnityActionRef<PlayAction, bool> onCheckAction = global::Events.OnCheckAction;
    if (onCheckAction != null)
      onCheckAction(ref action, ref flag);
    return flag;
  }

  public static event UnityAction<CardContainer> OnAbilityTargetAdd;

  public static void InvokeAbilityTargetAdd(CardContainer container)
  {
    UnityAction<CardContainer> abilityTargetAdd = global::Events.OnAbilityTargetAdd;
    if (abilityTargetAdd == null)
      return;
    abilityTargetAdd(container);
  }

  public static event UnityAction<CardContainer> OnAbilityTargetRemove;

  public static void InvokeAbilityTargetRemove(CardContainer container)
  {
    UnityAction<CardContainer> abilityTargetRemove = global::Events.OnAbilityTargetRemove;
    if (abilityTargetRemove == null)
      return;
    abilityTargetRemove(container);
  }

  public static event UnityAction<int> OnCardDraw;

  public static void InvokeCardDraw(int count)
  {
    UnityAction<int> onCardDraw = global::Events.OnCardDraw;
    if (onCardDraw == null)
      return;
    onCardDraw(count);
  }

  public static event UnityAction OnCardDrawEnd;

  public static void InvokeCardDrawEnd()
  {
    UnityAction onCardDrawEnd = global::Events.OnCardDrawEnd;
    if (onCardDrawEnd == null)
      return;
    onCardDrawEnd();
  }

  public static event UnityAction<CampaignNode> PreBattleSetUp;

  public static void InvokePreBattleSetUp(CampaignNode node)
  {
    UnityAction<CampaignNode> preBattleSetUp = global::Events.PreBattleSetUp;
    if (preBattleSetUp == null)
      return;
    preBattleSetUp(node);
  }

  public static event UnityAction<CampaignNode> PostBattleSetUp;

  public static void InvokePostBattleSetUp(CampaignNode node)
  {
    UnityAction<CampaignNode> postBattleSetUp = global::Events.PostBattleSetUp;
    if (postBattleSetUp == null)
      return;
    postBattleSetUp(node);
  }

  public static event UnityAction<Battle.Phase> OnBattlePhaseStart;

  public static void InvokeBattlePhaseStart(Battle.Phase phase)
  {
    UnityAction<Battle.Phase> battlePhaseStart = global::Events.OnBattlePhaseStart;
    if (battlePhaseStart == null)
      return;
    battlePhaseStart(phase);
  }

  public static event UnityAction OnBattleStart;

  public static void InvokeBattleStart()
  {
    UnityAction onBattleStart = global::Events.OnBattleStart;
    if (onBattleStart == null)
      return;
    onBattleStart();
  }

  public static event global::Events.AsyncAction PreBattleEnd;

  public static IEnumerator InvokePreBattleEnd()
  {
    if (global::Events.PreBattleEnd != null)
    {
      Task task = global::Events.PreBattleEnd();
      yield return (object) new WaitUntil((Func<bool>) (() => task.IsCompleted));
    }
  }

  public static event UnityAction OnBattleEnd;

  public static void InvokeBattleEnd()
  {
    UnityAction onBattleEnd = global::Events.OnBattleEnd;
    if (onBattleEnd == null)
      return;
    onBattleEnd();
  }

  public static event UnityAction OnBattleWinPreRewards;

  public static void InvokeBattleWinPreRewards()
  {
    UnityAction battleWinPreRewards = global::Events.OnBattleWinPreRewards;
    if (battleWinPreRewards == null)
      return;
    battleWinPreRewards();
  }

  public static event UnityAction OnBattleWin;

  public static void InvokeBattleWin()
  {
    UnityAction onBattleWin = global::Events.OnBattleWin;
    if (onBattleWin == null)
      return;
    onBattleWin();
  }

  public static event UnityAction<CampaignNode> PostBattle;

  public static void InvokePostBattle(CampaignNode campaignNode)
  {
    UnityAction<CampaignNode> postBattle = global::Events.PostBattle;
    if (postBattle == null)
      return;
    postBattle(campaignNode);
  }

  public static event global::Events.UnityActionCheck<StatusEffectData, int> OnStatusEffectCountDown;

  public static void InvokeStatusEffectCountDown(StatusEffectData status, ref int amount)
  {
    global::Events.UnityActionCheck<StatusEffectData, int> statusEffectCountDown = global::Events.OnStatusEffectCountDown;
    if (statusEffectCountDown == null)
      return;
    statusEffectCountDown(status, ref amount);
  }

  public static event UnityAction<StatusEffectApply> OnStatusEffectApplied;

  public static void InvokeStatusEffectApplied(StatusEffectApply apply)
  {
    UnityAction<StatusEffectApply> statusEffectApplied = global::Events.OnStatusEffectApplied;
    if (statusEffectApplied == null)
      return;
    statusEffectApplied(apply);
  }

  public static event UnityAction<Character> OnPreProcessUnits;

  public static void InvokePreProcessUnits(Character character)
  {
    UnityAction<Character> onPreProcessUnits = global::Events.OnPreProcessUnits;
    if (onPreProcessUnits == null)
      return;
    onPreProcessUnits(character);
  }

  public static event UnityAction<Character> OnPostProcessUnits;

  public static void InvokePostProcessUnits(Character character)
  {
    UnityAction<Character> postProcessUnits = global::Events.OnPostProcessUnits;
    if (postProcessUnits == null)
      return;
    postProcessUnits(character);
  }

  public static event global::Events.UnityActionCheck<Entity, int> OnEntityCountDown;

  public static void InvokeEntityCountDown(Entity entity, ref int amount)
  {
    global::Events.UnityActionCheck<Entity, int> onEntityCountDown = global::Events.OnEntityCountDown;
    if (onEntityCountDown == null)
      return;
    onEntityCountDown(entity, ref amount);
  }

  public static event UnityAction<int> OnBattlePreTurnStart;

  public static void InvokeBattlePreTurnStart(int turnNumber)
  {
    UnityAction<int> battlePreTurnStart = global::Events.OnBattlePreTurnStart;
    if (battlePreTurnStart == null)
      return;
    battlePreTurnStart(turnNumber);
  }

  public static event UnityAction<int> OnBattleTurnStart;

  public static void InvokeBattleTurnStart(int turnNumber)
  {
    UnityAction<int> onBattleTurnStart = global::Events.OnBattleTurnStart;
    if (onBattleTurnStart == null)
      return;
    onBattleTurnStart(turnNumber);
  }

  public static event UnityAction<int> OnBattleTurnEnd;

  public static void InvokeBattleTurnEnd(int turnNumber)
  {
    UnityAction<int> onBattleTurnEnd = global::Events.OnBattleTurnEnd;
    if (onBattleTurnEnd == null)
      return;
    onBattleTurnEnd(turnNumber);
  }

  public static event UnityAction<Entity> OnMinibossIntro;

  public static void InvokeMinibossIntro(Entity entity)
  {
    UnityAction<Entity> onMinibossIntro = global::Events.OnMinibossIntro;
    if (onMinibossIntro == null)
      return;
    onMinibossIntro(entity);
  }

  public static event UnityAction<Entity> OnMinibossIntroDone;

  public static void InvokeMinibossIntroDone(Entity entity)
  {
    UnityAction<Entity> minibossIntroDone = global::Events.OnMinibossIntroDone;
    if (minibossIntroDone == null)
      return;
    minibossIntroDone(entity);
  }

  public static event UnityAction<int> OnKillCombo;

  public static void InvokeKillCombo(int combo)
  {
    UnityAction<int> onKillCombo = global::Events.OnKillCombo;
    if (onKillCombo == null)
      return;
    onKillCombo(combo);
  }

  public static event UnityAction<RedrawBellSystem> OnRedrawBellHit;

  public static void InvokeRedrawBellHit(RedrawBellSystem redrawBellSystem)
  {
    UnityAction<RedrawBellSystem> onRedrawBellHit = global::Events.OnRedrawBellHit;
    if (onRedrawBellHit == null)
      return;
    onRedrawBellHit(redrawBellSystem);
  }

  public static event UnityAction<RedrawBellSystem> OnRedrawBellRevealed;

  public static void InvokeRedrawBellRevealed(RedrawBellSystem redrawBellSystem)
  {
    UnityAction<RedrawBellSystem> redrawBellRevealed = global::Events.OnRedrawBellRevealed;
    if (redrawBellRevealed == null)
      return;
    redrawBellRevealed(redrawBellSystem);
  }

  public static event UnityAction<CardData> OnCardInjured;

  public static void InvokeCardInjured(CardData cardData)
  {
    UnityAction<CardData> onCardInjured = global::Events.OnCardInjured;
    if (onCardInjured == null)
      return;
    onCardInjured(cardData);
  }

  public static event UnityAction OnBattleStateBuild;

  public static void InvokeBattleStateBuild()
  {
    UnityAction battleStateBuild = global::Events.OnBattleStateBuild;
    if (battleStateBuild == null)
      return;
    battleStateBuild();
  }

  public static event UnityAction<BattleSaveData> OnBattleStateBuilt;

  public static void InvokeBattleStateBuilt(BattleSaveData battleState)
  {
    UnityAction<BattleSaveData> battleStateBuilt = global::Events.OnBattleStateBuilt;
    if (battleStateBuilt == null)
      return;
    battleStateBuilt(battleState);
  }

  public static event UnityAction<Character> OnCharacterActionPerformed;

  public static void InvokeCharacterActionPerformed(Character character)
  {
    UnityAction<Character> characterActionPerformed = global::Events.OnCharacterActionPerformed;
    if (characterActionPerformed == null)
      return;
    characterActionPerformed(character);
  }

  public static event UnityAction<int> OnWaveDeployerPreCountDown;

  public static void InvokeWaveDeployerPreCountDown(int counter)
  {
    UnityAction<int> deployerPreCountDown = global::Events.OnWaveDeployerPreCountDown;
    if (deployerPreCountDown == null)
      return;
    deployerPreCountDown(counter);
  }

  public static event UnityAction<int> OnWaveDeployerPostCountDown;

  public static void InvokeWaveDeployerPostCountDown(int counter)
  {
    UnityAction<int> deployerPostCountDown = global::Events.OnWaveDeployerPostCountDown;
    if (deployerPostCountDown == null)
      return;
    deployerPostCountDown(counter);
  }

  public static event UnityAction<float> OnMapPathReveal;

  public static void InvokeMapPathReveal(float totalTime)
  {
    UnityAction<float> onMapPathReveal = global::Events.OnMapPathReveal;
    if (onMapPathReveal == null)
      return;
    onMapPathReveal(totalTime);
  }

  public static event UnityAction<MapNode> OnMapNodeReveal;

  public static void InvokeMapNodeReveal(MapNode node)
  {
    UnityAction<MapNode> onMapNodeReveal = global::Events.OnMapNodeReveal;
    if (onMapNodeReveal == null)
      return;
    onMapNodeReveal(node);
  }

  public static event UnityAction<MapNode> OnMapNodeSelect;

  public static void InvokeMapNodeSelect(MapNode node)
  {
    UnityAction<MapNode> onMapNodeSelect = global::Events.OnMapNodeSelect;
    if (onMapNodeSelect == null)
      return;
    onMapNodeSelect(node);
  }

  public static event UnityAction<MapNode> OnMapNodeHover;

  public static void InvokeMapNodeHover(MapNode node)
  {
    UnityAction<MapNode> onMapNodeHover = global::Events.OnMapNodeHover;
    if (onMapNodeHover == null)
      return;
    onMapNodeHover(node);
  }

  public static event UnityAction<MapNode> OnMapNodeUnHover;

  public static void InvokeMapNodeUnHover(MapNode node)
  {
    UnityAction<MapNode> onMapNodeUnHover = global::Events.OnMapNodeUnHover;
    if (onMapNodeUnHover == null)
      return;
    onMapNodeUnHover(node);
  }

  public static event UnityAction<UnlockData> OnTownUnlock;

  public static void InvokeTownUnlock(UnlockData unlockData)
  {
    UnityAction<UnlockData> onTownUnlock = global::Events.OnTownUnlock;
    if (onTownUnlock == null)
      return;
    onTownUnlock(unlockData);
  }

  public static event UnityAction<ShopItem> OnShopItemHover;

  public static void InvokeShopItemHover(ShopItem item)
  {
    UnityAction<ShopItem> onShopItemHover = global::Events.OnShopItemHover;
    if (onShopItemHover == null)
      return;
    onShopItemHover(item);
  }

  public static event UnityAction<ShopItem> OnShopItemUnHover;

  public static void InvokeShopItemUnHover(ShopItem item)
  {
    UnityAction<ShopItem> onShopItemUnHover = global::Events.OnShopItemUnHover;
    if (onShopItemUnHover == null)
      return;
    onShopItemUnHover(item);
  }

  public static event UnityAction<ShopItem> OnShopItemPurchase;

  public static void InvokeShopItemPurchase(ShopItem item)
  {
    UnityAction<ShopItem> shopItemPurchase = global::Events.OnShopItemPurchase;
    if (shopItemPurchase == null)
      return;
    shopItemPurchase(item);
  }

  public static event UnityAction<KeywordData, CardPopUpPanel> OnPopupCreated;

  public static void InvokePopupPanelCreated(KeywordData keyword, CardPopUpPanel panel)
  {
    UnityAction<KeywordData, CardPopUpPanel> onPopupCreated = global::Events.OnPopupCreated;
    if (onPopupCreated == null)
      return;
    onPopupCreated(keyword, panel);
  }

  public static event UnityAction<ButtonType> OnButtonHover;

  public static void InvokeButtonHover(ButtonType buttonType)
  {
    UnityAction<ButtonType> onButtonHover = global::Events.OnButtonHover;
    if (onButtonHover == null)
      return;
    onButtonHover(buttonType);
  }

  public static event UnityAction<ButtonType> OnButtonPress;

  public static void InvokeButtonPress(ButtonType buttonType)
  {
    UnityAction<ButtonType> onButtonPress = global::Events.OnButtonPress;
    if (onButtonPress == null)
      return;
    onButtonPress(buttonType);
  }

  public static event UnityAction<string, float> OnAudioVolumeChange;

  public static void InvokeAudioVolumeChange(string busName, float value)
  {
    UnityAction<string, float> audioVolumeChange = global::Events.OnAudioVolumeChange;
    if (audioVolumeChange == null)
      return;
    audioVolumeChange(busName, value);
  }

  public static event UnityAction<string, float> OnAudioPitchChange;

  public static void InvokeAudioPitchChange(string busName, float value)
  {
    UnityAction<string, float> audioPitchChange = global::Events.OnAudioPitchChange;
    if (audioPitchChange == null)
      return;
    audioPitchChange(busName, value);
  }

  public static event UnityAction<Entity> OnBombardShoot;

  public static void InvokeBombardShoot(Entity entity)
  {
    UnityAction<Entity> onBombardShoot = global::Events.OnBombardShoot;
    if (onBombardShoot == null)
      return;
    onBombardShoot(entity);
  }

  public static event UnityAction<BombardRocket> OnBombardRocketFall;

  public static void InvokeBombardRocketFall(BombardRocket rocket)
  {
    UnityAction<BombardRocket> bombardRocketFall = global::Events.OnBombardRocketFall;
    if (bombardRocketFall == null)
      return;
    bombardRocketFall(rocket);
  }

  public static event UnityAction<BombardRocket> OnBombardRocketExplode;

  public static void InvokeBombardRocketExplode(BombardRocket rocket)
  {
    UnityAction<BombardRocket> bombardRocketExplode = global::Events.OnBombardRocketExplode;
    if (bombardRocketExplode == null)
      return;
    bombardRocketExplode(rocket);
  }

  public static event UnityAction<float> OnProgressStart;

  public static void InvokeProgressStart(float fill)
  {
    UnityAction<float> onProgressStart = global::Events.OnProgressStart;
    if (onProgressStart == null)
      return;
    onProgressStart(fill);
  }

  public static event UnityAction<float> OnProgressUpdate;

  public static void InvokeProgressUpdate(float fill)
  {
    UnityAction<float> onProgressUpdate = global::Events.OnProgressUpdate;
    if (onProgressUpdate == null)
      return;
    onProgressUpdate(fill);
  }

  public static event UnityAction OnProgressStop;

  public static void InvokeProgressStop()
  {
    UnityAction onProgressStop = global::Events.OnProgressStop;
    if (onProgressStop == null)
      return;
    onProgressStop();
  }

  public static event UnityAction OnProgressDing;

  public static void InvokeProgressDing()
  {
    UnityAction onProgressDing = global::Events.OnProgressDing;
    if (onProgressDing == null)
      return;
    onProgressDing();
  }

  public static event UnityAction OnProgressBlip;

  public static void InvokeProgressBlip()
  {
    UnityAction onProgressBlip = global::Events.OnProgressBlip;
    if (onProgressBlip == null)
      return;
    onProgressBlip();
  }

  public static event UnityAction OnSaveSystemEnabled;

  public static void InvokeSaveSystemEnabled()
  {
    UnityAction saveSystemEnabled = global::Events.OnSaveSystemEnabled;
    if (saveSystemEnabled == null)
      return;
    saveSystemEnabled();
  }

  public static event UnityAction OnSaveSystemDisabled;

  public static void InvokeSaveSystemDisabled()
  {
    UnityAction saveSystemDisabled = global::Events.OnSaveSystemDisabled;
    if (saveSystemDisabled == null)
      return;
    saveSystemDisabled();
  }

  public static event UnityAction OnSaveSystemProfileChanged;

  public static void InvokeSaveSystemProfileChanged()
  {
    UnityAction systemProfileChanged = global::Events.OnSaveSystemProfileChanged;
    if (systemProfileChanged == null)
      return;
    systemProfileChanged();
  }

  public static event UnityAction OnCampaignSaved;

  public static void InvokeCampaignSaved()
  {
    UnityAction onCampaignSaved = global::Events.OnCampaignSaved;
    if (onCampaignSaved == null)
      return;
    onCampaignSaved();
  }

  public static event UnityAction OnCampaignLoaded;

  public static void InvokeCampaignLoaded()
  {
    UnityAction onCampaignLoaded = global::Events.OnCampaignLoaded;
    if (onCampaignLoaded == null)
      return;
    onCampaignLoaded();
  }

  public static event UnityAction OnCampaignDeleted;

  public static void InvokeCampaignDeleted()
  {
    UnityAction onCampaignDeleted = global::Events.OnCampaignDeleted;
    if (onCampaignDeleted == null)
      return;
    onCampaignDeleted();
  }

  public static event UnityAction OnBattleSaved;

  public static void InvokeBattleSaved()
  {
    UnityAction onBattleSaved = global::Events.OnBattleSaved;
    if (onBattleSaved == null)
      return;
    onBattleSaved();
  }

  public static event UnityAction OnBattleLoaded;

  public static void InvokeBattleLoaded()
  {
    UnityAction onBattleLoaded = global::Events.OnBattleLoaded;
    if (onBattleLoaded == null)
      return;
    onBattleLoaded();
  }

  public static event UnityAction OnGameStart;

  public static void InvokeGameStart()
  {
    UnityAction onGameStart = global::Events.OnGameStart;
    if (onGameStart == null)
      return;
    onGameStart();
  }

  public static event UnityAction OnGameEnd;

  public static void InvokeGameEnd()
  {
    UnityAction onGameEnd = global::Events.OnGameEnd;
    if (onGameEnd == null)
      return;
    onGameEnd();
  }

  public static event UnityAction OnCampaignStart;

  public static void InvokeCampaignStart()
  {
    UnityAction onCampaignStart = global::Events.OnCampaignStart;
    if (onCampaignStart == null)
      return;
    onCampaignStart();
  }

  public static event UnityAction OnCampaignFinal;

  public static void InvokeCampaignFinal()
  {
    UnityAction onCampaignFinal = global::Events.OnCampaignFinal;
    if (onCampaignFinal == null)
      return;
    onCampaignFinal();
  }

  public static event UnityAction<Campaign.Result, CampaignStats, PlayerData> OnCampaignEnd;

  public static void InvokeCampaignEnd(
    Campaign.Result result,
    CampaignStats stats,
    PlayerData playerData)
  {
    UnityAction<Campaign.Result, CampaignStats, PlayerData> onCampaignEnd = global::Events.OnCampaignEnd;
    if (onCampaignEnd == null)
      return;
    onCampaignEnd(result, stats, playerData);
  }

  public static event UnityAction<CampaignStats> OnOverallStatsSaved;

  public static void InvokeOverallStatsSaved(CampaignStats stats)
  {
    UnityAction<CampaignStats> overallStatsSaved = global::Events.OnOverallStatsSaved;
    if (overallStatsSaved == null)
      return;
    overallStatsSaved(stats);
  }

  public static event UnityAction<CampaignData> OnCampaignDataCreated;

  public static void InvokeCampaignDataCreated(CampaignData data)
  {
    UnityAction<CampaignData> campaignDataCreated = global::Events.OnCampaignDataCreated;
    if (campaignDataCreated == null)
      return;
    campaignDataCreated(data);
  }

  public static event global::Events.RoutineAction OnCampaignPreInit;

  public static IEnumerator InvokeCampaignPreInit()
  {
    if (global::Events.OnCampaignPreInit != null)
      yield return (object) global::Events.OnCampaignPreInit();
  }

  public static event global::Events.RoutineAction OnCampaignInit;

  public static IEnumerator InvokeCampaignInit()
  {
    if (global::Events.OnCampaignInit != null)
      yield return (object) global::Events.OnCampaignInit();
  }

  public static event UnityAction OnPreCampaignPopulate;

  public static void InvokePreCampaignPopulate()
  {
    UnityAction campaignPopulate = global::Events.OnPreCampaignPopulate;
    if (campaignPopulate == null)
      return;
    campaignPopulate();
  }

  public static event global::Events.UnityActionRef1<List<CampaignGenerator.Node>, Vector2> OnCampaignNodesCreated;

  public static void InvokeCampaignNodesCreated(
    ref List<CampaignGenerator.Node> nodes,
    Vector2 nodeSpacing)
  {
    global::Events.UnityActionRef1<List<CampaignGenerator.Node>, Vector2> campaignNodesCreated = global::Events.OnCampaignNodesCreated;
    if (campaignNodesCreated == null)
      return;
    campaignNodesCreated(ref nodes, nodeSpacing);
  }

  public static event global::Events.UnityActionRef<string[]> OnCampaignLoadPreset;

  public static void InvokeCampaignLoadPreset(ref string[] lines)
  {
    global::Events.UnityActionRef<string[]> campaignLoadPreset = global::Events.OnCampaignLoadPreset;
    if (campaignLoadPreset == null)
      return;
    campaignLoadPreset(ref lines);
  }

  public static event global::Events.AsyncAction OnCampaignGenerated;

  public static IEnumerator InvokeCampaignGenerated()
  {
    if (global::Events.OnCampaignGenerated != null)
    {
      Delegate[] delegateArray = global::Events.OnCampaignGenerated.GetInvocationList();
      for (int index = 0; index < delegateArray.Length; ++index)
      {
        if (delegateArray[index] is global::Events.AsyncAction asyncAction)
        {
          Task task = asyncAction();
          yield return (object) new WaitUntil((Func<bool>) (() => task.IsCompleted));
        }
      }
      delegateArray = (Delegate[]) null;
    }
  }

  public static event UnityAction<string, string, int, int> OnStatChanged;

  public static void InvokeStatChanged(string stat, string key, int oldValue, int newValue)
  {
    UnityAction<string, string, int, int> onStatChanged = global::Events.OnStatChanged;
    if (onStatChanged == null)
      return;
    onStatChanged(stat, key, oldValue, newValue);
  }

  public static event UnityAction<CardUpgradeData> OnUpgradeGained;

  public static void InvokeUpgradeGained(CardUpgradeData upgradeData)
  {
    UnityAction<CardUpgradeData> onUpgradeGained = global::Events.OnUpgradeGained;
    if (onUpgradeGained == null)
      return;
    onUpgradeGained(upgradeData);
  }

  public static event UnityAction<Entity, CardUpgradeData> OnUpgradeAssign;

  public static void InvokeUpgradeAssign(Entity entity, CardUpgradeData upgradeData)
  {
    UnityAction<Entity, CardUpgradeData> onUpgradeAssign = global::Events.OnUpgradeAssign;
    if (onUpgradeAssign == null)
      return;
    onUpgradeAssign(entity, upgradeData);
  }

  public static event UnityAction<UpgradeDisplay> OnUpgradeHover;

  public static void InvokeUpgradeHover(UpgradeDisplay upgradeDisplay)
  {
    UnityAction<UpgradeDisplay> onUpgradeHover = global::Events.OnUpgradeHover;
    if (onUpgradeHover == null)
      return;
    onUpgradeHover(upgradeDisplay);
  }

  public static event UnityAction<UpgradeDisplay> OnUpgradePickup;

  public static void InvokeUpgradePickup(UpgradeDisplay upgradeDisplay)
  {
    UnityAction<UpgradeDisplay> onUpgradePickup = global::Events.OnUpgradePickup;
    if (onUpgradePickup == null)
      return;
    onUpgradePickup(upgradeDisplay);
  }

  public static event UnityAction<UpgradeDisplay> OnUpgradeDrop;

  public static void InvokeUpgradeDrop(UpgradeDisplay upgradeDisplay)
  {
    UnityAction<UpgradeDisplay> onUpgradeDrop = global::Events.OnUpgradeDrop;
    if (onUpgradeDrop == null)
      return;
    onUpgradeDrop(upgradeDisplay);
  }

  public static event UnityAction<bool> OnUpdateInputSystem;

  public static void InvokeUpdateInputSystem(bool forceTouch)
  {
    UnityAction<bool> updateInputSystem = global::Events.OnUpdateInputSystem;
    if (updateInputSystem == null)
      return;
    updateInputSystem(forceTouch);
  }

  public static event UnityAction<float, float?> OnScreenShake;

  public static void InvokeScreenShake(float magnitude = 1f, float? direction = 0.0f)
  {
    UnityAction<float, float?> onScreenShake = global::Events.OnScreenShake;
    if (onScreenShake == null)
      return;
    onScreenShake(magnitude, direction);
  }

  public static event global::Events.UnityAction<float, float, float, float, float, float> OnScreenRumble;

  public static void InvokeScreenRumble(
    float startStrength,
    float endStrength,
    float delay,
    float fadeInTime,
    float holdTime,
    float fadeOutTime)
  {
    global::Events.UnityAction<float, float, float, float, float, float> onScreenRumble = global::Events.OnScreenRumble;
    if (onScreenRumble == null)
      return;
    onScreenRumble(startStrength, endStrength, delay, fadeInTime, holdTime, fadeOutTime);
  }

  public static event UnityAction<string> OnCameraAnimation;

  public static void InvokeCameraAnimation(string name)
  {
    UnityAction<string> onCameraAnimation = global::Events.OnCameraAnimation;
    if (onCameraAnimation == null)
      return;
    onCameraAnimation(name);
  }

  public static event UnityAction<int, string, Character, Vector3> OnDropGold;

  public static void InvokeDropGold(int amount, string source, Character owner, Vector3 position)
  {
    UnityAction<int, string, Character, Vector3> onDropGold = global::Events.OnDropGold;
    if (onDropGold == null)
      return;
    onDropGold(amount, source, owner, position);
  }

  public static event UnityAction<int, Character, Vector3> OnGoldFlyToBag;

  public static void InvokeGoldFlyToBag(int amount, Character owner, Vector3 position)
  {
    UnityAction<int, Character, Vector3> onGoldFlyToBag = global::Events.OnGoldFlyToBag;
    if (onGoldFlyToBag == null)
      return;
    onGoldFlyToBag(amount, owner, position);
  }

  public static event UnityAction<int> OnCollectGold;

  public static void InvokeCollectGold(int amount)
  {
    UnityAction<int> onCollectGold = global::Events.OnCollectGold;
    if (onCollectGold == null)
      return;
    onCollectGold(amount);
  }

  public static event UnityAction<int> OnSpendGold;

  public static void InvokeSpendGold(int amount)
  {
    UnityAction<int> onSpendGold = global::Events.OnSpendGold;
    if (onSpendGold == null)
      return;
    onSpendGold(amount);
  }

  public static event UnityAction<float> OnTimeScaleChange;

  public static void InvokeTimeScaleChange(float value)
  {
    UnityAction<float> onTimeScaleChange = global::Events.OnTimeScaleChange;
    if (onTimeScaleChange == null)
      return;
    onTimeScaleChange(value);
  }

  public static event UnityAction<Entity> OnInspect;

  public static void InvokeInspect(Entity entity)
  {
    UnityAction<Entity> onInspect = global::Events.OnInspect;
    if (onInspect == null)
      return;
    onInspect(entity);
  }

  public static event UnityAction<Entity> OnInspectEnd;

  public static void InvokeInspectEnd(Entity entity)
  {
    UnityAction<Entity> onInspectEnd = global::Events.OnInspectEnd;
    if (onInspectEnd == null)
      return;
    onInspectEnd(entity);
  }

  public static event UnityAction<Entity> OnInspectNewCard;

  public static void InvokeInspectNewCard(Entity entity)
  {
    UnityAction<Entity> onInspectNewCard = global::Events.OnInspectNewCard;
    if (onInspectNewCard == null)
      return;
    onInspectNewCard(entity);
  }

  public static event UnityAction<CardController> OnCardControllerEnabled;

  public static void InvokeCardControllerEnabled(CardController controller)
  {
    UnityAction<CardController> controllerEnabled = global::Events.OnCardControllerEnabled;
    if (controllerEnabled == null)
      return;
    controllerEnabled(controller);
  }

  public static event UnityAction<CardController> OnCardControllerDisabled;

  public static void InvokeCardControllerDisabled(CardController controller)
  {
    UnityAction<CardController> controllerDisabled = global::Events.OnCardControllerDisabled;
    if (controllerDisabled == null)
      return;
    controllerDisabled(controller);
  }

  public static event UnityAction OnDeckpackOpen;

  public static void InvokeDeckpackOpen()
  {
    UnityAction onDeckpackOpen = global::Events.OnDeckpackOpen;
    if (onDeckpackOpen == null)
      return;
    onDeckpackOpen();
  }

  public static event UnityAction OnDeckpackClose;

  public static void InvokeDeckpackClose()
  {
    UnityAction onDeckpackClose = global::Events.OnDeckpackClose;
    if (onDeckpackClose == null)
      return;
    onDeckpackClose();
  }

  public static event UnityAction<TransitionType> OnTransitionStart;

  public static void InvokeTransitionStart(TransitionType transition)
  {
    UnityAction<TransitionType> onTransitionStart = global::Events.OnTransitionStart;
    if (onTransitionStart == null)
      return;
    onTransitionStart(transition);
  }

  public static event UnityAction<TransitionType> OnTransitionEnd;

  public static void InvokeTransitionEnd(TransitionType transition)
  {
    UnityAction<TransitionType> onTransitionEnd = global::Events.OnTransitionEnd;
    if (onTransitionEnd == null)
      return;
    onTransitionEnd(transition);
  }

  public static event UnityAction<float, float> OnSetWeatherIntensity;

  public static void InvokeSetWeatherIntensity(float amount, float updateDuration)
  {
    UnityAction<float, float> weatherIntensity = global::Events.OnSetWeatherIntensity;
    if (weatherIntensity == null)
      return;
    weatherIntensity(amount, updateDuration);
  }

  public static event UnityAction<GoldDisplay, float> OnGoldCounterStart;

  public static void InvokeGoldCounterStart(GoldDisplay goldDisplay, float addAmount)
  {
    UnityAction<GoldDisplay, float> goldCounterStart = global::Events.OnGoldCounterStart;
    if (goldCounterStart == null)
      return;
    goldCounterStart(goldDisplay, addAmount);
  }

  public static event UnityAction<CampaignNode, EventRoutine> OnEventStart;

  public static void InvokeEventStart(CampaignNode node, EventRoutine @event)
  {
    UnityAction<CampaignNode, EventRoutine> onEventStart = global::Events.OnEventStart;
    if (onEventStart == null)
      return;
    onEventStart(node, @event);
  }

  public static event UnityAction<EventRoutine> OnEventPopulated;

  public static void InvokeEventPopulated(EventRoutine @event)
  {
    UnityAction<EventRoutine> onEventPopulated = global::Events.OnEventPopulated;
    if (onEventPopulated == null)
      return;
    onEventPopulated(@event);
  }

  public static event UnityAction OnMuncherDrag;

  public static void InvokeMuncherDrag()
  {
    UnityAction onMuncherDrag = global::Events.OnMuncherDrag;
    if (onMuncherDrag == null)
      return;
    onMuncherDrag();
  }

  public static event UnityAction OnMuncherDragCancel;

  public static void InvokeMuncherDragCancel()
  {
    UnityAction muncherDragCancel = global::Events.OnMuncherDragCancel;
    if (muncherDragCancel == null)
      return;
    muncherDragCancel();
  }

  public static event UnityAction<Entity> OnMuncherFeed;

  public static void InvokeMuncherFeed(Entity entity)
  {
    UnityAction<Entity> onMuncherFeed = global::Events.OnMuncherFeed;
    if (onMuncherFeed == null)
      return;
    onMuncherFeed(entity);
  }

  public static event UnityAction<string, object> OnSettingChanged;

  public static void InvokeSettingChanged(string key, object value)
  {
    UnityAction<string, object> onSettingChanged = global::Events.OnSettingChanged;
    if (onSettingChanged == null)
      return;
    onSettingChanged(key, value);
  }

  public static event UnityAction OnUINavigationReset;

  public static void InvokeUINavigationReset()
  {
    UnityAction uiNavigationReset = global::Events.OnUINavigationReset;
    if (uiNavigationReset == null)
      return;
    uiNavigationReset();
  }

  public static event UnityAction OnUINavigation;

  public static void InvokeUINavigation()
  {
    UnityAction onUiNavigation = global::Events.OnUINavigation;
    if (onUiNavigation == null)
      return;
    onUiNavigation();
  }

  public static event UnityAction OnButtonStyleChanged;

  public static void InvokeButtonStyleChanged()
  {
    UnityAction buttonStyleChanged = global::Events.OnButtonStyleChanged;
    if (buttonStyleChanged == null)
      return;
    buttonStyleChanged();
  }

  public static event UnityAction OnControllerSwitched;

  public static void InvokeControllerSwitched()
  {
    UnityAction controllerSwitched = global::Events.OnControllerSwitched;
    if (controllerSwitched == null)
      return;
    controllerSwitched();
  }

  public static event global::Events.UnityActionRef<Entity, string, bool> OnCheckRename;

  public static bool CheckRename(ref Entity entity, ref string newName)
  {
    bool flag = true;
    global::Events.UnityActionRef<Entity, string, bool> onCheckRename = global::Events.OnCheckRename;
    if (onCheckRename != null)
      onCheckRename(ref entity, ref newName, ref flag);
    return flag;
  }

  public static event UnityAction<Entity, string> OnRename;

  public static void InvokeRename(Entity entity, string newName)
  {
    UnityAction<Entity, string> onRename = global::Events.OnRename;
    if (onRename == null)
      return;
    onRename(entity, newName);
  }

  public static event global::Events.UnityActionRef<object, string, int, List<DataFile>> OnPullRewards;

  public static List<DataFile> PullRewards(object pulledBy, string poolName, ref int count)
  {
    List<DataFile> dataFileList = new List<DataFile>();
    global::Events.UnityActionRef<object, string, int, List<DataFile>> onPullRewards = global::Events.OnPullRewards;
    if (onPullRewards != null)
      onPullRewards(pulledBy, ref poolName, ref count, ref dataFileList);
    return dataFileList;
  }

  public static event UnityAction<CardData> OnCardDataCreated;

  public static void InvokeCardDataCreated(CardData cardData)
  {
    UnityAction<CardData> onCardDataCreated = global::Events.OnCardDataCreated;
    if (onCardDataCreated == null)
      return;
    onCardDataCreated(cardData);
  }

  public static event UnityAction<int> OnTutorialProgress;

  public static void InvokeTutorialProgress(int value)
  {
    UnityAction<int> tutorialProgress = global::Events.OnTutorialProgress;
    if (tutorialProgress == null)
      return;
    tutorialProgress(value);
  }

  public static event UnityAction OnTutorialSkip;

  public static void InvokeTutorialSkip()
  {
    UnityAction onTutorialSkip = global::Events.OnTutorialSkip;
    if (onTutorialSkip == null)
      return;
    onTutorialSkip();
  }

  public static event UnityAction<ChallengeData> OnChallengeCompletedSaved;

  public static void InvokeChallengeCompletedSaved(ChallengeData challengeData)
  {
    UnityAction<ChallengeData> challengeCompletedSaved = global::Events.OnChallengeCompletedSaved;
    if (challengeCompletedSaved == null)
      return;
    challengeCompletedSaved(challengeData);
  }

  public static event global::Events.UnityActionRef<int> OnGetHandSize;

  public static int GetHandSize(int baseHandSize)
  {
    int handSize = baseHandSize;
    global::Events.UnityActionRef<int> onGetHandSize = global::Events.OnGetHandSize;
    if (onGetHandSize != null)
      onGetHandSize(ref handSize);
    return handSize;
  }

  public static event UnityAction<WildfrostMod> OnModLoaded;

  public static void InvokeModLoaded(WildfrostMod mod)
  {
    UnityAction<WildfrostMod> onModLoaded = global::Events.OnModLoaded;
    if (onModLoaded == null)
      return;
    onModLoaded(mod);
  }

  public static event UnityAction<WildfrostMod> OnModUnloaded;

  public static void InvokeModUnloaded(WildfrostMod mod)
  {
    UnityAction<WildfrostMod> onModUnloaded = global::Events.OnModUnloaded;
    if (onModUnloaded == null)
      return;
    onModUnloaded(mod);
  }

  public delegate void UnityActionRef<T>(ref T arg0);

  public delegate void UnityActionRef<T0, T1>(ref T0 arg0, ref T1 arg1);

  public delegate void UnityActionRef1<T0, T1>(ref T0 arg0, T1 arg1);

  public delegate void UnityActionRef<T0, T1, T2>(ref T0 arg0, ref T1 arg1, ref T2 arg2);

  public delegate void UnityActionRef<T0, T1, T2, T3>(
    T0 arg0,
    ref T1 arg1,
    ref T2 arg2,
    ref T3 arg3);

  public delegate void UnityActionCheck<T0, T1>(T0 arg0, ref T1 arg1);

  public delegate void UnityActionCheck<T0, T1, T2>(T0 arg0, T1 arg1, ref T2 arg2);

  public delegate void UnityAction<T0, T1, T2, T3, T4>(
    T0 arg0,
    T1 arg1,
    T2 arg2,
    T3 arg3,
    T4 arg4);

  public delegate void UnityAction<T0, T1, T2, T3, T4, T5>(
    T0 arg0,
    T1 arg1,
    T2 arg2,
    T3 arg3,
    T4 arg4,
    T5 arg5);

  public delegate IEnumerator RoutineAction();

  public delegate Task AsyncAction();

  public delegate IEnumerator RoutineAction<T>(T arg);
}
﻿// Decompiled with JetBrains decompiler
// Type: ExportCards
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.IO;
using UnityEngine;

public class ExportCards : MonoBehaviour
{
  [SerializeField]
  public string folder = nameof (ExportCards);
  public Camera _camera;

  public Camera camera => this._camera ?? (this._camera = Camera.main);

  public IEnumerator Start()
  {
    ExportCards exportCards = this;
    yield return (object) new WaitUntil((Func<bool>) (() => CardManager.init));
    foreach (CardData cardData1 in AddressableLoader.GetGroup<CardData>("CardData"))
    {
      CardData cardData = cardData1;
      if (!((UnityEngine.Object) cardData.mainSprite == (UnityEngine.Object) null) && !(cardData.mainSprite.name == "Nothing"))
      {
        Card card = CardManager.Get(cardData, (CardController) null, (Character) null, false, false);
        yield return (object) card.UpdateData(false);
        card.transform.position = Vector3.zero;
        yield return (object) null;
        exportCards.Screenshot(Application.dataPath + "/../" + exportCards.folder + "/" + cardData.cardType.name, card.titleText.text + " (" + card.name + ").png");
        yield return (object) null;
        CardManager.ReturnToPool(card);
        card = (Card) null;
        cardData = (CardData) null;
      }
    }
  }

  public void Screenshot(string directory, string fileName)
  {
    string str = directory + "/" + fileName;
    Texture2D tex = new Texture2D(Screen.width, Screen.height, TextureFormat.ARGB32, false);
    RenderTexture renderTexture = new RenderTexture(tex.width, tex.height, 24);
    this.camera.targetTexture = renderTexture;
    this.camera.Render();
    RenderTexture.active = renderTexture;
    tex.ReadPixels(new Rect(0.0f, 0.0f, (float) tex.width, (float) tex.height), 0, 0);
    tex.Apply();
    byte[] png = tex.EncodeToPNG();
    System.IO.Directory.CreateDirectory(directory);
    File.WriteAllBytes(str, png);
    Debug.Log((object) str);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EyeData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[CreateAssetMenu(fileName = "EyeData", menuName = "EyeData")]
public class EyeData : DataFile
{
  public string cardData;
  public EyeData.Eye[] eyes;

  public void Set(params EyePositionSaver[] eyePositions)
  {
    this.eyes = new EyeData.Eye[eyePositions.Length];
    int num = 0;
    foreach (EyePositionSaver eyePosition in eyePositions)
      this.eyes[num++] = new EyeData.Eye(eyePosition.transform);
  }

  [Serializable]
  public struct Eye
  {
    public Vector2 position;
    public Vector2 scale;
    public float rotation;

    public Eye(Transform transform)
    {
      this.position = (Vector2) transform.localPosition;
      this.scale = (Vector2) transform.localScale;
      this.rotation = transform.localEulerAngles.z;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EyePositionSaver
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class EyePositionSaver : MonoBehaviour
{
}
﻿// Decompiled with JetBrains decompiler
// Type: EyePupil
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class EyePupil : MonoBehaviour
{
  [SerializeField]
  public Transform target;
  [SerializeField]
  public AnimationCurve aimAmount;
  [SerializeField]
  public float lerp = 0.2f;
  public Vector3 targetPos;

  public void OnEnable() => global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);

  public void OnDisable() => global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);

  public void Update() => this.target.localPosition = Delta.Lerp(this.target.localPosition, this.targetPos, this.lerp, Time.deltaTime);

  public void EntityHover(Entity entity) => this.LookAt(entity.transform.position);

  public void LookAt(Vector3 worldPosition)
  {
    Vector3 vector3 = (worldPosition - this.transform.position).WithZ(0.0f);
    float num = this.aimAmount.Evaluate(vector3.magnitude);
    this.targetPos = vector3.normalized * num;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: EyeTrackerSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public static class EyeTrackerSystem
{
}
﻿// Decompiled with JetBrains decompiler
// Type: Fader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof (Graphic))]
public class Fader : MonoBehaviour
{
  public Graphic _graphic;
  [SerializeField]
  public Gradient gradient;
  [SerializeField]
  public bool startFadedIn;
  [SerializeField]
  public LeanTweenType ease = LeanTweenType.easeInOutQuad;
  [SerializeField]
  public float delay;
  [SerializeField]
  public float dur = 0.5f;
  [SerializeField]
  public bool onAwake;
  [SerializeField]
  public bool onEnable;
  [SerializeField]
  public bool loop;
  [SerializeField]
  public bool ignoreTimeScale;
  public float current;

  public Graphic graphic => this._graphic ?? (this._graphic = this.GetComponent<Graphic>());

  public void Awake()
  {
    this.Set(this.startFadedIn ? 1f : 0.0f);
    if (!this.onAwake)
      return;
    this.In();
  }

  public void OnEnable()
  {
    if (!this.onEnable)
      return;
    this.Set(0.0f);
    this.In();
  }

  public void Set(float value)
  {
    this.current = value;
    this.graphic.color = this.gradient.Evaluate(value);
  }

  public void In() => this.Tween(1f, this.dur, this.ease);

  public void In(float dur) => this.Tween(1f, dur, this.ease);

  public void In(float dur, LeanTweenType ease) => this.Tween(1f, dur, ease);

  public void Out() => this.Tween(0.0f, this.dur, this.ease);

  public void Out(float dur) => this.Tween(0.0f, dur, this.ease);

  public void Out(float dur, LeanTweenType ease) => this.Tween(0.0f, dur, ease);

  public void Tween(float to, float dur, LeanTweenType ease)
  {
    LeanTween.cancel(this.gameObject);
    LTDescr ltDescr = LeanTween.value(this.gameObject, this.current, to, dur).setDelay(this.delay).setEase(ease).setOnUpdate(new Action<float>(this.Set)).setIgnoreTimeScale(this.ignoreTimeScale);
    if (!this.loop)
      return;
    ltDescr.setLoopCount(-1);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FinalBossCardModifier
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Campaign/Final Boss Card Modifier", fileName = "Final Boss Card Modifier")]
public class FinalBossCardModifier : ScriptableObject
{
  public CardData card;
  public CardScript[] runAll;

  public void Run(CardData card)
  {
    foreach (CardScript cardScript in this.runAll)
    {
      Debug.Log((object) ("Running [" + cardScript.name + "] on " + card.name));
      cardScript.Run(card);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FinalBossDeckGenerationSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class FinalBossDeckGenerationSystem : GameSystem
{
  public void OnEnable() => global::Events.OnCampaignEnd += new UnityAction<Campaign.Result, CampaignStats, PlayerData>(FinalBossDeckGenerationSystem.CampaignEnd);

  public void OnDisable() => global::Events.OnCampaignEnd -= new UnityAction<Campaign.Result, CampaignStats, PlayerData>(FinalBossDeckGenerationSystem.CampaignEnd);

  public static void CampaignEnd(
    Campaign.Result result,
    CampaignStats stats,
    PlayerData playerData)
  {
    if (!Campaign.Data.GameMode.mainGameMode)
      return;
    if (FinalBossDeckGenerationSystem.CheckTrueWin(result))
    {
      FinalBossDeckGenerationSystem.RevertToDefaultBoss();
    }
    else
    {
      if (!FinalBossDeckGenerationSystem.CheckResult(result))
        return;
      FinalBossDeckGenerationSystem.SetNewBoss(playerData);
    }
  }

  public static bool CheckResult(Campaign.Result result)
  {
    bool flag = SaveSystem.LoadCampaignData<bool>(Campaign.Data.GameMode, "trueWin", false);
    return result == Campaign.Result.Win && !flag || result != Campaign.Result.Win & flag;
  }

  public static bool CheckTrueWin(Campaign.Result result)
  {
    bool flag = SaveSystem.LoadCampaignData<bool>(Campaign.Data.GameMode, "trueWin", false);
    return result == Campaign.Result.Win & flag;
  }

  public static void SetNewBoss(PlayerData playerData)
  {
    SaveSystem.SaveProgressData<CardSaveData[]>("finalBossDeck", playerData.inventory.deck.SaveArray<CardData, CardSaveData>());
    SaveSystem.SaveProgressData<bool>("newFinalBoss", true);
    Debug.Log((object) ("~ Player's Deck Saved! [" + string.Join(", ", playerData.inventory.deck.Select<CardData, string>((Func<CardData, string>) (a => a.name))) + "]"));
  }

  public static void RevertToDefaultBoss()
  {
    SaveSystem.DeleteProgressData("finalBossDeck");
    SaveSystem.DeleteProgressData("newFinalBoss");
    Debug.Log((object) "~ TRUE VICTORY! Reverting Final Boss To Default");
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FinalBossEffectSwapper
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Campaign/Final Boss Effect Swapper", fileName = "Final Boss Effect Swapper")]
public class FinalBossEffectSwapper : ScriptableObject
{
  public StatusEffectData effect;
  public bool remove = true;
  [ShowIf("remove")]
  public StatusEffectData[] replaceWithOptions;
  [ShowIf("remove")]
  public StatusEffectData replaceWithAttackEffect;
  public Vector2Int boostRange;

  public void Process(CardData card, CardData.StatusEffectStacks stack, int stackIndex)
  {
    if (this.remove)
    {
      List<CardData.StatusEffectStacks> list = card.startWithEffects.ToList<CardData.StatusEffectStacks>();
      if (this.replaceWithOptions.Length != 0)
        stack.data = this.replaceWithOptions.RandomItem<StatusEffectData>();
      else
        list.RemoveAt(stackIndex);
      if ((bool) (Object) this.replaceWithAttackEffect)
      {
        CardData.StatusEffectStacks statusEffectStacks = new CardData.StatusEffectStacks(this.replaceWithAttackEffect, stack.count + this.boostRange.Random());
        card.attackEffects = CardData.StatusEffectStacks.Stack((IEnumerable<CardData.StatusEffectStacks>) card.attackEffects, (IEnumerable<CardData.StatusEffectStacks>) new CardData.StatusEffectStacks[1]
        {
          statusEffectStacks
        });
      }
      card.startWithEffects = list.ToArray();
    }
    stack.count += this.boostRange.Random();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FinalBossEnemyGenerator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Campaign/Final Boss Enemy Generator", fileName = "Final Boss Enemy Generator")]
public class FinalBossEnemyGenerator : ScriptableObject
{
  public CardData enemy;
  public CardData[] fromCards;
}
﻿// Decompiled with JetBrains decompiler
// Type: FinalBossGenerationSettings
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(menuName = "Campaign/Final Boss Generation Settings", fileName = "FinalBossGenerationSettings")]
public class FinalBossGenerationSettings : ScriptableObject
{
  [Header("Replace cards...")]
  [SerializeField]
  public FinalBossGenerationSettings.ReplaceCard[] replaceCards;
  [Header("Things to ignore...")]
  [SerializeField]
  public CardUpgradeData[] ignoreUpgrades;
  [SerializeField]
  public TraitData[] ignoreTraits;
  [Header("Effects to change...")]
  [SerializeField]
  public FinalBossEffectSwapper[] effectSwappers;
  [Header("Scripts to run on cards...")]
  [SerializeField]
  public CardScript[] runOnAll;
  [SerializeField]
  public FinalBossCardModifier[] cardModifiers;
  [SerializeField]
  public CardScript[] leaderScripts;
  [Header("New enemies to add")]
  [SerializeField]
  public FinalBossEnemyGenerator[] enemyOptions;

  public void ReplaceCards(IList<CardData> cards)
  {
    foreach (FinalBossGenerationSettings.ReplaceCard replaceCard in this.replaceCards)
    {
      FinalBossGenerationSettings.ReplaceCard replace = replaceCard;
      foreach (CardData cardData1 in cards.Where<CardData>((Func<CardData, bool>) (a => a.name == replace.card.name)).ToArray<CardData>())
      {
        int index = cards.IndexOf(cardData1);
        CardData cardData2 = replace.options.RandomItem<CardData>();
        cards.RemoveAt(index);
        cards.Insert(index, cardData2);
        Debug.Log((object) (replace.card.name + " Replaced With " + cardData2.name));
      }
    }
  }

  public void Process(CardData leader, IList<CardData> cards)
  {
    FinalBossGenerationSettings.RemoveInjuries((IEnumerable<CardData>) cards);
    this.RemoveUpgrades(cards);
    this.RemoveTraits(cards);
    this.ProcessEffects((IEnumerable<CardData>) cards);
    this.RunScripts(leader, cards);
  }

  public IEnumerable<CardData> GenerateBonusEnemies(
    int count,
    IEnumerable<CardData> basedOnDeck,
    CardData[] defaultEnemies)
  {
    WeightedRandomPool<CardData> weightedRandomPool = new WeightedRandomPool<CardData>();
    foreach (CardData cardData in basedOnDeck)
    {
      CardData card = cardData;
      FinalBossEnemyGenerator bossEnemyGenerator = ((IEnumerable<FinalBossEnemyGenerator>) this.enemyOptions).FirstOrDefault<FinalBossEnemyGenerator>((Func<FinalBossEnemyGenerator, bool>) (a => ((IEnumerable<CardData>) a.fromCards).Any<CardData>((Func<CardData, bool>) (b => b.name == card.name))));
      if ((bool) (UnityEngine.Object) bossEnemyGenerator)
      {
        weightedRandomPool.Add(bossEnemyGenerator.enemy);
        Debug.Log((object) string.Format("{0} added to weighted pool", (object) bossEnemyGenerator.enemy));
      }
    }
    List<CardData> bonusEnemies = new List<CardData>();
    int num = Mathf.Min(count, weightedRandomPool.Count);
    for (int index = 0; index < num; ++index)
    {
      CardData cardData = weightedRandomPool.Pull().Clone();
      bonusEnemies.Add(cardData);
    }
    if (bonusEnemies.Count < count)
    {
      foreach (CardData cardData in (IEnumerable<CardData>) ((IEnumerable<CardData>) defaultEnemies).InRandomOrder<CardData>())
      {
        bonusEnemies.Add(cardData.Clone());
        if (bonusEnemies.Count >= count)
          break;
      }
    }
    return (IEnumerable<CardData>) bonusEnemies;
  }

  public static void RemoveInjuries(IEnumerable<CardData> cards)
  {
    foreach (CardData card in cards)
    {
      if (card.injuries != null && card.injuries.Count > 0)
      {
        card.injuries.Clear();
        Debug.Log((object) ("Injuries removed from " + card.name));
      }
    }
  }

  public void RemoveUpgrades(IList<CardData> cards)
  {
    foreach (CardUpgradeData ignoreUpgrade in this.ignoreUpgrades)
    {
      foreach (CardData card in (IEnumerable<CardData>) cards)
      {
        if (card.upgrades.Contains(ignoreUpgrade))
        {
          ignoreUpgrade.UnAssign(card);
          Debug.Log((object) ("[" + ignoreUpgrade.name + "] Removed from " + card.name));
        }
      }
    }
  }

  public void ProcessEffects(IEnumerable<CardData> cards)
  {
    Dictionary<string, FinalBossEffectSwapper> dictionary = new Dictionary<string, FinalBossEffectSwapper>();
    foreach (FinalBossEffectSwapper effectSwapper in this.effectSwappers)
      dictionary[effectSwapper.effect.name] = effectSwapper;
    foreach (CardData card in cards)
    {
      for (int stackIndex = card.startWithEffects.Length - 1; stackIndex >= 0; --stackIndex)
      {
        CardData.StatusEffectStacks startWithEffect = card.startWithEffects[stackIndex];
        FinalBossEffectSwapper bossEffectSwapper;
        if ((bool) (UnityEngine.Object) startWithEffect.data && dictionary.TryGetValue(startWithEffect.data.name, out bossEffectSwapper))
          bossEffectSwapper.Process(card, startWithEffect, stackIndex);
      }
    }
  }

  public void RemoveTraits(IList<CardData> cards)
  {
    foreach (TraitData ignoreTrait in this.ignoreTraits)
    {
      TraitData trait = ignoreTrait;
      foreach (CardData card in (IEnumerable<CardData>) cards)
      {
        CardData.TraitStacks traitStacks = card.traits.FirstOrDefault<CardData.TraitStacks>((Func<CardData.TraitStacks, bool>) (a => a.data.name == trait.name));
        if (traitStacks != null)
        {
          card.traits.Remove(traitStacks);
          Debug.Log((object) string.Format("[{0}] Removed from {1}", (object) trait, (object) card.name));
        }
      }
    }
  }

  public void RunScripts(CardData leader, IList<CardData> cards)
  {
    foreach (CardScript cardScript in this.runOnAll)
    {
      foreach (CardData card in (IEnumerable<CardData>) cards)
      {
        Debug.Log((object) ("Running [" + cardScript.name + "] on " + card.name));
        cardScript.Run(card);
      }
    }
    foreach (CardData card1 in (IEnumerable<CardData>) cards)
    {
      CardData card = card1;
      FinalBossCardModifier bossCardModifier = ((IEnumerable<FinalBossCardModifier>) this.cardModifiers).FirstOrDefault<FinalBossCardModifier>((Func<FinalBossCardModifier, bool>) (a => a.card.name == card.name));
      if ((bool) (UnityEngine.Object) bossCardModifier)
        bossCardModifier.Run(card);
    }
    if (!(bool) (UnityEngine.Object) leader)
      return;
    foreach (CardScript leaderScript in this.leaderScripts)
      leaderScript.Run(leader);
  }

  [Serializable]
  public struct ReplaceCard
  {
    public CardData card;
    public CardData[] options;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FinalBossSequenceSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System;
using System.Collections;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class FinalBossSequenceSystem : GameSystem
{
  [SerializeField]
  public WispAnimator wispPrefab;
  [SerializeField]
  public Canvas canvas;
  [SerializeField]
  public Image background;
  [SerializeField]
  public ParticleSystem blipFX;
  [SerializeField]
  public ParticleSystem bigBlipFX;
  [SerializeField]
  public AnimationCurve hitMoveCurve;
  [SerializeField]
  public AnimationCurve hitRotateCurve;
  [SerializeField]
  public string sealCard = "LuminVase";
  [SerializeField]
  public Color possessFlashColor;
  [FormerlySerializedAs("flashColor")]
  [SerializeField]
  public Color luminFlashColor;
  [SerializeField]
  public LocalizedString continueKey;
  [SerializeField]
  public LocalizedString throwKey;
  [Header("SFX")]
  [SerializeField]
  public EventReference shadeSpawnSfxEvent;
  [SerializeField]
  public EventReference shadeFleeSfxEvent;
  [SerializeField]
  public EventReference shadeMoveSfxEvent;
  [SerializeField]
  public EventReference shadeFlashSfxEvent;
  [SerializeField]
  public EventReference cameraInSfxEvent;
  [SerializeField]
  public EventReference cameraOutHeroSfxEvent;
  [SerializeField]
  public EventReference cameraOutVaseSfxEvent;
  [SerializeField]
  public EventReference shakeHeroSfxEvent;
  [SerializeField]
  public EventReference shakeVaseSfxEvent;
  [SerializeField]
  public EventReference vaseSpawnSfxEvent;
  [SerializeField]
  public EventReference hitHeroSfxEvent;
  [SerializeField]
  public EventReference hitVaseSfxEvent;
  [SerializeField]
  public EventReference pingHeroSfxEvent;
  [SerializeField]
  public EventReference pingVaseSfxEvent;
  [SerializeField]
  public SfxLoop darkLoop;
  [SerializeField]
  public SfxLoop brightLoop;
  [SerializeField]
  public SfxLoop shadeLoop;
  public WispAnimator wisp;
  public bool running;
  public bool blockWisp;
  public Entity leader;
  public Entity blockCard;
  public CampaignNode playerNode;

  public void OnEnable()
  {
    global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.PreBattleEnd += new global::Events.AsyncAction(this.PreBattleEnd);
    this.playerNode = Campaign.FindCharacterNode(References.Player);
    if (this.playerNode.finalNode && Campaign.Data.GameMode.mainGameMode)
      return;
    UnityEngine.Object.Destroy((UnityEngine.Object) this);
  }

  public void OnDisable()
  {
    global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.PreBattleEnd -= new global::Events.AsyncAction(this.PreBattleEnd);
  }

  public void EntityKilled(Entity entity, DeathType type)
  {
    if (!(bool) (UnityEngine.Object) References.Battle || !entity.data.cardType.miniboss || entity.owner.team != References.Battle.enemy.team || References.Battle.minibosses.Count<Entity>((Func<Entity, bool>) (a => (UnityEngine.Object) a != (UnityEngine.Object) entity && a.owner.team == References.Battle.enemy.team)) > 0)
      return;
    this.wisp = UnityEngine.Object.Instantiate<WispAnimator>(this.wispPrefab, entity.transform.position, Quaternion.identity, this.transform);
    this.wisp.KnockBackFrom(Vector3.zero);
    this.leader = Battle.GetCards(References.Battle.player).FirstOrDefault<Entity>((Func<Entity, bool>) (a => a.data.cardType.miniboss));
    if ((bool) (UnityEngine.Object) this.leader && this.leader.IsAliveAndExists())
      this.wisp.SetTarget(this.leader.transform);
    SfxSystem.OneShot(this.shadeSpawnSfxEvent);
    this.shadeLoop.Play();
  }

  public async Task PreBattleEnd()
  {
    FinalBossSequenceSystem bossSequenceSystem = this;
    if (!(bool) (UnityEngine.Object) bossSequenceSystem.wisp)
      return;
    if (!bossSequenceSystem.wisp.TargetExists())
    {
      bossSequenceSystem.wisp.maxSpeed = 0.0f;
      bossSequenceSystem.wisp.gravitate *= 0.5f;
    }
    else
    {
      if (!bossSequenceSystem.playerNode.finalNode)
        bossSequenceSystem.StartCoroutine(bossSequenceSystem.Flee());
      else
        bossSequenceSystem.StartCoroutine(bossSequenceSystem.PossessLeader());
      while (bossSequenceSystem.running)
        await Task.Delay(25);
    }
  }

  public IEnumerator PossessLeader()
  {
    FinalBossSequenceSystem bossSequenceSystem = this;
    if (bossSequenceSystem.leader.IsAliveAndExists())
    {
      PauseMenu.Block();
      bossSequenceSystem.running = true;
      CardData blockCardData = bossSequenceSystem.GetBlockCard();
      bossSequenceSystem.blockWisp = (bool) (UnityEngine.Object) blockCardData;
      if (!bossSequenceSystem.blockWisp)
        References.LeaderData.SetCustomData("eyes", (object) "frost");
      bossSequenceSystem.wisp.maxSpeed = 0.0f;
      bossSequenceSystem.wisp.gravitate *= 0.5f;
      yield return (object) new WaitForSeconds(1f);
      AmbienceSystem.SetParam("shade_visit", 1f);
      SfxSystem.OneShot(bossSequenceSystem.cameraInSfxEvent);
      if (bossSequenceSystem.blockWisp)
        bossSequenceSystem.brightLoop.Play();
      else
        bossSequenceSystem.darkLoop.Play();
      CinemaBarSystem.In();
      CinemaBarSystem.SetSortingLayer("Inspect", 1);
      bossSequenceSystem.canvas.gameObject.SetActive(true);
      bossSequenceSystem.leader.transform.SetParent(bossSequenceSystem.canvas.transform);
      Vector2 v = new Vector2(1.5f, 2f);
      LeanTween.move(bossSequenceSystem.leader.gameObject, new Vector3(-3f, 0.25f, -3f), v.Random()).setEase(LeanTweenType.easeInOutQuart);
      LeanTween.move(bossSequenceSystem.wisp.gameObject, new Vector3(3f, 0.25f, -3f), v.Random()).setEase(LeanTweenType.easeInOutQuart);
      bossSequenceSystem.wisp.SetSortingLayer("Inspect", 1);
      yield return (object) new WaitForSeconds(v.y);
      if (bossSequenceSystem.blockWisp)
        yield return (object) bossSequenceSystem.BlockWisp(blockCardData);
      SfxSystem.OneShot(bossSequenceSystem.shadeMoveSfxEvent);
      SfxSystem.OneShot(bossSequenceSystem.shadeFlashSfxEvent);
      bossSequenceSystem.wisp.JumpToTarget();
      bossSequenceSystem.wisp.FadeToColour(new Color(0.6f, 0.2f, 1f), 0.5f, 0.4f);
      global::Events.InvokeScreenRumble(1f, 0.0f, 0.0f, 0.1f, 0.9f, 1f / 1000f);
      yield return (object) new WaitForSeconds(1f);
      global::Events.InvokeScreenShake();
      bossSequenceSystem.wisp.gameObject.Destroy();
      bossSequenceSystem.blipFX.transform.position = bossSequenceSystem.wisp.transform.position;
      bossSequenceSystem.blipFX.Play();
      bossSequenceSystem.shadeLoop.Stop();
      Entity hitCard = bossSequenceSystem.leader;
      if (bossSequenceSystem.blockWisp)
      {
        SfxSystem.OneShot(bossSequenceSystem.hitVaseSfxEvent);
        hitCard = bossSequenceSystem.blockCard;
        bossSequenceSystem.ReturnLeader();
      }
      else
        SfxSystem.OneShot(bossSequenceSystem.hitHeroSfxEvent);
      LeanTween.value(bossSequenceSystem.gameObject, Time.timeScale, 0.1f, 0.05f).setEase(LeanTweenType.linear).setOnUpdate(new Action<float>(global::Events.InvokeTimeScaleChange));
      ScreenFlashSystem.SetDrawOrder("ParticlesFront", 999);
      if (bossSequenceSystem.blockWisp)
      {
        ScreenFlashSystem.SetColour(bossSequenceSystem.luminFlashColor);
        ScreenFlashSystem.Run(0.25f);
      }
      else
      {
        ScreenFlashSystem.SetColour(bossSequenceSystem.possessFlashColor);
        ScreenFlashSystem.SetMaterialAdditive();
        ScreenFlashSystem.Run(0.15f);
      }
      hitCard.wobbler.WobbleRandom();
      double num1 = (double) hitCard.curveAnimator.Move(new Vector3(-2f, 0.0f, 0.0f), bossSequenceSystem.hitMoveCurve, 0.0f, 1f);
      double num2 = (double) hitCard.curveAnimator.Rotate(new Vector3(0.0f, 0.0f, 10f), bossSequenceSystem.hitRotateCurve, 1f);
      yield return (object) new WaitForSeconds(0.25f);
      LeanTween.value(bossSequenceSystem.gameObject, Time.timeScale, 1f, 0.25f).setEase(LeanTweenType.linear).setOnUpdate(new Action<float>(global::Events.InvokeTimeScaleChange));
      yield return (object) new WaitForSeconds(0.25f);
      SfxSystem.OneShot(bossSequenceSystem.blockWisp ? bossSequenceSystem.shakeVaseSfxEvent : bossSequenceSystem.shakeHeroSfxEvent);
      FinalBossSequenceSystem.ZoomInOn(hitCard.gameObject);
      global::Events.InvokeScreenRumble(0.0f, 1f, 0.4f, 0.3f, 0.2f, 0.1f);
      if (bossSequenceSystem.blockWisp)
        LeanTween.value(1f, 0.9f, 1f).setEaseInOutQuart().setOnUpdate(new Action<float>(bossSequenceSystem.\u003CPossessLeader\u003Eb__39_0));
      yield return (object) new WaitForSeconds(1.1f);
      bossSequenceSystem.brightLoop.Stop();
      bossSequenceSystem.darkLoop.Stop();
      SfxSystem.OneShot(bossSequenceSystem.blockWisp ? bossSequenceSystem.pingVaseSfxEvent : bossSequenceSystem.pingHeroSfxEvent);
      bossSequenceSystem.Ping(hitCard);
      if (!bossSequenceSystem.blockWisp)
        FrostEyeSystem.Create(bossSequenceSystem.leader);
      CinemaBarSystem.Top.SetPrompt(bossSequenceSystem.continueKey.GetLocalizedString(), "Select");
      yield return (object) new WaitUntil(new Func<bool>(InputSystem.IsSelectPressed));
      AmbienceSystem.SetParam("shade_visit", 0.0f);
      bossSequenceSystem.canvas.gameObject.SetActive(false);
      if (bossSequenceSystem.blockWisp)
      {
        CardManager.ReturnToPool(bossSequenceSystem.blockCard);
        SfxSystem.OneShot(bossSequenceSystem.cameraOutVaseSfxEvent);
      }
      else
      {
        bossSequenceSystem.ReturnLeader();
        SfxSystem.OneShot(bossSequenceSystem.cameraOutHeroSfxEvent);
      }
      CinemaBarSystem.Out();
      CinemaBarSystem.SetSortingLayer("CinemaBars");
      bossSequenceSystem.running = false;
      PauseMenu.Unblock();
    }
  }

  public CardData GetBlockCard() => References.PlayerData.inventory.deck.FirstOrDefault<CardData>((Func<CardData, bool>) (a => a.name == this.sealCard));

  public IEnumerator BlockWisp(CardData blockCardData)
  {
    FinalBossSequenceSystem bossSequenceSystem = this;
    bossSequenceSystem.blockCard = CardManager.Get(blockCardData, bossSequenceSystem.leader.display.hover.controller, bossSequenceSystem.leader.owner, true, true).entity;
    yield return (object) bossSequenceSystem.blockCard.display.UpdateData();
    SfxSystem.OneShot(bossSequenceSystem.vaseSpawnSfxEvent);
    LeanTween.value(bossSequenceSystem.gameObject, Time.timeScale, 0.1f, 0.25f).setEase(LeanTweenType.linear).setOnUpdate(new Action<float>(global::Events.InvokeTimeScaleChange));
    bossSequenceSystem.blockCard.transform.localScale = bossSequenceSystem.leader.transform.localScale;
    bossSequenceSystem.blockCard.transform.SetParent(bossSequenceSystem.canvas.transform);
    bossSequenceSystem.blockCard.transform.SetPositionAndRotation(new Vector3(0.0f, -5f, -2f), Quaternion.identity);
    LeanTween.move(bossSequenceSystem.blockCard.gameObject, bossSequenceSystem.blockCard.transform.position.WithY(-3f), 0.5f).setIgnoreTimeScale(true).setEaseOutBack();
    bossSequenceSystem.blockCard.DrawOrder = 2;
    CinemaBarSystem.Top.SetPrompt(bossSequenceSystem.throwKey.GetLocalizedString().Format((object) blockCardData.title), "Select");
    yield return (object) new WaitUntil(new Func<bool>(InputSystem.IsSelectPressed));
    CinemaBarSystem.Top.RemovePrompt();
    LeanTween.move(bossSequenceSystem.blockCard.gameObject, bossSequenceSystem.leader.transform.position.WithX(-2.5f), 1f).setEaseOutQuint();
    LeanTween.move(bossSequenceSystem.leader.gameObject, bossSequenceSystem.leader.transform.position.WithX(-5f), 0.75f).setEaseOutQuint();
    LeanTween.value(bossSequenceSystem.gameObject, Time.timeScale, 1f, 0.15f).setEase(LeanTweenType.linear).setOnUpdate(new Action<float>(global::Events.InvokeTimeScaleChange));
  }

  public IEnumerator Flee()
  {
    SfxSystem.OneShot(this.shadeFleeSfxEvent);
    this.shadeLoop.Stop();
    this.running = true;
    this.wisp.SetTarget(References.Battle.enemy.reserveContainer.transform);
    this.wisp.JumpToTarget();
    yield return (object) new WaitForSeconds(1f);
    this.running = false;
  }

  public static void ZoomInOn(GameObject target, float zPos = -2f)
  {
    LeanTween.cancel(target);
    LeanTween.moveLocal(target, Vector3.zero.WithZ(zPos), 0.5f).setEase(LeanTweenType.easeInOutQuad);
    LeanTween.rotateLocal(target, Vector3.zero, 0.5f).setEase(LeanTweenType.easeInOutQuad);
  }

  public void Ping(Entity entity)
  {
    double num = (double) entity.curveAnimator.Ping();
    entity.wobbler.WobbleRandom(2f);
    global::Events.InvokeScreenShake(2f);
    this.bigBlipFX.transform.position = entity.transform.position;
    this.bigBlipFX.Play();
  }

  public void ReturnLeader()
  {
    this.leader.transform.SetParent((Transform) this.leader.actualContainers[0].holder);
    this.leader.TweenToContainer();
    this.leader.wobbler.WobbleRandom();
  }

  [CompilerGenerated]
  public void \u003CPossessLeader\u003Eb__39_0(float a) => this.background.color = this.background.color.WithAlpha(a);

  [CompilerGenerated]
  public bool \u003CGetBlockCard\u003Eb__40_0(CardData a) => a.name == this.sealCard;
}
﻿// Decompiled with JetBrains decompiler
// Type: Fitter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

public class Fitter : MonoBehaviourRect
{
  [SerializeField]
  public Fitter[] linkedFitters;
  public Vector2 padding;
  public bool widthFixed = true;
  [ShowIf("widthFixed")]
  public float fixedWidth = 2.4f;
  [HideIf("widthFixed")]
  public float minWidth = 2.4f;
  public bool heightFixed;
  [ShowIf("heightFixed")]
  public float fixedHeight = 0.5f;
  [HideIf("heightFixed")]
  public float minHeight = 0.5f;

  public void Fit(System.Action onComplete) => this.StartCoroutine(this.FitRoutine(onComplete));

  public void SetSize(float w, float h) => this.rectTransform.sizeDelta = new Vector2(w, h) + this.padding;

  public virtual IEnumerator FitRoutine(System.Action onComplete)
  {
    Fitter fitter = this;
    float w = fitter.fixedWidth;
    float h = fitter.fixedHeight;
    if (!fitter.widthFixed && !fitter.heightFixed)
    {
      float a1;
      float a2 = a1 = fitter.rectTransform.localPosition.x;
      float a3;
      float a4 = a3 = fitter.rectTransform.localPosition.y;
      foreach (RectTransform rectTransform in (Transform) fitter.rectTransform)
      {
        Vector2 vector2 = rectTransform.sizeDelta * 0.5f;
        Vector3 localPosition = rectTransform.localPosition;
        a2 = Mathf.Min(a2, localPosition.x - vector2.x);
        a4 = Mathf.Min(a4, localPosition.y - vector2.y);
        a1 = Mathf.Max(a1, localPosition.x + vector2.x);
        a3 = Mathf.Max(a3, localPosition.y + vector2.y);
      }
      w = a1 - a2;
      h = a3 - a4;
    }
    else
    {
      if (!fitter.widthFixed)
      {
        float a5;
        float a6 = a5 = 0.0f;
        foreach (RectTransform rectTransform in (Transform) fitter.rectTransform)
        {
          Vector2 vector2 = rectTransform.sizeDelta * 0.5f;
          Vector3 localPosition = rectTransform.localPosition;
          a6 = Mathf.Min(a6, localPosition.x - vector2.x);
          a5 = Mathf.Max(a5, localPosition.x + vector2.x);
        }
        w = Mathf.Max(fitter.minWidth, a5 - a6);
      }
      if (!fitter.heightFixed)
      {
        float a7;
        float a8 = a7 = 0.0f;
        foreach (RectTransform rectTransform in (Transform) fitter.rectTransform)
        {
          Vector2 vector2 = rectTransform.sizeDelta * 0.5f;
          Vector3 localPosition = rectTransform.localPosition;
          a8 = Mathf.Min(a8, localPosition.y - vector2.y);
          a7 = Mathf.Max(a7, localPosition.y + vector2.y);
        }
        h = Mathf.Max(fitter.minHeight, a7 - a8);
      }
    }
    fitter.SetSize(w, h);
    yield return (object) fitter.UpdateLinkedFitters();
    System.Action action = onComplete;
    if (action != null)
      action();
  }

  public IEnumerator UpdateLinkedFitters()
  {
    Fitter[] fitterArray = this.linkedFitters;
    for (int index = 0; index < fitterArray.Length; ++index)
      yield return (object) fitterArray[index].FitRoutine((System.Action) null);
    fitterArray = (Fitter[]) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FleeSfxSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using FMODUnity;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class FleeSfxSystem : GameSystem
{
  [SerializeField]
  public float globalChance = 1f;
  [SerializeField]
  public FleeSfxSystem.Profile[] profiles;
  [SerializeField]
  public EventReference fallbackEnemy;
  [SerializeField]
  public EventReference fallbackPlayer;
  [SerializeField]
  public CardData[] excludeFromFallback;
  public readonly Dictionary<string, FleeSfxSystem.Profile> profileLookup = new Dictionary<string, FleeSfxSystem.Profile>();

  public void OnEnable()
  {
    global::Events.OnEntityFlee += new UnityAction<Entity>(this.EntityFlee);
    this.profileLookup.Clear();
    foreach (FleeSfxSystem.Profile profile in this.profiles)
    {
      foreach (UnityEngine.Object card in profile.cards)
        this.profileLookup[card.name] = profile;
    }
  }

  public void OnDisable() => global::Events.OnEntityFlee -= new UnityAction<Entity>(this.EntityFlee);

  public void EntityFlee(Entity entity)
  {
    FleeSfxSystem.Profile profile;
    if (this.profileLookup.TryGetValue(entity.data.name, out profile))
    {
      if (!FleeSfxSystem.CheckChance(profile.chance * this.globalChance))
        return;
      SfxSystem.OneShot(profile.eventReference);
    }
    else
    {
      if (!((IEnumerable<CardData>) this.excludeFromFallback).All<CardData>((Func<CardData, bool>) (a => a.name != entity.data.name)) || !FleeSfxSystem.CheckChance(this.globalChance))
        return;
      SfxSystem.OneShot(entity.owner.team == References.Player.team ? this.fallbackPlayer : this.fallbackEnemy);
      SfxSystem.OneShot(this.fallbackEnemy);
    }
  }

  public static bool CheckChance(float chance) => (double) PettyRandom.Range(0.0f, 1f) < (double) chance;

  [Serializable]
  public class Profile
  {
    public EventReference eventReference;
    public CardData[] cards;
    public float chance;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FlexibleGridLayout
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class FlexibleGridLayout : LayoutGroup
{
  public FlexibleGridLayout.FitType fitType;
  public int rows;
  public int columns;
  public Vector2 cellSize;
  public Vector2 spacing;
  public bool autoSizeX;
  public bool autoSizeY;

  public override void CalculateLayoutInputHorizontal()
  {
    base.CalculateLayoutInputHorizontal();
    this.autoSizeX = false;
    this.autoSizeY = false;
    if (this.fitType == FlexibleGridLayout.FitType.Width || this.fitType == FlexibleGridLayout.FitType.Height || this.fitType == FlexibleGridLayout.FitType.Uniform)
    {
      this.autoSizeX = true;
      this.autoSizeY = true;
      float f = Mathf.Sqrt((float) this.transform.childCount);
      this.rows = Mathf.CeilToInt(f);
      this.columns = Mathf.CeilToInt(f);
    }
    switch (this.fitType)
    {
      case FlexibleGridLayout.FitType.Width:
      case FlexibleGridLayout.FitType.FixedColumns:
        this.rows = Mathf.CeilToInt((float) (this.transform.childCount / this.columns));
        break;
      case FlexibleGridLayout.FitType.Height:
      case FlexibleGridLayout.FitType.FixedRows:
        this.columns = Mathf.CeilToInt((float) (this.transform.childCount / this.rows));
        break;
    }
    Rect rect = this.rectTransform.rect;
    float width = rect.width;
    rect = this.rectTransform.rect;
    float height = rect.height;
    if (this.autoSizeX)
      this.cellSize.x = (float) ((double) width / (double) this.columns - (double) this.spacing.x / (double) this.columns * (double) (this.columns - 1)) - (float) (this.padding.left / this.columns) - (float) (this.padding.right / this.columns);
    if (this.autoSizeY)
      this.cellSize.y = (float) ((double) height / (double) this.rows - (double) this.spacing.y / (double) this.rows * (double) (this.columns - 1)) - (float) (this.padding.top / this.rows) - (float) (this.padding.bottom / this.rows);
    for (int index = 0; index < this.rectChildren.Count; ++index)
    {
      int num1 = index / this.columns;
      int num2 = index % this.columns;
      RectTransform rectChild = this.rectChildren[index];
      float pos1 = (float) ((double) this.cellSize.x * (double) num2 + (double) this.spacing.x * (double) num2) + (float) this.padding.left;
      float pos2 = (float) ((double) this.cellSize.y * (double) num1 + (double) this.spacing.y * (double) num1) + (float) this.padding.top;
      this.SetChildAlongAxis(rectChild, 0, pos1, this.cellSize.x);
      this.SetChildAlongAxis(rectChild, 1, pos2, this.cellSize.y);
    }
  }

  public override void CalculateLayoutInputVertical()
  {
  }

  public override void SetLayoutHorizontal()
  {
  }

  public override void SetLayoutVertical()
  {
  }

  public enum FitType
  {
    Uniform,
    Width,
    Height,
    FixedRows,
    FixedColumns,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FlipCreateCardAnimation
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FlipCreateCardAnimation : CreateCardAnimation
{
  public static readonly Vector3 startPos = new Vector3(0.0f, -10f, 0.0f);

  public override IEnumerator Run(Entity entity, params CardData.StatusEffectStacks[] withEffects)
  {
    FlipCreateCardAnimation createCardAnimation = this;
    entity.transform.localScale = Vector3.zero;
    entity.transform.position = FlipCreateCardAnimation.startPos;
    if (entity.display is Card display)
      display.canvasGroup.alpha = 1f;
    entity.flipper.FlipDownInstant();
    double num = (double) entity.curveAnimator.Ping();
    yield return (object) CreateCardAnimation.GainEffects(entity, (IEnumerable<CardData.StatusEffectStacks>) withEffects);
    entity.flipper.FlipUp();
    entity.wobbler.WobbleRandom();
    createCardAnimation.gameObject.Destroy();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Flipper
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;

public class Flipper : MonoBehaviourCacheTransform, IPoolable
{
  public Flipper.State state;
  [SerializeField]
  public Entity entity;
  [SerializeField]
  public CardHover hover;
  public Vector2 flipUpDurationRand = new Vector2(0.5f, 0.6f);
  public Vector2 flipDownDurationRand = new Vector2(0.5f, 0.6f);
  public AnimationCurve flipUpCurve;
  public AnimationCurve flipDownCurve;
  public Vector3 flipPositionOffset = new Vector3(0.0f, 1f, -1f);
  public AnimationCurve flipPositionCurve;
  public UnityEvent onFlipUp;
  public UnityEvent onFlipDown;
  public float preAngle;
  public float angle;
  [ReadOnly]
  public bool flipped;
  public float t = 1f;
  public float duration;
  public bool isCompleteFired = true;

  public void Update()
  {
    if ((double) this.t > (double) this.duration)
      return;
    this.isCompleteFired = false;
    this.t += Time.deltaTime;
    float time = this.t / this.duration;
    switch (this.state)
    {
      case Flipper.State.FlipUp:
        this.UpdateAngle((float) ((1.0 - (double) this.flipUpCurve.Evaluate(time)) * 180.0));
        this.transform.localPosition = this.flipPositionCurve.Evaluate(time) * this.flipPositionOffset;
        break;
      case Flipper.State.FlipDown:
        this.UpdateAngle(this.flipDownCurve.Evaluate(time) * 180f);
        this.transform.localPosition = this.flipPositionCurve.Evaluate(time) * this.flipPositionOffset;
        break;
    }
    if ((double) this.t <= (double) this.duration)
      return;
    if (!this.isCompleteFired)
    {
      global::Events.InvokeEntityFlipComplete(this.entity);
      this.isCompleteFired = true;
    }
    this.state = Flipper.State.None;
  }

  public void UpdateAngle(float angle)
  {
    this.angle = angle;
    if ((double) this.preAngle < 90.0 && (double) angle >= 90.0)
    {
      this.flipped = true;
      this.onFlipDown.Invoke();
    }
    if ((double) this.preAngle > 90.0 && (double) angle <= 90.0)
    {
      this.flipped = false;
      this.onFlipUp.Invoke();
    }
    this.preAngle = angle;
    this.transform.localEulerAngles = this.transform.localEulerAngles.WithY(angle);
  }

  [Button(null, EButtonEnableMode.Always)]
  public void FlipUp(bool force = false)
  {
    if (!force && !this.flipped && this.state != Flipper.State.FlipDown)
      return;
    this.preAngle = this.angle;
    this.t = 0.0f;
    this.duration = this.flipUpDurationRand.PettyRandom();
    this.state = Flipper.State.FlipUp;
    this.hover.SetHoverable(true);
    global::Events.InvokeEntityFlipUp(this.entity);
  }

  public void FlipUpInstant()
  {
    this.transform.localEulerAngles = this.transform.localEulerAngles.WithY(0.0f);
    this.angle = 0.0f;
    this.preAngle = 0.0f;
    this.flipped = false;
    this.onFlipUp.Invoke();
    this.state = Flipper.State.None;
    this.hover.SetHoverable(true);
  }

  [Button(null, EButtonEnableMode.Always)]
  public void FlipDown(bool force = false)
  {
    if (!force && this.flipped && this.state != Flipper.State.FlipUp)
      return;
    this.preAngle = this.angle;
    this.t = 0.0f;
    this.duration = this.flipDownDurationRand.PettyRandom();
    this.state = Flipper.State.FlipDown;
    this.hover.SetHoverable(false);
    global::Events.InvokeEntityFlipDown(this.entity);
  }

  public void FlipDownInstant()
  {
    this.transform.localEulerAngles = this.transform.localEulerAngles.WithY(180f);
    this.angle = 180f;
    this.preAngle = 180f;
    this.flipped = true;
    this.onFlipDown.Invoke();
    this.state = Flipper.State.None;
    this.hover.SetHoverable(false);
  }

  public void OnGetFromPool()
  {
  }

  public void OnReturnToPool()
  {
    this.state = Flipper.State.None;
    this.preAngle = 0.0f;
    this.angle = 0.0f;
    this.flipped = false;
    this.t = 1f;
    this.duration = 0.0f;
    this.isCompleteFired = true;
    this.transform.localRotation = Quaternion.identity;
    this.transform.localPosition = Vector3.zero;
  }

  public enum State
  {
    None,
    FlipUp,
    FlipDown,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FloatingText
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using TMPro;
using UnityEngine;

public class FloatingText : MonoBehaviour
{
  [SerializeField]
  public TMP_Text textAsset;
  [SerializeField]
  public Canvas canvas;
  [SerializeField]
  public CanvasGroup canvasGroup;

  public static FloatingText Create(Vector3 position)
  {
    FloatingText fromPool = FloatingTextManager.GetFromPool();
    fromPool.transform.position = position;
    return fromPool;
  }

  public static FloatingText Create(Vector3 position, string text)
  {
    FloatingText fromPool = FloatingTextManager.GetFromPool();
    fromPool.transform.position = position;
    fromPool.SetText(text);
    return fromPool;
  }

  public FloatingText SetText(string text)
  {
    this.textAsset.text = text;
    return this;
  }

  public FloatingText Reset()
  {
    this.canvas.overrideSorting = false;
    this.canvasGroup.alpha = 1f;
    return this;
  }

  public FloatingText SetSortingLayer(string sortingLayerName, int orderInLayer)
  {
    this.canvas.overrideSorting = true;
    this.canvas.sortingLayerName = sortingLayerName;
    this.canvas.sortingOrder = orderInLayer;
    return this;
  }

  public FloatingText Animate(string animationName, float strength = 1f)
  {
    FloatingTextManager.Animation animation = FloatingTextManager.GetAnimation(animationName);
    if (animation.tweens != null && animation.tweens.Length != 0)
      this.StartCoroutine(this.AnimateRoutine(animation, strength));
    return this;
  }

  public FloatingText Fade(string fadeCurveName, float duration = 1f, float delay = 0.0f)
  {
    this.StartCoroutine(this.FadeRoutine(FloatingTextManager.GetFadeCurve(fadeCurveName).curve, duration, delay));
    return this;
  }

  public FloatingText Fade(AnimationCurve curve, float duration = 1f, float delay = 0.0f)
  {
    this.StartCoroutine(this.FadeRoutine(curve, duration, delay));
    return this;
  }

  public FloatingText DestroyAfterSeconds(float seconds)
  {
    this.StartCoroutine(this.DestroyAfterSecondsRoutine(seconds));
    return this;
  }

  public IEnumerator AnimateRoutine(FloatingTextManager.Animation animation, float strength)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    FloatingText floatingText = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    animation.Fire(floatingText.gameObject, strength);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) floatingText.DestroyAfterSecondsRoutine(animation.GetDuration());
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public IEnumerator DestroyAfterSecondsRoutine(float seconds)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    FloatingText floatingText = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      FloatingTextManager.ReturnToPool(floatingText);
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) Sequences.Wait(seconds);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public IEnumerator FadeRoutine(AnimationCurve curve, float duration = 1f, float delay = 0.0f)
  {
    FloatingText floatingText = this;
    if ((double) delay > 0.0)
      yield return (object) Sequences.Wait(delay);
    if (curve.length > 1)
    {
      float t1 = curve[0].time;
      float num = curve[curve.length - 1].time - t1;
      float currentTime = 0.0f;
      float scale = num / duration;
      while ((double) currentTime <= (double) duration)
      {
        floatingText.canvasGroup.alpha = curve.Evaluate(t1 + currentTime * scale);
        currentTime += Time.deltaTime;
        yield return (object) null;
      }
    }
    FloatingTextManager.ReturnToPool(floatingText);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FloatingTextManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections.Generic;
using UnityEngine;

public class FloatingTextManager : MonoBehaviourSingleton<FloatingTextManager>
{
  [SerializeField]
  public FloatingText prefab;
  [SerializeField]
  public FloatingTextManager.Animation[] animations;
  [SerializeField]
  public FloatingTextManager.FadeCurve[] fadeCurves;
  public Dictionary<string, FloatingTextManager.Animation> animationDictionary;
  public Dictionary<string, FloatingTextManager.FadeCurve> fadeCurveDictionary;
  public static Queue<FloatingText> pool = new Queue<FloatingText>();

  public void Start()
  {
    this.animationDictionary = new Dictionary<string, FloatingTextManager.Animation>();
    foreach (FloatingTextManager.Animation animation in this.animations)
      this.animationDictionary[animation.name] = animation;
    this.fadeCurveDictionary = new Dictionary<string, FloatingTextManager.FadeCurve>();
    foreach (FloatingTextManager.FadeCurve fadeCurve in this.fadeCurves)
      this.fadeCurveDictionary[fadeCurve.name] = fadeCurve;
  }

  public static FloatingTextManager.Animation GetAnimation(string name) => MonoBehaviourSingleton<FloatingTextManager>.instance.animationDictionary[name];

  public static FloatingTextManager.FadeCurve GetFadeCurve(string name) => MonoBehaviourSingleton<FloatingTextManager>.instance.fadeCurveDictionary[name];

  public static FloatingText GetFromPool()
  {
    if (FloatingTextManager.pool.Count <= 0)
      return MonoBehaviourSingleton<FloatingTextManager>.instance.CreatePrefab();
    FloatingText fromPool = FloatingTextManager.pool.Dequeue();
    fromPool.gameObject.SetActive(true);
    return fromPool;
  }

  public static void ReturnToPool(FloatingText item)
  {
    item.Reset();
    item.StopAllCoroutines();
    item.gameObject.SetActive(false);
    item.transform.SetParent(MonoBehaviourSingleton<FloatingTextManager>.instance.transform);
    FloatingTextManager.pool.Enqueue(item);
  }

  public FloatingText CreatePrefab()
  {
    FloatingText prefab = UnityEngine.Object.Instantiate<FloatingText>(this.prefab, this.transform);
    prefab.gameObject.SetActive(true);
    return prefab;
  }

  [Serializable]
  public struct Animation
  {
    public string name;
    public FloatingTextManager.Animation.Tween[] tweens;

    public void Fire(GameObject target, float strength)
    {
      foreach (FloatingTextManager.Animation.Tween tween in this.tweens)
        tween.Fire(target, strength);
    }

    public float GetDuration()
    {
      float duration = 0.0f;
      foreach (FloatingTextManager.Animation.Tween tween in this.tweens)
        duration += tween.GetDuration();
      return duration;
    }

    [Serializable]
    public struct Tween
    {
      public LeanTweenType ease;
      [ShowIf("IsAnimationCurve")]
      public AnimationCurve curve;
      public float duration;
      public float delay;
      public FloatingTextManager.Animation.Tween.Property property;
      public bool relative;
      public Vector3 to;
      public bool hasFrom;
      [ShowIf("hasFrom")]
      public Vector3 from;

      public bool IsAnimationCurve => this.ease == LeanTweenType.animationCurve;

      public void Fire(GameObject target, float strength)
      {
        LTDescr ltDescr = (LTDescr) null;
        switch (this.property)
        {
          case FloatingTextManager.Animation.Tween.Property.Move:
            Vector3 localPosition = target.transform.localPosition;
            if (this.hasFrom)
              target.transform.localPosition = this.relative ? localPosition + this.from * strength : this.from;
            ltDescr = LeanTween.moveLocal(target, this.relative ? localPosition + this.to * strength : this.to, this.duration);
            break;
          case FloatingTextManager.Animation.Tween.Property.Scale:
            Vector3 localScale = target.transform.localScale;
            if (this.hasFrom)
              target.transform.localScale = this.relative ? localScale + this.from * strength : this.from;
            ltDescr = LeanTween.scale(target, this.relative ? localScale + this.to * strength : this.to, this.duration);
            break;
          case FloatingTextManager.Animation.Tween.Property.Rotate:
            Vector3 localEulerAngles = target.transform.localEulerAngles;
            if (this.hasFrom)
              target.transform.localEulerAngles = this.relative ? localEulerAngles + this.from * strength : this.from;
            ltDescr = LeanTween.rotateLocal(target, this.relative ? localEulerAngles + this.to * strength : this.to, this.duration);
            break;
        }
        if (this.IsAnimationCurve)
          ltDescr?.setEase(this.curve);
        else
          ltDescr?.setEase(this.ease);
        if ((double) this.delay <= 0.0 || ltDescr == null)
          return;
        ltDescr.setDelay(this.delay);
      }

      public float GetDuration() => this.duration + this.delay;

      public enum Property
      {
        Move,
        Scale,
        Rotate,
      }
    }
  }

  [Serializable]
  public struct FadeCurve
  {
    public string name;
    public AnimationCurve curve;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FlyOffScreen
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using UnityEngine;

public class FlyOffScreen : MonoBehaviourCacheTransform
{
  [Header("Movement")]
  public Vector3 velocity;
  [SerializeField]
  public Vector3 grav = new Vector3(0.0f, -80f, 0.0f);
  [SerializeField]
  public Vector3 rotation = new Vector3(0.0f, 100f, 320f);
  [SerializeField]
  public Vector3 frictMult = new Vector3(0.95f, 1f, 0.92f);
  [Header("Fade")]
  public CanvasGroup canvasGroup;
  [SerializeField]
  public float alpha = 2f;
  [SerializeField]
  public float fade = 2f;
  [Header("Rotation Amount")]
  [SerializeField]
  public Vector2 rotateRangeX = new Vector2(1f, 2f);
  [SerializeField]
  public Vector2 rotateRangeY = new Vector2(0.0f, 1f);
  [SerializeField]
  public Vector2 rotateRangeZ = new Vector2(1f, 2f);

  public void Awake()
  {
    this.rotation.Scale(new Vector3(this.rotateRangeX.PettyRandom(), this.rotateRangeY.PettyRandom(), this.rotateRangeZ.PettyRandom()));
    this.Begin();
  }

  public void Update()
  {
    this.velocity += this.grav * Time.deltaTime;
    this.velocity = Delta.Multiply(this.velocity, this.frictMult, Time.deltaTime);
    this.transform.position = this.transform.position + this.velocity * Time.deltaTime;
    this.transform.localEulerAngles = this.transform.localEulerAngles + this.rotation * (Mathf.Sign(this.velocity.x) * Time.deltaTime);
    this.alpha -= this.fade * Time.deltaTime;
    if ((double) this.alpha <= 0.0)
      this.End();
    else
      this.canvasGroup.alpha = Mathf.Min(1f, this.alpha);
  }

  public void Knockback(Hit lastHit)
  {
    Vector3 normalized = (lastHit == null || !(bool) (Object) lastHit.attacker ? Vector3.up.WithX(PettyRandom.Range(-1f, 1f)) : (this.transform.position - lastHit.attacker.transform.position).WithZ(0.0f)).normalized;
    Debug.Log((object) string.Format("knockback dir: {0}", (object) normalized));
    this.Knockback(new Vector3(Mathf.Clamp(normalized.x * PettyRandom.Range(5f, 10f), -1f, 1f), PettyRandom.Range(15f, 25f), -PettyRandom.Range(10f, 30f)));
  }

  public void Knockback(Vector3 dir) => this.velocity = dir;

  public virtual void Begin()
  {
  }

  public virtual void End() => this.gameObject.Destroy();
}
﻿// Decompiled with JetBrains decompiler
// Type: FontSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

[RequireComponent(typeof (TMP_Text))]
public class FontSetter : MonoBehaviour
{
  public TMP_Text _textElement;
  public bool registered;

  public TMP_Text textElement => this._textElement ?? (this._textElement = this.GetComponent<TMP_Text>());

  public void OnEnable()
  {
    FontSetterSystem.Register(this);
    this.registered = true;
  }

  public void OnDisable()
  {
    if (!this.registered)
      return;
    FontSetterSystem.Unregister(this);
    this.registered = false;
  }

  public void SetFont(TMP_FontAsset font) => this.textElement.font = font;
}
﻿// Decompiled with JetBrains decompiler
// Type: FontSetterSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;

public class FontSetterSystem : GameSystem
{
  [SerializeField]
  public AssetReferenceT<TMP_FontAsset> defaultFontRef;
  [SerializeField]
  public FontSetterSystem.LocaleFont[] localeFonts;
  public static AssetReferenceT<TMP_FontAsset> defaultRef;
  public static AssetReferenceT<TMP_FontAsset> currentRef;
  public static TMP_FontAsset current;
  public static Dictionary<string, AssetReferenceT<TMP_FontAsset>> lookup;
  public static readonly List<FontSetter> fontSetters = new List<FontSetter>();

  public void Awake()
  {
    FontSetterSystem.lookup = new Dictionary<string, AssetReferenceT<TMP_FontAsset>>();
    foreach (FontSetterSystem.LocaleFont localeFont in this.localeFonts)
      FontSetterSystem.lookup[localeFont.localeCode] = localeFont.fontRef;
    FontSetterSystem.defaultRef = this.defaultFontRef;
    FontSetterSystem.LocaleChanged(LocalizationSettings.SelectedLocale);
  }

  public void OnEnable() => LocalizationSettings.Instance.OnSelectedLocaleChanged += new Action<Locale>(FontSetterSystem.LocaleChanged);

  public void OnDisable() => LocalizationSettings.Instance.OnSelectedLocaleChanged -= new Action<Locale>(FontSetterSystem.LocaleChanged);

  public static void Register(FontSetter fontSetter)
  {
    FontSetterSystem.fontSetters.Add(fontSetter);
    if (!((UnityEngine.Object) FontSetterSystem.current != (UnityEngine.Object) null))
      return;
    fontSetter.SetFont(FontSetterSystem.current);
  }

  public static void Unregister(FontSetter fontSetter) => FontSetterSystem.fontSetters.Remove(fontSetter);

  public static void LocaleChanged(Locale locale)
  {
    if ((UnityEngine.Object) FontSetterSystem.current != (UnityEngine.Object) null)
      FontSetterSystem.currentRef.ReleaseAsset();
    FontSetterSystem.currentRef = FontSetterSystem.lookup.ContainsKey(locale.Identifier.Code) ? FontSetterSystem.lookup[locale.Identifier.Code] : FontSetterSystem.defaultRef;
    FontSetterSystem.current = FontSetterSystem.currentRef.LoadAssetAsync().WaitForCompletion();
    FontSetterSystem.UpdateFontSetters();
  }

  public static void UpdateFontSetters()
  {
    foreach (FontSetter fontSetter in FontSetterSystem.fontSetters)
      fontSetter.SetFont(FontSetterSystem.current);
  }

  [Serializable]
  public struct LocaleFont
  {
    public string localeCode;
    public AssetReferenceT<TMP_FontAsset> fontRef;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FpsDrawer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class FpsDrawer : MonoBehaviour
{
  public TextMeshProUGUI fpsText;
  [SerializeField]
  public bool @default = true;
  public float deltaTime;

  public void Awake()
  {
    if (!Settings.Load<bool>("ShowFps", this.@default))
      this.gameObject.SetActive(false);
    global::Events.OnSettingChanged += new UnityAction<string, object>(this.SettingChanged);
  }

  public void OnDestroy() => global::Events.OnSettingChanged -= new UnityAction<string, object>(this.SettingChanged);

  public void SettingChanged(string key, object value)
  {
    if (!(key == "ShowFps") || !(value is bool flag))
      return;
    this.gameObject.SetActive(flag);
  }

  public void Update()
  {
    this.deltaTime += (float) (((double) Time.unscaledDeltaTime - (double) this.deltaTime) * 0.10000000149011612);
    this.fpsText.text = string.Format("{0}\n{1}", (object) Mathf.Ceil(1f / this.deltaTime), (object) Random.seed);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FreezableList`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class FreezableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
{
  public readonly List<T> currentList = new List<T>();
  public readonly List<T> nextList = new List<T>();
  public int freezeCount;
  public bool updateRequired;
  public bool sortRequired;
  public bool autoSort;
  public IComparer<T> autoSortComparer;

  public FreezableList()
  {
  }

  public FreezableList(bool autoSort) => this.autoSort = autoSort;

  public FreezableList(bool autoSort, IComparer<T> autoSortComparer)
  {
    this.autoSort = autoSort;
    this.autoSortComparer = autoSortComparer;
  }

  public T this[int index]
  {
    get => this.currentList[index];
    set => this.nextList[index] = value;
  }

  public int Count => this.currentList.Count;

  public bool IsReadOnly => false;

  public void Add(T item)
  {
    int count = this.nextList.Count;
    int index1 = count;
    if (this.autoSort)
    {
      for (int index2 = 0; index2 < count; ++index2)
      {
        if (this.autoSortComparer.Compare(item, this.nextList[index2]) <= 0)
        {
          index1 = index2;
          break;
        }
      }
    }
    this.nextList.Insert(index1, item);
    if (this.freezeCount <= 0)
    {
      this.currentList.Insert(index1, item);
    }
    else
    {
      this.updateRequired = true;
      if (this.autoSort)
        return;
      this.sortRequired = true;
    }
  }

  public void Insert(int index, T item) => throw new NotImplementedException();

  public bool Remove(T item)
  {
    int num = this.nextList.Remove(item) ? 1 : 0;
    if (this.freezeCount <= 0)
    {
      this.currentList.Remove(item);
      return num != 0;
    }
    this.updateRequired = true;
    return num != 0;
  }

  public void RemoveAt(int index)
  {
    this.nextList.RemoveAt(index);
    if (this.freezeCount <= 0)
      this.currentList.RemoveAt(index);
    else
      this.updateRequired = true;
  }

  public void Clear()
  {
    this.nextList.Clear();
    if (this.freezeCount <= 0)
      this.currentList.Clear();
    else
      this.updateRequired = true;
  }

  public bool Contains(T item) => this.currentList.Contains(item);

  public void CopyTo(T[] array, int arrayIndex) => this.currentList.CopyTo(array, arrayIndex);

  public int IndexOf(T item) => this.currentList.IndexOf(item);

  public IEnumerator<T> GetEnumerator() => (IEnumerator<T>) this.currentList.GetEnumerator();

  IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.currentList.GetEnumerator();

  public T[] ToArray() => this.nextList.ToArray();

  public List<T> ToList() => new List<T>((IEnumerable<T>) this.nextList);

  public void Freeze() => ++this.freezeCount;

  public void Thaw()
  {
    --this.freezeCount;
    if (this.freezeCount > 0)
      return;
    if (this.updateRequired && this.sortRequired && this.autoSort)
    {
      FreezableList<T>.Sort(this.nextList, this.autoSortComparer);
      this.sortRequired = false;
    }
    this.TryUpdate();
    if (!this.autoSort || !this.sortRequired)
      return;
    this.TrySort(this.autoSortComparer);
  }

  public void TryUpdate()
  {
    if (!this.updateRequired)
      return;
    this.currentList.Clear();
    this.currentList.AddRange((IEnumerable<T>) this.nextList);
    this.updateRequired = false;
  }

  public void TrySort(IComparer<T> comparer)
  {
    if (!this.sortRequired)
      return;
    FreezableList<T>.Sort(this.currentList, comparer);
    this.nextList.Clear();
    this.nextList.AddRange((IEnumerable<T>) this.currentList);
    this.sortRequired = false;
  }

  public static void Sort(List<T> list, IComparer<T> comparer)
  {
    T[] array = list.OrderBy<T, T>((Func<T, T>) (a => a), comparer).ToArray<T>();
    list.Clear();
    list.AddRange((IEnumerable<T>) array);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FrostEyeSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Events;

public class FrostEyeSystem : GameSystem
{
  [SerializeField]
  public AssetReference frostEyePrefab;
  public static AssetReference frostEyePrefabRef;
  public static readonly List<Entity> toProcess = new List<Entity>();
  public static readonly Dictionary<Card, List<GameObject>> toRemove = new Dictionary<Card, List<GameObject>>();

  public void OnEnable()
  {
    FrostEyeSystem.frostEyePrefabRef = this.frostEyePrefab;
    global::Events.OnEntityCreated += new UnityAction<Entity>(FrostEyeSystem.EntityCreated);
    global::Events.OnEntityDataUpdated += new UnityAction<Entity>(FrostEyeSystem.EntityDataUpdated);
    global::Events.OnCardPooled += new UnityAction<Card>(FrostEyeSystem.CardPooled);
  }

  public void OnDisable()
  {
    global::Events.OnEntityCreated -= new UnityAction<Entity>(FrostEyeSystem.EntityCreated);
    global::Events.OnEntityDataUpdated -= new UnityAction<Entity>(FrostEyeSystem.EntityDataUpdated);
    global::Events.OnCardPooled -= new UnityAction<Card>(FrostEyeSystem.CardPooled);
  }

  public static void EntityCreated(Entity entity)
  {
    Dictionary<string, object> customData = entity.data.customData;
    if (!((customData != null ? customData.GetValueOrDefault<string, object>("eyes", (object) null) : (object) null) is string valueOrDefault) || !(valueOrDefault == "frost"))
      return;
    FrostEyeSystem.toProcess.Add(entity);
  }

  public static void EntityDataUpdated(Entity entity)
  {
    if (!FrostEyeSystem.toProcess.Contains(entity))
      return;
    FrostEyeSystem.toProcess.Remove(entity);
    FrostEyeSystem.Create(entity);
  }

  public static void Create(Entity entity)
  {
    if (!(entity.display is Card display))
      return;
    Transform parent1 = display.mainImage.transform.parent;
    AvatarEyePositions componentInChildren = parent1.GetComponentInChildren<AvatarEyePositions>();
    if (componentInChildren != null)
    {
      Transform transform1 = componentInChildren.transform;
      foreach (AvatarEyePositions.Eye eye in componentInChildren.eyes)
      {
        Transform transform2 = FrostEyeSystem.frostEyePrefabRef.InstantiateAsync(transform1).WaitForCompletion().transform;
        transform2.localPosition = eye.pos;
        transform2.localScale = eye.scale;
      }
    }
    else
    {
      EyeData eyeData = AddressableLoader.GetGroup<EyeData>("EyeData").FirstOrDefault<EyeData>((Func<EyeData, bool>) (a => a.cardData == entity.data.name));
      if (!(bool) (UnityEngine.Object) eyeData)
        return;
      Transform parent2 = parent1.Cast<Transform>().FirstOrDefault<Transform>((Func<Transform, bool>) (a => a.gameObject.activeSelf));
      if (!(bool) (UnityEngine.Object) parent2)
        return;
      FrostEyeSystem.toRemove.Add(display, new List<GameObject>());
      foreach (EyeData.Eye eye in eyeData.eyes)
      {
        Transform transform = FrostEyeSystem.frostEyePrefabRef.InstantiateAsync(parent2).WaitForCompletion().transform;
        transform.SetLocalPositionAndRotation((Vector3) eye.position, Quaternion.Euler(0.0f, 0.0f, eye.rotation));
        transform.localScale = eye.scale.WithZ(1f);
        FrostEyeSystem.toRemove[display].Add(transform.gameObject);
      }
    }
  }

  public static void CardPooled(Card card)
  {
    if (!FrostEyeSystem.toRemove.ContainsKey(card))
      return;
    Debug.Log((object) string.Format("Destroying [{0}] Frosteye objects from [{1}]", (object) FrostEyeSystem.toRemove[card].Count, (object) card.name));
    foreach (UnityEngine.Object @object in FrostEyeSystem.toRemove[card])
      UnityEngine.Object.Destroy(@object);
    FrostEyeSystem.toRemove.Remove(card);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FrostoscopeMapSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class FrostoscopeMapSystem : GameSystem
{
  [SerializeField]
  public UnlockData requiresUnlock;
  [SerializeField]
  public string[] visibleDuringScenes = new string[2]
  {
    "MapNew",
    "Event"
  };
  [SerializeField]
  public GameObject button;

  public void OnEnable()
  {
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    this.CheckIfUnlocked();
  }

  public void OnDisable() => global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);

  public void SceneChanged(Scene scene) => this.button.SetActive(this.visibleDuringScenes.Contains<string>(scene.name));

  public void CheckIfUnlocked()
  {
    if (MetaprogressionSystem.IsUnlocked(this.requiresUnlock))
      return;
    this.gameObject.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: FrostoscopeSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class FrostoscopeSequence : MonoBehaviour
{
  [SerializeField]
  public EventReference enterSfxEvent;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardContainer[] cardHolders;
  [SerializeField]
  public CardContainer leaderCardHolder;
  [SerializeField]
  public Transform scene;
  [SerializeField]
  public BattleGenerationScriptFinalBoss generationScript;
  [SerializeField]
  public Vector2 cameraLimits;
  [SerializeField]
  public GameObject nothingHere;
  [SerializeField]
  public GameObject group;
  [SerializeField]
  public bool enableGroupAfterGeneration;
  [SerializeField]
  [ShowIf("enableGroupAfterGeneration")]
  public float delayBeforeEnableGroup = 0.25f;
  [SerializeField]
  public bool unloadSceneOnEnd;
  public Entity hover;
  public bool hovering;
  public bool generated;

  public void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
    this.cardController.Enable();
    this.StartCoroutine(this.Run());
    MusicSystem.FadePitchTo(0.25f, 0.2f);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
    this.hover = (Entity) null;
    this.hovering = false;
    this.cardController.Disable();
    this.StopAllCoroutines();
    this.generated = false;
    MusicSystem.FadePitchTo(1f, 0.2f);
  }

  public void EntityHover(Entity entity)
  {
    this.hover = entity;
    this.hovering = true;
  }

  public void EntityUnHover(Entity entity)
  {
    this.hover = (Entity) null;
    this.hovering = false;
  }

  public void Update()
  {
    Vector3 localPosition = this.scene.localPosition;
    Vector3 target = -(this.hovering ? Vector3.Lerp(this.hover.transform.position.WithZ(0.0f), Cursor3d.Position, 0.5f) : Cursor3d.Position);
    target.x = Mathf.Clamp(target.x, -this.cameraLimits.x, this.cameraLimits.x);
    target.y = Mathf.Clamp(target.y, -this.cameraLimits.y, this.cameraLimits.y);
    this.scene.localPosition = Delta.Lerp(localPosition, target, 0.025f, Time.deltaTime);
  }

  public IEnumerator Run()
  {
    if (this.enableGroupAfterGeneration)
    {
      Routine.Clump clump = new Routine.Clump();
      clump.Add(this.CreateCards(false));
      clump.Add(Sequences.Wait(this.delayBeforeEnableGroup));
      yield return (object) clump.WaitForEnd();
      this.group.SetActive(true);
    }
    SfxSystem.OneShot(this.enterSfxEvent);
    if (!this.generated)
      yield return (object) this.CreateCards(true);
  }

  public IEnumerator CreateCards(bool startFlipped)
  {
    this.generated = true;
    (GameMode gameMode, int seed) = FrostoscopeSequence.GetGameModeAndSeed();
    List<CardData> cardDataList;
    if (!FrostoscopeSequence.TryGetPreGeneratedBattle(gameMode, out cardDataList))
      this.generationScript.GetBaseEnemies(this.generationScript.LoadCards(gameMode), seed, out cardDataList, out bool _, out bool _, out CardData _, out bool _, out CardData _);
    if (cardDataList == null || cardDataList.Count <= 0)
    {
      this.nothingHere.SetActive(true);
    }
    else
    {
      this.nothingHere.SetActive(false);
      Routine.Clump clump = new Routine.Clump();
      List<CardContainer> list = this.cardHolders.ToList<CardContainer>();
      foreach (CardData cardData in cardDataList)
      {
        if (cardData.cardType.miniboss)
          clump.Add(this.CreateCard(cardData, this.leaderCardHolder, startFlipped));
        else if (list.Count > 0)
        {
          clump.Add(this.CreateCard(cardData, list[0], startFlipped));
          list.RemoveAt(0);
        }
        else
          break;
      }
      yield return (object) clump.WaitForEnd();
    }
  }

  public static bool TryGetPreGeneratedBattle(GameMode gameMode, out List<CardData> cards)
  {
    cards = (List<CardData>) null;
    if (SaveSystem.LoadCampaignData<Campaign.Result>(gameMode, "result", Campaign.Result.None) != Campaign.Result.None)
      return false;
    CampaignSaveData campaignSaveData = SaveSystem.LoadCampaignData<CampaignSaveData>(gameMode, "data");
    CampaignNodeSaveData campaignNodeSaveData1;
    if (campaignSaveData == null)
    {
      campaignNodeSaveData1 = (CampaignNodeSaveData) null;
    }
    else
    {
      CampaignNodeSaveData[] nodes = campaignSaveData.nodes;
      campaignNodeSaveData1 = nodes != null ? ((IEnumerable<CampaignNodeSaveData>) nodes).FirstOrDefault<CampaignNodeSaveData>((Func<CampaignNodeSaveData, bool>) (a => a.typeName == "CampaignNodeFinalBoss")) : (CampaignNodeSaveData) null;
    }
    CampaignNodeSaveData campaignNodeSaveData2 = campaignNodeSaveData1;
    object obj;
    if (campaignNodeSaveData2 != null && campaignNodeSaveData2.data.TryGetValue("waves", out obj) && obj is SaveCollection<BattleWaveManager.WaveData> saveCollection)
    {
      BattleWaveManager.WaveData[] collection = saveCollection.collection;
      if (collection != null)
      {
        cards = new List<CardData>();
        if (!campaignNodeSaveData2.cleared)
        {
          foreach (BattleWaveManager.WaveData waveData in collection)
          {
            if (!(waveData is BattleWaveManager.WaveDataFull waveDataFull))
            {
              for (int index = 0; index < waveData.Count; ++index)
                cards.Add(waveData.GetCardData(index));
            }
            else
            {
              foreach (CardSaveData cardData in waveDataFull.cardDatas)
                cards.Add(cardData.Load());
            }
          }
        }
        return true;
      }
    }
    return false;
  }

  public static (GameMode, int) GetGameModeAndSeed()
  {
    GameMode gameMode;
    int num;
    if ((bool) (UnityEngine.Object) References.Campaign && Campaign.Data != null)
    {
      gameMode = Campaign.Data.GameMode;
      num = Campaign.Data.Seed;
    }
    else
    {
      gameMode = AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal");
      num = SaveSystem.LoadProgressData<int>("nextSeed", -1);
      if (num == -1)
      {
        num = Dead.Random.Seed();
        SaveSystem.SaveProgressData<int>("nextSeed", num);
      }
    }
    return (gameMode, num);
  }

  public IEnumerator CreateCard(CardData cardData, CardContainer cardHolder, bool startFlipped)
  {
    Card card = CardManager.Get(cardData, this.cardController, (Character) null, false, false);
    Transform transform = card.transform;
    if (startFlipped)
      card.entity.flipper.FlipDownInstant();
    cardHolder.Add(card.entity);
    cardHolder.SetChildPositions();
    yield return (object) card.UpdateData(false);
    if (startFlipped)
      card.entity.flipper.FlipUp(true);
  }

  public void End()
  {
    foreach (CardContainer cardHolder in this.cardHolders)
    {
      cardHolder.DestroyAll();
      cardHolder.Clear();
    }
    this.leaderCardHolder.DestroyAll();
    this.leaderCardHolder.Clear();
    this.gameObject.SetActive(false);
    if (!this.unloadSceneOnEnd)
      return;
    Routine routine = new Routine(SceneManager.Unload("NewFrostGuardian"));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GainBlessingSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Localization;
using UnityEngine.ResourceManagement.AsyncOperations;

public class GainBlessingSequence : UISequence
{
  [SerializeField]
  public AssetReferenceGameObject blessingPrefab;
  [SerializeField]
  public Transform blessingGroup;
  [SerializeField]
  public int options = 3;
  [SerializeField]
  public BlessingData[] blessingPool;
  [SerializeField]
  public LocalizedString titleKey;
  [SerializeField]
  public EventReference selectSfxEvent;
  public readonly List<BlessingData> blessings = new List<BlessingData>();

  public override IEnumerator Run()
  {
    GainBlessingSequence blessingSequence = this;
    List<BlessingData> blessings = blessingSequence.GetBlessings();
    if (blessings.Count > 0)
    {
      CinemaBarSystem.In();
      CinemaBarSystem.Top.SetPrompt(blessingSequence.titleKey.GetLocalizedString(), "Select");
      yield return (object) blessingSequence.CreateBlessings((IEnumerable<BlessingData>) blessings);
      while (!blessingSequence.promptEnd)
        yield return (object) null;
      CinemaBarSystem.Out();
    }
  }

  public List<BlessingData> GetBlessings()
  {
    List<BlessingData> blessings = new List<BlessingData>();
    foreach (BlessingData blessingData in this.blessingPool)
    {
      bool flag = false;
      if (Campaign.Data.Modifiers != null)
      {
        foreach (GameModifierData modifier in Campaign.Data.Modifiers)
        {
          if (blessingData.modifierToAdd.blockedBy.Contains<GameModifierData>(modifier))
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
      {
        blessings.Add(blessingData);
        if (blessings.Count >= this.options)
          break;
      }
    }
    return blessings;
  }

  public IEnumerator CreateBlessings(IEnumerable<BlessingData> blessingsToCreate)
  {
    foreach (BlessingData blessingData in blessingsToCreate)
      yield return (object) this.CreateBlessing(blessingData);
  }

  public IEnumerator CreateBlessing(BlessingData blessingData)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    GainBlessingSequence gainBlessingSequence = this;
    AsyncOperationHandle<GameObject> handle;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      handle.Result.GetComponent<BlessingSelect>().SetUp(blessingData, gainBlessingSequence);
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    handle = gainBlessingSequence.blessingPrefab.InstantiateAsync(gainBlessingSequence.blessingGroup);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) handle;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public void SelectBlessing(BlessingData blessingData)
  {
    if (this.promptEnd)
      return;
    blessingData.Select();
    this.promptEnd = true;
    SfxSystem.OneShot(this.selectSfxEvent);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GainBlessingSequence2
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using FMODUnity;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Localization;

public class GainBlessingSequence2 : UISequence
{
  [SerializeField]
  public Transform rewardGroup;
  [SerializeField]
  public LocalizedString titleKey;
  [SerializeField]
  public LocalizedString chooseKey;
  [SerializeField]
  public EventReference selectSfxEvent;
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public ParticleSystem buildUpPS;
  [SerializeField]
  public ParticleSystem explodePS;
  [SerializeField]
  public HandleSpinner handleSpinner;
  [SerializeField]
  public GameObject openTrigger;
  [SerializeField]
  public GameObject closedEye;
  [SerializeField]
  public GameObject openEye;
  [Header("Prefabs")]
  [SerializeField]
  public GainBlessingSequence2.SelectPrefab[] selectPrefabs;
  [Header("Positioning")]
  [SerializeField]
  public float spacing = 2.5f;
  [SerializeField]
  public float randX = 0.1f;
  [SerializeField]
  public float randY = 1f;
  [Header("SFX")]
  [SerializeField]
  public EventReference appearSfxEvent;
  [SerializeField]
  public EventReference openSfxEvent;
  public CampaignNodeTypeBoss.RewardData rewardData;
  public bool canOpen;
  public bool open;
  public int taken;

  public override IEnumerator Run()
  {
    GainBlessingSequence2 blessingSequence2 = this;
    CampaignNode characterNode = Campaign.FindCharacterNode(References.Player);
    blessingSequence2.rewardData = characterNode.data.Get<CampaignNodeTypeBoss.RewardData>("rewards");
    List<BossRewardData.Data> rewardsToCreate = blessingSequence2.rewardData.rewards;
    if (rewardsToCreate != null && rewardsToCreate.Count > 0)
    {
      SfxSystem.OneShot(blessingSequence2.appearSfxEvent);
      CinemaBarSystem.In();
      blessingSequence2.UpdateCinemaBarPrompt();
      blessingSequence2.canOpen = true;
      while (!blessingSequence2.open)
        yield return (object) null;
      blessingSequence2.UpdateCinemaBarPrompt();
      blessingSequence2.CreateRewards(rewardsToCreate);
      while (!blessingSequence2.promptEnd)
        yield return (object) null;
      CinemaBarSystem.Out();
    }
  }

  public void StartOpen()
  {
    if (this.open || !this.canOpen)
      return;
    this.canOpen = false;
    this.openTrigger.SetActive(false);
    this.StartCoroutine(this.OpenRoutine());
  }

  public IEnumerator OpenRoutine()
  {
    CinemaBarSystem.Top.RemovePrompt();
    SfxSystem.OneShot(this.openSfxEvent);
    this.closedEye.SetActive(false);
    this.openEye.SetActive(true);
    this.animator.SetBool("Open", true);
    this.handleSpinner.Spin();
    Events.InvokeScreenRumble(0.0f, 0.5f, 0.0f, 0.05f, 0.25f, 0.05f);
    yield return (object) new WaitForSeconds(0.75f);
    this.handleSpinner.Stop();
    yield return (object) new WaitForSeconds(0.25f);
    Events.InvokeScreenRumble(0.0f, 1f, 0.0f, 0.5f, 0.5f, 0.1f);
    this.buildUpPS.Play();
    yield return (object) new WaitForSeconds(1f);
    Events.InvokeScreenShake(1.5f);
    this.explodePS.Play();
    this.open = true;
    this.animator.gameObject.Destroy();
  }

  public void UpdateCinemaBarPrompt()
  {
    string str;
    if (!this.open)
      str = this.titleKey.GetLocalizedString();
    else
      str = this.chooseKey.GetLocalizedString().Format((object) (this.rewardData.canTake - this.taken));
    string text = str;
    CinemaBarSystem.Top.SetPrompt(text, "Select");
  }

  public void CreateRewards(List<BossRewardData.Data> rewardsToCreate)
  {
    UnityEngine.Random.InitState(Campaign.FindCharacterNode(References.Player).seed);
    float startX = (float) (-(double) this.spacing * (double) (rewardsToCreate.Count - 1) * 0.5);
    int ySign = PettyRandom.Choose<int>(1, -1);
    foreach (BossRewardData.Data reward in rewardsToCreate)
    {
      this.CreateReward(reward, startX, 0.0f, (float) ySign);
      startX += this.spacing;
      if ((double) PettyRandom.Range(0.0f, 1f) > 0.20000000298023224)
        ySign *= -1;
    }
  }

  public void CreateReward(BossRewardData.Data reward, float startX, float startY, float ySign)
  {
    BossRewardSelect bossRewardSelect = UnityEngine.Object.Instantiate<BossRewardSelect>(((IEnumerable<GainBlessingSequence2.SelectPrefab>) this.selectPrefabs).FirstOrDefault<GainBlessingSequence2.SelectPrefab>((Func<GainBlessingSequence2.SelectPrefab, bool>) (a => a.bossRewardType == reward.type)).prefab, this.rewardGroup);
    float x = startX + PettyRandom.Range(-this.randX, this.randX);
    float y = startY + PettyRandom.Range(0.0f, this.randY) * ySign;
    bossRewardSelect.transform.localPosition = PettyRandom.Vector3();
    LeanTween.moveLocal(bossRewardSelect.gameObject, new Vector3(x, y), PettyRandom.Range(1f, 2f)).setEaseOutElastic();
    bossRewardSelect.SetUp(reward, this);
  }

  public void Select(BossRewardData.Data reward)
  {
    if (this.promptEnd)
      return;
    reward.Select();
    if (++this.taken >= this.rewardData.canTake)
      this.promptEnd = true;
    else
      this.UpdateCinemaBarPrompt();
    SfxSystem.OneShot(this.selectSfxEvent);
  }

  [Serializable]
  public struct SelectPrefab
  {
    public BossRewardData.Type bossRewardType;
    public BossRewardSelect prefab;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GainCharmSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using TMPro;
using UnityEngine;

public class GainCharmSequence : UISequence
{
  [Header("Custom Values")]
  [SerializeField]
  public CardUpgradeData charmData;
  [SerializeField]
  public CardCharm charmPrefab;
  [SerializeField]
  public float charmScale = 2f;
  [SerializeField]
  public Vector2 charmPopUpOffset = new Vector2(1f, 0.0f);
  [SerializeField]
  public Transform charmHolder;
  [SerializeField]
  public CanvasGroup fade;
  [SerializeField]
  public float fadeInTime = 0.2f;
  [SerializeField]
  public float fadeOutTime = 0.2f;
  [SerializeField]
  public TweenUI[] startTweens;
  [SerializeField]
  public TweenUI[] endTweens;
  [SerializeField]
  public Character character;
  [SerializeField]
  public TMP_Text title;
  public CardCharmInteraction charmInteraction;

  public void SetCharm(CardUpgradeData charmData) => this.charmData = charmData;

  public void SetCharacter(Character character) => this.character = character;

  public void SetTitle(string text) => this.title.text = "<size=0.5><#A9AAD4>" + text + "</size></color>\n" + this.charmData.title;

  public override IEnumerator Run()
  {
    GainCharmSequence gainCharmSequence = this;
    gainCharmSequence.character.data.inventory.upgrades.Add(gainCharmSequence.charmData);
    Events.InvokeUpgradeGained(gainCharmSequence.charmData);
    Campaign.PromptSave();
    gainCharmSequence.fade.gameObject.SetActive(false);
    gainCharmSequence.charmHolder.DestroyAllChildren();
    yield return (object) Sequences.Wait(gainCharmSequence.startDelay);
    gainCharmSequence.gameObject.SetActive(true);
    gainCharmSequence.fade.gameObject.SetActive(true);
    gainCharmSequence.fade.alpha = 0.0f;
    gainCharmSequence.fade.LeanAlpha(1f, gainCharmSequence.fadeInTime);
    gainCharmSequence.fade.blocksRaycasts = true;
    float a = 0.0f;
    foreach (TweenUI startTween in gainCharmSequence.startTweens)
    {
      startTween.Fire();
      a = Mathf.Max(a, startTween.GetDuration());
    }
    CardCharm cardCharm = Object.Instantiate<CardCharm>(gainCharmSequence.charmPrefab, gainCharmSequence.charmHolder);
    cardCharm.holder = gainCharmSequence.charmHolder;
    cardCharm.transform.localScale = Vector3.one * gainCharmSequence.charmScale;
    cardCharm.SetData(gainCharmSequence.charmData);
    gainCharmSequence.charmInteraction = cardCharm.GetComponent<CardCharmInteraction>();
    if ((bool) (Object) gainCharmSequence.charmInteraction)
    {
      gainCharmSequence.charmInteraction.popUpOffset = gainCharmSequence.charmPopUpOffset;
      gainCharmSequence.charmInteraction.PopUpDescription();
    }
    while (!gainCharmSequence.promptEnd)
      yield return (object) null;
    gainCharmSequence.promptEnd = false;
    gainCharmSequence.charmInteraction.HideDescription();
    gainCharmSequence.fade.LeanAlpha(0.0f, gainCharmSequence.fadeOutTime);
    gainCharmSequence.fade.blocksRaycasts = false;
    SfxSystem.OneShot("event:/sfx/ui/message_closing");
    float num = gainCharmSequence.fadeOutTime;
    foreach (TweenUI endTween in gainCharmSequence.endTweens)
    {
      endTween.Fire();
      num = Mathf.Max(num, endTween.GetDuration());
    }
    yield return (object) Sequences.Wait(num);
    gainCharmSequence.gameObject.SetActive(false);
    yield return (object) GainCharmSequence.WaitForInventoryClose();
  }

  public void CharacterOpenInventory()
  {
    if (!(this.character.entity.display is CharacterDisplay display))
      return;
    display.OpenInventory();
  }

  public static IEnumerator WaitForInventoryClose()
  {
    while (Deckpack.IsOpen)
      yield return (object) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GainCompanionSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;

public class GainCompanionSequence : UISequence
{
  public Entity target;

  public void SetTarget(Entity target) => this.target = target;

  public override IEnumerator Run()
  {
    yield return (object) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GainCrownSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.UI;

public class GainCrownSequence : UISequence
{
  [Header("Custom Values")]
  [SerializeField]
  public CanvasGroup fade;
  [SerializeField]
  public float fadeInTime = 0.2f;
  [SerializeField]
  public float fadeOutTime = 0.2f;
  [SerializeField]
  public TweenUI[] startTweens;
  [SerializeField]
  public TweenUI[] endTweens;
  [SerializeField]
  public Image crownImage;
  [SerializeField]
  public CardUpgradeData defaultCrownData;
  public CardUpgradeData crownData;

  public void SetData(CardUpgradeData crownData) => this.crownData = crownData;

  public override IEnumerator Run()
  {
    GainCrownSequence gainCrownSequence = this;
    if (!(bool) (Object) gainCrownSequence.crownData)
      gainCrownSequence.crownData = gainCrownSequence.defaultCrownData.Clone();
    gainCrownSequence.crownImage.sprite = gainCrownSequence.crownData.image;
    References.PlayerData.inventory.upgrades.Add(gainCrownSequence.crownData);
    Events.InvokeUpgradeGained(gainCrownSequence.crownData);
    gainCrownSequence.fade.gameObject.SetActive(false);
    yield return (object) Sequences.Wait(gainCrownSequence.startDelay);
    gainCrownSequence.gameObject.SetActive(true);
    gainCrownSequence.fade.gameObject.SetActive(true);
    gainCrownSequence.fade.alpha = 0.0f;
    gainCrownSequence.fade.LeanAlpha(1f, gainCrownSequence.fadeInTime);
    gainCrownSequence.fade.blocksRaycasts = true;
    float a = 0.0f;
    foreach (TweenUI startTween in gainCrownSequence.startTweens)
    {
      startTween.Fire();
      a = Mathf.Max(a, startTween.GetDuration());
    }
    while (!gainCrownSequence.promptEnd)
      yield return (object) null;
    gainCrownSequence.promptEnd = false;
    gainCrownSequence.fade.LeanAlpha(0.0f, gainCrownSequence.fadeOutTime);
    gainCrownSequence.fade.blocksRaycasts = false;
    SfxSystem.OneShot("event:/sfx/ui/message_closing");
    float num = gainCrownSequence.fadeOutTime;
    foreach (TweenUI endTween in gainCrownSequence.endTweens)
    {
      endTween.Fire();
      num = Mathf.Max(num, endTween.GetDuration());
    }
    yield return (object) Sequences.Wait(num);
    gainCrownSequence.gameObject.SetActive(false);
  }

  public void CharacterOpenInventory()
  {
    if (!(References.Player.entity.display is CharacterDisplay display))
      return;
    display.OpenInventory();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GainNegativeCharmSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

public class GainNegativeCharmSequence : MonoBehaviour
{
  [SerializeField]
  public GameObject holderGroup;
  [SerializeField]
  public CardCharmHolder[] holders;
  [SerializeField]
  public CardCharmHolder activeCharmHolder;
  [SerializeField]
  public GameObject cardGridGroup;
  [SerializeField]
  public DeckDisplayGroup deckDisplayGroup;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardUpgradeData[] charmOptions;
  [SerializeField]
  public CinemaBarShower cinemaBarShower;
  [SerializeField]
  public Fader backgroundFader;
  public bool charmChosen;
  public bool promptEnd;

  public IEnumerator Run()
  {
    GainNegativeCharmSequence negativeCharmSequence = this;
    CampaignNode characterNode = Campaign.FindCharacterNode(References.Player);
    UnityEngine.Random.State state = UnityEngine.Random.state;
    UnityEngine.Random.InitState(characterNode.seed);
    negativeCharmSequence.CreateUpgrades();
    UnityEngine.Random.state = state;
    yield return (object) new WaitUntil(new Func<bool>(negativeCharmSequence.\u003CRun\u003Eb__11_0));
    negativeCharmSequence.cinemaBarShower.Hide();
    negativeCharmSequence.backgroundFader.Out(0.25f);
    yield return (object) new WaitForSeconds(0.5f);
  }

  public void CreateUpgrades()
  {
    List<CardUpgradeData> list = new List<CardUpgradeData>((IEnumerable<CardUpgradeData>) this.charmOptions);
    list.Shuffle<CardUpgradeData>();
    int length = this.holders.Length;
    foreach (CardUpgradeData upgradeData in list)
    {
      if (this.UpgradeCanBeAssignedToSomethingInDeck(upgradeData))
      {
        this.CreateUpgrade(upgradeData.Clone());
        if (--length <= 0)
          break;
      }
    }
  }

  public bool UpgradeCanBeAssignedToSomethingInDeck(CardUpgradeData upgradeData)
  {
    foreach (CardData cardData in References.PlayerData.inventory.deck)
    {
      if (upgradeData.CanAssign(cardData))
        return true;
    }
    return false;
  }

  public void CreateUpgrade(CardUpgradeData upgradeDataClone)
  {
    CardCharmHolder cardCharmHolder = ((IEnumerable<CardCharmHolder>) this.holders).FirstOrDefault<CardCharmHolder>((Func<CardCharmHolder, bool>) (a => a.transform.childCount == 0));
    if (!(bool) (UnityEngine.Object) cardCharmHolder)
      return;
    UpgradeDisplay upgrade = cardCharmHolder.Create(upgradeDataClone);
    CardCharmInteraction component = upgrade.GetComponent<CardCharmInteraction>();
    component.popUpOffset = new Vector2(0.8f, -0.25f);
    component.onDrag.AddListener((UnityAction<UpgradeDisplay>) (_ => this.Take(upgrade)));
  }

  public void Take(UpgradeDisplay upgrade)
  {
    if (this.charmChosen)
      return;
    this.charmChosen = true;
    this.activeCharmHolder.Create(upgrade.data);
    this.holderGroup.SetActive(false);
    this.StartCoroutine(this.OpenCardGrid(upgrade.data));
  }

  public IEnumerator OpenCardGrid(CardUpgradeData upgradeData)
  {
    this.cardGridGroup.SetActive(true);
    Routine.Clump clump = new Routine.Clump();
    foreach (CardData cardData in References.PlayerData.inventory.deck)
    {
      if (upgradeData.CanAssign(cardData))
        clump.Add(this.CreateCard(cardData));
    }
    yield return (object) clump.WaitForEnd();
    this.deckDisplayGroup.UpdatePositions();
    yield return (object) ((RectTransform) this.deckDisplayGroup.transform.parent).FixLayoutGroup();
    yield return (object) this.FlipCardsUp();
  }

  public void HideCardGrid()
  {
    LeanTween.cancel(this.cardGridGroup);
    LeanTween.scale(this.cardGridGroup, Vector3.zero, 0.33f).setEaseInBack();
  }

  public IEnumerator FlipCardsUp()
  {
    foreach (Entity entity in (CardContainer) this.deckDisplayGroup.grids[0])
    {
      entity.flipper.FlipUp(true);
      yield return (object) new WaitForSeconds(PettyRandom.Range(0.0f, 0.1f));
    }
  }

  public IEnumerator CreateCard(CardData cardData)
  {
    Card card = CardManager.Get(cardData, this.cardController, References.Player, false, true);
    this.deckDisplayGroup.AddCard(card);
    card.entity.flipper.FlipDownInstant();
    yield return (object) card.UpdateData(false);
  }

  public void End() => this.promptEnd = true;

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__11_0() => this.promptEnd;
}
﻿// Decompiled with JetBrains decompiler
// Type: GainUnlockSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;
using UnityEngine.Localization;

public class GainUnlockSequence : MonoBehaviour
{
  public TMP_Text titleElement;
  public TMP_Text descriptionElement;
  [Header("Displays")]
  [SerializeField]
  public GameObject constructionDisplay;
  [SerializeField]
  public GameObject petHutDisplay;
  [SerializeField]
  public GameObject inventorDisplay;
  [SerializeField]
  public GameObject icebreakerDisplay;
  [SerializeField]
  public GameObject tribeHallDisplay;
  [SerializeField]
  public GameObject hotSpringDisplay;
  [SerializeField]
  public GameObject frostoscopeDisplay;
  [SerializeField]
  public GameObject challengeShrineDisplay;
  [SerializeField]
  public GameObject newItemIcon;
  public GameObject display;

  public void SetUp(UnlockData unlockData)
  {
    this.SetTitle(unlockData);
    this.SetDisplay(unlockData);
    this.SetDescription(unlockData);
    this.gameObject.SetActive(true);
  }

  public void SetTitle(UnlockData unlockData)
  {
    string str = string.Empty;
    if ((Object) unlockData.relatedBuilding != (Object) null && unlockData.relatedBuilding.titleKey != null)
      str = str + "<size=7.5>" + unlockData.relatedBuilding.titleKey.GetLocalizedString() + "</size>";
    if (unlockData.unlockTitle != null)
    {
      if (!str.IsNullOrWhitespace())
        str += "\n";
      str = str + "<#C3967F>" + unlockData.unlockTitle.GetLocalizedString();
    }
    this.titleElement.text = str;
  }

  public void SetDisplay(UnlockData unlockData)
  {
    this.newItemIcon.SetActive(unlockData.type == UnlockData.Type.Item || unlockData.type == UnlockData.Type.Pet || unlockData.type == UnlockData.Type.Tribe);
    if ((Object) this.display != (Object) null)
      this.display.SetActive(false);
    if (unlockData.type == UnlockData.Type.BuildingStarted)
    {
      this.SetDisplay(this.constructionDisplay);
    }
    else
    {
      string name = unlockData.relatedBuilding.name;
      // ISSUE: reference to a compiler-generated method
      switch (\u003CPrivateImplementationDetails\u003E.ComputeStringHash(name))
      {
        case 274784770:
          if (!(name == "Frostoscope"))
            break;
          this.SetDisplay(this.frostoscopeDisplay);
          break;
        case 492444653:
          if (!(name == "InventorHut"))
            break;
          this.SetDisplay(this.inventorDisplay);
          break;
        case 1110305817:
          if (!(name == "ChallengeShrine"))
            break;
          this.SetDisplay(this.challengeShrineDisplay);
          break;
        case 1471324901:
          if (!(name == "Icebreakers"))
            break;
          this.SetDisplay(this.icebreakerDisplay);
          break;
        case 1949646385:
          if (!(name == "HotSpring"))
            break;
          this.SetDisplay(this.hotSpringDisplay);
          break;
        case 2945460819:
          if (!(name == "PetHut"))
            break;
          this.SetDisplay(this.petHutDisplay);
          break;
        case 4143207400:
          if (!(name == "TribeHut"))
            break;
          this.SetDisplay(this.tribeHallDisplay);
          break;
      }
    }
  }

  public void SetDisplay(GameObject type)
  {
    this.display = type;
    this.display.SetActive(true);
  }

  public void SetDescription(UnlockData unlockData)
  {
    LocalizedString unlockDesc = unlockData.unlockDesc;
    if (unlockDesc != null && !unlockDesc.IsEmpty)
      this.descriptionElement.text = unlockData.unlockDesc.GetLocalizedString();
    else
      this.descriptionElement.text = "";
  }

  public void Close() => this.gameObject.SetActive(false);
}
﻿// Decompiled with JetBrains decompiler
// Type: GameManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Globalization;
using System.Threading;
using UnityEngine;

public class GameManager : MonoBehaviourSingleton<GameManager>
{
  public const float CARD_WIDTH = 3f;
  public const float CARD_HEIGHT = 4.5f;
  public static readonly Vector2 CARD_SIZE = new Vector2(3f, 4.5f);
  public const float LARGE_UI = 0.0f;
  [SerializeField]
  public int targetFrameRate = -1;
  [SerializeField]
  public int editorTargetFrameRate = 60;
  public static int tasksInProgress = 0;
  public static bool init;
  public static bool End;
  public static bool paused;
  public static readonly CultureInfo CultureInfo = CultureInfo.CreateSpecificCulture("en-GB");

  public static bool Busy => GameManager.tasksInProgress > 0 || !GameManager.init;

  public static bool Ready => GameManager.init;

  public IEnumerator Start()
  {
    Thread.CurrentThread.CurrentCulture = GameManager.CultureInfo;
    Application.targetFrameRate = this.targetFrameRate;
    UnityEngine.Random.InitState((int) DateTime.Now.Ticks);
    Debug.Log((object) "RELEASE = TRUE");
    yield return (object) null;
    yield return (object) new WaitUntil((Func<bool>) (() => Bootstrap.Count <= 0));
    GameManager.init = true;
    Events.InvokeGameStart();
  }

  public void OnApplicationQuit()
  {
    Debug.Log((object) ">>>> GAME END <<<<");
    GameManager.End = true;
    Events.InvokeGameEnd();
  }

  public static void Quit() => Application.Quit();
}
﻿// Decompiled with JetBrains decompiler
// Type: GameMode
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

[CreateAssetMenu(fileName = "GameMode", menuName = "Game Mode")]
public class GameMode : DataFile
{
  public string saveFileName = "";
  public string seed;
  public ClassData[] classes;
  public CampaignGenerator generator;
  public CampaignPopulator populator;
  public bool startInNode;
  public bool takeStartingPet = true;
  public bool countsAsWin = true;
  public bool showStats = true;
  public bool gainProgress = true;
  public bool doSave = true;
  public bool canRestart = true;
  public bool canGoBack = true;
  public bool submitScore;
  public bool mainGameMode = true;
  public bool dailyRun;
  public bool tutorialRun;
  [ShowIf("submitScore")]
  public Scores.Type leaderboardType;
  public string startScene;
  public string sceneAfterSelection = "Campaign";
  public string[] campaignSystemNames;
  public string[] systemsToDisable;
}
﻿// Decompiled with JetBrains decompiler
// Type: GameModifierData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using FMODUnity;
using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Localization;

[CreateAssetMenu(fileName = "Modifier", menuName = "Modifiers/Game Modifier")]
public class GameModifierData : DataFile
{
  public int value = 100;
  public bool visible = true;
  [ShowAssetPreview(64, 64)]
  public Sprite bellSprite;
  [ShowAssetPreview(64, 64)]
  public Sprite dingerSprite;
  public LocalizedString titleKey;
  public LocalizedString descriptionKey;
  public string[] systemsToAdd;
  public Script[] setupScripts;
  public Script[] startScripts;
  public int scriptPriority;
  public GameModifierData[] blockedBy;
  public HardModeModifierData linkedStormBell;
  [SerializeField]
  public EventReference ringSfxEvent;
  [SerializeField]
  public Vector2 ringSfxPitch = new Vector2(1f, 1f);

  public void PlayRingSfx()
  {
    if (this.ringSfxEvent.IsNull)
      return;
    int num = (int) SfxSystem.OneShot(this.ringSfxEvent).setPitch(this.ringSfxPitch.PettyRandom() * PettyRandom.Range(0.95f, 1.05f));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GameStatData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Localization;

[CreateAssetMenu(menuName = "Game Stat", fileName = "Stat")]
public class GameStatData : ScriptableObject
{
  public LocalizedString stringKey;
  [SerializeField]
  public GameStatData.Type type;
  [SerializeField]
  [ShowIf("NeedsStatName")]
  public string statName;
  [SerializeField]
  [ShowIf("NeedsKey")]
  public string statKey;
  [SerializeField]
  [ShowIf("NeedsRate")]
  public string statKeyOver;
  [SerializeField]
  [ShowIf("NeedsDefault")]
  public int defaultValue;
  public float displayOrder;
  public float priority;
  public float par = 1f;
  public float priorityAddOverPar;
  public float prioritySubUnderPar;
  public GameStatData[] overwrites;

  public bool NeedsStatName => this.type != GameStatData.Type.Time;

  public bool NeedsKey
  {
    get
    {
      GameStatData.Type type = this.type;
      int num;
      switch (type)
      {
        case GameStatData.Type.Normal:
        case GameStatData.Type.Best:
          num = 0;
          break;
        default:
          num = type != GameStatData.Type.Rate ? 1 : 0;
          break;
      }
      return num == 0;
    }
  }

  public bool NeedsDefault => this.type != GameStatData.Type.Count && this.type != GameStatData.Type.Time && this.type != GameStatData.Type.RandomKey;

  public bool NeedsRate => this.type == GameStatData.Type.Rate;

  public float GetPriority(float value)
  {
    float num = value - this.par;
    float priority = this.priority;
    return (double) num <= 0.0 ? priority + this.prioritySubUnderPar * num : priority + this.priorityAddOverPar * num;
  }

  public float GetValue(CampaignStats stats)
  {
    float num;
    switch (this.type)
    {
      case GameStatData.Type.Best:
        num = (float) this.GetBestValue(stats, this.statKey);
        break;
      case GameStatData.Type.BestAny:
        num = (float) stats.Best(this.statName, this.defaultValue);
        break;
      case GameStatData.Type.Count:
        num = (float) stats.Count(this.statName);
        break;
      case GameStatData.Type.Time:
        num = (float) Mathf.RoundToInt(stats.time + (float) (stats.hours * 3600));
        break;
      case GameStatData.Type.RandomKey:
        num = 1f;
        break;
      case GameStatData.Type.Rate:
        num = this.GetRateValue(stats);
        break;
      case GameStatData.Type.BestTime:
        num = (float) this.GetBestValue(stats, this.statKey);
        break;
      default:
        num = (float) this.GetNormalValue(stats, this.statKey);
        break;
    }
    return num;
  }

  public int GetBestValue(CampaignStats stats, string statKey)
  {
    if (!GameStatData.HasMultipleStatKeys(statKey))
      return stats.Best(this.statName, statKey, this.defaultValue);
    IEnumerable<string> statKeys = GameStatData.GetStatKeys(statKey);
    List<int> source = new List<int>();
    foreach (string key in statKeys)
      source.Add(stats.Best(this.statName, key, this.defaultValue));
    return source.Max();
  }

  public int GetNormalValue(CampaignStats stats, string statKey)
  {
    if (!GameStatData.HasMultipleStatKeys(statKey))
      return stats.Get(this.statName, statKey, this.defaultValue);
    IEnumerable<string> statKeys = GameStatData.GetStatKeys(statKey);
    int normalValue = 0;
    foreach (string key in statKeys)
      normalValue += stats.Get(this.statName, key, this.defaultValue);
    return normalValue;
  }

  public float GetRateValue(CampaignStats stats)
  {
    float normalValue = (float) this.GetNormalValue(stats, this.statKey);
    float num = (float) this.GetNormalValue(stats, this.statKeyOver) + normalValue;
    return (double) num <= 0.0 ? ((double) normalValue > 0.0 ? 1f : 0.0f) : normalValue / num;
  }

  public static bool HasMultipleStatKeys(string @in) => @in.Contains('|');

  public static IEnumerable<string> GetStatKeys(string @in) => (IEnumerable<string>) @in.Split('|', StringSplitOptions.None);

  public string GetStringValue(CampaignStats stats, float value)
  {
    if ((double) value <= 0.0)
      return "-";
    string stringValue;
    switch (this.type)
    {
      case GameStatData.Type.Time:
        stringValue = GameStatData.FromSeconds(value);
        break;
      case GameStatData.Type.RandomKey:
        stringValue = this.GetRandomStringValue(stats);
        break;
      case GameStatData.Type.Rate:
        stringValue = (value * 100f).ToString("0") + "%";
        break;
      case GameStatData.Type.BestTime:
        stringValue = GameStatData.FromSeconds(value);
        break;
      default:
        stringValue = Mathf.RoundToInt(value).ToString("N0");
        break;
    }
    return stringValue;
  }

  public string GetRandomStringValue(CampaignStats stats)
  {
    Dictionary<string, int> dictionary = stats.Get(this.statName);
    if (dictionary == null)
      return "-";
    string randomStringValue = "-";
    int num = 0;
    foreach (KeyValuePair<string, int> keyValuePair in dictionary)
    {
      if (keyValuePair.Value >= num)
      {
        num = keyValuePair.Value;
        randomStringValue = keyValuePair.Key;
      }
    }
    return randomStringValue;
  }

  public static string FromSeconds(float seconds)
  {
    TimeSpan timeSpan = TimeSpan.FromSeconds((double) seconds);
    return string.Format("{0:00}:{1:00}:{2:00}", (object) (int) timeSpan.TotalHours, (object) timeSpan.Minutes, (object) timeSpan.Seconds);
  }

  public enum Type
  {
    Normal,
    Best,
    BestAny,
    Count,
    Time,
    RandomKey,
    Rate,
    BestTime,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GameSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public abstract class GameSystem : MonoBehaviour
{
  public void Enable() => this.enabled = true;

  public void Disable() => this.enabled = false;
}
﻿// Decompiled with JetBrains decompiler
// Type: GameUpdateDisplayer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;
using UnityEngine.Localization.Components;
using UnityEngine.SceneManagement;

public class GameUpdateDisplayer : MonoBehaviour
{
  [SerializeField]
  public GameObject display;
  [SerializeField]
  public SmoothScrollRect scrollRect;
  [SerializeField]
  public LocalizeStringEvent titleEvent;
  [SerializeField]
  public LocalizeStringEvent bodyEvent;
  [SerializeField]
  public GameUpdateDisplayer.Update[] updates;
  [Header("Beta Version")]
  [SerializeField]
  public GameUpdateDisplayer.Update beta;

  public void OnEnable()
  {
    this.display.SetActive(false);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
  }

  public void OnDisable() => global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);

  public void SceneChanged(Scene scene)
  {
    if (!(scene.name == "MainMenu"))
      return;
    this.Check();
  }

  public void Check()
  {
    VersionCompatibility.GetVersions();
    foreach (GameUpdateDisplayer.Update update in ((IEnumerable<GameUpdateDisplayer.Update>) this.updates).Reverse<GameUpdateDisplayer.Update>())
    {
      int result1;
      if (VersionCompatibility.currentVersion == update.buildNumber && int.TryParse(VersionCompatibility.currentVersion, out result1))
      {
        int result2;
        if (int.TryParse(VersionCompatibility.previousVersion, out result2) && result2 > 0 && result2 < result1)
        {
          this.StartCoroutine(this.ShowRoutine(update));
          return;
        }
        this.Hide();
        return;
      }
    }
    this.Hide();
  }

  public IEnumerator ShowRoutine(GameUpdateDisplayer.Update update)
  {
    this.display.SetActive(true);
    this.titleEvent.StringReference = update.titleRef;
    this.bodyEvent.StringReference = update.bodyRef;
    if (this.scrollRect.transform is RectTransform transform)
      transform.sizeDelta = transform.sizeDelta.WithY(update.panelHeight);
    yield return (object) new WaitForSeconds(0.35f);
    this.scrollRect.ScrollToTop();
  }

  public void Hide()
  {
    this.display.SetActive(false);
    this.gameObject.SetActive(false);
  }

  [Serializable]
  public struct Update
  {
    public string buildNumber;
    public LocalizedString titleRef;
    public LocalizedString bodyRef;
    public float panelHeight;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GenericCompare`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

public class GenericCompare<T> : IComparer<T>
{
  [CompilerGenerated]
  public Func<T, T, int> \u003CComparerFunction\u003Ek__BackingField;

  public Func<T, T, int> ComparerFunction
  {
    set => this.\u003CComparerFunction\u003Ek__BackingField = value;
    get => this.\u003CComparerFunction\u003Ek__BackingField;
  }

  public GenericCompare(Func<T, T, int> comparerFunction) => this.ComparerFunction = comparerFunction;

  public int Compare(T x, T y)
  {
    if ((object) x == null || (object) y == null)
    {
      if ((object) y == null && (object) x == null)
        return 0;
      if ((object) y == null)
        return 1;
      if ((object) x == null)
        return -1;
    }
    try
    {
      return this.ComparerFunction(x, y);
    }
    catch (Exception ex)
    {
    }
    return 0;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Glow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using UnityEngine;
using UnityEngine.UI;

public class Glow : MonoBehaviourRect
{
  [SerializeField]
  public Image image;
  [SerializeField]
  public AnimationCurve fadeCurve;
  [SerializeField]
  public float fadeDuration = 0.5f;
  public float delay;
  public float t;

  public Glow SetSize(Vector2 size)
  {
    this.rectTransform.sizeDelta = size;
    return this;
  }

  public Glow SetPosition(Vector2 position)
  {
    this.rectTransform.anchoredPosition = position;
    return this;
  }

  public Glow SetColor(Color color)
  {
    this.image.color = color;
    return this;
  }

  public Glow RandomColor(float saturation = 1f, float brightness = 1f)
  {
    this.image.color = Color.HSVToRGB(PettyRandom.Range(0.0f, 1f), saturation, brightness);
    return this;
  }

  public Glow Fade(AnimationCurve curve, float duration, float delay = 0.0f)
  {
    this.image.color = this.image.color.WithAlpha(0.0f);
    this.fadeCurve = curve;
    this.fadeDuration = duration;
    this.t = 0.0f;
    this.delay = delay;
    return this;
  }

  public void Update()
  {
    if ((double) this.delay > 0.0)
    {
      this.delay -= Time.deltaTime;
    }
    else
    {
      this.t += Time.deltaTime / this.fadeDuration;
      this.image.color = this.image.color.WithAlpha(this.fadeCurve.Evaluate(this.t));
      if ((double) this.t <= 1.0)
        return;
      Object.Destroy((Object) this.gameObject);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GoldDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class GoldDisplay : MonoBehaviour
{
  [SerializeField]
  public Image icon;
  [SerializeField]
  public bool doPing = true;
  [SerializeField]
  public LeanTweenType pingEase = LeanTweenType.easeOutElastic;
  [SerializeField]
  [ShowIf("PingIsAnimationCurve")]
  public AnimationCurve pingCurve;
  [SerializeField]
  public float pingDur = 1f;
  [SerializeField]
  public TMP_Text textAsset;
  [SerializeField]
  [TextArea]
  public string format = "{0}";
  [SerializeField]
  [TextArea]
  public string formatAdd = "{0}<#ffff00>+{1}";
  [SerializeField]
  [TextArea]
  public string formatSub = "{0}<#e05822>-{1}";
  [SerializeField]
  [TextArea]
  public string formatChangeUp = "<s>{0}</s><#ffff00> {2}";
  [SerializeField]
  [TextArea]
  public string formatChangeDown = "<s>{0}</s><#e05822> {2}";
  [SerializeField]
  public float addDelay = 1f;
  [SerializeField]
  public float totalAddTime = 1f;
  [SerializeField]
  public float addBetweenTimeMax = 0.05f;
  public int goldPre;
  public float current;
  [CompilerGenerated]
  public float \u003Cadd\u003Ek__BackingField;
  public float change;

  public bool PingIsAnimationCurve => this.pingEase == LeanTweenType.animationCurve;

  public float add
  {
    get => this.\u003Cadd\u003Ek__BackingField;
    set => this.\u003Cadd\u003Ek__BackingField = value;
  }

  public void Set(int amount)
  {
    if (amount != this.goldPre)
    {
      this.add += (float) (amount - this.goldPre);
      this.UpdateText();
      this.ResolveAfter(this.addDelay);
      if (this.doPing && (double) this.pingDur > 0.0 && this.pingEase != LeanTweenType.notUsed)
        this.Ping();
    }
    this.goldPre = amount;
  }

  public void ShowChange(int change)
  {
    this.change = (float) change;
    this.UpdateText();
  }

  public void HideChange()
  {
    this.change = 0.0f;
    this.UpdateText();
  }

  public void Ping()
  {
    LeanTween.cancel(this.gameObject);
    LTDescr ltDescr = LeanTween.scale(this.gameObject, Vector3.one, this.pingDur).setFrom(Vector3.zero);
    if (this.PingIsAnimationCurve)
      ltDescr.setEase(this.pingCurve);
    else
      ltDescr.setEase(this.pingEase);
  }

  public void UpdateText()
  {
    if ((double) this.change == 0.0)
    {
      if ((double) this.add == 0.0)
        this.textAsset.text = string.Format(this.format, (object) this.current);
      else if ((double) this.add > 0.0)
      {
        this.textAsset.text = string.Format(this.formatAdd, (object) this.current, (object) this.add);
      }
      else
      {
        if ((double) this.add >= 0.0)
          return;
        this.textAsset.text = string.Format(this.formatSub, (object) this.current, (object) (float) -(double) this.add);
      }
    }
    else if ((double) this.change > 0.0)
    {
      this.textAsset.text = string.Format(this.formatChangeUp, (object) this.current, (object) this.change, (object) (float) ((double) this.current + (double) this.change));
    }
    else
    {
      if ((double) this.change >= 0.0)
        return;
      this.textAsset.text = string.Format(this.formatChangeDown, (object) this.current, (object) this.change, (object) (float) ((double) this.current + (double) this.change));
    }
  }

  public void ResolveAfter(float delay)
  {
    this.StopAllCoroutines();
    this.StartCoroutine(this.ResolveAdd(delay));
  }

  public IEnumerator ResolveAdd(float delay)
  {
    GoldDisplay goldDisplay = this;
    yield return (object) Sequences.Wait(delay);
    float timeBetween = Mathf.Min(goldDisplay.totalAddTime / Mathf.Abs(goldDisplay.add), goldDisplay.addBetweenTimeMax);
    Events.InvokeGoldCounterStart(goldDisplay, goldDisplay.add);
    while ((double) goldDisplay.add != 0.0)
    {
      if ((double) goldDisplay.add > 0.0)
      {
        goldDisplay.add--;
        ++goldDisplay.current;
      }
      else
      {
        goldDisplay.add++;
        --goldDisplay.current;
      }
      goldDisplay.UpdateText();
      yield return (object) Sequences.Wait(timeBetween);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: GridLayoutBasedOnAspect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

[RequireComponent(typeof (GridLayoutGroup))]
public class GridLayoutBasedOnAspect : MonoBehaviour
{
  public GridLayoutGroup _layoutGroup;
  [SerializeField]
  public AnimationCurve curve;
  [SerializeField]
  public bool setSpacing;
  [SerializeField]
  [ShowIf("setSpacing")]
  public Vector2 minSpacing;
  [SerializeField]
  [ShowIf("setSpacing")]
  public Vector2 maxSpacing;
  [SerializeField]
  public bool autoLinkToParent;

  public GridLayoutGroup layoutGroup => this._layoutGroup ?? (this._layoutGroup = this.GetComponent<GridLayoutGroup>());

  public void Awake()
  {
    if (!this.autoLinkToParent)
      return;
    WorldSpaceCanvasFitScreen componentInParent = this.transform.GetComponentInParent<WorldSpaceCanvasFitScreen>();
    if (!(bool) (Object) componentInParent)
      return;
    componentInParent.onUpdate.AddListener(new UnityAction<RectTransform>(this.UpdateLayout));
    this.UpdateLayout(componentInParent.rectTransform);
  }

  public void UpdateLayout(RectTransform canvas)
  {
    Vector2 sizeDelta = canvas.sizeDelta;
    float num = this.curve.Evaluate(sizeDelta.x / sizeDelta.y);
    if (!this.setSpacing)
      return;
    this.layoutGroup.spacing = this.minSpacing + (this.maxSpacing - this.minSpacing) * num;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: HackedTextEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System.Collections;
using TMPro;
using UnityEngine;

[RequireComponent(typeof (TMP_Text))]
public class HackedTextEffect : MonoBehaviour
{
  public TMP_Text _tmp;
  public char[] extraChars;
  public string[] extraCharColourHexes;
  public Vector2 delayBetweenRoutines = new Vector2(1f, 2f);

  public TMP_Text tmp => this._tmp ?? (this._tmp = this.GetComponent<TMP_Text>());

  public void SetText(string text)
  {
    this.StopAllCoroutines();
    this.StartRoutine(text);
  }

  public void StartRoutine(string text) => this.StartCoroutine(this.Routine(text));

  public void OnDisable() => this.StopAllCoroutines();

  public IEnumerator Routine(string text)
  {
    yield return (object) this.Appear(text);
    while (true)
    {
      yield return (object) new WaitForSeconds(this.delayBetweenRoutines.Random());
      yield return (object) Dead.Random.Choose<IEnumerator>(this.LoopChars(text), this.AddCharsRandom(text), this.AppendChars(text), this.AddChar(text), this.ReplaceChar(text), this.ColourChar(text), this.Appear(text));
    }
  }

  public IEnumerator Appear(string text)
  {
    for (int i = 1; i < text.Length; ++i)
    {
      char ch = Dead.Random.Choose<char>(this.extraChars.RandomItem<char>(), text[Mathf.Max(0, i - 1)]);
      this.tmp.text = text.Remove(i, 1).Insert(i, string.Format("<#{0}>{1}</color>", (object) this.extraCharColourHexes.RandomItem<string>(), (object) ch));
      this.tmp.maxVisibleCharacters = i + 1;
      yield return (object) new WaitForSeconds(0.05f);
    }
    this.tmp.text = text;
    this.tmp.maxVisibleCharacters = 1000;
    yield return (object) new WaitForSeconds(1f);
  }

  public IEnumerator LoopChars(string text)
  {
    int count = Dead.Random.Choose<int>(text.Length, Dead.Random.Range(0, text.Length));
    for (int i = 0; i < count; ++i)
    {
      char ch = Dead.Random.Choose<char>(this.extraChars.RandomItem<char>(), text[i]);
      this.tmp.text = text.Remove(i, 1).Insert(i, string.Format("<#{0}>{1}</color>", (object) this.extraCharColourHexes.RandomItem<string>(), (object) ch));
      yield return (object) new WaitForSeconds(PettyRandom.Range(0.025f, 0.05f));
      this.tmp.text = text;
      yield return (object) new WaitForSeconds(PettyRandom.Range(0.025f, 0.05f));
    }
  }

  public IEnumerator AddCharsRandom(string text)
  {
    int count = PettyRandom.Range(5, 15);
    for (int i = 0; i < count; ++i)
    {
      int num = text.RandomIndex<char>();
      char ch = Dead.Random.Choose<char>(this.extraChars.RandomItem<char>(), text[num]);
      this.tmp.text = text.Remove(num, 1).Insert(num, string.Format("<#{0}>{1}</color>", (object) this.extraCharColourHexes.RandomItem<string>(), (object) ch));
      yield return (object) new WaitForSeconds(PettyRandom.Range(0.05f, 0.1f));
      this.tmp.text = text;
      yield return (object) new WaitForSeconds(0.1f);
    }
  }

  public IEnumerator AppendChars(string text)
  {
    int count = PettyRandom.Range(1, 3);
    string str = text;
    char finalChar = str[str.Length - 1];
    for (int i = 0; i < count; ++i)
    {
      this.tmp.text += string.Format("<#{0}>{1}</color>", (object) this.extraCharColourHexes.RandomItem<string>(), (object) finalChar);
      yield return (object) new WaitForSeconds(PettyRandom.Range(0.1f, 0.2f));
    }
    yield return (object) new WaitForSeconds(0.3f);
    this.tmp.text = text;
  }

  public IEnumerator AddChar(string text)
  {
    int index = text.RandomIndex<char>();
    char c = Dead.Random.Choose<char>(this.extraChars.RandomItem<char>(), text[index]);
    int count = Dead.Random.Choose<int>(1, 2, 2);
    for (int i = 0; i < count; ++i)
    {
      this.tmp.text = this.tmp.text.Insert(index, string.Format("<#{0}>{1}</color>", (object) this.extraCharColourHexes.RandomItem<string>(), (object) c));
      yield return (object) new WaitForSeconds(PettyRandom.Range(1f, 2f));
    }
    this.tmp.text = text;
  }

  public IEnumerator ReplaceChar(string text)
  {
    int index = text.RandomIndex<char>();
    char ch = this.extraChars.RandomItem<char>();
    this.tmp.text = text.Remove(index, 1).Insert(index, string.Format("<#{0}>{1}</color>", (object) this.extraCharColourHexes.RandomItem<string>(), (object) ch));
    yield return (object) new WaitForSeconds(PettyRandom.Range(1f, 2f));
    this.tmp.text = text.Remove(index, 1).Insert(index, " ");
    yield return (object) new WaitForSeconds(1f);
  }

  public IEnumerator ColourChar(string text)
  {
    int index = text.RandomIndex<char>();
    char ch = text[index];
    string col = this.extraCharColourHexes.RandomItem<string>();
    this.tmp.text = text.Remove(index, 1).Insert(index, string.Format("<#{0}>{1}</color>", (object) col, (object) ch));
    yield return (object) new WaitForSeconds(PettyRandom.Range(2f, 3f));
    int count = Dead.Random.Range(6, 10) * Dead.Random.Choose<int>(1, 1, 1, 1, 1, 3);
    for (int i = 0; i < count; ++i)
    {
      this.tmp.text = text.Remove(index, 1).Insert(index, string.Format("<#{0}>{1}</color>", (object) col, (object) this.extraChars.RandomItem<char>()));
      yield return (object) new WaitForSeconds(PettyRandom.Range(0.025f, 0.05f));
    }
    yield return (object) new WaitForSeconds(1f);
    this.tmp.text = text;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: HandleSpinner
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

public class HandleSpinner : MonoBehaviour
{
  [SerializeField]
  public Transform handle;
  [SerializeField]
  public float startSpeed = 100f;
  [SerializeField]
  public float targetSpeed = 100f;
  [SerializeField]
  public float acceleration = 10f;
  [SerializeField]
  public float deceleration = 10f;
  public bool spinning;
  public float speed;

  [Button(null, EButtonEnableMode.Always)]
  public void Spin()
  {
    this.enabled = true;
    this.spinning = true;
    this.speed = this.startSpeed;
  }

  [Button(null, EButtonEnableMode.Always)]
  public void Stop() => this.spinning = false;

  public void Update()
  {
    float xAngle = -this.speed * Time.deltaTime;
    this.transform.Rotate(xAngle, 0.0f, 0.0f);
    this.handle.Rotate(-xAngle, 0.0f, 0.0f);
    if (this.spinning)
      this.speed = Mathf.Min(this.speed + this.acceleration * Time.deltaTime, this.targetSpeed);
    else
      this.speed = Mathf.Max(0.0f, this.speed - this.deceleration * Time.deltaTime);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: HandOverlay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class HandOverlay : MonoBehaviour
{
  [SerializeField]
  [ReadOnly]
  public Character owner;
  [SerializeField]
  public CardContainer drawContainer;
  [SerializeField]
  public CardContainer handContainer;
  [SerializeField]
  public CardContainer discardContainer;
  [SerializeField]
  public TweenUI showTween;
  [SerializeField]
  public TweenUI hideTween;
  [SerializeField]
  public SpriteSetter[] spriteSetters;
  [Header("Shadow For Battle Phase")]
  [SerializeField]
  public CanvasGroup shadow;
  [SerializeField]
  public LeanTweenType shadowFadeEase = LeanTweenType.easeInOutQuart;
  [SerializeField]
  public float shadowFadeDur = 1f;
  public bool shadowActive;

  public void Start()
  {
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnSettingChanged += new UnityAction<string, object>(this.SettingChanged);
    this.UpdateVisibility(Settings.Load<bool>("HideHandOverlay", false));
  }

  public void OnDestroy()
  {
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnSettingChanged -= new UnityAction<string, object>(this.SettingChanged);
  }

  public void BattlePhaseStart(Battle.Phase phase)
  {
    if (phase == Battle.Phase.Battle)
    {
      if (this.shadowActive)
        return;
      LeanTween.cancel(this.shadow.gameObject);
      this.shadow.LeanAlpha(1f, this.shadowFadeDur).setEase(this.shadowFadeEase);
      this.shadowActive = true;
    }
    else
    {
      if (!this.shadowActive)
        return;
      LeanTween.cancel(this.shadow.gameObject);
      this.shadow.LeanAlpha(0.0f, this.shadowFadeDur).setEase(this.shadowFadeEase);
      this.shadowActive = false;
    }
  }

  public void SettingChanged(string key, object value)
  {
    if (!(key == "HideHandOverlay") || !(value is bool hidden))
      return;
    this.UpdateVisibility(hidden);
  }

  public void UpdateVisibility(bool hidden) => this.gameObject.SetActive(!hidden);

  public void SetOwner(Character character)
  {
    this.owner = character;
    this.drawContainer.owner = this.owner;
    this.handContainer.owner = this.owner;
    this.discardContainer.owner = this.owner;
    this.owner.drawContainer = this.drawContainer;
    this.owner.handContainer = this.handContainer;
    this.owner.discardContainer = this.discardContainer;
    this.handContainer.SetSize(this.owner.data.handSize, this.handContainer.CardScale);
    foreach (SpriteSetter spriteSetter in this.spriteSetters)
      spriteSetter.Set(character.data.classData.name);
  }

  public IEnumerator Show()
  {
    SfxSystem.OneShot("event:/sfx/inventory/showup");
    this.showTween.Fire();
    yield return (object) Sequences.Wait(this.showTween.GetDuration());
  }

  public IEnumerator Hide()
  {
    this.hideTween.Fire();
    yield return (object) Sequences.Wait(this.hideTween.GetDuration());
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: HardModeModifierData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

[CreateAssetMenu(menuName = "Modifiers/Hard Mode Modifier", fileName = "Hard Mode Modifier")]
public class HardModeModifierData : ScriptableObject
{
  public GameModifierData modifierData;
  public int stormPoints;
  public bool unlockedByDefault;
  [HideIf("unlockedByDefault")]
  public HardModeModifierData[] unlockRequires;
  [HideIf("unlockedByDefault")]
  public int unlockRequiresPoints;
}
﻿// Decompiled with JetBrains decompiler
// Type: HardModeModifierDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class HardModeModifierDisplay : ModifierDisplay
{
  [SerializeField]
  public GameObject background;
  public GameModifierData[] modifiers;
  public List<string> active;

  public void Populate()
  {
    int num = SaveSystem.LoadProgressData<int>("hardModeModifiersUnlocked", 0);
    this.background.SetActive(num > 0);
    this.active = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers");
    if (this.active == null)
      this.active = new List<string>();
    for (int index = 0; index < num && index < this.modifiers.Length; ++index)
    {
      GameModifierData modifier = this.modifiers[index];
      ModifierIcon icon = this.CreateIcon(modifier);
      if (this.active.Contains(modifier.name))
        ModifierSystem.AddModifier(Campaign.Data, modifier);
      else
        icon.GetComponent<ModifierToggle>()?.Toggle();
      icon.GetComponentInChildren<InputAction>()?.action.AddListener((UnityAction) (() => this.Toggle(modifier)));
    }
  }

  public void Toggle(GameModifierData modifier)
  {
    if (this.active.Contains(modifier.name))
    {
      this.active.Remove(modifier.name);
      ModifierSystem.RemoveModifier(Campaign.Data, modifier);
    }
    else
    {
      this.active.Add(modifier.name);
      ModifierSystem.AddModifier(Campaign.Data, modifier);
    }
    SaveSystem.SaveProgressData<List<string>>("activeHardModeModifiers", this.active);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: HelpPanelShower
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;

public class HelpPanelShower : MonoBehaviour
{
  [SerializeField]
  public LocalizedString key;
  [SerializeField]
  public Prompt.Emote.Type emote = Prompt.Emote.Type.Explain;
  [SerializeField]
  public LocalizedString[] buttonTextKeys;
  [SerializeField]
  public string[] buttonHotKeys;
  [SerializeField]
  public bool canGoBack = true;

  public void SetKey(LocalizedString key, Prompt.Emote.Type? emoteType = null)
  {
    this.key = key;
    if (!emoteType.HasValue)
      return;
    this.emote = emoteType.Value;
  }

  public void Show()
  {
    HelpPanelSystem.Show(this.key);
    HelpPanelSystem.SetEmote(this.emote);
    HelpPanelSystem.SetBackButtonActive(this.canGoBack);
  }

  public void AddButton(int index, HelpPanelSystem.ButtonType type, UnityAction action) => HelpPanelSystem.AddButton(type, this.buttonTextKeys[index], this.buttonHotKeys[index], action);
}
﻿// Decompiled with JetBrains decompiler
// Type: HelpPanelSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;
using UnityEngine.Localization.Components;
using UnityEngine.UI;

public class HelpPanelSystem : GameSystem
{
  public static HelpPanelSystem _instance;
  public static GameObject _rtCamera;
  [SerializeField]
  public TMP_Text title;
  [SerializeField]
  public TMP_Text body;
  [SerializeField]
  public TMP_Text note;
  [SerializeField]
  public ImageSprite image;
  [SerializeField]
  public LayoutElement imageLayout;
  [Header("Button Options")]
  [SerializeField]
  public Transform buttonGroup;
  [SerializeField]
  public GameObject backButton;
  [SerializeField]
  public HelpPanelSystem.ButtonProfile[] buttonPrefabs;
  public static readonly Dictionary<HelpPanelSystem.ButtonType, HelpPanelSystem.ButtonProfile> buttonProfileLookup = new Dictionary<HelpPanelSystem.ButtonType, HelpPanelSystem.ButtonProfile>();
  [Header("Emotes")]
  [SerializeField]
  public Image emote;
  [SerializeField]
  public Prompt.Emote[] emoteTypes;
  [Header("SFX")]
  [SerializeField]
  public EventReference popUpSfx;
  public static bool Active;

  public static HelpPanelSystem instance => HelpPanelSystem._instance ?? (HelpPanelSystem._instance = UnityEngine.Object.FindObjectOfType<HelpPanelSystem>(true));

  public static GameObject rtCamera
  {
    get
    {
      GameObject rtCamera = HelpPanelSystem._rtCamera;
      if (rtCamera != null)
        return rtCamera;
      Camera[] objectsOfType = UnityEngine.Object.FindObjectsOfType<Camera>(true);
      return HelpPanelSystem._rtCamera = ((IEnumerable<Camera>) objectsOfType).First<Camera>((Func<Camera, bool>) (a => a.name == "RenderTextureCamera")).gameObject;
    }
  }

  public void Awake()
  {
    HelpPanelSystem.buttonProfileLookup.Clear();
    foreach (HelpPanelSystem.ButtonProfile buttonPrefab in this.buttonPrefabs)
      HelpPanelSystem.buttonProfileLookup[buttonPrefab.type] = buttonPrefab;
  }

  public void OnEnable()
  {
    HelpPanelSystem.Active = true;
    HelpPanelSystem.rtCamera.SetActive(true);
  }

  public void OnDisable()
  {
    HelpPanelSystem.Active = false;
    HelpPanelSystem.rtCamera.SetActive(false);
    foreach (Component component in this.buttonGroup)
      component.gameObject.Destroy();
    this.imageLayout.gameObject.SetActive(false);
  }

  public static void SetBackButtonActive(bool active) => HelpPanelSystem.instance.backButton.SetActive(active);

  public static void Show(LocalizedString key)
  {
    string[] strArray = key.GetLocalizedString().Split('|', StringSplitOptions.None);
    HelpPanelSystem.instance.title.gameObject.SetActive(strArray.Length != 0);
    HelpPanelSystem.instance.body.gameObject.SetActive(strArray.Length > 1);
    HelpPanelSystem.instance.note.gameObject.SetActive(strArray.Length > 2);
    HelpPanelSystem.instance.title.text = strArray.Length != 0 ? strArray[0] : "";
    HelpPanelSystem.instance.body.text = strArray.Length > 1 ? strArray[1] : "";
    HelpPanelSystem.instance.note.text = strArray.Length > 2 ? strArray[2] : "";
    SfxSystem.OneShot(HelpPanelSystem.instance.popUpSfx);
    HelpPanelSystem.instance.gameObject.SetActive(true);
  }

  public static void SetEmote(Prompt.Emote.Type emoteType) => HelpPanelSystem.instance.emote.sprite = ((IEnumerable<Prompt.Emote>) HelpPanelSystem.instance.emoteTypes).FirstOrDefault<Prompt.Emote>((Func<Prompt.Emote, bool>) (a => a.type == emoteType)).sprite;

  public static void AddButton(
    HelpPanelSystem.ButtonType type,
    LocalizedString textKey,
    string hotKey,
    UnityAction onSelect)
  {
    HelpPanelSystem.ButtonProfile buttonProfile;
    if (!HelpPanelSystem.buttonProfileLookup.TryGetValue(type, out buttonProfile))
      return;
    GameObject gameObject = UnityEngine.Object.Instantiate<GameObject>(buttonProfile.prefab, HelpPanelSystem.instance.buttonGroup);
    gameObject.GetComponent<RewiredHotKeyController>()?.SetActionName(hotKey);
    Button componentInChildren = gameObject.GetComponentInChildren<Button>();
    if (onSelect != null)
      componentInChildren.onClick.AddListener(onSelect);
    componentInChildren.onClick.AddListener((UnityAction) (() => HelpPanelSystem.instance.gameObject.SetActive(false)));
    gameObject.GetComponentInChildren<LocalizeStringEvent>().StringReference = textKey;
  }

  public static void SetImage(float width, float height, Sprite sprite)
  {
    HelpPanelSystem.instance.imageLayout.gameObject.SetActive(true);
    HelpPanelSystem.instance.image.SetSprite(sprite);
    HelpPanelSystem.instance.imageLayout.preferredWidth = width;
    HelpPanelSystem.instance.imageLayout.preferredHeight = height;
  }

  [Serializable]
  public struct ButtonProfile
  {
    [SerializeField]
    public HelpPanelSystem.ButtonType type;
    [SerializeField]
    public GameObject prefab;
  }

  public enum ButtonType
  {
    Positive,
    Negative,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Hit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

public class Hit
{
  public Entity attacker;
  public readonly Character owner;
  public readonly Entity target;
  public string damageType = "basic";
  public Trigger trigger;
  public int damage;
  public int damageBlocked;
  [CompilerGenerated]
  public int \u003CdamageDealt\u003Ek__BackingField;
  public int counterReduction;
  public float screenShake = 1f;
  public bool countsAsHit = true;
  public bool canBeNullified = true;
  public bool nullified;
  public List<CardData.StatusEffectStacks> statusEffects;
  public bool doAnimation = true;
  public bool canRetaliate = true;
  public bool dodged;
  [CompilerGenerated]
  public bool \u003COffensive\u003Ek__BackingField;
  public int extraOffensiveness;

  public int damageDealt
  {
    get => this.\u003CdamageDealt\u003Ek__BackingField;
    set => this.\u003CdamageDealt\u003Ek__BackingField = value;
  }

  public bool Offensive
  {
    get => this.\u003COffensive\u003Ek__BackingField;
    set => this.\u003COffensive\u003Ek__BackingField = value;
  }

  public int GetOffensiveness()
  {
    int offensiveness = Mathf.Max(0, this.damage) + this.damageBlocked + this.extraOffensiveness;
    if (this.statusEffects != null)
    {
      foreach (CardData.StatusEffectStacks statusEffect in this.statusEffects)
      {
        if (statusEffect.data.offensive)
          offensiveness += statusEffect.count;
      }
    }
    return offensiveness;
  }

  public bool Supportive
  {
    get
    {
      if (this.damage < 0)
        return true;
      if (this.statusEffects != null)
      {
        foreach (CardData.StatusEffectStacks statusEffect in this.statusEffects)
        {
          if (!statusEffect.data.offensive)
            return true;
        }
      }
      return false;
    }
  }

  public int GetSupportiveness()
  {
    int supportiveness = Mathf.Max(0, -this.damage);
    if (this.statusEffects != null)
    {
      foreach (CardData.StatusEffectStacks statusEffect in this.statusEffects)
      {
        if (!statusEffect.data.offensive)
          supportiveness += statusEffect.count;
      }
    }
    return supportiveness;
  }

  public bool BasicHit => this.damageType == "basic";

  public Hit(Entity attacker, Entity target)
  {
    this.attacker = attacker;
    if ((bool) (Object) attacker)
    {
      this.owner = attacker.owner;
      this.damage = Mathf.Max(0, attacker.damage.current + attacker.tempDamage.Value);
      this.countsAsHit = attacker.data.hasAttack;
      if (this.countsAsHit)
        this.Offensive = attacker.IsOffensive();
    }
    this.target = target;
  }

  public Hit(Entity attacker, Entity target, int damage)
  {
    this.attacker = attacker;
    if ((bool) (Object) attacker)
      this.owner = attacker.owner;
    this.target = target;
    this.damage = damage;
    this.Offensive = damage > 0;
  }

  public void AddAttackerStatuses()
  {
    if (!(bool) (Object) this.attacker.data || this.attacker.attackEffects == null || this.attacker.silenced)
      return;
    foreach (CardData.StatusEffectStacks attackEffect in this.attacker.attackEffects)
    {
      int attackEffectAmount = this.CalculateAttackEffectAmount(attackEffect.count);
      if (attackEffectAmount > 0)
        this.AddStatusEffect(attackEffect.data, attackEffectAmount);
    }
  }

  public int CalculateAttackEffectAmount(int statusEffectStacks) => !this.attacker.silenced ? Mathf.Max(0, Mathf.RoundToInt((float) (statusEffectStacks + this.attacker.effectBonus) * this.attacker.effectFactor)) : 0;

  public void AddStatusEffect(CardData.StatusEffectStacks statusEffect)
  {
    if (this.statusEffects == null)
      this.statusEffects = new List<CardData.StatusEffectStacks>();
    this.statusEffects.Add(statusEffect);
    if (this.Offensive || !this.countsAsHit || !statusEffect.data.offensive)
      return;
    this.Offensive = true;
  }

  public void AddStatusEffect(StatusEffectData statusEffectData, int count) => this.AddStatusEffect(new CardData.StatusEffectStacks()
  {
    data = statusEffectData,
    count = count
  });

  public IEnumerator Process()
  {
    Hit hit = this;
    if ((bool) (Object) hit.target)
    {
      if (hit.countsAsHit)
        hit.target.lastHit = hit;
      if (hit.countsAsHit)
        yield return (object) StatusEffectSystem.HitEvent(hit);
      if (!hit.dodged)
      {
        Events.InvokeEntityHit(hit);
        if (!hit.nullified)
        {
          if (hit.damage != 0)
          {
            hit.damageDealt = hit.damage;
            int num = hit.target.hp.current - hit.damage;
            if (num > hit.target.hp.max)
            {
              hit.damageDealt += num - hit.target.hp.max;
              num = hit.target.hp.max;
            }
            hit.target.hp.current = num;
          }
          hit.target.counter.current = Mathf.Max(hit.target.counter.current - hit.counterReduction, 0);
        }
        Routine.Clump clump = new Routine.Clump();
        if (!hit.nullified)
        {
          List<CardData.StatusEffectStacks> statusEffects = hit.statusEffects;
          if (statusEffects != null && statusEffects.Count > 0)
          {
            foreach (CardData.StatusEffectStacks statusEffect in hit.statusEffects)
              clump.Add(StatusEffectSystem.Apply(hit.target, hit.attacker, statusEffect.data, statusEffect.count));
          }
        }
        hit.target.PromptUpdate();
        if (clump.Count > 0)
          yield return (object) clump.WaitForEnd();
      }
      else
        Events.InvokeEntityDodge(hit);
      Events.InvokeEntityPostHit(hit);
      if (hit.countsAsHit)
        yield return (object) StatusEffectSystem.PostHitEvent(hit);
      yield return (object) Sequences.Null();
    }
  }

  public void FlagAsOffensive() => this.Offensive = true;
}
﻿// Decompiled with JetBrains decompiler
// Type: HitAnimationSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class HitAnimationSystem : GameSystem
{
  [SerializeField]
  public AnimationCurve hitCurve;
  [SerializeField]
  public float strength = 0.65f;
  [SerializeField]
  public AnimationCurve strengthCurve;
  [SerializeField]
  public float duration = 0.667f;
  [SerializeField]
  public AnimationCurve durationCurve;
  [SerializeField]
  public float wobble = 2f;
  [SerializeField]
  public AnimationCurve wobbleCurve;

  public void OnEnable()
  {
    global::Events.OnEntityHit += new UnityAction<Hit>(this.EntityHit);
    global::Events.OnEntityDodge += new UnityAction<Hit>(this.EntityDodge);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHit -= new UnityAction<Hit>(this.EntityHit);
    global::Events.OnEntityDodge -= new UnityAction<Hit>(this.EntityDodge);
  }

  public void EntityDodge(Hit hit)
  {
    if (!hit.Offensive || !hit.doAnimation)
      return;
    Entity target = hit.target;
    if (target == null || !(target.display is Card))
      return;
    this.CardTakeHit(hit);
  }

  public void EntityHit(Hit hit)
  {
    if (!hit.Offensive || !hit.doAnimation || !hit.countsAsHit)
      return;
    Entity target = hit.target;
    if (target == null || !(target.display is Card))
      return;
    this.CardTakeHit(hit);
  }

  public void CardTakeHit(Hit hit)
  {
    CurveAnimator curveAnimator = hit.target.curveAnimator;
    if (curveAnimator == null)
      return;
    int offensiveness = hit.GetOffensiveness();
    float num1 = this.strength * this.strengthCurve.Evaluate((float) offensiveness);
    float duration = this.duration * this.durationCurve.Evaluate((float) offensiveness);
    float num2 = this.wobble * this.wobbleCurve.Evaluate((float) offensiveness);
    Vector3 attackerPos = (bool) (Object) hit.attacker ? hit.attacker.transform.position : Vector3.zero;
    Vector3 hitDirection = HitAnimationSystem.GetHitDirection(hit.target.transform.position, attackerPos);
    double num3 = (double) curveAnimator.Move(hitDirection * num1, this.hitCurve, 0.0f, duration);
    if ((double) num2 <= 0.0 || !(bool) (Object) hit.target.wobbler)
      return;
    hit.target.wobbler.Wobble(hitDirection * num2);
  }

  public static Vector3 GetHitDirection(Vector3 targetPos, Vector3 attackerPos) => (targetPos - attackerPos).normalized;
}
﻿// Decompiled with JetBrains decompiler
// Type: HitFlashSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class HitFlashSystem : GameSystem
{
  public static HitFlashSystem instance;
  [SerializeField]
  public float flashDuration = 0.1f;
  [SerializeField]
  public Material damageMaterial;
  public readonly List<HitFlashSystem.HitFlash> list = new List<HitFlashSystem.HitFlash>();

  public void Awake() => HitFlashSystem.instance = this;

  public void OnEnable() => global::Events.OnEntityHit += new UnityAction<Hit>(this.EntityHit);

  public void Update()
  {
    for (int index = this.list.Count - 1; index >= 0; --index)
    {
      HitFlashSystem.HitFlash hitFlash = this.list[index];
      hitFlash.Update(Time.deltaTime);
      if (hitFlash.ended)
        this.list.RemoveAt(index);
    }
  }

  public void OnDisable()
  {
    global::Events.OnEntityHit -= new UnityAction<Hit>(this.EntityHit);
    foreach (HitFlashSystem.HitFlash hitFlash in this.list)
      hitFlash.End();
    this.list.Clear();
  }

  public void EntityHit(Hit hit)
  {
    if (!hit.Offensive || hit.nullified)
      return;
    HitFlashSystem.HitFlash hitFlash = this.list.Find((Predicate<HitFlashSystem.HitFlash>) (a => (UnityEngine.Object) a.target == (UnityEngine.Object) hit.target));
    if (hitFlash != null)
      hitFlash.time = this.flashDuration;
    else
      this.list.Add(new HitFlashSystem.HitFlash(hit.target, this.damageMaterial, this.flashDuration));
  }

  public void RemoveFromTarget(Entity entity)
  {
    HitFlashSystem.HitFlash hitFlash = this.list.Find((Predicate<HitFlashSystem.HitFlash>) (a => (UnityEngine.Object) a.target == (UnityEngine.Object) entity));
    if (hitFlash == null)
      return;
    hitFlash.End();
    this.list.Remove(hitFlash);
  }

  public static void Remove(Entity entity)
  {
    if (!((UnityEngine.Object) HitFlashSystem.instance != (UnityEngine.Object) null))
      return;
    HitFlashSystem.instance.RemoveFromTarget(entity);
  }

  public class HitFlash
  {
    [CompilerGenerated]
    public Entity \u003Ctarget\u003Ek__BackingField;
    public Material material;
    public float time;
    public Dictionary<Image, Material> imageDict = new Dictionary<Image, Material>();
    public List<TMP_Text> textElements = new List<TMP_Text>();

    public Entity target
    {
      get => this.\u003Ctarget\u003Ek__BackingField;
      set => this.\u003Ctarget\u003Ek__BackingField = value;
    }

    public bool ended => (double) this.time <= 0.0;

    public HitFlash(Entity entity, Material material, float duration)
    {
      this.target = entity;
      this.material = material;
      this.time = duration;
      this.Start();
    }

    public void Start()
    {
      Image[] componentsInChildren1 = this.target.GetComponentsInChildren<Image>(true);
      TMP_Text[] componentsInChildren2 = this.target.GetComponentsInChildren<TMP_Text>(true);
      foreach (Image key in componentsInChildren1)
      {
        if (key.enabled && (UnityEngine.Object) key.sprite != (UnityEngine.Object) null && (UnityEngine.Object) key.gameObject.GetComponent<Mask>() == (UnityEngine.Object) null)
        {
          this.imageDict.Add(key, key.material);
          key.material = this.material;
        }
      }
      foreach (TMP_Text tmpText in componentsInChildren2)
      {
        if (tmpText.enabled)
        {
          this.textElements.Add(tmpText);
          tmpText.enabled = false;
        }
      }
    }

    public void Update(float delta)
    {
      this.time -= delta;
      if ((double) this.time > 0.0)
        return;
      this.End();
    }

    public void End()
    {
      foreach (KeyValuePair<Image, Material> keyValuePair in this.imageDict)
      {
        if ((UnityEngine.Object) keyValuePair.Key != (UnityEngine.Object) null)
          keyValuePair.Key.material = keyValuePair.Value;
      }
      foreach (TMP_Text textElement in this.textElements)
      {
        if ((UnityEngine.Object) textElement != (UnityEngine.Object) null)
          textElement.enabled = true;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: HotKeyDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

[RequireComponent(typeof (Image))]
public class HotKeyDisplay : MonoBehaviour
{
  public Image _image;
  [SerializeField]
  public string actionName;

  public Image image => this._image ?? (this._image = this.GetComponent<Image>());

  public void OnEnable()
  {
    global::Events.OnButtonStyleChanged += new UnityAction(this.Refresh);
    this.Refresh();
  }

  public void OnDisable() => global::Events.OnButtonStyleChanged -= new UnityAction(this.Refresh);

  public void Refresh()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
    {
      this.image.enabled = false;
    }
    else
    {
      JoystickButtonStyle.ElementButton element = ControllerButtonSystem.GetElement(RewiredControllerManager.GetPlayerController(0), this.actionName);
      this.image.enabled = element != null && element.hasSprite;
      if (!this.image.enabled)
        return;
      this.image.sprite = element.buttonSprite;
    }
  }

  public void SetActionName(string value)
  {
    this.actionName = value;
    this.Refresh();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Hover3dSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class Hover3dSystem : GameSystem
{
  public Camera cam;
  [SerializeField]
  public LayerMask layerMask;
  [SerializeField]
  public List<Hoverable3d> hoverList;
  public List<Hoverable3d> newList;
  public readonly RaycastHit[] hits = new RaycastHit[5];

  public void OnEnable()
  {
    this.cam = Camera.main;
    this.hoverList = new List<Hoverable3d>();
    this.newList = new List<Hoverable3d>();
  }

  public void Update()
  {
    int num = Physics.RaycastNonAlloc(this.cam.ScreenPointToRay((Vector3) MonoBehaviourSingleton<Cursor3d>.instance.GetScreenPoint()), this.hits, 100f, (int) this.layerMask);
    for (int index = 0; index < num; ++index)
    {
      Hoverable3d component = this.hits[index].transform.GetComponent<Hoverable3d>();
      if (component != null)
      {
        this.newList.Add(component);
        if (!this.hoverList.Contains(component))
          component.Hover();
      }
    }
    foreach (Hoverable3d hover in this.hoverList)
    {
      if (!this.newList.Contains(hover))
        hover.UnHover();
    }
    this.hoverList.Clear();
    this.hoverList.AddRange((IEnumerable<Hoverable3d>) this.newList);
    this.newList.Clear();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Hoverable3d
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class Hoverable3d : GameSystem
{
  [SerializeField]
  public UnityEvent onHover;
  [SerializeField]
  public UnityEvent onUnHover;

  public void Hover() => this.onHover?.Invoke();

  public void UnHover() => this.onUnHover?.Invoke();
}
﻿// Decompiled with JetBrains decompiler
// Type: HUDCanvas
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

[RequireComponent(typeof (CanvasGroup))]
public class HUDCanvas : MonoBehaviour
{
  public CanvasGroup _canvasGroup;

  public CanvasGroup canvasGroup => this._canvasGroup ?? (this._canvasGroup = this.GetComponent<CanvasGroup>());

  public void Awake()
  {
    this.canvasGroup.alpha = Settings.Load<float>("HudAlpha", 1f);
    global::Events.OnSettingChanged += new UnityAction<string, object>(this.SettingChanged);
  }

  public void OnDestroy() => global::Events.OnSettingChanged -= new UnityAction<string, object>(this.SettingChanged);

  public void SettingChanged(string key, object value)
  {
    if (!(key == "HudAlpha") || !(value is float num))
      return;
    this.canvasGroup.alpha = num;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ICardDestroyed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public interface ICardDestroyed
{
  void Final();
}
﻿// Decompiled with JetBrains decompiler
// Type: IcebreakerHutSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class IcebreakerHutSequence : BuildingSequence
{
  [SerializeField]
  public string metaprogressionKey = "events";
  [SerializeField]
  public ImageSprite[] nodes;
  [SerializeField]
  public ButtonAnimator[] buttons;
  [SerializeField]
  public ChallengeData[] challenges;
  [SerializeField]
  public ChallengeDisplayCreator challengeDisplayCreator;
  [SerializeField]
  public string firstGreetKey = "icebreakerFirstGreet";
  [SerializeField]
  public MapInspectSequence mapInspectSequence;
  [SerializeField]
  public EventReference denySfx;
  public readonly List<bool> unlocked = new List<bool>();

  public override IEnumerator Sequence()
  {
    IcebreakerHutSequence icebreakerHutSequence = this;
    if (icebreakerHutSequence.building.HasUncheckedUnlocks)
    {
      foreach (string uncheckedUnlock in icebreakerHutSequence.building.uncheckedUnlocks)
        icebreakerHutSequence.Unlock(uncheckedUnlock);
      icebreakerHutSequence.building.uncheckedUnlocks.Clear();
      icebreakerHutSequence.TalkerSay("new event", 0.5f);
    }
    else if (!icebreakerHutSequence.firstGreetKey.IsNullOrEmpty() && !SaveSystem.LoadProgressData<bool>(icebreakerHutSequence.firstGreetKey, false))
    {
      icebreakerHutSequence.TalkerFirstGreet();
      SaveSystem.SaveProgressData<bool>(icebreakerHutSequence.firstGreetKey, true);
    }
    else
      icebreakerHutSequence.TalkerGreet();
    List<string> checkedUnlocks = icebreakerHutSequence.building.checkedUnlocks;
    // ISSUE: explicit non-virtual call
    int count = checkedUnlocks != null ? __nonvirtual (checkedUnlocks.Count) : 0;
    icebreakerHutSequence.SetUpMapNodes(count);
    icebreakerHutSequence.SetCurrentChallenge(count);
    yield return (object) null;
  }

  public void Unlock(string unlockDataName)
  {
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>(this.building.type.unlockedCheckedKey, (List<string>) null) ?? new List<string>();
    stringList.Add(unlockDataName);
    SaveSystem.SaveProgressData<List<string>>(this.building.type.unlockedCheckedKey, stringList);
    Building building = this.building;
    if (building.unlocks == null)
      building.unlocks = new List<string>();
    this.building.unlocks.Add(unlockDataName);
  }

  public void SetUpMapNodes(int unlocked)
  {
    List<string> stringList = MetaprogressionSystem.Get<List<string>>(this.metaprogressionKey);
    for (int index = 0; index < stringList.Count; ++index)
      this.unlocked.Add(index < unlocked);
    for (int index = 0; index < unlocked && index < stringList.Count; ++index)
    {
      CampaignNodeType campaignNodeType = AddressableLoader.Get<CampaignNodeType>("CampaignNodeType", stringList[index]);
      this.nodes[index].SetSprite(campaignNodeType.mapNodeSprite);
      this.buttons[index].interactable = true;
    }
  }

  public void SetCurrentChallenge(int unlocked)
  {
    if (unlocked >= this.challenges.Length)
      return;
    this.challengeDisplayCreator.challenge = this.challenges[unlocked];
    this.challengeDisplayCreator.Check();
  }

  public void TryInspect(int mapNodeIndex)
  {
    if (this.unlocked[mapNodeIndex])
      this.mapInspectSequence.Inspect(mapNodeIndex);
    else
      this.Deny(this.nodes[mapNodeIndex].gameObject);
  }

  public void Deny(GameObject obj)
  {
    SfxSystem.OneShot(this.denySfx);
    LeanTween.cancel(obj);
    LeanTween.moveLocal(obj, Vector3.zero, 0.67f).setFrom(new Vector3(0.5f.WithRandomSign(), 0.0f, 0.0f)).setEaseOutElastic();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: IconUpdater
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof (Image))]
[RequireComponent(typeof (StatusIcon))]
public class IconUpdater : MonoBehaviour
{
  public Sprite iconIfValueBelowMax;
  public Sprite iconIfValueAboveMax;
  public Image image;
  public Sprite defaultIcon;

  public void Awake()
  {
    this.image = this.GetComponent<Image>();
    this.defaultIcon = this.image.sprite;
  }

  public void CheckUpdate(Stat previousValue, Stat newValue)
  {
    StatusIcon component = this.GetComponent<StatusIcon>();
    if (!((Object) component != (Object) null) || !((Object) component.target != (Object) null))
      return;
    if (newValue.current < newValue.max && previousValue.current >= previousValue.max)
      this.image.sprite = (Object) this.iconIfValueBelowMax != (Object) null ? this.iconIfValueBelowMax : this.defaultIcon;
    else if ((Object) this.iconIfValueAboveMax != (Object) null && newValue.current > newValue.max && previousValue.current <= previousValue.max)
    {
      this.image.sprite = (Object) this.iconIfValueAboveMax != (Object) null ? this.iconIfValueAboveMax : this.defaultIcon;
    }
    else
    {
      if (newValue.current != newValue.max || previousValue.current == previousValue.max)
        return;
      this.image.sprite = this.defaultIcon;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: IdleAnimationSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class IdleAnimationSystem : GameSystem
{
  public readonly List<Entity> current = new List<Entity>();

  public void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
    this.current.Clear();
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
  }

  public void EntityHover(Entity entity)
  {
    if (!(bool) (Object) entity.data.idleAnimationProfile || !(entity.display is Card display))
      return;
    display.imageIdleAnimator.FadeIn();
    display.backgroundIdleAnimator.FadeIn();
    this.current.Add(entity);
  }

  public void EntityUnHover(Entity entity)
  {
    if (!this.current.Contains(entity) || !(entity.display is Card display))
      return;
    display.imageIdleAnimator.FadeOut();
    display.backgroundIdleAnimator.FadeOut();
    this.current.Remove(entity);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: BetaJester.EnumGenerator.IEnumContainer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

namespace BetaJester.EnumGenerator
{
  public interface IEnumContainer
  {
    EnumInfo[] GetEnums();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: IListExt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public static class IListExt
{
  public static SaveCollection<string> ToSaveCollectionOfNames<T>(this IList<T> list) where T : Object => new SaveCollection<string>(list.ToArrayOfNames<T>());

  public static void DestroyAllAndClear(this IList<GameObject> list)
  {
    foreach (GameObject gameObject in (IEnumerable<GameObject>) list)
      gameObject.Destroy();
    list.Clear();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ILoadableExt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;

public static class ILoadableExt
{
  public static T[] LoadArray<T, TSaveData>(this TSaveData[] data) where TSaveData : ILoadable<T> => data.LoadList<T, TSaveData>().ToArray();

  public static List<T> LoadList<T, TSaveData>(this TSaveData[] data) where TSaveData : ILoadable<T>
  {
    List<T> list = new List<T>();
    foreach (TSaveData saveData in data)
      list.AddIfNotNull<T>(saveData.Load());
    return list;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ILoadable`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public interface ILoadable<T>
{
  T Load();
}
﻿// Decompiled with JetBrains decompiler
// Type: ImageCutout
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ImageCutout : ImageSprite
{
  public override Material materialForRendering
  {
    get
    {
      if (!this.maskable)
        return base.materialForRendering;
      Material materialForRendering = new Material(base.materialForRendering);
      materialForRendering.SetInt("_StencilComp", 6);
      return materialForRendering;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ImageDropShadow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof (Image))]
public class ImageDropShadow : MonoBehaviourRect
{
  [SerializeField]
  public Vector2 offset = new Vector2(0.1f, -0.1f);
  [SerializeField]
  public Material shadowMaterial;
  [SerializeField]
  public Color shadowColor;
  public Image caster;
  public Image shadow;
  public RectTransform casterTransform;
  public RectTransform shadowTransform;

  public IEnumerator Start()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    ImageDropShadow imageDropShadow = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      imageDropShadow.shadowTransform.localScale = Vector3.one;
      imageDropShadow.shadowTransform.localEulerAngles = Vector3.zero;
      imageDropShadow.shadow = imageDropShadow.shadowTransform.gameObject.AddComponent<Image>();
      imageDropShadow.shadow.raycastTarget = false;
      imageDropShadow.shadow.material = imageDropShadow.shadowMaterial;
      imageDropShadow.shadow.sprite = imageDropShadow.caster.sprite;
      imageDropShadow.shadow.color = imageDropShadow.shadowColor;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    imageDropShadow.caster = imageDropShadow.GetComponent<Image>();
    imageDropShadow.casterTransform = imageDropShadow.rectTransform;
    imageDropShadow.shadowTransform = new GameObject(nameof (ImageDropShadow), new System.Type[1]
    {
      typeof (RectTransform)
    }).GetComponent<RectTransform>();
    imageDropShadow.shadowTransform.SetParent(imageDropShadow.casterTransform.parent);
    imageDropShadow.shadowTransform.SetSiblingIndex(imageDropShadow.casterTransform.GetSiblingIndex());
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) null;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public void LateUpdate()
  {
    this.shadowTransform.sizeDelta = this.casterTransform.sizeDelta;
    this.shadowTransform.anchoredPosition = this.casterTransform.anchoredPosition + this.offset;
    this.shadowTransform.rotation = this.casterTransform.rotation;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ImageSprite
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class ImageSprite : Image
{
  [SerializeField]
  public bool copySpriteSize = true;
  [SerializeField]
  public bool copySpritePivot = true;

  public void SetSprite(Sprite sprite)
  {
    this.sprite = sprite;
    if (!(bool) (Object) sprite)
      return;
    Vector2 size = sprite.rect.size;
    if (this.copySpritePivot)
    {
      Vector3 anchoredPosition3D = this.rectTransform.anchoredPosition3D;
      this.rectTransform.pivot = sprite.pivot / size;
      this.rectTransform.anchoredPosition3D = anchoredPosition3D;
    }
    if (!this.copySpriteSize)
      return;
    this.rectTransform.sizeDelta = size / sprite.pixelsPerUnit;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: INavigationState
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public interface INavigationState
{
  void Begin();

  void End();
}
﻿// Decompiled with JetBrains decompiler
// Type: InjuredCompanionEventSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class InjuredCompanionEventSystem : GameSystem
{
  public void OnEnable() => Events.OnCampaignLoadPreset += new Events.UnityActionRef<string[]>(InjuredCompanionEventSystem.CampaignLoadPreset);

  public void OnDisable() => Events.OnCampaignLoadPreset -= new Events.UnityActionRef<string[]>(InjuredCompanionEventSystem.CampaignLoadPreset);

  public static int GetCampaignInsertPosition(RunHistory mostRecentRun)
  {
    CampaignStats stats = mostRecentRun.stats;
    int num = stats != null ? stats.Count("battlesWon") : 0;
    int campaignInsertPosition = num >= 6 ? 23 : (num >= 3 ? 11 : 2);
    Debug.Log((object) string.Format("InjuredCompanionEventSystem - Battles Won: {0} - Insert Pos: {1}", (object) num, (object) campaignInsertPosition));
    return campaignInsertPosition;
  }

  public static void CampaignLoadPreset(ref string[] lines)
  {
    if (!Campaign.Data.GameMode.mainGameMode || Campaign.Data.GameMode.tutorialRun)
      return;
    RunHistory mostRecentRun = InjuredCompanionEventSystem.GetMostRecentRun();
    if (mostRecentRun == null || mostRecentRun.result != Campaign.Result.Lose || !InjuredCompanionEventSystem.HasEligibleCompanion(mostRecentRun))
      return;
    int campaignInsertPosition = InjuredCompanionEventSystem.GetCampaignInsertPosition(mostRecentRun);
    lines[0] = lines[0].Insert(campaignInsertPosition, "#");
    lines[1] = lines[1].Insert(campaignInsertPosition, " ");
    lines[2] = lines[2].Insert(campaignInsertPosition, lines[2][campaignInsertPosition - 1].ToString());
    lines[3] = lines[3].Insert(campaignInsertPosition, lines[3][campaignInsertPosition - 1].ToString());
  }

  public static RunHistory GetMostRecentRun()
  {
    List<RunHistory> runHistoryList = SaveSystem.LoadHistoryData<List<RunHistory>>("list");
    if (runHistoryList != null && runHistoryList.Count > 0)
    {
      for (int index = runHistoryList.Count - 1; index >= 0; --index)
      {
        if (runHistoryList[index] != null)
        {
          string gameModeName = runHistoryList[index].gameModeName;
          if (gameModeName != null)
          {
            GameMode gameMode = AddressableLoader.Get<GameMode>("GameMode", gameModeName);
            if ((bool) (Object) gameMode && gameMode.mainGameMode)
              return runHistoryList[index];
          }
        }
      }
    }
    return (RunHistory) null;
  }

  public static bool HasEligibleCompanion(RunHistory run)
  {
    string[] unlockedPets = MetaprogressionSystem.GetUnlockedPets();
    foreach (CardSaveData card in run.inventory.deck)
    {
      if (InjuredCompanionEventSystem.IsEligible(card, unlockedPets))
        return true;
    }
    foreach (CardSaveData card in run.inventory.reserve)
    {
      if (InjuredCompanionEventSystem.IsEligible(card, unlockedPets))
        return true;
    }
    return false;
  }

  public static bool IsEligible(CardSaveData card, string[] illegal)
  {
    if (illegal.Contains<string>(card.name))
      return false;
    CardData cardData = card.Peek();
    return (bool) (Object) cardData && cardData.cardType.name == "Friendly";
  }

  public static List<CardSaveData> GetEligibleCompanions(RunHistory run)
  {
    string[] unlockedPets = MetaprogressionSystem.GetUnlockedPets();
    List<CardSaveData> eligibleCompanions = new List<CardSaveData>();
    foreach (CardSaveData card in run.inventory.deck)
    {
      if (InjuredCompanionEventSystem.IsEligible(card, unlockedPets))
        eligibleCompanions.Add(card);
    }
    foreach (CardSaveData card in run.inventory.reserve)
    {
      if (InjuredCompanionEventSystem.IsEligible(card, unlockedPets))
        eligibleCompanions.Add(card);
    }
    return eligibleCompanions;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: InjurySystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class InjurySystem : GameSystem
{
  [SerializeField]
  public CardType[] typesThatCanBeInjured;
  [SerializeField]
  public StatusEffectData injuryEffect;
  [SerializeField]
  public List<CardData> injuredThisBattle;

  public void OnEnable()
  {
    global::Events.OnBattleStart += new UnityAction(this.BattleStart);
    global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnBattleSaved += new UnityAction(this.BattleSaved);
    global::Events.OnBattleLoaded += new UnityAction(this.BattleLoaded);
  }

  public void OnDisable()
  {
    global::Events.OnBattleStart -= new UnityAction(this.BattleStart);
    global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnBattleSaved -= new UnityAction(this.BattleSaved);
    global::Events.OnBattleLoaded -= new UnityAction(this.BattleLoaded);
  }

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    if (InjurySystem.IsPlayerCard(entity.data))
    {
      if (InjurySystem.AnyAliveClonesOfThisCard(entity.data))
        return;
      this.Injure(entity.data);
    }
    else
    {
      CardData originalCardData;
      if (!InjurySystem.IsCloneOfPlayerCard(entity.data, out originalCardData) || InjurySystem.IsCardAlive(originalCardData) || InjurySystem.AnyAliveClonesOfThisCard(originalCardData))
        return;
      this.Injure(originalCardData);
    }
  }

  public void BattleStart()
  {
    if (this.injuredThisBattle == null)
      this.injuredThisBattle = new List<CardData>();
    this.injuredThisBattle.Clear();
  }

  public void BattleSaved()
  {
    if (!Campaign.Data.GameMode.doSave)
      return;
    CardData[] injuriesThisBattle = InjurySystem.GetInjuriesThisBattle();
    if (injuriesThisBattle == null || injuriesThisBattle.Length <= 0)
      return;
    InjurySystem.SaveState saveState = new InjurySystem.SaveState(Campaign.FindCharacterNode(References.Player).id, (IEnumerable<CardData>) injuriesThisBattle);
    SaveSystem.SaveCampaignData<InjurySystem.SaveState>(Campaign.Data.GameMode, "battleInjuredThisBattle", saveState);
  }

  public void BattleLoaded()
  {
    InjurySystem.SaveState saveState = SaveSystem.LoadCampaignData<InjurySystem.SaveState>(Campaign.Data.GameMode, "battleInjuredThisBattle");
    if (saveState == null || Campaign.FindCharacterNode(References.Player).id != saveState.campaignNodeId || saveState.injuredThisBattleIds == null)
      return;
    this.injuredThisBattle = saveState.Load();
    foreach (CardData cardData1 in this.injuredThisBattle)
    {
      CardData cardData2 = cardData1;
      if (cardData2.injuries == null)
        cardData2.injuries = new List<CardData.StatusEffectStacks>();
      if (cardData1.injuries.Count <= 0)
        cardData1.injuries.Add(new CardData.StatusEffectStacks(this.injuryEffect, 1));
    }
  }

  public static bool IsPlayerCard(CardData cardData) => References.PlayerData.inventory.deck.Any<CardData>((Func<CardData, bool>) (a => (long) a.id == (long) cardData.id));

  public static bool IsCloneOfPlayerCard(CardData cardData, out CardData originalCardData)
  {
    ulong num;
    if (cardData.TryGetCustomData<ulong>("splitOriginalId", out num, 0UL))
    {
      foreach (CardData cardData1 in References.PlayerData.inventory.deck)
      {
        if ((long) cardData1.id == (long) num)
        {
          originalCardData = cardData1;
          return true;
        }
      }
    }
    originalCardData = (CardData) null;
    return false;
  }

  public void Injure(CardData cardData)
  {
    if (!this.CanInjure(cardData))
      return;
    CardData cardData1 = cardData;
    if (cardData1.injuries == null)
      cardData1.injuries = new List<CardData.StatusEffectStacks>();
    if (cardData.injuries.Count <= 0)
      cardData.injuries.Add(new CardData.StatusEffectStacks(this.injuryEffect, 1));
    if (this.injuredThisBattle == null)
      this.injuredThisBattle = new List<CardData>();
    this.injuredThisBattle.Add(cardData);
    global::Events.InvokeCardInjured(cardData);
  }

  public bool CanInjure(CardData cardData) => (bool) (UnityEngine.Object) cardData && this.CanInjure(cardData.cardType);

  public bool CanInjure(CardType cardType) => this.typesThatCanBeInjured.Contains<CardType>(cardType);

  public static CardData[] GetInjuriesThisBattle()
  {
    InjurySystem objectOfType = UnityEngine.Object.FindObjectOfType<InjurySystem>();
    return (bool) (UnityEngine.Object) objectOfType && objectOfType.injuredThisBattle != null ? objectOfType.injuredThisBattle.Where<CardData>(new Func<CardData, bool>(InjurySystem.IsPlayerCard)).ToArray<CardData>() : new CardData[0];
  }

  public static bool IsCardAlive(CardData cardData)
  {
    foreach (Entity card in References.Battle.cards)
    {
      if ((long) card.data.id == (long) cardData.id && card.IsAliveAndExists())
        return true;
    }
    return false;
  }

  public static bool AnyAliveClonesOfThisCard(CardData originalCardData)
  {
    bool flag = false;
    foreach (Entity card in References.Battle.cards)
    {
      object obj;
      if (card.data.customData != null && card.data.customData.TryGetValue("splitOriginalId", out obj) && obj is ulong num && (long) num == (long) originalCardData.id && card.IsAliveAndExists())
      {
        flag = true;
        break;
      }
    }
    return flag;
  }

  [Serializable]
  public class SaveState
  {
    public int campaignNodeId;
    public List<ulong> injuredThisBattleIds;

    public SaveState()
    {
    }

    public SaveState(int campaignNodeId, IEnumerable<CardData> injuredThisBattle)
    {
      this.campaignNodeId = campaignNodeId;
      this.injuredThisBattleIds = injuredThisBattle.Select<CardData, ulong>((Func<CardData, ulong>) (a => a.id)).ToList<ulong>();
    }

    public List<CardData> Load()
    {
      List<CardData> cardDataList = new List<CardData>();
      foreach (CardData cardData in References.PlayerData.inventory.deck)
      {
        int index = this.injuredThisBattleIds.IndexOf(cardData.id);
        if (index >= 0)
        {
          this.injuredThisBattleIds.RemoveAt(index);
          cardDataList.Add(cardData);
        }
      }
      return cardDataList;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: InputAction
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class InputAction : MonoBehaviour
{
  public UnityEvent action;

  public void Run()
  {
    if (!InputSystem.Enabled)
      return;
    this.action?.Invoke();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: InputFieldKeepFocus
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;

[RequireComponent(typeof (TMP_InputField))]
public class InputFieldKeepFocus : MonoBehaviour
{
  public TMP_InputField _i;
  public PointerEventData _e;
  public bool focused;

  public TMP_InputField i => this._i ?? (this._i = this.GetComponent<TMP_InputField>());

  public PointerEventData e => this._e ?? (this._e = new PointerEventData(EventSystem.current));

  public void Update()
  {
    if (this.focused)
      return;
    if (!this.i.isFocused)
    {
      Debug.Log((object) ("[" + this.name + "] is not focused! Attempting to select"));
      this.i.OnPointerClick(this.e);
    }
    if (!this.i.isFocused)
      return;
    this.focused = true;
  }

  public void OnDisable() => this.focused = false;
}
﻿// Decompiled with JetBrains decompiler
// Type: InputSwitcher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class InputSwitcher : MonoBehaviour
{
  public static int justSwitchedCount = 3;
  public const int maxJustSwitchedCount = 3;
  public static bool justSwitched;
  public int currentIndex = -1;
  [SerializeField]
  public BaseInputSwitcher startingInput;
  [SerializeReference]
  public BaseInputSwitcher[] switchers;

  public void Awake()
  {
    foreach (Component switcher in this.switchers)
      switcher.gameObject.SetActive(false);
  }

  public void Start()
  {
    int length = this.switchers.Length;
    for (int profileIndex = 0; profileIndex < length; ++profileIndex)
    {
      if ((Object) this.switchers[profileIndex] == (Object) this.startingInput)
      {
        this.SwitchTo(profileIndex);
        break;
      }
    }
  }

  public void Update()
  {
    int length = this.switchers.Length;
    for (int profileIndex = 0; profileIndex < length; ++profileIndex)
    {
      if (this.switchers[profileIndex].CheckSwitchTo())
      {
        if (profileIndex != this.currentIndex)
        {
          this.SwitchTo(profileIndex);
          break;
        }
        break;
      }
    }
    if (!InputSwitcher.justSwitched || --InputSwitcher.justSwitchedCount > 0)
      return;
    InputSwitcher.justSwitched = false;
  }

  public void SwitchTo(int profileIndex)
  {
    if (this.currentIndex >= 0)
      this.switchers[this.currentIndex].gameObject.SetActive(false);
    this.switchers[profileIndex].SwitchTo();
    this.currentIndex = profileIndex;
    InputSwitcher.justSwitched = true;
    InputSwitcher.justSwitchedCount = 3;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: InputSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Rewired;
using System.Runtime.CompilerServices;
using UnityEngine;

public class InputSystem : GameSystem
{
  public static InputSystem instance;
  [Header("Hold Direction Settings")]
  public float holdDirectionStartTime = 0.1f;
  public float holdDirectionFlowTime = 0.05f;
  public static Player mainPlayer;
  public static bool enabled = true;
  public static bool isLongHeld;
  public static float holdDirectionTime;
  public static bool wasSelectHeldLong;
  public static bool wasSelectHeldLong2;
  [CompilerGenerated]
  public static Vector3 \u003CMousePosition\u003Ek__BackingField;
  public static bool AllowDynamicSelectRelease = true;
  public static int _reset;

  public static bool Enabled => InputSystem.enabled && !Transition.Running;

  public static Vector3 MousePosition
  {
    get => InputSystem.\u003CMousePosition\u003Ek__BackingField;
    set => InputSystem.\u003CMousePosition\u003Ek__BackingField = value;
  }

  public static bool reset
  {
    get => InputSystem._reset > 0;
    set => InputSystem._reset = value ? 2 : 0;
  }

  public void Awake()
  {
    InputSystem.instance = this;
    InputSystem.mainPlayer = ReInput.players.GetPlayer(0);
  }

  public void LateUpdate()
  {
    InputSystem.wasSelectHeldLong = InputSystem.wasSelectHeldLong2;
    InputSystem.wasSelectHeldLong2 = InputSystem.mainPlayer.GetButtonTimedPress("Select", 0.1f);
    InputSystem.MousePosition = Input.touchCount <= 0 ? Input.mousePosition : (Vector3) Input.GetTouch(0).position;
    --InputSystem._reset;
  }

  public static void Enable() => InputSystem.enabled = true;

  public static void Disable() => InputSystem.enabled = false;

  public static bool IsButtonPressed(string input, bool positive = true) => !(InputSystem.Enabled & positive) ? InputSystem.mainPlayer.GetNegativeButtonDown(input) : InputSystem.mainPlayer.GetButtonDown(input);

  public static bool IsButtonHeld(string input, bool positive = true) => !(InputSystem.Enabled & positive) ? InputSystem.mainPlayer.GetNegativeButton(input) : InputSystem.mainPlayer.GetButton(input);

  public static bool IsButtonLongHeld(string input, bool positive = true) => !(InputSystem.Enabled & positive) ? InputSystem.mainPlayer.GetNegativeButtonLongPress(input) : InputSystem.mainPlayer.GetButtonLongPress(input);

  public static bool IsButtonReleased(string input, bool positive = true) => !(InputSystem.Enabled & positive) ? InputSystem.mainPlayer.GetNegativeButtonUp(input) : InputSystem.mainPlayer.GetButtonUp(input);

  public static bool WasButtonPressed(string input, bool positive = true) => !(InputSystem.Enabled & positive) ? InputSystem.mainPlayer.GetNegativeButtonPrev(input) : InputSystem.mainPlayer.GetButtonPrev(input);

  public static bool WasButtonReleased(string input, bool positive = true) => !(InputSystem.Enabled & positive) ? !InputSystem.mainPlayer.GetNegativeButtonPrev(input) : !InputSystem.mainPlayer.GetButtonPrev(input);

  public static bool IsSelectPressed() => InputSystem.IsButtonPressed("Select");

  public static bool IsSelectHeld() => InputSystem.IsButtonHeld("Select");

  public static bool IsSelectReleased() => InputSystem.IsButtonReleased("Select");

  public static bool IsDynamicSelectReleased(bool allowSelectAgainToRelease)
  {
    if (!InputSystem.Enabled)
      return false;
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse && InputSystem.wasSelectHeldLong && !InputSystem.IsSelectHeld())
      return true;
    return allowSelectAgainToRelease ? InputSystem.IsSelectPressed() : !InputSystem.IsSelectHeld();
  }

  public static bool CheckLongHold()
  {
    if (InputSystem.IsButtonLongHeld("Move Vertical") || InputSystem.IsButtonLongHeld("Move Vertical", false) || InputSystem.IsButtonLongHeld("Move Horizontal") || InputSystem.IsButtonLongHeld("Move Horizontal", false))
    {
      if (!InputSystem.isLongHeld)
        InputSystem.holdDirectionTime = InputSystem.instance.holdDirectionStartTime;
      InputSystem.isLongHeld = true;
    }
    if (InputSystem.isLongHeld)
    {
      if (RewiredControllerManager.instance.IsButtonReleased() || !RewiredControllerManager.instance.IsButtonHeld())
      {
        InputSystem.isLongHeld = false;
      }
      else
      {
        InputSystem.holdDirectionTime -= Time.unscaledDeltaTime;
        if ((double) InputSystem.holdDirectionTime > 0.0)
          return false;
        InputSystem.holdDirectionTime = InputSystem.instance.holdDirectionFlowTime;
        return true;
      }
    }
    return InputSystem.isLongHeld;
  }

  public static float GetAxis(string actionName) => InputSystem.Enabled ? InputSystem.mainPlayer.GetAxis(actionName) : 0.0f;

  public static float GetAxisDelta(string actionName) => InputSystem.Enabled ? InputSystem.mainPlayer.GetAxisDelta(actionName) : 0.0f;
}
﻿// Decompiled with JetBrains decompiler
// Type: InspectCharmsSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class InspectCharmsSystem : GameSystem
{
  [SerializeField]
  public InspectSystem inspectSystem;
  [SerializeField]
  public CardCharm charmPrefab;
  [SerializeField]
  public GridLayoutGroup grid;
  [SerializeField]
  public string[] closeInputs = new string[3]
  {
    "Select",
    "Back",
    "Inspect"
  };
  public readonly List<CardCharm> charms = new List<CardCharm>();
  public const int maxCharms = 30;
  public const int maxColumns = 6;
  public float wait;

  public void Update()
  {
    if ((double) this.wait <= 0.0 && !MonoBehaviourSingleton<Cursor3d>.instance.usingMouse && ((IEnumerable<string>) this.closeInputs).Any<string>((Func<string, bool>) (i => InputSystem.IsButtonPressed(i))))
      this.Hide();
    if ((double) this.wait <= 0.0)
      return;
    this.wait -= Time.deltaTime;
  }

  public void Show()
  {
    this.gameObject.SetActive(true);
    this.Create(this.inspectSystem.inspect.data.upgrades.Where<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => a.type == CardUpgradeData.Type.Charm)).ToArray<CardUpgradeData>());
    this.wait = 0.15f;
  }

  public void Create(CardUpgradeData[] cardUpgrades)
  {
    int count = Mathf.Min(30, cardUpgrades.Length);
    this.SetGridSize(count);
    for (int index = 0; index < count; ++index)
    {
      CardCharm cardCharm = UnityEngine.Object.Instantiate<CardCharm>(this.charmPrefab, this.grid.transform);
      cardCharm.SetData(cardUpgrades[index]);
      cardCharm.holder = cardCharm.transform;
      this.charms.Add(cardCharm);
    }
  }

  public void SetGridSize(int count)
  {
    int num1 = Mathf.Min(6, count);
    int num2 = Mathf.CeilToInt((float) count / 6f);
    if (!(this.grid.transform is RectTransform transform))
      return;
    transform.sizeDelta = new Vector2((float) num1 * this.grid.cellSize.x, (float) num2 * this.grid.cellSize.y);
  }

  public void TryHide()
  {
    if ((double) this.wait > 0.0)
      return;
    this.Hide();
  }

  public void Hide()
  {
    foreach (Component charm in this.charms)
      charm.gameObject.Destroy();
    this.charms.Clear();
    this.gameObject.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: InspectNewUnitSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Localization;

public class InspectNewUnitSequence : UISequence
{
  [Header("Custom Values")]
  public bool takeCard;
  public Transform cardHolder;
  [SerializeField]
  public SpeechBubble speechBubble;
  [SerializeField]
  public LocalizedString[] defaultGreetMessages;
  [SerializeField]
  public Color nameHighlightColour;
  [SerializeField]
  public Color nameTextColour;
  public Entity unit;
  public string greeting;
  public Transform unitPreParent;
  public Vector3 unitPrePosition;
  public Vector3 unitPreRotation;
  public Vector3 unitPreScale;
  [SerializeField]
  public float unitMoveWobble = 1.5f;
  [SerializeField]
  public AnimationCurve unitMoveCurve;
  [SerializeField]
  public float unitMoveDur = 0.33f;
  public CardSelector cardSelector;
  [SerializeField]
  public RenameCompanionSequence renameSequence;
  public bool destroyOnEnd;

  public void SetUnit(Entity unit) => this.SetUnit(unit, true);

  public void SetUnit(Entity unit, bool updateGreeting)
  {
    this.unit = unit;
    if (updateGreeting && (Object) this.speechBubble != (Object) null)
      this.greeting = unit.data.greetMessages.Length > 0 ? unit.data.greetMessages.RandomItem<string>() : this.defaultGreetMessages.RandomItem<LocalizedString>().GetLocalizedString();
    this.UpdateUnit();
  }

  public void UpdateUnit()
  {
    if ((Object) this.speechBubble == (Object) null)
      return;
    string newValue = this.unit.data.title;
    if ((double) this.nameTextColour.a > 0.0)
      newValue = "<color=#" + this.nameTextColour.ToHexRGBA() + ">" + newValue + "</color>";
    if ((double) this.nameHighlightColour.a > 0.0)
      newValue = "<mark=#" + this.nameHighlightColour.ToHexRGBA() + ">" + newValue + "</mark>";
    this.speechBubble.SetText(this.greeting.Replace("<name>", newValue));
  }

  public void UnsetUnit() => this.unit = (Entity) null;

  public override IEnumerator Run()
  {
    InspectNewUnitSequence inspectNewUnitSequence = this;
    UIAnchors anchors = inspectNewUnitSequence.GetComponent<UIAnchors>();
    foreach (UIAnchors.AnchorPoint anchorPoint in anchors.list)
    {
      anchorPoint.Deactivate();
      anchorPoint.SetUp();
    }
    yield return (object) Sequences.Wait(inspectNewUnitSequence.startDelay);
    Events.InvokeInspectNewCard(inspectNewUnitSequence.unit);
    Events.InvokeEntityFocus(inspectNewUnitSequence.unit);
    if (inspectNewUnitSequence.gameObject.activeSelf)
      inspectNewUnitSequence.GetComponent<UINavigationLayer>().OnEnable();
    inspectNewUnitSequence.gameObject.SetActive(true);
    if ((double) inspectNewUnitSequence.unitMoveWobble != 0.0 && (Object) inspectNewUnitSequence.unit.wobbler != (Object) null)
      inspectNewUnitSequence.unit.wobbler.WobbleRandom(inspectNewUnitSequence.unitMoveWobble);
    Transform transform = inspectNewUnitSequence.unit.transform;
    inspectNewUnitSequence.unitPreParent = transform.parent;
    inspectNewUnitSequence.unitPrePosition = transform.localPosition;
    inspectNewUnitSequence.unitPreRotation = transform.localEulerAngles;
    inspectNewUnitSequence.unitPreScale = transform.localScale;
    transform.SetParent(inspectNewUnitSequence.cardHolder, true);
    LeanTween.cancel(inspectNewUnitSequence.unit.gameObject);
    LeanTween.moveLocal(inspectNewUnitSequence.unit.gameObject, Vector3.zero, inspectNewUnitSequence.unitMoveDur).setEase(inspectNewUnitSequence.unitMoveCurve);
    LeanTween.rotateLocal(inspectNewUnitSequence.unit.gameObject, Vector3.zero, inspectNewUnitSequence.unitMoveDur).setEase(inspectNewUnitSequence.unitMoveCurve);
    LeanTween.scale(inspectNewUnitSequence.unit.gameObject, Vector3.one, inspectNewUnitSequence.unitMoveDur).setEase(inspectNewUnitSequence.unitMoveCurve);
    int c = anchors.Count;
    for (int i = 0; i < c; ++i)
    {
      anchors.Activate(i);
      yield return (object) null;
      inspectNewUnitSequence.StartCoroutine(anchors.Reveal(i));
      yield return (object) Sequences.Wait(inspectNewUnitSequence.delayBetween);
    }
    inspectNewUnitSequence.StartCoroutine(anchors.UpdatePositions());
    while (!inspectNewUnitSequence.promptEnd)
      yield return (object) null;
    inspectNewUnitSequence.promptEnd = false;
    MonoBehaviourSingleton<UINavigationSystem>.instance.RemoveActiveLayer();
    if (!inspectNewUnitSequence.takeCard && (Object) inspectNewUnitSequence.unit != (Object) null)
    {
      inspectNewUnitSequence.unit.transform.SetParent(inspectNewUnitSequence.unitPreParent, true);
      LeanTween.cancel(inspectNewUnitSequence.unit.gameObject);
      LeanTween.moveLocal(inspectNewUnitSequence.unit.gameObject, inspectNewUnitSequence.unitPrePosition, inspectNewUnitSequence.unitMoveDur).setEase(inspectNewUnitSequence.unitMoveCurve);
      LeanTween.rotateLocal(inspectNewUnitSequence.unit.gameObject, inspectNewUnitSequence.unitPreRotation, inspectNewUnitSequence.unitMoveDur).setEase(inspectNewUnitSequence.unitMoveCurve);
      LeanTween.scale(inspectNewUnitSequence.unit.gameObject, inspectNewUnitSequence.unitPreScale, inspectNewUnitSequence.unitMoveDur).setEase(inspectNewUnitSequence.unitMoveCurve);
      if ((double) inspectNewUnitSequence.unitMoveWobble != 0.0 && (Object) inspectNewUnitSequence.unit.wobbler != (Object) null)
        inspectNewUnitSequence.unit.wobbler.WobbleRandom(inspectNewUnitSequence.unitMoveWobble);
    }
    if (inspectNewUnitSequence.destroyOnEnd)
      inspectNewUnitSequence.gameObject.Destroy();
    else
      inspectNewUnitSequence.gameObject.SetActive(false);
  }

  public void TakeCard()
  {
    if (this.takeCard)
      return;
    this.End();
    if (!((Object) this.unit != (Object) null))
      return;
    this.takeCard = true;
    this.cardSelector.TakeCard(this.unit);
  }

  public void StartRename()
  {
    if (this.takeCard)
      return;
    this.renameSequence.SetUnit(this.unit);
    this.renameSequence.Begin();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: InspectSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class InspectSystem : GameSystem
{
  [SerializeField]
  public GameObject container;
  [SerializeField]
  public Transform cardHolder;
  [SerializeField]
  public string openInput = "Inspect";
  [SerializeField]
  public string[] closeInputs = new string[3]
  {
    "Select",
    "Back",
    "Inspect"
  };
  [SerializeField]
  public string inspectCharmsInput = "Options";
  [SerializeField]
  public float cardScale = 1f;
  [SerializeField]
  public Vector2 cardRandomAngle = new Vector2(0.0f, 2f);
  [SerializeField]
  public List<Entity> hover = new List<Entity>();
  [SerializeField]
  public bool idleAnimation = true;
  [SerializeField]
  public float idleAnimationFactor = 1f;
  [SerializeField]
  public float canInspectDelay = 0.1f;
  [SerializeField]
  public float canEndDelay = 0.1f;
  [SerializeField]
  public KeywordData injuredKeyword;
  public float wait;
  [Header("Inspect Charms")]
  [SerializeField]
  public GameObject inspectCharmsLayout;
  [SerializeField]
  public InspectCharmsSystem inspectCharmsSystem;
  [Header("Pop up panels")]
  [SerializeField]
  public RectTransform leftPopGroup;
  [SerializeField]
  public RectTransform leftOverflowPopGroup;
  [SerializeField]
  public RectTransform rightPopGroup;
  [SerializeField]
  public RectTransform rightOverflowPopGroup;
  [SerializeField]
  public RectTransform bottomPopGroup;
  [SerializeField]
  public RectTransform notePopGroup;
  [SerializeField]
  public RectTransform[] overflowOrder;
  [SerializeField]
  public CardPopUpPanel popUpPrefab;
  [SerializeField]
  public CardTooltip cardTooltipPrefab;
  [SerializeField]
  public LayoutGroup[] layoutsToFix;
  [Header("Fading")]
  [SerializeField]
  public CanvasGroup backgroundFade;
  [SerializeField]
  public CanvasGroup cardInfoFade;
  [SerializeField]
  public float fadeInDur = 0.2f;
  [SerializeField]
  public float fadeOutDur = 0.1f;
  public float fade;
  [Header("Card Info Elements")]
  [SerializeField]
  public TMP_Text nameText;
  [SerializeField]
  public ImageSprite typeIcon;
  [SerializeField]
  public TMP_Text typeText;
  [Header("Tribe Flag")]
  [SerializeField]
  public Image flagImage;
  public Entity drag;
  public Entity press;
  [CompilerGenerated]
  public Entity \u003Cinspect\u003Ek__BackingField;
  public Transform previousParent;
  public int previousChildIndex;
  public const float enableAnimationDelay = 0.1f;
  public float enableAnimationTimer;
  public float currentIdleAnimationFactor;
  public bool hasAnyCharms;
  public readonly List<Tooltip> popups = new List<Tooltip>();
  public readonly List<KeywordData> currentPoppedKeywords = new List<KeywordData>();

  public Entity inspect
  {
    get => this.\u003Cinspect\u003Ek__BackingField;
    set => this.\u003Cinspect\u003Ek__BackingField = value;
  }

  public static bool IsActive()
  {
    InspectSystem objectOfType = UnityEngine.Object.FindObjectOfType<InspectSystem>();
    return (bool) (UnityEngine.Object) objectOfType && (bool) (UnityEngine.Object) objectOfType.inspect;
  }

  public void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
    global::Events.OnEntityDrag += new UnityAction<Entity>(this.EntityDrag);
    global::Events.OnEntityRelease += new UnityAction<Entity>(this.EntityRelease);
    global::Events.OnEntityDestroyed += new UnityAction<Entity>(this.EntityUnHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
    global::Events.OnEntityDrag -= new UnityAction<Entity>(this.EntityDrag);
    global::Events.OnEntityRelease -= new UnityAction<Entity>(this.EntityRelease);
    global::Events.OnEntityDestroyed -= new UnityAction<Entity>(this.EntityUnHover);
  }

  public void Update()
  {
    if ((bool) (UnityEngine.Object) this.inspect)
    {
      if ((double) this.wait <= 0.0 && !MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      {
        if (this.hasAnyCharms && !this.inspectCharmsSystem.gameObject.activeSelf && InputSystem.IsButtonPressed(this.inspectCharmsInput))
          this.inspectCharmsSystem.Show();
        if (!this.inspectCharmsSystem.gameObject.activeSelf && ((IEnumerable<string>) this.closeInputs).Any<string>((Func<string, bool>) (i => InputSystem.IsButtonPressed(i))))
          this.InspectEnd();
      }
    }
    else if (!(bool) (UnityEngine.Object) this.press)
    {
      if (!GameManager.paused && (double) this.wait <= 0.0 && !(bool) (UnityEngine.Object) this.drag && this.hover.Count == 1 && InputSystem.IsButtonPressed(this.openInput))
        this.press = this.hover[0];
    }
    else if (!GameManager.paused && !InputSystem.IsButtonHeld(this.openInput))
    {
      if (this.hover.Count == 1 && (UnityEngine.Object) this.hover[0] == (UnityEngine.Object) this.press)
      {
        ActionInspect action = new ActionInspect(this.press, this);
        if (global::Events.CheckAction((PlayAction) action))
          action.Process();
      }
      this.press = (Entity) null;
    }
    if ((double) this.enableAnimationTimer > 0.0)
    {
      this.enableAnimationTimer -= Time.deltaTime;
      if ((double) this.enableAnimationTimer <= 0.0)
        this.EnableIdleAnimation();
    }
    if ((double) this.wait <= 0.0)
      return;
    this.wait -= Time.deltaTime;
  }

  public void Inspect(Entity entity)
  {
    this.inspect = entity;
    this.SetFlag();
    this.hasAnyCharms = entity.HasAnyCharms();
    this.inspectCharmsLayout.SetActive(this.hasAnyCharms);
    this.container.SetActive(true);
    this.StopAllCoroutines();
    this.StartCoroutine(this.FadeIn());
    this.nameText.text = entity.data.title;
    this.typeIcon.SetSprite(entity.data.cardType.icon);
    this.typeText.text = entity.data.cardType.title;
    this.CreatePopups();
    entity.ForceUnHover();
    this.previousParent = entity.transform.parent;
    this.previousChildIndex = entity.transform.GetSiblingIndex();
    entity.transform.SetParent(this.cardHolder, true);
    LeanTween.moveLocal(entity.gameObject, Vector3.zero, 0.5f).setEase(LeanTweenType.easeOutQuart);
    entity.wobbler?.WobbleRandom();
    LeanTween.scale(entity.gameObject, Vector3.one * this.cardScale, 0.67f).setEase(LeanTweenType.easeOutBack);
    float z = this.cardRandomAngle.PettyRandom().WithRandomSign();
    LeanTween.rotateLocal(entity.gameObject, new Vector3(0.0f, 0.0f, z), 1f).setEase(LeanTweenType.easeOutBack);
    if (this.idleAnimation)
      this.enableAnimationTimer = 0.1f;
    global::Events.InvokeInspect(entity);
    global::Events.InvokeEntityFocus(entity);
    this.wait = this.canEndDelay;
  }

  public void SetFlag()
  {
    ClassData classData = InspectSystem.GetClass(this.inspect.data);
    if ((bool) (UnityEngine.Object) classData)
    {
      this.flagImage.gameObject.SetActive(true);
      this.flagImage.sprite = classData.flag;
    }
    else
      this.flagImage.gameObject.SetActive(false);
  }

  public static ClassData GetClass(CardData cardData)
  {
    if (cardData.cardType.tag == "Enemy")
      return (ClassData) null;
    if (cardData.cardType.name == "Leader")
    {
      foreach (ClassData classData in References.Classes)
      {
        foreach (UnityEngine.Object leader in classData.leaders)
        {
          if (leader.name == cardData.name)
            return classData;
        }
      }
    }
    else
    {
      foreach (ClassData classData in References.Classes)
      {
        foreach (UnityEngine.Object @object in classData.startingInventory.deck)
        {
          if (@object.name == cardData.name)
            return classData;
        }
        foreach (RewardPool rewardPool in classData.rewardPools)
        {
          if (!rewardPool.isGeneralPool)
          {
            foreach (UnityEngine.Object @object in rewardPool.list)
            {
              if (@object.name == cardData.name)
                return classData;
            }
          }
        }
      }
    }
    return (ClassData) null;
  }

  public void TryInspectEnd()
  {
    if ((double) this.wait > 0.0)
      return;
    this.InspectEnd();
  }

  public void InspectEnd()
  {
    this.inspect.transform.parent = this.previousParent;
    this.inspect.transform.SetSiblingIndex(this.previousChildIndex);
    this.inspect.TweenToContainer();
    this.inspect.wobbler?.WobbleRandom();
    this.DisableIdleAnimation();
    this.StopAllCoroutines();
    this.StartCoroutine(this.FadeOut());
    global::Events.InvokeInspectEnd(this.inspect);
    this.inspect = (Entity) null;
    this.wait = this.canInspectDelay;
  }

  public IEnumerator FadeIn()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    InspectSystem inspectSystem = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    inspectSystem.UpdateFade(0.0f);
    LeanTween.cancel(inspectSystem.gameObject);
    LeanTween.value(inspectSystem.gameObject, inspectSystem.fade, 1f, inspectSystem.fadeInDur).setEase(LeanTweenType.easeOutQuad).setOnUpdate(new Action<float>(inspectSystem.UpdateFade));
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) null;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public IEnumerator FadeOut()
  {
    InspectSystem inspectSystem = this;
    LeanTween.cancel(inspectSystem.gameObject);
    LeanTween.value(inspectSystem.gameObject, inspectSystem.fade, 0.0f, inspectSystem.fadeOutDur).setEase(LeanTweenType.easeOutQuad).setOnUpdate(new Action<float>(inspectSystem.UpdateFade));
    yield return (object) inspectSystem.fadeOutDur;
    yield return (object) null;
    inspectSystem.ClearPopups();
    inspectSystem.container.SetActive(false);
  }

  public void UpdateFade(float value)
  {
    this.fade = value;
    this.backgroundFade.alpha = this.fade;
    this.cardInfoFade.alpha = this.fade;
  }

  public void CreatePopups()
  {
    this.CreateIconPopups(this.inspect.display.healthLayoutGroup, (Transform) this.leftPopGroup);
    this.CreateIconPopups(this.inspect.display.damageLayoutGroup, (Transform) this.rightPopGroup);
    this.CreateIconPopups(this.inspect.display.counterLayoutGroup, (Transform) this.bottomPopGroup);
    if (this.inspect.display is Card display)
    {
      foreach (CardData mentionedCard in display.mentionedCards)
        this.Popup(mentionedCard, (Transform) this.rightPopGroup);
      foreach (KeywordData keyword in display.keywords)
        this.Popup(keyword, (Transform) this.rightPopGroup);
    }
    foreach (StatusEffectData statusEffect in this.inspect.statusEffects)
    {
      foreach (KeywordData hiddenKeyword in statusEffect.hiddenKeywords)
        this.Popup(hiddenKeyword, (Transform) this.rightPopGroup);
    }
    List<CardData.StatusEffectStacks> injuries = this.inspect.data.injuries;
    if (injuries != null && injuries.Count > 0)
      this.Popup(this.injuredKeyword, (Transform) this.rightPopGroup);
    CoroutineManager.Start(this.FixLayoutsAfterFrame());
  }

  public void CreateIconPopups(RectTransform iconLayoutGroup, Transform popGroup)
  {
    foreach (CardPopUpTarget componentsInChild in iconLayoutGroup.GetComponentsInChildren<CardPopUpTarget>())
    {
      foreach (KeywordData keyword in componentsInChild.keywords)
        this.Popup(keyword, popGroup);
    }
  }

  public void ClearPopups()
  {
    foreach (Component popup in this.popups)
      popup.gameObject.Destroy();
    this.popups.Clear();
    this.currentPoppedKeywords.Clear();
  }

  public IEnumerator FixLayoutsAfterFrame()
  {
    yield return (object) null;
    yield return (object) this.FixLayouts();
  }

  public IEnumerator FixLayouts()
  {
    InspectSystem inspectSystem = this;
    yield return (object) null;
    foreach (LayoutGroup layoutGroup in inspectSystem.layoutsToFix)
    {
      switch (layoutGroup)
      {
        case VerticalLayoutGroup layout1:
          layout1.FitToChildren();
          break;
        case HorizontalLayoutGroup layout2:
          layout2.FitToChildren();
          break;
      }
    }
    if (inspectSystem.CheckOverflow(inspectSystem.bottomPopGroup))
      yield return (object) inspectSystem.FixLayouts();
  }

  public bool CheckOverflow(params RectTransform[] checkCollide)
  {
    for (int index = 0; index < this.overflowOrder.Length - 1; ++index)
    {
      RectTransform target = this.overflowOrder[index];
      if (target.childCount > 0 && InspectSystem.CheckCollide(target, (IEnumerable<RectTransform>) checkCollide))
      {
        Transform child = target.GetChild(target.childCount - 1);
        child.SetParent((Transform) this.overflowOrder[index + 1]);
        child.SetSiblingIndex(0);
        return true;
      }
    }
    return false;
  }

  public static bool CheckCollide(RectTransform target, IEnumerable<RectTransform> checks)
  {
    foreach (RectTransform check in checks)
    {
      if (InspectSystem.RectOverlap(target, check))
      {
        Debug.Log((object) string.Format("[{0}] Overlaps [{1}]", (object) target.rect, (object) check.rect));
        return true;
      }
    }
    return false;
  }

  public static bool RectOverlap(RectTransform a, RectTransform b)
  {
    Vector3 position1 = a.position;
    Vector2 size1 = a.rect.size;
    Vector2 pivot1 = a.pivot;
    Rect rect = new Rect(position1.x - pivot1.x * size1.x, position1.y - pivot1.y * size1.y, size1.x, size1.y);
    Vector3 position2 = b.position;
    Vector2 size2 = b.rect.size;
    Vector2 pivot2 = b.pivot;
    Rect other = new Rect(position2.x - pivot2.x * size2.x, position2.y - pivot2.y * size2.y, size2.x, size2.y);
    return rect.Overlaps(other);
  }

  public CardPopUpPanel Popup(KeywordData keyword, Transform group)
  {
    if (this.currentPoppedKeywords.Contains(keyword))
      return (CardPopUpPanel) null;
    CardPopUpPanel panel = UnityEngine.Object.Instantiate<CardPopUpPanel>(this.popUpPrefab, group);
    panel.gameObject.name = keyword.name;
    panel.Set(keyword);
    global::Events.InvokePopupPanelCreated(keyword, panel);
    this.currentPoppedKeywords.Add(keyword);
    this.popups.Add((Tooltip) panel);
    foreach (KeywordData keyword1 in Text.GetKeywords(keyword.body))
    {
      CardPopUpPanel cardPopUpPanel = this.Popup(keyword1, group);
      panel.children.AddIfNotNull<Tooltip>((Tooltip) cardPopUpPanel);
    }
    return panel;
  }

  public CardTooltip Popup(CardData cardData, Transform group)
  {
    CardTooltip cardTooltip = UnityEngine.Object.Instantiate<CardTooltip>(this.cardTooltipPrefab, group);
    cardTooltip.gameObject.name = cardData.name;
    cardTooltip.Set(cardData);
    this.popups.Add((Tooltip) cardTooltip);
    foreach (KeywordData keyword in cardTooltip.keywords)
    {
      CardPopUpPanel cardPopUpPanel = this.Popup(keyword, group);
      cardTooltip.children.AddIfNotNull<Tooltip>((Tooltip) cardPopUpPanel);
    }
    return cardTooltip;
  }

  public void EnableIdleAnimation()
  {
    if (!(bool) (UnityEngine.Object) this.inspect?.data?.idleAnimationProfile || !(this.inspect.display is Card display) || (double) this.idleAnimationFactor == 0.0)
      return;
    if ((bool) (UnityEngine.Object) display.imageIdleAnimator)
    {
      display.imageIdleAnimator.FadeIn();
      display.imageIdleAnimator.strength *= this.idleAnimationFactor;
    }
    if ((bool) (UnityEngine.Object) display.backgroundIdleAnimator)
    {
      display.backgroundIdleAnimator.FadeIn();
      display.backgroundIdleAnimator.strength *= this.idleAnimationFactor;
    }
    this.currentIdleAnimationFactor = this.idleAnimationFactor;
  }

  public void DisableIdleAnimation()
  {
    if (!(this.inspect?.display is Card display))
      return;
    if ((bool) (UnityEngine.Object) display.imageIdleAnimator)
    {
      display.imageIdleAnimator.FadeOut();
      display.imageIdleAnimator.strength /= this.currentIdleAnimationFactor;
    }
    if (!(bool) (UnityEngine.Object) display.backgroundIdleAnimator)
      return;
    display.backgroundIdleAnimator.FadeOut();
    display.backgroundIdleAnimator.strength /= this.currentIdleAnimationFactor;
  }

  public void EntityHover(Entity entity)
  {
    if (this.hover.Contains(entity))
      return;
    this.hover.Add(entity);
  }

  public void EntityUnHover(Entity entity) => this.hover.Remove(entity);

  public void EntityDrag(Entity entity) => this.drag = entity;

  public void EntityRelease(Entity entity)
  {
    if (!((UnityEngine.Object) entity == (UnityEngine.Object) this.drag))
      return;
    this.drag = (Entity) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: IntroSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization;

public class IntroSequence : MonoBehaviour
{
  [SerializeField]
  public string nextScene;
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public LocalizedString[] textKeys;
  public int textCurrent;
  public GameObject current;

  public void Start()
  {
    if (!GameManager.Ready)
      return;
    Transition.End();
    this.StartSequence();
  }

  public void OnDisable()
  {
    CinemaBarSystem.Clear();
    CinemaBarSystem.OutInstant();
  }

  public void StartSequence()
  {
    CinemaBarSystem.InInstant();
    CinemaBarSystem.Clear();
    this.animator.SetTrigger("Play");
  }

  public void EndSequence()
  {
    Routine routine = new Routine(Transition.To(this.nextScene));
  }

  public void NextText() => CinemaBarSystem.SetScript(this.textKeys[this.textCurrent++].GetLocalizedString(), true);
}
﻿// Decompiled with JetBrains decompiler
// Type: InventorHutSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class InventorHutSequence : BuildingSequenceWithUnlocks<InventorHutSequence>
{
  [SerializeField]
  public CardController controller;
  [SerializeField]
  public CardUnlockSequence cardUnlockSequence;
  [SerializeField]
  public string firstGreetKey = "inventorFirstGreet";

  public void Start() => this._OnStart();

  public override IEnumerator Sequence()
  {
    InventorHutSequence inventorHutSequence = this;
    int num = Mathf.Min(inventorHutSequence.locks.Length, inventorHutSequence.building.type.unlocks.Length);
    for (int index = 0; index < num; ++index)
    {
      if (inventorHutSequence.building.type.unlocks[index].IsActive)
        inventorHutSequence.locks[index].SetActive(false);
    }
    yield return (object) inventorHutSequence.CreateCards();
    if (inventorHutSequence.building.HasUncheckedUnlocks)
    {
      foreach (string uncheckedUnlock in inventorHutSequence.building.uncheckedUnlocks)
        yield return (object) inventorHutSequence.Unlock(uncheckedUnlock);
      Entity top = ((IEnumerable<CardContainer>) inventorHutSequence.cardSlots).LastOrDefault<CardContainer>((Func<CardContainer, bool>) (a => !a.Empty))?.GetTop();
      if ((bool) (UnityEngine.Object) top)
        inventorHutSequence.TalkerNewCard(top.data);
    }
    else if (!inventorHutSequence.firstGreetKey.IsNullOrEmpty() && !SaveSystem.LoadProgressData<bool>(inventorHutSequence.firstGreetKey, false))
    {
      inventorHutSequence.TalkerFirstGreet();
      SaveSystem.SaveProgressData<bool>(inventorHutSequence.firstGreetKey, true);
    }
    else
      inventorHutSequence.TalkerGreet();
  }

  public IEnumerator Unlock(string unlockDataName)
  {
    InventorHutSequence inventorHutSequence = this;
    int index = ((IEnumerable<UnlockData>) inventorHutSequence.building.type.unlocks).Select<UnlockData, string>((Func<UnlockData, string>) (a => a.name)).ToList<string>().IndexOf(unlockDataName);
    string assetName = index >= 0 ? MetaprogressionSystem.Get<List<string>>("items")[index] : throw new IndexOutOfRangeException("[" + unlockDataName + "] does not exist in [" + inventorHutSequence.building.name + "] unlocks list!");
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>(inventorHutSequence.building.type.unlockedCheckedKey, new List<string>());
    stringList.Add(unlockDataName);
    SaveSystem.SaveProgressData<List<string>>(inventorHutSequence.building.type.unlockedCheckedKey, stringList);
    Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", assetName), inventorHutSequence.controller, (Character) null, false, true);
    yield return (object) card.UpdateData(false);
    CardContainer finalSlot = ((IEnumerable<CardContainer>) inventorHutSequence.cardSlots).FirstOrDefault<CardContainer>((Func<CardContainer, bool>) (a => a.Empty));
    yield return (object) inventorHutSequence.cardUnlockSequence.Run(card.entity, finalSlot);
    if ((bool) (UnityEngine.Object) finalSlot)
    {
      Image component = finalSlot.GetComponent<Image>();
      if (component != null)
        component.enabled = true;
    }
  }

  public IEnumerator CreateCards()
  {
    InventorHutSequence inventorHutSequence = this;
    List<Entity> cards = new List<Entity>();
    Routine.Clump clump = new Routine.Clump();
    List<string> checkedUnlocks = inventorHutSequence.building.checkedUnlocks;
    // ISSUE: explicit non-virtual call
    int count = checkedUnlocks != null ? __nonvirtual (checkedUnlocks.Count) : 0;
    List<string> stringList = MetaprogressionSystem.Get<List<string>>("items");
    for (int index = 0; index < count && index < stringList.Count; ++index)
    {
      Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", stringList[index]), inventorHutSequence.controller, (Character) null, false, true);
      cards.Add(card.entity);
      clump.Add(card.UpdateData(false));
    }
    yield return (object) clump.WaitForEnd();
    foreach (Entity entity in cards)
    {
      CardContainer cardContainer = ((IEnumerable<CardContainer>) inventorHutSequence.cardSlots).FirstOrDefault<CardContainer>((Func<CardContainer, bool>) (a => a.Empty));
      if (cardContainer == null)
        break;
      entity.flipper.FlipUpInstant();
      entity.enabled = true;
      cardContainer.Add(entity);
      cardContainer.SetChildPositions();
      Image component = cardContainer.GetComponent<Image>();
      if (component != null)
        component.enabled = false;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Inventory
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Inventory", menuName = "Inventory")]
public class Inventory : ScriptableObject, ISaveable<InventorySaveData>
{
  public CardDataList deck = new CardDataList();
  public CardDataList reserve = new CardDataList();
  public List<CardUpgradeData> upgrades = new List<CardUpgradeData>();
  public SafeInt gold;
  public int goldOwed;

  public void AddGold(int amount)
  {
    this.gold += amount;
    this.goldOwed = Mathf.Max(0, this.goldOwed - amount);
  }

  public Inventory Clone()
  {
    Inventory inventory = this.InstantiateKeepName<Inventory>();
    inventory.deck.Clear();
    inventory.reserve.Clear();
    inventory.upgrades.Clear();
    foreach (CardData cardData in this.deck)
      inventory.deck.Add(cardData.Clone());
    foreach (CardData cardData in this.reserve)
      inventory.reserve.Add(cardData.Clone());
    foreach (CardUpgradeData upgrade in this.upgrades)
      inventory.upgrades.Add(upgrade.Clone());
    inventory.gold = new SafeInt(this.gold.Value);
    return inventory;
  }

  public InventorySaveData Save() => new InventorySaveData(this.deck.SaveArray<CardData, CardSaveData>(), this.reserve.SaveArray<CardData, CardSaveData>(), this.upgrades.SaveArray<CardUpgradeData, CardUpgradeSaveData>(), this.gold.Value + this.goldOwed);
}
﻿// Decompiled with JetBrains decompiler
// Type: InventorySaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using UnityEngine;

[Serializable]
public class InventorySaveData : ILoadable<Inventory>
{
  public CardSaveData[] deck;
  public CardSaveData[] reserve;
  public CardUpgradeSaveData[] upgrades;
  public int gold;

  public InventorySaveData()
  {
  }

  public InventorySaveData(
    CardSaveData[] deck,
    CardSaveData[] reserve,
    CardUpgradeSaveData[] upgrades,
    int gold)
  {
    this.deck = deck;
    this.reserve = reserve;
    this.upgrades = upgrades;
    this.gold = gold;
  }

  public Inventory Load()
  {
    Inventory instance = ScriptableObject.CreateInstance<Inventory>();
    foreach (CardSaveData cardSaveData in this.deck)
      instance.deck.Add(cardSaveData.Load());
    foreach (CardSaveData cardSaveData in this.reserve)
      instance.reserve.Add(cardSaveData.Load());
    foreach (CardUpgradeSaveData upgrade in this.upgrades)
      instance.upgrades.Add(upgrade.Load());
    instance.gold = new SafeInt(this.gold);
    return instance;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: IPointerAfterExitHandler
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine.EventSystems;

public interface IPointerAfterExitHandler
{
  void OnPointerAfterExit(PointerEventData eventData);
}
﻿// Decompiled with JetBrains decompiler
// Type: IPoolable
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public interface IPoolable
{
  void OnGetFromPool();

  void OnReturnToPool();
}
﻿// Decompiled with JetBrains decompiler
// Type: IRemoveWhenPooled
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public interface IRemoveWhenPooled
{
}
﻿// Decompiled with JetBrains decompiler
// Type: IRerollable
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public interface IRerollable
{
  bool Reroll();
}
﻿// Decompiled with JetBrains decompiler
// Type: ISaveableExt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;

public static class ISaveableExt
{
  public static D[] SaveArray<S, D>(this IEnumerable<S> list) where S : ISaveable<D> => list.Select<S, D>((Func<S, D>) (a => a.Save())).ToArray<D>();

  public static D[] SaveArray<S, D>(this S[] array) where S : ISaveable<D> => ((IEnumerable<S>) array).Select<S, D>((Func<S, D>) (a => a.Save())).ToArray<D>();
}
﻿// Decompiled with JetBrains decompiler
// Type: ISaveable`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public interface ISaveable<T>
{
  T Save();
}
﻿// Decompiled with JetBrains decompiler
// Type: ItemEventRoutine
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Localization;
using UnityEngine.UI;

public class ItemEventRoutine : EventRoutine, IRerollable
{
  [SerializeField]
  public ChooseNewCardSequence sequence;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public CardContainer cardContainer;
  [SerializeField]
  public SpriteRenderer backgroundImage;
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public ParticleSystem pulseParticleSystem;
  [SerializeField]
  public Button skipButton;
  [SerializeField]
  public LocalizedString openKey;
  [SerializeField]
  public LocalizedString chooseKey;
  [SerializeField]
  public SfxLoop loop;
  [SerializeField]
  public GameObject backButton;
  public bool cardTaken;
  public bool showCards;
  public bool promptOpen;
  public bool analyticsEventSent;

  public bool IsOpen => this.data.Get<bool>("open");

  public void RunOpenRoutine(BaseEventData eventData)
  {
    if (eventData is PointerEventData pointerEventData && pointerEventData.button != PointerEventData.InputButton.Left)
      return;
    this.promptOpen = true;
  }

  public IEnumerator OpenRoutine()
  {
    ItemEventRoutine itemEventRoutine = this;
    DeckpackBlocker.Block();
    SfxSystem.OneShot("event:/sfx/location/item_chest/claim");
    itemEventRoutine.data["open"] = (object) true;
    itemEventRoutine.animator.SetBool("Open", true);
    Events.InvokeScreenRumble(0.0f, 1f, 0.05f, 0.7f, 0.2f, 0.05f);
    yield return (object) Sequences.Wait(1f);
    Events.InvokeScreenShake(5f);
    itemEventRoutine.animator.SetBool("Zoom", true);
    yield return (object) null;
    itemEventRoutine.Open();
    DeckpackBlocker.Unblock();
  }

  public void Open()
  {
    this.showCards = true;
    CinemaBarSystem.Top.SetPrompt(this.chooseKey.GetLocalizedString(), "");
    this.data["open"] = (object) true;
    Image component = this.backgroundImage.GetComponent<Image>();
    if (component != null)
      component.enabled = false;
    this.pulseParticleSystem?.Stop();
    UINavigationDefaultSystem.SetStartingItem();
    if (!(bool) (UnityEngine.Object) this.backButton)
      return;
    this.backButton.SetActive(true);
  }

  public void Close()
  {
    this.showCards = false;
    this.animator.SetBool("Open", false);
    CinemaBarSystem.Top.SetPrompt(this.openKey.GetLocalizedString(), "Select");
    Image component = this.backgroundImage.GetComponent<Image>();
    if (component != null)
      component.enabled = true;
    this.pulseParticleSystem?.Play();
  }

  public override IEnumerator Populate()
  {
    ItemEventRoutine itemEventRoutine = this;
    string[] saveCollection = itemEventRoutine.data.GetSaveCollection<string>("cards");
    itemEventRoutine.cardContainer.SetSize(saveCollection.Length, 0.8f);
    Routine.Clump clump = new Routine.Clump();
    for (int cardIndex = 0; cardIndex < saveCollection.Length; ++cardIndex)
    {
      CardData cardData = AddressableLoader.Get<CardData>("CardData", saveCollection[cardIndex]).Clone();
      itemEventRoutine.CheckAddUpgrades(cardIndex, cardData);
      Card card = CardManager.Get(cardData, itemEventRoutine.cardController, itemEventRoutine.player, false, true);
      if (!itemEventRoutine.cardContainer.gameObject.activeInHierarchy)
        card.entity.flipper.FlipDownInstant();
      itemEventRoutine.cardContainer.Add(card.entity);
      clump.Add(card.UpdateData(false));
    }
    yield return (object) clump.WaitForEnd();
    foreach (Entity child in itemEventRoutine.cardContainer)
    {
      Transform transform = child.transform;
      transform.localPosition = itemEventRoutine.cardContainer.GetChildPosition(child);
      transform.localScale = itemEventRoutine.cardContainer.GetChildScale(child);
      transform.localEulerAngles = itemEventRoutine.cardContainer.GetChildRotation(child);
    }
    if (itemEventRoutine.data.Get<bool>("open"))
    {
      itemEventRoutine.Open();
      itemEventRoutine.animator.SetBool("Zoom", true);
    }
    else
      itemEventRoutine.Close();
  }

  public override IEnumerator Run()
  {
    ItemEventRoutine itemEventRoutine = this;
    itemEventRoutine.sequence.owner = itemEventRoutine.player;
    itemEventRoutine.cardController.owner = itemEventRoutine.player;
    itemEventRoutine.cardSelector.character = itemEventRoutine.player;
    if (!itemEventRoutine.data.Get<bool>("open"))
      itemEventRoutine.loop.Play();
    while (!itemEventRoutine.data.Get<bool>("open"))
    {
      if (itemEventRoutine.promptOpen)
      {
        itemEventRoutine.promptOpen = false;
        if (!itemEventRoutine.data.Get<bool>("open"))
        {
          itemEventRoutine.loop.Stop();
          yield return (object) itemEventRoutine.OpenRoutine();
        }
      }
      yield return (object) null;
    }
    if (!itemEventRoutine.analyticsEventSent)
    {
      foreach (Entity entity in itemEventRoutine.cardContainer)
        Events.InvokeEntityOffered(entity);
      itemEventRoutine.analyticsEventSent = true;
    }
    yield return (object) itemEventRoutine.sequence.Run();
    CinemaBarSystem.Clear();
    if (itemEventRoutine.cardTaken)
      itemEventRoutine.node.SetCleared();
  }

  public void TrySelect(Entity entity)
  {
    if (this.cardTaken)
      return;
    ActionSelect action = new ActionSelect(entity, (Action<Entity>) (e =>
    {
      this.cardSelector.TakeCard(entity);
      this.cardController.Disable();
      if ((bool) (UnityEngine.Object) this.skipButton)
        this.skipButton.interactable = false;
      if ((bool) (UnityEngine.Object) this.backButton)
        this.backButton.SetActive(false);
      this.cardTaken = true;
      Events.InvokeEntityChosen(entity);
    }));
    if (!Events.CheckAction((PlayAction) action))
      return;
    ActionQueue.Add((PlayAction) action);
  }

  public void TrySkip()
  {
    ActionSelect action = new ActionSelect((Entity) null, (Action<Entity>) (e => this.sequence.Skip()));
    if (!Events.CheckAction((PlayAction) action))
      return;
    ActionQueue.Add((PlayAction) action);
  }

  public bool Reroll()
  {
    if (!this.cardContainer.gameObject.activeInHierarchy || !this.cardSelector.enabled || InspectSystem.IsActive())
      return false;
    InspectNewUnitSequence objectOfType = UnityEngine.Object.FindObjectOfType<InspectNewUnitSequence>();
    if (objectOfType != null && objectOfType.gameObject.activeSelf)
      return false;
    this.data["cards"] = (object) ((IList<CardData>) this.cardController.owner.GetComponent<CharacterRewards>().Pull<CardData>((object) this.node, "Items", this.data.GetSaveCollection<string>("cards").Length)).ToSaveCollectionOfNames<CardData>();
    foreach (Entity entity in this.cardContainer)
      CardManager.ReturnToPool(entity);
    this.cardContainer.Clear();
    this.StartCoroutine(this.Populate());
    CardPopUp.Clear();
    return true;
  }

  [CompilerGenerated]
  public void \u003CTrySkip\u003Eb__25_0(Entity e) => this.sequence.Skip();
}
﻿// Decompiled with JetBrains decompiler
// Type: ItemHolderPet
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class ItemHolderPet : MonoBehaviour
{
  [SerializeField]
  public Entity owner;
  [SerializeField]
  public ItemHolderPetUsed usedPrefab;
  [SerializeField]
  public TweenUI showTween;
  [SerializeField]
  public AngleWobbler headWobbler;
  [Header("Head")]
  [SerializeField]
  public Sprite[] headOptions;
  [SerializeField]
  public Image head;

  public void Show()
  {
    if (this.gameObject.activeSelf)
      return;
    this.gameObject.SetActive(true);
    if ((Object) this.head != (Object) null && this.headOptions.Length != 0)
      this.head.sprite = this.headOptions[Mathf.RoundToInt((float) this.headOptions.Length * this.owner.data.random3.x).Mod(this.headOptions.Length)];
    this.showTween.Fire();
    this.headWobbler.WobbleRandom();
  }

  public void Hide()
  {
    if (!((Object) this.gameObject != (Object) null) || !this.gameObject.activeSelf)
      return;
    this.gameObject.SetActive(false);
  }

  public void Used()
  {
    this.gameObject.SetActive(false);
    ItemHolderPetUsed itemHolderPetUsed = Object.Instantiate<ItemHolderPetUsed>(this.usedPrefab, (Transform) null);
    itemHolderPetUsed.transform.position = this.transform.position;
    itemHolderPetUsed.transform.eulerAngles = this.transform.eulerAngles;
    itemHolderPetUsed.SetUp(this.head.sprite);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ItemHolderPetUsed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class ItemHolderPetUsed : MonoBehaviour
{
  [SerializeField]
  public Image headImage;
  [SerializeField]
  public Vector2 velocityRangeX = new Vector2(10f, 15f);
  [SerializeField]
  public Vector2 velocityRangeY = new Vector2(11f, 13f);
  [SerializeField]
  public Vector2 velocityRangeZ = new Vector2(-15f, -10f);

  public void Start()
  {
    Vector3 dir = new Vector3(this.velocityRangeX.PettyRandom().WithRandomSign(), this.velocityRangeY.PettyRandom(), this.velocityRangeZ.PettyRandom());
    this.gameObject.GetOrAdd<FlyOffScreen>().Knockback(dir);
  }

  public void SetUp(Sprite headSprite)
  {
    if (!((Object) this.headImage != (Object) null))
      return;
    this.headImage.sprite = headSprite;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Journal
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using UnityEngine;
using UnityEngine.UI;

[ExecuteInEditMode]
public class Journal : MonoBehaviour
{
  [SerializeField]
  public JournalTab openOnEnable;
  [SerializeField]
  public Transform leftPageGroup;
  [SerializeField]
  public Transform rightPageGroup;
  [SerializeField]
  public Image page;
  [SerializeField]
  public EventReference closeSfxRef;

  public void OnEnable()
  {
    if (!Application.isPlaying)
      return;
    if ((bool) (Object) this.openOnEnable)
      this.openOnEnable.Select();
    SfxSystem.OneShot("event:/sfx/ui/journal_open");
  }

  public void PagedOpened(JournalPage page)
  {
    if (!((Object) page.transform.parent == (Object) this.leftPageGroup))
      return;
    foreach (Component component1 in this.rightPageGroup)
    {
      JournalPage component2 = component1.GetComponent<JournalPage>();
      if (component2 != null && component2.gameObject.activeSelf)
        component2.Close();
    }
  }

  public void SetPageImage(Sprite sprite) => this.page.sprite = sprite;

  public void Close() => SfxSystem.OneShot(this.closeSfxRef);
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalAddNameSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System.Collections;
using UnityEngine;

public class JournalAddNameSequence : MonoBehaviour
{
  [SerializeField]
  public LeaderNameHistoryDisplay display;
  [SerializeField]
  public TweenUI endTween;
  [SerializeField]
  public EventReference sfxEvent;

  public static IEnumerator LoadAndRun(CardData leader, bool unloadAfter)
  {
    InputSystem.Disable();
    yield return (object) SceneManager.Load("JournalNameHistory", SceneType.Temporary);
    JournalAddNameSequence addNameSequence = Object.FindObjectOfType<JournalAddNameSequence>();
    yield return (object) addNameSequence.Run(leader);
    if (unloadAfter)
    {
      Routine routine = new Routine(addNameSequence.End());
    }
    InputSystem.Enable();
  }

  public IEnumerator Run(CardData leader)
  {
    yield return (object) new WaitForSecondsRealtime(0.5f);
    JournalNameHistory.FadePrevious();
    JournalNameHistory.AddName(leader.title);
    this.display.Repopulate();
    SfxSystem.OneShot(this.sfxEvent);
    yield return (object) new WaitForSecondsRealtime(1f);
  }

  public IEnumerator End()
  {
    this.endTween.Fire();
    yield return (object) new WaitForSecondsRealtime(this.endTween.GetDuration());
    Routine routine = new Routine(SceneManager.Unload("JournalNameHistory"));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalCard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class JournalCard : MonoBehaviour
{
  [SerializeField]
  public TMP_Text nameText;
  [SerializeField]
  public Image background;
  [SerializeField]
  public Image image;
  [SerializeField]
  public Button button;
  [SerializeField]
  public Material discoveredMaterial;
  [SerializeField]
  public Image frame;
  [SerializeField]
  public Sprite[] frames;
  public CardData cardData;
  public bool discovered;

  public void SetCardArt(CardData cardData, float scale)
  {
    this.cardData = cardData;
    this.background.sprite = cardData.backgroundSprite;
    this.image.sprite = cardData.mainSprite;
    this.background.transform.localScale = Vector3.one * scale;
    this.image.transform.localScale = Vector3.one * scale;
    string rootCardDataName;
    CreatedByLookup.TryGetCreatedByRoot(cardData.name, out rootCardDataName);
    this.frame.sprite = this.frames[CardFramesSystem.GetFrameLevel(rootCardDataName)];
  }

  public void CheckDiscovered(List<string> discoveredCards, JournalCardManager manager)
  {
    if (this.discovered || !discoveredCards.Contains(this.cardData.name))
      return;
    this.SetDiscovered(this.cardData.title, manager);
  }

  public void SetDiscovered(string title, JournalCardManager manager)
  {
    this.discovered = true;
    this.nameText.text = title;
    this.background.enabled = true;
    this.image.material = this.discoveredMaterial;
    this.image.color = Color.white;
    this.button.onClick.AddListener((UnityAction) (() => manager.Select(this.cardData)));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalCardDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using TMPro;
using UnityEngine;

public class JournalCardDisplay : MonoBehaviour
{
  [SerializeField]
  public CardInspector inspector;
  [SerializeField]
  public JournalCardDisplay.PositionProfile normalPositionProfile;
  [SerializeField]
  public JournalCardDisplay.PositionProfile bigPositionProfile;
  [Header("Card Info Elements")]
  [SerializeField]
  public TMP_Text nameText;
  [SerializeField]
  public ImageSprite typeIcon;
  [SerializeField]
  public TMP_Text typeText;
  public CanvasGroup _canvasGroup;
  public Card current;
  public readonly Vector3 from = new Vector3(0.75f, 0.75f, 0.75f);

  public CanvasGroup canvasGroup => this._canvasGroup ?? (this._canvasGroup = this.gameObject.GetOrAdd<CanvasGroup>());

  public void OnDisable()
  {
    if (!(bool) (UnityEngine.Object) this.current)
      return;
    this.nameText.text = "";
    this.typeIcon.enabled = false;
    this.typeText.text = "";
    this.inspector.ClearPopups();
    CardManager.ReturnToPoolNextFrame(this.current);
    this.current = (Card) null;
  }

  public void Display(CardData cardData)
  {
    if ((bool) (UnityEngine.Object) this.current)
    {
      if ((bool) (UnityEngine.Object) this.current.entity.data && (bool) (UnityEngine.Object) cardData && this.current.entity.data.name == cardData.name)
        return;
      CardManager.ReturnToPool(this.current);
    }
    this.current = CardManager.Get(cardData, (CardController) null, (Character) null, false, true);
    this.current.transform.SetParent(this.transform);
    if (this.current.entity.height == 2)
      this.bigPositionProfile.Set();
    else
      this.normalPositionProfile.Set();
    this.StopAllCoroutines();
    this.StartCoroutine(this.UpdateCard(this.current));
  }

  public IEnumerator UpdateCard(Card card)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    JournalCardDisplay journalCardDisplay = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      journalCardDisplay.nameText.text = card.entity.data.title;
      journalCardDisplay.typeIcon.enabled = true;
      journalCardDisplay.typeIcon.SetSprite(card.entity.data.cardType.icon);
      journalCardDisplay.typeText.text = card.entity.data.cardType.title;
      card.transform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
      card.transform.localScale = Vector3.one;
      journalCardDisplay.inspector.ClearPopups();
      journalCardDisplay.inspector.CreatePopups(card.entity);
      LeanTween.cancel(journalCardDisplay.gameObject);
      journalCardDisplay.transform.localScale = journalCardDisplay.from;
      LeanTween.scale(journalCardDisplay.gameObject, Vector3.one, 0.2f).setEaseOutBack().setIgnoreTimeScale(true);
      journalCardDisplay.canvasGroup.alpha = 0.0f;
      LeanTween.alphaCanvas(journalCardDisplay.canvasGroup, 1f, 0.2f).setEaseOutBack().setIgnoreTimeScale(true);
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) card.UpdateData(false);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  [Serializable]
  public struct PositionProfile
  {
    public RectTransform[] transforms;
    public Vector3[] anchoredPositions;

    public void Set()
    {
      for (int index = 0; index < this.transforms.Length; ++index)
        this.transforms[index].anchoredPosition = (Vector2) this.anchoredPositions[index];
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalCardManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Deadpan.Enums.Engine.Components.Modding;
using FMODUnity;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;
using UnityEngine.ResourceManagement.AsyncOperations;
using UnityEngine.UI;

public class JournalCardManager : MonoBehaviour
{
  [SerializeField]
  public JournalCardManager.Category[] categories;
  [SerializeField]
  public JournalCard cardPrefab;
  [SerializeField]
  public Transform content;
  [SerializeField]
  public Scroller scroller;
  [SerializeField]
  public JournalCardDisplay cardDisplay;
  [SerializeField]
  public Button[] tabs;
  [SerializeField]
  public GameObject[] tabSelected;
  [SerializeField]
  public RewiredHotKeyController hotKeyTabLeft;
  [SerializeField]
  public RewiredHotKeyController hotKeyTabRight;
  [SerializeField]
  public EventReference selectCardSfxEvent;
  public List<string> discovered;
  public int currentCategory;
  public readonly List<AsyncOperationHandle<CardData>> handles = new List<AsyncOperationHandle<CardData>>();
  public readonly List<JournalCard> cardIcons = new List<JournalCard>();
  public Locale locale;
  public static readonly Dictionary<string, float> scaleOverride = new Dictionary<string, float>()
  {
    {
      "FinalBoss2",
      1.3f
    }
  };

  public void OnEnable()
  {
    this.discovered = SaveSystem.LoadProgressData<List<string>>("cardsDiscovered");
    if (this.discovered != null)
    {
      foreach (JournalCard cardIcon in this.cardIcons)
        cardIcon.CheckDiscovered(this.discovered, this);
    }
    else
      this.discovered = new List<string>();
    if (!((UnityEngine.Object) this.locale != (UnityEngine.Object) null) || !((UnityEngine.Object) this.locale != (UnityEngine.Object) LocalizationSettings.SelectedLocale))
      return;
    this.locale = LocalizationSettings.SelectedLocale;
    this.CreateCards(this.currentCategory);
  }

  public void Start()
  {
    this.CreateCards(0);
    this.locale = LocalizationSettings.SelectedLocale;
  }

  public void CreateCards(string categoryName)
  {
    for (int categoryIndex = 0; categoryIndex < this.categories.Length; ++categoryIndex)
    {
      if (this.categories[categoryIndex].name == categoryName)
      {
        if (categoryIndex == this.currentCategory)
          break;
        this.CreateCards(categoryIndex);
        break;
      }
    }
  }

  public void CreateCards(int categoryIndex)
  {
    this.currentCategory = categoryIndex;
    this.content.DestroyAllChildren();
    this.cardIcons.Clear();
    foreach (CardData cardData in Extensions.GetCategoryCardData(this.categories[this.currentCategory].name))
    {
      string title = cardData.title;
      JournalCard journalCard = UnityEngine.Object.Instantiate<JournalCard>(this.cardPrefab, this.content);
      this.cardIcons.Add(journalCard);
      float num;
      float scale = JournalCardManager.scaleOverride.TryGetValue(cardData.name, out num) ? num : 1f;
      journalCard.SetCardArt(cardData, scale);
      if (this.discovered.Contains(cardData.name))
        journalCard.SetDiscovered(title, this);
    }
    this.StartCoroutine(this.ScrollToTop());
  }

  public IEnumerator ScrollToTop()
  {
    yield return (object) new WaitForEndOfFrame();
    this.scroller.ScrollImmediate(100f);
  }

  public void Select(CardData cardData)
  {
    this.cardDisplay.Display(cardData);
    SfxSystem.OneShot(this.selectCardSfxEvent);
  }

  public void SelectTab(int index)
  {
    this.CreateCards(index);
    foreach (GameObject gameObject in this.tabSelected)
      gameObject.SetActive(false);
    this.tabSelected[index].SetActive(true);
  }

  public void NextTab()
  {
    ++this.currentCategory;
    if (this.currentCategory >= this.categories.Length)
      this.currentCategory -= this.categories.Length;
    this.SelectTab(this.currentCategory);
  }

  public void PreviousTab()
  {
    --this.currentCategory;
    if (this.currentCategory < 0)
      this.currentCategory += this.categories.Length;
    this.SelectTab(this.currentCategory);
  }

  [Serializable]
  public struct Category
  {
    public string name;
    public AssetReferenceT<CardData>[] cards;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalCharm
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class JournalCharm : MonoBehaviourRect
{
  public Vector2 popUpOffset = new Vector2(1f, 0.0f);
  [SerializeField]
  public Image image;
  [SerializeField]
  public Material discoveredMaterial;
  public CardUpgradeData upgradeData;
  public bool discovered;
  public bool hover;

  public void OnDisable() => this.UnHover();

  public void Assign(CardUpgradeData upgradeData)
  {
    this.upgradeData = upgradeData;
    this.image.sprite = this.upgradeData.image;
  }

  public void CheckDiscovered(List<string> discoveredCharms)
  {
    if (this.discovered || !discoveredCharms.Contains(this.upgradeData.name))
      return;
    this.SetDiscovered();
  }

  public void SetDiscovered()
  {
    this.discovered = true;
    this.image.material = this.discoveredMaterial;
    this.image.color = Color.white;
  }

  public void Hover()
  {
    if (!this.discovered)
      return;
    this.hover = true;
    CardPopUp.AssignTo(this.rectTransform, this.popUpOffset.x, this.popUpOffset.y);
    CardPopUp.AddPanel(this.upgradeData.name, this.upgradeData.title, this.upgradeData.text);
  }

  public void UnHover()
  {
    if (!this.discovered || !this.hover)
      return;
    this.hover = false;
    CardPopUp.RemovePanel(this.upgradeData.name);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalCharmManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;

public class JournalCharmManager : MonoBehaviour
{
  [SerializeField]
  public JournalCharm charmPrefab;
  [SerializeField]
  public Transform content;
  public List<string> discovered;
  public readonly List<JournalCharm> charmIcons = new List<JournalCharm>();
  public Locale locale;

  public void OnEnable()
  {
    this.discovered = SaveSystem.LoadProgressData<List<string>>("charmsDiscovered");
    if (this.discovered != null)
    {
      foreach (JournalCharm charmIcon in this.charmIcons)
        charmIcon.CheckDiscovered(this.discovered);
    }
    else
      this.discovered = new List<string>();
    CardPopUp.SetCanvasLayer("PauseMenu", 1);
    CardPopUp.SetIgnoreTimeScale(true);
    if (!((UnityEngine.Object) this.locale == (UnityEngine.Object) null) && !((UnityEngine.Object) this.locale != (UnityEngine.Object) LocalizationSettings.SelectedLocale))
      return;
    this.locale = LocalizationSettings.SelectedLocale;
    this.CreateCharms();
  }

  public void OnDisable() => CardPopUp.Reset();

  public void CreateCharms()
  {
    this.content.DestroyAllChildren();
    this.charmIcons.Clear();
    foreach (KeyValuePair<string, CardUpgradeData> keyValuePair in this.LoadCharmData())
    {
      JournalCharm journalCharm = UnityEngine.Object.Instantiate<JournalCharm>(this.charmPrefab, this.content);
      this.charmIcons.Add(journalCharm);
      journalCharm.Assign(keyValuePair.Value);
      if (this.discovered.Contains(keyValuePair.Value.name))
        journalCharm.SetDiscovered();
    }
  }

  public List<KeyValuePair<string, CardUpgradeData>> LoadCharmData() => AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData").Where<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => a.type == CardUpgradeData.Type.Charm && a.tier >= -2)).ToDictionary<CardUpgradeData, string, CardUpgradeData>((Func<CardUpgradeData, string>) (a => a.title), (Func<CardUpgradeData, CardUpgradeData>) (a => a)).OrderByDescending<KeyValuePair<string, CardUpgradeData>, bool>((Func<KeyValuePair<string, CardUpgradeData>, bool>) (a => a.Value.tier >= 0)).ThenBy<KeyValuePair<string, CardUpgradeData>, string>((Func<KeyValuePair<string, CardUpgradeData>, string>) (a => a.Key)).ToList<KeyValuePair<string, CardUpgradeData>>();
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalIconGroup
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class JournalIconGroup : MonoBehaviour
{
  [SerializeField]
  public List<ButtonAnimator> buttons;
  [SerializeField]
  public Image[] icons;
  [SerializeField]
  public Color baseColour = Color.white;
  [SerializeField]
  public Color highlightColour = Color.white;
  public ButtonAnimator currentHover;
  public Image highlightedIcon;

  public void Awake()
  {
    foreach (Graphic icon in this.icons)
      icon.color = this.baseColour;
  }

  public void Update()
  {
    if ((UnityEngine.Object) this.currentHover == (UnityEngine.Object) null)
    {
      ButtonAnimator buttonAnimator = this.buttons.FirstOrDefault<ButtonAnimator>((Func<ButtonAnimator, bool>) (a => a.IsHoveredOrPressed));
      if (!((UnityEngine.Object) buttonAnimator != (UnityEngine.Object) null))
        return;
      this.currentHover = buttonAnimator;
      this.Changed();
    }
    else
    {
      if (this.currentHover.IsHoveredOrPressed)
        return;
      this.currentHover = (ButtonAnimator) null;
      this.Changed();
    }
  }

  public void Changed()
  {
    if ((UnityEngine.Object) this.highlightedIcon != (UnityEngine.Object) null)
      this.highlightedIcon.color = this.baseColour;
    if (!((UnityEngine.Object) this.currentHover != (UnityEngine.Object) null))
      return;
    this.highlightedIcon = this.icons[this.buttons.IndexOf(this.currentHover)];
    this.highlightedIcon.color = this.highlightColour;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalNameHistory
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Collections.Generic;
using UnityEngine;

public static class JournalNameHistory
{
  public const int maxEntries = 26;
  public const float fadePrevious = 0.035f;
  public static readonly Vector2 startPos = new Vector2(-1.733333f, 3f);
  public static readonly Vector2 spacing = new Vector2(1.733333f, 1f);
  public static readonly Vector2 bounds = new Vector2(1.733333f, -3f);
  public static readonly Vector2 randomOffset = new Vector2(0.5f, 0.25f);
  public const float randomAngle = 3f;

  public static void AddName(string name)
  {
    JournalNameHistory.Name name1 = new JournalNameHistory.Name(name, JournalNameHistory.randomOffset, 3f);
    List<JournalNameHistory.Name> nameList1 = SaveSystem.LoadProgressData<List<JournalNameHistory.Name>>("leaderNameHistory") ?? new List<JournalNameHistory.Name>();
    Vector2 vector2_1;
    if (nameList1.Count <= 0)
    {
      vector2_1 = JournalNameHistory.startPos;
    }
    else
    {
      List<JournalNameHistory.Name> nameList2 = nameList1;
      vector2_1 = nameList2[nameList2.Count - 1].position;
    }
    Vector2 vector2_2 = vector2_1;
    if (nameList1.Count > 0)
    {
      vector2_2.y -= JournalNameHistory.spacing.y;
      if ((double) vector2_2.y < (double) JournalNameHistory.bounds.y)
      {
        vector2_2.y = JournalNameHistory.startPos.y;
        vector2_2.x += JournalNameHistory.spacing.x;
        if ((double) vector2_2.x > (double) JournalNameHistory.bounds.x)
          vector2_2.x = JournalNameHistory.startPos.x;
      }
    }
    name1.position = vector2_2;
    nameList1.Add(name1);
    SaveSystem.SaveProgressData<List<JournalNameHistory.Name>>("leaderNameHistory", nameList1);
  }

  public static void FadePrevious()
  {
    List<JournalNameHistory.Name> nameList = SaveSystem.LoadProgressData<List<JournalNameHistory.Name>>("leaderNameHistory");
    if (nameList == null || nameList.Count <= 0)
      return;
    while (nameList.Count > 25)
      nameList.RemoveAt(0);
    foreach (JournalNameHistory.Name name in nameList)
      name.opacity -= 0.035f;
    SaveSystem.SaveProgressData<List<JournalNameHistory.Name>>("leaderNameHistory", nameList);
  }

  public static void MostRecentNameKilled()
  {
    List<JournalNameHistory.Name> nameList1 = SaveSystem.LoadProgressData<List<JournalNameHistory.Name>>("leaderNameHistory");
    if (nameList1 == null || nameList1.Count <= 0)
      return;
    List<JournalNameHistory.Name> nameList2 = nameList1;
    nameList2[nameList2.Count - 1].killed = true;
    SaveSystem.SaveProgressData<List<JournalNameHistory.Name>>("leaderNameHistory", nameList1);
  }

  public static void MostRecentNameMissing()
  {
    List<JournalNameHistory.Name> nameList1 = SaveSystem.LoadProgressData<List<JournalNameHistory.Name>>("leaderNameHistory");
    if (nameList1 == null || nameList1.Count <= 0)
      return;
    List<JournalNameHistory.Name> nameList2 = nameList1;
    nameList2[nameList2.Count - 1].missing = true;
    SaveSystem.SaveProgressData<List<JournalNameHistory.Name>>("leaderNameHistory", nameList1);
  }

  [Serializable]
  public class Name
  {
    public string text;
    public bool killed;
    public bool missing;
    public float opacity;
    public Vector2 position;
    public Vector2 offset;
    public float angle;

    public Name()
    {
    }

    public Name(string text, Vector2 randomOffset, float randomAngle)
    {
      this.text = text;
      this.opacity = 1f;
      this.offset = new Vector2(randomOffset.x * PettyRandom.Range(-1f, 1f), randomOffset.y * PettyRandom.Range(-1f, 1f));
      this.angle = randomAngle * PettyRandom.Range(-1f, 1f);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalPage
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[ExecuteInEditMode]
public class JournalPage : MonoBehaviour
{
  [SerializeField]
  public Journal journal;
  [SerializeField]
  public Sprite pageSprite;
  [SerializeField]
  public JournalPage alsoOpen;

  public void Open()
  {
    if (this.gameObject.activeSelf)
      return;
    foreach (Component component in this.transform.parent)
      component.gameObject.SetActive(false);
    this.gameObject.SetActive(true);
    this.journal.PagedOpened(this);
    if ((bool) (Object) this.pageSprite)
      this.journal.SetPageImage(this.pageSprite);
    if (!((Object) this.alsoOpen != (Object) null))
      return;
    this.alsoOpen.Open();
  }

  public void Close() => this.gameObject.SetActive(false);
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalPageData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.AddressableAssets;

[CreateAssetMenu(fileName = "Journal Page Data", menuName = "Journal Page Data")]
public class JournalPageData : ScriptableObject
{
  public UnlockData unlock;
  public bool unlockOnMap = true;
  [ShowIf("unlockOnMap")]
  public char mapTierIndex;
  [ShowIf("unlockOnMap")]
  public char mapAfterLetter;
  [ShowIf("unlockOnMap")]
  public CampaignNodeType mapNodeType;
  public AssetReferenceGameObject prefabRef;
  public GameMode[] legalGameModes;
  public ClassData[] legalTribes;
  public GameModifierData[] requiresModifiers;
  public int requiresStormPoints;
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalPageMenu
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class JournalPageMenu : JournalPage
{
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalPageUnlockSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class JournalPageUnlockSystem : GameSystem
{
  [SerializeField]
  public JournalPageData[] pages;

  public void OnEnable() => Events.OnCampaignLoadPreset += new Events.UnityActionRef<string[]>(this.InsertJournalPages);

  public void OnDisable() => Events.OnCampaignLoadPreset -= new Events.UnityActionRef<string[]>(this.InsertJournalPages);

  public void InsertJournalPages(ref string[] lines)
  {
    List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
    foreach (JournalPageData page in this.pages)
    {
      if (page.unlockOnMap && !unlockedList.Contains(page.unlock.name) && JournalPageUnlockSystem.IsLegal(page))
      {
        int startIndex = 0;
        for (int index = lines[0].Length - 1; index >= 0; --index)
        {
          if ((int) lines[2][index] == (int) page.mapTierIndex && ((int) lines[0][index] == (int) page.mapAfterLetter || (int) lines[1][index] == (int) page.mapAfterLetter))
          {
            startIndex = index + 1;
            break;
          }
        }
        lines[0] = lines[0].Insert(startIndex, page.mapNodeType.letter);
        lines[1] = lines[1].Insert(startIndex, " ");
        lines[2] = lines[2].Insert(startIndex, lines[2][startIndex - 1].ToString());
        lines[3] = lines[3].Insert(startIndex, lines[3][startIndex - 1].ToString());
      }
    }
  }

  public static bool IsLegal(JournalPageData page) => page.legalGameModes.Contains<GameMode>(Campaign.Data.GameMode) && page.legalTribes.Contains<ClassData>(References.PlayerData.classData) && JournalPageUnlockSystem.HasRequiredStormPoints(page) && JournalPageUnlockSystem.HasRequiredModifiers(page);

  public static bool HasRequiredStormPoints(JournalPageData page) => page.requiresStormPoints <= 0 || StormBellManager.GetCurrentStormPoints(StormBellManager.GetActiveStormBells()) >= page.requiresStormPoints;

  public static bool HasRequiredModifiers(JournalPageData page)
  {
    GameModifierData[] requiresModifiers = page.requiresModifiers;
    if (requiresModifiers == null || requiresModifiers.Length <= 0)
      return true;
    return Campaign.Data.Modifiers != null && Campaign.Data.Modifiers.ContainsAll<GameModifierData>((IEnumerable<GameModifierData>) page.requiresModifiers);
  }

  public static CampaignGenerator.Node CreateNode(
    float x,
    float y,
    string type,
    int positionIndex)
  {
    Vector2 vector2 = Dead.Random.Vector2();
    x += vector2.x;
    y += vector2.y;
    return new CampaignGenerator.Node(x, y, 1f, 0, positionIndex, 0, type);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalTab
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class JournalTab : MonoBehaviour
{
  [SerializeField]
  public ButtonType type = ButtonType.Sub;
  [SerializeField]
  public GameObject tweenTarget;
  [SerializeField]
  public Image image;
  [SerializeField]
  public UINavigationItem nav;
  [SerializeField]
  public bool selected;
  [SerializeField]
  public GameObject selectedGroup;
  [SerializeField]
  public GameObject unselectedGroup;
  [SerializeField]
  public UnityEvent onSelect;
  [SerializeField]
  public Transform[] unselectGroups;
  [Header("Colours")]
  [SerializeField]
  public Color baseColour;
  [SerializeField]
  public Color highlightColour;
  [SerializeField]
  public Color pressColour;
  [SerializeField]
  public Color disabledColour;
  public bool _interactable = true;
  public bool hover;
  public bool press;

  public bool interactable
  {
    get => this._interactable;
    set
    {
      if (value)
        this.SetUnHighlighted();
      else
        this.SetDisabled();
      this._interactable = value;
      if (!((Object) this.nav != (Object) null))
        return;
      this.nav.enabled = value;
    }
  }

  public void OnEnable() => this.SetSelected();

  public void Hover()
  {
    if (this.hover || !this.interactable)
      return;
    this.hover = true;
    if (this.press)
      return;
    this.HoverTween();
    this.SetHighlighted();
    global::Events.InvokeButtonHover(this.type);
  }

  public void UnHover()
  {
    if (!this.hover)
      return;
    this.hover = false;
    if (this.press)
      return;
    this.UnHoverTween();
    this.SetUnHighlighted();
  }

  public void Press()
  {
    if (this.press || !this.interactable)
      return;
    this.press = true;
    this.PressTween();
    this.SetPressed();
    global::Events.InvokeButtonPress(this.type);
  }

  public void Release()
  {
    if (!this.press)
      return;
    this.press = false;
    if (this.hover)
    {
      SfxSystem.OneShot("event:/sfx/ui/journal_click");
      this.Select();
      this.SetHighlighted();
      this.HoverTween();
    }
    else
    {
      this.SetUnHighlighted();
      this.ReleaseTween();
    }
  }

  public void Select()
  {
    foreach (Transform unselectGroup in this.unselectGroups)
    {
      foreach (Component component1 in unselectGroup)
      {
        JournalTab component2 = component1.GetComponent<JournalTab>();
        if (component2 != null && component2.selected)
          component2.Deselect();
      }
    }
    this.selected = true;
    this.SetSelected();
    this.onSelect?.Invoke();
  }

  public void Deselect()
  {
    this.selected = false;
    this.SetSelected();
  }

  public void HoverTween()
  {
    LeanTween.cancel(this.tweenTarget);
    LeanTween.scale(this.tweenTarget, new Vector3(1.05f, 1.05f, 1f), 0.2f).setIgnoreTimeScale(true).setEaseOutBack();
  }

  public void UnHoverTween()
  {
    LeanTween.cancel(this.tweenTarget);
    LeanTween.scale(this.tweenTarget, Vector3.one, 0.05f).setIgnoreTimeScale(true);
  }

  public void PressTween()
  {
    LeanTween.cancel(this.tweenTarget);
    LeanTween.scale(this.tweenTarget, new Vector3(0.95f, 0.95f, 1f), 0.05f).setIgnoreTimeScale(true);
  }

  public void ReleaseTween()
  {
    LeanTween.cancel(this.tweenTarget);
    LeanTween.scale(this.tweenTarget, Vector3.one, 0.05f).setIgnoreTimeScale(true);
  }

  public void SetHighlighted()
  {
    if (!((Object) this.image != (Object) null))
      return;
    this.image.color = this.highlightColour;
  }

  public void SetUnHighlighted()
  {
    if (!((Object) this.image != (Object) null))
      return;
    this.image.color = this.baseColour;
  }

  public void SetPressed()
  {
    if (!((Object) this.image != (Object) null))
      return;
    this.image.color = this.pressColour;
  }

  public void SetDisabled()
  {
    if (!((Object) this.image != (Object) null))
      return;
    this.image.color = this.disabledColour;
  }

  public void SetSelected()
  {
    this.selectedGroup.SetActive(this.selected);
    this.unselectedGroup.SetActive(!this.selected);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JournalVoidNameSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class JournalVoidNameSequence : MonoBehaviour
{
  [SerializeField]
  public LeaderNameHistoryDisplay display;
  [SerializeField]
  public TweenUI endTween;

  public static IEnumerator LoadAndRun(bool unloadAfter)
  {
    yield return (object) SceneManager.Load("JournalNameHistory", SceneType.Temporary);
    JournalVoidNameSequence voidNameSequence = Object.FindObjectOfType<JournalVoidNameSequence>();
    yield return (object) voidNameSequence.PlayerKilled();
    if (unloadAfter)
      yield return (object) voidNameSequence.End();
  }

  public IEnumerator PlayerKilled()
  {
    yield return (object) new WaitForSecondsRealtime(0.5f);
    JournalNameHistory.MostRecentNameKilled();
    this.display.Repopulate();
    yield return (object) new WaitForSecondsRealtime(1f);
  }

  public IEnumerator End()
  {
    this.endTween.Fire();
    yield return (object) new WaitForSecondsRealtime(this.endTween.GetDuration());
    Routine routine = new Routine(SceneManager.Unload("JournalNameHistory"));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JoystickButtonStyle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Rewired;
using Rewired.Data.Mapping;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Localization;

[CreateAssetMenu(menuName = "Joystick Button Style", fileName = "Joystick Button Style")]
public class JoystickButtonStyle : ScriptableObject
{
  public HardwareJoystickMap[] hardwareMaps;
  public string hardwareIdentifier;
  public int templateId;
  public string tag;
  [SerializeField]
  public JoystickButtonStyle.ElementButton[] elements;
  [SerializeField]
  public ControllerType type = ControllerType.Joystick;

  public IEnumerable<Guid> guids => ((IEnumerable<HardwareJoystickMap>) this.hardwareMaps).Select<HardwareJoystickMap, Guid>((Func<HardwareJoystickMap, Guid>) (a => a.Guid));

  public JoystickButtonStyle.ElementButton GetElement(Player player, string actionName)
  {
    ActionElementMap elementMapWithAction = player.controllers.maps.GetFirstElementMapWithAction(this.type, actionName, true);
    return elementMapWithAction != null ? this.elements[elementMapWithAction.elementIndex] : (JoystickButtonStyle.ElementButton) null;
  }

  [Serializable]
  public class ElementButton
  {
    public string elementName;
    public Sprite buttonSprite;
    public LocalizedString textKey;

    public bool hasSprite => (bool) (UnityEngine.Object) this.buttonSprite;

    public string text => this.textKey.GetLocalizedString();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: JoystickScroller
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof (ScrollRect))]
public class JoystickScroller : MonoBehaviour
{
  [SerializeField]
  public string scrollAction = "Scroll Vertical";
  public ScrollRect _scrollRect;
  public readonly Vector2 add = new Vector2(0.0f, -20f);

  public ScrollRect scrollRect => this._scrollRect ?? (this._scrollRect = this.GetComponent<ScrollRect>());

  public void LateUpdate()
  {
    if (!this.scrollRect.enabled)
      return;
    float axis = InputSystem.GetAxis(this.scrollAction);
    if ((double) Mathf.Abs(axis) <= 1.4012984643248171E-45 || !(bool) (Object) this.scrollRect.content)
      return;
    float normalizedPosition = this.scrollRect.verticalNormalizedPosition;
    if (((double) axis <= 0.0 || (double) normalizedPosition >= 1.0) && ((double) axis >= 0.0 || (double) normalizedPosition <= 0.0))
      return;
    this.scrollRect.content.anchoredPosition += this.add * (axis * Mathf.Abs(axis) * Time.unscaledDeltaTime);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: KeywordData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization;

[CreateAssetMenu(fileName = "Keyword", menuName = "Keyword")]
public class KeywordData : DataFile
{
  [SerializeField]
  public LocalizedString titleKey;
  [SerializeField]
  public LocalizedString descKey;
  public Color titleColour = new Color(1f, 0.7921569f, 0.3411765f, 1f);
  public Color bodyColour = Color.white;
  public Color noteColour = Color.gray;
  public Sprite panelSprite;
  public Color panelColor;
  public string iconName;
  public string iconTintHex;
  public bool show = true;
  public bool showName;
  public bool showIcon = true;
  public bool canStack;

  public bool HasTitle => !this.titleKey.IsEmpty;

  public string title => this.titleKey.GetLocalizedString();

  public string body
  {
    get
    {
      string localizedString = this.descKey.GetLocalizedString();
      int length = localizedString.IndexOf('|');
      return length <= 0 ? localizedString : localizedString.Substring(0, length);
    }
  }

  public string note
  {
    get
    {
      string localizedString = this.descKey.GetLocalizedString();
      int num = localizedString.IndexOf('|');
      return num <= 0 ? (string) null : localizedString.Substring(num + 1);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: KillComboSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class KillComboSystem : GameSystem
{
  public string[] colors = new string[1]{ "ffffff" };
  public string format = "<line-height=0.35><size=0.7><#{1}>x{0}\n<size=0.35>Combo\n\n<#FFD150>+{2}<sprite name=bling>";
  public int min = 2;
  public int baseGold;
  public int goldPerCombo = 5;
  public int count = 1;

  public void OnEnable()
  {
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnBattleTurnEnd += new UnityAction<int>(this.BattleTurnEnd);
    global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);
  }

  public void OnDisable()
  {
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnBattleTurnEnd -= new UnityAction<int>(this.BattleTurnEnd);
    global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);
  }

  public void BattlePhaseStart(Battle.Phase phase)
  {
    if (phase != Battle.Phase.Init)
      return;
    this.count = 1;
  }

  public void BattleTurnEnd(int turnNumber) => this.count = 1;

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    if (!(bool) (Object) References.Player || !((Object) entity.owner != (Object) References.Player))
      return;
    if (this.count >= this.min)
    {
      Vector3 position = entity.transform.position;
      int goldAmount = this.GetGoldAmount(this.count);
      string text = string.Format(this.format, (object) this.count, (object) this.colors[Mathf.Clamp(this.count - this.min, 0, this.colors.Length - 1)], (object) goldAmount);
      FloatingText.Create(position + Vector3.down * 0.5f, text).Animate("Spring").Fade("Smooth", 0.5f, 0.5f);
      global::Events.InvokeDropGold(goldAmount, "Combo", References.Player, position);
      SfxSystem.OneShot("event:/sfx/attack/combo_marker");
      global::Events.InvokeKillCombo(this.count);
    }
    ++this.count;
  }

  public int GetGoldAmount(int killCount) => Mathf.RoundToInt((float) (this.baseGold + (1 + killCount - this.min) * this.goldPerCombo) * References.PlayerData.comboGoldFactor);
}
﻿// Decompiled with JetBrains decompiler
// Type: LargeUIScaler
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Serialization;

public class LargeUIScaler : WorldSpaceCanvasUpdater
{
  [SerializeField]
  public bool setScale = true;
  [SerializeField]
  [ShowIf("setScale")]
  [FormerlySerializedAs("scaleMinV")]
  public Vector3 scaleMin = Vector3.one;
  [SerializeField]
  [ShowIf("setScale")]
  [FormerlySerializedAs("scaleMaxV")]
  public Vector3 scaleMax = Vector3.one;
  [SerializeField]
  public bool setPosition;
  [SerializeField]
  [ShowIf("setPosition")]
  public Vector3 positionMin;
  [SerializeField]
  [ShowIf("setPosition")]
  public Vector3 positionMax;
  [SerializeField]
  public AnimationCurve aspectRatioInfluence;

  public override void UpdateSize()
  {
    if (!this.setScale && !this.setPosition)
      return;
    float t = 0.0f;
    if (this.aspectRatioInfluence.length > 0)
      t *= this.aspectRatioInfluence.Evaluate(WorldSpaceCanvasFitScreenSystem.AspectRatio);
    if (this.setScale)
      this.rectTransform.localScale = Vector3.Lerp(this.scaleMin, this.scaleMax, t);
    if (!this.setPosition)
      return;
    this.rectTransform.anchoredPosition3D = Vector3.Lerp(this.positionMin, this.positionMax, t);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LargeUIScaleUpdater
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LargeUIScaleUpdater : MonoBehaviour
{
  [SerializeField]
  public Vector3 scaleMin = Vector3.one;
  [SerializeField]
  public Vector3 scaleMax = Vector3.one;
  [SerializeField]
  public Vector3 positionMin;
  [SerializeField]
  public Vector3 positionMax;
  public Transform _transform;

  public Transform t => this._transform ?? (this._transform = this.transform);

  public void PromptUpdate()
  {
    this.t.localScale = Vector3.Lerp(this.scaleMin, this.scaleMax, 0.0f);
    this.t.localPosition = Vector3.Lerp(this.positionMin, this.positionMax, 0.0f);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LastStandSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

public class LastStandSystem : GameSystem
{
  [SerializeField]
  public StatusEffectData effect;
  [SerializeField]
  public StatusEffectData killEffect;
  [SerializeField]
  public Transform entityGroup;
  [SerializeField]
  public GameObject background;
  [SerializeField]
  public GameObject button;
  [SerializeField]
  public Dice playerDicePrefab;
  [SerializeField]
  public Dice enemyDicePrefab;
  [SerializeField]
  public Dice bossDicePrefab;
  [SerializeField]
  public Transform playerDiceGroup;
  [SerializeField]
  public Transform enemyDiceGroup;
  [SerializeField]
  public CardType[] legalCardTypes;
  [SerializeField]
  [ReadOnly]
  public int lastStandCount;
  public static Battle.Phase previousPhase;
  public static StatusEffectLastStand target;
  public static Entity subject;
  public static Entity attacker;
  public List<Entity> entities;
  public readonly Dictionary<Entity, Transform> previousParents = new Dictionary<Entity, Transform>();
  public readonly List<Dice> dice = new List<Dice>();
  public int result = -1;
  public bool diceRolled;
  public bool _active;

  public bool active
  {
    get => this._active;
    set
    {
      this._active = value;
      this.background.SetActive(value);
      this.button.SetActive(value);
    }
  }

  public void OnEnable()
  {
    global::Events.OnBattleStart += new UnityAction(this.BattleStart);
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);
  }

  public void OnDisable()
  {
    global::Events.OnBattleStart -= new UnityAction(this.BattleStart);
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);
  }

  public void BattleStart()
  {
    Entity target = References.Battle.cards.FirstOrDefault<Entity>((Func<Entity, bool>) (a => a.data.cardType.miniboss && (UnityEngine.Object) a.owner == (UnityEngine.Object) References.Player));
    if (!((UnityEngine.Object) target != (UnityEngine.Object) null))
      return;
    Routine routine = new Routine(StatusEffectSystem.Apply(target, (Entity) null, this.effect, 1));
  }

  public void BattlePhaseStart(Battle.Phase phase)
  {
    if (phase != Battle.Phase.LastStand)
      return;
    ActionSequence action = new ActionSequence(this.Process());
    action.note = "Last Stand";
    ActionQueue.Stack((PlayAction) action, true);
  }

  public IEnumerator Process()
  {
    LastStandSystem lastStandSystem = this;
    BattleMusicSystem musicSystem = UnityEngine.Object.FindObjectOfType<BattleMusicSystem>();
    if ((UnityEngine.Object) musicSystem != (UnityEngine.Object) null)
      musicSystem.FadePitchTo(0.3333f);
    lastStandSystem.entities = Battle.GetCardsOnBoard();
    foreach (Entity entity in lastStandSystem.entities)
    {
      lastStandSystem.previousParents[entity] = entity.transform.parent;
      entity.transform.parent = lastStandSystem.entityGroup;
      ++entity.silenceCount;
    }
    lastStandSystem.active = true;
    yield return (object) new WaitUntil(new Func<bool>(lastStandSystem.\u003CProcess\u003Eb__29_0));
    yield return (object) lastStandSystem.RollSequence();
    lastStandSystem.Clear();
    foreach (KeyValuePair<Entity, Transform> keyValuePair in lastStandSystem.previousParents.Where<KeyValuePair<Entity, Transform>>((Func<KeyValuePair<Entity, Transform>, bool>) (pair => (UnityEngine.Object) pair.Key != (UnityEngine.Object) null && (UnityEngine.Object) pair.Value != (UnityEngine.Object) null)))
      keyValuePair.Key.transform.parent = keyValuePair.Value;
    lastStandSystem.previousParents.Clear();
    lastStandSystem.active = false;
    if ((UnityEngine.Object) musicSystem != (UnityEngine.Object) null)
      musicSystem.FadePitchTo(1f);
    LastStandSystem.target.preventDeath = false;
    switch (lastStandSystem.result)
    {
      case 0:
        Debug.Log((object) "Player Wins!");
        if (Battle.IsOnBoard(LastStandSystem.attacker) && LastStandSystem.attacker.owner.team != LastStandSystem.subject.owner.team)
        {
          yield return (object) lastStandSystem.AttackAndKill(References.Battle.player, LastStandSystem.attacker);
          break;
        }
        break;
      case 1:
        Debug.Log((object) "Enemy Wins!");
        yield return (object) lastStandSystem.AttackAndKill(References.Battle.enemy, LastStandSystem.subject);
        break;
    }
    lastStandSystem.result = -1;
    References.Battle.CancelTurn();
    foreach (Entity entity in lastStandSystem.entities.Where<Entity>((Func<Entity, bool>) (e => (UnityEngine.Object) e != (UnityEngine.Object) null)))
      --entity.silenceCount;
    lastStandSystem.entities = (List<Entity>) null;
    if ((UnityEngine.Object) LastStandSystem.target != (UnityEngine.Object) null)
      LastStandSystem.target.ReEnable();
    if (!References.Battle.CheckEnd())
      References.Battle.phase = LastStandSystem.previousPhase;
  }

  public void Roll()
  {
    this.button.SetActive(false);
    this.diceRolled = true;
  }

  public IEnumerator RollSequence()
  {
    LastStandSystem lastStandSystem = this;
    Debug.Log((object) "Last Stand: Rolling Dice...");
    float delayBetween = 1f;
    Entity[] legalEntities = lastStandSystem.entities.Where<Entity>(new Func<Entity, bool>(lastStandSystem.\u003CRollSequence\u003Eb__31_0)).ToArray<Entity>();
    int count1 = ((IEnumerable<Entity>) legalEntities).Count<Entity>((Func<Entity, bool>) (a => (UnityEngine.Object) a.owner == (UnityEngine.Object) References.Battle.player));
    lastStandSystem.CreateDice(count1, lastStandSystem.playerDicePrefab, lastStandSystem.playerDiceGroup);
    int playerTotal = LastStandSystem.ThrowDice(lastStandSystem.playerDiceGroup);
    yield return (object) new WaitForSeconds(delayBetween);
    int count2 = ((IEnumerable<Entity>) legalEntities).Count<Entity>((Func<Entity, bool>) (a => (UnityEngine.Object) a.owner == (UnityEngine.Object) References.Battle.enemy && !a.data.cardType.miniboss)) + lastStandSystem.lastStandCount;
    lastStandSystem.CreateDice(count2, lastStandSystem.enemyDicePrefab, lastStandSystem.enemyDiceGroup);
    int count3 = ((IEnumerable<Entity>) legalEntities).Count<Entity>((Func<Entity, bool>) (a => (UnityEngine.Object) a.owner == (UnityEngine.Object) References.Battle.enemy && a.data.cardType.miniboss));
    lastStandSystem.CreateDice(count3, lastStandSystem.bossDicePrefab, lastStandSystem.enemyDiceGroup);
    int enemyTotal = LastStandSystem.ThrowDice(lastStandSystem.enemyDiceGroup);
    yield return (object) new WaitForSeconds(delayBetween);
    do
    {
      lastStandSystem.result = playerTotal > enemyTotal ? 0 : (enemyTotal > playerTotal ? 1 : -1);
      if (lastStandSystem.result == -1)
      {
        Debug.Log((object) "It's a draw!");
        playerTotal = LastStandSystem.ThrowDice(lastStandSystem.playerDiceGroup);
        yield return (object) new WaitForSeconds(delayBetween);
        enemyTotal = LastStandSystem.ThrowDice(lastStandSystem.enemyDiceGroup);
        yield return (object) new WaitForSeconds(delayBetween);
      }
    }
    while (lastStandSystem.result == -1);
    ++lastStandSystem.lastStandCount;
  }

  public void Clear()
  {
    foreach (Component die in this.dice)
      die.gameObject.Destroy();
    this.dice.Clear();
    this.diceRolled = false;
  }

  public void CreateDice(int count, Dice prefab, Transform group)
  {
    for (int index = 0; index < count; ++index)
    {
      Dice dice = UnityEngine.Object.Instantiate<Dice>(prefab, group);
      dice.gameObject.SetActive(true);
      this.dice.Add(dice);
    }
  }

  public static int ThrowDice(Transform group)
  {
    int num1 = 0;
    float num2 = 0.5f;
    Dice[] componentsInChildren = group.GetComponentsInChildren<Dice>();
    for (int index = 0; index < componentsInChildren.Length; ++index)
    {
      Dice dice = componentsInChildren[index];
      dice.transform.localPosition = new Vector3(num2 * (float) index, 0.0f);
      dice.Throw(new Vector2(Dead.Random.Range(-1f, 1f), 1f).normalized);
      num1 += dice.value;
    }
    return num1;
  }

  public IEnumerator AttackAndKillAll(Character attackingTeam, Character defendingTeam)
  {
    List<Entity> attackers = ((IEnumerable<Entity>) this.entities.Where<Entity>((Func<Entity, bool>) (a => this.legalCardTypes.Contains<CardType>(a.data.cardType))).ToArray<Entity>()).Where<Entity>((Func<Entity, bool>) (a => (UnityEngine.Object) a.owner == (UnityEngine.Object) attackingTeam)).ToList<Entity>();
    List<Entity> defenders = this.entities.Where<Entity>((Func<Entity, bool>) (a => (UnityEngine.Object) a.owner == (UnityEngine.Object) defendingTeam)).ToList<Entity>();
    while (defenders.Count > 0)
    {
      Entity entity = attackers.RandomItem<Entity>();
      Entity target = defenders.RandomItem<Entity>();
      defenders.Remove(target);
      Hit hit = new Hit(entity, target, 99)
      {
        canRetaliate = false,
        canBeNullified = false
      };
      hit.AddStatusEffect(this.killEffect, 1);
      yield return (object) new Trigger(entity, entity, "laststand", new Entity[1]
      {
        target
      })
      {
        countsAsTrigger = false,
        hits = new Hit[1]{ hit }
      }.Process();
      yield return (object) new WaitForSeconds(Dead.Random.Range(0.0f, 0.1f));
    }
    yield return (object) new WaitForSeconds(1f);
  }

  public IEnumerator AttackOnce(Character attackingTeam)
  {
    List<Entity> list = ((IEnumerable<Entity>) this.entities.Where<Entity>((Func<Entity, bool>) (a => this.legalCardTypes.Contains<CardType>(a.data.cardType))).ToArray<Entity>()).Where<Entity>((Func<Entity, bool>) (a => (UnityEngine.Object) a.owner == (UnityEngine.Object) attackingTeam)).ToList<Entity>();
    list.Shuffle<Entity>();
    foreach (Entity entity in list)
    {
      Entity attacker = entity;
      if (attacker.data.hasAttack)
      {
        Entity[] targets = (UnityEngine.Object) attacker.targetMode != (UnityEngine.Object) null ? attacker.targetMode.GetTargets(attacker, (Entity) null, (CardContainer) null) : (Entity[]) null;
        if (targets != null && targets.Length != 0)
        {
          Hit[] array = ((IEnumerable<Entity>) targets).Select<Entity, Hit>((Func<Entity, Hit>) (a => new Hit(attacker, a)
          {
            canRetaliate = false,
            canBeNullified = false
          })).ToArray<Hit>();
          yield return (object) new Trigger(attacker, attacker, "laststand", targets)
          {
            countsAsTrigger = false,
            hits = array
          }.Process();
          yield return (object) new WaitForSeconds(Dead.Random.Range(0.1f, 0.1f));
        }
      }
    }
    yield return (object) new WaitForSeconds(1f);
  }

  public IEnumerator AttackAndKill(Character attackingTeam, Entity target)
  {
    target.alive = false;
    List<Entity> attackers = ((IEnumerable<Entity>) this.entities.Where<Entity>((Func<Entity, bool>) (a => this.legalCardTypes.Contains<CardType>(a.data.cardType))).ToArray<Entity>()).Where<Entity>((Func<Entity, bool>) (a => (UnityEngine.Object) a.owner == (UnityEngine.Object) attackingTeam)).ToList<Entity>();
    attackers.Shuffle<Entity>();
    int attackersCount = attackers.Count;
    for (int i = 0; i < attackersCount; ++i)
    {
      int num = i == attackersCount - 1 ? 1 : 0;
      Entity attacker = attackers[i];
      Hit hit = new Hit(attacker, target, 0)
      {
        canRetaliate = false,
        canBeNullified = false,
        extraOffensiveness = 5
      };
      hit.FlagAsOffensive();
      if (num != 0)
      {
        target.alive = true;
        hit.AddStatusEffect(this.killEffect, 1);
        hit.extraOffensiveness = 10;
        yield return (object) new WaitForSeconds(0.25f);
      }
      yield return (object) new Trigger(attacker, attacker, "laststand", new Entity[1]
      {
        target
      })
      {
        countsAsTrigger = false,
        hits = new Hit[1]{ hit }
      }.Process();
      yield return (object) new WaitForSeconds(Dead.Random.Range(0.0f, 0.01f));
      attacker = (Entity) null;
      hit = (Hit) null;
    }
    yield return (object) new WaitForSeconds(1f);
  }

  [CompilerGenerated]
  public bool \u003CProcess\u003Eb__29_0() => this.diceRolled;

  [CompilerGenerated]
  public bool \u003CRollSequence\u003Eb__31_0(Entity a) => this.legalCardTypes.Contains<CardType>(a.data.cardType);
}
﻿// Decompiled with JetBrains decompiler
// Type: LayoutFixer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;
using UnityEngine.UI;

public class LayoutFixer : MonoBehaviourRect
{
  [SerializeField]
  public bool unlimitedDepth = true;
  [SerializeField]
  [HideIf("unlimitedDepth")]
  public int depth;
  public LayoutFixer.Prompt prompt;

  public void Update()
  {
    if (this.prompt == LayoutFixer.Prompt.None)
      return;
    switch (this.prompt)
    {
      case LayoutFixer.Prompt.All:
        this.DoAll();
        break;
      case LayoutFixer.Prompt.Horizontal:
        this.DoHorizontal();
        break;
      case LayoutFixer.Prompt.Vertical:
        this.DoVertical();
        break;
    }
    this.prompt = LayoutFixer.Prompt.None;
  }

  public void Fix() => this.prompt = LayoutFixer.Prompt.All;

  public void FixHorizontal() => this.prompt = LayoutFixer.Prompt.Horizontal;

  public void FixVertical() => this.prompt = LayoutFixer.Prompt.Vertical;

  public void DoAll()
  {
    if (this.unlimitedDepth)
      this.rectTransform.FixLayoutGroups();
    else
      this.rectTransform.FixLayoutGroups(this.depth);
  }

  public void DoHorizontal()
  {
    this.StopAllCoroutines();
    this.StartCoroutine(this.FixHorizontalRoutine());
  }

  public void DoVertical()
  {
    this.StopAllCoroutines();
    this.StartCoroutine(this.FixVerticalRoutine());
  }

  public IEnumerator FixHorizontalRoutine()
  {
    LayoutFixer layoutFixer = this;
    if (layoutFixer.depth <= 0 && !layoutFixer.unlimitedDepth)
    {
      ContentSizeFitter fitter = layoutFixer.GetComponent<ContentSizeFitter>();
      if ((Object) fitter != (Object) null)
      {
        ContentSizeFitter.FitMode pre = fitter.horizontalFit;
        fitter.horizontalFit = ContentSizeFitter.FitMode.Unconstrained;
        yield return (object) null;
        fitter.horizontalFit = pre;
      }
      fitter = (ContentSizeFitter) null;
    }
    else
    {
      layoutFixer.rectTransform.DisableContentFitters();
      yield return (object) null;
      layoutFixer.rectTransform.EnableContentFitters();
    }
  }

  public IEnumerator FixVerticalRoutine()
  {
    LayoutFixer layoutFixer = this;
    if (layoutFixer.depth <= 0 && !layoutFixer.unlimitedDepth)
    {
      ContentSizeFitter fitter = layoutFixer.GetComponent<ContentSizeFitter>();
      if ((Object) fitter != (Object) null)
      {
        ContentSizeFitter.FitMode pre = fitter.verticalFit;
        fitter.verticalFit = ContentSizeFitter.FitMode.Unconstrained;
        yield return (object) null;
        fitter.verticalFit = pre;
      }
      fitter = (ContentSizeFitter) null;
    }
    else
    {
      layoutFixer.rectTransform.DisableContentFitters();
      yield return (object) null;
      layoutFixer.rectTransform.EnableContentFitters();
    }
  }

  public enum Prompt
  {
    None,
    All,
    Horizontal,
    Vertical,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LayoutLink
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

[ExecuteInEditMode]
public class LayoutLink : MonoBehaviourRect
{
  [FormerlySerializedAs("layoutTransform")]
  public RectTransform link;
  public float lerp = 0.1f;
  public bool setPositionOnEnable = true;
  public Vector3 offset;
  [Header("Link to layout element to update layout element size")]
  public LayoutElement layoutElement;
  [ShowIf("HasLayoutElement")]
  public bool setLayoutWidth;
  [ShowIf("HasLayoutElement")]
  public bool setLayoutHeight;

  public bool HasLayoutElement => (Object) this.layoutElement != (Object) null;

  public void OnEnable()
  {
    if (!this.setPositionOnEnable || !((Object) this.link != (Object) null))
      return;
    this.rectTransform.position = this.link.position + this.offset;
  }

  public void LateUpdate() => this.rectTransform.position = Delta.Lerp(this.rectTransform.position, this.link.position + this.offset, this.lerp, Time.deltaTime);

  public void Update()
  {
    if (!this.HasLayoutElement)
      return;
    Vector2 sizeDelta = this.rectTransform.sizeDelta;
    if (this.setLayoutWidth)
      this.layoutElement.preferredWidth = sizeDelta.x;
    if (!this.setLayoutHeight)
      return;
    this.layoutElement.preferredHeight = sizeDelta.y;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Leader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class Leader : ScriptableCardImage
{
  [SerializeField]
  public CharacterAvatar avatar;

  public override void AssignEvent() => this.avatar.UpdateDisplay(this.entity.data.customData.Get<CharacterData>("CharacterData"));
}
﻿// Decompiled with JetBrains decompiler
// Type: LeaderboardsEntry
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class LeaderboardsEntry : MonoBehaviour
{
  [SerializeField]
  public Color playerBgColor;
  [SerializeField]
  public Graphic background;
  [SerializeField]
  public TMP_Text nameText;
  [SerializeField]
  public TMP_Text rankText;
  [SerializeField]
  public TMP_Text scoreText;
  [SerializeField]
  public TMP_Text timeText;

  public void Set(bool isPlayer, string name, int rank, object score, string timeString)
  {
    if (isPlayer)
      this.background.color = this.playerBgColor;
    this.nameText.text = name;
    this.rankText.text = string.Format("#{0}", (object) rank);
    this.scoreText.text = score.ToString();
    this.timeText.text = timeString;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeaderboardsFetcher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Steamworks.Data;
using System;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using UnityEngine;

public class LeaderboardsFetcher : MonoBehaviour
{
  [SerializeField]
  public Scores.Type boardType = Scores.Type.Daily;
  [CompilerGenerated]
  public LeaderboardsFetcher.Result \u003Cresult\u003Ek__BackingField;
  public bool playerRankFetched;
  [CompilerGenerated]
  public bool \u003CplayerHasRank\u003Ek__BackingField;
  [CompilerGenerated]
  public uint \u003CplayerRank\u003Ek__BackingField;
  [CompilerGenerated]
  public uint \u003CtotalScores\u003Ek__BackingField;
  public uint fetchCount;
  public Leaderboard? leaderboard;
  [CompilerGenerated]
  public LeaderboardEntry[] \u003Cinfo\u003Ek__BackingField;
  public int fetchBoardTaskId;
  public int fetchScoresTaskId;
  public int fetchPlayerRankTaskId;
  public int dayOffset = -1;

  public LeaderboardsFetcher.Result result
  {
    get => this.\u003Cresult\u003Ek__BackingField;
    set => this.\u003Cresult\u003Ek__BackingField = value;
  }

  public bool playerHasRank
  {
    get => this.\u003CplayerHasRank\u003Ek__BackingField;
    set => this.\u003CplayerHasRank\u003Ek__BackingField = value;
  }

  public uint playerRank
  {
    get => this.\u003CplayerRank\u003Ek__BackingField;
    set => this.\u003CplayerRank\u003Ek__BackingField = value;
  }

  public uint totalScores
  {
    get => this.\u003CtotalScores\u003Ek__BackingField;
    set => this.\u003CtotalScores\u003Ek__BackingField = value;
  }

  public void ResetPlayerRank()
  {
    this.playerRankFetched = false;
    this.playerHasRank = false;
    this.playerRank = 0U;
  }

  public LeaderboardEntry[] info
  {
    get => this.\u003Cinfo\u003Ek__BackingField;
    set => this.\u003Cinfo\u003Ek__BackingField = value;
  }

  public async Task Fetch(
    LeaderboardsFetcher.Type type,
    int dayOffset,
    int entriesPerPage,
    int page = -1)
  {
    DateTime date = DailyFetcher.GetDateTime().AddDays((double) -dayOffset);
    if (this.dayOffset != dayOffset || !this.leaderboard.HasValue)
    {
      this.dayOffset = dayOffset;
      Task<Leaderboard?> fetchBoardTask = Scores.GetLeaderboard(this.boardType, date);
      this.fetchBoardTaskId = fetchBoardTask.Id;
      Leaderboard? nullable = await fetchBoardTask;
      if (this.fetchBoardTaskId == fetchBoardTask.Id)
        this.leaderboard = fetchBoardTask.Result;
      fetchBoardTask = (Task<Leaderboard?>) null;
    }
    if (!this.leaderboard.HasValue)
      return;
    this.totalScores = (uint) this.leaderboard.Value.EntryCount;
    if (!this.playerRankFetched)
      await this.FetchPlayerRankIfNecessary(this.leaderboard.Value);
    if (page < 0)
      page = this.playerHasRank ? Mathf.FloorToInt((float) (this.playerRank - 1U) / (float) entriesPerPage) : 0;
    Task<LeaderboardEntry[]> fetchGlobalScoresTask;
    Task<LeaderboardEntry[]> fetchFriendsScoresTask;
    switch (type)
    {
      case LeaderboardsFetcher.Type.Global:
        fetchGlobalScoresTask = Scores.GetGlobal(this.leaderboard.Value, entriesPerPage, 1 + page * entriesPerPage);
        this.fetchScoresTaskId = fetchGlobalScoresTask.Id;
        LeaderboardEntry[] leaderboardEntryArray1 = await fetchGlobalScoresTask;
        if (this.fetchScoresTaskId == fetchGlobalScoresTask.Id)
        {
          this.info = fetchGlobalScoresTask.Result;
          break;
        }
        break;
      case LeaderboardsFetcher.Type.Friends:
        fetchFriendsScoresTask = Scores.GetFriends(this.leaderboard.Value, entriesPerPage);
        this.fetchScoresTaskId = fetchFriendsScoresTask.Id;
        LeaderboardEntry[] leaderboardEntryArray2 = await fetchFriendsScoresTask;
        if (this.fetchScoresTaskId == fetchFriendsScoresTask.Id)
        {
          this.info = fetchFriendsScoresTask.Result;
          break;
        }
        break;
    }
    fetchGlobalScoresTask = (Task<LeaderboardEntry[]>) null;
    fetchFriendsScoresTask = (Task<LeaderboardEntry[]>) null;
  }

  public async Task FetchPlayerRankIfNecessary(Leaderboard board)
  {
    Task<LeaderboardEntry[]> fetchPlayerRankTask = Scores.GetAround(board, 0);
    this.fetchPlayerRankTaskId = fetchPlayerRankTask.Id;
    LeaderboardEntry[] leaderboardEntryArray = await fetchPlayerRankTask;
    if (fetchPlayerRankTask.Id != this.fetchPlayerRankTaskId)
    {
      fetchPlayerRankTask = (Task<LeaderboardEntry[]>) null;
    }
    else
    {
      LeaderboardEntry[] result = fetchPlayerRankTask.Result;
      if (result != null && result.Length > 0)
      {
        this.playerHasRank = true;
        this.playerRank = (uint) result[0].GlobalRank;
      }
      this.playerRankFetched = true;
      fetchPlayerRankTask = (Task<LeaderboardEntry[]>) null;
    }
  }

  public enum Type
  {
    Global,
    Friends,
    Around,
  }

  public enum Result
  {
    Success,
    NoConnection,
    TooManyRequests,
    Cancel,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeaderboardsPanel
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Steamworks;
using Steamworks.Data;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LeaderboardsPanel : MonoBehaviour
{
  [SerializeField]
  public GameObject loading;
  [SerializeField]
  public GameObject noEntries;
  [SerializeField]
  public GameObject noConnection;
  [SerializeField]
  public GameObject tooManyRequests;
  [SerializeField]
  public Transform entriesGroup;
  [SerializeField]
  public DateTextSetter dateTextSetter;
  [SerializeField]
  public LeaderboardsFetcher fetcher;
  [SerializeField]
  public LeaderboardsEntry entryPrefab;
  [SerializeField]
  public bool fetchEveryTime = true;
  [SerializeField]
  public int entriesPerPage = 10;
  [SerializeField]
  public LeaderboardsFetcher.Type type;
  [Header("Buttons")]
  [SerializeField]
  public ButtonAnimator globalButton;
  [SerializeField]
  public ButtonAnimator friendsButton;
  [SerializeField]
  public ButtonAnimator playerRankButton;
  [SerializeField]
  public ButtonAnimator nextPageButton;
  [SerializeField]
  public ButtonAnimator prePageButton;
  [SerializeField]
  public ButtonAnimator nextDayButton;
  [SerializeField]
  public ButtonAnimator preDayButton;
  public int page;
  public int dayOffset;
  public int playerRankPage;
  public const int maxDayOffset = 100;
  public int maxPage = 9999;
  public bool fetched;

  public bool fetch => !this.fetched || this.fetchEveryTime;

  public void OnEnable()
  {
    this.page = 0;
    this.dayOffset = 0;
    this.nextDayButton.interactable = false;
    if (!this.fetch)
      return;
    this.Clear();
    this.StartCoroutine(this.Fetch(true));
  }

  public void OnDisable() => this.StopAllCoroutines();

  public void Clear()
  {
    this.noEntries.SetActive(false);
    this.noConnection.SetActive(false);
    this.tooManyRequests.SetActive(false);
    this.entriesGroup.DestroyAllChildren();
    this.prePageButton.interactable = false;
    this.nextPageButton.interactable = false;
  }

  public IEnumerator Fetch(bool aroundPlayer)
  {
    yield break;
  }

  public void Populate(IReadOnlyCollection<LeaderboardEntry> entries)
  {
    bool flag = entries != null && entries.Count > 0;
    this.noEntries.SetActive(!flag);
    if (!flag)
      return;
    foreach (LeaderboardEntry entry in (IEnumerable<LeaderboardEntry>) entries)
    {
      LeaderboardsEntry leaderboardsEntry = UnityEngine.Object.Instantiate<LeaderboardsEntry>(this.entryPrefab, this.entriesGroup);
      Friend user = entry.User;
      int num = user.IsMe ? 1 : 0;
      user = entry.User;
      string name = user.Name;
      int globalRank = entry.GlobalRank;
      // ISSUE: variable of a boxed type
      __Boxed<int> score = (ValueType) entry.Score;
      string timeString = LeaderboardsPanel.SecondsToTimeString(entry.Details[0]);
      leaderboardsEntry.Set(num != 0, name, globalRank, (object) score, timeString);
    }
  }

  public void PreviousDay()
  {
    if (this.dayOffset >= 100)
      return;
    this.SetDayOffset(this.dayOffset + 1);
    this.Refetch(true);
  }

  public void NextDay()
  {
    if (this.dayOffset <= 0)
      return;
    this.SetDayOffset(this.dayOffset - 1);
    this.Refetch(true);
  }

  public void SetDayOffset(int value)
  {
    this.dayOffset = value;
    this.dateTextSetter.SetText(-this.dayOffset);
    this.fetcher.ResetPlayerRank();
    this.maxPage = 0;
    this.type = LeaderboardsFetcher.Type.Global;
    this.SetPage(0);
    this.playerRankButton.interactable = false;
    this.preDayButton.interactable = this.dayOffset < 100;
    this.nextDayButton.interactable = this.dayOffset > 0;
  }

  public void NextPage()
  {
    if (this.page >= this.maxPage)
      return;
    this.SetPage(this.page + 1);
    this.Refetch(false);
  }

  public void PreviousPage()
  {
    if (this.page <= 0)
      return;
    this.SetPage(this.page - 1);
    this.Refetch(false);
  }

  public void SetPage(int value)
  {
    this.page = value;
    this.nextPageButton.interactable = this.page < this.maxPage;
    this.prePageButton.interactable = this.page > 0;
  }

  public void Global()
  {
    if (this.type == LeaderboardsFetcher.Type.Global && this.page <= 0)
      return;
    this.type = LeaderboardsFetcher.Type.Global;
    this.SetPage(0);
    this.Refetch(false);
  }

  public void Friends()
  {
    if (this.type == LeaderboardsFetcher.Type.Friends)
      return;
    this.type = LeaderboardsFetcher.Type.Friends;
    this.SetPage(0);
    this.Refetch(false);
  }

  public void JumpToPlayer()
  {
    if (!this.fetcher.playerHasRank || this.page == this.playerRankPage)
      return;
    this.type = LeaderboardsFetcher.Type.Global;
    this.SetPage(this.playerRankPage);
    this.Refetch(false);
  }

  public void Refetch(bool aroundPlayer)
  {
    this.Clear();
    this.StopAllCoroutines();
    this.StartCoroutine(this.Fetch(aroundPlayer));
  }

  public static string SecondsToTimeString(int seconds)
  {
    double f = (double) seconds / 60.0 / 60.0;
    int num1 = Mathf.FloorToInt((float) f);
    int num2 = Mathf.FloorToInt((float) ((f - (double) num1) * 60.0));
    return num1 <= 0 ? string.Format("{0}m", (object) num2) : string.Format("{0}h {1}m", (object) num1, (object) num2);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeaderNameHistoryDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using NaughtyAttributes;
using System.Collections.Generic;
using UnityEngine;

public class LeaderNameHistoryDisplay : MonoBehaviour
{
  [SerializeField]
  public LeaderNameHistoryEntry namePrefab;

  public void OnEnable() => this.Populate();

  public void OnDisable() => this.transform.DestroyAllChildren();

  public void Populate()
  {
    List<JournalNameHistory.Name> nameList = SaveSystem.LoadProgressData<List<JournalNameHistory.Name>>("leaderNameHistory");
    if (nameList == null)
      return;
    Transform transform = this.transform;
    foreach (JournalNameHistory.Name name in nameList)
    {
      LeaderNameHistoryEntry nameHistoryEntry = Object.Instantiate<LeaderNameHistoryEntry>(this.namePrefab, transform);
      nameHistoryEntry.transform.localPosition = (Vector3) name.position;
      nameHistoryEntry.Assign(name);
    }
  }

  [Button(null, EButtonEnableMode.Always)]
  public void AddName()
  {
    if ((double) PettyRandom.Range(0.0f, 1f) > 0.25)
      JournalNameHistory.MostRecentNameKilled();
    else
      JournalNameHistory.MostRecentNameMissing();
    JournalNameHistory.FadePrevious();
    JournalNameHistory.AddName(Names.Pull("SnowdwellerMale"));
    this.Repopulate();
  }

  public void Repopulate()
  {
    this.transform.DestroyAllChildren();
    this.Populate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeaderNameHistoryEntry
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class LeaderNameHistoryEntry : MonoBehaviour
{
  [SerializeField]
  public Transform offset;
  [SerializeField]
  public TMP_Text textElement;
  [SerializeField]
  public AnimationCurve scaleCurve;
  [SerializeField]
  public Gradient colour;
  [SerializeField]
  public Gradient missingColour;

  public void Assign(JournalNameHistory.Name name)
  {
    this.offset.localPosition = (Vector3) name.offset;
    this.offset.localEulerAngles = Vector2.zero.WithZ(name.angle);
    this.offset.localScale = Vector3.one * this.scaleCurve.Evaluate(name.opacity);
    this.textElement.text = name.text;
    if (name.killed)
      this.textElement.fontStyle = FontStyles.Strikethrough;
    if (name.missing)
    {
      this.textElement.text += " ?";
      this.textElement.color = this.missingColour.Evaluate(name.opacity);
    }
    else
      this.textElement.color = this.colour.Evaluate(name.opacity);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeaderProfileData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(fileName = "New Leader Profile", menuName = "Leader Profile")]
public class LeaderProfileData : ScriptableObject
{
  [SerializeField]
  public SpriteCollection backgroundPool;
  [SerializeField]
  public LeaderProfileData.Collection[] collectionsToAdd;

  public Sprite GetRandomBackground() => this.backgroundPool.RandomItem();

  public void Apply(CharacterType type)
  {
    foreach (LeaderProfileData.Collection collection in this.collectionsToAdd)
      collection.AddTo(type);
  }

  public void UnApply(CharacterType type)
  {
    foreach (LeaderProfileData.Collection collection in this.collectionsToAdd)
      collection.AddTo(type, -1f);
  }

  [Serializable]
  public class Collection
  {
    public string collectionName;
    public LeaderProfileData.Collection.Type type;
    public CollectionModifier modifier;

    public void AddTo(CharacterType characterType, float multiply = 1f)
    {
      switch (this.type)
      {
        case LeaderProfileData.Collection.Type.Prefab:
          PrefabCollection collection1 = ((IEnumerable<CharacterType.PrefabGroup>) characterType.prefabs).First<CharacterType.PrefabGroup>((Func<CharacterType.PrefabGroup, bool>) (a => a.name == this.collectionName)).collection;
          foreach (CollectionModifier.Modify modify in this.modifier.list)
            collection1.AddWeight(modify.index, modify.addWeight * multiply);
          break;
        case LeaderProfileData.Collection.Type.Sprite:
          SpriteCollection collection2 = ((IEnumerable<CharacterType.SpriteGroup>) characterType.sprites).First<CharacterType.SpriteGroup>((Func<CharacterType.SpriteGroup, bool>) (a => a.name == this.collectionName)).collection;
          foreach (CollectionModifier.Modify modify in this.modifier.list)
            collection2.AddWeight(modify.index, modify.addWeight * multiply);
          break;
        case LeaderProfileData.Collection.Type.ColorSet:
          ColorSetCollection collection3 = ((IEnumerable<CharacterType.ColorSetGroup>) characterType.colorSets).First<CharacterType.ColorSetGroup>((Func<CharacterType.ColorSetGroup, bool>) (a => a.name == this.collectionName)).collection;
          foreach (CollectionModifier.Modify modify in this.modifier.list)
            collection3.AddWeight(modify.index, modify.addWeight * multiply);
          break;
      }
    }

    [CompilerGenerated]
    public bool \u003CAddTo\u003Eb__4_0(CharacterType.PrefabGroup a) => a.name == this.collectionName;

    [CompilerGenerated]
    public bool \u003CAddTo\u003Eb__4_1(CharacterType.SpriteGroup a) => a.name == this.collectionName;

    [CompilerGenerated]
    public bool \u003CAddTo\u003Eb__4_2(CharacterType.ColorSetGroup a) => a.name == this.collectionName;

    public enum Type
    {
      Prefab,
      Sprite,
      ColorSet,
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeanAudio
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LeanAudio
{
  public static float MIN_FREQEUNCY_PERIOD = 0.000115f;
  public static int PROCESSING_ITERATIONS_MAX = 50000;
  public static float[] generatedWaveDistances;
  public static int generatedWaveDistancesCount = 0;
  public static float[] longList;

  public static LeanAudioOptions options()
  {
    if (LeanAudio.generatedWaveDistances == null)
    {
      LeanAudio.generatedWaveDistances = new float[LeanAudio.PROCESSING_ITERATIONS_MAX];
      LeanAudio.longList = new float[LeanAudio.PROCESSING_ITERATIONS_MAX];
    }
    return new LeanAudioOptions();
  }

  public static LeanAudioStream createAudioStream(
    AnimationCurve volume,
    AnimationCurve frequency,
    LeanAudioOptions options = null)
  {
    if (options == null)
      options = new LeanAudioOptions();
    options.useSetData = false;
    LeanAudio.createAudioFromWave(LeanAudio.createAudioWave(volume, frequency, options), options);
    return options.stream;
  }

  public static AudioClip createAudio(
    AnimationCurve volume,
    AnimationCurve frequency,
    LeanAudioOptions options = null)
  {
    if (options == null)
      options = new LeanAudioOptions();
    return LeanAudio.createAudioFromWave(LeanAudio.createAudioWave(volume, frequency, options), options);
  }

  public static int createAudioWave(
    AnimationCurve volume,
    AnimationCurve frequency,
    LeanAudioOptions options)
  {
    float time1 = volume[volume.length - 1].time;
    int index1 = 0;
    float time2 = 0.0f;
    for (int index2 = 0; index2 < LeanAudio.PROCESSING_ITERATIONS_MAX; ++index2)
    {
      float minFreqeuncyPeriod = frequency.Evaluate(time2);
      if ((double) minFreqeuncyPeriod < (double) LeanAudio.MIN_FREQEUNCY_PERIOD)
        minFreqeuncyPeriod = LeanAudio.MIN_FREQEUNCY_PERIOD;
      float num1 = volume.Evaluate(time2 + 0.5f * minFreqeuncyPeriod);
      if (options.vibrato != null)
      {
        for (int index3 = 0; index3 < options.vibrato.Length; ++index3)
        {
          float num2 = Mathf.Abs(Mathf.Sin((float) (1.5707999467849731 + (double) time2 * (1.0 / (double) options.vibrato[index3][0]) * 3.1415927410125732)));
          float num3 = 1f - options.vibrato[index3][1];
          float num4 = options.vibrato[index3][1] + num3 * num2;
          num1 *= num4;
        }
      }
      if ((double) time2 + 0.5 * (double) minFreqeuncyPeriod < (double) time1)
      {
        if (index1 >= LeanAudio.PROCESSING_ITERATIONS_MAX - 1)
        {
          Debug.LogError((object) ("LeanAudio has reached it's processing cap. To avoid this error increase the number of iterations ex: LeanAudio.PROCESSING_ITERATIONS_MAX = " + (LeanAudio.PROCESSING_ITERATIONS_MAX * 2).ToString()));
          break;
        }
        int index4 = index1 / 2;
        time2 += minFreqeuncyPeriod;
        LeanAudio.generatedWaveDistances[index4] = time2;
        LeanAudio.longList[index1] = time2;
        LeanAudio.longList[index1 + 1] = index2 % 2 == 0 ? -num1 : num1;
        index1 += 2;
      }
      else
        break;
    }
    int audioWave = index1 - 2;
    LeanAudio.generatedWaveDistancesCount = audioWave / 2;
    return audioWave;
  }

  public static AudioClip createAudioFromWave(int waveLength, LeanAudioOptions options)
  {
    float num1 = LeanAudio.longList[waveLength - 2];
    float[] numArray = new float[(int) ((double) options.frequencyRate * (double) num1)];
    int index1 = 0;
    float num2 = LeanAudio.longList[index1];
    float num3 = 0.0f;
    double num4 = (double) LeanAudio.longList[index1];
    float num5 = LeanAudio.longList[index1 + 1];
    for (int index2 = 0; index2 < numArray.Length; ++index2)
    {
      float num6 = (float) index2 / (float) options.frequencyRate;
      if ((double) num6 > (double) LeanAudio.longList[index1])
      {
        num3 = LeanAudio.longList[index1];
        index1 += 2;
        num2 = LeanAudio.longList[index1] - LeanAudio.longList[index1 - 2];
        num5 = LeanAudio.longList[index1 + 1];
      }
      float num7 = (num6 - num3) / num2;
      float num8 = Mathf.Sin(num7 * 3.14159274f);
      if (options.waveStyle == LeanAudioOptions.LeanAudioWaveStyle.Square)
      {
        if ((double) num8 > 0.0)
          num8 = 1f;
        if ((double) num8 < 0.0)
          num8 = -1f;
      }
      else if (options.waveStyle == LeanAudioOptions.LeanAudioWaveStyle.Sawtooth)
      {
        float num9 = (double) num8 > 0.0 ? 1f : -1f;
        num8 = (double) num7 >= 0.5 ? (float) ((1.0 - (double) num7) * 2.0) * num9 : num7 * 2f * num9;
      }
      else if (options.waveStyle == LeanAudioOptions.LeanAudioWaveStyle.Noise)
      {
        float num10 = (float) (1.0 - (double) options.waveNoiseInfluence + (double) Mathf.PerlinNoise(0.0f, num6 * options.waveNoiseScale) * (double) options.waveNoiseInfluence);
        num8 *= num10;
      }
      float num11 = num8 * num5;
      if (options.modulation != null)
      {
        for (int index3 = 0; index3 < options.modulation.Length; ++index3)
        {
          float num12 = Mathf.Abs(Mathf.Sin((float) (1.5707999467849731 + (double) num6 * (1.0 / (double) options.modulation[index3][0]) * 3.1415927410125732)));
          float num13 = 1f - options.modulation[index3][1];
          float num14 = options.modulation[index3][1] + num13 * num12;
          num11 *= num14;
        }
      }
      numArray[index2] = num11;
    }
    int length = numArray.Length;
    AudioClip audioFromWave;
    if (options.useSetData)
    {
      audioFromWave = AudioClip.Create("Generated Audio", length, 1, options.frequencyRate, false, (AudioClip.PCMReaderCallback) null, new AudioClip.PCMSetPositionCallback(LeanAudio.OnAudioSetPosition));
      audioFromWave.SetData(numArray, 0);
    }
    else
    {
      options.stream = new LeanAudioStream(numArray);
      audioFromWave = AudioClip.Create("Generated Audio", length, 1, options.frequencyRate, false, new AudioClip.PCMReaderCallback(options.stream.OnAudioRead), new AudioClip.PCMSetPositionCallback(options.stream.OnAudioSetPosition));
      options.stream.audioClip = audioFromWave;
    }
    return audioFromWave;
  }

  public static void OnAudioSetPosition(int newPosition)
  {
  }

  public static AudioClip generateAudioFromCurve(AnimationCurve curve, int frequencyRate = 44100)
  {
    float time1 = curve[curve.length - 1].time;
    float[] data = new float[(int) ((double) frequencyRate * (double) time1)];
    for (int index = 0; index < data.Length; ++index)
    {
      float time2 = (float) index / (float) frequencyRate;
      data[index] = curve.Evaluate(time2);
    }
    AudioClip audioFromCurve = AudioClip.Create("Generated Audio", data.Length, 1, frequencyRate, false);
    audioFromCurve.SetData(data, 0);
    return audioFromCurve;
  }

  public static AudioSource play(AudioClip audio, float volume)
  {
    AudioSource audioSource = LeanAudio.playClipAt(audio, Vector3.zero);
    audioSource.volume = volume;
    return audioSource;
  }

  public static AudioSource play(AudioClip audio) => LeanAudio.playClipAt(audio, Vector3.zero);

  public static AudioSource play(AudioClip audio, Vector3 pos) => LeanAudio.playClipAt(audio, pos);

  public static AudioSource play(AudioClip audio, Vector3 pos, float volume)
  {
    AudioSource audioSource = LeanAudio.playClipAt(audio, pos);
    audioSource.minDistance = 1f;
    audioSource.volume = volume;
    return audioSource;
  }

  public static AudioSource playClipAt(AudioClip clip, Vector3 pos)
  {
    GameObject gameObject = new GameObject();
    gameObject.transform.position = pos;
    AudioSource audioSource = gameObject.AddComponent<AudioSource>();
    audioSource.clip = clip;
    audioSource.Play();
    Object.Destroy((Object) gameObject, clip.length);
    return audioSource;
  }

  public static void printOutAudioClip(AudioClip audioClip, ref AnimationCurve curve, float scaleX = 1f)
  {
    float[] data = new float[audioClip.samples * audioClip.channels];
    audioClip.GetData(data, 0);
    int index = 0;
    Keyframe[] keyframeArray = new Keyframe[data.Length];
    for (; index < data.Length; ++index)
      keyframeArray[index] = new Keyframe((float) index * scaleX, data[index]);
    curve = new AnimationCurve(keyframeArray);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeanAudioOptions
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LeanAudioOptions
{
  public LeanAudioOptions.LeanAudioWaveStyle waveStyle;
  public Vector3[] vibrato;
  public Vector3[] modulation;
  public int frequencyRate = 44100;
  public float waveNoiseScale = 1000f;
  public float waveNoiseInfluence = 1f;
  public bool useSetData = true;
  public LeanAudioStream stream;

  public LeanAudioOptions setFrequency(int frequencyRate)
  {
    this.frequencyRate = frequencyRate;
    return this;
  }

  public LeanAudioOptions setVibrato(Vector3[] vibrato)
  {
    this.vibrato = vibrato;
    return this;
  }

  public LeanAudioOptions setWaveSine()
  {
    this.waveStyle = LeanAudioOptions.LeanAudioWaveStyle.Sine;
    return this;
  }

  public LeanAudioOptions setWaveSquare()
  {
    this.waveStyle = LeanAudioOptions.LeanAudioWaveStyle.Square;
    return this;
  }

  public LeanAudioOptions setWaveSawtooth()
  {
    this.waveStyle = LeanAudioOptions.LeanAudioWaveStyle.Sawtooth;
    return this;
  }

  public LeanAudioOptions setWaveNoise()
  {
    this.waveStyle = LeanAudioOptions.LeanAudioWaveStyle.Noise;
    return this;
  }

  public LeanAudioOptions setWaveStyle(LeanAudioOptions.LeanAudioWaveStyle style)
  {
    this.waveStyle = style;
    return this;
  }

  public LeanAudioOptions setWaveNoiseScale(float waveScale)
  {
    this.waveNoiseScale = waveScale;
    return this;
  }

  public LeanAudioOptions setWaveNoiseInfluence(float influence)
  {
    this.waveNoiseInfluence = influence;
    return this;
  }

  public enum LeanAudioWaveStyle
  {
    Sine,
    Square,
    Sawtooth,
    Noise,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeanAudioStream
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LeanAudioStream
{
  public int position;
  public AudioClip audioClip;
  public float[] audioArr;

  public LeanAudioStream(float[] audioArr) => this.audioArr = audioArr;

  public void OnAudioRead(float[] data)
  {
    for (int index = 0; index < data.Length; ++index)
    {
      data[index] = this.audioArr[this.position];
      ++this.position;
    }
  }

  public void OnAudioSetPosition(int newPosition) => this.position = newPosition;
}
﻿// Decompiled with JetBrains decompiler
// Type: LeanProp
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public enum LeanProp
{
  position,
  localPosition,
  x,
  y,
  z,
  localX,
  localY,
  localZ,
  scale,
  color,
}
﻿// Decompiled with JetBrains decompiler
// Type: LeanSmooth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LeanSmooth
{
  public static float damp(
    float current,
    float target,
    ref float currentVelocity,
    float smoothTime,
    float maxSpeed = -1f,
    float deltaTime = -1f)
  {
    if ((double) deltaTime < 0.0)
      deltaTime = Time.deltaTime;
    smoothTime = Mathf.Max(0.0001f, smoothTime);
    float num1 = 2f / smoothTime;
    float num2 = num1 * deltaTime;
    float num3 = (float) (1.0 / (1.0 + (double) num2 + 0.47999998927116394 * (double) num2 * (double) num2 + 0.23499999940395355 * (double) num2 * (double) num2 * (double) num2));
    float num4 = current - target;
    float num5 = target;
    if ((double) maxSpeed > 0.0)
    {
      float max = maxSpeed * smoothTime;
      num4 = Mathf.Clamp(num4, -max, max);
    }
    target = current - num4;
    float num6 = (currentVelocity + num1 * num4) * deltaTime;
    currentVelocity = (currentVelocity - num1 * num6) * num3;
    float num7 = target + (num4 + num6) * num3;
    if ((double) num5 - (double) current > 0.0 == (double) num7 > (double) num5)
    {
      num7 = num5;
      currentVelocity = (num7 - num5) / deltaTime;
    }
    return num7;
  }

  public static Vector3 damp(
    Vector3 current,
    Vector3 target,
    ref Vector3 currentVelocity,
    float smoothTime,
    float maxSpeed = -1f,
    float deltaTime = -1f)
  {
    double x = (double) LeanSmooth.damp(current.x, target.x, ref currentVelocity.x, smoothTime, maxSpeed, deltaTime);
    float num1 = LeanSmooth.damp(current.y, target.y, ref currentVelocity.y, smoothTime, maxSpeed, deltaTime);
    float num2 = LeanSmooth.damp(current.z, target.z, ref currentVelocity.z, smoothTime, maxSpeed, deltaTime);
    double y = (double) num1;
    double z = (double) num2;
    return new Vector3((float) x, (float) y, (float) z);
  }

  public static Color damp(
    Color current,
    Color target,
    ref Color currentVelocity,
    float smoothTime,
    float maxSpeed = -1f,
    float deltaTime = -1f)
  {
    double r = (double) LeanSmooth.damp(current.r, target.r, ref currentVelocity.r, smoothTime, maxSpeed, deltaTime);
    float num1 = LeanSmooth.damp(current.g, target.g, ref currentVelocity.g, smoothTime, maxSpeed, deltaTime);
    float num2 = LeanSmooth.damp(current.b, target.b, ref currentVelocity.b, smoothTime, maxSpeed, deltaTime);
    float num3 = LeanSmooth.damp(current.a, target.a, ref currentVelocity.a, smoothTime, maxSpeed, deltaTime);
    double g = (double) num1;
    double b = (double) num2;
    double a = (double) num3;
    return new Color((float) r, (float) g, (float) b, (float) a);
  }

  public static float spring(
    float current,
    float target,
    ref float currentVelocity,
    float smoothTime,
    float maxSpeed = -1f,
    float deltaTime = -1f,
    float friction = 2f,
    float accelRate = 0.5f)
  {
    if ((double) deltaTime < 0.0)
      deltaTime = Time.deltaTime;
    float num = target - current;
    currentVelocity += deltaTime / smoothTime * accelRate * num;
    currentVelocity *= (float) (1.0 - (double) deltaTime * (double) friction);
    if ((double) maxSpeed > 0.0 && (double) maxSpeed < (double) Mathf.Abs(currentVelocity))
      currentVelocity = maxSpeed * Mathf.Sign(currentVelocity);
    return current + currentVelocity;
  }

  public static Vector3 spring(
    Vector3 current,
    Vector3 target,
    ref Vector3 currentVelocity,
    float smoothTime,
    float maxSpeed = -1f,
    float deltaTime = -1f,
    float friction = 2f,
    float accelRate = 0.5f)
  {
    double x = (double) LeanSmooth.spring(current.x, target.x, ref currentVelocity.x, smoothTime, maxSpeed, deltaTime, friction, accelRate);
    float num1 = LeanSmooth.spring(current.y, target.y, ref currentVelocity.y, smoothTime, maxSpeed, deltaTime, friction, accelRate);
    float num2 = LeanSmooth.spring(current.z, target.z, ref currentVelocity.z, smoothTime, maxSpeed, deltaTime, friction, accelRate);
    double y = (double) num1;
    double z = (double) num2;
    return new Vector3((float) x, (float) y, (float) z);
  }

  public static Color spring(
    Color current,
    Color target,
    ref Color currentVelocity,
    float smoothTime,
    float maxSpeed = -1f,
    float deltaTime = -1f,
    float friction = 2f,
    float accelRate = 0.5f)
  {
    double r = (double) LeanSmooth.spring(current.r, target.r, ref currentVelocity.r, smoothTime, maxSpeed, deltaTime, friction, accelRate);
    float num1 = LeanSmooth.spring(current.g, target.g, ref currentVelocity.g, smoothTime, maxSpeed, deltaTime, friction, accelRate);
    float num2 = LeanSmooth.spring(current.b, target.b, ref currentVelocity.b, smoothTime, maxSpeed, deltaTime, friction, accelRate);
    float num3 = LeanSmooth.spring(current.a, target.a, ref currentVelocity.a, smoothTime, maxSpeed, deltaTime, friction, accelRate);
    double g = (double) num1;
    double b = (double) num2;
    double a = (double) num3;
    return new Color((float) r, (float) g, (float) b, (float) a);
  }

  public static float linear(float current, float target, float moveSpeed, float deltaTime = -1f)
  {
    if ((double) deltaTime < 0.0)
      deltaTime = Time.deltaTime;
    bool flag = (double) target > (double) current;
    float num1 = (float) ((double) deltaTime * (double) moveSpeed * (flag ? 1.0 : -1.0));
    float num2 = current + num1;
    float num3 = num2 - target;
    return flag && (double) num3 > 0.0 || !flag && (double) num3 < 0.0 ? target : num2;
  }

  public static Vector3 linear(Vector3 current, Vector3 target, float moveSpeed, float deltaTime = -1f)
  {
    double x = (double) LeanSmooth.linear(current.x, target.x, moveSpeed, deltaTime);
    float num1 = LeanSmooth.linear(current.y, target.y, moveSpeed, deltaTime);
    float num2 = LeanSmooth.linear(current.z, target.z, moveSpeed, deltaTime);
    double y = (double) num1;
    double z = (double) num2;
    return new Vector3((float) x, (float) y, (float) z);
  }

  public static Color linear(Color current, Color target, float moveSpeed)
  {
    double r = (double) LeanSmooth.linear(current.r, target.r, moveSpeed);
    float num1 = LeanSmooth.linear(current.g, target.g, moveSpeed);
    float num2 = LeanSmooth.linear(current.b, target.b, moveSpeed);
    float num3 = LeanSmooth.linear(current.a, target.a, moveSpeed);
    double g = (double) num1;
    double b = (double) num2;
    double a = (double) num3;
    return new Color((float) r, (float) g, (float) b, (float) a);
  }

  public static float bounceOut(
    float current,
    float target,
    ref float currentVelocity,
    float smoothTime,
    float maxSpeed = -1f,
    float deltaTime = -1f,
    float friction = 2f,
    float accelRate = 0.5f,
    float hitDamping = 0.9f)
  {
    if ((double) deltaTime < 0.0)
      deltaTime = Time.deltaTime;
    float num1 = target - current;
    currentVelocity += deltaTime / smoothTime * accelRate * num1;
    currentVelocity *= (float) (1.0 - (double) deltaTime * (double) friction);
    if ((double) maxSpeed > 0.0 && (double) maxSpeed < (double) Mathf.Abs(currentVelocity))
      currentVelocity = maxSpeed * Mathf.Sign(currentVelocity);
    float num2 = current + currentVelocity;
    bool flag = (double) target > (double) current;
    float num3 = num2 - target;
    if (flag && (double) num3 > 0.0 || !flag && (double) num3 < 0.0)
    {
      currentVelocity = -currentVelocity * hitDamping;
      num2 = current + currentVelocity;
    }
    return num2;
  }

  public static Vector3 bounceOut(
    Vector3 current,
    Vector3 target,
    ref Vector3 currentVelocity,
    float smoothTime,
    float maxSpeed = -1f,
    float deltaTime = -1f,
    float friction = 2f,
    float accelRate = 0.5f,
    float hitDamping = 0.9f)
  {
    double x = (double) LeanSmooth.bounceOut(current.x, target.x, ref currentVelocity.x, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
    float num1 = LeanSmooth.bounceOut(current.y, target.y, ref currentVelocity.y, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
    float num2 = LeanSmooth.bounceOut(current.z, target.z, ref currentVelocity.z, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
    double y = (double) num1;
    double z = (double) num2;
    return new Vector3((float) x, (float) y, (float) z);
  }

  public static Color bounceOut(
    Color current,
    Color target,
    ref Color currentVelocity,
    float smoothTime,
    float maxSpeed = -1f,
    float deltaTime = -1f,
    float friction = 2f,
    float accelRate = 0.5f,
    float hitDamping = 0.9f)
  {
    double r = (double) LeanSmooth.bounceOut(current.r, target.r, ref currentVelocity.r, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
    float num1 = LeanSmooth.bounceOut(current.g, target.g, ref currentVelocity.g, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
    float num2 = LeanSmooth.bounceOut(current.b, target.b, ref currentVelocity.b, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
    float num3 = LeanSmooth.bounceOut(current.a, target.a, ref currentVelocity.a, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
    double g = (double) num1;
    double b = (double) num2;
    double a = (double) num3;
    return new Color((float) r, (float) g, (float) b, (float) a);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeanTest
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LeanTest
{
  public static int expected = 0;
  public static int tests = 0;
  public static int passes = 0;
  public static float timeout = 15f;
  public static bool timeoutStarted = false;
  public static bool testsFinished = false;

  public static void debug(string name, bool didPass, string failExplaination = null) => LeanTest.expect(didPass, name, failExplaination);

  public static void expect(bool didPass, string definition, string failExplaination = null)
  {
    string str = "".PadRight(40 - (int) ((double) LeanTest.printOutLength(definition) * 1.0499999523162842), "_"[0]);
    string message = LeanTest.formatB(definition) + " " + str + " [ " + (didPass ? LeanTest.formatC("pass", "green") : LeanTest.formatC("fail", "red")) + " ]";
    if (!didPass && failExplaination != null)
      message = message + " - " + failExplaination;
    Debug.Log((object) message);
    if (didPass)
      ++LeanTest.passes;
    ++LeanTest.tests;
    if (LeanTest.tests == LeanTest.expected && !LeanTest.testsFinished)
      LeanTest.overview();
    else if (LeanTest.tests > LeanTest.expected)
      Debug.Log((object) (LeanTest.formatB("Too many tests for a final report!") + " set LeanTest.expected = " + LeanTest.tests.ToString()));
    if (LeanTest.timeoutStarted)
      return;
    LeanTest.timeoutStarted = true;
    GameObject gameObject = new GameObject();
    gameObject.name = "~LeanTest";
    (gameObject.AddComponent(typeof (LeanTester)) as LeanTester).timeout = LeanTest.timeout;
    gameObject.hideFlags = HideFlags.HideAndDontSave;
  }

  public static string padRight(int len)
  {
    string str = "";
    for (int index = 0; index < len; ++index)
      str += "_";
    return str;
  }

  public static float printOutLength(string str)
  {
    float num = 0.0f;
    for (int index = 0; index < str.Length; ++index)
    {
      if ((int) str[index] == (int) "I"[0])
        num += 0.5f;
      else if ((int) str[index] == (int) "J"[0])
        num += 0.85f;
      else
        ++num;
    }
    return num;
  }

  public static string formatBC(string str, string color) => LeanTest.formatC(LeanTest.formatB(str), color);

  public static string formatB(string str) => "<b>" + str + "</b>";

  public static string formatC(string str, string color) => "<color=" + color + ">" + str + "</color>";

  public static void overview()
  {
    LeanTest.testsFinished = true;
    int num = LeanTest.expected - LeanTest.passes;
    string str = num > 0 ? LeanTest.formatBC(num.ToString() ?? "", "red") : num.ToString() ?? "";
    Debug.Log((object) (LeanTest.formatB("Final Report:") + " _____________________ PASSED: " + LeanTest.formatBC(LeanTest.passes.ToString() ?? "", "green") + " FAILED: " + str + " "));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeanTester
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class LeanTester : MonoBehaviour
{
  public float timeout = 15f;

  public void Start() => this.StartCoroutine(this.timeoutCheck());

  public IEnumerator timeoutCheck()
  {
    float pauseEndTime = Time.realtimeSinceStartup + this.timeout;
    while ((double) Time.realtimeSinceStartup < (double) pauseEndTime)
      yield return (object) 0;
    if (!LeanTest.testsFinished)
    {
      Debug.Log((object) LeanTest.formatB("Tests timed out!"));
      LeanTest.overview();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeanTween
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class LeanTween : MonoBehaviour
{
  public static bool throwErrors = true;
  public static float tau = 6.28318548f;
  public static float PI_DIV2 = 1.57079637f;
  public static LTSeq[] sequences;
  public static LTDescr[] tweens;
  public static int[] tweensFinished;
  public static int[] tweensFinishedIds;
  public static LTDescr tween;
  public static int tweenMaxSearch = -1;
  public static int maxTweens = 400;
  public static int maxSequences = 400;
  public static int frameRendered = -1;
  public static GameObject _tweenEmpty;
  public static float dtEstimated = -1f;
  public static float dtManual;
  public static float dtActual;
  public static uint global_counter = 0;
  public static int i;
  public static int j;
  public static int finishedCnt;
  public static AnimationCurve punch = new AnimationCurve(new Keyframe[9]
  {
    new Keyframe(0.0f, 0.0f),
    new Keyframe(0.112586f, 0.9976035f),
    new Keyframe(0.3120486f, -0.1720615f),
    new Keyframe(0.4316337f, 0.07030682f),
    new Keyframe(0.5524869f, -0.03141804f),
    new Keyframe(0.6549395f, 0.003909959f),
    new Keyframe(0.770987f, -0.009817753f),
    new Keyframe(0.8838775f, 0.001939224f),
    new Keyframe(1f, 0.0f)
  });
  public static AnimationCurve shake = new AnimationCurve(new Keyframe[4]
  {
    new Keyframe(0.0f, 0.0f),
    new Keyframe(0.25f, 1f),
    new Keyframe(0.75f, -1f),
    new Keyframe(1f, 0.0f)
  });
  public static int maxTweenReached;
  public static int startSearch = 0;
  public static LTDescr d;
  public static Action<LTEvent>[] eventListeners;
  public static GameObject[] goListeners;
  public static int eventsMaxSearch = 0;
  public static int EVENTS_MAX = 10;
  public static int LISTENERS_MAX = 10;
  public static int INIT_LISTENERS_MAX = LeanTween.LISTENERS_MAX;

  public static void init() => LeanTween.init(LeanTween.maxTweens);

  public static int maxSearch => LeanTween.tweenMaxSearch;

  public static int maxSimulataneousTweens => LeanTween.maxTweens;

  public static int tweensRunning
  {
    get
    {
      int tweensRunning = 0;
      for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
      {
        if (LeanTween.tweens[index].toggle)
          ++tweensRunning;
      }
      return tweensRunning;
    }
  }

  public static void init(int maxSimultaneousTweens) => LeanTween.init(maxSimultaneousTweens, LeanTween.maxSequences);

  public static void init(int maxSimultaneousTweens, int maxSimultaneousSequences)
  {
    if (LeanTween.tweens != null)
      return;
    LeanTween.maxTweens = maxSimultaneousTweens;
    LeanTween.tweens = new LTDescr[LeanTween.maxTweens];
    LeanTween.tweensFinished = new int[LeanTween.maxTweens];
    LeanTween.tweensFinishedIds = new int[LeanTween.maxTweens];
    LeanTween._tweenEmpty = new GameObject();
    LeanTween._tweenEmpty.name = "~LeanTween";
    LeanTween._tweenEmpty.AddComponent(typeof (LeanTween));
    LeanTween._tweenEmpty.isStatic = true;
    LeanTween._tweenEmpty.hideFlags = HideFlags.HideAndDontSave;
    UnityEngine.Object.DontDestroyOnLoad((UnityEngine.Object) LeanTween._tweenEmpty);
    for (int index = 0; index < LeanTween.maxTweens; ++index)
      LeanTween.tweens[index] = new LTDescr();
    UnityEngine.SceneManagement.SceneManager.sceneLoaded += new UnityAction<Scene, LoadSceneMode>(LeanTween.onLevelWasLoaded54);
    LeanTween.sequences = new LTSeq[maxSimultaneousSequences];
    for (int index = 0; index < maxSimultaneousSequences; ++index)
      LeanTween.sequences[index] = new LTSeq();
  }

  public static void reset()
  {
    if (LeanTween.tweens != null)
    {
      for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
      {
        if (LeanTween.tweens[index] != null)
          LeanTween.tweens[index].toggle = false;
      }
    }
    LeanTween.tweens = (LTDescr[]) null;
    UnityEngine.Object.Destroy((UnityEngine.Object) LeanTween._tweenEmpty);
  }

  public void Update() => LeanTween.update();

  public static void onLevelWasLoaded54(Scene scene, LoadSceneMode mode) => LeanTween.internalOnLevelWasLoaded(scene.buildIndex);

  public static void internalOnLevelWasLoaded(int lvl) => LTGUI.reset();

  public static void update()
  {
    if (LeanTween.frameRendered == Time.frameCount)
      return;
    LeanTween.init();
    LeanTween.dtEstimated = (double) LeanTween.dtEstimated < 0.0 ? 0.0f : (LeanTween.dtEstimated = Time.unscaledDeltaTime);
    LeanTween.dtActual = Time.deltaTime;
    LeanTween.maxTweenReached = 0;
    LeanTween.finishedCnt = 0;
    for (int index = 0; index <= LeanTween.tweenMaxSearch && index < LeanTween.maxTweens; ++index)
    {
      LeanTween.tween = LeanTween.tweens[index];
      if (LeanTween.tween.toggle)
      {
        LeanTween.maxTweenReached = index;
        if (LeanTween.tween.updateInternal())
        {
          LeanTween.tweensFinished[LeanTween.finishedCnt] = index;
          LeanTween.tweensFinishedIds[LeanTween.finishedCnt] = LeanTween.tweens[index].id;
          ++LeanTween.finishedCnt;
        }
      }
    }
    LeanTween.tweenMaxSearch = LeanTween.maxTweenReached;
    LeanTween.frameRendered = Time.frameCount;
    for (int index = 0; index < LeanTween.finishedCnt; ++index)
    {
      LeanTween.j = LeanTween.tweensFinished[index];
      LeanTween.tween = LeanTween.tweens[LeanTween.j];
      if (LeanTween.tween.id == LeanTween.tweensFinishedIds[index])
      {
        LeanTween.removeTween(LeanTween.j);
        if (LeanTween.tween.hasExtraOnCompletes && (UnityEngine.Object) LeanTween.tween.trans != (UnityEngine.Object) null)
          LeanTween.tween.callOnCompletes();
      }
    }
  }

  public static void removeTween(int i, int uniqueId)
  {
    if (LeanTween.tweens[i].uniqueId != uniqueId)
      return;
    LeanTween.removeTween(i);
  }

  public static void removeTween(int i)
  {
    if (!LeanTween.tweens[i].toggle)
      return;
    LeanTween.tweens[i].toggle = false;
    LeanTween.tweens[i].counter = uint.MaxValue;
    if (LeanTween.tweens[i].destroyOnComplete)
    {
      if (LeanTween.tweens[i]._optional.ltRect != null)
        LTGUI.destroy(LeanTween.tweens[i]._optional.ltRect.id);
      else if ((UnityEngine.Object) LeanTween.tweens[i].trans != (UnityEngine.Object) null && (UnityEngine.Object) LeanTween.tweens[i].trans.gameObject != (UnityEngine.Object) LeanTween._tweenEmpty)
        UnityEngine.Object.Destroy((UnityEngine.Object) LeanTween.tweens[i].trans.gameObject);
    }
    LeanTween.startSearch = i;
    if (i + 1 < LeanTween.tweenMaxSearch)
      return;
    LeanTween.startSearch = 0;
  }

  public static Vector3[] add(Vector3[] a, Vector3 b)
  {
    Vector3[] vector3Array = new Vector3[a.Length];
    for (LeanTween.i = 0; LeanTween.i < a.Length; ++LeanTween.i)
      vector3Array[LeanTween.i] = a[LeanTween.i] + b;
    return vector3Array;
  }

  public static float closestRot(float from, float to)
  {
    float num1 = (float) (0.0 - (360.0 - (double) to));
    float num2 = 360f + to;
    float num3 = Mathf.Abs(to - from);
    float num4 = Mathf.Abs(num1 - from);
    float num5 = Mathf.Abs(num2 - from);
    if ((double) num3 < (double) num4 && (double) num3 < (double) num5)
      return to;
    return (double) num4 < (double) num5 ? num1 : num2;
  }

  public static void cancelAll() => LeanTween.cancelAll(false);

  public static void cancelAll(bool callComplete)
  {
    LeanTween.init();
    for (int i = 0; i <= LeanTween.tweenMaxSearch; ++i)
    {
      if ((UnityEngine.Object) LeanTween.tweens[i].trans != (UnityEngine.Object) null)
      {
        if (callComplete && LeanTween.tweens[i].optional.onComplete != null)
          LeanTween.tweens[i].optional.onComplete();
        LeanTween.removeTween(i);
      }
    }
  }

  public static void cancel(GameObject gameObject) => LeanTween.cancel(gameObject, false);

  public static void cancel(GameObject gameObject, bool callOnComplete)
  {
    LeanTween.init();
    Transform transform = gameObject.transform;
    for (int i = 0; i <= LeanTween.tweenMaxSearch; ++i)
    {
      LTDescr tween = LeanTween.tweens[i];
      if (tween != null && tween.toggle && (UnityEngine.Object) tween.trans == (UnityEngine.Object) transform)
      {
        if (callOnComplete && tween.optional.onComplete != null)
          tween.optional.onComplete();
        LeanTween.removeTween(i);
      }
    }
  }

  public static void cancel(RectTransform rect) => LeanTween.cancel(rect.gameObject, false);

  public static void cancel(GameObject gameObject, int uniqueId, bool callOnComplete = false)
  {
    if (uniqueId < 0)
      return;
    LeanTween.init();
    int i = uniqueId & (int) ushort.MaxValue;
    int num = uniqueId >> 16;
    if (!((UnityEngine.Object) LeanTween.tweens[i].trans == (UnityEngine.Object) null) && (!((UnityEngine.Object) LeanTween.tweens[i].trans.gameObject == (UnityEngine.Object) gameObject) || (long) LeanTween.tweens[i].counter != (long) num))
      return;
    if (callOnComplete && LeanTween.tweens[i].optional.onComplete != null)
      LeanTween.tweens[i].optional.onComplete();
    LeanTween.removeTween(i);
  }

  public static void cancel(LTRect ltRect, int uniqueId)
  {
    if (uniqueId < 0)
      return;
    LeanTween.init();
    int i = uniqueId & (int) ushort.MaxValue;
    int num = uniqueId >> 16;
    if (LeanTween.tweens[i]._optional.ltRect != ltRect || (long) LeanTween.tweens[i].counter != (long) num)
      return;
    LeanTween.removeTween(i);
  }

  public static void cancel(int uniqueId) => LeanTween.cancel(uniqueId, false);

  public static void cancel(int uniqueId, bool callOnComplete)
  {
    if (uniqueId < 0)
      return;
    LeanTween.init();
    int i = uniqueId & (int) ushort.MaxValue;
    int num = uniqueId >> 16;
    if (i > LeanTween.tweens.Length - 1)
    {
      int index1 = i - LeanTween.tweens.Length;
      LTSeq sequence = LeanTween.sequences[index1];
      for (int index2 = 0; index2 < LeanTween.maxSequences; ++index2)
      {
        if (sequence.current.tween != null)
          LeanTween.removeTween(sequence.current.tween.uniqueId & (int) ushort.MaxValue);
        if (sequence.current.previous == null)
          break;
        sequence.current = sequence.current.previous;
      }
    }
    else
    {
      if ((long) LeanTween.tweens[i].counter != (long) num)
        return;
      if (callOnComplete && LeanTween.tweens[i].optional.onComplete != null)
        LeanTween.tweens[i].optional.onComplete();
      LeanTween.removeTween(i);
    }
  }

  public static LTDescr descr(int uniqueId)
  {
    LeanTween.init();
    int index1 = uniqueId & (int) ushort.MaxValue;
    int num = uniqueId >> 16;
    if (LeanTween.tweens[index1] != null && LeanTween.tweens[index1].uniqueId == uniqueId && (long) LeanTween.tweens[index1].counter == (long) num)
      return LeanTween.tweens[index1];
    for (int index2 = 0; index2 <= LeanTween.tweenMaxSearch; ++index2)
    {
      if (LeanTween.tweens[index2].uniqueId == uniqueId && (long) LeanTween.tweens[index2].counter == (long) num)
        return LeanTween.tweens[index2];
    }
    return (LTDescr) null;
  }

  public static LTDescr description(int uniqueId) => LeanTween.descr(uniqueId);

  public static LTDescr[] descriptions(GameObject gameObject = null)
  {
    if ((UnityEngine.Object) gameObject == (UnityEngine.Object) null)
      return (LTDescr[]) null;
    List<LTDescr> ltDescrList = new List<LTDescr>();
    Transform transform = gameObject.transform;
    for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
    {
      if (LeanTween.tweens[index].toggle && (UnityEngine.Object) LeanTween.tweens[index].trans == (UnityEngine.Object) transform)
        ltDescrList.Add(LeanTween.tweens[index]);
    }
    return ltDescrList.ToArray();
  }

  [Obsolete("Use 'pause( id )' instead")]
  public static void pause(GameObject gameObject, int uniqueId) => LeanTween.pause(uniqueId);

  public static void pause(int uniqueId)
  {
    int index = uniqueId & (int) ushort.MaxValue;
    int num = uniqueId >> 16;
    if ((long) LeanTween.tweens[index].counter != (long) num)
      return;
    LeanTween.tweens[index].pause();
  }

  public static void pause(GameObject gameObject)
  {
    Transform transform = gameObject.transform;
    for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
    {
      if ((UnityEngine.Object) LeanTween.tweens[index].trans == (UnityEngine.Object) transform)
        LeanTween.tweens[index].pause();
    }
  }

  public static void pauseAll()
  {
    LeanTween.init();
    for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
      LeanTween.tweens[index].pause();
  }

  public static void resumeAll()
  {
    LeanTween.init();
    for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
      LeanTween.tweens[index].resume();
  }

  [Obsolete("Use 'resume( id )' instead")]
  public static void resume(GameObject gameObject, int uniqueId) => LeanTween.resume(uniqueId);

  public static void resume(int uniqueId)
  {
    int index = uniqueId & (int) ushort.MaxValue;
    int num = uniqueId >> 16;
    if ((long) LeanTween.tweens[index].counter != (long) num)
      return;
    LeanTween.tweens[index].resume();
  }

  public static void resume(GameObject gameObject)
  {
    Transform transform = gameObject.transform;
    for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
    {
      if ((UnityEngine.Object) LeanTween.tweens[index].trans == (UnityEngine.Object) transform)
        LeanTween.tweens[index].resume();
    }
  }

  public static bool isPaused(GameObject gameObject = null)
  {
    if ((UnityEngine.Object) gameObject == (UnityEngine.Object) null)
    {
      for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
      {
        if (object.Equals((object) LeanTween.tweens[index].direction, (object) 0.0f))
          return true;
      }
      return false;
    }
    Transform transform = gameObject.transform;
    for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
    {
      if (object.Equals((object) LeanTween.tweens[index].direction, (object) 0.0f) && (UnityEngine.Object) LeanTween.tweens[index].trans == (UnityEngine.Object) transform)
        return true;
    }
    return false;
  }

  public static bool isPaused(RectTransform rect) => LeanTween.isTweening(rect.gameObject);

  public static bool isPaused(int uniqueId)
  {
    int index = uniqueId & (int) ushort.MaxValue;
    int num = uniqueId >> 16;
    return index >= 0 && index < LeanTween.maxTweens && (long) LeanTween.tweens[index].counter == (long) num && object.Equals((object) LeanTween.tweens[LeanTween.i].direction, (object) 0.0f);
  }

  public static bool isTweening(GameObject gameObject = null)
  {
    if ((UnityEngine.Object) gameObject == (UnityEngine.Object) null)
    {
      for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
      {
        if (LeanTween.tweens[index].toggle)
          return true;
      }
      return false;
    }
    Transform transform = gameObject.transform;
    for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
    {
      if (LeanTween.tweens[index].toggle && (UnityEngine.Object) LeanTween.tweens[index].trans == (UnityEngine.Object) transform)
        return true;
    }
    return false;
  }

  public static bool isTweening(RectTransform rect) => LeanTween.isTweening(rect.gameObject);

  public static bool isTweening(int uniqueId)
  {
    int index = uniqueId & (int) ushort.MaxValue;
    int num = uniqueId >> 16;
    return index >= 0 && index < LeanTween.maxTweens && (long) LeanTween.tweens[index].counter == (long) num && LeanTween.tweens[index].toggle;
  }

  public static bool isTweening(LTRect ltRect)
  {
    for (int index = 0; index <= LeanTween.tweenMaxSearch; ++index)
    {
      if (LeanTween.tweens[index].toggle && LeanTween.tweens[index]._optional.ltRect == ltRect)
        return true;
    }
    return false;
  }

  public static void drawBezierPath(
    Vector3 a,
    Vector3 b,
    Vector3 c,
    Vector3 d,
    float arrowSize = 0.0f,
    Transform arrowTransform = null)
  {
    Vector3 vector3_1 = a;
    Vector3 vector3_2 = -a + 3f * (b - c) + d;
    Vector3 vector3_3 = 3f * (a + c) - 6f * b;
    Vector3 vector3_4 = 3f * (b - a);
    if ((double) arrowSize > 0.0)
    {
      Vector3 position = arrowTransform.position;
      Quaternion rotation = arrowTransform.rotation;
      float num1 = 0.0f;
      for (float num2 = 1f; (double) num2 <= 120.0; ++num2)
      {
        float num3 = num2 / 120f;
        Vector3 vector3_5 = ((vector3_2 * num3 + vector3_3) * num3 + vector3_4) * num3 + a;
        Gizmos.DrawLine(vector3_1, vector3_5);
        num1 += (vector3_5 - vector3_1).magnitude;
        if ((double) num1 > 1.0)
        {
          --num1;
          arrowTransform.position = vector3_5;
          arrowTransform.LookAt(vector3_1, Vector3.forward);
          Vector3 vector3_6 = arrowTransform.TransformDirection(Vector3.right);
          Vector3 normalized = (vector3_1 - vector3_5).normalized;
          Gizmos.DrawLine(vector3_5, vector3_5 + (vector3_6 + normalized) * arrowSize);
          Vector3 vector3_7 = arrowTransform.TransformDirection(-Vector3.right);
          Gizmos.DrawLine(vector3_5, vector3_5 + (vector3_7 + normalized) * arrowSize);
        }
        vector3_1 = vector3_5;
      }
      arrowTransform.position = position;
      arrowTransform.rotation = rotation;
    }
    else
    {
      for (float num4 = 1f; (double) num4 <= 30.0; ++num4)
      {
        float num5 = num4 / 30f;
        Vector3 to = ((vector3_2 * num5 + vector3_3) * num5 + vector3_4) * num5 + a;
        Gizmos.DrawLine(vector3_1, to);
        vector3_1 = to;
      }
    }
  }

  public static object logError(string error)
  {
    if (LeanTween.throwErrors)
      Debug.LogError((object) error);
    else
      Debug.Log((object) error);
    return (object) null;
  }

  public static LTDescr options(LTDescr seed)
  {
    Debug.LogError((object) "error this function is no longer used");
    return (LTDescr) null;
  }

  public static LTDescr options()
  {
    LeanTween.init();
    bool flag = false;
    LeanTween.j = 0;
    LeanTween.i = LeanTween.startSearch;
    while (LeanTween.j <= LeanTween.maxTweens)
    {
      if (LeanTween.j >= LeanTween.maxTweens)
        return LeanTween.logError("LeanTween - You have run out of available spaces for tweening. To avoid this error increase the number of spaces to available for tweening when you initialize the LeanTween class ex: LeanTween.init( " + (LeanTween.maxTweens * 2).ToString() + " );") as LTDescr;
      if (LeanTween.i >= LeanTween.maxTweens)
        LeanTween.i = 0;
      if (!LeanTween.tweens[LeanTween.i].toggle)
      {
        if (LeanTween.i + 1 > LeanTween.tweenMaxSearch && LeanTween.i + 1 < LeanTween.maxTweens)
          LeanTween.tweenMaxSearch = LeanTween.i + 1;
        LeanTween.startSearch = LeanTween.i + 1;
        flag = true;
        break;
      }
      ++LeanTween.j;
      ++LeanTween.i;
    }
    if (!flag)
      LeanTween.logError("no available tween found!");
    LeanTween.tweens[LeanTween.i].reset();
    ++LeanTween.global_counter;
    if (LeanTween.global_counter > 32768U)
      LeanTween.global_counter = 0U;
    LeanTween.tweens[LeanTween.i].setId((uint) LeanTween.i, LeanTween.global_counter);
    return LeanTween.tweens[LeanTween.i];
  }

  public static GameObject tweenEmpty
  {
    get
    {
      LeanTween.init(LeanTween.maxTweens);
      return LeanTween._tweenEmpty;
    }
  }

  public static LTDescr pushNewTween(GameObject gameObject, Vector3 to, float time, LTDescr tween)
  {
    LeanTween.init(LeanTween.maxTweens);
    if ((UnityEngine.Object) gameObject == (UnityEngine.Object) null || tween == null)
      return (LTDescr) null;
    tween.trans = gameObject.transform;
    tween.to = to;
    tween.time = time;
    if ((double) tween.time <= 0.0)
      tween.updateInternal();
    return tween;
  }

  public static LTDescr play(RectTransform rectTransform, Sprite[] sprites)
  {
    float time = 0.25f * (float) sprites.Length;
    return LeanTween.pushNewTween(rectTransform.gameObject, new Vector3((float) sprites.Length - 1f, 0.0f, 0.0f), time, LeanTween.options().setCanvasPlaySprite().setSprites(sprites).setRepeat(-1));
  }

  public static LTSeq sequence(bool initSequence = true)
  {
    LeanTween.init(LeanTween.maxTweens);
    for (int index = 0; index < LeanTween.sequences.Length; ++index)
    {
      if ((LeanTween.sequences[index].tween == null || !LeanTween.sequences[index].tween.toggle) && !LeanTween.sequences[index].toggle)
      {
        LTSeq sequence = LeanTween.sequences[index];
        if (initSequence)
        {
          sequence.init((uint) (index + LeanTween.tweens.Length), LeanTween.global_counter);
          ++LeanTween.global_counter;
          if (LeanTween.global_counter > 32768U)
            LeanTween.global_counter = 0U;
        }
        else
          sequence.reset();
        return sequence;
      }
    }
    return (LTSeq) null;
  }

  public static LTDescr alpha(GameObject gameObject, float to, float time)
  {
    LTDescr ltDescr = LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setAlpha());
    ltDescr.spriteRen = gameObject.GetComponent<SpriteRenderer>();
    return ltDescr;
  }

  public static LTDescr alpha(LTRect ltRect, float to, float time)
  {
    ltRect.alphaEnabled = true;
    return LeanTween.pushNewTween(LeanTween.tweenEmpty, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setGUIAlpha().setRect(ltRect));
  }

  public static LTDescr textAlpha(RectTransform rectTransform, float to, float time) => LeanTween.pushNewTween(rectTransform.gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setTextAlpha());

  public static LTDescr alphaText(RectTransform rectTransform, float to, float time) => LeanTween.pushNewTween(rectTransform.gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setTextAlpha());

  public static LTDescr alphaCanvas(CanvasGroup canvasGroup, float to, float time) => LeanTween.pushNewTween(canvasGroup.gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCanvasGroupAlpha());

  public static LTDescr alphaVertex(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setAlphaVertex());

  public static LTDescr color(GameObject gameObject, Color to, float time)
  {
    LTDescr ltDescr = LeanTween.pushNewTween(gameObject, new Vector3(1f, to.a, 0.0f), time, LeanTween.options().setColor().setPoint(new Vector3(to.r, to.g, to.b)));
    ltDescr.spriteRen = gameObject.GetComponent<SpriteRenderer>();
    return ltDescr;
  }

  public static LTDescr textColor(RectTransform rectTransform, Color to, float time) => LeanTween.pushNewTween(rectTransform.gameObject, new Vector3(1f, to.a, 0.0f), time, LeanTween.options().setTextColor().setPoint(new Vector3(to.r, to.g, to.b)));

  public static LTDescr colorText(RectTransform rectTransform, Color to, float time) => LeanTween.pushNewTween(rectTransform.gameObject, new Vector3(1f, to.a, 0.0f), time, LeanTween.options().setTextColor().setPoint(new Vector3(to.r, to.g, to.b)));

  public static LTDescr delayedCall(float delayTime, System.Action callback) => LeanTween.pushNewTween(LeanTween.tweenEmpty, Vector3.zero, delayTime, LeanTween.options().setCallback().setOnComplete(callback));

  public static LTDescr delayedCall(float delayTime, Action<object> callback) => LeanTween.pushNewTween(LeanTween.tweenEmpty, Vector3.zero, delayTime, LeanTween.options().setCallback().setOnComplete(callback));

  public static LTDescr delayedCall(GameObject gameObject, float delayTime, System.Action callback) => LeanTween.pushNewTween(gameObject, Vector3.zero, delayTime, LeanTween.options().setCallback().setOnComplete(callback));

  public static LTDescr delayedCall(
    GameObject gameObject,
    float delayTime,
    Action<object> callback)
  {
    return LeanTween.pushNewTween(gameObject, Vector3.zero, delayTime, LeanTween.options().setCallback().setOnComplete(callback));
  }

  public static LTDescr destroyAfter(LTRect rect, float delayTime) => LeanTween.pushNewTween(LeanTween.tweenEmpty, Vector3.zero, delayTime, LeanTween.options().setCallback().setRect(rect).setDestroyOnComplete(true));

  public static LTDescr move(GameObject gameObject, Vector3 to, float time) => LeanTween.pushNewTween(gameObject, to, time, LeanTween.options().setMove());

  public static LTDescr move(GameObject gameObject, Vector2 to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to.x, to.y, gameObject.transform.position.z), time, LeanTween.options().setMove());

  public static LTDescr move(GameObject gameObject, Vector3[] to, float time)
  {
    LeanTween.d = LeanTween.options().setMoveCurved();
    if (LeanTween.d.optional.path == null)
      LeanTween.d.optional.path = new LTBezierPath(to);
    else
      LeanTween.d.optional.path.setPoints(to);
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, 0.0f, 0.0f), time, LeanTween.d);
  }

  public static LTDescr move(GameObject gameObject, LTBezierPath to, float time)
  {
    LeanTween.d = LeanTween.options().setMoveCurved();
    LeanTween.d.optional.path = to;
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, 0.0f, 0.0f), time, LeanTween.d);
  }

  public static LTDescr move(GameObject gameObject, LTSpline to, float time)
  {
    LeanTween.d = LeanTween.options().setMoveSpline();
    LeanTween.d.optional.spline = to;
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, 0.0f, 0.0f), time, LeanTween.d);
  }

  public static LTDescr moveSpline(GameObject gameObject, Vector3[] to, float time)
  {
    LeanTween.d = LeanTween.options().setMoveSpline();
    LeanTween.d.optional.spline = new LTSpline(to);
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, 0.0f, 0.0f), time, LeanTween.d);
  }

  public static LTDescr moveSpline(GameObject gameObject, LTSpline to, float time)
  {
    LeanTween.d = LeanTween.options().setMoveSpline();
    LeanTween.d.optional.spline = to;
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, 0.0f, 0.0f), time, LeanTween.d);
  }

  public static LTDescr moveSplineLocal(GameObject gameObject, Vector3[] to, float time)
  {
    LeanTween.d = LeanTween.options().setMoveSplineLocal();
    LeanTween.d.optional.spline = new LTSpline(to);
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, 0.0f, 0.0f), time, LeanTween.d);
  }

  public static LTDescr move(LTRect ltRect, Vector2 to, float time) => LeanTween.pushNewTween(LeanTween.tweenEmpty, (Vector3) to, time, LeanTween.options().setGUIMove().setRect(ltRect));

  public static LTDescr moveMargin(LTRect ltRect, Vector2 to, float time) => LeanTween.pushNewTween(LeanTween.tweenEmpty, (Vector3) to, time, LeanTween.options().setGUIMoveMargin().setRect(ltRect));

  public static LTDescr moveX(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setMoveX());

  public static LTDescr moveY(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setMoveY());

  public static LTDescr moveZ(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setMoveZ());

  public static LTDescr moveLocal(GameObject gameObject, Vector3 to, float time) => LeanTween.pushNewTween(gameObject, to, time, LeanTween.options().setMoveLocal());

  public static LTDescr moveLocal(GameObject gameObject, Vector3[] to, float time)
  {
    LeanTween.d = LeanTween.options().setMoveCurvedLocal();
    if (LeanTween.d.optional.path == null)
      LeanTween.d.optional.path = new LTBezierPath(to);
    else
      LeanTween.d.optional.path.setPoints(to);
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, 0.0f, 0.0f), time, LeanTween.d);
  }

  public static LTDescr moveLocalX(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setMoveLocalX());

  public static LTDescr moveLocalY(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setMoveLocalY());

  public static LTDescr moveLocalZ(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setMoveLocalZ());

  public static LTDescr moveLocal(GameObject gameObject, LTBezierPath to, float time)
  {
    LeanTween.d = LeanTween.options().setMoveCurvedLocal();
    LeanTween.d.optional.path = to;
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, 0.0f, 0.0f), time, LeanTween.d);
  }

  public static LTDescr moveLocal(GameObject gameObject, LTSpline to, float time)
  {
    LeanTween.d = LeanTween.options().setMoveSplineLocal();
    LeanTween.d.optional.spline = to;
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, 0.0f, 0.0f), time, LeanTween.d);
  }

  public static LTDescr move(GameObject gameObject, Transform to, float time) => LeanTween.pushNewTween(gameObject, Vector3.zero, time, LeanTween.options().setTo(to).setMoveToTransform());

  public static LTDescr rotate(GameObject gameObject, Vector3 to, float time) => LeanTween.pushNewTween(gameObject, to, time, LeanTween.options().setRotate());

  public static LTDescr rotate(LTRect ltRect, float to, float time) => LeanTween.pushNewTween(LeanTween.tweenEmpty, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setGUIRotate().setRect(ltRect));

  public static LTDescr rotateLocal(GameObject gameObject, Vector3 to, float time) => LeanTween.pushNewTween(gameObject, to, time, LeanTween.options().setRotateLocal());

  public static LTDescr rotateX(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setRotateX());

  public static LTDescr rotateY(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setRotateY());

  public static LTDescr rotateZ(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setRotateZ());

  public static LTDescr rotateAround(GameObject gameObject, Vector3 axis, float add, float time) => LeanTween.pushNewTween(gameObject, new Vector3(add, 0.0f, 0.0f), time, LeanTween.options().setAxis(axis).setRotateAround());

  public static LTDescr rotateAroundLocal(
    GameObject gameObject,
    Vector3 axis,
    float add,
    float time)
  {
    return LeanTween.pushNewTween(gameObject, new Vector3(add, 0.0f, 0.0f), time, LeanTween.options().setRotateAroundLocal().setAxis(axis));
  }

  public static LTDescr scale(GameObject gameObject, Vector3 to, float time) => LeanTween.pushNewTween(gameObject, to, time, LeanTween.options().setScale());

  public static LTDescr scale(LTRect ltRect, Vector2 to, float time) => LeanTween.pushNewTween(LeanTween.tweenEmpty, (Vector3) to, time, LeanTween.options().setGUIScale().setRect(ltRect));

  public static LTDescr scaleX(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setScaleX());

  public static LTDescr scaleY(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setScaleY());

  public static LTDescr scaleZ(GameObject gameObject, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setScaleZ());

  public static LTDescr value(GameObject gameObject, float from, float to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCallback().setFrom(new Vector3(from, 0.0f, 0.0f)));

  public static LTDescr value(float from, float to, float time) => LeanTween.pushNewTween(LeanTween.tweenEmpty, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCallback().setFrom(new Vector3(from, 0.0f, 0.0f)));

  public static LTDescr value(GameObject gameObject, Vector2 from, Vector2 to, float time) => LeanTween.pushNewTween(gameObject, new Vector3(to.x, to.y, 0.0f), time, LeanTween.options().setValue3().setTo(new Vector3(to.x, to.y, 0.0f)).setFrom(new Vector3(from.x, from.y, 0.0f)));

  public static LTDescr value(GameObject gameObject, Vector3 from, Vector3 to, float time) => LeanTween.pushNewTween(gameObject, to, time, LeanTween.options().setValue3().setFrom(from));

  public static LTDescr value(GameObject gameObject, Color from, Color to, float time)
  {
    LTDescr ltDescr = LeanTween.pushNewTween(gameObject, new Vector3(1f, to.a, 0.0f), time, LeanTween.options().setCallbackColor().setPoint(new Vector3(to.r, to.g, to.b)).setFromColor(from).setHasInitialized(false));
    ltDescr.spriteRen = gameObject.GetComponent<SpriteRenderer>();
    return ltDescr;
  }

  public static LTDescr value(
    GameObject gameObject,
    Action<float> callOnUpdate,
    float from,
    float to,
    float time)
  {
    return LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCallback().setTo(new Vector3(to, 0.0f, 0.0f)).setFrom(new Vector3(from, 0.0f, 0.0f)).setOnUpdate(callOnUpdate));
  }

  public static LTDescr value(
    GameObject gameObject,
    Action<float, float> callOnUpdateRatio,
    float from,
    float to,
    float time)
  {
    return LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCallback().setTo(new Vector3(to, 0.0f, 0.0f)).setFrom(new Vector3(from, 0.0f, 0.0f)).setOnUpdateRatio(callOnUpdateRatio));
  }

  public static LTDescr value(
    GameObject gameObject,
    Action<Color> callOnUpdate,
    Color from,
    Color to,
    float time)
  {
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, to.a, 0.0f), time, LeanTween.options().setCallbackColor().setPoint(new Vector3(to.r, to.g, to.b)).setAxis(new Vector3(from.r, from.g, from.b)).setFrom(new Vector3(0.0f, from.a, 0.0f)).setHasInitialized(false).setOnUpdateColor(callOnUpdate));
  }

  public static LTDescr value(
    GameObject gameObject,
    Action<Color, object> callOnUpdate,
    Color from,
    Color to,
    float time)
  {
    return LeanTween.pushNewTween(gameObject, new Vector3(1f, to.a, 0.0f), time, LeanTween.options().setCallbackColor().setPoint(new Vector3(to.r, to.g, to.b)).setAxis(new Vector3(from.r, from.g, from.b)).setFrom(new Vector3(0.0f, from.a, 0.0f)).setHasInitialized(false).setOnUpdateColor(callOnUpdate));
  }

  public static LTDescr value(
    GameObject gameObject,
    Action<Vector2> callOnUpdate,
    Vector2 from,
    Vector2 to,
    float time)
  {
    return LeanTween.pushNewTween(gameObject, new Vector3(to.x, to.y, 0.0f), time, LeanTween.options().setValue3().setTo(new Vector3(to.x, to.y, 0.0f)).setFrom(new Vector3(from.x, from.y, 0.0f)).setOnUpdateVector2(callOnUpdate));
  }

  public static LTDescr value(
    GameObject gameObject,
    Action<Vector3> callOnUpdate,
    Vector3 from,
    Vector3 to,
    float time)
  {
    return LeanTween.pushNewTween(gameObject, to, time, LeanTween.options().setValue3().setTo(to).setFrom(from).setOnUpdateVector3(callOnUpdate));
  }

  public static LTDescr value(
    GameObject gameObject,
    Action<float, object> callOnUpdate,
    float from,
    float to,
    float time)
  {
    return LeanTween.pushNewTween(gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCallback().setTo(new Vector3(to, 0.0f, 0.0f)).setFrom(new Vector3(from, 0.0f, 0.0f)).setOnUpdate(callOnUpdate, (object) gameObject));
  }

  public static LTDescr delayedSound(AudioClip audio, Vector3 pos, float volume) => LeanTween.pushNewTween(LeanTween.tweenEmpty, pos, 0.0f, LeanTween.options().setDelayedSound().setTo(pos).setFrom(new Vector3(volume, 0.0f, 0.0f)).setAudio((object) audio));

  public static LTDescr delayedSound(
    GameObject gameObject,
    AudioClip audio,
    Vector3 pos,
    float volume)
  {
    return LeanTween.pushNewTween(gameObject, pos, 0.0f, LeanTween.options().setDelayedSound().setTo(pos).setFrom(new Vector3(volume, 0.0f, 0.0f)).setAudio((object) audio));
  }

  public static LTDescr move(RectTransform rectTrans, Vector3 to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, to, time, LeanTween.options().setCanvasMove().setRect(rectTrans));

  public static LTDescr moveX(RectTransform rectTrans, float to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCanvasMoveX().setRect(rectTrans));

  public static LTDescr moveY(RectTransform rectTrans, float to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCanvasMoveY().setRect(rectTrans));

  public static LTDescr moveZ(RectTransform rectTrans, float to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCanvasMoveZ().setRect(rectTrans));

  public static LTDescr rotate(RectTransform rectTrans, float to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCanvasRotateAround().setRect(rectTrans).setAxis(Vector3.forward));

  public static LTDescr rotate(RectTransform rectTrans, Vector3 to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, to, time, LeanTween.options().setCanvasRotateAround().setRect(rectTrans).setAxis(Vector3.forward));

  public static LTDescr rotateAround(RectTransform rectTrans, Vector3 axis, float to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCanvasRotateAround().setRect(rectTrans).setAxis(axis));

  public static LTDescr rotateAroundLocal(
    RectTransform rectTrans,
    Vector3 axis,
    float to,
    float time)
  {
    return LeanTween.pushNewTween(rectTrans.gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCanvasRotateAroundLocal().setRect(rectTrans).setAxis(axis));
  }

  public static LTDescr scale(RectTransform rectTrans, Vector3 to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, to, time, LeanTween.options().setCanvasScale().setRect(rectTrans));

  public static LTDescr size(RectTransform rectTrans, Vector2 to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, (Vector3) to, time, LeanTween.options().setCanvasSizeDelta().setRect(rectTrans));

  public static LTDescr alpha(RectTransform rectTrans, float to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, new Vector3(to, 0.0f, 0.0f), time, LeanTween.options().setCanvasAlpha().setRect(rectTrans));

  public static LTDescr color(RectTransform rectTrans, Color to, float time) => LeanTween.pushNewTween(rectTrans.gameObject, new Vector3(1f, to.a, 0.0f), time, LeanTween.options().setCanvasColor().setRect(rectTrans).setPoint(new Vector3(to.r, to.g, to.b)));

  public static float tweenOnCurve(LTDescr tweenDescr, float ratioPassed) => tweenDescr.from.x + tweenDescr.diff.x * tweenDescr.optional.animationCurve.Evaluate(ratioPassed);

  public static Vector3 tweenOnCurveVector(LTDescr tweenDescr, float ratioPassed) => new Vector3(tweenDescr.from.x + tweenDescr.diff.x * tweenDescr.optional.animationCurve.Evaluate(ratioPassed), tweenDescr.from.y + tweenDescr.diff.y * tweenDescr.optional.animationCurve.Evaluate(ratioPassed), tweenDescr.from.z + tweenDescr.diff.z * tweenDescr.optional.animationCurve.Evaluate(ratioPassed));

  public static float easeOutQuadOpt(float start, float diff, float ratioPassed) => (float) (-(double) diff * (double) ratioPassed * ((double) ratioPassed - 2.0)) + start;

  public static float easeInQuadOpt(float start, float diff, float ratioPassed) => diff * ratioPassed * ratioPassed + start;

  public static float easeInOutQuadOpt(float start, float diff, float ratioPassed)
  {
    ratioPassed /= 0.5f;
    if ((double) ratioPassed < 1.0)
      return diff / 2f * ratioPassed * ratioPassed + start;
    --ratioPassed;
    return (float) (-(double) diff / 2.0 * ((double) ratioPassed * ((double) ratioPassed - 2.0) - 1.0)) + start;
  }

  public static Vector3 easeInOutQuadOpt(Vector3 start, Vector3 diff, float ratioPassed)
  {
    ratioPassed /= 0.5f;
    if ((double) ratioPassed < 1.0)
      return diff / 2f * ratioPassed * ratioPassed + start;
    --ratioPassed;
    return -diff / 2f * (float) ((double) ratioPassed * ((double) ratioPassed - 2.0) - 1.0) + start;
  }

  public static float linear(float start, float end, float val) => Mathf.Lerp(start, end, val);

  public static float clerp(float start, float end, float val)
  {
    float num1 = 0.0f;
    float num2 = 360f;
    float num3 = Mathf.Abs((float) (((double) num2 - (double) num1) / 2.0));
    float num4;
    if ((double) end - (double) start < -(double) num3)
    {
      float num5 = (num2 - start + end) * val;
      num4 = start + num5;
    }
    else if ((double) end - (double) start > (double) num3)
    {
      float num6 = (float) -((double) num2 - (double) end + (double) start) * val;
      num4 = start + num6;
    }
    else
      num4 = start + (end - start) * val;
    return num4;
  }

  public static float spring(float start, float end, float val)
  {
    val = Mathf.Clamp01(val);
    val = (float) (((double) Mathf.Sin((float) ((double) val * 3.1415927410125732 * (0.20000000298023224 + 2.5 * (double) val * (double) val * (double) val))) * (double) Mathf.Pow(1f - val, 2.2f) + (double) val) * (1.0 + 1.2000000476837158 * (1.0 - (double) val)));
    return start + (end - start) * val;
  }

  public static float easeInQuad(float start, float end, float val)
  {
    end -= start;
    return end * val * val + start;
  }

  public static float easeOutQuad(float start, float end, float val)
  {
    end -= start;
    return (float) (-(double) end * (double) val * ((double) val - 2.0)) + start;
  }

  public static float easeInOutQuad(float start, float end, float val)
  {
    val /= 0.5f;
    end -= start;
    if ((double) val < 1.0)
      return end / 2f * val * val + start;
    --val;
    return (float) (-(double) end / 2.0 * ((double) val * ((double) val - 2.0) - 1.0)) + start;
  }

  public static float easeInOutQuadOpt2(float start, float diffBy2, float val, float val2)
  {
    val /= 0.5f;
    if ((double) val < 1.0)
      return diffBy2 * val2 + start;
    --val;
    return (float) (-(double) diffBy2 * ((double) val2 - 2.0 - 1.0)) + start;
  }

  public static float easeInCubic(float start, float end, float val)
  {
    end -= start;
    return end * val * val * val + start;
  }

  public static float easeOutCubic(float start, float end, float val)
  {
    --val;
    end -= start;
    return end * (float) ((double) val * (double) val * (double) val + 1.0) + start;
  }

  public static float easeInOutCubic(float start, float end, float val)
  {
    val /= 0.5f;
    end -= start;
    if ((double) val < 1.0)
      return end / 2f * val * val * val + start;
    val -= 2f;
    return (float) ((double) end / 2.0 * ((double) val * (double) val * (double) val + 2.0)) + start;
  }

  public static float easeInQuart(float start, float end, float val)
  {
    end -= start;
    return end * val * val * val * val + start;
  }

  public static float easeOutQuart(float start, float end, float val)
  {
    --val;
    end -= start;
    return (float) (-(double) end * ((double) val * (double) val * (double) val * (double) val - 1.0)) + start;
  }

  public static float easeInOutQuart(float start, float end, float val)
  {
    val /= 0.5f;
    end -= start;
    if ((double) val < 1.0)
      return end / 2f * val * val * val * val + start;
    val -= 2f;
    return (float) (-(double) end / 2.0 * ((double) val * (double) val * (double) val * (double) val - 2.0)) + start;
  }

  public static float easeInQuint(float start, float end, float val)
  {
    end -= start;
    return end * val * val * val * val * val + start;
  }

  public static float easeOutQuint(float start, float end, float val)
  {
    --val;
    end -= start;
    return end * (float) ((double) val * (double) val * (double) val * (double) val * (double) val + 1.0) + start;
  }

  public static float easeInOutQuint(float start, float end, float val)
  {
    val /= 0.5f;
    end -= start;
    if ((double) val < 1.0)
      return end / 2f * val * val * val * val * val + start;
    val -= 2f;
    return (float) ((double) end / 2.0 * ((double) val * (double) val * (double) val * (double) val * (double) val + 2.0)) + start;
  }

  public static float easeInSine(float start, float end, float val)
  {
    end -= start;
    return -end * Mathf.Cos((float) ((double) val / 1.0 * 1.5707963705062866)) + end + start;
  }

  public static float easeOutSine(float start, float end, float val)
  {
    end -= start;
    return end * Mathf.Sin((float) ((double) val / 1.0 * 1.5707963705062866)) + start;
  }

  public static float easeInOutSine(float start, float end, float val)
  {
    end -= start;
    return (float) (-(double) end / 2.0 * ((double) Mathf.Cos((float) (3.1415927410125732 * (double) val / 1.0)) - 1.0)) + start;
  }

  public static float easeInExpo(float start, float end, float val)
  {
    end -= start;
    return end * Mathf.Pow(2f, (float) (10.0 * ((double) val / 1.0 - 1.0))) + start;
  }

  public static float easeOutExpo(float start, float end, float val)
  {
    end -= start;
    return end * (float) (-(double) Mathf.Pow(2f, (float) (-10.0 * (double) val / 1.0)) + 1.0) + start;
  }

  public static float easeInOutExpo(float start, float end, float val)
  {
    val /= 0.5f;
    end -= start;
    if ((double) val < 1.0)
      return end / 2f * Mathf.Pow(2f, (float) (10.0 * ((double) val - 1.0))) + start;
    --val;
    return (float) ((double) end / 2.0 * (-(double) Mathf.Pow(2f, -10f * val) + 2.0)) + start;
  }

  public static float easeInCirc(float start, float end, float val)
  {
    end -= start;
    return (float) (-(double) end * ((double) Mathf.Sqrt((float) (1.0 - (double) val * (double) val)) - 1.0)) + start;
  }

  public static float easeOutCirc(float start, float end, float val)
  {
    --val;
    end -= start;
    return end * Mathf.Sqrt((float) (1.0 - (double) val * (double) val)) + start;
  }

  public static float easeInOutCirc(float start, float end, float val)
  {
    val /= 0.5f;
    end -= start;
    if ((double) val < 1.0)
      return (float) (-(double) end / 2.0 * ((double) Mathf.Sqrt((float) (1.0 - (double) val * (double) val)) - 1.0)) + start;
    val -= 2f;
    return (float) ((double) end / 2.0 * ((double) Mathf.Sqrt((float) (1.0 - (double) val * (double) val)) + 1.0)) + start;
  }

  public static float easeInBounce(float start, float end, float val)
  {
    end -= start;
    float num = 1f;
    return end - LeanTween.easeOutBounce(0.0f, end, num - val) + start;
  }

  public static float easeOutBounce(float start, float end, float val)
  {
    val /= 1f;
    end -= start;
    if ((double) val < 0.36363637447357178)
      return end * (121f / 16f * val * val) + start;
    if ((double) val < 0.72727274894714355)
    {
      val -= 0.545454562f;
      return end * (float) (121.0 / 16.0 * (double) val * (double) val + 0.75) + start;
    }
    if ((double) val < 10.0 / 11.0)
    {
      val -= 0.8181818f;
      return end * (float) (121.0 / 16.0 * (double) val * (double) val + 15.0 / 16.0) + start;
    }
    val -= 0.954545438f;
    return end * (float) (121.0 / 16.0 * (double) val * (double) val + 63.0 / 64.0) + start;
  }

  public static float easeInOutBounce(float start, float end, float val)
  {
    end -= start;
    float num = 1f;
    return (double) val < (double) num / 2.0 ? LeanTween.easeInBounce(0.0f, end, val * 2f) * 0.5f + start : (float) ((double) LeanTween.easeOutBounce(0.0f, end, val * 2f - num) * 0.5 + (double) end * 0.5) + start;
  }

  public static float easeInBack(float start, float end, float val, float overshoot = 1f)
  {
    end -= start;
    val /= 1f;
    float num = 1.70158f * overshoot;
    return (float) ((double) end * (double) val * (double) val * (((double) num + 1.0) * (double) val - (double) num)) + start;
  }

  public static float easeOutBack(float start, float end, float val, float overshoot = 1f)
  {
    float num = 1.70158f * overshoot;
    end -= start;
    val = (float) ((double) val / 1.0 - 1.0);
    return end * (float) ((double) val * (double) val * (((double) num + 1.0) * (double) val + (double) num) + 1.0) + start;
  }

  public static float easeInOutBack(float start, float end, float val, float overshoot = 1f)
  {
    float num1 = 1.70158f * overshoot;
    end -= start;
    val /= 0.5f;
    if ((double) val < 1.0)
    {
      float num2 = num1 * (1.525f * overshoot);
      return (float) ((double) end / 2.0 * ((double) val * (double) val * (((double) num2 + 1.0) * (double) val - (double) num2))) + start;
    }
    val -= 2f;
    float num3 = num1 * (1.525f * overshoot);
    return (float) ((double) end / 2.0 * ((double) val * (double) val * (((double) num3 + 1.0) * (double) val + (double) num3) + 2.0)) + start;
  }

  public static float easeInElastic(
    float start,
    float end,
    float val,
    float overshoot = 1f,
    float period = 0.3f)
  {
    end -= start;
    float num1 = period;
    float num2 = 0.0f;
    if ((double) val == 0.0)
      return start;
    if ((double) val == 1.0)
      return start + end;
    float num3;
    if ((double) num2 == 0.0 || (double) num2 < (double) Mathf.Abs(end))
    {
      num2 = end;
      num3 = num1 / 4f;
    }
    else
      num3 = num1 / 6.28318548f * Mathf.Asin(end / num2);
    if ((double) overshoot > 1.0 && (double) val > 0.60000002384185791)
      overshoot = (float) (1.0 + (1.0 - (double) val) / 0.40000000596046448 * ((double) overshoot - 1.0));
    --val;
    return start - num2 * Mathf.Pow(2f, 10f * val) * Mathf.Sin((float) (((double) val - (double) num3) * 6.2831854820251465) / num1) * overshoot;
  }

  public static float easeOutElastic(
    float start,
    float end,
    float val,
    float overshoot = 1f,
    float period = 0.3f)
  {
    end -= start;
    float num1 = period;
    float num2 = 0.0f;
    if ((double) val == 0.0)
      return start;
    if ((double) val == 1.0)
      return start + end;
    float num3;
    if ((double) num2 == 0.0 || (double) num2 < (double) Mathf.Abs(end))
    {
      num2 = end;
      num3 = num1 / 4f;
    }
    else
      num3 = num1 / 6.28318548f * Mathf.Asin(end / num2);
    if ((double) overshoot > 1.0 && (double) val < 0.40000000596046448)
      overshoot = (float) (1.0 + (double) val / 0.40000000596046448 * ((double) overshoot - 1.0));
    return (float) ((double) start + (double) end + (double) num2 * (double) Mathf.Pow(2f, -10f * val) * (double) Mathf.Sin((float) (((double) val - (double) num3) * 6.2831854820251465) / num1) * (double) overshoot);
  }

  public static float easeInOutElastic(
    float start,
    float end,
    float val,
    float overshoot = 1f,
    float period = 0.3f)
  {
    end -= start;
    float num1 = period;
    float num2 = 0.0f;
    if ((double) val == 0.0)
      return start;
    val /= 0.5f;
    if ((double) val == 2.0)
      return start + end;
    float num3;
    if ((double) num2 == 0.0 || (double) num2 < (double) Mathf.Abs(end))
    {
      num2 = end;
      num3 = num1 / 4f;
    }
    else
      num3 = num1 / 6.28318548f * Mathf.Asin(end / num2);
    if ((double) overshoot > 1.0)
    {
      if ((double) val < 0.20000000298023224)
        overshoot = (float) (1.0 + (double) val / 0.20000000298023224 * ((double) overshoot - 1.0));
      else if ((double) val > 0.800000011920929)
        overshoot = (float) (1.0 + (1.0 - (double) val) / 0.20000000298023224 * ((double) overshoot - 1.0));
    }
    if ((double) val < 1.0)
    {
      --val;
      return start - (float) (0.5 * ((double) num2 * (double) Mathf.Pow(2f, 10f * val) * (double) Mathf.Sin((float) (((double) val - (double) num3) * 6.2831854820251465) / num1))) * overshoot;
    }
    --val;
    return (float) ((double) end + (double) start + (double) num2 * (double) Mathf.Pow(2f, -10f * val) * (double) Mathf.Sin((float) (((double) val - (double) num3) * 6.2831854820251465) / num1) * 0.5 * (double) overshoot);
  }

  public static LTDescr followDamp(
    Transform trans,
    Transform target,
    LeanProp prop,
    float smoothTime,
    float maxSpeed = -1f)
  {
    LTDescr d = LeanTween.pushNewTween(trans.gameObject, Vector3.zero, float.MaxValue, LeanTween.options().setFollow().setTarget(target));
    switch (prop)
    {
      case LeanProp.position:
        d.diff = d.trans.position;
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          d.optional.axis = LeanSmooth.damp(d.optional.axis, d.toTrans.position, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime);
          d.trans.position = d.optional.axis + d.toInternal;
        });
        break;
      case LeanProp.localPosition:
        d.optional.axis = d.trans.localPosition;
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          d.optional.axis = LeanSmooth.damp(d.optional.axis, d.toTrans.localPosition, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime);
          d.trans.localPosition = d.optional.axis + d.toInternal;
        });
        break;
      case LeanProp.x:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosX(LeanSmooth.damp(d.trans.position.x, d.toTrans.position.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime)));
        break;
      case LeanProp.y:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosY(LeanSmooth.damp(d.trans.position.y, d.toTrans.position.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime)));
        break;
      case LeanProp.z:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosZ(LeanSmooth.damp(d.trans.position.z, d.toTrans.position.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime)));
        break;
      case LeanProp.localX:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosX(LeanSmooth.damp(d.trans.localPosition.x, d.toTrans.localPosition.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime)));
        break;
      case LeanProp.localY:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosY(LeanSmooth.damp(d.trans.localPosition.y, d.toTrans.localPosition.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime)));
        break;
      case LeanProp.localZ:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosZ(LeanSmooth.damp(d.trans.localPosition.z, d.toTrans.localPosition.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime)));
        break;
      case LeanProp.scale:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.localScale = LeanSmooth.damp(d.trans.localScale, d.toTrans.localScale, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime));
        break;
      case LeanProp.color:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          Color color = LeanSmooth.damp(d.trans.LeanColor(), d.toTrans.LeanColor(), ref d.optional.color, smoothTime, maxSpeed, Time.deltaTime);
          d.trans.GetComponent<Renderer>().material.color = color;
        });
        break;
    }
    return d;
  }

  public static LTDescr followSpring(
    Transform trans,
    Transform target,
    LeanProp prop,
    float smoothTime,
    float maxSpeed = -1f,
    float friction = 2f,
    float accelRate = 0.5f)
  {
    LTDescr d = LeanTween.pushNewTween(trans.gameObject, Vector3.zero, float.MaxValue, LeanTween.options().setFollow().setTarget(target));
    switch (prop)
    {
      case LeanProp.position:
        d.diff = d.trans.position;
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          d.diff = LeanSmooth.spring(d.diff, d.toTrans.position, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
          d.trans.position = d.diff;
        });
        break;
      case LeanProp.localPosition:
        d.optional.axis = d.trans.localPosition;
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          d.optional.axis = LeanSmooth.spring(d.optional.axis, d.toTrans.localPosition, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
          d.trans.localPosition = d.optional.axis + d.toInternal;
        });
        break;
      case LeanProp.x:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosX(LeanSmooth.spring(d.trans.position.x, d.toTrans.position.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate)));
        break;
      case LeanProp.y:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosY(LeanSmooth.spring(d.trans.position.y, d.toTrans.position.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate)));
        break;
      case LeanProp.z:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosZ(LeanSmooth.spring(d.trans.position.z, d.toTrans.position.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate)));
        break;
      case LeanProp.localX:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosX(LeanSmooth.spring(d.trans.localPosition.x, d.toTrans.localPosition.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate)));
        break;
      case LeanProp.localY:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosY(LeanSmooth.spring(d.trans.localPosition.y, d.toTrans.localPosition.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate)));
        break;
      case LeanProp.localZ:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosZ(LeanSmooth.spring(d.trans.localPosition.z, d.toTrans.localPosition.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate)));
        break;
      case LeanProp.scale:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.localScale = LeanSmooth.spring(d.trans.localScale, d.toTrans.localScale, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
        break;
      case LeanProp.color:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          Color color = LeanSmooth.spring(d.trans.LeanColor(), d.toTrans.LeanColor(), ref d.optional.color, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
          d.trans.GetComponent<Renderer>().material.color = color;
        });
        break;
    }
    return d;
  }

  public static LTDescr followBounceOut(
    Transform trans,
    Transform target,
    LeanProp prop,
    float smoothTime,
    float maxSpeed = -1f,
    float friction = 2f,
    float accelRate = 0.5f,
    float hitDamping = 0.9f)
  {
    LTDescr d = LeanTween.pushNewTween(trans.gameObject, Vector3.zero, float.MaxValue, LeanTween.options().setFollow().setTarget(target));
    switch (prop)
    {
      case LeanProp.position:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          d.optional.axis = LeanSmooth.bounceOut(d.optional.axis, d.toTrans.position, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
          d.trans.position = d.optional.axis + d.toInternal;
        });
        break;
      case LeanProp.localPosition:
        d.optional.axis = d.trans.localPosition;
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          d.optional.axis = LeanSmooth.bounceOut(d.optional.axis, d.toTrans.localPosition, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
          d.trans.localPosition = d.optional.axis + d.toInternal;
        });
        break;
      case LeanProp.x:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosX(LeanSmooth.bounceOut(d.trans.position.x, d.toTrans.position.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping)));
        break;
      case LeanProp.y:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosY(LeanSmooth.bounceOut(d.trans.position.y, d.toTrans.position.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping)));
        break;
      case LeanProp.z:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosZ(LeanSmooth.bounceOut(d.trans.position.z, d.toTrans.position.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping)));
        break;
      case LeanProp.localX:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosX(LeanSmooth.bounceOut(d.trans.localPosition.x, d.toTrans.localPosition.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping)));
        break;
      case LeanProp.localY:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosY(LeanSmooth.bounceOut(d.trans.localPosition.y, d.toTrans.localPosition.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping)));
        break;
      case LeanProp.localZ:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosZ(LeanSmooth.bounceOut(d.trans.localPosition.z, d.toTrans.localPosition.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping)));
        break;
      case LeanProp.scale:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.localScale = LeanSmooth.bounceOut(d.trans.localScale, d.toTrans.localScale, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
        break;
      case LeanProp.color:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          Color color = LeanSmooth.bounceOut(d.trans.LeanColor(), d.toTrans.LeanColor(), ref d.optional.color, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
          d.trans.GetComponent<Renderer>().material.color = color;
        });
        break;
    }
    return d;
  }

  public static LTDescr followLinear(
    Transform trans,
    Transform target,
    LeanProp prop,
    float moveSpeed)
  {
    LTDescr d = LeanTween.pushNewTween(trans.gameObject, Vector3.zero, float.MaxValue, LeanTween.options().setFollow().setTarget(target));
    switch (prop)
    {
      case LeanProp.position:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.position = LeanSmooth.linear(d.trans.position, d.toTrans.position, moveSpeed));
        break;
      case LeanProp.localPosition:
        d.optional.axis = d.trans.localPosition;
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          d.optional.axis = LeanSmooth.linear(d.optional.axis, d.toTrans.localPosition, moveSpeed);
          d.trans.localPosition = d.optional.axis + d.toInternal;
        });
        break;
      case LeanProp.x:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosX(LeanSmooth.linear(d.trans.position.x, d.toTrans.position.x, moveSpeed)));
        break;
      case LeanProp.y:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosY(LeanSmooth.linear(d.trans.position.y, d.toTrans.position.y, moveSpeed)));
        break;
      case LeanProp.z:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetPosZ(LeanSmooth.linear(d.trans.position.z, d.toTrans.position.z, moveSpeed)));
        break;
      case LeanProp.localX:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosX(LeanSmooth.linear(d.trans.localPosition.x, d.toTrans.localPosition.x, moveSpeed)));
        break;
      case LeanProp.localY:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosY(LeanSmooth.linear(d.trans.localPosition.y, d.toTrans.localPosition.y, moveSpeed)));
        break;
      case LeanProp.localZ:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.LeanSetLocalPosZ(LeanSmooth.linear(d.trans.localPosition.z, d.toTrans.localPosition.z, moveSpeed)));
        break;
      case LeanProp.scale:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() => d.trans.localScale = LeanSmooth.linear(d.trans.localScale, d.toTrans.localScale, moveSpeed));
        break;
      case LeanProp.color:
        d.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
        {
          Color color = LeanSmooth.linear(d.trans.LeanColor(), d.toTrans.LeanColor(), moveSpeed);
          d.trans.GetComponent<Renderer>().material.color = color;
        });
        break;
    }
    return d;
  }

  public static void addListener(int eventId, Action<LTEvent> callback) => LeanTween.addListener(LeanTween.tweenEmpty, eventId, callback);

  public static void addListener(GameObject caller, int eventId, Action<LTEvent> callback)
  {
    if (LeanTween.eventListeners == null)
    {
      LeanTween.INIT_LISTENERS_MAX = LeanTween.LISTENERS_MAX;
      LeanTween.eventListeners = new Action<LTEvent>[LeanTween.EVENTS_MAX * LeanTween.LISTENERS_MAX];
      LeanTween.goListeners = new GameObject[LeanTween.EVENTS_MAX * LeanTween.LISTENERS_MAX];
    }
    for (LeanTween.i = 0; LeanTween.i < LeanTween.INIT_LISTENERS_MAX; ++LeanTween.i)
    {
      int index = eventId * LeanTween.INIT_LISTENERS_MAX + LeanTween.i;
      if ((UnityEngine.Object) LeanTween.goListeners[index] == (UnityEngine.Object) null || LeanTween.eventListeners[index] == null)
      {
        LeanTween.eventListeners[index] = callback;
        LeanTween.goListeners[index] = caller;
        if (LeanTween.i < LeanTween.eventsMaxSearch)
          return;
        LeanTween.eventsMaxSearch = LeanTween.i + 1;
        return;
      }
      if ((UnityEngine.Object) LeanTween.goListeners[index] == (UnityEngine.Object) caller && object.Equals((object) LeanTween.eventListeners[index], (object) callback))
        return;
    }
    Debug.LogError((object) ("You ran out of areas to add listeners, consider increasing LISTENERS_MAX, ex: LeanTween.LISTENERS_MAX = " + (LeanTween.LISTENERS_MAX * 2).ToString()));
  }

  public static bool removeListener(int eventId, Action<LTEvent> callback) => LeanTween.removeListener(LeanTween.tweenEmpty, eventId, callback);

  public static bool removeListener(int eventId)
  {
    int index = eventId * LeanTween.INIT_LISTENERS_MAX + LeanTween.i;
    LeanTween.eventListeners[index] = (Action<LTEvent>) null;
    LeanTween.goListeners[index] = (GameObject) null;
    return true;
  }

  public static bool removeListener(GameObject caller, int eventId, Action<LTEvent> callback)
  {
    for (LeanTween.i = 0; LeanTween.i < LeanTween.eventsMaxSearch; ++LeanTween.i)
    {
      int index = eventId * LeanTween.INIT_LISTENERS_MAX + LeanTween.i;
      if ((UnityEngine.Object) LeanTween.goListeners[index] == (UnityEngine.Object) caller && object.Equals((object) LeanTween.eventListeners[index], (object) callback))
      {
        LeanTween.eventListeners[index] = (Action<LTEvent>) null;
        LeanTween.goListeners[index] = (GameObject) null;
        return true;
      }
    }
    return false;
  }

  public static void dispatchEvent(int eventId) => LeanTween.dispatchEvent(eventId, (object) null);

  public static void dispatchEvent(int eventId, object data)
  {
    for (int index1 = 0; index1 < LeanTween.eventsMaxSearch; ++index1)
    {
      int index2 = eventId * LeanTween.INIT_LISTENERS_MAX + index1;
      if (LeanTween.eventListeners[index2] != null)
      {
        if ((bool) (UnityEngine.Object) LeanTween.goListeners[index2])
          LeanTween.eventListeners[index2](new LTEvent(eventId, data));
        else
          LeanTween.eventListeners[index2] = (Action<LTEvent>) null;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LeanTweenExt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public static class LeanTweenExt
{
  public static LTDescr LeanAlpha(this GameObject gameObject, float to, float time) => LeanTween.alpha(gameObject, to, time);

  public static LTDescr LeanAlphaVertex(this GameObject gameObject, float to, float time) => LeanTween.alphaVertex(gameObject, to, time);

  public static LTDescr LeanAlpha(this RectTransform rectTransform, float to, float time) => LeanTween.alpha(rectTransform, to, time);

  public static LTDescr LeanAlpha(this CanvasGroup canvas, float to, float time) => LeanTween.alphaCanvas(canvas, to, time);

  public static LTDescr LeanAlphaText(this RectTransform rectTransform, float to, float time) => LeanTween.alphaText(rectTransform, to, time);

  public static void LeanCancel(this GameObject gameObject) => LeanTween.cancel(gameObject);

  public static void LeanCancel(this GameObject gameObject, bool callOnComplete) => LeanTween.cancel(gameObject, callOnComplete);

  public static void LeanCancel(this GameObject gameObject, int uniqueId, bool callOnComplete = false) => LeanTween.cancel(gameObject, uniqueId, callOnComplete);

  public static void LeanCancel(this RectTransform rectTransform) => LeanTween.cancel(rectTransform);

  public static LTDescr LeanColor(this GameObject gameObject, Color to, float time) => LeanTween.color(gameObject, to, time);

  public static LTDescr LeanColorText(this RectTransform rectTransform, Color to, float time) => LeanTween.colorText(rectTransform, to, time);

  public static LTDescr LeanDelayedCall(
    this GameObject gameObject,
    float delayTime,
    System.Action callback)
  {
    return LeanTween.delayedCall(gameObject, delayTime, callback);
  }

  public static LTDescr LeanDelayedCall(
    this GameObject gameObject,
    float delayTime,
    Action<object> callback)
  {
    return LeanTween.delayedCall(gameObject, delayTime, callback);
  }

  public static bool LeanIsPaused(this GameObject gameObject) => LeanTween.isPaused(gameObject);

  public static bool LeanIsPaused(this RectTransform rectTransform) => LeanTween.isPaused(rectTransform);

  public static bool LeanIsTweening(this GameObject gameObject) => LeanTween.isTweening(gameObject);

  public static LTDescr LeanMove(this GameObject gameObject, Vector3 to, float time) => LeanTween.move(gameObject, to, time);

  public static LTDescr LeanMove(this Transform transform, Vector3 to, float time) => LeanTween.move(transform.gameObject, to, time);

  public static LTDescr LeanMove(this RectTransform rectTransform, Vector3 to, float time) => LeanTween.move(rectTransform, to, time);

  public static LTDescr LeanMove(this GameObject gameObject, Vector2 to, float time) => LeanTween.move(gameObject, to, time);

  public static LTDescr LeanMove(this Transform transform, Vector2 to, float time) => LeanTween.move(transform.gameObject, to, time);

  public static LTDescr LeanMove(this GameObject gameObject, Vector3[] to, float time) => LeanTween.move(gameObject, to, time);

  public static LTDescr LeanMove(this GameObject gameObject, LTBezierPath to, float time) => LeanTween.move(gameObject, to, time);

  public static LTDescr LeanMove(this GameObject gameObject, LTSpline to, float time) => LeanTween.move(gameObject, to, time);

  public static LTDescr LeanMove(this Transform transform, Vector3[] to, float time) => LeanTween.move(transform.gameObject, to, time);

  public static LTDescr LeanMove(this Transform transform, LTBezierPath to, float time) => LeanTween.move(transform.gameObject, to, time);

  public static LTDescr LeanMove(this Transform transform, LTSpline to, float time) => LeanTween.move(transform.gameObject, to, time);

  public static LTDescr LeanMoveLocal(this GameObject gameObject, Vector3 to, float time) => LeanTween.moveLocal(gameObject, to, time);

  public static LTDescr LeanMoveLocal(this GameObject gameObject, LTBezierPath to, float time) => LeanTween.moveLocal(gameObject, to, time);

  public static LTDescr LeanMoveLocal(this GameObject gameObject, LTSpline to, float time) => LeanTween.moveLocal(gameObject, to, time);

  public static LTDescr LeanMoveLocal(this Transform transform, Vector3 to, float time) => LeanTween.moveLocal(transform.gameObject, to, time);

  public static LTDescr LeanMoveLocal(this Transform transform, LTBezierPath to, float time) => LeanTween.moveLocal(transform.gameObject, to, time);

  public static LTDescr LeanMoveLocal(this Transform transform, LTSpline to, float time) => LeanTween.moveLocal(transform.gameObject, to, time);

  public static LTDescr LeanMoveLocalX(this GameObject gameObject, float to, float time) => LeanTween.moveLocalX(gameObject, to, time);

  public static LTDescr LeanMoveLocalY(this GameObject gameObject, float to, float time) => LeanTween.moveLocalY(gameObject, to, time);

  public static LTDescr LeanMoveLocalZ(this GameObject gameObject, float to, float time) => LeanTween.moveLocalZ(gameObject, to, time);

  public static LTDescr LeanMoveLocalX(this Transform transform, float to, float time) => LeanTween.moveLocalX(transform.gameObject, to, time);

  public static LTDescr LeanMoveLocalY(this Transform transform, float to, float time) => LeanTween.moveLocalY(transform.gameObject, to, time);

  public static LTDescr LeanMoveLocalZ(this Transform transform, float to, float time) => LeanTween.moveLocalZ(transform.gameObject, to, time);

  public static LTDescr LeanMoveSpline(this GameObject gameObject, Vector3[] to, float time) => LeanTween.moveSpline(gameObject, to, time);

  public static LTDescr LeanMoveSpline(this GameObject gameObject, LTSpline to, float time) => LeanTween.moveSpline(gameObject, to, time);

  public static LTDescr LeanMoveSpline(this Transform transform, Vector3[] to, float time) => LeanTween.moveSpline(transform.gameObject, to, time);

  public static LTDescr LeanMoveSpline(this Transform transform, LTSpline to, float time) => LeanTween.moveSpline(transform.gameObject, to, time);

  public static LTDescr LeanMoveSplineLocal(this GameObject gameObject, Vector3[] to, float time) => LeanTween.moveSplineLocal(gameObject, to, time);

  public static LTDescr LeanMoveSplineLocal(this Transform transform, Vector3[] to, float time) => LeanTween.moveSplineLocal(transform.gameObject, to, time);

  public static LTDescr LeanMoveX(this GameObject gameObject, float to, float time) => LeanTween.moveX(gameObject, to, time);

  public static LTDescr LeanMoveX(this Transform transform, float to, float time) => LeanTween.moveX(transform.gameObject, to, time);

  public static LTDescr LeanMoveX(this RectTransform rectTransform, float to, float time) => LeanTween.moveX(rectTransform, to, time);

  public static LTDescr LeanMoveY(this GameObject gameObject, float to, float time) => LeanTween.moveY(gameObject, to, time);

  public static LTDescr LeanMoveY(this Transform transform, float to, float time) => LeanTween.moveY(transform.gameObject, to, time);

  public static LTDescr LeanMoveY(this RectTransform rectTransform, float to, float time) => LeanTween.moveY(rectTransform, to, time);

  public static LTDescr LeanMoveZ(this GameObject gameObject, float to, float time) => LeanTween.moveZ(gameObject, to, time);

  public static LTDescr LeanMoveZ(this Transform transform, float to, float time) => LeanTween.moveZ(transform.gameObject, to, time);

  public static LTDescr LeanMoveZ(this RectTransform rectTransform, float to, float time) => LeanTween.moveZ(rectTransform, to, time);

  public static void LeanPause(this GameObject gameObject) => LeanTween.pause(gameObject);

  public static LTDescr LeanPlay(this RectTransform rectTransform, Sprite[] sprites) => LeanTween.play(rectTransform, sprites);

  public static void LeanResume(this GameObject gameObject) => LeanTween.resume(gameObject);

  public static LTDescr LeanRotate(this GameObject gameObject, Vector3 to, float time) => LeanTween.rotate(gameObject, to, time);

  public static LTDescr LeanRotate(this Transform transform, Vector3 to, float time) => LeanTween.rotate(transform.gameObject, to, time);

  public static LTDescr LeanRotate(this RectTransform rectTransform, Vector3 to, float time) => LeanTween.rotate(rectTransform, to, time);

  public static LTDescr LeanRotateAround(
    this GameObject gameObject,
    Vector3 axis,
    float add,
    float time)
  {
    return LeanTween.rotateAround(gameObject, axis, add, time);
  }

  public static LTDescr LeanRotateAround(
    this Transform transform,
    Vector3 axis,
    float add,
    float time)
  {
    return LeanTween.rotateAround(transform.gameObject, axis, add, time);
  }

  public static LTDescr LeanRotateAround(
    this RectTransform rectTransform,
    Vector3 axis,
    float add,
    float time)
  {
    return LeanTween.rotateAround(rectTransform, axis, add, time);
  }

  public static LTDescr LeanRotateAroundLocal(
    this GameObject gameObject,
    Vector3 axis,
    float add,
    float time)
  {
    return LeanTween.rotateAroundLocal(gameObject, axis, add, time);
  }

  public static LTDescr LeanRotateAroundLocal(
    this Transform transform,
    Vector3 axis,
    float add,
    float time)
  {
    return LeanTween.rotateAroundLocal(transform.gameObject, axis, add, time);
  }

  public static LTDescr LeanRotateAroundLocal(
    this RectTransform rectTransform,
    Vector3 axis,
    float add,
    float time)
  {
    return LeanTween.rotateAroundLocal(rectTransform, axis, add, time);
  }

  public static LTDescr LeanRotateX(this GameObject gameObject, float to, float time) => LeanTween.rotateX(gameObject, to, time);

  public static LTDescr LeanRotateX(this Transform transform, float to, float time) => LeanTween.rotateX(transform.gameObject, to, time);

  public static LTDescr LeanRotateY(this GameObject gameObject, float to, float time) => LeanTween.rotateY(gameObject, to, time);

  public static LTDescr LeanRotateY(this Transform transform, float to, float time) => LeanTween.rotateY(transform.gameObject, to, time);

  public static LTDescr LeanRotateZ(this GameObject gameObject, float to, float time) => LeanTween.rotateZ(gameObject, to, time);

  public static LTDescr LeanRotateZ(this Transform transform, float to, float time) => LeanTween.rotateZ(transform.gameObject, to, time);

  public static LTDescr LeanScale(this GameObject gameObject, Vector3 to, float time) => LeanTween.scale(gameObject, to, time);

  public static LTDescr LeanScale(this Transform transform, Vector3 to, float time) => LeanTween.scale(transform.gameObject, to, time);

  public static LTDescr LeanScale(this RectTransform rectTransform, Vector3 to, float time) => LeanTween.scale(rectTransform, to, time);

  public static LTDescr LeanScaleX(this GameObject gameObject, float to, float time) => LeanTween.scaleX(gameObject, to, time);

  public static LTDescr LeanScaleX(this Transform transform, float to, float time) => LeanTween.scaleX(transform.gameObject, to, time);

  public static LTDescr LeanScaleY(this GameObject gameObject, float to, float time) => LeanTween.scaleY(gameObject, to, time);

  public static LTDescr LeanScaleY(this Transform transform, float to, float time) => LeanTween.scaleY(transform.gameObject, to, time);

  public static LTDescr LeanScaleZ(this GameObject gameObject, float to, float time) => LeanTween.scaleZ(gameObject, to, time);

  public static LTDescr LeanScaleZ(this Transform transform, float to, float time) => LeanTween.scaleZ(transform.gameObject, to, time);

  public static LTDescr LeanSize(this RectTransform rectTransform, Vector2 to, float time) => LeanTween.size(rectTransform, to, time);

  public static LTDescr LeanValue(this GameObject gameObject, Color from, Color to, float time) => LeanTween.value(gameObject, from, to, time);

  public static LTDescr LeanValue(this GameObject gameObject, float from, float to, float time) => LeanTween.value(gameObject, from, to, time);

  public static LTDescr LeanValue(
    this GameObject gameObject,
    Vector2 from,
    Vector2 to,
    float time)
  {
    return LeanTween.value(gameObject, from, to, time);
  }

  public static LTDescr LeanValue(
    this GameObject gameObject,
    Vector3 from,
    Vector3 to,
    float time)
  {
    return LeanTween.value(gameObject, from, to, time);
  }

  public static LTDescr LeanValue(
    this GameObject gameObject,
    Action<float> callOnUpdate,
    float from,
    float to,
    float time)
  {
    return LeanTween.value(gameObject, callOnUpdate, from, to, time);
  }

  public static LTDescr LeanValue(
    this GameObject gameObject,
    Action<float, float> callOnUpdate,
    float from,
    float to,
    float time)
  {
    return LeanTween.value(gameObject, callOnUpdate, from, to, time);
  }

  public static LTDescr LeanValue(
    this GameObject gameObject,
    Action<float, object> callOnUpdate,
    float from,
    float to,
    float time)
  {
    return LeanTween.value(gameObject, callOnUpdate, from, to, time);
  }

  public static LTDescr LeanValue(
    this GameObject gameObject,
    Action<Color> callOnUpdate,
    Color from,
    Color to,
    float time)
  {
    return LeanTween.value(gameObject, callOnUpdate, from, to, time);
  }

  public static LTDescr LeanValue(
    this GameObject gameObject,
    Action<Vector2> callOnUpdate,
    Vector2 from,
    Vector2 to,
    float time)
  {
    return LeanTween.value(gameObject, callOnUpdate, from, to, time);
  }

  public static LTDescr LeanValue(
    this GameObject gameObject,
    Action<Vector3> callOnUpdate,
    Vector3 from,
    Vector3 to,
    float time)
  {
    return LeanTween.value(gameObject, callOnUpdate, from, to, time);
  }

  public static void LeanSetPosX(this Transform transform, float val) => transform.position = new Vector3(val, transform.position.y, transform.position.z);

  public static void LeanSetPosY(this Transform transform, float val) => transform.position = new Vector3(transform.position.x, val, transform.position.z);

  public static void LeanSetPosZ(this Transform transform, float val) => transform.position = new Vector3(transform.position.x, transform.position.y, val);

  public static void LeanSetLocalPosX(this Transform transform, float val) => transform.localPosition = new Vector3(val, transform.localPosition.y, transform.localPosition.z);

  public static void LeanSetLocalPosY(this Transform transform, float val) => transform.localPosition = new Vector3(transform.localPosition.x, val, transform.localPosition.z);

  public static void LeanSetLocalPosZ(this Transform transform, float val) => transform.localPosition = new Vector3(transform.localPosition.x, transform.localPosition.y, val);

  public static Color LeanColor(this Transform transform) => transform.GetComponent<Renderer>().material.color;
}
﻿// Decompiled with JetBrains decompiler
// Type: LeanTweenType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public enum LeanTweenType
{
  notUsed,
  linear,
  easeOutQuad,
  easeInQuad,
  easeInOutQuad,
  easeInCubic,
  easeOutCubic,
  easeInOutCubic,
  easeInQuart,
  easeOutQuart,
  easeInOutQuart,
  easeInQuint,
  easeOutQuint,
  easeInOutQuint,
  easeInSine,
  easeOutSine,
  easeInOutSine,
  easeInExpo,
  easeOutExpo,
  easeInOutExpo,
  easeInCirc,
  easeOutCirc,
  easeInOutCirc,
  easeInBounce,
  easeOutBounce,
  easeInOutBounce,
  easeInBack,
  easeOutBack,
  easeInOutBack,
  easeInElastic,
  easeOutElastic,
  easeInOutElastic,
  easeSpring,
  easeShake,
  punch,
  once,
  clamp,
  pingPong,
  animationCurve,
}
﻿// Decompiled with JetBrains decompiler
// Type: Lengthdir
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public static class Lengthdir
{
  public static float X(float len, float radians) => Mathf.Cos(radians) * len;

  public static float Y(float len, float radians) => Mathf.Sin(radians) * len;

  public static Vector2 ToVector2(float len, float radians) => new Vector2(Lengthdir.X(len, radians), Lengthdir.Y(len, radians));
}
﻿// Decompiled with JetBrains decompiler
// Type: Likelihood
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public enum Likelihood
{
  MostToLeast,
  LeastToMost,
  Balanced,
}
﻿// Decompiled with JetBrains decompiler
// Type: LilBerry
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LilBerry : ScriptableCardImage
{
  [SerializeField]
  public Transform image;
  [SerializeField]
  public AnimationCurve scaleCurve;
  [Header("Scale Tween")]
  [SerializeField]
  public AnimationCurve tweenCurve;
  [SerializeField]
  public float tweenDur;
  public float scaleFrom = 1f;
  public float scaleTo = 1f;
  public float tweenT;
  public bool tween;
  public bool currentSet;
  public int current;

  public override void UpdateEvent()
  {
    if (this.currentSet && this.current == this.entity.damage.current)
      return;
    this.currentSet = true;
    this.current = this.entity.damage.current;
    this.SetScale();
  }

  public void SetScale()
  {
    this.scaleFrom = Mathf.Lerp(1f, this.image.localScale.x, 0.5f);
    this.scaleTo = this.scaleCurve.Evaluate((float) this.current);
    this.StartScaleTween();
  }

  public void StartScaleTween()
  {
    this.tween = true;
    this.tweenT = 0.0f;
  }

  public void Update()
  {
    if (!this.tween)
      return;
    this.tweenT += Time.deltaTime / this.tweenDur;
    float num = this.scaleFrom + this.tweenCurve.Evaluate(this.tweenT) * (this.scaleTo - this.scaleFrom);
    this.image.transform.localScale = new Vector3(num, num, 1f);
    if ((double) this.tweenT <= 1.0)
      return;
    this.tween = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LineSmoother
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class LineSmoother : MonoBehaviour
{
  public static Vector3[] SmoothLine(Vector3[] inputPoints, float segmentSize)
  {
    AnimationCurve animationCurve1 = new AnimationCurve();
    AnimationCurve animationCurve2 = new AnimationCurve();
    AnimationCurve animationCurve3 = new AnimationCurve();
    Keyframe[] keyframeArray1 = new Keyframe[inputPoints.Length];
    Keyframe[] keyframeArray2 = new Keyframe[inputPoints.Length];
    Keyframe[] keyframeArray3 = new Keyframe[inputPoints.Length];
    for (int time = 0; time < inputPoints.Length; ++time)
    {
      keyframeArray1[time] = new Keyframe((float) time, inputPoints[time].x);
      keyframeArray2[time] = new Keyframe((float) time, inputPoints[time].y);
      keyframeArray3[time] = new Keyframe((float) time, inputPoints[time].z);
    }
    animationCurve1.keys = keyframeArray1;
    animationCurve2.keys = keyframeArray2;
    animationCurve3.keys = keyframeArray3;
    for (int index = 0; index < inputPoints.Length; ++index)
    {
      animationCurve1.SmoothTangents(index, 0.0f);
      animationCurve2.SmoothTangents(index, 0.0f);
      animationCurve3.SmoothTangents(index, 0.0f);
    }
    List<Vector3> vector3List = new List<Vector3>();
    for (int index1 = 0; index1 < inputPoints.Length; ++index1)
    {
      vector3List.Add(inputPoints[index1]);
      if (index1 + 1 < inputPoints.Length)
      {
        int num = (int) ((double) Vector3.Distance(inputPoints[index1], inputPoints[index1 + 1]) / (double) segmentSize);
        for (int index2 = 1; index2 < num; ++index2)
        {
          float time = (float) index2 / (float) num + (float) index1;
          Vector3 vector3 = new Vector3(animationCurve1.Evaluate(time), animationCurve2.Evaluate(time), animationCurve3.Evaluate(time));
          vector3List.Add(vector3);
        }
      }
    }
    return vector3List.ToArray();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LinkEnable
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class LinkEnable : MonoBehaviour
{
  public GameObject linkTo;

  public void OnEnable() => this.StartCoroutine(this.EnableAfterEndOfFrame());

  public IEnumerator EnableAfterEndOfFrame()
  {
    yield return (object) new WaitForEndOfFrame();
    this.linkTo.gameObject.SetActive(true);
  }

  public void OnDisable()
  {
    this.StopAllCoroutines();
    this.linkTo.gameObject.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LocaleListener
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;

public class LocaleListener : MonoBehaviour
{
  [SerializeField]
  public UnityEvent<Locale> OnLocaleChanged;

  public void OnEnable() => LocalizationSettings.Instance.OnSelectedLocaleChanged += new Action<Locale>(this.LocaleChanged);

  public void OnDisable() => LocalizationSettings.Instance.OnSelectedLocaleChanged -= new Action<Locale>(this.LocaleChanged);

  public void LocaleChanged(Locale locale) => this.OnLocaleChanged?.Invoke(locale);
}
﻿// Decompiled with JetBrains decompiler
// Type: LocalizeActionString
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;

public class LocalizeActionString : MonoBehaviour
{
  [SerializeField]
  public LocalizedString mouseString;
  [SerializeField]
  public LocalizedString joystickString;
  [SerializeField]
  public UnityEvent<string> onUpdate;
  [SerializeField]
  public bool preferTextActions;

  public void OnEnable()
  {
    LocalizationSettings.Instance.OnSelectedLocaleChanged += new Action<Locale>(this.LocaleChanged);
    global::Events.OnButtonStyleChanged += new UnityAction(this.ButtonStyleChanged);
    this.UpdateText();
  }

  public void OnDisable()
  {
    LocalizationSettings.Instance.OnSelectedLocaleChanged -= new Action<Locale>(this.LocaleChanged);
    global::Events.OnButtonStyleChanged -= new UnityAction(this.ButtonStyleChanged);
  }

  public void UpdateText() => this.onUpdate?.Invoke(ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<Cursor3d>.instance.usingMouse ? this.mouseString : this.joystickString, this.preferTextActions));

  public void LocaleChanged(Locale locale) => this.UpdateText();

  public void ButtonStyleChanged() => this.UpdateText();
}
﻿// Decompiled with JetBrains decompiler
// Type: LogSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.IO;
using UnityEngine;

public class LogSystem : GameSystem
{
  public const int backups = 9;
  public const string format = "[{0}] {1}\n";
  public static string toLog = "";
  public static int logDelay = 0;
  public const int logDelayMax = 10;

  public static string directory => Application.persistentDataPath ?? "";

  public static string path => LogSystem.directory + "/Log.log";

  public void OnEnable()
  {
    if (!System.IO.Directory.Exists(LogSystem.directory))
      System.IO.Directory.CreateDirectory(LogSystem.directory);
    LogSystem.CreateBackups();
    Application.logMessageReceived += new Application.LogCallback(LogSystem.Log);
    LogSystem.LogSystemInformation();
  }

  public void OnDisable() => Application.logMessageReceived -= new Application.LogCallback(LogSystem.Log);

  public void OnDestroy()
  {
    if (LogSystem.toLog.IsNullOrEmpty())
      return;
    LogSystem.Write(LogSystem.toLog);
  }

  public void Update()
  {
    if (LogSystem.logDelay < 0)
    {
      if (LogSystem.toLog.IsNullOrEmpty())
        return;
      LogSystem.Write(LogSystem.toLog);
      LogSystem.toLog = "";
      LogSystem.logDelay = 10;
    }
    else
      --LogSystem.logDelay;
  }

  public static void Write(string str)
  {
    using (StreamWriter streamWriter = new StreamWriter(LogSystem.path, true))
      streamWriter.Write(str);
  }

  public static void Log(string log, string stacktrace, LogType type)
  {
    if (type == LogType.Error || type == LogType.Exception)
      log = "\n\n" + log + "\n" + stacktrace;
    LogSystem.Log(log);
  }

  public static void Log(string log) => LogSystem.toLog += string.Format("[{0}] {1}\n", (object) DateTime.Now, (object) log);

  public static void CreateBackups()
  {
    for (int backupNumber = 8; backupNumber >= 0; --backupNumber)
    {
      string fileName1 = LogSystem.GetFileName(backupNumber);
      if (File.Exists(fileName1))
      {
        string fileName2 = LogSystem.GetFileName(backupNumber + 1);
        File.Copy(fileName1, fileName2, true);
        if (backupNumber == 0)
          File.Delete(fileName1);
      }
    }
  }

  public static string GetFileName(int backupNumber) => backupNumber <= 0 ? LogSystem.path : string.Format("{0}.{1}", (object) LogSystem.path, (object) backupNumber);

  public static void LogSystemInformation() => LogSystem.Log("\n" + SystemInfo.deviceModel + string.Format("\n{0} ({1}) [{2}]", (object) SystemInfo.deviceType, (object) SystemInfo.deviceName, (object) SystemInfo.deviceUniqueIdentifier) + "\n" + SystemInfo.operatingSystem + string.Format("\n{0} ({1} Cores, {2}hz)", (object) SystemInfo.processorType, (object) SystemInfo.processorCount, (object) SystemInfo.processorFrequency) + "\n" + SystemInfo.graphicsDeviceVendor + " | " + SystemInfo.graphicsDeviceName + " (" + SystemInfo.graphicsDeviceVersion + ")" + string.Format("\nShader Level: {0}", (object) SystemInfo.graphicsShaderLevel) + string.Format("\nGraphics Memory: {0}", (object) SystemInfo.graphicsMemorySize) + string.Format("\nSystem Memory: {0}", (object) SystemInfo.systemMemorySize));
}
﻿// Decompiled with JetBrains decompiler
// Type: LorePage
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using UnityEngine;
using UnityEngine.UI;

public class LorePage : MonoBehaviour
{
  public LorePageManager manager;
  public JournalPageData pageData;
  [SerializeField]
  public GameObject lockedDisplay;
  [SerializeField]
  public GameObject unlockedDisplay;
  [SerializeField]
  public GameObject newDisplay;
  public Button button;
  public Canvas canvas;
  public bool isUnlocked;
  public bool isNew;
  [SerializeField]
  public TweenUI denyTween;
  [SerializeField]
  public TweenUI newTween;

  public void Awake() => this.button.transform.localEulerAngles = new Vector3(0.0f, 0.0f, PettyRandom.Range(-1f, 1f) * 2f);

  public void SetUnlocked(JournalPageData pageData, bool value)
  {
    this.pageData = pageData;
    this.isUnlocked = value;
    this.button.interactable = value;
    this.lockedDisplay.SetActive(!value);
    this.unlockedDisplay.SetActive(value);
  }

  public void SetNew(bool value)
  {
    this.isNew = value;
    this.newDisplay.SetActive(value);
    if (!value)
      return;
    this.newTween.Fire();
  }

  public void Select()
  {
    if (this.isUnlocked)
    {
      this.manager.Select(this);
    }
    else
    {
      this.denyTween.Fire();
      SfxSystem.OneShot("event:/sfx/ui/deny");
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LorePageManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

public class LorePageManager : MonoBehaviour
{
  [SerializeField]
  public GameObject focusLayer;
  [SerializeField]
  public Transform focusLayerPageHolder;
  [SerializeField]
  public AssetReferenceT<JournalPageData>[] pages;
  [SerializeField]
  public AddressableReleaser assetReleaser;
  [SerializeField]
  public EventReference selectSfxEvent;
  [SerializeField]
  public EventReference deselectSfxEvent;
  [SerializeField]
  public EventReference newSfxEvent;
  [SerializeField]
  public SfxLoop newLoop;
  public readonly List<GameObject> pageObjects = new List<GameObject>();
  public LorePage current;
  public Canvas focus;
  public bool focusLayerActive;
  public List<string> inspected;
  public int newCount;

  public void OnEnable()
  {
    this.inspected = SaveSystem.LoadProgressData<List<string>>("lorePagesInspected");
    if (this.inspected == null)
      this.inspected = new List<string>();
    this.Populate();
  }

  public void OnDisable()
  {
    foreach (GameObject pageObject in this.pageObjects)
      pageObject.Destroy();
    this.pageObjects.Clear();
    this.DisableFocusLayer();
  }

  public void Populate()
  {
    this.newCount = 0;
    List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
    foreach (AssetReferenceT<JournalPageData> page in this.pages)
    {
      AsyncOperationHandle<JournalPageData> handle1 = page.LoadAssetAsync();
      JournalPageData pageData = handle1.WaitForCompletion();
      AsyncOperationHandle<GameObject> handle2 = pageData.prefabRef.InstantiateAsync(this.transform);
      LorePage component = handle2.WaitForCompletion().GetComponent<LorePage>();
      component.manager = this;
      this.pageObjects.Add(component.gameObject);
      if (unlockedList.Contains(pageData.unlock.name))
      {
        bool flag = !this.inspected.Contains(pageData.unlock.name);
        component.SetUnlocked(pageData, true);
        component.SetNew(flag);
        if (flag)
          ++this.newCount;
      }
      this.assetReleaser.Add((AsyncOperationHandle) handle2);
      this.assetReleaser.Add((AsyncOperationHandle) handle1);
    }
    if (this.newCount <= 0)
      return;
    SfxSystem.OneShot(this.newSfxEvent);
    this.newLoop.Play();
  }

  public void Select(LorePage lorePage)
  {
    if (this.focusLayerActive || !lorePage.isUnlocked)
      return;
    this.current = lorePage;
    this.focus = lorePage.canvas;
    SfxSystem.OneShot(this.selectSfxEvent);
    if (lorePage.isNew)
    {
      lorePage.SetNew(false);
      this.inspected.Add(lorePage.pageData.unlock.name);
      SaveSystem.SaveProgressData<List<string>>("lorePagesInspected", this.inspected);
      if (--this.newCount <= 0)
        this.newLoop.Stop();
    }
    this.focusLayerActive = true;
    this.focusLayer.SetActive(true);
    this.focus.overrideSorting = true;
    this.focus.sortingLayerName = "PauseMenu";
    this.focus.sortingOrder = 11;
    this.focus.transform.SetParent(this.focusLayerPageHolder);
    LeanTween.cancel(this.focus.gameObject);
    LeanTween.moveLocal(this.focus.gameObject, Vector3.zero, 0.3f).setEaseOutQuint().setIgnoreTimeScale(true);
    LeanTween.scale(this.focus.gameObject, Vector3.one, 0.3f).setEaseOutQuint().setIgnoreTimeScale(true);
    LeanTween.rotateLocal(this.focus.gameObject, Vector3.zero, 0.6f).setEaseOutBack().setIgnoreTimeScale(true);
  }

  public void DisableFocusLayer()
  {
    if (!this.focusLayerActive)
      return;
    SfxSystem.OneShot(this.deselectSfxEvent);
    this.focus.overrideSorting = false;
    this.focus.sortingOrder = 1;
    this.focus.transform.SetParent(this.current.button.transform);
    LeanTween.cancel(this.focus.gameObject);
    LeanTween.moveLocal(this.focus.gameObject, Vector3.zero, 0.1f).setEaseOutQuad().setIgnoreTimeScale(true);
    LeanTween.scale(this.focus.gameObject, Vector3.one, 0.1f).setEaseOutQuad().setIgnoreTimeScale(true);
    LeanTween.rotateLocal(this.focus.gameObject, Vector3.zero, 0.1f).setEaseOutQuad().setIgnoreTimeScale(true);
    this.focusLayerActive = false;
    this.focusLayer.SetActive(false);
    this.current = (LorePage) null;
    this.focus = (Canvas) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LTBezier
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LTBezier
{
  public float length;
  public Vector3 a;
  public Vector3 aa;
  public Vector3 bb;
  public Vector3 cc;
  public float len;
  public float[] arcLengths;

  public LTBezier(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float precision)
  {
    this.a = a;
    this.aa = -a + 3f * (b - c) + d;
    this.bb = 3f * (a + c) - 6f * b;
    this.cc = 3f * (b - a);
    this.len = 1f / precision;
    this.arcLengths = new float[(int) this.len + 1];
    this.arcLengths[0] = 0.0f;
    Vector3 vector3_1 = a;
    float num = 0.0f;
    for (int index = 1; (double) index <= (double) this.len; ++index)
    {
      Vector3 vector3_2 = this.bezierPoint((float) index * precision);
      num += (vector3_1 - vector3_2).magnitude;
      this.arcLengths[index] = num;
      vector3_1 = vector3_2;
    }
    this.length = num;
  }

  public float map(float u)
  {
    float num1 = u * this.arcLengths[(int) this.len];
    int num2 = 0;
    int num3 = (int) this.len;
    int index = 0;
    while (num2 < num3)
    {
      index = num2 + ((int) ((double) (num3 - num2) / 2.0) | 0);
      if ((double) this.arcLengths[index] < (double) num1)
        num2 = index + 1;
      else
        num3 = index;
    }
    if ((double) this.arcLengths[index] > (double) num1)
      --index;
    if (index < 0)
      index = 0;
    return ((float) index + (float) (((double) num1 - (double) this.arcLengths[index]) / ((double) this.arcLengths[index + 1] - (double) this.arcLengths[index]))) / this.len;
  }

  public Vector3 bezierPoint(float t) => ((this.aa * t + this.bb) * t + this.cc) * t + this.a;

  public Vector3 point(float t) => this.bezierPoint(this.map(t));
}
﻿// Decompiled with JetBrains decompiler
// Type: LTBezierPath
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LTBezierPath
{
  public Vector3[] pts;
  public float length;
  public bool orientToPath;
  public bool orientToPath2d;
  public LTBezier[] beziers;
  public float[] lengthRatio;
  public int currentBezier;
  public int previousBezier;

  public LTBezierPath()
  {
  }

  public LTBezierPath(Vector3[] pts_) => this.setPoints(pts_);

  public void setPoints(Vector3[] pts_)
  {
    if (pts_.Length < 4)
      LeanTween.logError("LeanTween - When passing values for a vector path, you must pass four or more values!");
    if (pts_.Length % 4 != 0)
      LeanTween.logError("LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...");
    this.pts = pts_;
    int index1 = 0;
    this.beziers = new LTBezier[this.pts.Length / 4];
    this.lengthRatio = new float[this.beziers.Length];
    this.length = 0.0f;
    for (int index2 = 0; index2 < this.pts.Length; index2 += 4)
    {
      this.beziers[index1] = new LTBezier(this.pts[index2], this.pts[index2 + 2], this.pts[index2 + 1], this.pts[index2 + 3], 0.05f);
      this.length += this.beziers[index1].length;
      ++index1;
    }
    for (int index3 = 0; index3 < this.beziers.Length; ++index3)
      this.lengthRatio[index3] = this.beziers[index3].length / this.length;
  }

  public float distance => this.length;

  public Vector3 point(float ratio)
  {
    float num = 0.0f;
    for (int index = 0; index < this.lengthRatio.Length; ++index)
    {
      num += this.lengthRatio[index];
      if ((double) num >= (double) ratio)
        return this.beziers[index].point((ratio - (num - this.lengthRatio[index])) / this.lengthRatio[index]);
    }
    return this.beziers[this.lengthRatio.Length - 1].point(1f);
  }

  public void place2d(Transform transform, float ratio)
  {
    transform.position = this.point(ratio);
    ratio += 1f / 1000f;
    if ((double) ratio > 1.0)
      return;
    Vector3 vector3 = this.point(ratio) - transform.position;
    float z = Mathf.Atan2(vector3.y, vector3.x) * 57.29578f;
    transform.eulerAngles = new Vector3(0.0f, 0.0f, z);
  }

  public void placeLocal2d(Transform transform, float ratio)
  {
    transform.localPosition = this.point(ratio);
    ratio += 1f / 1000f;
    if ((double) ratio > 1.0)
      return;
    Vector3 vector3 = this.point(ratio) - transform.localPosition;
    float z = Mathf.Atan2(vector3.y, vector3.x) * 57.29578f;
    transform.localEulerAngles = new Vector3(0.0f, 0.0f, z);
  }

  public void place(Transform transform, float ratio) => this.place(transform, ratio, Vector3.up);

  public void place(Transform transform, float ratio, Vector3 worldUp)
  {
    transform.position = this.point(ratio);
    ratio += 1f / 1000f;
    if ((double) ratio > 1.0)
      return;
    transform.LookAt(this.point(ratio), worldUp);
  }

  public void placeLocal(Transform transform, float ratio) => this.placeLocal(transform, ratio, Vector3.up);

  public void placeLocal(Transform transform, float ratio, Vector3 worldUp)
  {
    ratio = Mathf.Clamp01(ratio);
    transform.localPosition = this.point(ratio);
    ratio = Mathf.Clamp01(ratio + 1f / 1000f);
    if ((double) ratio > 1.0)
      return;
    transform.LookAt(transform.parent.TransformPoint(this.point(ratio)), worldUp);
  }

  public void gizmoDraw(float t = -1f)
  {
    Vector3 to = this.point(0.0f);
    for (int index = 1; index <= 120; ++index)
    {
      Vector3 from = this.point((float) index / 120f);
      Gizmos.color = this.previousBezier == this.currentBezier ? Color.magenta : Color.grey;
      Gizmos.DrawLine(from, to);
      to = from;
      this.previousBezier = this.currentBezier;
    }
  }

  public float ratioAtPoint(Vector3 pt, float precision = 0.01f)
  {
    float num1 = float.MaxValue;
    int num2 = 0;
    int num3 = Mathf.RoundToInt(1f / precision);
    for (int index = 0; index < num3; ++index)
    {
      float ratio = (float) index / (float) num3;
      float num4 = Vector3.Distance(pt, this.point(ratio));
      if ((double) num4 < (double) num1)
      {
        num1 = num4;
        num2 = index;
      }
    }
    return (float) num2 / (float) num3;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LTDescr
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UI;

public class LTDescr
{
  public bool toggle;
  public bool useEstimatedTime;
  public bool useFrames;
  public bool useManualTime;
  public bool usesNormalDt;
  public bool hasInitiliazed;
  public bool hasExtraOnCompletes;
  public bool hasPhysics;
  public bool onCompleteOnRepeat;
  public bool onCompleteOnStart;
  public bool useRecursion;
  public float ratioPassed;
  public float passed;
  public float delay;
  public float time;
  public float speed;
  public float lastVal;
  public uint _id;
  public int loopCount;
  public uint counter = uint.MaxValue;
  public float direction;
  public float directionLast;
  public float overshoot;
  public float period;
  public float scale;
  public bool destroyOnComplete;
  public Transform trans;
  public Vector3 fromInternal;
  public Vector3 toInternal;
  public Vector3 diff;
  public Vector3 diffDiv2;
  public TweenAction type;
  public LeanTweenType easeType;
  public LeanTweenType loopType;
  public bool hasUpdateCallback;
  public LTDescr.EaseTypeDelegate easeMethod;
  [CompilerGenerated]
  public LTDescr.ActionMethodDelegate \u003CeaseInternal\u003Ek__BackingField;
  [CompilerGenerated]
  public LTDescr.ActionMethodDelegate \u003CinitInternal\u003Ek__BackingField;
  public SpriteRenderer spriteRen;
  public RectTransform rectTransform;
  public UnityEngine.UI.Text uiText;
  public Image uiImage;
  public RawImage rawImage;
  public Sprite[] sprites;
  public LTDescrOptional _optional = new LTDescrOptional();
  public static float val;
  public static float dt;
  public static Vector3 newVect;

  public Vector3 from
  {
    get => this.fromInternal;
    set => this.fromInternal = value;
  }

  public Vector3 to
  {
    get => this.toInternal;
    set => this.toInternal = value;
  }

  public LTDescr.ActionMethodDelegate easeInternal
  {
    get => this.\u003CeaseInternal\u003Ek__BackingField;
    set => this.\u003CeaseInternal\u003Ek__BackingField = value;
  }

  public LTDescr.ActionMethodDelegate initInternal
  {
    get => this.\u003CinitInternal\u003Ek__BackingField;
    set => this.\u003CinitInternal\u003Ek__BackingField = value;
  }

  public Transform toTrans => this.optional.toTrans;

  public override string ToString() => ((UnityEngine.Object) this.trans != (UnityEngine.Object) null ? "name:" + this.trans.gameObject.name : "gameObject:null") + " toggle:" + this.toggle.ToString() + " passed:" + this.passed.ToString() + " time:" + this.time.ToString() + " delay:" + this.delay.ToString() + " direction:" + this.direction.ToString() + " from:" + this.from.ToString() + " to:" + this.to.ToString() + " diff:" + this.diff.ToString() + " type:" + this.type.ToString() + " ease:" + this.easeType.ToString() + " useEstimatedTime:" + this.useEstimatedTime.ToString() + " id:" + this.id.ToString() + " hasInitiliazed:" + this.hasInitiliazed.ToString();

  [Obsolete("Use 'LeanTween.cancel( id )' instead")]
  public LTDescr cancel(GameObject gameObject)
  {
    if ((UnityEngine.Object) gameObject == (UnityEngine.Object) this.trans.gameObject)
      LeanTween.removeTween((int) this._id, this.uniqueId);
    return this;
  }

  public int uniqueId => (int) this._id | (int) this.counter << 16;

  public int id => this.uniqueId;

  public LTDescrOptional optional
  {
    get => this._optional;
    set => this._optional = value;
  }

  public void reset()
  {
    this.toggle = this.useRecursion = this.usesNormalDt = true;
    this.trans = (Transform) null;
    this.spriteRen = (SpriteRenderer) null;
    this.passed = this.delay = this.lastVal = 0.0f;
    this.hasUpdateCallback = this.useEstimatedTime = this.useFrames = this.hasInitiliazed = this.onCompleteOnRepeat = this.destroyOnComplete = this.onCompleteOnStart = this.useManualTime = this.hasExtraOnCompletes = false;
    this.easeType = LeanTweenType.linear;
    this.loopType = LeanTweenType.once;
    this.loopCount = 0;
    this.direction = this.directionLast = this.overshoot = this.scale = 1f;
    this.period = 0.3f;
    this.speed = -1f;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeLinear);
    this.from = this.to = Vector3.zero;
    this._optional.reset();
  }

  public LTDescr setFollow()
  {
    this.type = TweenAction.FOLLOW;
    return this;
  }

  public LTDescr setMoveX()
  {
    this.type = TweenAction.MOVE_X;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.trans.position.x);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.position = new Vector3(this.easeMethod().x, this.trans.position.y, this.trans.position.z));
    return this;
  }

  public LTDescr setMoveY()
  {
    this.type = TweenAction.MOVE_Y;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.trans.position.y);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.position = new Vector3(this.trans.position.x, this.easeMethod().x, this.trans.position.z));
    return this;
  }

  public LTDescr setMoveZ()
  {
    this.type = TweenAction.MOVE_Z;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.trans.position.z);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.position = new Vector3(this.trans.position.x, this.trans.position.y, this.easeMethod().x));
    return this;
  }

  public LTDescr setMoveLocalX()
  {
    this.type = TweenAction.MOVE_LOCAL_X;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.trans.localPosition.x);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.localPosition = new Vector3(this.easeMethod().x, this.trans.localPosition.y, this.trans.localPosition.z));
    return this;
  }

  public LTDescr setMoveLocalY()
  {
    this.type = TweenAction.MOVE_LOCAL_Y;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.trans.localPosition.y);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.localPosition = new Vector3(this.trans.localPosition.x, this.easeMethod().x, this.trans.localPosition.z));
    return this;
  }

  public LTDescr setMoveLocalZ()
  {
    this.type = TweenAction.MOVE_LOCAL_Z;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.trans.localPosition.z);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.localPosition = new Vector3(this.trans.localPosition.x, this.trans.localPosition.y, this.easeMethod().x));
    return this;
  }

  public void initFromInternal() => this.fromInternal.x = 0.0f;

  public LTDescr setOffset(Vector3 offset)
  {
    this.toInternal = offset;
    return this;
  }

  public LTDescr setMoveCurved()
  {
    this.type = TweenAction.MOVE_CURVED;
    this.initInternal = new LTDescr.ActionMethodDelegate(this.initFromInternal);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      if (this._optional.path.orientToPath)
      {
        if (this._optional.path.orientToPath2d)
          this._optional.path.place2d(this.trans, LTDescr.val);
        else
          this._optional.path.place(this.trans, LTDescr.val);
      }
      else
        this.trans.position = this._optional.path.point(LTDescr.val);
    });
    return this;
  }

  public LTDescr setMoveCurvedLocal()
  {
    this.type = TweenAction.MOVE_CURVED_LOCAL;
    this.initInternal = new LTDescr.ActionMethodDelegate(this.initFromInternal);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      if (this._optional.path.orientToPath)
      {
        if (this._optional.path.orientToPath2d)
          this._optional.path.placeLocal2d(this.trans, LTDescr.val);
        else
          this._optional.path.placeLocal(this.trans, LTDescr.val);
      }
      else
        this.trans.localPosition = this._optional.path.point(LTDescr.val);
    });
    return this;
  }

  public LTDescr setMoveSpline()
  {
    this.type = TweenAction.MOVE_SPLINE;
    this.initInternal = new LTDescr.ActionMethodDelegate(this.initFromInternal);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      if (this._optional.spline.orientToPath)
      {
        if (this._optional.spline.orientToPath2d)
          this._optional.spline.place2d(this.trans, LTDescr.val);
        else
          this._optional.spline.place(this.trans, LTDescr.val);
      }
      else
        this.trans.position = this._optional.spline.point(LTDescr.val);
    });
    return this;
  }

  public LTDescr setMoveSplineLocal()
  {
    this.type = TweenAction.MOVE_SPLINE_LOCAL;
    this.initInternal = new LTDescr.ActionMethodDelegate(this.initFromInternal);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      if (this._optional.spline.orientToPath)
      {
        if (this._optional.spline.orientToPath2d)
          this._optional.spline.placeLocal2d(this.trans, LTDescr.val);
        else
          this._optional.spline.placeLocal(this.trans, LTDescr.val);
      }
      else
        this.trans.localPosition = this._optional.spline.point(LTDescr.val);
    });
    return this;
  }

  public LTDescr setScaleX()
  {
    this.type = TweenAction.SCALE_X;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.trans.localScale.x);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.localScale = new Vector3(this.easeMethod().x, this.trans.localScale.y, this.trans.localScale.z));
    return this;
  }

  public LTDescr setScaleY()
  {
    this.type = TweenAction.SCALE_Y;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.trans.localScale.y);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.localScale = new Vector3(this.trans.localScale.x, this.easeMethod().x, this.trans.localScale.z));
    return this;
  }

  public LTDescr setScaleZ()
  {
    this.type = TweenAction.SCALE_Z;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.trans.localScale.z);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.localScale = new Vector3(this.trans.localScale.x, this.trans.localScale.y, this.easeMethod().x));
    return this;
  }

  public LTDescr setRotateX()
  {
    this.type = TweenAction.ROTATE_X;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.fromInternal.x = this.trans.eulerAngles.x;
      this.toInternal.x = LeanTween.closestRot(this.fromInternal.x, this.toInternal.x);
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.eulerAngles = new Vector3(this.easeMethod().x, this.trans.eulerAngles.y, this.trans.eulerAngles.z));
    return this;
  }

  public LTDescr setRotateY()
  {
    this.type = TweenAction.ROTATE_Y;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.fromInternal.x = this.trans.eulerAngles.y;
      this.toInternal.x = LeanTween.closestRot(this.fromInternal.x, this.toInternal.x);
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.eulerAngles = new Vector3(this.trans.eulerAngles.x, this.easeMethod().x, this.trans.eulerAngles.z));
    return this;
  }

  public LTDescr setRotateZ()
  {
    this.type = TweenAction.ROTATE_Z;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.fromInternal.x = this.trans.eulerAngles.z;
      this.toInternal.x = LeanTween.closestRot(this.fromInternal.x, this.toInternal.x);
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.eulerAngles = new Vector3(this.trans.eulerAngles.x, this.trans.eulerAngles.y, this.easeMethod().x));
    return this;
  }

  public LTDescr setRotateAround()
  {
    this.type = TweenAction.ROTATE_AROUND;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.fromInternal.x = 0.0f;
      this._optional.origRotation = this.trans.rotation;
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      Vector3 localPosition = this.trans.localPosition;
      this.trans.RotateAround(this.trans.TransformPoint(this._optional.point), this._optional.axis, -this._optional.lastVal);
      Vector3 vector3 = localPosition - this.trans.localPosition;
      this.trans.localPosition = localPosition - vector3;
      this.trans.rotation = this._optional.origRotation;
      this.trans.RotateAround(this.trans.TransformPoint(this._optional.point), this._optional.axis, LTDescr.val);
      this._optional.lastVal = LTDescr.val;
    });
    return this;
  }

  public LTDescr setRotateAroundLocal()
  {
    this.type = TweenAction.ROTATE_AROUND_LOCAL;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.fromInternal.x = 0.0f;
      this._optional.origRotation = this.trans.localRotation;
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      Vector3 localPosition = this.trans.localPosition;
      this.trans.RotateAround(this.trans.TransformPoint(this._optional.point), this.trans.TransformDirection(this._optional.axis), -this._optional.lastVal);
      Vector3 vector3 = localPosition - this.trans.localPosition;
      this.trans.localPosition = localPosition - vector3;
      this.trans.localRotation = this._optional.origRotation;
      this.trans.RotateAround(this.trans.TransformPoint(this._optional.point), this.trans.TransformDirection(this._optional.axis), LTDescr.val);
      this._optional.lastVal = LTDescr.val;
    });
    return this;
  }

  public LTDescr setAlpha()
  {
    this.type = TweenAction.ALPHA;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      SpriteRenderer component = this.trans.GetComponent<SpriteRenderer>();
      if ((UnityEngine.Object) component != (UnityEngine.Object) null)
        this.fromInternal.x = component.color.a;
      else if ((UnityEngine.Object) this.trans.GetComponent<Renderer>() != (UnityEngine.Object) null && this.trans.GetComponent<Renderer>().material.HasProperty("_Color"))
        this.fromInternal.x = this.trans.GetComponent<Renderer>().material.color.a;
      else if ((UnityEngine.Object) this.trans.GetComponent<Renderer>() != (UnityEngine.Object) null && this.trans.GetComponent<Renderer>().material.HasProperty("_TintColor"))
        this.fromInternal.x = this.trans.GetComponent<Renderer>().material.GetColor("_TintColor").a;
      else if (this.trans.childCount > 0)
      {
        foreach (Transform tran in this.trans)
        {
          if ((UnityEngine.Object) tran.gameObject.GetComponent<Renderer>() != (UnityEngine.Object) null)
          {
            this.fromInternal.x = tran.gameObject.GetComponent<Renderer>().material.color.a;
            break;
          }
        }
      }
      this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
      {
        LTDescr.val = this.easeMethod().x;
        if ((UnityEngine.Object) this.spriteRen != (UnityEngine.Object) null)
        {
          this.spriteRen.color = new Color(this.spriteRen.color.r, this.spriteRen.color.g, this.spriteRen.color.b, LTDescr.val);
          LTDescr.alphaRecursiveSprite(this.trans, LTDescr.val);
        }
        else
          LTDescr.alphaRecursive(this.trans, LTDescr.val, this.useRecursion);
      });
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      if ((UnityEngine.Object) this.spriteRen != (UnityEngine.Object) null)
      {
        this.spriteRen.color = new Color(this.spriteRen.color.r, this.spriteRen.color.g, this.spriteRen.color.b, LTDescr.val);
        LTDescr.alphaRecursiveSprite(this.trans, LTDescr.val);
      }
      else
        LTDescr.alphaRecursive(this.trans, LTDescr.val, this.useRecursion);
    });
    return this;
  }

  public LTDescr setTextAlpha()
  {
    this.type = TweenAction.TEXT_ALPHA;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.uiText = this.trans.GetComponent<UnityEngine.UI.Text>();
      this.fromInternal.x = (UnityEngine.Object) this.uiText != (UnityEngine.Object) null ? this.uiText.color.a : 1f;
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => LTDescr.textAlphaRecursive(this.trans, this.easeMethod().x, this.useRecursion));
    return this;
  }

  public LTDescr setAlphaVertex()
  {
    this.type = TweenAction.ALPHA_VERTEX;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = (float) this.trans.GetComponent<MeshFilter>().mesh.colors32[0].a);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      Mesh mesh = this.trans.GetComponent<MeshFilter>().mesh;
      Vector3[] vertices = mesh.vertices;
      Color32[] color32Array = new Color32[vertices.Length];
      if (color32Array.Length == 0)
      {
        Color32 color32 = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, (byte) 0);
        color32Array = new Color32[mesh.vertices.Length];
        for (int index = 0; index < color32Array.Length; ++index)
          color32Array[index] = color32;
        mesh.colors32 = color32Array;
      }
      Color32 color32_1 = mesh.colors32[0];
      Color32 color32_2 = (Color32) new Color((float) color32_1.r, (float) color32_1.g, (float) color32_1.b, LTDescr.val);
      for (int index = 0; index < vertices.Length; ++index)
        color32Array[index] = color32_2;
      mesh.colors32 = color32Array;
    });
    return this;
  }

  public LTDescr setColor()
  {
    this.type = TweenAction.COLOR;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      SpriteRenderer component = this.trans.GetComponent<SpriteRenderer>();
      if ((UnityEngine.Object) component != (UnityEngine.Object) null)
        this.setFromColor(component.color);
      else if ((UnityEngine.Object) this.trans.GetComponent<Renderer>() != (UnityEngine.Object) null && this.trans.GetComponent<Renderer>().material.HasProperty("_Color"))
        this.setFromColor(this.trans.GetComponent<Renderer>().material.color);
      else if ((UnityEngine.Object) this.trans.GetComponent<Renderer>() != (UnityEngine.Object) null && this.trans.GetComponent<Renderer>().material.HasProperty("_TintColor"))
      {
        this.setFromColor(this.trans.GetComponent<Renderer>().material.GetColor("_TintColor"));
      }
      else
      {
        if (this.trans.childCount <= 0)
          return;
        foreach (Transform tran in this.trans)
        {
          if ((UnityEngine.Object) tran.gameObject.GetComponent<Renderer>() != (UnityEngine.Object) null)
          {
            this.setFromColor(tran.gameObject.GetComponent<Renderer>().material.color);
            break;
          }
        }
      }
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      Color toColor = LTDescr.tweenColor(this, LTDescr.val);
      if ((UnityEngine.Object) this.spriteRen != (UnityEngine.Object) null)
      {
        this.spriteRen.color = toColor;
        LTDescr.colorRecursiveSprite(this.trans, toColor);
      }
      else if (this.type == TweenAction.COLOR)
        LTDescr.colorRecursive(this.trans, toColor, this.useRecursion);
      if ((double) LTDescr.dt != 0.0 && this._optional.onUpdateColor != null)
      {
        this._optional.onUpdateColor(toColor);
      }
      else
      {
        if ((double) LTDescr.dt == 0.0 || this._optional.onUpdateColorObject == null)
          return;
        this._optional.onUpdateColorObject(toColor, this._optional.onUpdateParam);
      }
    });
    return this;
  }

  public LTDescr setCallbackColor()
  {
    this.type = TweenAction.CALLBACK_COLOR;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.diff = new Vector3(1f, 0.0f, 0.0f));
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      Color toColor = LTDescr.tweenColor(this, LTDescr.val);
      if ((UnityEngine.Object) this.spriteRen != (UnityEngine.Object) null)
      {
        this.spriteRen.color = toColor;
        LTDescr.colorRecursiveSprite(this.trans, toColor);
      }
      else if (this.type == TweenAction.COLOR)
        LTDescr.colorRecursive(this.trans, toColor, this.useRecursion);
      if ((double) LTDescr.dt != 0.0 && this._optional.onUpdateColor != null)
      {
        this._optional.onUpdateColor(toColor);
      }
      else
      {
        if ((double) LTDescr.dt == 0.0 || this._optional.onUpdateColorObject == null)
          return;
        this._optional.onUpdateColorObject(toColor, this._optional.onUpdateParam);
      }
    });
    return this;
  }

  public LTDescr setTextColor()
  {
    this.type = TweenAction.TEXT_COLOR;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.uiText = this.trans.GetComponent<UnityEngine.UI.Text>();
      this.setFromColor((UnityEngine.Object) this.uiText != (UnityEngine.Object) null ? this.uiText.color : Color.white);
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      Color toColor = LTDescr.tweenColor(this, LTDescr.val);
      this.uiText.color = toColor;
      if ((double) LTDescr.dt != 0.0 && this._optional.onUpdateColor != null)
        this._optional.onUpdateColor(toColor);
      if (!this.useRecursion || this.trans.childCount <= 0)
        return;
      LTDescr.textColorRecursive(this.trans, toColor);
    });
    return this;
  }

  public LTDescr setCanvasAlpha()
  {
    this.type = TweenAction.CANVAS_ALPHA;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.uiImage = this.trans.GetComponent<Image>();
      if ((UnityEngine.Object) this.uiImage != (UnityEngine.Object) null)
      {
        this.fromInternal.x = this.uiImage.color.a;
      }
      else
      {
        this.rawImage = this.trans.GetComponent<RawImage>();
        if ((UnityEngine.Object) this.rawImage != (UnityEngine.Object) null)
          this.fromInternal.x = this.rawImage.color.a;
        else
          this.fromInternal.x = 1f;
      }
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      if ((UnityEngine.Object) this.uiImage != (UnityEngine.Object) null)
        this.uiImage.color = this.uiImage.color with
        {
          a = LTDescr.val
        };
      else if ((UnityEngine.Object) this.rawImage != (UnityEngine.Object) null)
        this.rawImage.color = this.rawImage.color with
        {
          a = LTDescr.val
        };
      if (!this.useRecursion)
        return;
      LTDescr.alphaRecursive(this.rectTransform, LTDescr.val, 0);
      LTDescr.textAlphaChildrenRecursive((Transform) this.rectTransform, LTDescr.val);
    });
    return this;
  }

  public LTDescr setCanvasGroupAlpha()
  {
    this.type = TweenAction.CANVASGROUP_ALPHA;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.trans.GetComponent<CanvasGroup>().alpha);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.trans.GetComponent<CanvasGroup>().alpha = this.easeMethod().x);
    return this;
  }

  public LTDescr setCanvasColor()
  {
    this.type = TweenAction.CANVAS_COLOR;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.uiImage = this.trans.GetComponent<Image>();
      if ((UnityEngine.Object) this.uiImage == (UnityEngine.Object) null)
      {
        this.rawImage = this.trans.GetComponent<RawImage>();
        this.setFromColor((UnityEngine.Object) this.rawImage != (UnityEngine.Object) null ? this.rawImage.color : Color.white);
      }
      else
        this.setFromColor(this.uiImage.color);
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      Color toColor = LTDescr.tweenColor(this, LTDescr.val);
      if ((UnityEngine.Object) this.uiImage != (UnityEngine.Object) null)
        this.uiImage.color = toColor;
      else if ((UnityEngine.Object) this.rawImage != (UnityEngine.Object) null)
        this.rawImage.color = toColor;
      if ((double) LTDescr.dt != 0.0 && this._optional.onUpdateColor != null)
        this._optional.onUpdateColor(toColor);
      if (!this.useRecursion)
        return;
      LTDescr.colorRecursive(this.rectTransform, toColor);
    });
    return this;
  }

  public LTDescr setCanvasMoveX()
  {
    this.type = TweenAction.CANVAS_MOVE_X;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.rectTransform.anchoredPosition3D.x);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      Vector3 anchoredPosition3D = this.rectTransform.anchoredPosition3D;
      this.rectTransform.anchoredPosition3D = new Vector3(this.easeMethod().x, anchoredPosition3D.y, anchoredPosition3D.z);
    });
    return this;
  }

  public LTDescr setCanvasMoveY()
  {
    this.type = TweenAction.CANVAS_MOVE_Y;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.rectTransform.anchoredPosition3D.y);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      Vector3 anchoredPosition3D = this.rectTransform.anchoredPosition3D;
      this.rectTransform.anchoredPosition3D = new Vector3(anchoredPosition3D.x, this.easeMethod().x, anchoredPosition3D.z);
    });
    return this;
  }

  public LTDescr setCanvasMoveZ()
  {
    this.type = TweenAction.CANVAS_MOVE_Z;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this.rectTransform.anchoredPosition3D.z);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      Vector3 anchoredPosition3D = this.rectTransform.anchoredPosition3D;
      this.rectTransform.anchoredPosition3D = new Vector3(anchoredPosition3D.x, anchoredPosition3D.y, this.easeMethod().x);
    });
    return this;
  }

  public void initCanvasRotateAround()
  {
    this.lastVal = 0.0f;
    this.fromInternal.x = 0.0f;
    this._optional.origRotation = this.rectTransform.rotation;
  }

  public LTDescr setCanvasRotateAround()
  {
    this.type = TweenAction.CANVAS_ROTATEAROUND;
    this.initInternal = new LTDescr.ActionMethodDelegate(this.initCanvasRotateAround);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      RectTransform rectTransform = this.rectTransform;
      Vector3 localPosition = rectTransform.localPosition;
      rectTransform.RotateAround(rectTransform.TransformPoint(this._optional.point), this._optional.axis, -LTDescr.val);
      Vector3 vector3 = localPosition - rectTransform.localPosition;
      rectTransform.localPosition = localPosition - vector3;
      rectTransform.rotation = this._optional.origRotation;
      rectTransform.RotateAround(rectTransform.TransformPoint(this._optional.point), this._optional.axis, LTDescr.val);
    });
    return this;
  }

  public LTDescr setCanvasRotateAroundLocal()
  {
    this.type = TweenAction.CANVAS_ROTATEAROUND_LOCAL;
    this.initInternal = new LTDescr.ActionMethodDelegate(this.initCanvasRotateAround);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      RectTransform rectTransform = this.rectTransform;
      Vector3 localPosition = rectTransform.localPosition;
      rectTransform.RotateAround(rectTransform.TransformPoint(this._optional.point), rectTransform.TransformDirection(this._optional.axis), -LTDescr.val);
      Vector3 vector3 = localPosition - rectTransform.localPosition;
      rectTransform.localPosition = localPosition - vector3;
      rectTransform.rotation = this._optional.origRotation;
      rectTransform.RotateAround(rectTransform.TransformPoint(this._optional.point), rectTransform.TransformDirection(this._optional.axis), LTDescr.val);
    });
    return this;
  }

  public LTDescr setCanvasPlaySprite()
  {
    this.type = TweenAction.CANVAS_PLAYSPRITE;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.uiImage = this.trans.GetComponent<Image>();
      this.fromInternal.x = 0.0f;
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      LTDescr.val = LTDescr.newVect.x;
      this.uiImage.sprite = this.sprites[(int) Mathf.Round(LTDescr.val)];
    });
    return this;
  }

  public LTDescr setCanvasMove()
  {
    this.type = TweenAction.CANVAS_MOVE;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal = this.rectTransform.anchoredPosition3D);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.rectTransform.anchoredPosition3D = this.easeMethod());
    return this;
  }

  public LTDescr setCanvasScale()
  {
    this.type = TweenAction.CANVAS_SCALE;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.from = this.rectTransform.localScale);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.rectTransform.localScale = this.easeMethod());
    return this;
  }

  public LTDescr setCanvasSizeDelta()
  {
    this.type = TweenAction.CANVAS_SIZEDELTA;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.from = (Vector3) this.rectTransform.sizeDelta);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this.rectTransform.sizeDelta = (Vector2) this.easeMethod());
    return this;
  }

  public void callback()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
  }

  public LTDescr setCallback()
  {
    this.type = TweenAction.CALLBACK;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => { });
    this.easeInternal = new LTDescr.ActionMethodDelegate(this.callback);
    return this;
  }

  public LTDescr setValue3()
  {
    this.type = TweenAction.VALUE3;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => { });
    this.easeInternal = new LTDescr.ActionMethodDelegate(this.callback);
    return this;
  }

  public LTDescr setMove()
  {
    this.type = TweenAction.MOVE;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.from = this.trans.position);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      this.trans.position = LTDescr.newVect;
    });
    return this;
  }

  public LTDescr setMoveLocal()
  {
    this.type = TweenAction.MOVE_LOCAL;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.from = this.trans.localPosition);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      this.trans.localPosition = LTDescr.newVect;
    });
    return this;
  }

  public LTDescr setMoveToTransform()
  {
    this.type = TweenAction.MOVE_TO_TRANSFORM;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.from = this.trans.position);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.to = this._optional.toTrans.position;
      this.diff = this.to - this.from;
      this.diffDiv2 = this.diff * 0.5f;
      LTDescr.newVect = this.easeMethod();
      this.trans.position = LTDescr.newVect;
    });
    return this;
  }

  public LTDescr setRotate()
  {
    this.type = TweenAction.ROTATE;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.from = this.trans.eulerAngles;
      this.to = new Vector3(LeanTween.closestRot(this.fromInternal.x, this.toInternal.x), LeanTween.closestRot(this.from.y, this.to.y), LeanTween.closestRot(this.from.z, this.to.z));
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      this.trans.eulerAngles = LTDescr.newVect;
    });
    return this;
  }

  public LTDescr setRotateLocal()
  {
    this.type = TweenAction.ROTATE_LOCAL;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      this.from = this.trans.localEulerAngles;
      this.to = new Vector3(LeanTween.closestRot(this.fromInternal.x, this.toInternal.x), LeanTween.closestRot(this.from.y, this.to.y), LeanTween.closestRot(this.from.z, this.to.z));
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      this.trans.localEulerAngles = LTDescr.newVect;
    });
    return this;
  }

  public LTDescr setScale()
  {
    this.type = TweenAction.SCALE;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.from = this.trans.localScale);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.newVect = this.easeMethod();
      this.trans.localScale = LTDescr.newVect;
    });
    return this;
  }

  public LTDescr setGUIMove()
  {
    this.type = TweenAction.GUI_MOVE;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      Rect rect = this._optional.ltRect.rect;
      double x = (double) rect.x;
      rect = this._optional.ltRect.rect;
      double y = (double) rect.y;
      this.from = new Vector3((float) x, (float) y, 0.0f);
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      Vector3 vector3 = this.easeMethod();
      LTRect ltRect = this._optional.ltRect;
      double x = (double) vector3.x;
      double y = (double) vector3.y;
      Rect rect1 = this._optional.ltRect.rect;
      double width = (double) rect1.width;
      rect1 = this._optional.ltRect.rect;
      double height = (double) rect1.height;
      Rect rect2 = new Rect((float) x, (float) y, (float) width, (float) height);
      ltRect.rect = rect2;
    });
    return this;
  }

  public LTDescr setGUIMoveMargin()
  {
    this.type = TweenAction.GUI_MOVE_MARGIN;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.from = (Vector3) new Vector2(this._optional.ltRect.margin.x, this._optional.ltRect.margin.y));
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      Vector3 vector3 = this.easeMethod();
      this._optional.ltRect.margin = new Vector2(vector3.x, vector3.y);
    });
    return this;
  }

  public LTDescr setGUIScale()
  {
    this.type = TweenAction.GUI_SCALE;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      Rect rect = this._optional.ltRect.rect;
      double width = (double) rect.width;
      rect = this._optional.ltRect.rect;
      double height = (double) rect.height;
      this.from = new Vector3((float) width, (float) height, 0.0f);
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      Vector3 vector3 = this.easeMethod();
      LTRect ltRect = this._optional.ltRect;
      Rect rect1 = this._optional.ltRect.rect;
      double x1 = (double) rect1.x;
      rect1 = this._optional.ltRect.rect;
      double y1 = (double) rect1.y;
      double x2 = (double) vector3.x;
      double y2 = (double) vector3.y;
      Rect rect2 = new Rect((float) x1, (float) y1, (float) x2, (float) y2);
      ltRect.rect = rect2;
    });
    return this;
  }

  public LTDescr setGUIAlpha()
  {
    this.type = TweenAction.GUI_ALPHA;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.fromInternal.x = this._optional.ltRect.alpha);
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this._optional.ltRect.alpha = this.easeMethod().x);
    return this;
  }

  public LTDescr setGUIRotate()
  {
    this.type = TweenAction.GUI_ROTATE;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      if (!this._optional.ltRect.rotateEnabled)
      {
        this._optional.ltRect.rotateEnabled = true;
        this._optional.ltRect.resetForRotation();
      }
      this.fromInternal.x = this._optional.ltRect.rotation;
    });
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() => this._optional.ltRect.rotation = this.easeMethod().x);
    return this;
  }

  public LTDescr setDelayedSound()
  {
    this.type = TweenAction.DELAYED_SOUND;
    this.initInternal = (LTDescr.ActionMethodDelegate) (() => this.hasExtraOnCompletes = true);
    this.easeInternal = new LTDescr.ActionMethodDelegate(this.callback);
    return this;
  }

  public LTDescr setTarget(Transform trans)
  {
    this.optional.toTrans = trans;
    return this;
  }

  public void init()
  {
    this.hasInitiliazed = true;
    this.usesNormalDt = !this.useEstimatedTime && !this.useManualTime && !this.useFrames;
    if (this.useFrames)
      this.optional.initFrameCount = Time.frameCount;
    if ((double) this.time <= 0.0)
      this.time = Mathf.Epsilon;
    if (this.initInternal != null)
      this.initInternal();
    this.diff = this.to - this.from;
    this.diffDiv2 = this.diff * 0.5f;
    if (this._optional.onStart != null)
      this._optional.onStart();
    if (this.onCompleteOnStart)
      this.callOnCompletes();
    if ((double) this.speed < 0.0)
      return;
    this.initSpeed();
  }

  public void initSpeed()
  {
    if (this.type == TweenAction.MOVE_CURVED || this.type == TweenAction.MOVE_CURVED_LOCAL)
      this.time = this._optional.path.distance / this.speed;
    else if (this.type == TweenAction.MOVE_SPLINE || this.type == TweenAction.MOVE_SPLINE_LOCAL)
      this.time = this._optional.spline.distance / this.speed;
    else
      this.time = (this.to - this.from).magnitude / this.speed;
  }

  public LTDescr updateNow()
  {
    this.updateInternal();
    return this;
  }

  public bool updateInternal()
  {
    float direction = this.direction;
    if (this.usesNormalDt)
      LTDescr.dt = LeanTween.dtActual;
    else if (this.useEstimatedTime)
      LTDescr.dt = LeanTween.dtEstimated;
    else if (this.useFrames)
    {
      LTDescr.dt = this.optional.initFrameCount == 0 ? 0.0f : 1f;
      this.optional.initFrameCount = Time.frameCount;
    }
    else if (this.useManualTime)
      LTDescr.dt = LeanTween.dtManual;
    if ((double) this.delay <= 0.0 && (double) direction != 0.0)
    {
      if ((UnityEngine.Object) this.trans == (UnityEngine.Object) null)
        return true;
      if (!this.hasInitiliazed)
        this.init();
      LTDescr.dt *= direction;
      this.passed += LTDescr.dt;
      this.passed = Mathf.Clamp(this.passed, 0.0f, this.time);
      this.ratioPassed = this.passed / this.time;
      this.easeInternal();
      if (this.hasUpdateCallback)
        this._optional.callOnUpdate(LTDescr.val, this.ratioPassed);
      if (((double) direction > 0.0 ? ((double) this.passed >= (double) this.time ? 1 : 0) : ((double) this.passed <= 0.0 ? 1 : 0)) != 0)
      {
        --this.loopCount;
        if (this.loopType == LeanTweenType.pingPong)
          this.direction = 0.0f - direction;
        else
          this.passed = Mathf.Epsilon;
        int num = this.loopCount == 0 ? 1 : (this.loopType == LeanTweenType.once ? 1 : 0);
        if (num != 0)
          return num != 0;
        if (!this.onCompleteOnRepeat)
          return num != 0;
        if (!this.hasExtraOnCompletes)
          return num != 0;
        this.callOnCompletes();
        return num != 0;
      }
    }
    else
      this.delay -= LTDescr.dt;
    return false;
  }

  public void callOnCompletes()
  {
    if (this.type == TweenAction.GUI_ROTATE)
      this._optional.ltRect.rotateFinished = true;
    if (this.type == TweenAction.DELAYED_SOUND)
      AudioSource.PlayClipAtPoint((AudioClip) this._optional.onCompleteParam, this.to, this.from.x);
    if (this._optional.onComplete != null)
    {
      this._optional.onComplete();
    }
    else
    {
      if (this._optional.onCompleteObject == null)
        return;
      this._optional.onCompleteObject(this._optional.onCompleteParam);
    }
  }

  public LTDescr setFromColor(Color col)
  {
    this.from = new Vector3(0.0f, col.a, 0.0f);
    this.diff = new Vector3(1f, 0.0f, 0.0f);
    this._optional.axis = new Vector3(col.r, col.g, col.b);
    return this;
  }

  public static void alphaRecursive(Transform transform, float val, bool useRecursion = true)
  {
    Renderer component = transform.gameObject.GetComponent<Renderer>();
    if ((UnityEngine.Object) component != (UnityEngine.Object) null)
    {
      foreach (Material material in component.materials)
      {
        if (material.HasProperty("_Color"))
          material.color = new Color(material.color.r, material.color.g, material.color.b, val);
        else if (material.HasProperty("_TintColor"))
        {
          Color color = material.GetColor("_TintColor");
          material.SetColor("_TintColor", new Color(color.r, color.g, color.b, val));
        }
      }
    }
    if (!useRecursion || transform.childCount <= 0)
      return;
    foreach (Transform transform1 in transform)
      LTDescr.alphaRecursive(transform1, val);
  }

  public static void colorRecursive(Transform transform, Color toColor, bool useRecursion = true)
  {
    Renderer component = transform.gameObject.GetComponent<Renderer>();
    if ((UnityEngine.Object) component != (UnityEngine.Object) null)
    {
      foreach (Material material in component.materials)
        material.color = toColor;
    }
    if (!useRecursion || transform.childCount <= 0)
      return;
    foreach (Transform transform1 in transform)
      LTDescr.colorRecursive(transform1, toColor);
  }

  public static void alphaRecursive(RectTransform rectTransform, float val, int recursiveLevel = 0)
  {
    if (rectTransform.childCount <= 0)
      return;
    foreach (RectTransform rectTransform1 in (Transform) rectTransform)
    {
      MaskableGraphic component1 = (MaskableGraphic) rectTransform1.GetComponent<Image>();
      if ((UnityEngine.Object) component1 != (UnityEngine.Object) null)
      {
        Color color = component1.color with { a = val };
        component1.color = color;
      }
      else
      {
        MaskableGraphic component2 = (MaskableGraphic) rectTransform1.GetComponent<RawImage>();
        if ((UnityEngine.Object) component2 != (UnityEngine.Object) null)
        {
          Color color = component2.color with { a = val };
          component2.color = color;
        }
      }
      LTDescr.alphaRecursive(rectTransform1, val, recursiveLevel + 1);
    }
  }

  public static void alphaRecursiveSprite(Transform transform, float val)
  {
    if (transform.childCount <= 0)
      return;
    foreach (Transform transform1 in transform)
    {
      SpriteRenderer component = transform1.GetComponent<SpriteRenderer>();
      if ((UnityEngine.Object) component != (UnityEngine.Object) null)
        component.color = new Color(component.color.r, component.color.g, component.color.b, val);
      LTDescr.alphaRecursiveSprite(transform1, val);
    }
  }

  public static void colorRecursiveSprite(Transform transform, Color toColor)
  {
    if (transform.childCount <= 0)
      return;
    foreach (Transform transform1 in transform)
    {
      SpriteRenderer component = transform.gameObject.GetComponent<SpriteRenderer>();
      if ((UnityEngine.Object) component != (UnityEngine.Object) null)
        component.color = toColor;
      Color toColor1 = toColor;
      LTDescr.colorRecursiveSprite(transform1, toColor1);
    }
  }

  public static void colorRecursive(RectTransform rectTransform, Color toColor)
  {
    if (rectTransform.childCount <= 0)
      return;
    foreach (RectTransform rectTransform1 in (Transform) rectTransform)
    {
      MaskableGraphic component1 = (MaskableGraphic) rectTransform1.GetComponent<Image>();
      if ((UnityEngine.Object) component1 != (UnityEngine.Object) null)
      {
        component1.color = toColor;
      }
      else
      {
        MaskableGraphic component2 = (MaskableGraphic) rectTransform1.GetComponent<RawImage>();
        if ((UnityEngine.Object) component2 != (UnityEngine.Object) null)
          component2.color = toColor;
      }
      LTDescr.colorRecursive(rectTransform1, toColor);
    }
  }

  public static void textAlphaChildrenRecursive(Transform trans, float val, bool useRecursion = true)
  {
    if (!useRecursion || trans.childCount <= 0)
      return;
    foreach (Transform tran in trans)
    {
      UnityEngine.UI.Text component = tran.GetComponent<UnityEngine.UI.Text>();
      if ((UnityEngine.Object) component != (UnityEngine.Object) null)
      {
        Color color = component.color with { a = val };
        component.color = color;
      }
      LTDescr.textAlphaChildrenRecursive(tran, val);
    }
  }

  public static void textAlphaRecursive(Transform trans, float val, bool useRecursion = true)
  {
    UnityEngine.UI.Text component = trans.GetComponent<UnityEngine.UI.Text>();
    if ((UnityEngine.Object) component != (UnityEngine.Object) null)
    {
      Color color = component.color with { a = val };
      component.color = color;
    }
    if (!useRecursion || trans.childCount <= 0)
      return;
    foreach (Transform tran in trans)
      LTDescr.textAlphaRecursive(tran, val);
  }

  public static void textColorRecursive(Transform trans, Color toColor)
  {
    if (trans.childCount <= 0)
      return;
    foreach (Transform tran in trans)
    {
      UnityEngine.UI.Text component = tran.GetComponent<UnityEngine.UI.Text>();
      if ((UnityEngine.Object) component != (UnityEngine.Object) null)
        component.color = toColor;
      LTDescr.textColorRecursive(tran, toColor);
    }
  }

  public static Color tweenColor(LTDescr tween, float val)
  {
    Vector3 vector3 = tween._optional.point - tween._optional.axis;
    float num = tween.to.y - tween.from.y;
    return new Color(tween._optional.axis.x + vector3.x * val, tween._optional.axis.y + vector3.y * val, tween._optional.axis.z + vector3.z * val, tween.from.y + num * val);
  }

  public LTDescr pause()
  {
    if ((double) this.direction != 0.0)
    {
      this.directionLast = this.direction;
      this.direction = 0.0f;
    }
    return this;
  }

  public LTDescr resume()
  {
    this.direction = this.directionLast;
    return this;
  }

  public LTDescr setAxis(Vector3 axis)
  {
    this._optional.axis = axis;
    return this;
  }

  public LTDescr setDelay(float delay)
  {
    this.delay = delay;
    return this;
  }

  public LTDescr setEase(LeanTweenType easeType)
  {
    switch (easeType)
    {
      case LeanTweenType.linear:
        this.setEaseLinear();
        break;
      case LeanTweenType.easeOutQuad:
        this.setEaseOutQuad();
        break;
      case LeanTweenType.easeInQuad:
        this.setEaseInQuad();
        break;
      case LeanTweenType.easeInOutQuad:
        this.setEaseInOutQuad();
        break;
      case LeanTweenType.easeInCubic:
        this.setEaseInCubic();
        break;
      case LeanTweenType.easeOutCubic:
        this.setEaseOutCubic();
        break;
      case LeanTweenType.easeInOutCubic:
        this.setEaseInOutCubic();
        break;
      case LeanTweenType.easeInQuart:
        this.setEaseInQuart();
        break;
      case LeanTweenType.easeOutQuart:
        this.setEaseOutQuart();
        break;
      case LeanTweenType.easeInOutQuart:
        this.setEaseInOutQuart();
        break;
      case LeanTweenType.easeInQuint:
        this.setEaseInQuint();
        break;
      case LeanTweenType.easeOutQuint:
        this.setEaseOutQuint();
        break;
      case LeanTweenType.easeInOutQuint:
        this.setEaseInOutQuint();
        break;
      case LeanTweenType.easeInSine:
        this.setEaseInSine();
        break;
      case LeanTweenType.easeOutSine:
        this.setEaseOutSine();
        break;
      case LeanTweenType.easeInOutSine:
        this.setEaseInOutSine();
        break;
      case LeanTweenType.easeInExpo:
        this.setEaseInExpo();
        break;
      case LeanTweenType.easeOutExpo:
        this.setEaseOutExpo();
        break;
      case LeanTweenType.easeInOutExpo:
        this.setEaseInOutExpo();
        break;
      case LeanTweenType.easeInCirc:
        this.setEaseInCirc();
        break;
      case LeanTweenType.easeOutCirc:
        this.setEaseOutCirc();
        break;
      case LeanTweenType.easeInOutCirc:
        this.setEaseInOutCirc();
        break;
      case LeanTweenType.easeInBounce:
        this.setEaseInBounce();
        break;
      case LeanTweenType.easeOutBounce:
        this.setEaseOutBounce();
        break;
      case LeanTweenType.easeInOutBounce:
        this.setEaseInOutBounce();
        break;
      case LeanTweenType.easeInBack:
        this.setEaseInBack();
        break;
      case LeanTweenType.easeOutBack:
        this.setEaseOutBack();
        break;
      case LeanTweenType.easeInOutBack:
        this.setEaseInOutBack();
        break;
      case LeanTweenType.easeInElastic:
        this.setEaseInElastic();
        break;
      case LeanTweenType.easeOutElastic:
        this.setEaseOutElastic();
        break;
      case LeanTweenType.easeInOutElastic:
        this.setEaseInOutElastic();
        break;
      case LeanTweenType.easeSpring:
        this.setEaseSpring();
        break;
      case LeanTweenType.easeShake:
        this.setEaseShake();
        break;
      case LeanTweenType.punch:
        this.setEasePunch();
        break;
      default:
        this.setEaseLinear();
        break;
    }
    return this;
  }

  public LTDescr setEaseLinear()
  {
    this.easeType = LeanTweenType.linear;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeLinear);
    return this;
  }

  public LTDescr setEaseSpring()
  {
    this.easeType = LeanTweenType.easeSpring;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeSpring);
    return this;
  }

  public LTDescr setEaseInQuad()
  {
    this.easeType = LeanTweenType.easeInQuad;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInQuad);
    return this;
  }

  public LTDescr setEaseOutQuad()
  {
    this.easeType = LeanTweenType.easeOutQuad;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeOutQuad);
    return this;
  }

  public LTDescr setEaseInOutQuad()
  {
    this.easeType = LeanTweenType.easeInOutQuad;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInOutQuad);
    return this;
  }

  public LTDescr setEaseInCubic()
  {
    this.easeType = LeanTweenType.easeInCubic;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInCubic);
    return this;
  }

  public LTDescr setEaseOutCubic()
  {
    this.easeType = LeanTweenType.easeOutCubic;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeOutCubic);
    return this;
  }

  public LTDescr setEaseInOutCubic()
  {
    this.easeType = LeanTweenType.easeInOutCubic;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInOutCubic);
    return this;
  }

  public LTDescr setEaseInQuart()
  {
    this.easeType = LeanTweenType.easeInQuart;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInQuart);
    return this;
  }

  public LTDescr setEaseOutQuart()
  {
    this.easeType = LeanTweenType.easeOutQuart;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeOutQuart);
    return this;
  }

  public LTDescr setEaseInOutQuart()
  {
    this.easeType = LeanTweenType.easeInOutQuart;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInOutQuart);
    return this;
  }

  public LTDescr setEaseInQuint()
  {
    this.easeType = LeanTweenType.easeInQuint;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInQuint);
    return this;
  }

  public LTDescr setEaseOutQuint()
  {
    this.easeType = LeanTweenType.easeOutQuint;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeOutQuint);
    return this;
  }

  public LTDescr setEaseInOutQuint()
  {
    this.easeType = LeanTweenType.easeInOutQuint;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInOutQuint);
    return this;
  }

  public LTDescr setEaseInSine()
  {
    this.easeType = LeanTweenType.easeInSine;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInSine);
    return this;
  }

  public LTDescr setEaseOutSine()
  {
    this.easeType = LeanTweenType.easeOutSine;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeOutSine);
    return this;
  }

  public LTDescr setEaseInOutSine()
  {
    this.easeType = LeanTweenType.easeInOutSine;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInOutSine);
    return this;
  }

  public LTDescr setEaseInExpo()
  {
    this.easeType = LeanTweenType.easeInExpo;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInExpo);
    return this;
  }

  public LTDescr setEaseOutExpo()
  {
    this.easeType = LeanTweenType.easeOutExpo;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeOutExpo);
    return this;
  }

  public LTDescr setEaseInOutExpo()
  {
    this.easeType = LeanTweenType.easeInOutExpo;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInOutExpo);
    return this;
  }

  public LTDescr setEaseInCirc()
  {
    this.easeType = LeanTweenType.easeInCirc;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInCirc);
    return this;
  }

  public LTDescr setEaseOutCirc()
  {
    this.easeType = LeanTweenType.easeOutCirc;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeOutCirc);
    return this;
  }

  public LTDescr setEaseInOutCirc()
  {
    this.easeType = LeanTweenType.easeInOutCirc;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInOutCirc);
    return this;
  }

  public LTDescr setEaseInBounce()
  {
    this.easeType = LeanTweenType.easeInBounce;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInBounce);
    return this;
  }

  public LTDescr setEaseOutBounce()
  {
    this.easeType = LeanTweenType.easeOutBounce;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeOutBounce);
    return this;
  }

  public LTDescr setEaseInOutBounce()
  {
    this.easeType = LeanTweenType.easeInOutBounce;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInOutBounce);
    return this;
  }

  public LTDescr setEaseInBack()
  {
    this.easeType = LeanTweenType.easeInBack;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInBack);
    return this;
  }

  public LTDescr setEaseOutBack()
  {
    this.easeType = LeanTweenType.easeOutBack;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeOutBack);
    return this;
  }

  public LTDescr setEaseInOutBack()
  {
    this.easeType = LeanTweenType.easeInOutBack;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInOutBack);
    return this;
  }

  public LTDescr setEaseInElastic()
  {
    this.easeType = LeanTweenType.easeInElastic;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInElastic);
    return this;
  }

  public LTDescr setEaseOutElastic()
  {
    this.easeType = LeanTweenType.easeOutElastic;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeOutElastic);
    return this;
  }

  public LTDescr setEaseInOutElastic()
  {
    this.easeType = LeanTweenType.easeInOutElastic;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.easeInOutElastic);
    return this;
  }

  public LTDescr setEasePunch()
  {
    this._optional.animationCurve = LeanTween.punch;
    this.toInternal.x = this.from.x + this.to.x;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.tweenOnCurve);
    return this;
  }

  public LTDescr setEaseShake()
  {
    this._optional.animationCurve = LeanTween.shake;
    this.toInternal.x = this.from.x + this.to.x;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.tweenOnCurve);
    return this;
  }

  public Vector3 tweenOnCurve() => new Vector3(this.from.x + this.diff.x * this._optional.animationCurve.Evaluate(this.ratioPassed), this.from.y + this.diff.y * this._optional.animationCurve.Evaluate(this.ratioPassed), this.from.z + this.diff.z * this._optional.animationCurve.Evaluate(this.ratioPassed));

  public Vector3 easeInOutQuad()
  {
    LTDescr.val = this.ratioPassed * 2f;
    if ((double) LTDescr.val < 1.0)
    {
      LTDescr.val *= LTDescr.val;
      return new Vector3(this.diffDiv2.x * LTDescr.val + this.from.x, this.diffDiv2.y * LTDescr.val + this.from.y, this.diffDiv2.z * LTDescr.val + this.from.z);
    }
    LTDescr.val = (float) ((1.0 - (double) LTDescr.val) * ((double) LTDescr.val - 3.0) + 1.0);
    return new Vector3(this.diffDiv2.x * LTDescr.val + this.from.x, this.diffDiv2.y * LTDescr.val + this.from.y, this.diffDiv2.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInQuad()
  {
    LTDescr.val = this.ratioPassed * this.ratioPassed;
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeOutQuad()
  {
    LTDescr.val = this.ratioPassed;
    LTDescr.val = (float) (-(double) LTDescr.val * ((double) LTDescr.val - 2.0));
    return this.diff * LTDescr.val + this.from;
  }

  public Vector3 easeLinear()
  {
    LTDescr.val = this.ratioPassed;
    return new Vector3(this.from.x + this.diff.x * LTDescr.val, this.from.y + this.diff.y * LTDescr.val, this.from.z + this.diff.z * LTDescr.val);
  }

  public Vector3 easeSpring()
  {
    LTDescr.val = Mathf.Clamp01(this.ratioPassed);
    LTDescr.val = (float) (((double) Mathf.Sin((float) ((double) LTDescr.val * 3.1415927410125732 * (0.20000000298023224 + 2.5 * (double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val))) * (double) Mathf.Pow(1f - LTDescr.val, 2.2f) + (double) LTDescr.val) * (1.0 + 1.2000000476837158 * (1.0 - (double) LTDescr.val)));
    return this.from + this.diff * LTDescr.val;
  }

  public Vector3 easeInCubic()
  {
    LTDescr.val = this.ratioPassed * this.ratioPassed * this.ratioPassed;
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeOutCubic()
  {
    LTDescr.val = this.ratioPassed - 1f;
    LTDescr.val = (float) ((double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val + 1.0);
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInOutCubic()
  {
    LTDescr.val = this.ratioPassed * 2f;
    if ((double) LTDescr.val < 1.0)
    {
      LTDescr.val = LTDescr.val * LTDescr.val * LTDescr.val;
      return new Vector3(this.diffDiv2.x * LTDescr.val + this.from.x, this.diffDiv2.y * LTDescr.val + this.from.y, this.diffDiv2.z * LTDescr.val + this.from.z);
    }
    LTDescr.val -= 2f;
    LTDescr.val = (float) ((double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val + 2.0);
    return new Vector3(this.diffDiv2.x * LTDescr.val + this.from.x, this.diffDiv2.y * LTDescr.val + this.from.y, this.diffDiv2.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInQuart()
  {
    LTDescr.val = this.ratioPassed * this.ratioPassed * this.ratioPassed * this.ratioPassed;
    return this.diff * LTDescr.val + this.from;
  }

  public Vector3 easeOutQuart()
  {
    LTDescr.val = this.ratioPassed - 1f;
    LTDescr.val = (float) -((double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val - 1.0);
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInOutQuart()
  {
    LTDescr.val = this.ratioPassed * 2f;
    if ((double) LTDescr.val < 1.0)
    {
      LTDescr.val = LTDescr.val * LTDescr.val * LTDescr.val * LTDescr.val;
      return new Vector3(this.diffDiv2.x * LTDescr.val + this.from.x, this.diffDiv2.y * LTDescr.val + this.from.y, this.diffDiv2.z * LTDescr.val + this.from.z);
    }
    LTDescr.val -= 2f;
    return -this.diffDiv2 * (float) ((double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val - 2.0) + this.from;
  }

  public Vector3 easeInQuint()
  {
    LTDescr.val = this.ratioPassed;
    LTDescr.val = LTDescr.val * LTDescr.val * LTDescr.val * LTDescr.val * LTDescr.val;
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeOutQuint()
  {
    LTDescr.val = this.ratioPassed - 1f;
    LTDescr.val = (float) ((double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val + 1.0);
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInOutQuint()
  {
    LTDescr.val = this.ratioPassed * 2f;
    if ((double) LTDescr.val < 1.0)
    {
      LTDescr.val = LTDescr.val * LTDescr.val * LTDescr.val * LTDescr.val * LTDescr.val;
      return new Vector3(this.diffDiv2.x * LTDescr.val + this.from.x, this.diffDiv2.y * LTDescr.val + this.from.y, this.diffDiv2.z * LTDescr.val + this.from.z);
    }
    LTDescr.val -= 2f;
    LTDescr.val = (float) ((double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val * (double) LTDescr.val + 2.0);
    return new Vector3(this.diffDiv2.x * LTDescr.val + this.from.x, this.diffDiv2.y * LTDescr.val + this.from.y, this.diffDiv2.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInSine()
  {
    LTDescr.val = -Mathf.Cos(this.ratioPassed * LeanTween.PI_DIV2);
    return new Vector3(this.diff.x * LTDescr.val + this.diff.x + this.from.x, this.diff.y * LTDescr.val + this.diff.y + this.from.y, this.diff.z * LTDescr.val + this.diff.z + this.from.z);
  }

  public Vector3 easeOutSine()
  {
    LTDescr.val = Mathf.Sin(this.ratioPassed * LeanTween.PI_DIV2);
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInOutSine()
  {
    LTDescr.val = (float) -((double) Mathf.Cos(3.14159274f * this.ratioPassed) - 1.0);
    return new Vector3(this.diffDiv2.x * LTDescr.val + this.from.x, this.diffDiv2.y * LTDescr.val + this.from.y, this.diffDiv2.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInExpo()
  {
    LTDescr.val = Mathf.Pow(2f, (float) (10.0 * ((double) this.ratioPassed - 1.0)));
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeOutExpo()
  {
    LTDescr.val = (float) (-(double) Mathf.Pow(2f, -10f * this.ratioPassed) + 1.0);
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInOutExpo()
  {
    LTDescr.val = this.ratioPassed * 2f;
    if ((double) LTDescr.val < 1.0)
      return this.diffDiv2 * Mathf.Pow(2f, (float) (10.0 * ((double) LTDescr.val - 1.0))) + this.from;
    --LTDescr.val;
    return this.diffDiv2 * (float) (-(double) Mathf.Pow(2f, -10f * LTDescr.val) + 2.0) + this.from;
  }

  public Vector3 easeInCirc()
  {
    LTDescr.val = (float) -((double) Mathf.Sqrt((float) (1.0 - (double) this.ratioPassed * (double) this.ratioPassed)) - 1.0);
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeOutCirc()
  {
    LTDescr.val = this.ratioPassed - 1f;
    LTDescr.val = Mathf.Sqrt((float) (1.0 - (double) LTDescr.val * (double) LTDescr.val));
    return new Vector3(this.diff.x * LTDescr.val + this.from.x, this.diff.y * LTDescr.val + this.from.y, this.diff.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInOutCirc()
  {
    LTDescr.val = this.ratioPassed * 2f;
    if ((double) LTDescr.val < 1.0)
    {
      LTDescr.val = (float) -((double) Mathf.Sqrt((float) (1.0 - (double) LTDescr.val * (double) LTDescr.val)) - 1.0);
      return new Vector3(this.diffDiv2.x * LTDescr.val + this.from.x, this.diffDiv2.y * LTDescr.val + this.from.y, this.diffDiv2.z * LTDescr.val + this.from.z);
    }
    LTDescr.val -= 2f;
    LTDescr.val = Mathf.Sqrt((float) (1.0 - (double) LTDescr.val * (double) LTDescr.val)) + 1f;
    return new Vector3(this.diffDiv2.x * LTDescr.val + this.from.x, this.diffDiv2.y * LTDescr.val + this.from.y, this.diffDiv2.z * LTDescr.val + this.from.z);
  }

  public Vector3 easeInBounce()
  {
    LTDescr.val = this.ratioPassed;
    LTDescr.val = 1f - LTDescr.val;
    return new Vector3(this.diff.x - LeanTween.easeOutBounce(0.0f, this.diff.x, LTDescr.val) + this.from.x, this.diff.y - LeanTween.easeOutBounce(0.0f, this.diff.y, LTDescr.val) + this.from.y, this.diff.z - LeanTween.easeOutBounce(0.0f, this.diff.z, LTDescr.val) + this.from.z);
  }

  public Vector3 easeOutBounce()
  {
    LTDescr.val = this.ratioPassed;
    float num1;
    if ((double) LTDescr.val < (double) (num1 = (float) (1.0 - 1.75 * (double) this.overshoot / 2.75)))
    {
      LTDescr.val = 1f / num1 / num1 * LTDescr.val * LTDescr.val;
    }
    else
    {
      float num2;
      if ((double) LTDescr.val < (double) (num2 = (float) (1.0 - 0.75 * (double) this.overshoot / 2.75)))
      {
        LTDescr.val -= (float) (((double) num1 + (double) num2) / 2.0);
        LTDescr.val = (float) (121.0 / 16.0 * (double) LTDescr.val * (double) LTDescr.val + 1.0 - 0.25 * (double) this.overshoot * (double) this.overshoot);
      }
      else
      {
        float num3;
        if ((double) LTDescr.val < (double) (num3 = (float) (1.0 - 0.25 * (double) this.overshoot / 2.75)))
        {
          LTDescr.val -= (float) (((double) num3 + (double) num2) / 2.0);
          LTDescr.val = (float) (121.0 / 16.0 * (double) LTDescr.val * (double) LTDescr.val + 1.0 - 1.0 / 16.0 * (double) this.overshoot * (double) this.overshoot);
        }
        else
        {
          LTDescr.val -= (float) (((double) num3 + 1.0) / 2.0);
          LTDescr.val = (float) (121.0 / 16.0 * (double) LTDescr.val * (double) LTDescr.val + 1.0 - 1.0 / 64.0 * (double) this.overshoot * (double) this.overshoot);
        }
      }
    }
    return this.diff * LTDescr.val + this.from;
  }

  public Vector3 easeInOutBounce()
  {
    LTDescr.val = this.ratioPassed * 2f;
    if ((double) LTDescr.val < 1.0)
      return new Vector3(LeanTween.easeInBounce(0.0f, this.diff.x, LTDescr.val) * 0.5f + this.from.x, LeanTween.easeInBounce(0.0f, this.diff.y, LTDescr.val) * 0.5f + this.from.y, LeanTween.easeInBounce(0.0f, this.diff.z, LTDescr.val) * 0.5f + this.from.z);
    --LTDescr.val;
    return new Vector3(LeanTween.easeOutBounce(0.0f, this.diff.x, LTDescr.val) * 0.5f + this.diffDiv2.x + this.from.x, LeanTween.easeOutBounce(0.0f, this.diff.y, LTDescr.val) * 0.5f + this.diffDiv2.y + this.from.y, LeanTween.easeOutBounce(0.0f, this.diff.z, LTDescr.val) * 0.5f + this.diffDiv2.z + this.from.z);
  }

  public Vector3 easeInBack()
  {
    LTDescr.val = this.ratioPassed;
    LTDescr.val /= 1f;
    float num = 1.70158f * this.overshoot;
    return this.diff * LTDescr.val * LTDescr.val * ((num + 1f) * LTDescr.val - num) + this.from;
  }

  public Vector3 easeOutBack()
  {
    float num = 1.70158f * this.overshoot;
    LTDescr.val = (float) ((double) this.ratioPassed / 1.0 - 1.0);
    LTDescr.val = (float) ((double) LTDescr.val * (double) LTDescr.val * (((double) num + 1.0) * (double) LTDescr.val + (double) num) + 1.0);
    return this.diff * LTDescr.val + this.from;
  }

  public Vector3 easeInOutBack()
  {
    float num1 = 1.70158f * this.overshoot;
    LTDescr.val = this.ratioPassed * 2f;
    if ((double) LTDescr.val < 1.0)
    {
      float num2 = num1 * (1.525f * this.overshoot);
      return this.diffDiv2 * (float) ((double) LTDescr.val * (double) LTDescr.val * (((double) num2 + 1.0) * (double) LTDescr.val - (double) num2)) + this.from;
    }
    LTDescr.val -= 2f;
    float num3 = num1 * (1.525f * this.overshoot);
    LTDescr.val = (float) ((double) LTDescr.val * (double) LTDescr.val * (((double) num3 + 1.0) * (double) LTDescr.val + (double) num3) + 2.0);
    return this.diffDiv2 * LTDescr.val + this.from;
  }

  public Vector3 easeInElastic() => new Vector3(LeanTween.easeInElastic(this.from.x, this.to.x, this.ratioPassed, this.overshoot, this.period), LeanTween.easeInElastic(this.from.y, this.to.y, this.ratioPassed, this.overshoot, this.period), LeanTween.easeInElastic(this.from.z, this.to.z, this.ratioPassed, this.overshoot, this.period));

  public Vector3 easeOutElastic() => new Vector3(LeanTween.easeOutElastic(this.from.x, this.to.x, this.ratioPassed, this.overshoot, this.period), LeanTween.easeOutElastic(this.from.y, this.to.y, this.ratioPassed, this.overshoot, this.period), LeanTween.easeOutElastic(this.from.z, this.to.z, this.ratioPassed, this.overshoot, this.period));

  public Vector3 easeInOutElastic() => new Vector3(LeanTween.easeInOutElastic(this.from.x, this.to.x, this.ratioPassed, this.overshoot, this.period), LeanTween.easeInOutElastic(this.from.y, this.to.y, this.ratioPassed, this.overshoot, this.period), LeanTween.easeInOutElastic(this.from.z, this.to.z, this.ratioPassed, this.overshoot, this.period));

  public LTDescr setOvershoot(float overshoot)
  {
    this.overshoot = overshoot;
    return this;
  }

  public LTDescr setPeriod(float period)
  {
    this.period = period;
    return this;
  }

  public LTDescr setScale(float scale)
  {
    this.scale = scale;
    return this;
  }

  public LTDescr setEase(AnimationCurve easeCurve)
  {
    this._optional.animationCurve = easeCurve;
    this.easeMethod = new LTDescr.EaseTypeDelegate(this.tweenOnCurve);
    this.easeType = LeanTweenType.animationCurve;
    return this;
  }

  public LTDescr setTo(Vector3 to)
  {
    if (this.hasInitiliazed)
    {
      this.to = to;
      this.diff = to - this.from;
    }
    else
      this.to = to;
    return this;
  }

  public LTDescr setTo(Transform to)
  {
    this._optional.toTrans = to;
    return this;
  }

  public LTDescr setFrom(Vector3 from)
  {
    if ((bool) (UnityEngine.Object) this.trans)
      this.init();
    this.from = from;
    this.diff = this.to - this.from;
    this.diffDiv2 = this.diff * 0.5f;
    return this;
  }

  public LTDescr setFrom(float from) => this.setFrom(new Vector3(from, 0.0f, 0.0f));

  public LTDescr setDiff(Vector3 diff)
  {
    this.diff = diff;
    return this;
  }

  public LTDescr setHasInitialized(bool has)
  {
    this.hasInitiliazed = has;
    return this;
  }

  public LTDescr setId(uint id, uint global_counter)
  {
    this._id = id;
    this.counter = global_counter;
    return this;
  }

  public LTDescr setPassed(float passed)
  {
    this.passed = passed;
    return this;
  }

  public LTDescr setTime(float time)
  {
    float num = this.passed / this.time;
    this.passed = time * num;
    this.time = time;
    return this;
  }

  public LTDescr setSpeed(float speed)
  {
    this.speed = speed;
    if (this.hasInitiliazed)
      this.initSpeed();
    return this;
  }

  public LTDescr setRepeat(int repeat)
  {
    this.loopCount = repeat;
    if (repeat > 1 && this.loopType == LeanTweenType.once || repeat < 0 && this.loopType == LeanTweenType.once)
      this.loopType = LeanTweenType.clamp;
    if (this.type == TweenAction.CALLBACK || this.type == TweenAction.CALLBACK_COLOR)
      this.setOnCompleteOnRepeat(true);
    return this;
  }

  public LTDescr setLoopType(LeanTweenType loopType)
  {
    this.loopType = loopType;
    return this;
  }

  public LTDescr setUseEstimatedTime(bool useEstimatedTime)
  {
    this.useEstimatedTime = useEstimatedTime;
    this.usesNormalDt = false;
    return this;
  }

  public LTDescr setIgnoreTimeScale(bool useUnScaledTime)
  {
    this.useEstimatedTime = useUnScaledTime;
    this.usesNormalDt = false;
    return this;
  }

  public LTDescr setUseFrames(bool useFrames)
  {
    this.useFrames = useFrames;
    this.usesNormalDt = false;
    return this;
  }

  public LTDescr setUseManualTime(bool useManualTime)
  {
    this.useManualTime = useManualTime;
    this.usesNormalDt = false;
    return this;
  }

  public LTDescr setLoopCount(int loopCount)
  {
    this.loopType = LeanTweenType.clamp;
    this.loopCount = loopCount;
    return this;
  }

  public LTDescr setLoopOnce()
  {
    this.loopType = LeanTweenType.once;
    return this;
  }

  public LTDescr setLoopClamp()
  {
    this.loopType = LeanTweenType.clamp;
    if (this.loopCount == 0)
      this.loopCount = -1;
    return this;
  }

  public LTDescr setLoopClamp(int loops)
  {
    this.loopCount = loops;
    return this;
  }

  public LTDescr setLoopPingPong()
  {
    this.loopType = LeanTweenType.pingPong;
    if (this.loopCount == 0)
      this.loopCount = -1;
    return this;
  }

  public LTDescr setLoopPingPong(int loops)
  {
    this.loopType = LeanTweenType.pingPong;
    this.loopCount = loops == -1 ? loops : loops * 2;
    return this;
  }

  public LTDescr setOnComplete(System.Action onComplete)
  {
    this._optional.onComplete = onComplete;
    this.hasExtraOnCompletes = true;
    return this;
  }

  public LTDescr setOnComplete(Action<object> onComplete)
  {
    this._optional.onCompleteObject = onComplete;
    this.hasExtraOnCompletes = true;
    return this;
  }

  public LTDescr setOnComplete(Action<object> onComplete, object onCompleteParam)
  {
    this._optional.onCompleteObject = onComplete;
    this.hasExtraOnCompletes = true;
    if (onCompleteParam != null)
      this._optional.onCompleteParam = onCompleteParam;
    return this;
  }

  public LTDescr setOnCompleteParam(object onCompleteParam)
  {
    this._optional.onCompleteParam = onCompleteParam;
    this.hasExtraOnCompletes = true;
    return this;
  }

  public LTDescr setOnUpdate(Action<float> onUpdate)
  {
    this._optional.onUpdateFloat = onUpdate;
    this.hasUpdateCallback = true;
    return this;
  }

  public LTDescr setOnUpdateRatio(Action<float, float> onUpdate)
  {
    this._optional.onUpdateFloatRatio = onUpdate;
    this.hasUpdateCallback = true;
    return this;
  }

  public LTDescr setOnUpdateObject(Action<float, object> onUpdate)
  {
    this._optional.onUpdateFloatObject = onUpdate;
    this.hasUpdateCallback = true;
    return this;
  }

  public LTDescr setOnUpdateVector2(Action<Vector2> onUpdate)
  {
    this._optional.onUpdateVector2 = onUpdate;
    this.hasUpdateCallback = true;
    return this;
  }

  public LTDescr setOnUpdateVector3(Action<Vector3> onUpdate)
  {
    this._optional.onUpdateVector3 = onUpdate;
    this.hasUpdateCallback = true;
    return this;
  }

  public LTDescr setOnUpdateColor(Action<Color> onUpdate)
  {
    this._optional.onUpdateColor = onUpdate;
    this.hasUpdateCallback = true;
    return this;
  }

  public LTDescr setOnUpdateColor(Action<Color, object> onUpdate)
  {
    this._optional.onUpdateColorObject = onUpdate;
    this.hasUpdateCallback = true;
    return this;
  }

  public LTDescr setOnUpdate(Action<Color> onUpdate)
  {
    this._optional.onUpdateColor = onUpdate;
    this.hasUpdateCallback = true;
    return this;
  }

  public LTDescr setOnUpdate(Action<Color, object> onUpdate)
  {
    this._optional.onUpdateColorObject = onUpdate;
    this.hasUpdateCallback = true;
    return this;
  }

  public LTDescr setOnUpdate(Action<float, object> onUpdate, object onUpdateParam = null)
  {
    this._optional.onUpdateFloatObject = onUpdate;
    this.hasUpdateCallback = true;
    if (onUpdateParam != null)
      this._optional.onUpdateParam = onUpdateParam;
    return this;
  }

  public LTDescr setOnUpdate(Action<Vector3, object> onUpdate, object onUpdateParam = null)
  {
    this._optional.onUpdateVector3Object = onUpdate;
    this.hasUpdateCallback = true;
    if (onUpdateParam != null)
      this._optional.onUpdateParam = onUpdateParam;
    return this;
  }

  public LTDescr setOnUpdate(Action<Vector2> onUpdate, object onUpdateParam = null)
  {
    this._optional.onUpdateVector2 = onUpdate;
    this.hasUpdateCallback = true;
    if (onUpdateParam != null)
      this._optional.onUpdateParam = onUpdateParam;
    return this;
  }

  public LTDescr setOnUpdate(Action<Vector3> onUpdate, object onUpdateParam = null)
  {
    this._optional.onUpdateVector3 = onUpdate;
    this.hasUpdateCallback = true;
    if (onUpdateParam != null)
      this._optional.onUpdateParam = onUpdateParam;
    return this;
  }

  public LTDescr setOnUpdateParam(object onUpdateParam)
  {
    this._optional.onUpdateParam = onUpdateParam;
    return this;
  }

  public LTDescr setOrientToPath(bool doesOrient)
  {
    if (this.type == TweenAction.MOVE_CURVED || this.type == TweenAction.MOVE_CURVED_LOCAL)
    {
      if (this._optional.path == null)
        this._optional.path = new LTBezierPath();
      this._optional.path.orientToPath = doesOrient;
    }
    else
      this._optional.spline.orientToPath = doesOrient;
    return this;
  }

  public LTDescr setOrientToPath2d(bool doesOrient2d)
  {
    this.setOrientToPath(doesOrient2d);
    if (this.type == TweenAction.MOVE_CURVED || this.type == TweenAction.MOVE_CURVED_LOCAL)
      this._optional.path.orientToPath2d = doesOrient2d;
    else
      this._optional.spline.orientToPath2d = doesOrient2d;
    return this;
  }

  public LTDescr setRect(LTRect rect)
  {
    this._optional.ltRect = rect;
    return this;
  }

  public LTDescr setRect(Rect rect)
  {
    this._optional.ltRect = new LTRect(rect);
    return this;
  }

  public LTDescr setPath(LTBezierPath path)
  {
    this._optional.path = path;
    return this;
  }

  public LTDescr setPoint(Vector3 point)
  {
    this._optional.point = point;
    return this;
  }

  public LTDescr setDestroyOnComplete(bool doesDestroy)
  {
    this.destroyOnComplete = doesDestroy;
    return this;
  }

  public LTDescr setAudio(object audio)
  {
    this._optional.onCompleteParam = audio;
    return this;
  }

  public LTDescr setOnCompleteOnRepeat(bool isOn)
  {
    this.onCompleteOnRepeat = isOn;
    return this;
  }

  public LTDescr setOnCompleteOnStart(bool isOn)
  {
    this.onCompleteOnStart = isOn;
    return this;
  }

  public LTDescr setRect(RectTransform rect)
  {
    this.rectTransform = rect;
    return this;
  }

  public LTDescr setSprites(Sprite[] sprites)
  {
    this.sprites = sprites;
    return this;
  }

  public LTDescr setFrameRate(float frameRate)
  {
    this.time = (float) this.sprites.Length / frameRate;
    return this;
  }

  public LTDescr setOnStart(System.Action onStart)
  {
    this._optional.onStart = onStart;
    return this;
  }

  public LTDescr setDirection(float direction)
  {
    if ((double) this.direction != -1.0 && (double) this.direction != 1.0)
    {
      Debug.LogWarning((object) ("You have passed an incorrect direction of '" + direction.ToString() + "', direction must be -1f or 1f"));
      return this;
    }
    if ((double) this.direction != (double) direction)
    {
      if (this.hasInitiliazed)
        this.direction = direction;
      else if (this._optional.path != null)
        this._optional.path = new LTBezierPath(LTUtility.reverse(this._optional.path.pts));
      else if (this._optional.spline != null)
        this._optional.spline = new LTSpline(LTUtility.reverse(this._optional.spline.pts));
    }
    return this;
  }

  public LTDescr setRecursive(bool useRecursion)
  {
    this.useRecursion = useRecursion;
    return this;
  }

  [CompilerGenerated]
  public void \u003CsetMoveX\u003Eb__73_0() => this.fromInternal.x = this.trans.position.x;

  [CompilerGenerated]
  public void \u003CsetMoveX\u003Eb__73_1() => this.trans.position = new Vector3(this.easeMethod().x, this.trans.position.y, this.trans.position.z);

  [CompilerGenerated]
  public void \u003CsetMoveY\u003Eb__74_0() => this.fromInternal.x = this.trans.position.y;

  [CompilerGenerated]
  public void \u003CsetMoveY\u003Eb__74_1() => this.trans.position = new Vector3(this.trans.position.x, this.easeMethod().x, this.trans.position.z);

  [CompilerGenerated]
  public void \u003CsetMoveZ\u003Eb__75_0() => this.fromInternal.x = this.trans.position.z;

  [CompilerGenerated]
  public void \u003CsetMoveZ\u003Eb__75_1() => this.trans.position = new Vector3(this.trans.position.x, this.trans.position.y, this.easeMethod().x);

  [CompilerGenerated]
  public void \u003CsetMoveLocalX\u003Eb__76_0() => this.fromInternal.x = this.trans.localPosition.x;

  [CompilerGenerated]
  public void \u003CsetMoveLocalX\u003Eb__76_1() => this.trans.localPosition = new Vector3(this.easeMethod().x, this.trans.localPosition.y, this.trans.localPosition.z);

  [CompilerGenerated]
  public void \u003CsetMoveLocalY\u003Eb__77_0() => this.fromInternal.x = this.trans.localPosition.y;

  [CompilerGenerated]
  public void \u003CsetMoveLocalY\u003Eb__77_1() => this.trans.localPosition = new Vector3(this.trans.localPosition.x, this.easeMethod().x, this.trans.localPosition.z);

  [CompilerGenerated]
  public void \u003CsetMoveLocalZ\u003Eb__78_0() => this.fromInternal.x = this.trans.localPosition.z;

  [CompilerGenerated]
  public void \u003CsetMoveLocalZ\u003Eb__78_1() => this.trans.localPosition = new Vector3(this.trans.localPosition.x, this.trans.localPosition.y, this.easeMethod().x);

  [CompilerGenerated]
  public void \u003CsetMoveCurved\u003Eb__81_0()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    if (this._optional.path.orientToPath)
    {
      if (this._optional.path.orientToPath2d)
        this._optional.path.place2d(this.trans, LTDescr.val);
      else
        this._optional.path.place(this.trans, LTDescr.val);
    }
    else
      this.trans.position = this._optional.path.point(LTDescr.val);
  }

  [CompilerGenerated]
  public void \u003CsetMoveCurvedLocal\u003Eb__82_0()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    if (this._optional.path.orientToPath)
    {
      if (this._optional.path.orientToPath2d)
        this._optional.path.placeLocal2d(this.trans, LTDescr.val);
      else
        this._optional.path.placeLocal(this.trans, LTDescr.val);
    }
    else
      this.trans.localPosition = this._optional.path.point(LTDescr.val);
  }

  [CompilerGenerated]
  public void \u003CsetMoveSpline\u003Eb__83_0()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    if (this._optional.spline.orientToPath)
    {
      if (this._optional.spline.orientToPath2d)
        this._optional.spline.place2d(this.trans, LTDescr.val);
      else
        this._optional.spline.place(this.trans, LTDescr.val);
    }
    else
      this.trans.position = this._optional.spline.point(LTDescr.val);
  }

  [CompilerGenerated]
  public void \u003CsetMoveSplineLocal\u003Eb__84_0()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    if (this._optional.spline.orientToPath)
    {
      if (this._optional.spline.orientToPath2d)
        this._optional.spline.placeLocal2d(this.trans, LTDescr.val);
      else
        this._optional.spline.placeLocal(this.trans, LTDescr.val);
    }
    else
      this.trans.localPosition = this._optional.spline.point(LTDescr.val);
  }

  [CompilerGenerated]
  public void \u003CsetScaleX\u003Eb__85_0() => this.fromInternal.x = this.trans.localScale.x;

  [CompilerGenerated]
  public void \u003CsetScaleX\u003Eb__85_1() => this.trans.localScale = new Vector3(this.easeMethod().x, this.trans.localScale.y, this.trans.localScale.z);

  [CompilerGenerated]
  public void \u003CsetScaleY\u003Eb__86_0() => this.fromInternal.x = this.trans.localScale.y;

  [CompilerGenerated]
  public void \u003CsetScaleY\u003Eb__86_1() => this.trans.localScale = new Vector3(this.trans.localScale.x, this.easeMethod().x, this.trans.localScale.z);

  [CompilerGenerated]
  public void \u003CsetScaleZ\u003Eb__87_0() => this.fromInternal.x = this.trans.localScale.z;

  [CompilerGenerated]
  public void \u003CsetScaleZ\u003Eb__87_1() => this.trans.localScale = new Vector3(this.trans.localScale.x, this.trans.localScale.y, this.easeMethod().x);

  [CompilerGenerated]
  public void \u003CsetRotateX\u003Eb__88_0()
  {
    this.fromInternal.x = this.trans.eulerAngles.x;
    this.toInternal.x = LeanTween.closestRot(this.fromInternal.x, this.toInternal.x);
  }

  [CompilerGenerated]
  public void \u003CsetRotateX\u003Eb__88_1() => this.trans.eulerAngles = new Vector3(this.easeMethod().x, this.trans.eulerAngles.y, this.trans.eulerAngles.z);

  [CompilerGenerated]
  public void \u003CsetRotateY\u003Eb__89_0()
  {
    this.fromInternal.x = this.trans.eulerAngles.y;
    this.toInternal.x = LeanTween.closestRot(this.fromInternal.x, this.toInternal.x);
  }

  [CompilerGenerated]
  public void \u003CsetRotateY\u003Eb__89_1() => this.trans.eulerAngles = new Vector3(this.trans.eulerAngles.x, this.easeMethod().x, this.trans.eulerAngles.z);

  [CompilerGenerated]
  public void \u003CsetRotateZ\u003Eb__90_0()
  {
    this.fromInternal.x = this.trans.eulerAngles.z;
    this.toInternal.x = LeanTween.closestRot(this.fromInternal.x, this.toInternal.x);
  }

  [CompilerGenerated]
  public void \u003CsetRotateZ\u003Eb__90_1() => this.trans.eulerAngles = new Vector3(this.trans.eulerAngles.x, this.trans.eulerAngles.y, this.easeMethod().x);

  [CompilerGenerated]
  public void \u003CsetRotateAround\u003Eb__91_0()
  {
    this.fromInternal.x = 0.0f;
    this._optional.origRotation = this.trans.rotation;
  }

  [CompilerGenerated]
  public void \u003CsetRotateAround\u003Eb__91_1()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    Vector3 localPosition = this.trans.localPosition;
    this.trans.RotateAround(this.trans.TransformPoint(this._optional.point), this._optional.axis, -this._optional.lastVal);
    Vector3 vector3 = localPosition - this.trans.localPosition;
    this.trans.localPosition = localPosition - vector3;
    this.trans.rotation = this._optional.origRotation;
    this.trans.RotateAround(this.trans.TransformPoint(this._optional.point), this._optional.axis, LTDescr.val);
    this._optional.lastVal = LTDescr.val;
  }

  [CompilerGenerated]
  public void \u003CsetRotateAroundLocal\u003Eb__92_0()
  {
    this.fromInternal.x = 0.0f;
    this._optional.origRotation = this.trans.localRotation;
  }

  [CompilerGenerated]
  public void \u003CsetRotateAroundLocal\u003Eb__92_1()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    Vector3 localPosition = this.trans.localPosition;
    this.trans.RotateAround(this.trans.TransformPoint(this._optional.point), this.trans.TransformDirection(this._optional.axis), -this._optional.lastVal);
    Vector3 vector3 = localPosition - this.trans.localPosition;
    this.trans.localPosition = localPosition - vector3;
    this.trans.localRotation = this._optional.origRotation;
    this.trans.RotateAround(this.trans.TransformPoint(this._optional.point), this.trans.TransformDirection(this._optional.axis), LTDescr.val);
    this._optional.lastVal = LTDescr.val;
  }

  [CompilerGenerated]
  public void \u003CsetAlpha\u003Eb__93_0()
  {
    SpriteRenderer component = this.trans.GetComponent<SpriteRenderer>();
    if ((UnityEngine.Object) component != (UnityEngine.Object) null)
      this.fromInternal.x = component.color.a;
    else if ((UnityEngine.Object) this.trans.GetComponent<Renderer>() != (UnityEngine.Object) null && this.trans.GetComponent<Renderer>().material.HasProperty("_Color"))
      this.fromInternal.x = this.trans.GetComponent<Renderer>().material.color.a;
    else if ((UnityEngine.Object) this.trans.GetComponent<Renderer>() != (UnityEngine.Object) null && this.trans.GetComponent<Renderer>().material.HasProperty("_TintColor"))
      this.fromInternal.x = this.trans.GetComponent<Renderer>().material.GetColor("_TintColor").a;
    else if (this.trans.childCount > 0)
    {
      foreach (Transform tran in this.trans)
      {
        if ((UnityEngine.Object) tran.gameObject.GetComponent<Renderer>() != (UnityEngine.Object) null)
        {
          this.fromInternal.x = tran.gameObject.GetComponent<Renderer>().material.color.a;
          break;
        }
      }
    }
    this.easeInternal = (LTDescr.ActionMethodDelegate) (() =>
    {
      LTDescr.val = this.easeMethod().x;
      if ((UnityEngine.Object) this.spriteRen != (UnityEngine.Object) null)
      {
        this.spriteRen.color = new Color(this.spriteRen.color.r, this.spriteRen.color.g, this.spriteRen.color.b, LTDescr.val);
        LTDescr.alphaRecursiveSprite(this.trans, LTDescr.val);
      }
      else
        LTDescr.alphaRecursive(this.trans, LTDescr.val, this.useRecursion);
    });
  }

  [CompilerGenerated]
  public void \u003CsetAlpha\u003Eb__93_2()
  {
    LTDescr.val = this.easeMethod().x;
    if ((UnityEngine.Object) this.spriteRen != (UnityEngine.Object) null)
    {
      this.spriteRen.color = new Color(this.spriteRen.color.r, this.spriteRen.color.g, this.spriteRen.color.b, LTDescr.val);
      LTDescr.alphaRecursiveSprite(this.trans, LTDescr.val);
    }
    else
      LTDescr.alphaRecursive(this.trans, LTDescr.val, this.useRecursion);
  }

  [CompilerGenerated]
  public void \u003CsetAlpha\u003Eb__93_1()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    if ((UnityEngine.Object) this.spriteRen != (UnityEngine.Object) null)
    {
      this.spriteRen.color = new Color(this.spriteRen.color.r, this.spriteRen.color.g, this.spriteRen.color.b, LTDescr.val);
      LTDescr.alphaRecursiveSprite(this.trans, LTDescr.val);
    }
    else
      LTDescr.alphaRecursive(this.trans, LTDescr.val, this.useRecursion);
  }

  [CompilerGenerated]
  public void \u003CsetTextAlpha\u003Eb__94_0()
  {
    this.uiText = this.trans.GetComponent<UnityEngine.UI.Text>();
    this.fromInternal.x = (UnityEngine.Object) this.uiText != (UnityEngine.Object) null ? this.uiText.color.a : 1f;
  }

  [CompilerGenerated]
  public void \u003CsetTextAlpha\u003Eb__94_1() => LTDescr.textAlphaRecursive(this.trans, this.easeMethod().x, this.useRecursion);

  [CompilerGenerated]
  public void \u003CsetAlphaVertex\u003Eb__95_0() => this.fromInternal.x = (float) this.trans.GetComponent<MeshFilter>().mesh.colors32[0].a;

  [CompilerGenerated]
  public void \u003CsetAlphaVertex\u003Eb__95_1()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    Mesh mesh = this.trans.GetComponent<MeshFilter>().mesh;
    Vector3[] vertices = mesh.vertices;
    Color32[] color32Array = new Color32[vertices.Length];
    if (color32Array.Length == 0)
    {
      Color32 color32 = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, (byte) 0);
      color32Array = new Color32[mesh.vertices.Length];
      for (int index = 0; index < color32Array.Length; ++index)
        color32Array[index] = color32;
      mesh.colors32 = color32Array;
    }
    Color32 color32_1 = mesh.colors32[0];
    Color32 color32_2 = (Color32) new Color((float) color32_1.r, (float) color32_1.g, (float) color32_1.b, LTDescr.val);
    for (int index = 0; index < vertices.Length; ++index)
      color32Array[index] = color32_2;
    mesh.colors32 = color32Array;
  }

  [CompilerGenerated]
  public void \u003CsetColor\u003Eb__96_0()
  {
    SpriteRenderer component = this.trans.GetComponent<SpriteRenderer>();
    if ((UnityEngine.Object) component != (UnityEngine.Object) null)
      this.setFromColor(component.color);
    else if ((UnityEngine.Object) this.trans.GetComponent<Renderer>() != (UnityEngine.Object) null && this.trans.GetComponent<Renderer>().material.HasProperty("_Color"))
      this.setFromColor(this.trans.GetComponent<Renderer>().material.color);
    else if ((UnityEngine.Object) this.trans.GetComponent<Renderer>() != (UnityEngine.Object) null && this.trans.GetComponent<Renderer>().material.HasProperty("_TintColor"))
    {
      this.setFromColor(this.trans.GetComponent<Renderer>().material.GetColor("_TintColor"));
    }
    else
    {
      if (this.trans.childCount <= 0)
        return;
      foreach (Transform tran in this.trans)
      {
        if ((UnityEngine.Object) tran.gameObject.GetComponent<Renderer>() != (UnityEngine.Object) null)
        {
          this.setFromColor(tran.gameObject.GetComponent<Renderer>().material.color);
          break;
        }
      }
    }
  }

  [CompilerGenerated]
  public void \u003CsetColor\u003Eb__96_1()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    Color toColor = LTDescr.tweenColor(this, LTDescr.val);
    if ((UnityEngine.Object) this.spriteRen != (UnityEngine.Object) null)
    {
      this.spriteRen.color = toColor;
      LTDescr.colorRecursiveSprite(this.trans, toColor);
    }
    else if (this.type == TweenAction.COLOR)
      LTDescr.colorRecursive(this.trans, toColor, this.useRecursion);
    if ((double) LTDescr.dt != 0.0 && this._optional.onUpdateColor != null)
    {
      this._optional.onUpdateColor(toColor);
    }
    else
    {
      if ((double) LTDescr.dt == 0.0 || this._optional.onUpdateColorObject == null)
        return;
      this._optional.onUpdateColorObject(toColor, this._optional.onUpdateParam);
    }
  }

  [CompilerGenerated]
  public void \u003CsetCallbackColor\u003Eb__97_0() => this.diff = new Vector3(1f, 0.0f, 0.0f);

  [CompilerGenerated]
  public void \u003CsetCallbackColor\u003Eb__97_1()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    Color toColor = LTDescr.tweenColor(this, LTDescr.val);
    if ((UnityEngine.Object) this.spriteRen != (UnityEngine.Object) null)
    {
      this.spriteRen.color = toColor;
      LTDescr.colorRecursiveSprite(this.trans, toColor);
    }
    else if (this.type == TweenAction.COLOR)
      LTDescr.colorRecursive(this.trans, toColor, this.useRecursion);
    if ((double) LTDescr.dt != 0.0 && this._optional.onUpdateColor != null)
    {
      this._optional.onUpdateColor(toColor);
    }
    else
    {
      if ((double) LTDescr.dt == 0.0 || this._optional.onUpdateColorObject == null)
        return;
      this._optional.onUpdateColorObject(toColor, this._optional.onUpdateParam);
    }
  }

  [CompilerGenerated]
  public void \u003CsetTextColor\u003Eb__98_0()
  {
    this.uiText = this.trans.GetComponent<UnityEngine.UI.Text>();
    this.setFromColor((UnityEngine.Object) this.uiText != (UnityEngine.Object) null ? this.uiText.color : Color.white);
  }

  [CompilerGenerated]
  public void \u003CsetTextColor\u003Eb__98_1()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    Color toColor = LTDescr.tweenColor(this, LTDescr.val);
    this.uiText.color = toColor;
    if ((double) LTDescr.dt != 0.0 && this._optional.onUpdateColor != null)
      this._optional.onUpdateColor(toColor);
    if (!this.useRecursion || this.trans.childCount <= 0)
      return;
    LTDescr.textColorRecursive(this.trans, toColor);
  }

  [CompilerGenerated]
  public void \u003CsetCanvasAlpha\u003Eb__99_0()
  {
    this.uiImage = this.trans.GetComponent<Image>();
    if ((UnityEngine.Object) this.uiImage != (UnityEngine.Object) null)
    {
      this.fromInternal.x = this.uiImage.color.a;
    }
    else
    {
      this.rawImage = this.trans.GetComponent<RawImage>();
      if ((UnityEngine.Object) this.rawImage != (UnityEngine.Object) null)
        this.fromInternal.x = this.rawImage.color.a;
      else
        this.fromInternal.x = 1f;
    }
  }

  [CompilerGenerated]
  public void \u003CsetCanvasAlpha\u003Eb__99_1()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    if ((UnityEngine.Object) this.uiImage != (UnityEngine.Object) null)
      this.uiImage.color = this.uiImage.color with
      {
        a = LTDescr.val
      };
    else if ((UnityEngine.Object) this.rawImage != (UnityEngine.Object) null)
      this.rawImage.color = this.rawImage.color with
      {
        a = LTDescr.val
      };
    if (!this.useRecursion)
      return;
    LTDescr.alphaRecursive(this.rectTransform, LTDescr.val, 0);
    LTDescr.textAlphaChildrenRecursive((Transform) this.rectTransform, LTDescr.val);
  }

  [CompilerGenerated]
  public void \u003CsetCanvasGroupAlpha\u003Eb__100_0() => this.fromInternal.x = this.trans.GetComponent<CanvasGroup>().alpha;

  [CompilerGenerated]
  public void \u003CsetCanvasGroupAlpha\u003Eb__100_1() => this.trans.GetComponent<CanvasGroup>().alpha = this.easeMethod().x;

  [CompilerGenerated]
  public void \u003CsetCanvasColor\u003Eb__101_0()
  {
    this.uiImage = this.trans.GetComponent<Image>();
    if ((UnityEngine.Object) this.uiImage == (UnityEngine.Object) null)
    {
      this.rawImage = this.trans.GetComponent<RawImage>();
      this.setFromColor((UnityEngine.Object) this.rawImage != (UnityEngine.Object) null ? this.rawImage.color : Color.white);
    }
    else
      this.setFromColor(this.uiImage.color);
  }

  [CompilerGenerated]
  public void \u003CsetCanvasColor\u003Eb__101_1()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    Color toColor = LTDescr.tweenColor(this, LTDescr.val);
    if ((UnityEngine.Object) this.uiImage != (UnityEngine.Object) null)
      this.uiImage.color = toColor;
    else if ((UnityEngine.Object) this.rawImage != (UnityEngine.Object) null)
      this.rawImage.color = toColor;
    if ((double) LTDescr.dt != 0.0 && this._optional.onUpdateColor != null)
      this._optional.onUpdateColor(toColor);
    if (!this.useRecursion)
      return;
    LTDescr.colorRecursive(this.rectTransform, toColor);
  }

  [CompilerGenerated]
  public void \u003CsetCanvasMoveX\u003Eb__102_0() => this.fromInternal.x = this.rectTransform.anchoredPosition3D.x;

  [CompilerGenerated]
  public void \u003CsetCanvasMoveX\u003Eb__102_1()
  {
    Vector3 anchoredPosition3D = this.rectTransform.anchoredPosition3D;
    this.rectTransform.anchoredPosition3D = new Vector3(this.easeMethod().x, anchoredPosition3D.y, anchoredPosition3D.z);
  }

  [CompilerGenerated]
  public void \u003CsetCanvasMoveY\u003Eb__103_0() => this.fromInternal.x = this.rectTransform.anchoredPosition3D.y;

  [CompilerGenerated]
  public void \u003CsetCanvasMoveY\u003Eb__103_1()
  {
    Vector3 anchoredPosition3D = this.rectTransform.anchoredPosition3D;
    this.rectTransform.anchoredPosition3D = new Vector3(anchoredPosition3D.x, this.easeMethod().x, anchoredPosition3D.z);
  }

  [CompilerGenerated]
  public void \u003CsetCanvasMoveZ\u003Eb__104_0() => this.fromInternal.x = this.rectTransform.anchoredPosition3D.z;

  [CompilerGenerated]
  public void \u003CsetCanvasMoveZ\u003Eb__104_1()
  {
    Vector3 anchoredPosition3D = this.rectTransform.anchoredPosition3D;
    this.rectTransform.anchoredPosition3D = new Vector3(anchoredPosition3D.x, anchoredPosition3D.y, this.easeMethod().x);
  }

  [CompilerGenerated]
  public void \u003CsetCanvasRotateAround\u003Eb__106_0()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    RectTransform rectTransform = this.rectTransform;
    Vector3 localPosition = rectTransform.localPosition;
    rectTransform.RotateAround(rectTransform.TransformPoint(this._optional.point), this._optional.axis, -LTDescr.val);
    Vector3 vector3 = localPosition - rectTransform.localPosition;
    rectTransform.localPosition = localPosition - vector3;
    rectTransform.rotation = this._optional.origRotation;
    rectTransform.RotateAround(rectTransform.TransformPoint(this._optional.point), this._optional.axis, LTDescr.val);
  }

  [CompilerGenerated]
  public void \u003CsetCanvasRotateAroundLocal\u003Eb__107_0()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    RectTransform rectTransform = this.rectTransform;
    Vector3 localPosition = rectTransform.localPosition;
    rectTransform.RotateAround(rectTransform.TransformPoint(this._optional.point), rectTransform.TransformDirection(this._optional.axis), -LTDescr.val);
    Vector3 vector3 = localPosition - rectTransform.localPosition;
    rectTransform.localPosition = localPosition - vector3;
    rectTransform.rotation = this._optional.origRotation;
    rectTransform.RotateAround(rectTransform.TransformPoint(this._optional.point), rectTransform.TransformDirection(this._optional.axis), LTDescr.val);
  }

  [CompilerGenerated]
  public void \u003CsetCanvasPlaySprite\u003Eb__108_0()
  {
    this.uiImage = this.trans.GetComponent<Image>();
    this.fromInternal.x = 0.0f;
  }

  [CompilerGenerated]
  public void \u003CsetCanvasPlaySprite\u003Eb__108_1()
  {
    LTDescr.newVect = this.easeMethod();
    LTDescr.val = LTDescr.newVect.x;
    this.uiImage.sprite = this.sprites[(int) Mathf.Round(LTDescr.val)];
  }

  [CompilerGenerated]
  public void \u003CsetCanvasMove\u003Eb__109_0() => this.fromInternal = this.rectTransform.anchoredPosition3D;

  [CompilerGenerated]
  public void \u003CsetCanvasMove\u003Eb__109_1() => this.rectTransform.anchoredPosition3D = this.easeMethod();

  [CompilerGenerated]
  public void \u003CsetCanvasScale\u003Eb__110_0() => this.from = this.rectTransform.localScale;

  [CompilerGenerated]
  public void \u003CsetCanvasScale\u003Eb__110_1() => this.rectTransform.localScale = this.easeMethod();

  [CompilerGenerated]
  public void \u003CsetCanvasSizeDelta\u003Eb__111_0() => this.from = (Vector3) this.rectTransform.sizeDelta;

  [CompilerGenerated]
  public void \u003CsetCanvasSizeDelta\u003Eb__111_1() => this.rectTransform.sizeDelta = (Vector2) this.easeMethod();

  [CompilerGenerated]
  public void \u003CsetMove\u003Eb__115_0() => this.from = this.trans.position;

  [CompilerGenerated]
  public void \u003CsetMove\u003Eb__115_1()
  {
    LTDescr.newVect = this.easeMethod();
    this.trans.position = LTDescr.newVect;
  }

  [CompilerGenerated]
  public void \u003CsetMoveLocal\u003Eb__116_0() => this.from = this.trans.localPosition;

  [CompilerGenerated]
  public void \u003CsetMoveLocal\u003Eb__116_1()
  {
    LTDescr.newVect = this.easeMethod();
    this.trans.localPosition = LTDescr.newVect;
  }

  [CompilerGenerated]
  public void \u003CsetMoveToTransform\u003Eb__117_0() => this.from = this.trans.position;

  [CompilerGenerated]
  public void \u003CsetMoveToTransform\u003Eb__117_1()
  {
    this.to = this._optional.toTrans.position;
    this.diff = this.to - this.from;
    this.diffDiv2 = this.diff * 0.5f;
    LTDescr.newVect = this.easeMethod();
    this.trans.position = LTDescr.newVect;
  }

  [CompilerGenerated]
  public void \u003CsetRotate\u003Eb__118_0()
  {
    this.from = this.trans.eulerAngles;
    this.to = new Vector3(LeanTween.closestRot(this.fromInternal.x, this.toInternal.x), LeanTween.closestRot(this.from.y, this.to.y), LeanTween.closestRot(this.from.z, this.to.z));
  }

  [CompilerGenerated]
  public void \u003CsetRotate\u003Eb__118_1()
  {
    LTDescr.newVect = this.easeMethod();
    this.trans.eulerAngles = LTDescr.newVect;
  }

  [CompilerGenerated]
  public void \u003CsetRotateLocal\u003Eb__119_0()
  {
    this.from = this.trans.localEulerAngles;
    this.to = new Vector3(LeanTween.closestRot(this.fromInternal.x, this.toInternal.x), LeanTween.closestRot(this.from.y, this.to.y), LeanTween.closestRot(this.from.z, this.to.z));
  }

  [CompilerGenerated]
  public void \u003CsetRotateLocal\u003Eb__119_1()
  {
    LTDescr.newVect = this.easeMethod();
    this.trans.localEulerAngles = LTDescr.newVect;
  }

  [CompilerGenerated]
  public void \u003CsetScale\u003Eb__120_0() => this.from = this.trans.localScale;

  [CompilerGenerated]
  public void \u003CsetScale\u003Eb__120_1()
  {
    LTDescr.newVect = this.easeMethod();
    this.trans.localScale = LTDescr.newVect;
  }

  [CompilerGenerated]
  public void \u003CsetGUIMove\u003Eb__121_0()
  {
    Rect rect = this._optional.ltRect.rect;
    double x = (double) rect.x;
    rect = this._optional.ltRect.rect;
    double y = (double) rect.y;
    this.from = new Vector3((float) x, (float) y, 0.0f);
  }

  [CompilerGenerated]
  public void \u003CsetGUIMove\u003Eb__121_1()
  {
    Vector3 vector3 = this.easeMethod();
    LTRect ltRect = this._optional.ltRect;
    double x = (double) vector3.x;
    double y = (double) vector3.y;
    Rect rect1 = this._optional.ltRect.rect;
    double width = (double) rect1.width;
    rect1 = this._optional.ltRect.rect;
    double height = (double) rect1.height;
    Rect rect2 = new Rect((float) x, (float) y, (float) width, (float) height);
    ltRect.rect = rect2;
  }

  [CompilerGenerated]
  public void \u003CsetGUIMoveMargin\u003Eb__122_0() => this.from = (Vector3) new Vector2(this._optional.ltRect.margin.x, this._optional.ltRect.margin.y);

  [CompilerGenerated]
  public void \u003CsetGUIMoveMargin\u003Eb__122_1()
  {
    Vector3 vector3 = this.easeMethod();
    this._optional.ltRect.margin = new Vector2(vector3.x, vector3.y);
  }

  [CompilerGenerated]
  public void \u003CsetGUIScale\u003Eb__123_0()
  {
    Rect rect = this._optional.ltRect.rect;
    double width = (double) rect.width;
    rect = this._optional.ltRect.rect;
    double height = (double) rect.height;
    this.from = new Vector3((float) width, (float) height, 0.0f);
  }

  [CompilerGenerated]
  public void \u003CsetGUIScale\u003Eb__123_1()
  {
    Vector3 vector3 = this.easeMethod();
    LTRect ltRect = this._optional.ltRect;
    Rect rect1 = this._optional.ltRect.rect;
    double x1 = (double) rect1.x;
    rect1 = this._optional.ltRect.rect;
    double y1 = (double) rect1.y;
    double x2 = (double) vector3.x;
    double y2 = (double) vector3.y;
    Rect rect2 = new Rect((float) x1, (float) y1, (float) x2, (float) y2);
    ltRect.rect = rect2;
  }

  [CompilerGenerated]
  public void \u003CsetGUIAlpha\u003Eb__124_0() => this.fromInternal.x = this._optional.ltRect.alpha;

  [CompilerGenerated]
  public void \u003CsetGUIAlpha\u003Eb__124_1() => this._optional.ltRect.alpha = this.easeMethod().x;

  [CompilerGenerated]
  public void \u003CsetGUIRotate\u003Eb__125_0()
  {
    if (!this._optional.ltRect.rotateEnabled)
    {
      this._optional.ltRect.rotateEnabled = true;
      this._optional.ltRect.resetForRotation();
    }
    this.fromInternal.x = this._optional.ltRect.rotation;
  }

  [CompilerGenerated]
  public void \u003CsetGUIRotate\u003Eb__125_1() => this._optional.ltRect.rotation = this.easeMethod().x;

  [CompilerGenerated]
  public void \u003CsetDelayedSound\u003Eb__126_0() => this.hasExtraOnCompletes = true;

  public delegate Vector3 EaseTypeDelegate();

  public delegate void ActionMethodDelegate();
}
﻿// Decompiled with JetBrains decompiler
// Type: LTDescrOptional
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Runtime.CompilerServices;
using UnityEngine;

public class LTDescrOptional
{
  [CompilerGenerated]
  public Transform \u003CtoTrans\u003Ek__BackingField;
  [CompilerGenerated]
  public Vector3 \u003Cpoint\u003Ek__BackingField;
  [CompilerGenerated]
  public Vector3 \u003Caxis\u003Ek__BackingField;
  [CompilerGenerated]
  public float \u003ClastVal\u003Ek__BackingField;
  [CompilerGenerated]
  public Quaternion \u003CorigRotation\u003Ek__BackingField;
  [CompilerGenerated]
  public LTBezierPath \u003Cpath\u003Ek__BackingField;
  [CompilerGenerated]
  public LTSpline \u003Cspline\u003Ek__BackingField;
  public AnimationCurve animationCurve;
  public int initFrameCount;
  public Color color;
  [CompilerGenerated]
  public LTRect \u003CltRect\u003Ek__BackingField;
  [CompilerGenerated]
  public Action<float> \u003ConUpdateFloat\u003Ek__BackingField;
  [CompilerGenerated]
  public Action<float, float> \u003ConUpdateFloatRatio\u003Ek__BackingField;
  [CompilerGenerated]
  public Action<float, object> \u003ConUpdateFloatObject\u003Ek__BackingField;
  [CompilerGenerated]
  public Action<Vector2> \u003ConUpdateVector2\u003Ek__BackingField;
  [CompilerGenerated]
  public Action<Vector3> \u003ConUpdateVector3\u003Ek__BackingField;
  [CompilerGenerated]
  public Action<Vector3, object> \u003ConUpdateVector3Object\u003Ek__BackingField;
  [CompilerGenerated]
  public Action<Color> \u003ConUpdateColor\u003Ek__BackingField;
  [CompilerGenerated]
  public Action<Color, object> \u003ConUpdateColorObject\u003Ek__BackingField;
  [CompilerGenerated]
  public System.Action \u003ConComplete\u003Ek__BackingField;
  [CompilerGenerated]
  public Action<object> \u003ConCompleteObject\u003Ek__BackingField;
  [CompilerGenerated]
  public object \u003ConCompleteParam\u003Ek__BackingField;
  [CompilerGenerated]
  public object \u003ConUpdateParam\u003Ek__BackingField;
  [CompilerGenerated]
  public System.Action \u003ConStart\u003Ek__BackingField;

  public Transform toTrans
  {
    get => this.\u003CtoTrans\u003Ek__BackingField;
    set => this.\u003CtoTrans\u003Ek__BackingField = value;
  }

  public Vector3 point
  {
    get => this.\u003Cpoint\u003Ek__BackingField;
    set => this.\u003Cpoint\u003Ek__BackingField = value;
  }

  public Vector3 axis
  {
    get => this.\u003Caxis\u003Ek__BackingField;
    set => this.\u003Caxis\u003Ek__BackingField = value;
  }

  public float lastVal
  {
    get => this.\u003ClastVal\u003Ek__BackingField;
    set => this.\u003ClastVal\u003Ek__BackingField = value;
  }

  public Quaternion origRotation
  {
    get => this.\u003CorigRotation\u003Ek__BackingField;
    set => this.\u003CorigRotation\u003Ek__BackingField = value;
  }

  public LTBezierPath path
  {
    get => this.\u003Cpath\u003Ek__BackingField;
    set => this.\u003Cpath\u003Ek__BackingField = value;
  }

  public LTSpline spline
  {
    get => this.\u003Cspline\u003Ek__BackingField;
    set => this.\u003Cspline\u003Ek__BackingField = value;
  }

  public LTRect ltRect
  {
    get => this.\u003CltRect\u003Ek__BackingField;
    set => this.\u003CltRect\u003Ek__BackingField = value;
  }

  public Action<float> onUpdateFloat
  {
    get => this.\u003ConUpdateFloat\u003Ek__BackingField;
    set => this.\u003ConUpdateFloat\u003Ek__BackingField = value;
  }

  public Action<float, float> onUpdateFloatRatio
  {
    get => this.\u003ConUpdateFloatRatio\u003Ek__BackingField;
    set => this.\u003ConUpdateFloatRatio\u003Ek__BackingField = value;
  }

  public Action<float, object> onUpdateFloatObject
  {
    get => this.\u003ConUpdateFloatObject\u003Ek__BackingField;
    set => this.\u003ConUpdateFloatObject\u003Ek__BackingField = value;
  }

  public Action<Vector2> onUpdateVector2
  {
    get => this.\u003ConUpdateVector2\u003Ek__BackingField;
    set => this.\u003ConUpdateVector2\u003Ek__BackingField = value;
  }

  public Action<Vector3> onUpdateVector3
  {
    get => this.\u003ConUpdateVector3\u003Ek__BackingField;
    set => this.\u003ConUpdateVector3\u003Ek__BackingField = value;
  }

  public Action<Vector3, object> onUpdateVector3Object
  {
    get => this.\u003ConUpdateVector3Object\u003Ek__BackingField;
    set => this.\u003ConUpdateVector3Object\u003Ek__BackingField = value;
  }

  public Action<Color> onUpdateColor
  {
    get => this.\u003ConUpdateColor\u003Ek__BackingField;
    set => this.\u003ConUpdateColor\u003Ek__BackingField = value;
  }

  public Action<Color, object> onUpdateColorObject
  {
    get => this.\u003ConUpdateColorObject\u003Ek__BackingField;
    set => this.\u003ConUpdateColorObject\u003Ek__BackingField = value;
  }

  public System.Action onComplete
  {
    get => this.\u003ConComplete\u003Ek__BackingField;
    set => this.\u003ConComplete\u003Ek__BackingField = value;
  }

  public Action<object> onCompleteObject
  {
    get => this.\u003ConCompleteObject\u003Ek__BackingField;
    set => this.\u003ConCompleteObject\u003Ek__BackingField = value;
  }

  public object onCompleteParam
  {
    get => this.\u003ConCompleteParam\u003Ek__BackingField;
    set => this.\u003ConCompleteParam\u003Ek__BackingField = value;
  }

  public object onUpdateParam
  {
    get => this.\u003ConUpdateParam\u003Ek__BackingField;
    set => this.\u003ConUpdateParam\u003Ek__BackingField = value;
  }

  public System.Action onStart
  {
    get => this.\u003ConStart\u003Ek__BackingField;
    set => this.\u003ConStart\u003Ek__BackingField = value;
  }

  public void reset()
  {
    this.animationCurve = (AnimationCurve) null;
    this.onUpdateFloat = (Action<float>) null;
    this.onUpdateFloatRatio = (Action<float, float>) null;
    this.onUpdateVector2 = (Action<Vector2>) null;
    this.onUpdateVector3 = (Action<Vector3>) null;
    this.onUpdateFloatObject = (Action<float, object>) null;
    this.onUpdateVector3Object = (Action<Vector3, object>) null;
    this.onUpdateColor = (Action<Color>) null;
    this.onComplete = (System.Action) null;
    this.onCompleteObject = (Action<object>) null;
    this.onCompleteParam = (object) null;
    this.onStart = (System.Action) null;
    this.point = Vector3.zero;
    this.initFrameCount = 0;
  }

  public void callOnUpdate(float val, float ratioPassed)
  {
    if (this.onUpdateFloat != null)
      this.onUpdateFloat(val);
    if (this.onUpdateFloatRatio != null)
      this.onUpdateFloatRatio(val, ratioPassed);
    else if (this.onUpdateFloatObject != null)
      this.onUpdateFloatObject(val, this.onUpdateParam);
    else if (this.onUpdateVector3Object != null)
      this.onUpdateVector3Object(LTDescr.newVect, this.onUpdateParam);
    else if (this.onUpdateVector3 != null)
    {
      this.onUpdateVector3(LTDescr.newVect);
    }
    else
    {
      if (this.onUpdateVector2 == null)
        return;
      this.onUpdateVector2(new Vector2(LTDescr.newVect.x, LTDescr.newVect.y));
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LTEvent
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class LTEvent
{
  public int id;
  public object data;

  public LTEvent(int id, object data)
  {
    this.id = id;
    this.data = data;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LTGUI
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LTGUI
{
  public static int RECT_LEVELS = 5;
  public static int RECTS_PER_LEVEL = 10;
  public static int BUTTONS_MAX = 24;
  public static LTRect[] levels;
  public static int[] levelDepths;
  public static Rect[] buttons;
  public static int[] buttonLevels;
  public static int[] buttonLastFrame;
  public static LTRect r;
  public static Color color = Color.white;
  public static bool isGUIEnabled = false;
  public static int global_counter = 0;

  public static void init()
  {
    if (LTGUI.levels != null)
      return;
    LTGUI.levels = new LTRect[LTGUI.RECT_LEVELS * LTGUI.RECTS_PER_LEVEL];
    LTGUI.levelDepths = new int[LTGUI.RECT_LEVELS];
  }

  public static void initRectCheck()
  {
    if (LTGUI.buttons != null)
      return;
    LTGUI.buttons = new Rect[LTGUI.BUTTONS_MAX];
    LTGUI.buttonLevels = new int[LTGUI.BUTTONS_MAX];
    LTGUI.buttonLastFrame = new int[LTGUI.BUTTONS_MAX];
    for (int index = 0; index < LTGUI.buttonLevels.Length; ++index)
      LTGUI.buttonLevels[index] = -1;
  }

  public static void reset()
  {
    if (!LTGUI.isGUIEnabled)
      return;
    LTGUI.isGUIEnabled = false;
    for (int index = 0; index < LTGUI.levels.Length; ++index)
      LTGUI.levels[index] = (LTRect) null;
    for (int index = 0; index < LTGUI.levelDepths.Length; ++index)
      LTGUI.levelDepths[index] = 0;
  }

  public static void update(int updateLevel)
  {
    if (!LTGUI.isGUIEnabled)
      return;
    LTGUI.init();
    if (LTGUI.levelDepths[updateLevel] <= 0)
      return;
    LTGUI.color = GUI.color;
    int num1 = updateLevel * LTGUI.RECTS_PER_LEVEL;
    int num2 = num1 + LTGUI.levelDepths[updateLevel];
    for (int index = num1; index < num2; ++index)
    {
      LTGUI.r = LTGUI.levels[index];
      if (LTGUI.r != null)
      {
        if (LTGUI.r.useColor)
          GUI.color = LTGUI.r.color;
        Rect rect;
        if (LTGUI.r.type == LTGUI.Element_Type.Label)
        {
          if (LTGUI.r.style != null)
            GUI.skin.label = LTGUI.r.style;
          if (LTGUI.r.useSimpleScale)
          {
            rect = LTGUI.r.rect;
            double x = ((double) rect.x + (double) LTGUI.r.margin.x + (double) LTGUI.r.relativeRect.x) * (double) LTGUI.r.relativeRect.width;
            rect = LTGUI.r.rect;
            double y = ((double) rect.y + (double) LTGUI.r.margin.y + (double) LTGUI.r.relativeRect.y) * (double) LTGUI.r.relativeRect.height;
            rect = LTGUI.r.rect;
            double width = (double) rect.width * (double) LTGUI.r.relativeRect.width;
            rect = LTGUI.r.rect;
            double height = (double) rect.height * (double) LTGUI.r.relativeRect.height;
            GUI.Label(new Rect((float) x, (float) y, (float) width, (float) height), LTGUI.r.labelStr);
          }
          else
          {
            rect = LTGUI.r.rect;
            double x = (double) rect.x + (double) LTGUI.r.margin.x;
            rect = LTGUI.r.rect;
            double y = (double) rect.y + (double) LTGUI.r.margin.y;
            rect = LTGUI.r.rect;
            double width = (double) rect.width;
            rect = LTGUI.r.rect;
            double height = (double) rect.height;
            GUI.Label(new Rect((float) x, (float) y, (float) width, (float) height), LTGUI.r.labelStr);
          }
        }
        else if (LTGUI.r.type == LTGUI.Element_Type.Texture && (Object) LTGUI.r.texture != (Object) null)
        {
          Vector2 vector2_1;
          if (!LTGUI.r.useSimpleScale)
          {
            rect = LTGUI.r.rect;
            double width = (double) rect.width;
            rect = LTGUI.r.rect;
            double height = (double) rect.height;
            vector2_1 = new Vector2((float) width, (float) height);
          }
          else
          {
            rect = LTGUI.r.rect;
            vector2_1 = new Vector2(0.0f, (float) ((double) rect.height * (double) LTGUI.r.relativeRect.height));
          }
          Vector2 vector2_2 = vector2_1;
          if (LTGUI.r.sizeByHeight)
            vector2_2.x = (float) LTGUI.r.texture.width / (float) LTGUI.r.texture.height * vector2_2.y;
          if (LTGUI.r.useSimpleScale)
          {
            rect = LTGUI.r.rect;
            double x1 = ((double) rect.x + (double) LTGUI.r.margin.x + (double) LTGUI.r.relativeRect.x) * (double) LTGUI.r.relativeRect.width;
            rect = LTGUI.r.rect;
            double y1 = ((double) rect.y + (double) LTGUI.r.margin.y + (double) LTGUI.r.relativeRect.y) * (double) LTGUI.r.relativeRect.height;
            double x2 = (double) vector2_2.x;
            double y2 = (double) vector2_2.y;
            GUI.DrawTexture(new Rect((float) x1, (float) y1, (float) x2, (float) y2), LTGUI.r.texture);
          }
          else
          {
            rect = LTGUI.r.rect;
            double x3 = (double) rect.x + (double) LTGUI.r.margin.x;
            rect = LTGUI.r.rect;
            double y3 = (double) rect.y + (double) LTGUI.r.margin.y;
            double x4 = (double) vector2_2.x;
            double y4 = (double) vector2_2.y;
            GUI.DrawTexture(new Rect((float) x3, (float) y3, (float) x4, (float) y4), LTGUI.r.texture);
          }
        }
      }
    }
    GUI.color = LTGUI.color;
  }

  public static bool checkOnScreen(Rect rect)
  {
    int num1 = (double) rect.x + (double) rect.width < 0.0 ? 1 : 0;
    bool flag1 = (double) rect.x > (double) Screen.width;
    bool flag2 = (double) rect.y > (double) Screen.height;
    bool flag3 = (double) rect.y + (double) rect.height < 0.0;
    int num2 = flag1 ? 1 : 0;
    return (num1 | num2 | (flag2 ? 1 : 0) | (flag3 ? 1 : 0)) == 0;
  }

  public static void destroy(int id)
  {
    int index = id & (int) ushort.MaxValue;
    int num = id >> 16;
    if (id < 0 || LTGUI.levels[index] == null || !LTGUI.levels[index].hasInitiliazed || LTGUI.levels[index].counter != num)
      return;
    LTGUI.levels[index] = (LTRect) null;
  }

  public static void destroyAll(int depth)
  {
    int num = depth * LTGUI.RECTS_PER_LEVEL + LTGUI.RECTS_PER_LEVEL;
    for (int index = depth * LTGUI.RECTS_PER_LEVEL; LTGUI.levels != null && index < num; ++index)
      LTGUI.levels[index] = (LTRect) null;
  }

  public static LTRect label(Rect rect, string label, int depth) => LTGUI.label(new LTRect(rect), label, depth);

  public static LTRect label(LTRect rect, string label, int depth)
  {
    rect.type = LTGUI.Element_Type.Label;
    rect.labelStr = label;
    return LTGUI.element(rect, depth);
  }

  public static LTRect texture(Rect rect, Texture texture, int depth) => LTGUI.texture(new LTRect(rect), texture, depth);

  public static LTRect texture(LTRect rect, Texture texture, int depth)
  {
    rect.type = LTGUI.Element_Type.Texture;
    rect.texture = texture;
    return LTGUI.element(rect, depth);
  }

  public static LTRect element(LTRect rect, int depth)
  {
    LTGUI.isGUIEnabled = true;
    LTGUI.init();
    int num1 = depth * LTGUI.RECTS_PER_LEVEL + LTGUI.RECTS_PER_LEVEL;
    int num2 = 0;
    if (rect != null)
      LTGUI.destroy(rect.id);
    if (rect.type == LTGUI.Element_Type.Label && rect.style != null && (double) rect.style.normal.textColor.a <= 0.0)
      Debug.LogWarning((object) "Your GUI normal color has an alpha of zero, and will not be rendered.");
    if ((double) rect.relativeRect.width == double.PositiveInfinity)
      rect.relativeRect = new Rect(0.0f, 0.0f, (float) Screen.width, (float) Screen.height);
    for (int id = depth * LTGUI.RECTS_PER_LEVEL; id < num1; ++id)
    {
      LTGUI.r = LTGUI.levels[id];
      if (LTGUI.r == null)
      {
        LTGUI.r = rect;
        LTGUI.r.rotateEnabled = true;
        LTGUI.r.alphaEnabled = true;
        LTGUI.r.setId(id, LTGUI.global_counter);
        LTGUI.levels[id] = LTGUI.r;
        if (num2 >= LTGUI.levelDepths[depth])
          LTGUI.levelDepths[depth] = num2 + 1;
        ++LTGUI.global_counter;
        return LTGUI.r;
      }
      ++num2;
    }
    Debug.LogError((object) "You ran out of GUI Element spaces");
    return (LTRect) null;
  }

  public static bool hasNoOverlap(Rect rect, int depth)
  {
    LTGUI.initRectCheck();
    bool flag1 = true;
    bool flag2 = false;
    for (int index = 0; index < LTGUI.buttonLevels.Length; ++index)
    {
      if (LTGUI.buttonLevels[index] >= 0)
      {
        if (LTGUI.buttonLastFrame[index] + 1 < Time.frameCount)
          LTGUI.buttonLevels[index] = -1;
        else if (LTGUI.buttonLevels[index] > depth && LTGUI.pressedWithinRect(LTGUI.buttons[index]))
          flag1 = false;
      }
      if (!flag2 && LTGUI.buttonLevels[index] < 0)
      {
        flag2 = true;
        LTGUI.buttonLevels[index] = depth;
        LTGUI.buttons[index] = rect;
        LTGUI.buttonLastFrame[index] = Time.frameCount;
      }
    }
    return flag1;
  }

  public static bool pressedWithinRect(Rect rect)
  {
    Vector2 vector2 = LTGUI.firstTouch();
    if ((double) vector2.x < 0.0)
      return false;
    float num = (float) Screen.height - vector2.y;
    return (double) vector2.x > (double) rect.x && (double) vector2.x < (double) rect.x + (double) rect.width && (double) num > (double) rect.y && (double) num < (double) rect.y + (double) rect.height;
  }

  public static bool checkWithinRect(Vector2 vec2, Rect rect)
  {
    vec2.y = (float) Screen.height - vec2.y;
    return (double) vec2.x > (double) rect.x && (double) vec2.x < (double) rect.x + (double) rect.width && (double) vec2.y > (double) rect.y && (double) vec2.y < (double) rect.y + (double) rect.height;
  }

  public static Vector2 firstTouch()
  {
    if (Input.touchCount > 0)
      return Input.touches[0].position;
    return Input.GetMouseButton(0) ? (Vector2) Input.mousePosition : new Vector2(float.NegativeInfinity, float.NegativeInfinity);
  }

  public enum Element_Type
  {
    Texture,
    Label,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LTRect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public class LTRect
{
  public Rect _rect;
  public float alpha = 1f;
  public float rotation;
  public Vector2 pivot;
  public Vector2 margin;
  public Rect relativeRect = new Rect(0.0f, 0.0f, float.PositiveInfinity, float.PositiveInfinity);
  public bool rotateEnabled;
  [HideInInspector]
  public bool rotateFinished;
  public bool alphaEnabled;
  public string labelStr;
  public LTGUI.Element_Type type;
  public GUIStyle style;
  public bool useColor;
  public Color color = Color.white;
  public bool fontScaleToFit;
  public bool useSimpleScale;
  public bool sizeByHeight;
  public Texture texture;
  public int _id = -1;
  [HideInInspector]
  public int counter;
  public static bool colorTouched;

  public LTRect()
  {
    this.reset();
    this.rotateEnabled = this.alphaEnabled = true;
    this._rect = new Rect(0.0f, 0.0f, 1f, 1f);
  }

  public LTRect(Rect rect)
  {
    this._rect = rect;
    this.reset();
  }

  public LTRect(float x, float y, float width, float height)
  {
    this._rect = new Rect(x, y, width, height);
    this.alpha = 1f;
    this.rotation = 0.0f;
    this.rotateEnabled = this.alphaEnabled = false;
  }

  public LTRect(float x, float y, float width, float height, float alpha)
  {
    this._rect = new Rect(x, y, width, height);
    this.alpha = alpha;
    this.rotation = 0.0f;
    this.rotateEnabled = this.alphaEnabled = false;
  }

  public LTRect(float x, float y, float width, float height, float alpha, float rotation)
  {
    this._rect = new Rect(x, y, width, height);
    this.alpha = alpha;
    this.rotation = rotation;
    this.rotateEnabled = this.alphaEnabled = false;
    if ((double) rotation == 0.0)
      return;
    this.rotateEnabled = true;
    this.resetForRotation();
  }

  public bool hasInitiliazed => this._id != -1;

  public int id => this._id | this.counter << 16;

  public void setId(int id, int counter)
  {
    this._id = id;
    this.counter = counter;
  }

  public void reset()
  {
    this.alpha = 1f;
    this.rotation = 0.0f;
    this.rotateEnabled = this.alphaEnabled = false;
    this.margin = Vector2.zero;
    this.sizeByHeight = false;
    this.useColor = false;
  }

  public void resetForRotation()
  {
    Vector3 vector3;
    ref Vector3 local = ref vector3;
    Matrix4x4 matrix = GUI.matrix;
    double x = (double) matrix[0, 0];
    matrix = GUI.matrix;
    double y = (double) matrix[1, 1];
    matrix = GUI.matrix;
    double z = (double) matrix[2, 2];
    local = new Vector3((float) x, (float) y, (float) z);
    if (!(this.pivot == Vector2.zero))
      return;
    this.pivot = new Vector2((this._rect.x + this._rect.width * 0.5f) * vector3.x + GUI.matrix[0, 3], (this._rect.y + this._rect.height * 0.5f) * vector3.y + GUI.matrix[1, 3]);
  }

  public float x
  {
    get => this._rect.x;
    set => this._rect.x = value;
  }

  public float y
  {
    get => this._rect.y;
    set => this._rect.y = value;
  }

  public float width
  {
    get => this._rect.width;
    set => this._rect.width = value;
  }

  public float height
  {
    get => this._rect.height;
    set => this._rect.height = value;
  }

  public Rect rect
  {
    get
    {
      if (LTRect.colorTouched)
      {
        LTRect.colorTouched = false;
        GUI.color = new Color(GUI.color.r, GUI.color.g, GUI.color.b, 1f);
      }
      if (this.rotateEnabled)
      {
        if (this.rotateFinished)
        {
          this.rotateFinished = false;
          this.rotateEnabled = false;
          this.pivot = Vector2.zero;
        }
        else
          GUIUtility.RotateAroundPivot(this.rotation, this.pivot);
      }
      if (this.alphaEnabled)
      {
        GUI.color = new Color(GUI.color.r, GUI.color.g, GUI.color.b, this.alpha);
        LTRect.colorTouched = true;
      }
      if (this.fontScaleToFit)
        this.style.fontSize = !this.useSimpleScale ? (int) this._rect.height : (int) ((double) this._rect.height * (double) this.relativeRect.height);
      return this._rect;
    }
    set => this._rect = value;
  }

  public LTRect setStyle(GUIStyle style)
  {
    this.style = style;
    return this;
  }

  public LTRect setFontScaleToFit(bool fontScaleToFit)
  {
    this.fontScaleToFit = fontScaleToFit;
    return this;
  }

  public LTRect setColor(Color color)
  {
    this.color = color;
    this.useColor = true;
    return this;
  }

  public LTRect setAlpha(float alpha)
  {
    this.alpha = alpha;
    return this;
  }

  public LTRect setLabel(string str)
  {
    this.labelStr = str;
    return this;
  }

  public LTRect setUseSimpleScale(bool useSimpleScale, Rect relativeRect)
  {
    this.useSimpleScale = useSimpleScale;
    this.relativeRect = relativeRect;
    return this;
  }

  public LTRect setUseSimpleScale(bool useSimpleScale)
  {
    this.useSimpleScale = useSimpleScale;
    this.relativeRect = new Rect(0.0f, 0.0f, (float) Screen.width, (float) Screen.height);
    return this;
  }

  public LTRect setSizeByHeight(bool sizeByHeight)
  {
    this.sizeByHeight = sizeByHeight;
    return this;
  }

  public override string ToString() => "x:" + this._rect.x.ToString() + " y:" + this._rect.y.ToString() + " width:" + this._rect.width.ToString() + " height:" + this._rect.height.ToString();
}
﻿// Decompiled with JetBrains decompiler
// Type: LTSeq
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public class LTSeq
{
  public LTSeq previous;
  public LTSeq current;
  public LTDescr tween;
  public float totalDelay;
  public float timeScale;
  public int debugIter;
  public uint counter;
  public bool toggle;
  public uint _id;

  public int id => (int) this._id | (int) this.counter << 16;

  public void reset()
  {
    this.previous = (LTSeq) null;
    this.tween = (LTDescr) null;
    this.totalDelay = 0.0f;
  }

  public void init(uint id, uint global_counter)
  {
    this.reset();
    this._id = id;
    this.counter = global_counter;
    this.current = this;
  }

  public LTSeq addOn()
  {
    this.current.toggle = true;
    LTSeq current = this.current;
    this.current = LeanTween.sequence();
    this.current.previous = current;
    current.toggle = false;
    this.current.totalDelay = current.totalDelay;
    this.current.debugIter = current.debugIter + 1;
    return this.current;
  }

  public float addPreviousDelays()
  {
    LTSeq previous = this.current.previous;
    return previous != null && previous.tween != null ? this.current.totalDelay + previous.tween.time : this.current.totalDelay;
  }

  public LTSeq append(float delay)
  {
    this.current.totalDelay += delay;
    return this.current;
  }

  public LTSeq append(System.Action callback) => this.append(LeanTween.delayedCall(0.0f, callback));

  public LTSeq append(Action<object> callback, object obj)
  {
    this.append(LeanTween.delayedCall(0.0f, callback).setOnCompleteParam(obj));
    return this.addOn();
  }

  public LTSeq append(GameObject gameObject, System.Action callback)
  {
    this.append(LeanTween.delayedCall(gameObject, 0.0f, callback));
    return this.addOn();
  }

  public LTSeq append(GameObject gameObject, Action<object> callback, object obj)
  {
    this.append(LeanTween.delayedCall(gameObject, 0.0f, callback).setOnCompleteParam(obj));
    return this.addOn();
  }

  public LTSeq append(LTDescr tween)
  {
    this.current.tween = tween;
    this.current.totalDelay = this.addPreviousDelays();
    tween.setDelay(this.current.totalDelay);
    return this.addOn();
  }

  public LTSeq insert(LTDescr tween)
  {
    this.current.tween = tween;
    tween.setDelay(this.addPreviousDelays());
    return this.addOn();
  }

  public LTSeq setScale(float timeScale)
  {
    this.setScaleRecursive(this.current, timeScale, 500);
    return this.addOn();
  }

  public void setScaleRecursive(LTSeq seq, float timeScale, int count)
  {
    if (count <= 0)
      return;
    this.timeScale = timeScale;
    seq.totalDelay *= timeScale;
    if (seq.tween != null)
    {
      if ((double) seq.tween.time != 0.0)
        seq.tween.setTime(seq.tween.time * timeScale);
      seq.tween.setDelay(seq.tween.delay * timeScale);
    }
    if (seq.previous == null)
      return;
    this.setScaleRecursive(seq.previous, timeScale, count - 1);
  }

  public LTSeq reverse() => this.addOn();
}
﻿// Decompiled with JetBrains decompiler
// Type: LTSpline
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class LTSpline
{
  public static int DISTANCE_COUNT = 3;
  public static int SUBLINE_COUNT = 20;
  public float distance;
  public bool constantSpeed = true;
  public Vector3[] pts;
  [NonSerialized]
  public Vector3[] ptsAdj;
  public int ptsAdjLength;
  public bool orientToPath;
  public bool orientToPath2d;
  public int numSections;
  public int currPt;

  public LTSpline(Vector3[] pts) => this.init(pts, true);

  public LTSpline(Vector3[] pts, bool constantSpeed)
  {
    this.constantSpeed = constantSpeed;
    this.init(pts, constantSpeed);
  }

  public void init(Vector3[] pts, bool constantSpeed)
  {
    if (pts.Length < 4)
    {
      LeanTween.logError("LeanTween - When passing values for a spline path, you must pass four or more values!");
    }
    else
    {
      this.pts = new Vector3[pts.Length];
      Array.Copy((Array) pts, (Array) this.pts, pts.Length);
      this.numSections = pts.Length - 3;
      float num1 = float.PositiveInfinity;
      Vector3 pt = this.pts[1];
      float num2 = 0.0f;
      for (int index = 1; index < this.pts.Length - 1; ++index)
      {
        float num3 = Vector3.Distance(this.pts[index], pt);
        if ((double) num3 < (double) num1)
          num1 = num3;
        num2 += num3;
      }
      if (!constantSpeed)
        return;
      float num4 = num2 / (float) (this.numSections * LTSpline.SUBLINE_COUNT) / (float) LTSpline.SUBLINE_COUNT;
      int length = (int) Mathf.Ceil(num2 / num4) * LTSpline.DISTANCE_COUNT;
      if (length <= 1)
        length = 2;
      this.ptsAdj = new Vector3[length];
      Vector3 b = this.interp(0.0f);
      int index1 = 1;
      this.ptsAdj[0] = b;
      this.distance = 0.0f;
      for (int index2 = 0; index2 < length + 1; ++index2)
      {
        float t = (float) index2 / (float) length;
        Vector3 a = this.interp(t);
        float num5 = Vector3.Distance(a, b);
        if ((double) num5 >= (double) num4 || (double) t >= 1.0)
        {
          this.ptsAdj[index1] = a;
          this.distance += num5;
          b = a;
          ++index1;
        }
      }
      this.ptsAdjLength = index1;
    }
  }

  public Vector3 map(float u)
  {
    if ((double) u >= 1.0)
      return this.pts[this.pts.Length - 2];
    double f = (double) u * (double) (this.ptsAdjLength - 1);
    int index1 = (int) Mathf.Floor((float) f);
    int index2 = (int) Mathf.Ceil((float) f);
    if (index1 < 0)
      index1 = 0;
    Vector3 vector3_1 = this.ptsAdj[index1];
    Vector3 vector3_2 = this.ptsAdj[index2];
    float num = (float) f - (float) index1;
    return vector3_1 + (vector3_2 - vector3_1) * num;
  }

  public Vector3 interp(float t)
  {
    this.currPt = Mathf.Min(Mathf.FloorToInt(t * (float) this.numSections), this.numSections - 1);
    float num = t * (float) this.numSections - (float) this.currPt;
    Vector3 pt1 = this.pts[this.currPt];
    Vector3 pt2 = this.pts[this.currPt + 1];
    Vector3 pt3 = this.pts[this.currPt + 2];
    Vector3 pt4 = this.pts[this.currPt + 3];
    return 0.5f * ((-pt1 + 3f * pt2 - 3f * pt3 + pt4) * (num * num * num) + (2f * pt1 - 5f * pt2 + 4f * pt3 - pt4) * (num * num) + (-pt1 + pt3) * num + 2f * pt2);
  }

  public float ratioAtPoint(Vector3 pt)
  {
    float num1 = float.MaxValue;
    int num2 = 0;
    for (int index = 0; index < this.ptsAdjLength; ++index)
    {
      float num3 = Vector3.Distance(pt, this.ptsAdj[index]);
      if ((double) num3 < (double) num1)
      {
        num1 = num3;
        num2 = index;
      }
    }
    return (float) num2 / (float) (this.ptsAdjLength - 1);
  }

  public Vector3 point(float ratio)
  {
    float num = (double) ratio > 1.0 ? 1f : ratio;
    return !this.constantSpeed ? this.interp(num) : this.map(num);
  }

  public void place2d(Transform transform, float ratio)
  {
    transform.position = this.point(ratio);
    ratio += 1f / 1000f;
    if ((double) ratio > 1.0)
      return;
    Vector3 vector3 = this.point(ratio) - transform.position;
    float z = Mathf.Atan2(vector3.y, vector3.x) * 57.29578f;
    transform.eulerAngles = new Vector3(0.0f, 0.0f, z);
  }

  public void placeLocal2d(Transform transform, float ratio)
  {
    if ((UnityEngine.Object) transform.parent == (UnityEngine.Object) null)
    {
      this.place2d(transform, ratio);
    }
    else
    {
      transform.localPosition = this.point(ratio);
      ratio += 1f / 1000f;
      if ((double) ratio > 1.0)
        return;
      Vector3 vector3 = this.point(ratio) - transform.localPosition;
      float z = Mathf.Atan2(vector3.y, vector3.x) * 57.29578f;
      transform.localEulerAngles = new Vector3(0.0f, 0.0f, z);
    }
  }

  public void place(Transform transform, float ratio) => this.place(transform, ratio, Vector3.up);

  public void place(Transform transform, float ratio, Vector3 worldUp)
  {
    transform.position = this.point(ratio);
    ratio += 1f / 1000f;
    if ((double) ratio > 1.0)
      return;
    transform.LookAt(this.point(ratio), worldUp);
  }

  public void placeLocal(Transform transform, float ratio) => this.placeLocal(transform, ratio, Vector3.up);

  public void placeLocal(Transform transform, float ratio, Vector3 worldUp)
  {
    transform.localPosition = this.point(ratio);
    ratio += 1f / 1000f;
    if ((double) ratio > 1.0)
      return;
    transform.LookAt(transform.parent.TransformPoint(this.point(ratio)), worldUp);
  }

  public void gizmoDraw(float t = -1f)
  {
    if (this.ptsAdj == null || this.ptsAdj.Length == 0)
      return;
    Vector3 from = this.ptsAdj[0];
    for (int index = 0; index < this.ptsAdjLength; ++index)
    {
      Vector3 to = this.ptsAdj[index];
      Gizmos.DrawLine(from, to);
      from = to;
    }
  }

  public void drawGizmo(Color color)
  {
    if (this.ptsAdjLength < 4)
      return;
    Vector3 from = this.ptsAdj[0];
    Color color1 = Gizmos.color;
    Gizmos.color = color;
    for (int index = 0; index < this.ptsAdjLength; ++index)
    {
      Vector3 to = this.ptsAdj[index];
      Gizmos.DrawLine(from, to);
      from = to;
    }
    Gizmos.color = color1;
  }

  public static void drawGizmo(Transform[] arr, Color color)
  {
    if (arr.Length < 4)
      return;
    Vector3[] pts = new Vector3[arr.Length];
    for (int index = 0; index < arr.Length; ++index)
      pts[index] = arr[index].position;
    LTSpline ltSpline = new LTSpline(pts);
    Vector3 from = ltSpline.ptsAdj[0];
    Color color1 = Gizmos.color;
    Gizmos.color = color;
    for (int index = 0; index < ltSpline.ptsAdjLength; ++index)
    {
      Vector3 to = ltSpline.ptsAdj[index];
      Gizmos.DrawLine(from, to);
      from = to;
    }
    Gizmos.color = color1;
  }

  public static void drawLine(Transform[] arr, float width, Color color)
  {
    int length = arr.Length;
  }

  public void drawLinesGLLines(Material outlineMaterial, Color color, float width)
  {
    GL.PushMatrix();
    outlineMaterial.SetPass(0);
    GL.LoadPixelMatrix();
    GL.Begin(1);
    GL.Color(color);
    if (this.constantSpeed)
    {
      if (this.ptsAdjLength >= 4)
      {
        Vector3 v1 = this.ptsAdj[0];
        for (int index = 0; index < this.ptsAdjLength; ++index)
        {
          Vector3 v2 = this.ptsAdj[index];
          GL.Vertex(v1);
          GL.Vertex(v2);
          v1 = v2;
        }
      }
    }
    else if (this.pts.Length >= 4)
    {
      Vector3 v3 = this.pts[0];
      float num1 = (float) (1.0 / ((double) this.pts.Length * 10.0));
      for (float num2 = 0.0f; (double) num2 < 1.0; num2 += num1)
      {
        Vector3 v4 = this.interp(num2 / 1f);
        GL.Vertex(v3);
        GL.Vertex(v4);
        v3 = v4;
      }
    }
    GL.End();
    GL.PopMatrix();
  }

  public Vector3[] generateVectors()
  {
    if (this.pts.Length >= 4)
    {
      List<Vector3> vector3List = new List<Vector3>();
      vector3List.Add(this.pts[0]);
      float num1 = (float) (1.0 / ((double) this.pts.Length * 10.0));
      for (float num2 = 0.0f; (double) num2 < 1.0; num2 += num1)
      {
        Vector3 vector3 = this.interp(num2 / 1f);
        vector3List.Add(vector3);
      }
      vector3List.ToArray();
    }
    return (Vector3[]) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: LTUtility
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class LTUtility
{
  public static Vector3[] reverse(Vector3[] arr)
  {
    int length = arr.Length;
    int index1 = 0;
    for (int index2 = length - 1; index1 < index2; --index2)
    {
      Vector3 vector3 = arr[index1];
      arr[index1] = arr[index2];
      arr[index2] = vector3;
      ++index1;
    }
    return arr;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MainMenu
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class MainMenu : Menu
{
  public GameObject playButton;
  public GameObject continueButton;
  public GameObject modsButton;
  public bool skipTutorial = true;

  public bool tutorial => !this.skipTutorial && SaveSystem.LoadProgressData<int>("tutorialProgress", 0) == 0;

  public void Start()
  {
    this.modsButton.SetActive(true);
    this.skipTutorial = false;
  }

  public void Play()
  {
    if (this.tutorial)
      this.StartGame("GameModeTutorial");
    else
      this.GoToTown();
  }

  public void Credits()
  {
    if (!this.active)
      return;
    this.StartCoroutine(this.CreditsRoutine());
  }

  public IEnumerator CreditsRoutine()
  {
    MainMenu mainMenu = this;
    mainMenu.active = false;
    yield return (object) SceneManager.Load("Credits", SceneType.Temporary);
    yield return (object) SceneManager.WaitUntilUnloaded("Credits");
    mainMenu.active = true;
  }

  public void Settings() => Object.FindObjectOfType<PauseMenu>(true)?.Settings();
}
﻿// Decompiled with JetBrains decompiler
// Type: MapAreaNameRevealSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine.Events;

public class MapAreaNameRevealSystem : GameSystem
{
  public readonly Dictionary<int, CampaignNode> areaNameNodes = new Dictionary<int, CampaignNode>();

  public void OnEnable()
  {
    global::Events.OnMapNodeReveal += new UnityAction<MapNode>(this.MapNodeReveal);
    foreach (CampaignNode node in References.Campaign.nodes)
    {
      if (!node.revealed && !node.type.interactable && node.type.letter.StartsWith("area"))
        this.areaNameNodes[node.areaIndex] = node;
    }
  }

  public void OnDisable() => global::Events.OnMapNodeReveal -= new UnityAction<MapNode>(this.MapNodeReveal);

  public void MapNodeReveal(MapNode mapNode)
  {
    CampaignNode campaignNode;
    if (!this.areaNameNodes.TryGetValue(mapNode.campaignNode.areaIndex, out campaignNode))
      return;
    References.Map.FindNode(campaignNode).Reveal();
    this.areaNameNodes.Remove(campaignNode.areaIndex);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MapInspectSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Components;
using UnityEngine.UI;

public class MapInspectSequence : MonoBehaviour
{
  [SerializeField]
  public LocalizeStringEvent title;
  [SerializeField]
  public LocalizeStringEvent desc;
  [SerializeField]
  public Image image;
  [SerializeField]
  public MapInspectSequence.Profile[] profiles;

  public void Inspect(int index) => this.Inspect(this.profiles[index]);

  public void Inspect(MapInspectSequence.Profile profile) => this.Inspect(profile.titleKey, profile.descKey, profile.icon);

  public void Inspect(LocalizedString titleKey, LocalizedString descKey, Sprite icon)
  {
    this.title.StringReference = titleKey;
    this.desc.StringReference = descKey;
    this.image.sprite = icon;
    this.gameObject.SetActive(true);
  }

  [Serializable]
  public struct Profile
  {
    public LocalizedString titleKey;
    public LocalizedString descKey;
    public Sprite icon;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MapNew
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class MapNew : MonoBehaviour
{
  [SerializeField]
  public Transform positioner;
  [SerializeField]
  public Transform nodesGroup;
  [SerializeField]
  public MapPath pathPrefab;
  [SerializeField]
  public MapStamp stamp;
  public static Vector3 prePosition = Vector3.zero;
  public readonly List<MapNode> nodes = new List<MapNode>();
  public readonly List<MapPath> paths = new List<MapPath>();
  [SerializeField]
  public Sprite[] detailSprites;
  public bool active = true;
  public MapPath[] fadedPaths;
  public MapNode hoverNode;
  public MapNode[] fadedNodes;
  public bool interactable = true;

  public void OnEnable()
  {
    global::Events.OnMapNodeHover += new UnityAction<MapNode>(this.HoverNode);
    global::Events.OnMapNodeUnHover += new UnityAction<MapNode>(this.UnHoverNode);
  }

  public void OnDisable()
  {
    global::Events.OnMapNodeHover -= new UnityAction<MapNode>(this.HoverNode);
    global::Events.OnMapNodeUnHover -= new UnityAction<MapNode>(this.UnHoverNode);
  }

  public IEnumerator Start()
  {
    MapNew mapNew = this;
    yield return (object) new WaitUntil((Func<bool>) (() => !Transition.Running));
    References.Map = mapNew;
    mapNew.nodesGroup.DestroyAllChildren();
    mapNew.nodes.Clear();
    mapNew.paths.Clear();
    foreach (CampaignNode node in Campaign.instance.nodes)
      mapNew.CreateNode(node);
    foreach (MapNode node1 in mapNew.nodes)
    {
      List<MapNode> mapNodeList = new List<MapNode>();
      if (node1.campaignNode.connections != null)
      {
        foreach (CampaignNode.Connection connection in node1.campaignNode.connections)
        {
          MapNode node2 = mapNew.FindNode(Campaign.GetNode(connection.otherId));
          mapNodeList.Add(node2);
          ++node2.connectedTo;
        }
      }
      node1.connections = mapNodeList.ToArray();
    }
    foreach (MapNode node in mapNew.nodes)
    {
      if (!node.campaignNode.revealed)
        node.gameObject.SetActive(false);
    }
    mapNew.CreatePaths();
    mapNew.positioner.localPosition = MapNew.prePosition;
    yield return (object) Sequences.Wait(0.5f);
    mapNew.Continue();
  }

  public IEnumerator Restart()
  {
    yield return (object) SceneManager.Unload("Campaign");
    Routine routine = new Routine(Transition.To("Campaign"));
  }

  public MapNode CreateNode(CampaignNode campaignNode)
  {
    MapNode node = UnityEngine.Object.Instantiate<MapNode>(campaignNode.type.mapNodePrefab, this.nodesGroup);
    node.transform.localPosition = campaignNode.position.WithZ(0.0f);
    node.Assign(campaignNode);
    this.nodes.Add(node);
    node.map = this;
    node.name = string.Format("MapNode{0}", (object) this.nodes.Count);
    return node;
  }

  public MapNode FindNode(CampaignNode campaignNode) => this.nodes.Find((Predicate<MapNode>) (a => a.campaignNode == campaignNode));

  public List<MapPath> FindPaths(MapNode fromNode) => this.paths.FindAll((Predicate<MapPath>) (a => (UnityEngine.Object) a.StartNode == (UnityEngine.Object) fromNode));

  public void CreatePaths()
  {
    MapNode mapNode1 = (MapNode) null;
    foreach (MapNode node in this.nodes)
    {
      if (node.connections.Length != 0)
      {
        mapNode1 = node;
        break;
      }
    }
    List<MapNode> mapNodeList1 = new List<MapNode>();
    while ((UnityEngine.Object) mapNode1 != (UnityEngine.Object) null)
    {
      if (mapNode1.connections.Length == 1)
      {
        this.CreatePath(mapNode1, mapNode1.connections[0]);
        mapNode1 = mapNode1.connections[0];
      }
      else if (mapNode1.connections.Length > 1)
      {
        MapNode mapNode2 = (MapNode) null;
        foreach (MapNode connection in mapNode1.connections)
        {
          List<MapNode> mapNodeList2 = new List<MapNode>()
          {
            mapNode1,
            connection
          };
          MapNode mapNode3 = connection;
          while ((UnityEngine.Object) mapNode3 != (UnityEngine.Object) null)
          {
            if (mapNode3.connectedTo == 1 && mapNode3.connections.Length != 0)
            {
              mapNodeList2.Add(mapNode3.connections[0]);
              mapNode3 = mapNode3.connections[0];
            }
            else
            {
              mapNode2 = mapNode3;
              mapNode3 = (MapNode) null;
            }
          }
          this.CreatePath(mapNodeList2.ToArray());
        }
        if ((UnityEngine.Object) mapNode2 != (UnityEngine.Object) null)
          mapNode1 = mapNode2;
      }
      else
        mapNode1 = (MapNode) null;
    }
  }

  public MapPath CreatePath(params MapNode[] nodes)
  {
    MapPath path = UnityEngine.Object.Instantiate<MapPath>(this.pathPrefab, this.nodesGroup);
    foreach (MapNode node in nodes)
      path.Add(node);
    path.Setup();
    this.paths.Add(path);
    return path;
  }

  public IEnumerator Reveal()
  {
    MapNode currentNode = this.FindNode(Campaign.FindCharacterNode(References.Player));
    yield return (object) Sequences.Wait(0.5f);
    yield return (object) this.Reveal(currentNode);
  }

  public IEnumerator Reveal(MapNode fromNode)
  {
    if (!fromNode.campaignNode.type.isBattle || fromNode.campaignNode.cleared)
    {
      fromNode.Reveal();
      List<MapNode> endNodes = new List<MapNode>();
      foreach (MapPath path in this.FindPaths(fromNode))
      {
        yield return (object) path.Reveal();
        MapNode endNode = path.EndNode;
        if (!endNodes.Contains(endNode))
          endNodes.Add(endNode);
      }
      foreach (MapNode fromNode1 in endNodes)
      {
        if (!fromNode1.campaignNode.type.isBattle)
          yield return (object) this.Reveal(fromNode1);
      }
    }
  }

  public void UpdateInteractability(bool forceCanSkip = false)
  {
    MapNode node1 = this.FindNode(Campaign.FindCharacterNode(References.Player));
    List<MapNode> allConnections = this.GetAllConnections(node1, forceCanSkip);
    foreach (MapNode node2 in this.nodes)
    {
      bool flag1 = allConnections.Contains(node2);
      node2.reachable = flag1 || node2.campaignNode.cleared;
      node2.hoverable = this.interactable & flag1;
      bool flag2 = node1.connections.Contains<MapNode>(node2);
      bool flag3 = node1.campaignNode.cleared || !node1.campaignNode.type.mustClear;
      node2.SetSelectable(this.interactable & flag2 & flag3);
    }
    node1.SetSelectable(this.interactable && node1.interactable && !node1.campaignNode.cleared);
    foreach (MapPath path in this.paths)
    {
      if (path.gameObject.activeSelf)
        path.CheckReachable();
    }
  }

  public void Focus()
  {
    MapNode[] array = this.GetAllConnections(this.FindNode(Campaign.FindCharacterNode(References.Player))).ToArray();
    if (array.Length == 0)
      return;
    this.FocusOn(array);
  }

  public void FocusOn(params MapNode[] nodes)
  {
    Vector3 zero = Vector3.zero;
    foreach (MapNode node in nodes)
      zero += node.transform.localPosition;
    Vector3 to = -(zero / (float) nodes.Length);
    LeanTween.moveLocal(this.positioner.gameObject, to, 0.5f).setEase(LeanTweenType.easeInOutQuad);
    MapNew.prePosition = to;
  }

  public List<MapNode> GetAllConnections(MapNode startNode, bool forceCanSkip = false)
  {
    List<MapNode> allConnections = new List<MapNode>();
    List<MapNode> mapNodeList = new List<MapNode>()
    {
      startNode
    };
    while (mapNodeList.Count > 0)
    {
      MapNode mapNode = mapNodeList[0];
      mapNodeList.RemoveAt(0);
      if (!allConnections.Contains(mapNode))
        allConnections.Add(mapNode);
      if (mapNode.campaignNode.cleared | forceCanSkip || mapNode.campaignNode.type.canSkip)
      {
        foreach (MapNode connection in mapNode.connections)
        {
          if (!mapNodeList.Contains(connection))
            mapNodeList.Add(connection);
        }
      }
    }
    return allConnections;
  }

  public bool TryMoveTo(MapNode node)
  {
    Character player = References.Player;
    CampaignNode characterNode = Campaign.FindCharacterNode(player);
    if (characterNode != node.campaignNode && !characterNode.connections.Exists((Predicate<CampaignNode.Connection>) (a => a.otherId == node.campaignNode.id)))
      return false;
    if (!node.campaignNode.type.isBattle || player.GetCompanionCount() <= player.data.companionLimit)
    {
      MapNew.MoveTo(player, node);
      this.Enter(player, node);
      return true;
    }
    if (player.entity.display is CharacterDisplay display)
      display.deckDisplay.companionLimitSequence.Begin();
    return false;
  }

  public static void MoveTo(Character character, MapNode node) => Campaign.MoveCharacter(character, node.campaignNode);

  public void Enter(Character character, MapNode node)
  {
    this.interactable = false;
    this.UpdateInteractability();
    this.stamp.Stamp(node.transform.position);
    Campaign.TryEnterNode(node.campaignNode);
  }

  public static IEnumerator CheckCompanionLimit()
  {
    Character player = References.Player;
    CharacterDisplay playerDisplay = player.entity.display as CharacterDisplay;
    if (playerDisplay != null && player.GetCompanionCount() > player.data.companionLimit)
    {
      playerDisplay.deckDisplay.companionLimitSequence.Begin();
      yield return (object) new WaitUntil((Func<bool>) (() => !playerDisplay.deckDisplay.companionLimitSequence.IsRunning));
    }
  }

  [Button(null, EButtonEnableMode.Always)]
  public void Continue(bool forceCanSkip = false)
  {
    this.interactable = true;
    foreach (MapNode node in this.nodes)
      node.Refresh();
    this.StartCoroutine(this.Reveal(this.FindNode(Campaign.FindCharacterNode(References.Player))));
    this.UpdateInteractability(forceCanSkip);
    this.Focus();
    this.stamp.FadeOut();
  }

  public void HoverNode(MapNode node)
  {
    if ((UnityEngine.Object) this.hoverNode != (UnityEngine.Object) null)
      this.UnHoverNode(this.hoverNode);
    MapNode node1 = this.FindNode(Campaign.FindCharacterNode(References.Player));
    if (node1.connections.Length <= 1 || !((UnityEngine.Object) node != (UnityEngine.Object) node1) || node.connectedTo != 1)
      return;
    List<MapPath> paths = this.FindPaths(node1);
    MapPath mapPath1 = (MapPath) null;
    List<MapPath> mapPathList = new List<MapPath>();
    foreach (MapPath mapPath2 in paths)
    {
      if (mapPath2.ContainsNode(node))
        mapPath1 = mapPath2;
      else
        mapPathList.Add(mapPath2);
    }
    if (!((UnityEngine.Object) mapPath1 != (UnityEngine.Object) null))
      return;
    this.hoverNode = node;
    foreach (MapPath mapPath3 in paths)
    {
      if ((UnityEngine.Object) mapPath3 != (UnityEngine.Object) mapPath1)
        mapPath3.FadeTo(0.5f, 0.0f);
    }
    List<MapNode> allConnections = this.GetAllConnections(node);
    List<MapNode> mapNodeList = new List<MapNode>();
    foreach (MapNode node2 in this.nodes)
    {
      bool flag = allConnections.Contains(node2);
      if (!node2.campaignNode.cleared && !flag && !mapPath1.ContainsNode(node2))
      {
        mapNodeList.Add(node2);
        node2.color = new Color(1f, 1f, 1f, 0.5f);
      }
    }
    this.fadedPaths = mapPathList.ToArray();
    this.fadedNodes = mapNodeList.ToArray();
  }

  public void UnHoverNode(MapNode node)
  {
    if (!((UnityEngine.Object) this.hoverNode == (UnityEngine.Object) node))
      return;
    if (this.fadedPaths != null)
    {
      foreach (MapPath fadedPath in this.fadedPaths)
      {
        if (fadedPath.reachable)
          fadedPath.FadeTo(1f, 0.0f);
      }
      this.fadedPaths = (MapPath[]) null;
    }
    if (this.fadedNodes != null)
    {
      foreach (MapNode fadedNode in this.fadedNodes)
      {
        if (fadedNode.reachable)
          fadedNode.color = Color.white;
      }
      this.fadedNodes = (MapNode[]) null;
    }
    this.hoverNode = (MapNode) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MapNode
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using NaughtyAttributes;
using UnityEngine;
using UnityEngine.EventSystems;

public class MapNode : MonoBehaviour
{
  public MapNew map;
  public CampaignNode campaignNode;
  public MapNode[] connections;
  public int connectedTo;
  public bool interactable;
  [SerializeField]
  public Animator animator;
  [SerializeField]
  public GameObject highlight;
  [SerializeField]
  public GameObject glow;
  [SerializeField]
  public UINavigationItem uINavigationItem;
  [SerializeField]
  public MapNodeSpriteSetter spriteSetter;
  [SerializeField]
  [HideIf("HasSpriteSetter")]
  public Sprite[] spriteOptions;
  [SerializeField]
  [HideIf("HasSpriteSetter")]
  public Sprite[] clearedSpriteOptions;
  public int spriteIndex;
  [SerializeField]
  public EventReference highlightSfx;
  public bool selectable;
  public bool _hoverable = true;
  public bool _pressable = true;
  public bool reachable = true;
  public bool hasSprite;
  public bool hover;
  public bool press;
  [SerializeField]
  public Transform scaler;
  [SerializeField]
  public SpriteRenderer spriteRenderer;
  [SerializeField]
  public MapNodeLabel label;

  public bool HasSpriteSetter => (bool) (Object) this.spriteSetter;

  public bool hoverable
  {
    get => this._hoverable;
    set
    {
      if (this._hoverable != value)
      {
        if (value)
        {
          if (this.hasSprite)
            this.spriteRenderer.color = Color.white;
          if ((bool) (Object) this.scaler)
          {
            LeanTween.cancel(this.scaler.gameObject);
            LeanTween.scale(this.scaler.gameObject, Vector3.one * 1f, 0.33f).setEase(LeanTweenType.easeOutBack);
          }
        }
        else
        {
          Color color = this.reachable ? new Color(1f, 1f, 1f, 1f) : new Color(1f, 1f, 1f, 0.25f);
          if (this.hasSprite)
            this.spriteRenderer.color = color;
          if ((bool) (Object) this.scaler)
          {
            LeanTween.cancel(this.scaler.gameObject);
            LeanTween.scale(this.scaler.gameObject, Vector3.one * 0.9f, 0.33f).setEase(LeanTweenType.easeOutBack);
          }
          if (this.hover)
            this.UnHover();
        }
      }
      if ((bool) (Object) this.uINavigationItem)
        this.uINavigationItem.enabled = value;
      this._hoverable = value;
    }
  }

  public bool pressable
  {
    get => this._pressable;
    set => this._pressable = value;
  }

  public bool IsHovered => this.hover;

  public Color color
  {
    set
    {
      if (!this.hasSprite)
        return;
      this.spriteRenderer.color = value;
    }
  }

  public void Assign(CampaignNode node)
  {
    this.hasSprite = (bool) (Object) this.spriteRenderer;
    Random.InitState(node.seed);
    if (!this.HasSpriteSetter && this.spriteOptions.Length != 0)
      this.spriteIndex = Random.Range(0, this.spriteOptions.Length);
    this.campaignNode = node;
    this.Refresh();
    this.interactable = node.type.interactable;
    if (this.hasSprite)
    {
      Collider2D component = this.spriteRenderer.GetComponent<Collider2D>();
      if (component != null)
        component.Destroy();
      this.spriteRenderer.gameObject.AddComponent<BoxCollider2D>();
    }
    if (!(bool) (Object) this.glow)
      return;
    this.glow.SetActive(node.glow && !node.cleared);
  }

  public void Refresh()
  {
    if (!this.hasSprite)
      return;
    if (this.HasSpriteSetter)
    {
      this.spriteSetter.Set(this);
    }
    else
    {
      Sprite spriteOption = this.spriteOptions[this.spriteIndex];
      Sprite sprite = spriteOption;
      if (this.clearedSpriteOptions.Length != 0)
        sprite = this.clearedSpriteOptions[this.spriteIndex % this.clearedSpriteOptions.Length];
      this.SetSprite(this.campaignNode.cleared ? ((bool) (Object) sprite ? sprite : spriteOption) : spriteOption);
    }
  }

  public void SetSprite(Sprite sprite) => this.spriteRenderer.sprite = sprite;

  public void OnEnable() => this.CheckForFocus();

  public void CheckForFocus()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse || !(bool) (Object) this.highlight || !this.highlight.gameObject.activeSelf || !(bool) (Object) this.uINavigationItem || !this.uINavigationItem.isActiveAndEnabled)
      return;
    MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(this.uINavigationItem);
  }

  public void Reveal()
  {
    this.campaignNode.revealed = true;
    if (this.gameObject.activeSelf)
      return;
    this.gameObject.SetActive(true);
    this.transform.localScale = Vector3.zero;
    LeanTween.scale(this.gameObject, Vector3.one, Random.Range(0.4f, 0.5f)).setEase(LeanTweenType.easeOutBack);
    this.transform.localEulerAngles = new Vector3(0.0f, 0.0f, Random.Range(45f, 90f));
    LeanTween.rotateLocal(this.gameObject, Vector3.zero, Random.Range(0.4f, 0.5f)).setEase(LeanTweenType.easeOutBack);
    Events.InvokeMapNodeReveal(this);
    if (this.hover || !((Object) MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem == (Object) this.uINavigationItem))
      return;
    this.Hover();
  }

  public void Hover()
  {
    if (!this.interactable || !this.hoverable || this.hover)
      return;
    this.hover = true;
    LeanTween.cancel(this.spriteRenderer.gameObject);
    LeanTween.scale(this.spriteRenderer.gameObject, Vector3.one * 1.1f, 0.23f).setEase(LeanTweenType.easeOutBack);
    if ((bool) (Object) this.label)
      this.label.Show();
    Events.InvokeMapNodeHover(this);
  }

  public void UnHover()
  {
    if (!this.hover)
      return;
    this.hover = false;
    LeanTween.cancel(this.spriteRenderer.gameObject);
    LeanTween.scale(this.spriteRenderer.gameObject, Vector3.one * 1f, 0.13f).setEase(LeanTweenType.easeOutBack);
    if ((bool) (Object) this.label)
      this.label.Hide();
    Events.InvokeMapNodeUnHover(this);
  }

  public void Press(BaseEventData eventData)
  {
    if (eventData is PointerEventData pointerEventData && pointerEventData.button != PointerEventData.InputButton.Left || !this.interactable || !this.pressable || this.press || !this.hover)
      return;
    this.press = true;
    this.color = new Color(0.85f, 0.85f, 0.85f);
  }

  public void Release(BaseEventData eventData)
  {
    if (eventData is PointerEventData pointerEventData && pointerEventData.button != PointerEventData.InputButton.Left || !this.press)
      return;
    this.press = false;
    this.color = Color.white;
    if (!this.hover)
      return;
    this.Select();
  }

  public void Select()
  {
    if (this.selectable && this.map.TryMoveTo(this))
    {
      Events.InvokeMapNodeSelect(this);
      this.animator.Play(nameof (Select));
      this.glow.SetActive(false);
    }
    else
    {
      Events.InvokeMapNodeSelect((MapNode) null);
      this.animator.Play("Shake");
    }
  }

  public void SetSelectable(bool value)
  {
    if (!this.selectable & value)
    {
      if ((bool) (Object) this.animator)
        this.animator.Play("Selectable");
      if ((bool) (Object) this.highlight)
      {
        this.highlight.gameObject.SetActive(true);
        this.highlight.transform.localScale = Vector3.zero;
        LeanTween.scale(this.highlight, Vector3.one, 1.25f).setEase(LeanTweenType.easeOutElastic).setDelay(0.25f);
      }
      SfxSystem.OneShot(this.highlightSfx);
      this.CheckForFocus();
    }
    else if (this.selectable && !value)
    {
      if ((bool) (Object) this.animator)
        this.animator.Stop();
      if ((bool) (Object) this.highlight)
        this.highlight.gameObject.SetActive(false);
    }
    this.selectable = value;
  }

  public override string ToString() => this.name;
}
﻿// Decompiled with JetBrains decompiler
// Type: MapNodeLabel
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class MapNodeLabel : MonoBehaviour
{
  [SerializeField]
  public SpriteRenderer spriteRenderer;
  [SerializeField]
  public TextMeshFitter textFitter;
  public Vector3 startPos;
  public Color startColor;

  public void Awake()
  {
    this.startPos = this.transform.localPosition;
    this.startColor = this.spriteRenderer.color;
  }

  public void Show()
  {
    this.gameObject.SetActive(true);
    LeanTween.cancel(this.gameObject);
    LeanTween.cancel(this.spriteRenderer.gameObject);
    this.transform.localPosition = this.startPos + new Vector3(0.0f, -0.15f, 0.0f);
    LeanTween.moveLocal(this.gameObject, this.startPos, 1f).setEase(LeanTweenType.easeOutElastic);
    this.spriteRenderer.color = this.startColor.With(alpha: 0.0f);
    LeanTween.color(this.spriteRenderer.gameObject, this.startColor, 0.25f).setEase(LeanTweenType.easeOutQuart);
  }

  public void Hide() => this.gameObject.SetActive(false);
}
﻿// Decompiled with JetBrains decompiler
// Type: MapNodeSpriteSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public abstract class MapNodeSpriteSetter : MonoBehaviour
{
  public virtual void Set(MapNode mapNode)
  {
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MapNodeSpriteSetterBattle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization.Components;

public class MapNodeSpriteSetterBattle : MapNodeSpriteSetter
{
  [SerializeField]
  public SpriteRenderer @base;
  [SerializeField]
  public SpriteRenderer icon;
  [SerializeField]
  public LocalizeStringEvent battleNameString;
  [SerializeField]
  public GameObject iconObj;
  [SerializeField]
  public GameObject flagObj;

  public override void Set(MapNode mapNode)
  {
    if ((bool) (Object) this.@base)
      this.@base.sprite = References.Areas[mapNode.campaignNode.areaIndex].battleBaseSprite;
    object obj;
    if (mapNode.campaignNode.type is CampaignNodeTypeBattle && mapNode.campaignNode.data.TryGetValue("battle", out obj) && obj is string assetName)
    {
      BattleData battleData = AddressableLoader.Get<BattleData>("BattleData", assetName);
      if (battleData != null)
      {
        this.icon.sprite = battleData.sprite;
        if ((bool) (Object) this.battleNameString)
          this.battleNameString.StringReference = battleData.nameRef;
      }
    }
    if (!mapNode.campaignNode.cleared || !(bool) (Object) this.flagObj)
      return;
    this.flagObj.SetActive(true);
    this.iconObj.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MapNodeSpriteSetterItem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class MapNodeSpriteSetterItem : MapNodeSpriteSetter
{
  [SerializeField]
  public Sprite normalSprite;
  [SerializeField]
  public Sprite bigSprite;
  [SerializeField]
  public Sprite clearedSprite;

  public override void Set(MapNode mapNode)
  {
    if (mapNode.campaignNode.cleared)
    {
      mapNode.SetSprite(this.clearedSprite);
    }
    else
    {
      object obj;
      if (mapNode.campaignNode.data.TryGetValue("cards", out obj) && obj is SaveCollection<string> saveCollection && saveCollection.Count > 3)
        mapNode.SetSprite(this.bigSprite);
      else
        mapNode.SetSprite(this.normalSprite);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MapPath
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

public class MapPath : MonoBehaviour
{
  [SerializeField]
  public Transform linePointPrefab;
  [SerializeField]
  public Transform lastPoint;
  [SerializeField]
  public Vector2 midPointOffset = new Vector2(0.0f, 1f);
  [SerializeField]
  public float pathShort = 1f;
  [SerializeField]
  public Vector2 pathNodePull = new Vector2(0.75f, 1.2f);
  [SerializeField]
  public LineRenderer line;
  [SerializeField]
  public CurvedLineRenderer curve;
  [Header("Tweens")]
  [SerializeField]
  public LeanTweenType revealEase = LeanTweenType.easeInOutCubic;
  [SerializeField]
  public float revealSpeed = 1f;
  public List<MapPath.Node> nodes = new List<MapPath.Node>();
  [CompilerGenerated]
  public MapNode \u003CStartNode\u003Ek__BackingField;
  public bool reachable = true;
  public float alpha = 1f;
  public LTDescr alphaTween;

  public MapNode StartNode
  {
    get => this.\u003CStartNode\u003Ek__BackingField;
    set => this.\u003CStartNode\u003Ek__BackingField = value;
  }

  public MapNode EndNode => this.nodes[this.nodes.Count - 1].mapNode;

  public int NodeCount => this.nodes.Count;

  public bool ContainsNode(MapNode node) => this.nodes.Exists((Predicate<MapPath.Node>) (a => (UnityEngine.Object) a.mapNode == (UnityEngine.Object) node));

  public void Add(MapNode node)
  {
    Vector3 localPosition = node.transform.localPosition;
    if ((UnityEngine.Object) this.lastPoint != (UnityEngine.Object) null)
      this.AddPoint((this.lastPoint.localPosition + localPosition) * 0.5f + new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)).normalized * this.midPointOffset.Random());
    if (this.StartNode == null)
    {
      MapNode mapNode;
      this.StartNode = mapNode = node;
    }
    Transform transform = this.AddPoint(localPosition);
    this.nodes.Add(new MapPath.Node()
    {
      mapNode = node,
      point = transform
    });
    this.lastPoint = transform;
  }

  public MapNode Get(int index) => this.nodes[index].mapNode;

  public MapNode[] GetNodes()
  {
    List<MapNode> mapNodeList = new List<MapNode>();
    foreach (MapPath.Node node in this.nodes)
      mapNodeList.Add(node.mapNode);
    return mapNodeList.ToArray();
  }

  public void Setup()
  {
    if (this.nodes.Count <= 1)
      throw new Exception("MapPath Error: MUST HAVE more than 1 node in the path");
    this.PullTowards(this.nodes[0].point.transform, this.nodes[1].point.transform.localPosition, this.pathShort);
    this.PullTowards(this.nodes[this.nodes.Count - 1].point.transform, this.nodes[this.nodes.Count - 2].point.transform.localPosition, this.pathShort);
    for (int index = 1; index < this.nodes.Count - 1; ++index)
    {
      Transform transform1 = this.nodes[index - 1].mapNode.transform;
      Transform transform2 = this.nodes[index].point.transform;
      Transform transform3 = this.nodes[index + 1].mapNode.transform;
      Vector3 towards = (transform1.localPosition + transform3.localPosition) * 0.5f;
      this.PullTowards(transform2, towards, this.pathNodePull.Random());
    }
    this.curve.UpdatePoints();
    bool flag = true;
    foreach (MapPath.Node node in this.nodes)
    {
      if (!node.mapNode.campaignNode.revealed)
      {
        flag = false;
        break;
      }
    }
    if (flag)
      return;
    this.Hide();
  }

  public void PullTowards(Transform point, Vector3 towards, float amount)
  {
    Vector3 localPosition = point.localPosition;
    Vector3 vector3 = (towards - localPosition).normalized * amount;
    point.localPosition += vector3;
  }

  public Transform AddPoint(Vector3 localPosition)
  {
    Transform transform = UnityEngine.Object.Instantiate<Transform>(this.linePointPrefab, this.transform);
    transform.localPosition = localPosition;
    transform.gameObject.SetActive(true);
    return transform;
  }

  public void Hide()
  {
    if (!this.gameObject.activeSelf)
      return;
    this.gameObject.SetActive(false);
  }

  public IEnumerator Reveal()
  {
    MapPath mapPath = this;
    if (!mapPath.gameObject.activeSelf)
    {
      mapPath.gameObject.SetActive(true);
      mapPath.SetAlpha(1f);
      mapPath.UpdatePathVisibility(0.0f);
      float delayPerNode = 0.2f / mapPath.revealSpeed;
      float num = (float) mapPath.nodes.Count * delayPerNode;
      LeanTween.value(mapPath.gameObject, 0.0f, 1f, num).setEase(mapPath.revealEase).setOnUpdate(new Action<float>(mapPath.\u003CReveal\u003Eb__29_0));
      Events.InvokeMapPathReveal(num);
      foreach (MapPath.Node node1 in mapPath.nodes)
      {
        MapPath.Node node = node1;
        yield return (object) Sequences.Wait(delayPerNode);
        node.mapNode.Reveal();
        node = new MapPath.Node();
      }
    }
  }

  public void CheckReachable()
  {
    if (!this.reachable)
      return;
    this.reachable = false;
    int num = Mathf.Max(2, this.nodes.Count - 1);
    for (int index = 1; index < num; ++index)
    {
      if (this.nodes[index].mapNode.reachable)
      {
        this.reachable = true;
        break;
      }
    }
    if (this.reachable)
      return;
    this.SetUnreachable();
  }

  public void SetUnreachable()
  {
    this.reachable = false;
    this.FadeTo(0.0f);
  }

  public void FadeTo(float alpha, float time = 0.3f)
  {
    if ((double) Mathf.Abs(this.alpha - alpha) <= 0.0099999997764825821)
      return;
    if ((double) time > 0.0)
      this.alphaTween = LeanTween.value(this.gameObject, this.alpha, alpha, time).setEase(LeanTweenType.easeInOutQuad).setOnUpdate(new Action<float>(this.SetAlpha));
    else
      this.SetAlpha(alpha);
    this.alpha = alpha;
  }

  public void UpdatePathVisibility(float value)
  {
    int num = 1;
    if ((double) value <= 0.0099999997764825821)
      this.line.widthCurve = new AnimationCurve(new Keyframe[2]
      {
        new Keyframe(0.0f, 0.0f, 0.0f, 0.0f),
        new Keyframe(1f, 0.0f, 0.0f, 0.0f)
      });
    else if ((double) value >= 0.99000000953674316)
      this.line.widthCurve = new AnimationCurve(new Keyframe[2]
      {
        new Keyframe(0.0f, (float) num, 0.0f, 0.0f),
        new Keyframe(1f, (float) num, 0.0f, 0.0f)
      });
    else
      this.line.widthCurve = new AnimationCurve(new Keyframe[3]
      {
        new Keyframe(0.0f, (float) num, 0.0f, 0.0f),
        new Keyframe(value - 0.01f, (float) num, 0.0f, 0.0f),
        new Keyframe(value, 0.0f, 0.0f, 0.0f)
      });
  }

  public void SetColour(Color value) => this.line.colorGradient.colorKeys = new GradientColorKey[2]
  {
    new GradientColorKey(value, 0.0f),
    new GradientColorKey(value, 1f)
  };

  public void SetAlpha(float value)
  {
    Gradient colorGradient = this.line.colorGradient;
    colorGradient.alphaKeys = new GradientAlphaKey[2]
    {
      new GradientAlphaKey(value, 0.0f),
      new GradientAlphaKey(value, 1f)
    };
    this.line.colorGradient = colorGradient;
  }

  [CompilerGenerated]
  public void \u003CReveal\u003Eb__29_0(float a) => this.UpdatePathVisibility(a);

  public struct Node
  {
    public MapNode mapNode;
    public Transform point;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MapStamp
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Runtime.CompilerServices;
using UnityEngine;

[RequireComponent(typeof (SpriteRenderer))]
public class MapStamp : MonoBehaviour
{
  public SpriteRenderer spriteRenderer;

  public void Awake() => this.spriteRenderer = this.GetComponent<SpriteRenderer>();

  public void Stamp(Vector3 position)
  {
    this.gameObject.SetActive(true);
    this.transform.position = position;
    this.transform.localEulerAngles = new Vector3(0.0f, 0.0f, (float) UnityEngine.Random.Range(-20, 20));
    LeanTween.cancel(this.gameObject);
    this.transform.localScale = Vector3.one * 2f;
    LeanTween.scale(this.gameObject, Vector3.one, 0.5f).setEase(LeanTweenType.easeOutBounce);
    this.spriteRenderer.color = new Color(1f, 1f, 1f, 0.0f);
    LeanTween.color(this.gameObject, Color.white, 0.33f).setEase(LeanTweenType.easeOutQuad);
  }

  public void FadeOut()
  {
    LeanTween.cancel(this.gameObject);
    LeanTween.color(this.gameObject, new Color(1f, 1f, 1f, 0.0f), 0.33f).setEase(LeanTweenType.easeOutQuad).setOnComplete((System.Action) (() => this.gameObject.SetActive(false)));
  }

  [CompilerGenerated]
  public void \u003CFadeOut\u003Eb__3_0() => this.gameObject.SetActive(false);
}
﻿// Decompiled with JetBrains decompiler
// Type: Menu
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class Menu : MonoBehaviour
{
  [SerializeField]
  public HelpPanelShower retryTutorialHelp;
  public bool active = true;

  public void GoTo(string sceneName)
  {
    if (!this.active)
      return;
    Routine routine = new Routine(Transition.To(sceneName));
    this.active = false;
  }

  public void StartGameOrContinue() => this.StartGameOrContinue("GameModeNormal");

  public void StartGameOrContinue(string gameModeName, bool skipTutorial = false)
  {
    GameMode gameMode1 = AddressableLoader.Get<GameMode>("GameMode", "GameModeTutorial");
    if (Campaign.CheckContinue(gameMode1))
    {
      Campaign.Data = CampaignData.Load(gameMode1);
      Routine routine = new Routine(SceneManager.Load("ContinueRun", SceneType.Temporary));
    }
    else if (!skipTutorial && SaveSystem.LoadProgressData<int>("tutorialProgress", 0) <= 1 && (bool) (Object) this.retryTutorialHelp)
    {
      this.retryTutorialHelp.Show();
      this.retryTutorialHelp.AddButton(0, HelpPanelSystem.ButtonType.Positive, (UnityAction) (() => this.StartGame("GameModeTutorial")));
      this.retryTutorialHelp.AddButton(1, HelpPanelSystem.ButtonType.Negative, (UnityAction) (() =>
      {
        SaveSystem.SaveProgressData<int>("tutorialProgress", 2);
        global::Events.InvokeTutorialSkip();
        this.StartGameOrContinue(gameModeName, true);
      }));
    }
    else
    {
      GameMode gameMode2 = AddressableLoader.Get<GameMode>("GameMode", gameModeName);
      if (Campaign.CheckContinue(gameMode2))
      {
        Campaign.Data = CampaignData.Load(gameMode2);
        Routine routine = new Routine(SceneManager.Load("ContinueRun", SceneType.Temporary));
      }
      else
        this.StartGame(gameMode2);
    }
  }

  public void StartGame() => this.StartGame("GameModeNormal");

  public void StartGame(string gameModeName) => this.StartGame(AddressableLoader.Get<GameMode>("GameMode", gameModeName));

  public void StartGame(GameMode gameMode)
  {
    SaveSystem.DeleteCampaign(gameMode);
    global::Events.InvokeCampaignDeleted();
    Campaign.Data = new CampaignData(gameMode);
    this.GoTo(gameMode.startScene);
  }

  public void GoToTown() => this.GoTo("Town");

  public void ExitGame()
  {
    if (!this.active)
      return;
    GameManager.Quit();
  }

  public virtual void Open()
  {
    this.gameObject.SetActive(true);
    this.active = true;
  }

  public void Close()
  {
    this.gameObject.SetActive(false);
    this.active = false;
  }

  public void Toggle()
  {
    if (this.gameObject.activeSelf)
      this.Close();
    else
      this.Open();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MetaprogressionSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Deadpan.Enums.Engine.Components.Modding;
using HarmonyLib;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class MetaprogressionSystem : GameSystem
{
  public static readonly Dictionary<string, object> data = new Dictionary<string, object>()
  {
    {
      "pets",
      (object) new List<string>()
      {
        "Wolfie",
        "BerryPet",
        "DemonPet",
        "DrawPet",
        "Jagzag",
        "BoostPet"
      }
    },
    {
      "items",
      (object) new List<string>()
      {
        "Slapcrackers",
        "Snowcracker",
        "Hooker",
        "ScrapPile",
        "MegaMimik",
        "Krono"
      }
    },
    {
      "companions",
      (object) new List<string>()
      {
        "Snobble",
        "Klutz",
        "TinyTyko",
        "Bombom",
        "BoBo",
        "Turmeep"
      }
    },
    {
      "events",
      (object) new List<string>()
      {
        "CampaignNodeCopyItem",
        "CampaignNodeCharmShop",
        "CampaignNodeCurseItems"
      }
    },
    {
      "buildings",
      (object) new List<string>()
      {
        "InventorHut",
        "IcebreakerHut",
        "HotSpring"
      }
    },
    {
      "charms",
      (object) new Dictionary<string, string>()
      {
        {
          "Charm 1",
          "CardUpgradeFury"
        },
        {
          "Charm 2",
          "CardUpgradeSnowImmune"
        },
        {
          "Charm 3",
          "CardUpgradeAttackIncreaseCounter"
        },
        {
          "Charm 4",
          "CardUpgradeAttackRemoveEffects"
        },
        {
          "Charm 5",
          "CardUpgradeShellBecomesSpice"
        },
        {
          "Charm 6",
          "CardUpgradeEffigy"
        },
        {
          "Charm 7",
          "CardUpgradeShroomReduceHealth"
        },
        {
          "Charm 8",
          "CardUpgradeAttackConsume"
        },
        {
          "Charm 9",
          "CardUpgradeBlock"
        },
        {
          "Charm 10",
          "CardUpgradeGreed"
        },
        {
          "Charm 11",
          "CardUpgradeRemoveCharmLimit"
        },
        {
          "Charm 12",
          "CardUpgradeFrenzyReduceAttack"
        },
        {
          "Charm 13",
          "CardUpgradeConsumeAddHealth"
        },
        {
          "Charm 14",
          "CardUpgradeAttackAndHealth"
        },
        {
          "Charm 15",
          "CardUpgradeCritical"
        },
        {
          "Charm 16",
          "CardUpgradeSpark"
        }
      }
    }
  };

  public static T Get<T>(string key) where T : class => MetaprogressionSystem.data[key] as T;

  public static void Add<T, Y>(string key, Y keyValue, T value)
    where T : class
    where Y : class
  {
    Dictionary<Y, T> dictionary = (Dictionary<Y, T>) MetaprogressionSystem.data[key];
    if (!dictionary.TryAdd(keyValue, value))
      dictionary[keyValue] = value;
    MetaprogressionSystem.data[key] = (object) dictionary;
  }

  public static bool Remove<T, Y>(string key, Y keyValue, T value)
    where T : class
    where Y : class
  {
    Dictionary<Y, T> dictionary = (Dictionary<Y, T>) MetaprogressionSystem.data[key];
    int num = dictionary.Remove(keyValue) ? 1 : 0;
    MetaprogressionSystem.data[key] = (object) dictionary;
    return num != 0;
  }

  public static void Add<T>(string key, T value) where T : class
  {
    List<T> objList = (List<T>) MetaprogressionSystem.data[key];
    objList.Add(value);
    MetaprogressionSystem.data[key] = (object) objList;
  }

  public static bool Remove<T>(string key, T value) where T : class
  {
    List<T> objList = (List<T>) MetaprogressionSystem.data[key];
    int num = objList.Remove(value) ? 1 : 0;
    MetaprogressionSystem.data[key] = (object) objList;
    return num != 0;
  }

  public static T Get<T>(string key, T defaultValue)
  {
    if (MetaprogressionSystem.data.ContainsKey(key) && MetaprogressionSystem.data[key] is T obj)
      return obj;
    return !SaveSystem.Enabled ? defaultValue : SaveSystem.LoadProgressData<T>(key, defaultValue);
  }

  public static void Set<T>(string key, T value)
  {
    if (!SaveSystem.Enabled)
      return;
    SaveSystem.SaveProgressData<T>(key, value);
  }

  public static List<string> GetUnlockedList() => SaveSystem.LoadProgressData<List<string>>("unlocked", new List<string>());

  public static IEnumerable<UnlockData> GetUnlocked(Predicate<UnlockData> match) => MetaprogressionSystem.GetUnlockedList().Select<string, UnlockData>((Func<string, UnlockData>) (n => AddressableLoader.Get<UnlockData>("UnlockData", n))).Where<UnlockData>((Func<UnlockData, bool>) (unlock => (UnityEngine.Object) unlock != (UnityEngine.Object) null && unlock.IsActive && match(unlock)));

  public static List<UnlockData> GetRemainingUnlocks(List<string> alreadyUnlocked = null)
  {
    if (alreadyUnlocked == null)
      alreadyUnlocked = MetaprogressionSystem.GetUnlockedList();
    return AddressableLoader.GetGroup<UnlockData>("UnlockData").Where<UnlockData>((Func<UnlockData, bool>) (a => a.IsActive && !alreadyUnlocked.Contains(a.name) || !a.IsActive)).OrderBy<UnlockData, float>((Func<UnlockData, float>) (a => a.lowPriority)).ToList<UnlockData>();
  }

  public static bool IsUnlocked(UnlockData unlockData, List<string> alreadyUnlocked = null)
  {
    if ((UnityEngine.Object) unlockData == (UnityEngine.Object) null)
      return true;
    return unlockData.IsActive && MetaprogressionSystem.IsUnlocked(unlockData.name, alreadyUnlocked);
  }

  public static bool IsUnlocked(string unlockDataName, List<string> alreadyUnlocked = null)
  {
    if (alreadyUnlocked == null)
      alreadyUnlocked = MetaprogressionSystem.GetUnlockedList();
    return alreadyUnlocked.Contains(unlockDataName);
  }

  public static List<ClassData> GetLockedClasses()
  {
    List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
    return ((IEnumerable<ClassData>) References.Classes).Where<ClassData>((Func<ClassData, bool>) (c => (UnityEngine.Object) c.requiresUnlock != (UnityEngine.Object) null && !MetaprogressionSystem.IsUnlocked(c.requiresUnlock, unlockedList))).ToList<ClassData>();
  }

  public static List<string> GetLockedItems(List<UnlockData> remainingUnlocks)
  {
    int num1 = remainingUnlocks.Count<UnlockData>((Func<UnlockData, bool>) (a => a.type == UnlockData.Type.Item));
    List<string> stringList = MetaprogressionSystem.Get<List<string>>("items");
    int num2 = stringList.Count - num1;
    List<string> lockedItems = new List<string>();
    for (int index = num2; index < stringList.Count; ++index)
      lockedItems.Add(stringList[index]);
    return lockedItems;
  }

  public static List<string> GetLockedCompanions(List<UnlockData> remainingUnlocks)
  {
    int num1 = remainingUnlocks.Count<UnlockData>((Func<UnlockData, bool>) (a => a.type == UnlockData.Type.Companion));
    List<string> stringList = MetaprogressionSystem.Get<List<string>>("companions");
    int num2 = stringList.Count - num1;
    List<string> lockedCompanions = new List<string>();
    for (int index = num2; index < stringList.Count; ++index)
      lockedCompanions.Add(stringList[index]);
    return lockedCompanions;
  }

  public static List<string> GetLockedCharms(List<UnlockData> remainingUnlocks)
  {
    Dictionary<string, string> dictionary = MetaprogressionSystem.Get<Dictionary<string, string>>("charms");
    List<string> lockedCharms = new List<string>();
    foreach (UnlockData remainingUnlock in remainingUnlocks)
    {
      string str;
      if (remainingUnlock.type == UnlockData.Type.Charm && dictionary.TryGetValue(remainingUnlock.name, out str))
        lockedCharms.Add(str);
    }
    return lockedCharms;
  }

  public static string[] GetUnlockedPets()
  {
    List<string> stringList1 = MetaprogressionSystem.Get<List<string>>("pets");
    List<string> stringList2 = SaveSystem.LoadProgressData<List<string>>("petHutUnlocks", (List<string>) null);
    // ISSUE: explicit non-virtual call
    int length = Mathf.Min(stringList1.Count, 1 + (stringList2 != null ? __nonvirtual (stringList2.Count) : 0));
    string[] sequence = new string[length];
    for (int index = 0; index < length; ++index)
      sequence[index] = stringList1[index];
    string[] array = CardDataBuilder.AutoUnlockedPets.ToArray();
    return sequence.AddRangeToArray<string>(array);
  }

  public static void SetUnlocksReady(string unlockName)
  {
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>("townNew", new List<string>());
    stringList.Add(unlockName);
    SaveSystem.SaveProgressData<List<string>>("townNew", stringList);
    foreach (UnlockReadyIcon unlockReadyIcon in UnityEngine.Object.FindObjectsOfType<UnlockReadyIcon>(true))
      unlockReadyIcon.Set(true);
  }

  public static bool CheckUnlockRequirements(UnlockData unlock, ICollection<string> alreadyUnlocked) => ((IEnumerable<UnlockData>) unlock.requires).All<UnlockData>((Func<UnlockData, bool>) (requirement => requirement.IsActive && alreadyUnlocked.Contains(requirement.name)));

  public static bool AnyUnlocksReady() => SaveSystem.LoadProgressData<List<string>>("townNew", new List<string>()).Count > 0;
}
﻿// Decompiled with JetBrains decompiler
// Type: MetaprogressSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UI;

public class MetaprogressSequence : MonoBehaviour
{
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public GameObject tweener;
  [SerializeField]
  public float startDelay = 1f;
  [SerializeField]
  public float endDelay = 0.5f;
  [SerializeField]
  public Image progressImage;
  [SerializeField]
  public Vector2 randomizeProgress = new Vector2(0.9f, 1.1f);
  [SerializeField]
  public GainUnlockSequence gainUnlockSequence;
  [SerializeField]
  public ParticleSystem particleSystem;
  [CompilerGenerated]
  public bool \u003Crunning\u003Ek__BackingField;
  public float targetFillAmount;
  public const float progressPerParticle = 0.02f;

  public bool running
  {
    get => this.\u003Crunning\u003Ek__BackingField;
    set => this.\u003Crunning\u003Ek__BackingField = value;
  }

  public IEnumerator Start()
  {
    yield return (object) this.Sequence();
  }

  public IEnumerator Sequence(float? amount = null)
  {
    MetaprogressSequence metaprogressSequence = this;
    metaprogressSequence.running = true;
    yield return (object) AddressableLoader.LoadGroup("UnlockData");
    List<string> alreadyUnlocked = MetaprogressionSystem.GetUnlockedList();
    List<UnlockData> remainingUnlocks = MetaprogressionSystem.GetRemainingUnlocks(alreadyUnlocked);
    Debug.Log((object) string.Format("{0} Remaining Unlocks: {1}", (object) remainingUnlocks.Count, (object) string.Join<UnlockData>(", ", (IEnumerable<UnlockData>) remainingUnlocks)));
    MetaprogressSequence.RemoveIneligibleUnlocks((IList<UnlockData>) remainingUnlocks, (ICollection<string>) alreadyUnlocked);
    Debug.Log((object) string.Format("{0} Eligible Unlocks: {1}", (object) remainingUnlocks.Count, (object) string.Join<UnlockData>(", ", (IEnumerable<UnlockData>) remainingUnlocks)));
    Progression townProgress = SaveSystem.LoadProgressData<Progression>("townProgress", new Progression(0.0f, 1f, 0.0f));
    metaprogressSequence.progressImage.fillAmount = remainingUnlocks.Count > 0 ? townProgress.ProgressToNextUnlock() : 1f;
    if (remainingUnlocks.Count > 0)
    {
      yield return (object) new WaitForSeconds(metaprogressSequence.startDelay);
      float num1 = (float) StatsSystem.Get().Count("battlesWon");
      float num2 = 7f;
      double num3 = (!amount.HasValue ? ((double) num1 > 0.0 ? (double) Mathf.Round((float) (((double) num1 + 1.0) / (double) num2 * 3.0 * 3.0)) / 3.0 * 2.0 : 0.0) : (double) amount.GetValueOrDefault()) * (double) metaprogressSequence.randomizeProgress.Random();
      List<float> values = new List<float>();
      List<UnlockData> getUnlocks = new List<UnlockData>();
      float a = (float) num3;
      while (remainingUnlocks.Count > 0)
      {
        float b = townProgress.required - townProgress.current;
        float num4 = Mathf.Min(a, b);
        a -= num4;
        townProgress.current += num4;
        values.Add(townProgress.ProgressToNextUnlock());
        if (townProgress.RequirementMet())
        {
          townProgress.SetNextRequirement();
          UnlockData unlock = MetaprogressSequence.GetUnlock((IList<UnlockData>) remainingUnlocks);
          if (unlock != null)
          {
            getUnlocks.Add(unlock);
            alreadyUnlocked.Add(unlock.name);
            MetaprogressionSystem.SetUnlocksReady(unlock.name);
            Debug.Log((object) string.Format("Unlocking {0}", (object) unlock));
          }
        }
        else
          break;
      }
      SaveSystem.SaveProgressData<Progression>("townProgress", townProgress);
      SaveSystem.SaveProgressData<List<string>>("unlocked", alreadyUnlocked);
      Debug.Log((object) ("Progressing: " + string.Join<float>(", ", (IEnumerable<float>) values)));
      foreach (float num5 in values)
      {
        metaprogressSequence.targetFillAmount = num5;
        float progressToAdd = num5 - metaprogressSequence.progressImage.fillAmount;
        if ((double) progressToAdd > 0.0)
          Events.InvokeProgressStart(metaprogressSequence.progressImage.fillAmount);
        int particles = Mathf.CeilToInt(progressToAdd / 0.02f);
        if (particles > 0)
        {
          metaprogressSequence.animator.SetBool("Increasing", true);
          for (; particles > 0; --particles)
          {
            metaprogressSequence.particleSystem.Emit(1);
            yield return (object) new WaitForSeconds(Dead.Random.Range(0.02f, 0.03f));
          }
        }
        yield return (object) new WaitUntil(new Func<bool>(metaprogressSequence.\u003CSequence\u003Eb__15_0));
        metaprogressSequence.Fill(metaprogressSequence.targetFillAmount);
        metaprogressSequence.animator.SetBool("Increasing", false);
        if ((double) progressToAdd > 0.0)
          Events.InvokeProgressStop();
        if (getUnlocks.Count > 0)
        {
          Events.InvokeProgressDing();
          metaprogressSequence.Ping();
          getUnlocks.RemoveAt(0);
          yield return (object) new WaitForSeconds(1.5f);
          if (getUnlocks.Count > 0 || remainingUnlocks.Count > 0)
            metaprogressSequence.progressImage.fillAmount = 0.0f;
        }
      }
      getUnlocks = (List<UnlockData>) null;
    }
    yield return (object) new WaitForSeconds(metaprogressSequence.endDelay);
    metaprogressSequence.running = false;
  }

  public static UnlockData GetUnlock(IList<UnlockData> orderedList)
  {
    if (orderedList == null || orderedList.Count <= 0)
      return (UnlockData) null;
    List<int> list = new List<int>() { 0 };
    float lowPriority = orderedList[0].lowPriority;
    int count = orderedList.Count;
    for (int index = 1; index < count; ++index)
    {
      if ((double) orderedList[index].lowPriority <= (double) lowPriority)
        list.Add(index);
    }
    int index1 = list.RandomItem<int>();
    UnlockData ordered = orderedList[index1];
    orderedList.RemoveAt(index1);
    return ordered;
  }

  public static void RemoveIneligibleUnlocks(
    IList<UnlockData> remainingUnlocks,
    ICollection<string> alreadyUnlocked)
  {
    for (int index = remainingUnlocks.Count - 1; index >= 0; --index)
    {
      if (!MetaprogressionSystem.CheckUnlockRequirements(remainingUnlocks[index], alreadyUnlocked))
        remainingUnlocks.RemoveAt(index);
    }
  }

  public void OnParticleCollision(GameObject other)
  {
    if ((UnityEngine.Object) other != (UnityEngine.Object) this.particleSystem.gameObject)
      return;
    this.Fill((double) Math.Abs(this.progressImage.fillAmount - this.targetFillAmount) < 0.019999999552965164 ? this.targetFillAmount : this.progressImage.fillAmount + 0.02f);
    this.Blip();
    Events.InvokeProgressBlip();
  }

  public void Fill(float amount)
  {
    this.progressImage.fillAmount = amount;
    Events.InvokeProgressUpdate(amount);
  }

  public void Blip() => this.animator.SetTrigger(nameof (Blip));

  public void Ping() => this.animator.SetTrigger(nameof (Ping));

  [CompilerGenerated]
  public bool \u003CSequence\u003Eb__15_0() => !(bool) (UnityEngine.Object) this.particleSystem || this.particleSystem.particleCount <= 0;
}
﻿// Decompiled with JetBrains decompiler
// Type: MinibossDeathZoomSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class MinibossDeathZoomSystem : GameSystem
{
  [SerializeField]
  public Transform container;
  [SerializeField]
  public float zoomAmount = 4f;
  [SerializeField]
  public Image fade;
  [SerializeField]
  public Color fadeColor;
  [SerializeField]
  public Color flashColor;
  [SerializeField]
  public Image flash;
  [SerializeField]
  public AnimationCurve flashCurve;
  [SerializeField]
  public float slowmo = 0.1f;
  [SerializeField]
  public float duration = 0.3f;
  [SerializeField]
  public Vector3 limit = new Vector3(5.5f, 2.5f, 5f);
  public Entity target;
  public Transform targetPreviousParent;
  public bool pauseBlocked;
  public bool slowmoActive;

  public void OnEnable() => global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);

  public void OnDisable()
  {
    global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);
    this.UnblockPause();
    this.EndSlowmo();
  }

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    if (!(bool) (UnityEngine.Object) entity || !(bool) (UnityEngine.Object) entity.data)
      return;
    CardType cardType = entity.data.cardType;
    if (cardType == null || !cardType.miniboss || References.Battle.minibosses.Count<Entity>((Func<Entity, bool>) (a => (UnityEngine.Object) a != (UnityEngine.Object) entity && (UnityEngine.Object) a.owner == (UnityEngine.Object) entity.owner)) > 0)
      return;
    this.Run(entity);
  }

  public void Run(Entity target) => this.StartCoroutine(this.Routine(target));

  public void BlockPause()
  {
    if (this.pauseBlocked)
      return;
    this.pauseBlocked = true;
    PauseMenu.Block();
    DeckpackBlocker.Block();
    if (!Deckpack.IsOpen || !(References.Player.entity.display is CharacterDisplay display))
      return;
    display.CloseInventory();
  }

  public void UnblockPause()
  {
    if (!this.pauseBlocked)
      return;
    this.pauseBlocked = false;
    DeckpackBlocker.Unblock();
    PauseMenu.Unblock();
  }

  public void Slowmo()
  {
    if (this.slowmoActive)
      return;
    this.slowmoActive = true;
    LeanTween.value(Time.timeScale, this.slowmo, 0.05f).setEase(LeanTweenType.linear).setOnUpdate(new Action<float>(global::Events.InvokeTimeScaleChange));
  }

  public void EndSlowmo()
  {
    if (!this.slowmoActive)
      return;
    this.slowmoActive = false;
    LeanTween.value(Time.timeScale, 1f, 0.25f).setEase(LeanTweenType.linear).setOnUpdate(new Action<float>(global::Events.InvokeTimeScaleChange));
  }

  public IEnumerator Routine(Entity target)
  {
    MinibossDeathZoomSystem minibossDeathZoomSystem = this;
    minibossDeathZoomSystem.BlockPause();
    if ((bool) (UnityEngine.Object) minibossDeathZoomSystem.target)
      minibossDeathZoomSystem.target.transform.SetParent(minibossDeathZoomSystem.targetPreviousParent);
    yield return (object) null;
    minibossDeathZoomSystem.target = target;
    minibossDeathZoomSystem.targetPreviousParent = target.transform.parent;
    target.transform.SetParent(minibossDeathZoomSystem.container);
    target.ResetDrawOrder();
    HitFlashSystem.Remove(target);
    FlyOffScreen component = target.GetComponent<FlyOffScreen>();
    if ((bool) (UnityEngine.Object) component)
    {
      component.velocity.z = 0.0f;
      component.velocity = component.velocity.normalized * 20f;
      component.velocity.z = -3f;
    }
    ScreenFlashSystem.SetDrawOrder("Inspect", 1);
    ScreenFlashSystem.SetColour(minibossDeathZoomSystem.flashColor);
    ScreenFlashSystem.Run(0.1f);
    minibossDeathZoomSystem.Slowmo();
    LeanTween.value(minibossDeathZoomSystem.gameObject, minibossDeathZoomSystem.fade.color.a, minibossDeathZoomSystem.fadeColor.a, minibossDeathZoomSystem.duration).setEase(LeanTweenType.easeInOutQuint).setOnUpdate(new Action<float>(minibossDeathZoomSystem.\u003CRoutine\u003Eb__22_0));
    Vector3 to = (target.transform.position.WithZ(minibossDeathZoomSystem.zoomAmount) - References.MinibossCameraMover.position).Clamp(-minibossDeathZoomSystem.limit, minibossDeathZoomSystem.limit);
    LeanTween.cancel(References.MinibossCameraMover.gameObject);
    LeanTween.moveLocal(References.MinibossCameraMover.gameObject, to, Mathf.Min(minibossDeathZoomSystem.duration, 0.4f)).setEase(LeanTweenType.easeOutBack);
    yield return (object) Sequences.Wait(minibossDeathZoomSystem.duration);
    minibossDeathZoomSystem.EndSlowmo();
    LeanTween.moveLocal(References.MinibossCameraMover.gameObject, Vector3.zero, 1f).setEase(LeanTweenType.easeOutBack);
    LeanTween.value(minibossDeathZoomSystem.gameObject, minibossDeathZoomSystem.fade.color.a, 0.0f, 0.25f).setEase(LeanTweenType.easeInOutQuart).setOnUpdate(new Action<float>(minibossDeathZoomSystem.\u003CRoutine\u003Eb__22_1));
    yield return (object) Sequences.Wait(1f);
    if ((bool) (UnityEngine.Object) minibossDeathZoomSystem.target)
      minibossDeathZoomSystem.target.transform.SetParent(minibossDeathZoomSystem.targetPreviousParent);
    minibossDeathZoomSystem.target = (Entity) null;
    minibossDeathZoomSystem.UnblockPause();
  }

  [CompilerGenerated]
  public void \u003CRoutine\u003Eb__22_0(float a) => this.fade.color = this.fade.color.With(alpha: a);

  [CompilerGenerated]
  public void \u003CRoutine\u003Eb__22_1(float a) => this.fade.color = this.fade.color.With(alpha: a);
}
﻿// Decompiled with JetBrains decompiler
// Type: MinibossIntroSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class MinibossIntroSystem : GameSystem
{
  [SerializeField]
  public Transform container;
  [Header("Focus")]
  [SerializeField]
  public float focusAmount = 0.75f;
  [SerializeField]
  public float zoomAmount = 3f;
  [SerializeField]
  public CurveProfile focusTween;
  [SerializeField]
  public CurveProfile unfocusTween;
  [Header("Fade")]
  [SerializeField]
  public Image fade;
  [SerializeField]
  public Color fadeColor;
  [Header("Move miniboss to position")]
  [SerializeField]
  public Vector3 move = new Vector3(0.0f, 0.0f, -1f);
  [SerializeField]
  public CurveProfile moveTween;
  [SerializeField]
  public CurveProfile returnTween;
  [Header("Pauses before/after miniboss animation")]
  [SerializeField]
  public float pauseBefore = 0.33f;
  [SerializeField]
  public float pauseAfter = 1f;
  [Header("Delays")]
  [SerializeField]
  public float delayBefore = 0.2f;
  [SerializeField]
  public float delayAfter = 0.2f;
  [Header("Miniboss animations")]
  [SerializeField]
  public CardAnimation defaultAnimation;
  [SerializeField]
  public MinibossIntroSystem.MinibossAnimation[] specificAnimations;
  [Header("SFX")]
  [SerializeField]
  public EventReference zoomSfx;
  [SerializeField]
  public EventReference shakeSfx;
  public readonly List<Entity> ignore = new List<Entity>();
  public Dictionary<string, CardAnimation> animationLookup;
  public Entity target;
  public Transform targetPreviousParent;
  public global::Routine routine;
  public bool hasRun;

  public void OnEnable()
  {
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnEntityMove += new UnityAction<Entity>(this.EntityMove);
    this.animationLookup = new Dictionary<string, CardAnimation>();
    foreach (MinibossIntroSystem.MinibossAnimation specificAnimation in this.specificAnimations)
      this.animationLookup[specificAnimation.cardData.name] = specificAnimation.animation;
  }

  public void OnDisable()
  {
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnEntityMove -= new UnityAction<Entity>(this.EntityMove);
    this.StopAllCoroutines();
    this.routine?.Stop();
    if (!(bool) (UnityEngine.Object) References.MinibossCameraMover)
      return;
    LeanTween.cancel(References.MinibossCameraMover.gameObject);
    References.MinibossCameraMover.localPosition = Vector3.zero;
  }

  public void Ignore(Entity entity) => this.ignore.Add(entity);

  public void SceneChanged(Scene scene)
  {
    this.ignore.Clear();
    this.hasRun = false;
  }

  public void EntityMove(Entity entity)
  {
    if (this.hasRun || this.ignore.Contains(entity))
      return;
    CardType cardType = entity.data.cardType;
    if (cardType == null || !cardType.miniboss || !((UnityEngine.Object) entity.owner == (UnityEngine.Object) Battle.instance.enemy) || !Battle.IsOnBoard(entity) || Battle.IsOnBoard(entity.preContainers))
      return;
    this.Activate(entity);
    this.hasRun = true;
  }

  public void Activate(Entity target)
  {
    this.ignore.Add(target);
    this.routine = new global::Routine(this.Routine(target));
    ActionQueue.Stack((PlayAction) new ActionSequence(this.WaitForRoutineToEnd()));
  }

  public IEnumerator WaitForRoutineToEnd()
  {
    while (this.routine.IsRunning)
      yield return (object) null;
  }

  public void Assign(Entity target)
  {
    this.UnAssign();
    this.target = target;
    this.targetPreviousParent = target.transform.parent;
    target.transform.SetParent(this.container, true);
    target.ResetDrawOrder();
  }

  public void UnAssign()
  {
    if ((bool) (UnityEngine.Object) this.target)
      this.target.transform.SetParent(this.targetPreviousParent);
    this.target = (Entity) null;
  }

  public IEnumerator Routine(Entity target)
  {
    MinibossIntroSystem minibossIntroSystem = this;
    global::Events.InvokeSetWeatherIntensity(1f, 1f);
    minibossIntroSystem.Assign(target);
    LeanTween.value(minibossIntroSystem.gameObject, minibossIntroSystem.fade.color.a, minibossIntroSystem.fadeColor.a, minibossIntroSystem.focusTween.duration).setEase(LeanTweenType.easeInOutQuart).setOnUpdate((Action<float>) (a => this.fade.color = this.fade.color.With(alpha: a)));
    target.flipper?.FlipUpInstant();
    CinemaBarSystem.SetSortingLayer("Inspect", 1);
    CinemaBarSystem.In();
    LeanTween.cancel(target.gameObject);
    yield return (object) Sequences.Wait(minibossIntroSystem.delayBefore);
    global::Events.InvokeMinibossIntro(target);
    LeanTween.moveLocal(target.gameObject, Vector3.zero, minibossIntroSystem.moveTween.duration).setEase(minibossIntroSystem.moveTween.curve);
    yield return (object) Sequences.Wait(minibossIntroSystem.pauseBefore);
    PauseMenu.Block();
    Vector3 originalCameraPos = Vector3.zero;
    Vector3 to = Vector3.Lerp(originalCameraPos, minibossIntroSystem.container.position, minibossIntroSystem.focusAmount).WithZ(minibossIntroSystem.zoomAmount);
    LeanTween.cancel(References.MinibossCameraMover.gameObject);
    LeanTween.move(References.MinibossCameraMover.gameObject, to, minibossIntroSystem.focusTween.duration).setEase(minibossIntroSystem.focusTween.curve);
    SfxSystem.OneShot(minibossIntroSystem.zoomSfx);
    CardAnimation valueOrDefault = minibossIntroSystem.animationLookup.GetValueOrDefault<string, CardAnimation>(target.name, minibossIntroSystem.defaultAnimation);
    SfxSystem.OneShot(minibossIntroSystem.shakeSfx);
    yield return (object) valueOrDefault.Routine((object) target);
    yield return (object) Sequences.Wait(minibossIntroSystem.pauseAfter);
    CardContainer actualContainer = target.actualContainers[0];
    Vector3 containerScale = target.GetContainerScale();
    Vector3 containerWorldRotation = target.GetContainerWorldRotation();
    Vector3 containerWorldPosition = target.GetContainerWorldPosition();
    LeanTween.cancel(target.gameObject);
    LeanTween.scale(target.gameObject, containerScale, minibossIntroSystem.returnTween.duration).setEase(minibossIntroSystem.returnTween.curve);
    LeanTween.rotate(target.gameObject, containerWorldRotation, minibossIntroSystem.returnTween.duration).setEase(minibossIntroSystem.returnTween.curve);
    LeanTween.move(target.gameObject, containerWorldPosition, minibossIntroSystem.returnTween.duration).setEase(minibossIntroSystem.returnTween.curve).setOnComplete((System.Action) (() => target.wobbler?.WobbleRandom()));
    LeanTween.moveLocal(References.MinibossCameraMover.gameObject, originalCameraPos, minibossIntroSystem.unfocusTween.duration).setEase(LeanTweenType.easeInOutBack);
    LeanTween.value(minibossIntroSystem.gameObject, minibossIntroSystem.fade.color.a, 0.0f, minibossIntroSystem.unfocusTween.duration).setEase(minibossIntroSystem.unfocusTween.curve).setOnUpdate((Action<float>) (a => this.fade.color = this.fade.color.With(alpha: a)));
    CinemaBarSystem.Out();
    global::Events.InvokeSetWeatherIntensity(0.25f, 3f);
    global::Events.InvokeMinibossIntroDone(target);
    yield return (object) Sequences.Wait(minibossIntroSystem.unfocusTween.duration);
    minibossIntroSystem.UnAssign();
    PauseMenu.Unblock();
    yield return (object) Sequences.Wait(minibossIntroSystem.delayAfter);
  }

  [Serializable]
  public struct MinibossAnimation
  {
    public CardData cardData;
    public CardAnimation animation;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MissingCardSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public static class MissingCardSystem
{
  public static CardData Get() => AddressableLoader.Get<CardData>("CardData", "MissingCard");

  public static CardData GetClone(string cardDataName, bool runCreateScripts = true)
  {
    CardData cardData = MissingCardSystem.Get();
    if (!(bool) (UnityEngine.Object) cardData)
      return (CardData) null;
    CardData clone = cardData.Clone(runCreateScripts);
    clone.forceTitle = "Missing Card " + cardDataName;
    return clone;
  }

  public static CardData GetCloneWithId(
    string cardDataName,
    Vector3 random3,
    ulong id,
    bool runCreateScripts = true)
  {
    CardData cardData = MissingCardSystem.Get();
    if (!(bool) (UnityEngine.Object) cardData)
      return (CardData) null;
    CardData cloneWithId = cardData.Clone(random3, id, runCreateScripts);
    cloneWithId.forceTitle = "Missing Card " + cardDataName;
    return cloneWithId;
  }

  public static bool IsMissing(CardData cardData) => MissingCardSystem.IsMissing(cardData.name);

  public static bool IsMissing(CardSaveData cardSaveData) => MissingCardSystem.IsMissing(cardSaveData.name);

  public static bool IsMissing(string cardDataName)
  {
    CardData cardData = AddressableLoader.Get<CardData>("CardData", cardDataName);
    return !(bool) (UnityEngine.Object) cardData || cardData.name == "MissingCard";
  }

  public static bool HasMissingData(IEnumerable<string> cardDataNames)
  {
    foreach (string cardDataName in cardDataNames)
    {
      if (MissingCardSystem.IsMissing(cardDataName))
        return true;
    }
    return false;
  }

  public static bool HasMissingData(CardSaveData[] cardSaveDatas) => MissingCardSystem.HasMissingData((IEnumerable<CardData>) cardSaveDatas.LoadList<CardData, CardSaveData>());

  public static bool HasMissingData(IEnumerable<CardData> cardDataList) => cardDataList.Any<CardData>((Func<CardData, bool>) (a => MissingCardSystem.IsMissing(a.name)));
}
﻿// Decompiled with JetBrains decompiler
// Type: ModHolder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Deadpan.Enums.Engine.Components.Modding;
using System.Diagnostics;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ModHolder : MonoBehaviour
{
  public WildfrostMod Mod;
  public TextMeshProUGUI Title;
  public TextMeshProUGUI Description;
  public Image Icon;
  public GameObject PublishButton;
  public ToggleSprite[] toggleSprites;
  public BellRinger bellRinger;
  public bool DrawingUpload;

  public void OnEnable()
  {
    global::Events.OnModLoaded += new UnityAction<WildfrostMod>(this.ModToggled);
    global::Events.OnModUnloaded += new UnityAction<WildfrostMod>(this.ModToggled);
  }

  public void OnDisable()
  {
    global::Events.OnModLoaded -= new UnityAction<WildfrostMod>(this.ModToggled);
    global::Events.OnModUnloaded -= new UnityAction<WildfrostMod>(this.ModToggled);
  }

  public void ModToggled(WildfrostMod mod)
  {
    if (mod.GUID != this.Mod.GUID)
      return;
    this.UpdateSprites();
  }

  public void ToggleMod()
  {
    this.Mod.ModToggle();
    if (!this.Mod.HasLoaded)
      return;
    this.bellRinger.Ring();
  }

  public void OnGUI()
  {
    if (!this.DrawingUpload)
      return;
    if (GUILayout.Button("Confirm publish for " + this.Mod.GUID))
    {
      this.Mod.UpdateOrPublishWorkshop();
      this.DrawingUpload = false;
    }
    else
    {
      if (!GUILayout.Button("Cancel publish for " + this.Mod.GUID))
        return;
      this.DrawingUpload = false;
    }
  }

  public void PublishMod() => this.DrawingUpload = true;

  public void OpenModDirectory() => Process.Start(this.Mod.ModDirectory);

  public void UpdateInfo()
  {
    this.Title.text = this.Mod.Title;
    this.Description.text = this.Mod.Description;
    this.Icon.sprite = this.Mod.IconSprite;
    this.PublishButton.SetActive(this.Mod.ModDirectory.Contains(Application.streamingAssetsPath));
    this.UpdateSprites();
  }

  public void UpdateSprites()
  {
    foreach (ToggleSprite toggleSprite in this.toggleSprites)
      toggleSprite.Set(this.Mod.HasLoaded);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ModifierDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

public class ModifierDisplay : MonoBehaviour
{
  [SerializeField]
  public ModifierIcon iconPrefab;
  [SerializeField]
  public ModifierIconMultiple stormLevelIconPrefab;
  [SerializeField]
  public Vector2 popUpOffset;
  public readonly List<ModifierIcon> icons = new List<ModifierIcon>();
  [CompilerGenerated]
  public int \u003CmodifierCount\u003Ek__BackingField;
  public ModifierIconMultiple stormLevelIcon;

  public int modifierCount
  {
    get => this.\u003CmodifierCount\u003Ek__BackingField;
    set => this.\u003CmodifierCount\u003Ek__BackingField = value;
  }

  public ModifierIcon CreateIcon(GameModifierData data, bool combineStormBells = true)
  {
    if (combineStormBells && (bool) (Object) data.linkedStormBell && (bool) (Object) this.stormLevelIconPrefab)
      return this.AddToStormLevelIcon(data);
    ++this.modifierCount;
    if (!data.visible)
      return (ModifierIcon) null;
    ModifierIcon icon = Object.Instantiate<ModifierIcon>(this.iconPrefab, this.transform);
    icon.Set(data, this.popUpOffset);
    this.icons.Add(icon);
    return icon;
  }

  public void ClearIcons()
  {
    for (int index = this.icons.Count - 1; index >= 0; --index)
    {
      ModifierIcon icon = this.icons[index];
      if ((bool) (Object) icon)
        icon.gameObject.Destroy();
    }
    this.modifierCount = 0;
    this.stormLevelIcon = (ModifierIconMultiple) null;
  }

  public ModifierIcon AddToStormLevelIcon(GameModifierData modifier)
  {
    if (!(bool) (Object) this.stormLevelIcon)
    {
      this.CreateStormLevelIcon(modifier);
    }
    else
    {
      ++this.modifierCount;
      this.stormLevelIcon.Add(modifier);
    }
    return (ModifierIcon) this.stormLevelIcon;
  }

  public ModifierIcon CreateStormLevelIcon(GameModifierData firstModifier)
  {
    ++this.modifierCount;
    this.stormLevelIcon = Object.Instantiate<ModifierIconMultiple>(this.stormLevelIconPrefab, this.transform);
    this.stormLevelIcon.Set(firstModifier, this.popUpOffset);
    this.icons.Add((ModifierIcon) this.stormLevelIcon);
    return (ModifierIcon) this.stormLevelIcon;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ModifierDisplayCurrent
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class ModifierDisplayCurrent : ModifierDisplay
{
  [SerializeField]
  public GameObject navController;

  public void OnEnable() => this.CreateIcons();

  public void CreateIcons()
  {
    if (!(bool) (Object) this)
      return;
    this.ClearIcons();
    bool mainGameMode = Campaign.Data.GameMode.mainGameMode;
    CampaignData data1 = Campaign.Data;
    if (data1 != null)
    {
      List<GameModifierData> modifiers = data1.Modifiers;
      if (modifiers != null)
      {
        foreach (GameModifierData data2 in modifiers)
          this.CreateIcon(data2, mainGameMode);
      }
    }
    if (!(bool) (Object) this.navController)
      return;
    this.navController.SetActive(this.modifierCount > 0);
  }

  public void Update()
  {
    CampaignData data = Campaign.Data;
    int num;
    if (data != null)
    {
      List<GameModifierData> modifiers = data.Modifiers;
      if (modifiers != null)
      {
        num = modifiers.Count;
        goto label_4;
      }
    }
    num = 0;
label_4:
    int modifierCount = this.modifierCount;
    if (num == modifierCount)
      return;
    this.CreateIcons();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ModifierIcon
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.UI;

public class ModifierIcon : MonoBehaviourRect
{
  [SerializeField]
  public LayoutElement layoutElement;
  [SerializeField]
  public RectTransform bellHolder;
  public ImageSprite bellImage;
  [SerializeField]
  public ImageSprite dingerImage;
  [SerializeField]
  public GameObject activeIcon;
  [SerializeField]
  public GameObject inactiveIcon;
  [SerializeField]
  public TweenUI[] dingTweens;
  public bool playDingSfx = true;
  public string title;
  public string body;
  [SerializeField]
  public GameModifierData modifier;
  public string popUpName;
  [SerializeField]
  public bool dontPop;
  public bool poppedUp;
  public Vector2 popUpOffset;

  public virtual void Set(GameModifierData modifier, Vector2 popUpOffset)
  {
    this.modifier = modifier;
    this.popUpOffset = popUpOffset;
    if ((bool) (Object) this.dingerImage)
      this.dingerImage.SetSprite(this.modifier.dingerSprite);
    if ((bool) (Object) this.bellImage)
    {
      this.bellImage.SetSprite(modifier.bellSprite);
      float y = (float) (((double) Mathf.Max(1f, this.bellImage.rectTransform.sizeDelta.y) - 1.0) * 0.5);
      this.bellHolder.anchoredPosition = new Vector2(0.0f, y);
      if ((bool) (Object) this.layoutElement)
        this.layoutElement.preferredHeight = 1f + y;
    }
    this.popUpName = modifier.name;
    this.title = modifier.titleKey.GetLocalizedString();
    this.body = modifier.descriptionKey.GetLocalizedString();
  }

  public void SetText(string title, string body)
  {
    this.title = title;
    this.body = body;
  }

  public void AddText(string toBody) => this.body += toBody;

  public virtual void Pop()
  {
    if (this.dontPop || this.poppedUp)
      return;
    CardPopUp.AssignTo(this.rectTransform, this.popUpOffset.x, this.popUpOffset.y);
    CardPopUp.AddPanel(this.popUpName, this.title, this.body);
    this.poppedUp = true;
  }

  public virtual void UnPop()
  {
    if (this.dontPop || !this.poppedUp)
      return;
    CardPopUp.RemovePanel(this.popUpName);
    this.poppedUp = false;
  }

  public void OnDisable() => this.UnPop();

  [Button(null, EButtonEnableMode.Always)]
  public void Ding()
  {
    foreach (TweenUI dingTween in this.dingTweens)
      dingTween.Fire();
    if (!this.playDingSfx)
      return;
    this.modifier.PlayRingSfx();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ModifierIconMultiple
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using TMPro;
using UnityEngine;

public class ModifierIconMultiple : ModifierIcon
{
  [SerializeField]
  public TMP_Text stormLevelText;
  [SerializeField]
  public Transform juiceLevel;
  [SerializeField]
  public Vector2 juiceLevelRange = new Vector2(-0.9f, 0.0f);
  public readonly List<GameModifierData> modifiers = new List<GameModifierData>();
  public int _stormLevel;

  public int stormLevel
  {
    get => this._stormLevel;
    set
    {
      this._stormLevel = value;
      if ((bool) (Object) this.stormLevelText)
        this.stormLevelText.text = this._stormLevel.ToString();
      if (!(bool) (Object) this.juiceLevel)
        return;
      this.juiceLevel.transform.localPosition = this.juiceLevel.transform.localPosition.WithY(Mathf.Lerp(this.juiceLevelRange.x, this.juiceLevelRange.y, Mathf.Clamp((float) this._stormLevel / 10f, 0.0f, 1f)));
    }
  }

  public override void Set(GameModifierData modifier, Vector2 popUpOffset)
  {
    base.Set(modifier, popUpOffset);
    this.modifiers.Add(modifier);
    if ((bool) (Object) modifier.linkedStormBell)
      this.stormLevel = modifier.linkedStormBell.stormPoints;
    else
      this.stormLevel = 0;
  }

  public void Add(GameModifierData modifier)
  {
    this.modifiers.Add(modifier);
    if (!(bool) (Object) modifier.linkedStormBell)
      return;
    this.stormLevel += modifier.linkedStormBell.stormPoints;
  }

  public void Clear()
  {
    this.stormLevel = 0;
    this.modifiers.Clear();
  }

  public override void Pop()
  {
    if (this.poppedUp)
      return;
    CardPopUp.AssignTo(this.rectTransform, this.popUpOffset.x, this.popUpOffset.y);
    foreach (GameModifierData modifier in this.modifiers)
      CardPopUp.AddPanel(modifier.name, modifier.titleKey.GetLocalizedString(), modifier.descriptionKey.GetLocalizedString());
    this.poppedUp = true;
  }

  public override void UnPop()
  {
    if (!this.poppedUp)
      return;
    foreach (Object modifier in this.modifiers)
      CardPopUp.RemovePanel(modifier.name);
    this.poppedUp = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ModifierIconSpecialBorder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class ModifierIconSpecialBorder : MonoBehaviour
{
  [SerializeField]
  public Image border;
  [SerializeField]
  public Sprite specialBorder;

  public void SetSpecialBorder() => this.border.sprite = this.specialBorder;
}
﻿// Decompiled with JetBrains decompiler
// Type: ModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Events;

public class ModifierSystem : GameSystem
{
  public void OnEnable()
  {
    global::Events.OnCampaignInit += new global::Events.RoutineAction(ModifierSystem.RunInitScripts);
    global::Events.OnCampaignStart += new UnityAction(ModifierSystem.AddSystems);
    global::Events.OnCampaignLoaded += new UnityAction(ModifierSystem.AddSystems);
    global::Events.OnCampaignGenerated += new global::Events.AsyncAction(this.RunStartScripts);
  }

  public void OnDisable()
  {
    global::Events.OnCampaignInit -= new global::Events.RoutineAction(ModifierSystem.RunInitScripts);
    global::Events.OnCampaignStart -= new UnityAction(ModifierSystem.AddSystems);
    global::Events.OnCampaignLoaded -= new UnityAction(ModifierSystem.AddSystems);
    global::Events.OnCampaignGenerated -= new global::Events.AsyncAction(this.RunStartScripts);
  }

  public static void AddModifier(CampaignData data, GameModifierData modifier)
  {
    CampaignData campaignData = data;
    if (campaignData.Modifiers == null)
    {
      List<GameModifierData> gameModifierDataList;
      campaignData.Modifiers = gameModifierDataList = new List<GameModifierData>();
    }
    data.Modifiers.Add(modifier);
  }

  public static void RemoveModifier(CampaignData data, GameModifierData modifier) => data.Modifiers?.Remove(modifier);

  public static void AddSystems()
  {
    if (Campaign.Data.Modifiers == null)
      return;
    foreach (GameModifierData gameModifierData in (IEnumerable<GameModifierData>) Campaign.Data.Modifiers.OrderByDescending<GameModifierData, int>((Func<GameModifierData, int>) (m => m.scriptPriority)))
    {
      foreach (string str in gameModifierData.systemsToAdd)
      {
        if (Campaign.instance.systems.GetComponent(str) is GameSystem component)
        {
          Debug.Log((object) string.Format("[{0}] enabling system: {1}", (object) gameModifierData, (object) component));
          component.enabled = true;
        }
        else
        {
          Debug.Log((object) string.Format("[{0}] adding system: {1}", (object) gameModifierData, (object) str));
          Campaign.instance.systems.AddComponentByName(str);
        }
      }
    }
  }

  public static IEnumerator RunInitScripts() => ModifierSystem.RunInitScripts((IReadOnlyCollection<GameModifierData>) Campaign.Data.Modifiers);

  public async Task RunStartScripts()
  {
    ModifierSystem modifierSystem = this;
    Routine routine = new Routine(ModifierSystem.RunCampaignStartScripts((IReadOnlyCollection<GameModifierData>) Campaign.Data.Modifiers));
    while (routine.IsRunning)
    {
      if ((bool) (UnityEngine.Object) modifierSystem)
      {
        await Task.Delay(5);
      }
      else
      {
        routine = (Routine) null;
        return;
      }
    }
    routine = (Routine) null;
  }

  public static IEnumerator RunInitScripts(IReadOnlyCollection<GameModifierData> modifiers)
  {
    if (modifiers != null)
    {
      Debug.Log((object) string.Format("Running [{0}] Modifier Set Up Scripts", (object) modifiers.Count));
      foreach (GameModifierData gameModifierData in (IEnumerable<GameModifierData>) modifiers.OrderByDescending<GameModifierData, int>((Func<GameModifierData, int>) (m => m.scriptPriority)))
      {
        Debug.Log((object) string.Format("Running [{0}] Setup Scripts", (object) gameModifierData));
        Script[] scriptArray = gameModifierData.setupScripts;
        for (int index = 0; index < scriptArray.Length; ++index)
          yield return (object) scriptArray[index].Run();
        scriptArray = (Script[]) null;
      }
    }
  }

  public static IEnumerator RunCampaignStartScripts(IReadOnlyCollection<GameModifierData> modifiers)
  {
    if (modifiers != null)
    {
      Debug.Log((object) string.Format("Running [{0}] Modifier Campaign Start Scripts", (object) modifiers.Count));
      foreach (GameModifierData gameModifierData in (IEnumerable<GameModifierData>) modifiers.OrderByDescending<GameModifierData, int>((Func<GameModifierData, int>) (m => m.scriptPriority)))
      {
        Debug.Log((object) string.Format("Running [{0}] Campaign Start Scripts", (object) gameModifierData));
        Script[] scriptArray = gameModifierData.startScripts;
        for (int index = 0; index < scriptArray.Length; ++index)
          yield return (object) scriptArray[index].Run();
        scriptArray = (Script[]) null;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ModifierToggle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;

public class ModifierToggle : MonoBehaviour
{
  [SerializeField]
  public bool active = true;
  public bool canToggle = true;
  [SerializeField]
  [HideIf("canToggle")]
  public bool stillRing;
  public UnityEvent onToggle;
  [SerializeField]
  public UnityEngine.Animator animator;

  public bool IsActive => this.active;

  public void OnEnable() => this.UpdateAnimator();

  public void UpdateAnimator()
  {
    if (!(bool) (Object) this.animator || !this.animator.isActiveAndEnabled)
      return;
    this.animator.SetBool("Active", this.active);
    this.animator.SetBool("CanToggle", this.canToggle);
  }

  public void Toggle()
  {
    if (this.canToggle)
    {
      this.SetActive(!this.active);
      this.onToggle?.Invoke();
    }
    else
    {
      if (!this.stillRing)
        return;
      this.GetComponent<ModifierIcon>()?.Ding();
    }
  }

  public void SetActive(bool value)
  {
    this.active = value;
    this.UpdateArt();
  }

  public void UpdateArt()
  {
    if (this.active)
      this.GetComponent<ModifierIcon>()?.Ding();
    this.UpdateAnimator();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ModifierUnlockSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public class ModifierUnlockSystem : GameSystem
{
  [SerializeField]
  public ModifierUnlockSystem.Requirement[] requirements;

  [Serializable]
  public struct Requirement
  {
    public string[] requiresModifiers;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ModifyCardSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Localization;

public class ModifyCardSequence : MonoBehaviour
{
  [SerializeField]
  public CardContainer cardContainer;
  [SerializeField]
  public LocalizedString titleStringRef;
  [SerializeField]
  public LocalizedString continueStringRef;
  [SerializeField]
  public TweenUI endTween;
  public bool canEnd;
  public bool end;

  public IEnumerator Run(CardData cardToModify, CardScript modifyScript)
  {
    ModifyCardSequence modifyCardSequence = this;
    int hp = cardToModify.hp;
    modifyScript.Run(cardToModify);
    int healthLost = hp - cardToModify.hp;
    Events.InvokeScreenRumble(0.0f, 0.2f, 0.0f, 0.25f, 0.25f, 0.1f);
    Card card = CardManager.Get(cardToModify, (CardController) null, References.Player, false, true);
    card.entity.flipper.FlipDownInstant();
    modifyCardSequence.cardContainer.Add(card.entity);
    yield return (object) card.UpdateData(false);
    card.transform.localPosition = Vector3.down;
    card.entity.wobbler.WobbleRandom();
    modifyCardSequence.cardContainer.TweenChildPositions();
    CinemaBarSystem.In();
    CinemaBarSystem.Top.SetScript(modifyCardSequence.titleStringRef.GetLocalizedString().Format((object) cardToModify.title, (object) healthLost));
    CinemaBarSystem.Bottom.SetPrompt(modifyCardSequence.continueStringRef.GetLocalizedString(), "Select");
    yield return (object) new WaitForSeconds(0.2f);
    card.entity.flipper.FlipUp();
    modifyCardSequence.canEnd = true;
    yield return (object) new WaitUntil(new Func<bool>(modifyCardSequence.\u003CRun\u003Eb__6_0));
    CinemaBarSystem.Clear();
    if ((bool) (UnityEngine.Object) modifyCardSequence.endTween)
    {
      modifyCardSequence.endTween.Fire();
      yield return (object) new WaitForSeconds(modifyCardSequence.endTween.GetDuration());
    }
  }

  public void Continue()
  {
    if (!this.canEnd)
      return;
    this.end = true;
  }

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__6_0() => this.end;
}
﻿// Decompiled with JetBrains decompiler
// Type: MonoBehaviourCacheTransform
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class MonoBehaviourCacheTransform : MonoBehaviour
{
  public Transform _transform;

  public new Transform transform => this._transform ?? (this._transform = this.GetComponent<Transform>());
}
﻿// Decompiled with JetBrains decompiler
// Type: MonoBehaviourRect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class MonoBehaviourRect : MonoBehaviour
{
  public RectTransform _rectTransform;

  public RectTransform rectTransform => this._rectTransform ?? (this._rectTransform = (RectTransform) this.transform);
}
﻿// Decompiled with JetBrains decompiler
// Type: MonoBehaviourRectSingleton`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class MonoBehaviourRectSingleton<T> : MonoBehaviour where T : MonoBehaviour
{
  public static T _instance;
  public RectTransform _rectTransform;

  public static T instance
  {
    get
    {
      if ((Object) MonoBehaviourRectSingleton<T>._instance == (Object) null)
        MonoBehaviourRectSingleton<T>._instance = Object.FindObjectOfType<T>();
      return MonoBehaviourRectSingleton<T>._instance;
    }
  }

  public RectTransform rectTransform
  {
    get
    {
      if ((Object) this._rectTransform == (Object) null)
        this._rectTransform = (RectTransform) this.transform;
      return this._rectTransform;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MonoBehaviourSingleton`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Runtime.CompilerServices;
using UnityEngine;

public class MonoBehaviourSingleton<T> : MonoBehaviour where T : MonoBehaviour
{
  [CompilerGenerated]
  public static T \u003Cinstance\u003Ek__BackingField;

  public static T instance
  {
    get => MonoBehaviourSingleton<T>.\u003Cinstance\u003Ek__BackingField;
    set => MonoBehaviourSingleton<T>.\u003Cinstance\u003Ek__BackingField = value;
  }

  public virtual void Awake()
  {
    MonoBehaviourSingleton<T>.instance = this as T;
    Debug.Log((object) string.Format("Singleton<{0}> Created", (object) typeof (T)));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MoreCardRewardsModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class MoreCardRewardsModifierSystem : MonoBehaviour
{
  public const int toAdd = 1;
  public readonly List<int> tiersToAddTo = new List<int>();

  public void OnEnable()
  {
    Events.OnPullRewards += new Events.UnityActionRef<object, string, int, List<DataFile>>(this.PullRewards);
    this.tiersToAddTo.Clear();
    List<int> list = new List<int>() { 0, 1, 2, 3, 4 };
    Random.State state = Random.state;
    Random.InitState(Campaign.Data.Seed);
    for (int index = 0; index < 2 && list.Count > 0; ++index)
      this.tiersToAddTo.Add(list.TakeRandom<int>());
    Random.state = state;
    Debug.Log((object) ("MoreCardRewardsModifierSystem → tiers to add to: [" + string.Join<int>(", ", (IEnumerable<int>) this.tiersToAddTo) + "]"));
  }

  public void OnDisable() => Events.OnPullRewards -= new Events.UnityActionRef<object, string, int, List<DataFile>>(this.PullRewards);

  public void PullRewards(
    object pulledBy,
    ref string poolName,
    ref int itemCount,
    ref List<DataFile> result)
  {
    if (!(pulledBy is CampaignNode campaignNode) || !this.tiersToAddTo.Contains(campaignNode.tier) || !(campaignNode.type is CampaignNodeTypeItem))
      return;
    ++itemCount;
    Debug.Log((object) string.Format("MoreCardRewardsModifierSystem → adding +{0} to Reward Pool \"{1}\" Pull ({2} node index: {3})", (object) 1, (object) poolName, (object) campaignNode.type.name, (object) campaignNode.id));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MouseInputSwitcher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class MouseInputSwitcher : BaseInputSwitcher
{
  public override bool CheckSwitchTo() => this.canSwitchTo && Input.GetMouseButtonDown(0);

  public override void SwitchTo()
  {
    this.gameObject.SetActive(true);
    MonoBehaviourSingleton<Cursor3d>.instance.usingMouse = true;
    MonoBehaviourSingleton<Cursor3d>.instance.usingTouch = false;
    VirtualPointer.Hide();
    CustomCursor.UpdateState();
    MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem((UINavigationItem) null);
    ControllerButtonSystem.SetMouseStyle();
    InputSystem.mainPlayer.controllers.Mouse.enabled = true;
    InputSystem.AllowDynamicSelectRelease = true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Mover
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class Mover : MonoBehaviour
{
  public Vector3 velocity;
  public float frictMult = 0.9f;
  public bool removeWhenStopped = true;
  public bool removeWhenDisabled = true;

  public void Update()
  {
    if (this.removeWhenStopped && (double) this.velocity.sqrMagnitude <= 0.0099999997764825821)
    {
      Object.Destroy((Object) this);
    }
    else
    {
      this.transform.position += this.velocity * Time.deltaTime;
      this.velocity = Delta.Multiply(this.velocity, this.frictMult, Time.deltaTime);
    }
  }

  public void OnDisable()
  {
    if (!this.removeWhenDisabled)
      return;
    Object.Destroy((Object) this);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: MusicSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMOD;
using FMOD.Studio;
using FMODUnity;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class MusicSystem : GameSystem
{
  public static MusicSystem instance;
  public MusicSystem.Music[] music;
  public MusicSystem.Music[] eventMusic;
  public static EventInstance current;
  public static LTDescr fadePitchTween;
  public static float pitch = 1f;

  public void OnEnable()
  {
    MusicSystem.instance = this;
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
  }

  public void OnDisable()
  {
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    MusicSystem.StopMusic();
  }

  public void SceneChanged(Scene from, Scene to) => this.SceneChanged(to);

  public void SceneChanged(Scene scene)
  {
    MusicSystem.StopMusic();
    MusicSystem.Music music = ((IEnumerable<MusicSystem.Music>) this.music).FirstOrDefault<MusicSystem.Music>((Func<MusicSystem.Music, bool>) (a => a.sceneName == scene.name));
    if (music == null)
      return;
    MusicSystem.StartMusic(music.eventId.Guid);
  }

  public static void StartMusic(EventReference eventId) => MusicSystem.StartMusic(eventId.Guid);

  public static void StartMusic(GUID eventGUID)
  {
    try
    {
      MusicSystem.current = RuntimeManager.CreateInstance(eventGUID);
      int num = (int) MusicSystem.current.start();
    }
    catch (EventNotFoundException ex)
    {
      UnityEngine.Debug.LogWarning((object) ex);
    }
  }

  public static void SetParam(string name, float value)
  {
    if (!MusicSystem.IsRunning(MusicSystem.current))
      return;
    int num = (int) MusicSystem.current.setParameterByName(name, value);
  }

  public static void StopMusic(FMOD.Studio.STOP_MODE stopMode = FMOD.Studio.STOP_MODE.ALLOWFADEOUT)
  {
    if (!MusicSystem.IsRunning(MusicSystem.current))
      return;
    int num1 = (int) MusicSystem.current.stop(stopMode);
    int num2 = (int) MusicSystem.current.release();
  }

  public static void FadePitchTo(float value, float time) => MusicSystem.fadePitchTween = LeanTween.value(MusicSystem.instance.gameObject, MusicSystem.pitch, value, time).setOnUpdate((Action<float>) (a =>
  {
    MusicSystem.pitch = a;
    if (!MusicSystem.IsRunning(MusicSystem.current))
      return;
    int num = (int) MusicSystem.current.setPitch(MusicSystem.pitch);
  }));

  public static bool IsRunning(EventInstance instance)
  {
    if (instance.isValid())
    {
      PLAYBACK_STATE state;
      int playbackState = (int) instance.getPlaybackState(out state);
      if (state != PLAYBACK_STATE.STOPPED)
        return true;
    }
    return false;
  }

  [Serializable]
  public class Music
  {
    public string sceneName;
    public EventReference eventId;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Names
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;

public class Names : MonoBehaviourSingleton<Names>
{
  [SerializeField]
  public Names.Asset[] assets;
  public static Dictionary<string, TextAsset> files;
  public static readonly Dictionary<string, Queue<string>> lookup = new Dictionary<string, Queue<string>>();

  public static void Reset() => Names.lookup.Clear();

  public void OnEnable() => LocalizationSettings.Instance.OnSelectedLocaleChanged += new Action<Locale>(Names.LocaleChanged);

  public void OnDisable() => LocalizationSettings.Instance.OnSelectedLocaleChanged -= new Action<Locale>(Names.LocaleChanged);

  public static void LocaleChanged(Locale locale)
  {
    Names.files = (Dictionary<string, TextAsset>) null;
    Names.Reset();
  }

  public static string Pull(string key)
  {
    if (!Names.lookup.ContainsKey(key))
      Names.Load(key);
    Queue<string> stringQueue = Names.lookup[key];
    if (stringQueue == null || stringQueue.Count == 0)
    {
      Names.Load(key);
      stringQueue = Names.lookup[key];
    }
    return stringQueue.Dequeue();
  }

  public static string Pull(string characterRace, string characterGender) => Names.Pull(characterRace + characterGender);

  public static void Load(string key)
  {
    List<string> stringList = new List<string>();
    foreach (string str in Regex.Split(Names.GetFiles(key).text, "\r\n|\n|\r"))
      stringList.Add(str.Trim());
    stringList.Shuffle<string>();
    Names.lookup[key] = new Queue<string>((IEnumerable<string>) stringList);
  }

  public static TextAsset GetFiles(string key)
  {
    if (Names.files == null)
    {
      Names.files = new Dictionary<string, TextAsset>();
      foreach (Names.Asset asset in MonoBehaviourSingleton<Names>.instance.assets)
      {
        Names.LocaleTextAsset localeTextAsset = ((IEnumerable<Names.LocaleTextAsset>) asset.files).FirstOrDefault<Names.LocaleTextAsset>((Func<Names.LocaleTextAsset, bool>) (a => a.locale.name == LocalizationSettings.SelectedLocale.name)) ?? ((IEnumerable<Names.LocaleTextAsset>) asset.files).First<Names.LocaleTextAsset>();
        Names.files[asset.name] = localeTextAsset.textAsset;
      }
    }
    return Names.files[key];
  }

  [Serializable]
  public struct Asset
  {
    public string name;
    public Names.LocaleTextAsset[] files;
  }

  [Serializable]
  public class LocaleTextAsset
  {
    public Locale locale;
    public TextAsset textAsset;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NameTag
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class NameTag : MonoBehaviour
{
  [SerializeField]
  public NameTagStyle[] styles;
  public NameTagStyle currentStyle;
  public readonly Dictionary<string, NameTagStyle> styleDictionary = new Dictionary<string, NameTagStyle>();

  public void Awake()
  {
    foreach (NameTagStyle style in this.styles)
      this.styleDictionary[style.name] = style;
    foreach (NameTagStyle style in this.styles)
    {
      if (style.gameObject.activeSelf)
      {
        this.currentStyle = style;
        break;
      }
    }
  }

  public void SetStyle(string styleName)
  {
    NameTagStyle style = this.styleDictionary[styleName];
    if (!((Object) style != (Object) this.currentStyle))
      return;
    this.currentStyle.gameObject.SetActive(false);
    style.gameObject.SetActive(true);
    this.currentStyle = style;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NameTagStyle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class NameTagStyle : MonoBehaviour
{
  public TextMeshProUGUI textElement;
}
﻿// Decompiled with JetBrains decompiler
// Type: NavigationState
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;

public static class NavigationState
{
  public static readonly Stack<INavigationState> stateHistory = new Stack<INavigationState>();

  public static INavigationState PeekCurrentState() => NavigationState.stateHistory.Count <= 0 ? (INavigationState) null : NavigationState.stateHistory.Peek();

  public static INavigationState PopCurrentState() => NavigationState.stateHistory.Count <= 0 ? (INavigationState) null : NavigationState.stateHistory.Pop();

  public static void Start(INavigationState state)
  {
    INavigationState navigationState = NavigationState.PeekCurrentState();
    if (navigationState == state)
      return;
    navigationState?.End();
    if (state == null)
      return;
    state.Begin();
    NavigationState.stateHistory.Push(state);
  }

  public static void BackToPreviousState()
  {
    if (NavigationState.stateHistory.Count <= 0)
      return;
    NavigationState.PopCurrentState()?.End();
    NavigationState.PeekCurrentState()?.Begin();
  }

  public static void Reset()
  {
    NavigationState.stateHistory.Clear();
    NavigationState.Start((INavigationState) new NavigationStateIdle());
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NavigationStateAssignUpgrade
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class NavigationStateAssignUpgrade : INavigationState
{
  public readonly List<UINavigationItem> disabled = new List<UINavigationItem>();
  public readonly List<Entity> eligibleCards;

  public NavigationStateAssignUpgrade(List<Entity> eligibleCards) => this.eligibleCards = eligibleCards;

  public void Begin()
  {
    foreach (UpgradeDisplay upgradeDisplay in UnityEngine.Object.FindObjectsOfType<UpgradeDisplay>())
      this.Disable(upgradeDisplay.navigationItem);
    DeckDisplay objectOfType = UnityEngine.Object.FindObjectOfType<DeckDisplay>();
    if (objectOfType != null)
      this.Disable(objectOfType.backButtonNavigationItem);
    Dictionary<UINavigationItem, UINavigationItem.SelectionPriority> dictionary = new Dictionary<UINavigationItem, UINavigationItem.SelectionPriority>();
    foreach (UINavigationItem key in this.eligibleCards.Select<Entity, UINavigationItem>((Func<Entity, UINavigationItem>) (a => a.uINavigationItem)))
    {
      dictionary[key] = key.selectionPriority;
      key.selectionPriority = UINavigationItem.SelectionPriority.Mega;
    }
    UINavigationDefaultSystem.SetStartingItem(false);
    foreach (KeyValuePair<UINavigationItem, UINavigationItem.SelectionPriority> keyValuePair in dictionary)
      keyValuePair.Key.selectionPriority = keyValuePair.Value;
  }

  public void End()
  {
    foreach (Behaviour behaviour in this.disabled.Where<UINavigationItem>((Func<UINavigationItem, bool>) (a => (UnityEngine.Object) a != (UnityEngine.Object) null)))
      behaviour.enabled = true;
    this.disabled.Clear();
  }

  public void Disable(UINavigationItem item)
  {
    if ((UnityEngine.Object) item == (UnityEngine.Object) null)
      return;
    item.enabled = false;
    this.disabled.Add(item);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NavigationStateBattle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class NavigationStateBattle : INavigationState
{
  public readonly List<UINavigationItem> disabled = new List<UINavigationItem>();

  public void Begin()
  {
    foreach (CardSlotLane allRow in References.Battle.allRows)
    {
      this.Disable(allRow.nav);
      foreach (CardContainer slot in allRow.slots)
        this.Disable(slot.nav);
    }
    if (!(References.Battle.playerCardController is CardControllerBattle playerCardController))
      return;
    this.Disable(playerCardController.useOnHandAnchor);
  }

  public void End()
  {
    foreach (Behaviour behaviour in this.disabled.Where<UINavigationItem>((Func<UINavigationItem, bool>) (a => (bool) (UnityEngine.Object) a)))
      behaviour.enabled = true;
    this.disabled.Clear();
  }

  public void Disable(UINavigationItem item)
  {
    if (!(bool) (UnityEngine.Object) item)
      return;
    item.enabled = false;
    this.disabled.Add(item);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NavigationStateCard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class NavigationStateCard : INavigationState
{
  public readonly List<UINavigationItem> disabled = new List<UINavigationItem>();
  public readonly Entity entity;

  public NavigationStateCard(Entity entity) => this.entity = entity;

  public void Begin()
  {
    List<CardContainer> cardContainerList = new List<CardContainer>();
    foreach (CardContainer container in ((IEnumerable<CardContainer>) UnityEngine.Object.FindObjectsOfType<CardContainer>()).Where<CardContainer>((Func<CardContainer, bool>) (c => (bool) (UnityEngine.Object) c.nav && c.nav.enabled)))
    {
      if (this.entity.CanPlayOn(container))
        cardContainerList.Add(container);
      else
        this.Disable(container.nav);
    }
    foreach (Entity card in References.Battle.cards)
    {
      if ((bool) (UnityEngine.Object) card.uINavigationItem && card.uINavigationItem.enabled && (this.entity.data.playType != Card.PlayType.Play || !this.entity.CanPlayOn(card)))
        this.Disable(card.uINavigationItem);
    }
    this.Disable(RedrawBellSystem.nav);
    this.Disable(WaveDeploySystem.nav);
    if (References.Battle.playerCardController is CardControllerBattle playerCardController)
    {
      UINavigationItem useOnHandAnchor = playerCardController.useOnHandAnchor;
      if (useOnHandAnchor != null && this.entity.NeedsTarget)
        this.Disable(useOnHandAnchor);
    }
    Dictionary<UINavigationItem, UINavigationItem.SelectionPriority> dictionary = new Dictionary<UINavigationItem, UINavigationItem.SelectionPriority>();
    foreach (CardContainer cardContainer in cardContainerList)
    {
      if (cardContainer is CardSlot && cardContainer.Empty)
      {
        UINavigationItem nav = cardContainer.nav;
        if (nav != null && nav.enabled)
        {
          dictionary[nav] = nav.selectionPriority;
          nav.selectionPriority = UINavigationItem.SelectionPriority.Mega;
        }
      }
    }
    UINavigationDefaultSystem.SetDefaultTarget(this.entity);
    foreach (KeyValuePair<UINavigationItem, UINavigationItem.SelectionPriority> keyValuePair in dictionary)
      keyValuePair.Key.selectionPriority = keyValuePair.Value;
  }

  public void End()
  {
    foreach (Behaviour behaviour in this.disabled.Where<UINavigationItem>((Func<UINavigationItem, bool>) (a => (bool) (UnityEngine.Object) a)))
      behaviour.enabled = true;
    this.disabled.Clear();
  }

  public void Disable(UINavigationItem item)
  {
    if (!(bool) (UnityEngine.Object) item)
      return;
    item.enabled = false;
    this.disabled.Add(item);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NavigationStateIdle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class NavigationStateIdle : INavigationState
{
  public void Begin()
  {
  }

  public void End()
  {
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NavigationStateMuncher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class NavigationStateMuncher : INavigationState
{
  public readonly List<UINavigationItem> disabled = new List<UINavigationItem>();
  public readonly EventRoutineMuncher muncher;

  public NavigationStateMuncher(EventRoutineMuncher muncher) => this.muncher = muncher;

  public void Begin()
  {
    Button backButton = this.muncher.backButton;
    if (backButton != null)
      this.Disable(backButton.GetComponent<UINavigationItem>());
    foreach (Entity entity in this.muncher.cardContainer)
      this.Disable(entity.uINavigationItem);
    UINavigationDefaultSystem.SetStartingItem();
  }

  public void End()
  {
    foreach (Behaviour behaviour in this.disabled.Where<UINavigationItem>((Func<UINavigationItem, bool>) (a => (UnityEngine.Object) a != (UnityEngine.Object) null)))
      behaviour.enabled = true;
    this.disabled.Clear();
  }

  public void Disable(UINavigationItem item)
  {
    if ((UnityEngine.Object) item == (UnityEngine.Object) null)
      return;
    item.enabled = false;
    this.disabled.Add(item);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NavigationStateWait
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class NavigationStateWait : INavigationState
{
  public readonly bool disableInput;

  public NavigationStateWait(bool disableInput = false) => this.disableInput = disableInput;

  public void Begin()
  {
    VirtualPointer.Hide();
    if (!this.disableInput)
      return;
    InputSystem.Disable();
  }

  public void End()
  {
    VirtualPointer.Show();
    if (!this.disableInput)
      return;
    InputSystem.Enable();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NegativeCharmAfterBossModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class NegativeCharmAfterBossModifierSystem : GameSystem
{
  [SerializeField]
  public GainNegativeCharmSequence gainNegativeCharmSequencePrefab;

  public void OnEnable() => global::Events.OnBattleWin += new UnityAction(this.BattleWin);

  public void OnDisable() => global::Events.OnBattleWin -= new UnityAction(this.BattleWin);

  public void BattleWin()
  {
    if (!Campaign.FindCharacterNode(References.Player).type.isBoss)
      return;
    ActionQueue.Stack((PlayAction) new ActionSequence(this.GainCharmRoutine()));
  }

  public IEnumerator GainCharmRoutine()
  {
    GainNegativeCharmSequence sequence = Object.Instantiate<GainNegativeCharmSequence>(this.gainNegativeCharmSequencePrefab, References.Player.entity.display.transform);
    yield return (object) sequence.Run();
    sequence.gameObject.Destroy();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NewCardFramesChecker
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;

public static class NewCardFramesChecker
{
  public static bool Check() => SaveSystem.LoadProgressData<bool>("newFinalBoss", false);

  public static IEnumerator Run()
  {
    SaveSystem.SaveProgressData<bool>("newFinalBoss", false);
    InputSystem.Disable();
    yield return (object) SceneManager.Load("NewFrostGuardian", SceneType.Temporary);
    InputSystem.Enable();
    yield return (object) SceneManager.WaitUntilUnloaded("NewFrostGuardian");
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NewFinalBossChecker
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;

public static class NewFinalBossChecker
{
  public static bool Check() => SaveSystem.LoadProgressData<bool>("newFinalBoss", false);

  public static IEnumerator Run()
  {
    SaveSystem.SaveProgressData<bool>("newFinalBoss", false);
    InputSystem.Disable();
    yield return (object) SceneManager.Load("NewFrostGuardian", SceneType.Temporary);
    InputSystem.Enable();
    yield return (object) SceneManager.WaitUntilUnloaded("NewFrostGuardian");
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Nex
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class Nex : MonoBehaviour
{
}
﻿// Decompiled with JetBrains decompiler
// Type: NexFrequencyChecker
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public static class NexFrequencyChecker
{
  public static readonly Dictionary<NexFrequencyChecker.Function, NexFrequencyChecker.Profile> lookup = new Dictionary<NexFrequencyChecker.Function, NexFrequencyChecker.Profile>()
  {
    {
      NexFrequencyChecker.Function.PutScore,
      new NexFrequencyChecker.Profile(10, 60f)
    },
    {
      NexFrequencyChecker.Function.GetCommonData,
      new NexFrequencyChecker.Profile(10, 60f)
    },
    {
      NexFrequencyChecker.Function.PutCommonData,
      new NexFrequencyChecker.Profile(10, 60f)
    },
    {
      NexFrequencyChecker.Function.DeleteCommonData,
      new NexFrequencyChecker.Profile(10, 60f)
    },
    {
      NexFrequencyChecker.Function.GetRanking,
      new NexFrequencyChecker.Profile(20, 60f)
    },
    {
      NexFrequencyChecker.Function.GetCategorySetting,
      new NexFrequencyChecker.Profile(20, 60f)
    },
    {
      NexFrequencyChecker.Function.GetRankingChart,
      new NexFrequencyChecker.Profile(20, 60f)
    },
    {
      NexFrequencyChecker.Function.GetEstimatedScoreRank,
      new NexFrequencyChecker.Profile(20, 60f)
    }
  };

  public static bool Check(NexFrequencyChecker.Function functionName)
  {
    NexFrequencyChecker.Profile profile;
    if (!NexFrequencyChecker.lookup.TryGetValue(functionName, out profile) || !profile.Check())
      return false;
    profile.LogRequest();
    return true;
  }

  public enum Function
  {
    PutScore,
    GetCommonData,
    PutCommonData,
    DeleteCommonData,
    GetRanking,
    GetCategorySetting,
    GetRankingChart,
    GetEstimatedScoreRank,
  }

  public readonly struct Profile
  {
    public readonly int allowedRequests;
    public readonly float cooldownSeconds;
    public readonly List<float> requests;

    public Profile(int allowedRequests, float cooldownSeconds)
    {
      this.allowedRequests = allowedRequests;
      this.cooldownSeconds = cooldownSeconds;
      this.requests = new List<float>();
    }

    public bool Check()
    {
      this.RemoveInactive(Time.realtimeSinceStartup);
      return this.requests.Count < this.allowedRequests;
    }

    public void RemoveInactive(float time)
    {
      float num = time - this.cooldownSeconds;
      for (int index = this.requests.Count - 1; index >= 0; --index)
      {
        if ((double) this.requests[index] < (double) num)
          this.requests.RemoveAt(index);
      }
    }

    public void LogRequest() => this.requests.Add(Time.realtimeSinceStartup);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NoTargetTextSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;

public class NoTargetTextSystem : GameSystem
{
  public static NoTargetTextSystem instance;
  [SerializeField]
  public AnimationCurve shakeCurve;
  [SerializeField]
  public Vector3 shakeAmount = new Vector3(1f, 0.0f, 0.0f);
  [SerializeField]
  public Vector2 shakeDurationRange = new Vector2(0.3f, 0.4f);
  [SerializeField]
  public TMP_Text textElement;
  [SerializeField]
  public Vector3 textPopOffset = new Vector3(0.0f, 1.5f, -1f);
  [SerializeField]
  public EventReference sfxEvent;
  [Header("Text")]
  [SerializeField]
  public LocalizedString noTargetToAttackText;
  [SerializeField]
  public LocalizedString noAlliesToHealText;
  [SerializeField]
  public LocalizedString noTargetForStatusText;
  [SerializeField]
  public LocalizedString noSpaceToSummonText;
  [SerializeField]
  public LocalizedString noCardsToDrawText;
  [SerializeField]
  public LocalizedString noAllyToBoostText;
  [SerializeField]
  public LocalizedString noEnemyToBoostText;
  [SerializeField]
  public LocalizedString requiresJunkText;
  [SerializeField]
  public LocalizedString cantSplitText;
  [SerializeField]
  public LocalizedString noSummonedAlliesText;
  [SerializeField]
  public LocalizedString playCrownCardsText;
  [SerializeField]
  public LocalizedString noAllyToAttackText;
  [SerializeField]
  public LocalizedString cantMoveText;
  public readonly Dictionary<NoTargetType, string> strings = new Dictionary<NoTargetType, string>();

  public void OnEnable()
  {
    NoTargetTextSystem.instance = this;
    LocalizationSettings.SelectedLocaleChanged += new Action<Locale>(this.LocaleChanged);
    this.PopulateStrings();
  }

  public void OnDisable() => LocalizationSettings.SelectedLocaleChanged -= new Action<Locale>(this.LocaleChanged);

  public void LocaleChanged(Locale locale) => this.PopulateStrings();

  public void PopulateStrings()
  {
    this.strings.Clear();
    this.strings[NoTargetType.NoTargetToAttack] = this.noTargetToAttackText.GetLocalizedString();
    this.strings[NoTargetType.NoAllyToHeal] = this.noAlliesToHealText.GetLocalizedString();
    this.strings[NoTargetType.NoTargetForStatus] = this.noTargetForStatusText.GetLocalizedString();
    this.strings[NoTargetType.NoSpaceToSummon] = this.noSpaceToSummonText.GetLocalizedString();
    this.strings[NoTargetType.NoCardsToDraw] = this.noCardsToDrawText.GetLocalizedString();
    this.strings[NoTargetType.NoAllyToBoost] = this.noAllyToBoostText.GetLocalizedString();
    this.strings[NoTargetType.NoEnemyToBoost] = this.noEnemyToBoostText.GetLocalizedString();
    this.strings[NoTargetType.RequiresJunk] = this.requiresJunkText.GetLocalizedString();
    this.strings[NoTargetType.CantSplit] = this.cantSplitText.GetLocalizedString();
    this.strings[NoTargetType.NoSummonedAllies] = this.noSummonedAlliesText.GetLocalizedString();
    this.strings[NoTargetType.PlayCrownCardsFirst] = this.playCrownCardsText.GetLocalizedString();
    this.strings[NoTargetType.NoAllyToAttack] = this.noAllyToAttackText.GetLocalizedString();
    this.strings[NoTargetType.CantMove] = this.cantMoveText.GetLocalizedString();
  }

  public static bool Exists() => (bool) (UnityEngine.Object) NoTargetTextSystem.instance;

  public static IEnumerator Run(Entity entity, NoTargetType type, params object[] args) => NoTargetTextSystem.instance._Run(entity, type, args);

  public IEnumerator _Run(Entity entity, NoTargetType type, params object[] args)
  {
    NoTargetTextSystem targetTextSystem = this;
    if (targetTextSystem.enabled)
    {
      yield return (object) Sequences.WaitForAnimationEnd(entity);
      float num1 = targetTextSystem.shakeDurationRange.Random();
      double num2 = (double) entity.curveAnimator.Move(targetTextSystem.shakeAmount.WithX(targetTextSystem.shakeAmount.x.WithRandomSign()), targetTextSystem.shakeCurve, duration: num1);
      targetTextSystem.textElement.text = targetTextSystem.strings[type].Format(args);
      targetTextSystem.PopText(entity.transform.position);
      yield return (object) new WaitForSeconds(num1);
    }
  }

  public void PopText(Vector3 fromPos)
  {
    GameObject obj = this.textElement.gameObject;
    obj.SetActive(true);
    LeanTween.cancel(obj);
    obj.transform.position = fromPos;
    LeanTween.move(obj, fromPos + this.textPopOffset, 1.5f).setEaseOutElastic();
    this.textElement.color = this.textElement.color.WithAlpha(1f);
    LeanTween.value(obj, 1f, 0.0f, 0.2f).setDelay(1.3f).setOnUpdate((Action<float>) (a => this.textElement.color = this.textElement.color.WithAlpha(a))).setOnComplete((System.Action) (() => obj.SetActive(false)));
    SfxSystem.OneShot(this.sfxEvent);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: NoTargetType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public enum NoTargetType
{
  None,
  NoTargetToAttack,
  NoAllyBehind,
  NoAllyAhead,
  NoAlliesInRow,
  NoAllies,
  NoAllyToHeal,
  NoTargetForStatus,
  NoSpaceToSummon,
  NoCardsToDraw,
  NoAllyToBoost,
  NoEnemyToBoost,
  RequiresJunk,
  CantSplit,
  NoSummonedAllies,
  PlayCrownCardsFirst,
  NoAllyToAttack,
  CantMove,
}
﻿// Decompiled with JetBrains decompiler
// Type: ObjectInfo
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Serializable]
public class ObjectInfo
{
  public string objectName;
  public float objectValue;
}
﻿// Decompiled with JetBrains decompiler
// Type: ObjectTrackerUIScript
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ObjectTrackerUIScript : MonoBehaviour
{
  public RectTransform parentCanvas;
  public GameObject objToTrack;
  public Vector3 localOffset;
  public Vector3 targetPos;

  public virtual void Update()
  {
    this.targetPos = RectTransformUtility.WorldToScreenPoint(Camera.main, this.objToTrack.transform.position).WithZ(0.0f);
    this.GetComponent<RectTransform>().position = this.localOffset + this.targetPos;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: OpenCharmBlockSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class OpenCharmBlockSequence : UISequence
{
  [Header("Custom Values")]
  [SerializeField]
  public CardUpgradeData charmData;
  [SerializeField]
  public Transform charmBlockHolder;
  [SerializeField]
  public GainCharmSequence gainCharmSequence;
  [SerializeField]
  public Character character;
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public float animationDuration = 2f;
  [SerializeField]
  public ParticleSystem buildupParticleSystem;
  [SerializeField]
  public ParticleSystem explodeParticleSystem;

  public void SetCharm(CardUpgradeData charmData, Transform charmBlock)
  {
    this.charmData = charmData;
    this.charmBlockHolder.SetPositionAndRotation(charmBlock.position, charmBlock.rotation);
  }

  public void SetCharacter(Character character) => this.character = character;

  public override IEnumerator Run()
  {
    OpenCharmBlockSequence charmBlockSequence = this;
    yield return (object) Sequences.Wait(charmBlockSequence.startDelay);
    charmBlockSequence.gameObject.SetActive(true);
    charmBlockSequence.gainCharmSequence.SetCharm(charmBlockSequence.charmData);
    charmBlockSequence.gainCharmSequence.SetCharacter(charmBlockSequence.character);
    charmBlockSequence.animator.SetBool("BackgroundFade", true);
    Events.InvokeScreenRumble(0.1f, 0.0f, 0.0f, 0.1f, 0.0f, 0.0f);
    LeanTween.moveLocal(charmBlockSequence.charmBlockHolder.gameObject, Vector3.zero, 1f).setEase(LeanTweenType.easeOutBack);
    LeanTween.rotateLocal(charmBlockSequence.charmBlockHolder.gameObject, Vector3.zero, 1.5f).setEase(LeanTweenType.easeOutElastic);
    yield return (object) Sequences.Wait(0.4f);
    charmBlockSequence.animator.SetTrigger("Open");
    SfxSystem.OneShot("event:/sfx/inventory/charm_claim");
    Events.InvokeScreenRumble(0.0f, 2f, 0.25f, 0.75f, 0.5f, 0.25f);
    yield return (object) Sequences.Wait(charmBlockSequence.animationDuration);
    Events.InvokeScreenShake(5f);
    Routine.Clump clump = new Routine.Clump();
    clump.Add(charmBlockSequence.gainCharmSequence.Run());
    clump.Add(charmBlockSequence.FadeOutBackground(0.25f));
    yield return (object) clump.WaitForEnd();
    charmBlockSequence.gameObject.SetActive(false);
  }

  public IEnumerator FadeOutBackground(float delay = 0.0f)
  {
    yield return (object) Sequences.Wait(delay);
    this.animator.SetBool("BackgroundFade", false);
    yield return (object) Sequences.Wait(0.5f);
  }

  public void PlayBuildUpParticleSystem() => this.buildupParticleSystem.Play();

  public void PlayExplodeParticleSystem() => this.explodeParticleSystem.Play();
}
﻿// Decompiled with JetBrains decompiler
// Type: OpenURL
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class OpenURL : MonoBehaviour
{
  [SerializeField]
  public string url;

  public void Open() => Application.OpenURL(this.url);
}
﻿// Decompiled with JetBrains decompiler
// Type: OptionSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class OptionSetter : MonoBehaviour
{
  [SerializeField]
  public GameObject[] options;
  public bool init;

  public void Start()
  {
    if (this.init)
      return;
    TMP_Dropdown component = this.GetComponent<TMP_Dropdown>();
    if (component == null)
      return;
    this.Set(component.value);
  }

  public void Set(int index)
  {
    for (int index1 = 0; index1 < this.options.Length; ++index1)
      this.options[index1].SetActive(index1 == index);
    if (this.init)
      return;
    this.init = true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: OverallStatsDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Localization.Settings;

public class OverallStatsDisplay : MonoBehaviour
{
  [SerializeField]
  public GameStatData[] stats;
  [SerializeField]
  public int statsPerGroup = 20;
  [SerializeField]
  public TMP_Text[] nameGroups;
  [SerializeField]
  public TMP_Text[] valueGroups;
  [SerializeField]
  public float lineHeight = 0.34f;
  public static readonly Dictionary<string, bool> localesCentred = new Dictionary<string, bool>()
  {
    {
      "en",
      false
    },
    {
      "zh-Hans",
      true
    },
    {
      "zh-Hant",
      true
    },
    {
      "ko",
      true
    },
    {
      "ja",
      true
    }
  };
  public static bool centred;

  public void OnEnable()
  {
    OverallStatsDisplay.localesCentred.TryGetValue(LocalizationSettings.SelectedLocale.Identifier.Code, out OverallStatsDisplay.centred);
    this.Clear();
    this.Populate();
  }

  public void Populate()
  {
    StopWatch.Start();
    CampaignStats stats = OverallStatsSystem.Get().Clone();
    List<string> stringList = new List<string>()
    {
      "GameModeNormal",
      "GameModeDaily",
      "GameModeTutorial"
    };
    GameMode gameMode1 = (GameMode) null;
    if (Campaign.Data != null && (bool) (Object) References.Campaign && References.Campaign.result == Campaign.Result.None)
    {
      stringList.Remove(Campaign.Data.GameMode.name);
      OverallStatsSystem.Combine(stats, StatsSystem.Get());
      gameMode1 = Campaign.Data.GameMode;
    }
    foreach (string assetName in stringList)
    {
      if (!((Object) gameMode1 != (Object) null) || !(assetName == gameMode1.name))
      {
        GameMode gameMode2 = AddressableLoader.Get<GameMode>("GameMode", assetName);
        if (SaveSystem.CampaignExists(gameMode2) && Campaign.CheckContinue(gameMode2))
        {
          CampaignStats other = SaveSystem.LoadCampaignData<CampaignStats>(gameMode2, "stats");
          if (other != null)
            OverallStatsSystem.Combine(stats, other);
        }
      }
    }
    int num = 0;
    int index = 0;
    TMP_Text nameGroup = this.nameGroups[index];
    TMP_Text valueGroup = this.valueGroups[index];
    foreach (GameStatData stat in this.stats)
    {
      if (!(bool) (Object) stat)
      {
        nameGroup.text += "<br>";
        if (!OverallStatsDisplay.centred)
          valueGroup.text += "<br>";
      }
      else
      {
        string str = stat.stringKey.GetLocalizedString().Format(OverallStatsDisplay.centred ? (object) ("<#fff>" + stat.GetStringValue(stats, stat.GetValue(stats)) + "</color><br>") : (object) "<br>");
        nameGroup.text += str;
        if (!OverallStatsDisplay.centred)
        {
          TMP_Text tmpText = valueGroup;
          tmpText.text = tmpText.text + stat.GetStringValue(stats, stat.GetValue(stats)) + "<br>";
        }
      }
      if (++num > this.statsPerGroup)
      {
        num = 0;
        if (++index < this.nameGroups.Length)
        {
          nameGroup = this.nameGroups[index];
          valueGroup = this.valueGroups[index];
        }
        else
          break;
      }
    }
    Debug.Log((object) string.Format("OverallStatsDisplay → Populated ({0}ms)", (object) StopWatch.Stop()));
  }

  public void Clear()
  {
    foreach (TMP_Text nameGroup in this.nameGroups)
    {
      nameGroup.text = string.Format("<line-height={0}>", (object) this.lineHeight);
      if (OverallStatsDisplay.centred)
        nameGroup.text += "<align=center>";
    }
    foreach (TMP_Text valueGroup in this.valueGroups)
      valueGroup.text = string.Format("<line-height={0}>", (object) this.lineHeight);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: OverallStatsSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class OverallStatsSystem : GameSystem
{
  public static OverallStatsSystem instance;
  [SerializeField]
  public CampaignStats stats;

  public void Awake() => OverallStatsSystem.instance = this;

  public void OnEnable()
  {
    global::Events.OnCampaignEnd += new UnityAction<Campaign.Result, CampaignStats, PlayerData>(this.CampaignEnd);
    global::Events.OnGameStart += new UnityAction(this.GameStart);
  }

  public void OnDisable()
  {
    global::Events.OnCampaignEnd -= new UnityAction<Campaign.Result, CampaignStats, PlayerData>(this.CampaignEnd);
    global::Events.OnGameStart -= new UnityAction(this.GameStart);
  }

  public static CampaignStats Get() => OverallStatsSystem.instance.stats;

  public void GameStart()
  {
    if (SaveSystem.Enabled && SaveSystem.StatsExists() && SaveSystem.StatsDataExists("stats"))
      this.stats = SaveSystem.LoadStatsData<CampaignStats>("stats");
    else
      this.stats = new CampaignStats();
  }

  public void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
  {
    OverallStatsSystem.Combine(this.stats, stats);
    bool mainGameMode = Campaign.Data.GameMode.mainGameMode;
    bool dailyRun = Campaign.Data.GameMode.dailyRun;
    switch (result)
    {
      case Campaign.Result.Win:
        if (SaveSystem.LoadCampaignData<bool>(Campaign.Data.GameMode, "trueWin", false))
        {
          this.stats.Add("results", "trueWin", 1);
          if (mainGameMode)
          {
            this.stats.Add("currentTrueWinStreak", 1);
            this.stats.Max("bestTrueWinStreak", this.stats.Get("currentTrueWinStreak", 1));
          }
        }
        else
          this.stats.Add("results", "win", 1);
        if (mainGameMode)
        {
          this.stats.Add("currentWinStreak", 1);
          this.stats.Max("bestWinStreak", this.stats.Get("currentWinStreak", 1));
          this.stats.Max("bestWinTime", stats.hours + Mathf.FloorToInt(stats.time));
        }
        if (dailyRun)
        {
          this.stats.Add("dailyRunResults", "win", 1);
          break;
        }
        break;
      case Campaign.Result.Lose:
        this.stats.Add("results", "lose", 1);
        if (mainGameMode)
          this.ResetWinStreak();
        if (dailyRun)
        {
          this.stats.Add("dailyRunResults", "lose", 1);
          break;
        }
        break;
      case Campaign.Result.Restart:
        this.stats.Add("results", "restart", 1);
        if (mainGameMode)
          this.ResetWinStreak();
        if (dailyRun)
        {
          this.stats.Add("dailyRunResults", "restart", 1);
          break;
        }
        break;
    }
    this.Save();
  }

  public void ResetWinStreak()
  {
    this.stats.Set("currentWinStreak", 0);
    this.stats.Set("currentTrueWinStreak", 0);
  }

  public void Save()
  {
    SaveSystem.SaveStatsData<CampaignStats>("stats", this.stats);
    global::Events.InvokeOverallStatsSaved(this.stats);
  }

  public static void Combine(CampaignStats stats, CampaignStats other)
  {
    stats.time += other.time;
    stats.hours += other.hours;
    if (other.add != null)
    {
      foreach (KeyValuePair<string, Dictionary<string, int>> keyValuePair1 in other.add)
      {
        foreach (KeyValuePair<string, int> keyValuePair2 in keyValuePair1.Value)
          OverallStatsSystem.Change(keyValuePair1.Key, keyValuePair2.Key, keyValuePair2.Value, ref stats.add, new Func<int, int, int>(OverallStatsSystem.Add));
      }
    }
    if (other.max == null)
      return;
    foreach (KeyValuePair<string, Dictionary<string, int>> keyValuePair3 in other.max)
    {
      foreach (KeyValuePair<string, int> keyValuePair4 in keyValuePair3.Value)
        OverallStatsSystem.Change(keyValuePair3.Key, keyValuePair4.Key, keyValuePair4.Value, ref stats.max, new Func<int, int, int>(OverallStatsSystem.Max));
    }
  }

  public static void Change(
    string stat,
    string key,
    int value,
    ref Dictionary<string, Dictionary<string, int>> values,
    Func<int, int, int> action)
  {
    if (values == null)
      values = new Dictionary<string, Dictionary<string, int>>();
    Dictionary<string, int> dictionary1;
    if (!values.ContainsKey(stat))
    {
      dictionary1 = new Dictionary<string, int>();
      values[stat] = dictionary1;
    }
    else
    {
      Dictionary<string, int> dictionary2 = values[stat];
      if (dictionary2 != null)
      {
        dictionary1 = dictionary2;
      }
      else
      {
        dictionary1 = new Dictionary<string, int>();
        values[stat] = dictionary1;
      }
    }
    int num1;
    if (dictionary1.ContainsKey(key))
    {
      int num2 = dictionary1[key];
      num1 = action(num2, value);
    }
    else
      num1 = value;
    dictionary1[key] = num1;
  }

  public static int Add(int value, int add) => value + add;

  public static int Max(int value, int max) => Mathf.Max(value, max);
}
﻿// Decompiled with JetBrains decompiler
// Type: Page
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;

public class Page : MonoBehaviour
{
  [Header("Dragging")]
  public bool canDrag = true;
  [Header("Zooming")]
  public bool canZoom = true;
  [ShowIf("canZoom")]
  [MinMaxSlider(-100f, 100f)]
  public Vector2 zoomRange = new Vector2(0.0f, 80f);
  [ShowIf("canZoom")]
  [Range(0.0f, 1f)]
  public float zoomSpeed = 0.1f;
  public bool dragging;
  public Vector3 dragGrabPos;
  public float zoom;
  public float zoomTarget;
  public bool inspecting;

  public void OnEnable()
  {
    global::Events.OnInspect += new UnityAction<Entity>(this.InspectStart);
    global::Events.OnInspectEnd += new UnityAction<Entity>(this.InspectEnd);
  }

  public void OnDisable()
  {
    global::Events.OnInspect -= new UnityAction<Entity>(this.InspectStart);
    global::Events.OnInspectEnd -= new UnityAction<Entity>(this.InspectEnd);
  }

  public void Update()
  {
    if (this.inspecting)
      return;
    if (this.canDrag)
    {
      if (this.dragging)
        this.Drag();
      if (this.dragging && !Input.GetMouseButton(2))
        this.StopDrag();
      if (Input.GetMouseButtonDown(2))
        this.StartDrag();
    }
    float num = -Input.mouseScrollDelta.y;
    if ((double) num > 0.0)
      this.zoomTarget = Mathf.Min(this.zoomTarget + num * this.zoomSpeed, 1f);
    else if ((double) num < 0.0)
      this.zoomTarget = Mathf.Max(this.zoomTarget + num * this.zoomSpeed, 0.0f);
    if ((double) this.zoom == (double) this.zoomTarget)
      return;
    this.zoom = Delta.Lerp(this.zoom, this.zoomTarget, 0.1f, Time.deltaTime);
    this.transform.localPosition = this.transform.localPosition.WithZ(this.zoomRange.x + (this.zoomRange.y - this.zoomRange.x) * this.zoom);
  }

  public void InspectStart(Entity entity)
  {
    this.inspecting = true;
    this.StopDrag();
  }

  public void InspectEnd(Entity entity) => this.inspecting = false;

  public void StartDrag()
  {
    this.dragging = true;
    this.dragGrabPos = this.transform.position - Cursor3d.PositionWithZ;
  }

  public void Drag() => this.transform.position = Cursor3d.PositionWithZ + this.dragGrabPos;

  public void StopDrag() => this.dragging = false;
}
﻿// Decompiled with JetBrains decompiler
// Type: ParticleSystemCreator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ParticleSystemCreator : MonoBehaviour
{
  [SerializeField]
  public ParticleSystem prefab;

  public void Create() => Object.Instantiate<ParticleSystem>(this.prefab, this.transform).transform.localPosition = Vector3.zero;
}
﻿// Decompiled with JetBrains decompiler
// Type: PasswordCheck
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Linq;

public static class PasswordCheck
{
  public static PasswordCheck.PasswordStrength GetPasswordStrength(string password)
  {
    int passwordStrength = 0;
    if (string.IsNullOrEmpty(password) || string.IsNullOrEmpty(password.Trim()))
      return PasswordCheck.PasswordStrength.Blank;
    if (PasswordCheck.HasMinimumLength(password, 5))
      ++passwordStrength;
    if (PasswordCheck.HasMinimumLength(password, 8))
      ++passwordStrength;
    if (PasswordCheck.HasUpperCaseLetter(password) && PasswordCheck.HasLowerCaseLetter(password))
      ++passwordStrength;
    if (PasswordCheck.HasDigit(password))
      ++passwordStrength;
    if (PasswordCheck.HasSpecialChar(password))
      ++passwordStrength;
    return (PasswordCheck.PasswordStrength) passwordStrength;
  }

  public static bool IsStrongPassword(string password)
  {
    if (!PasswordCheck.HasMinimumLength(password, 8) || !PasswordCheck.HasUpperCaseLetter(password) || !PasswordCheck.HasLowerCaseLetter(password))
      return false;
    return PasswordCheck.HasDigit(password) || PasswordCheck.HasSpecialChar(password);
  }

  public static bool IsValidPassword(string password, PasswordCheck.PasswordOptions opts) => PasswordCheck.IsValidPassword(password, opts.RequiredLength, opts.RequiredUniqueChars, opts.RequireNonAlphanumeric, opts.RequireLowercase, opts.RequireUppercase, opts.RequireDigit);

  public static bool IsValidPassword(
    string password,
    int requiredLength,
    int requiredUniqueChars,
    bool requireNonAlphanumeric,
    bool requireLowercase,
    bool requireUppercase,
    bool requireDigit)
  {
    return PasswordCheck.HasMinimumLength(password, requiredLength) && PasswordCheck.HasMinimumUniqueChars(password, requiredUniqueChars) && (!requireNonAlphanumeric || PasswordCheck.HasSpecialChar(password)) && (!requireLowercase || PasswordCheck.HasLowerCaseLetter(password)) && (!requireUppercase || PasswordCheck.HasUpperCaseLetter(password)) && (!requireDigit || PasswordCheck.HasDigit(password));
  }

  public static bool HasMinimumLength(string password, int minLength) => password.Length >= minLength;

  public static bool HasMinimumUniqueChars(string password, int minUniqueChars) => password.Distinct<char>().Count<char>() >= minUniqueChars;

  public static bool HasDigit(string password) => password.Any<char>((Func<char, bool>) (c => char.IsDigit(c)));

  public static bool HasSpecialChar(string password) => password.IndexOfAny("!@#$%^&*?_~-£().,".ToCharArray()) != -1;

  public static bool HasUpperCaseLetter(string password) => password.Any<char>((Func<char, bool>) (c => char.IsUpper(c)));

  public static bool HasLowerCaseLetter(string password) => password.Any<char>((Func<char, bool>) (c => char.IsLower(c)));

  public enum PasswordStrength
  {
    Blank,
    VeryWeak,
    Weak,
    Medium,
    Strong,
    VeryStrong,
  }

  public struct PasswordOptions
  {
    public int RequiredLength;
    public int RequiredUniqueChars;
    public bool RequireNonAlphanumeric;
    public bool RequireLowercase;
    public bool RequireUppercase;
    public bool RequireDigit;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PauseMenu
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class PauseMenu : Menu
{
  [SerializeField]
  public ButtonAnimator backToMenuButton;
  [SerializeField]
  public ButtonAnimator quickRestartButton;
  [SerializeField]
  public bool freezeTimeScale = true;
  [SerializeField]
  public JournalTab battleLogTab;
  [SerializeField]
  public JournalTab settingsTab;
  [SerializeField]
  public JournalTab lorePageTab;
  public static int blocked;
  [SerializeField]
  public bool doButtonLogic = true;

  public void OnEnable()
  {
    if (this.doButtonLogic)
    {
      switch (SceneManager.GetActive().name)
      {
        case "MainMenu":
          this.backToMenuButton.interactable = false;
          this.quickRestartButton.interactable = false;
          break;
        case "CharacterSelect":
        case "ContinueRun":
        case "Town":
        case "Cards":
          this.backToMenuButton.interactable = true;
          this.quickRestartButton.interactable = false;
          break;
        default:
          this.backToMenuButton.interactable = true;
          this.quickRestartButton.interactable = Campaign.Data != null && Campaign.Data.GameMode.canRestart;
          break;
      }
    }
    GameManager.paused = true;
    if (!this.freezeTimeScale)
      return;
    Time.timeScale = 0.0f;
  }

  public void OnDisable()
  {
    GameManager.paused = false;
    if (!this.freezeTimeScale)
      return;
    Time.timeScale = 1f;
  }

  public void GoToMainMenu()
  {
    if (!this.active)
      return;
    MonoBehaviourSingleton<Transition>.instance.StartCoroutine(SceneManager.Unload("Mods"));
    MonoBehaviourSingleton<Transition>.instance.StartCoroutine(SceneManager.Load("MainMenu", SceneType.Active));
  }

  public void BackToMainMenu()
  {
    if (!this.active)
      return;
    if ((bool) (Object) References.Campaign && !Campaign.Data.GameMode.doSave)
    {
      References.Campaign.End(Campaign.Result.None);
      JournalNameHistory.MostRecentNameKilled();
    }
    Routine routine = new Routine(Sequences.EndCampaign("MainMenu"));
    this.active = false;
    Events.InvokeBackToMainMenu();
  }

  public void QuickRestart()
  {
    if (!this.active)
      return;
    if ((bool) (Object) References.Campaign)
    {
      References.Campaign.End(Campaign.Result.Restart);
      JournalNameHistory.MostRecentNameKilled();
    }
    Campaign.Data = new CampaignData(Campaign.Data.GameMode);
    Routine routine = new Routine(Sequences.EndCampaign("CharacterSelect"));
    this.active = false;
  }

  public void BattleLog()
  {
    if (this.gameObject.activeSelf)
      return;
    this.Open();
    this.battleLogTab.Select();
  }

  public void Settings()
  {
    if (this.gameObject.activeSelf)
      return;
    this.Open();
    this.settingsTab.Select();
  }

  public void OpenLorePages()
  {
    if (this.gameObject.activeSelf)
      return;
    this.Open();
    this.lorePageTab.Select();
  }

  public override void Open()
  {
    if (PauseMenu.blocked > 0)
      return;
    base.Open();
  }

  public static void Block()
  {
    ++PauseMenu.blocked;
    foreach (Menu menu in Object.FindObjectsOfType<PauseMenu>())
      menu.Close();
  }

  public static void Unblock() => --PauseMenu.blocked;
}
﻿// Decompiled with JetBrains decompiler
// Type: PauseMenuBlocker
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class PauseMenuBlocker : MonoBehaviour
{
  public void OnEnable() => PauseMenu.Block();

  public void OnDisable() => PauseMenu.Unblock();
}
﻿// Decompiled with JetBrains decompiler
// Type: PermadeathModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class PermadeathModifierSystem : GameSystem
{
  public static readonly string[] LegalTypes = new string[1]
  {
    "Friendly"
  };

  public void OnEnable() => global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(PermadeathModifierSystem.EntityKilled);

  public void OnDisable() => global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(PermadeathModifierSystem.EntityKilled);

  public static void EntityKilled(Entity entity, DeathType deathType)
  {
    if (!PermadeathModifierSystem.IsPlayerCard(entity) || !PermadeathModifierSystem.IsLegalCardType(entity))
      return;
    PermadeathModifierSystem.RemoveFromDeck(entity, References.PlayerData.inventory);
  }

  public static bool IsPlayerCard(Entity entity) => (Object) entity.owner == (Object) References.Player && References.PlayerData.inventory.deck.Contains(entity.data);

  public static bool IsLegalCardType(Entity entity) => PermadeathModifierSystem.LegalTypes.Contains<string>(entity.data.cardType.name);

  public static void RemoveFromDeck(Entity entity, Inventory inventory)
  {
    Debug.Log((object) string.Format("Permadeath System → deleting [{0}]", (object) entity.data));
    inventory.deck.Remove(entity.data);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PetHutFlagSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class PetHutFlagSetter : MonoBehaviour
{
  [SerializeField]
  public SpriteRenderer flag;
  [SerializeField]
  public Sprite[] flagSprites;

  public void SetupFlag() => this.flag.sprite = this.flagSprites[Mathf.Clamp(SaveSystem.LoadProgressData<int>("selectedPet", 0), 0, this.flagSprites.Length - 1)];
}
﻿// Decompiled with JetBrains decompiler
// Type: PetHutSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Deadpan.Enums.Engine.Components.Modding;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class PetHutSequence : BuildingSequenceWithUnlocks<PetHutSequence>
{
  [SerializeField]
  public CardController controller;
  [SerializeField]
  public CardUnlockSequence cardUnlockSequence;
  [SerializeField]
  public string firstGreetKey = "petHutFirstGreet";

  public void Start()
  {
    this._OnStart();
    this.cardSlots = this.cardSlots.RemoveFromArray<CardContainer>((Func<CardContainer, bool>) (container =>
    {
      ChallengeDisplayCreator componentInChildren = container.transform.parent.gameObject.GetComponentInChildren<ChallengeDisplayCreator>();
      if (!(bool) (UnityEngine.Object) componentInChildren || (bool) (UnityEngine.Object) componentInChildren.challenge)
        return true;
      UnityEngine.Object.Destroy((UnityEngine.Object) container.transform.parent.gameObject);
      return false;
    }));
  }

  public override IEnumerator Sequence()
  {
    PetHutSequence petHutSequence = this;
    int num = Mathf.Min(petHutSequence.locks.Length, petHutSequence.building.type.unlocks.Length);
    for (int index = 0; index < num; ++index)
    {
      if (petHutSequence.building.type.unlocks[index].IsActive)
        petHutSequence.locks[index].SetActive(false);
    }
    yield return (object) petHutSequence.CreateCards();
    if (petHutSequence.building.HasUncheckedUnlocks)
    {
      foreach (string uncheckedUnlock in petHutSequence.building.uncheckedUnlocks)
        yield return (object) petHutSequence.Unlock(uncheckedUnlock);
      Entity top = ((IEnumerable<CardContainer>) petHutSequence.cardSlots).LastOrDefault<CardContainer>((Func<CardContainer, bool>) (a => !a.Empty))?.GetTop();
      if ((bool) (UnityEngine.Object) top)
        petHutSequence.TalkerNewCard(top.data);
    }
    else if (!petHutSequence.firstGreetKey.IsNullOrEmpty() && !SaveSystem.LoadProgressData<bool>(petHutSequence.firstGreetKey, false))
    {
      petHutSequence.TalkerFirstGreet();
      SaveSystem.SaveProgressData<bool>(petHutSequence.firstGreetKey, true);
    }
    else
      petHutSequence.TalkerGreet();
  }

  public IEnumerator Unlock(string unlockDataName)
  {
    PetHutSequence petHutSequence = this;
    int index = 1 + ((IEnumerable<UnlockData>) petHutSequence.building.type.unlocks).Select<UnlockData, string>((Func<UnlockData, string>) (a => a.name)).ToList<string>().IndexOf(unlockDataName);
    string assetName = index >= 0 ? MetaprogressionSystem.Get<List<string>>("pets")[index] : throw new IndexOutOfRangeException("[" + unlockDataName + "] does not exist in [" + petHutSequence.building.name + "] unlocks list!");
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>(petHutSequence.building.type.unlockedCheckedKey, new List<string>());
    stringList.Add(unlockDataName);
    SaveSystem.SaveProgressData<List<string>>(petHutSequence.building.type.unlockedCheckedKey, stringList);
    Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", assetName), petHutSequence.controller, (Character) null, false, true);
    yield return (object) card.UpdateData(false);
    CardContainer finalSlot = ((IEnumerable<CardContainer>) petHutSequence.cardSlots).FirstOrDefault<CardContainer>((Func<CardContainer, bool>) (a => a.Empty));
    yield return (object) petHutSequence.cardUnlockSequence.Run(card.entity, finalSlot);
    if ((bool) (UnityEngine.Object) finalSlot)
    {
      Image component = finalSlot.GetComponent<Image>();
      if (component != null)
        component.enabled = true;
    }
  }

  public IEnumerator CreateCards()
  {
    PetHutSequence petHutSequence = this;
    List<Entity> cards = new List<Entity>();
    Routine.Clump clump = new Routine.Clump();
    foreach (string unlockedPet in MetaprogressionSystem.GetUnlockedPets())
    {
      Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", unlockedPet), petHutSequence.controller, (Character) null, false, true);
      cards.Add(card.entity);
      clump.Add(card.UpdateData(false));
    }
    yield return (object) clump.WaitForEnd();
    foreach (Entity entity in cards)
    {
      CardContainer cardContainer = ((IEnumerable<CardContainer>) petHutSequence.cardSlots).FirstOrDefault<CardContainer>((Func<CardContainer, bool>) (a => a.Empty));
      if (cardContainer == null)
        break;
      entity.flipper.FlipUpInstant();
      entity.enabled = true;
      cardContainer.Add(entity);
      cardContainer.SetChildPositions();
      Image component = cardContainer.GetComponent<Image>();
      if (component != null)
        component.enabled = false;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PlatformSpecific
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Serialization;

public class PlatformSpecific : MonoBehaviour
{
  [SerializeField]
  public bool editor = true;
  [SerializeField]
  public bool windows = true;
  [SerializeField]
  public bool @switch = true;
  [SerializeField]
  public bool android = true;
  [SerializeField]
  public bool iOs = true;
  [FormerlySerializedAs("mustBeRelease")]
  [SerializeField]
  public bool release;
  [SerializeField]
  public bool demo;
  [SerializeField]
  public bool notDemo;

  public void Awake()
  {
    bool flag = true;
    if (!this.windows)
      flag = false;
    if (this.demo)
      flag = false;
    if (flag)
      return;
    this.gameObject.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PlayAction
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;

public abstract class PlayAction
{
  public float pauseBefore;
  public float pauseAfter;
  public int priority;
  public bool fixedPosition;
  public bool parallel;
  public string note;

  public virtual bool IsRoutine => true;

  public virtual void Process()
  {
  }

  public virtual IEnumerator Run() => (IEnumerator) null;

  public virtual string Name => this.GetType().Name + (this.note.IsNullOrWhitespace() ? "" : " [" + this.note + "]");
}
﻿// Decompiled with JetBrains decompiler
// Type: PlayCrownCardsFirstSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine.Events;

public class PlayCrownCardsFirstSystem : GameSystem
{
  public bool crownPhase;

  public void OnEnable()
  {
    global::Events.OnBattleStart += new UnityAction(this.BattleStart);
    global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
    global::Events.OnBattleTurnEnd += new UnityAction<int>(this.BattleTurnEnd);
  }

  public void OnDisable()
  {
    global::Events.OnBattleStart -= new UnityAction(this.BattleStart);
    global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
    global::Events.OnBattleTurnEnd -= new UnityAction<int>(this.BattleTurnEnd);
  }

  public void BattleStart() => this.crownPhase = true;

  public void CheckAction(ref PlayAction action, ref bool allow)
  {
    if (!this.crownPhase)
      return;
    switch (action)
    {
      case ActionMove actionMove:
        if (actionMove.entity.data.HasCrown || Battle.IsOnBoard(actionMove.entity) || !Battle.IsOnBoard(actionMove.toContainers))
          break;
        allow = false;
        if (!NoTargetTextSystem.Exists())
          break;
        this.StartCoroutine(NoTargetTextSystem.Run(actionMove.entity, NoTargetType.PlayCrownCardsFirst));
        break;
      case ActionTrigger actionTrigger:
        if (actionTrigger.entity.data.HasCrown)
          break;
        allow = false;
        if (!NoTargetTextSystem.Exists())
          break;
        this.StartCoroutine(NoTargetTextSystem.Run(actionTrigger.entity, NoTargetType.PlayCrownCardsFirst));
        break;
    }
  }

  public void BattleTurnEnd(int turnNumber)
  {
    this.crownPhase = false;
    this.enabled = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PlayerData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public class PlayerData
{
  public ClassData classData;
  [Header("Stats")]
  public int handSize = 6;
  public int redrawBell = 4;
  public int companionLimit = 3;
  public float enemyGoldFactor = 1f;
  public float comboGoldFactor = 1f;
  [Header("Inventory")]
  public Inventory inventory;

  public PlayerData(ClassData classData, Inventory inventory)
  {
    this.classData = classData;
    this.inventory = inventory;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PlayerGetGold
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class PlayerGetGold : MonoBehaviour
{
  public void GetGold(int amount)
  {
    Character player = References.Player;
    if (!((Object) player != (Object) null))
      return;
    player.data.inventory.gold += amount;
    player.entity.PromptUpdate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PointAtCard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class PointAtCard : MonoBehaviour
{
  [SerializeField]
  public Transform holder;
  [SerializeField]
  public float moveAmount = 0.25f;
  [SerializeField]
  public float lerp = 0.1f;
  public Vector3 targetPos;
  public Transform t;
  public Camera cam;

  public void OnEnable()
  {
    this.cam = Camera.main;
    this.t = this.transform;
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
  }

  public void OnDisable() => global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);

  public void Update()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      this.SetTargetPos(MonoBehaviourSingleton<Cursor3d>.instance.transform.position);
    this.t.localPosition = Delta.Lerp(this.t.localPosition, this.targetPos, this.lerp, Time.deltaTime);
  }

  public void EntityHover(Entity entity) => this.SetTargetPos(entity.transform.position);

  public void SetTargetPos(Vector3 target) => this.targetPos = this.GetVectorTo(target) * this.moveAmount;

  public Vector3 GetVectorTo(Vector3 to)
  {
    Vector3 vectorTo = this.cam.WorldToScreenPoint(to) - this.cam.WorldToScreenPoint(this.holder.position);
    if ((double) vectorTo.magnitude > 1.0)
      vectorTo.Normalize();
    return vectorTo;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PointCameraAtHoverCardSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class PointCameraAtHoverCardSystem : GameSystem
{
  [SerializeField]
  public Transform cameraMover;
  [SerializeField]
  public bool affectInPlay = true;
  [SerializeField]
  public bool affectNotInPlay = true;
  [Header("Rotate To Face Card")]
  [SerializeField]
  [Range(0.0f, 1f)]
  public float aimLerp = 0.05f;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float aimResetLerp = 0.0125f;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float aimAmount = 0.05f;
  [Header("Pull Position Towards Card")]
  [SerializeField]
  [Range(0.0f, 1f)]
  public float pullLerp = 0.05f;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float pullResetLerp = 0.0125f;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float pullAmount = 0.05f;
  [SerializeField]
  public float pullClamp = 10f;
  public Entity current;
  public float amount;
  public readonly Quaternion originalRotation = Quaternion.identity;
  public Quaternion toRotation;
  public readonly Vector3 originalPosition = Vector3.zero;
  public Vector3 toPosition;

  public void OnEnable()
  {
    this.amount = Settings.Load<float>("CameraSway", 1f);
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
    global::Events.OnEntityDestroyed += new UnityAction<Entity>(this.EntityUnHover);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnSettingChanged += new UnityAction<string, object>(this.SettingChanged);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
    global::Events.OnEntityDestroyed -= new UnityAction<Entity>(this.EntityUnHover);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnSettingChanged -= new UnityAction<string, object>(this.SettingChanged);
  }

  public void Update()
  {
    bool current = (bool) (Object) this.current;
    if ((double) this.aimAmount > 0.0)
    {
      if (current)
        this.toRotation = Quaternion.Lerp(this.originalRotation, Quaternion.FromToRotation(this.transform.forward, this.current.transform.position - this.cameraMover.position), this.aimAmount * this.amount);
      this.cameraMover.rotation = Delta.Lerp(this.cameraMover.rotation, this.toRotation, !current ? this.aimResetLerp : this.aimLerp, Time.deltaTime);
    }
    if ((double) this.pullAmount <= 0.0)
      return;
    if (current)
      this.toPosition = Vector3.Lerp(this.originalPosition, this.originalPosition + Vector3.ClampMagnitude(this.current.transform.position, this.pullClamp), this.pullAmount * this.amount);
    this.cameraMover.localPosition = Delta.Lerp(this.cameraMover.localPosition, this.toPosition, !current ? this.pullResetLerp : this.pullLerp, Time.deltaTime);
  }

  public void EntityHover(Entity entity)
  {
    if (!this.Check(entity))
      return;
    this.current = entity;
  }

  public void EntityUnHover(Entity entity)
  {
    if (!((Object) this.current == (Object) entity))
      return;
    this.toRotation = this.originalRotation;
    this.toPosition = this.originalPosition;
    this.current = (Entity) null;
  }

  public void SceneChanged(Scene scene) => this.cameraMover.SetLocalPositionAndRotation(this.originalPosition, this.originalRotation);

  public bool Check(Entity entity)
  {
    if (entity.inPlay && this.affectInPlay)
      return true;
    return !entity.inPlay && this.affectNotInPlay;
  }

  public void SettingChanged(string key, object value)
  {
    if (!(key == "CameraSway") || !(value is float num))
      return;
    this.amount = num;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PopUpAddStatsSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;

public class PopUpAddStatsSystem : GameSystem
{
  [SerializeField]
  public LocalizedString counterRef;
  [SerializeField]
  public LocalizedString counterThisTurnRef;
  [SerializeField]
  public LocalizedString counterFrozenRef;
  [SerializeField]
  public LocalizedString reactionRef;
  [SerializeField]
  public LocalizedString reactionJoinRef;
  [SerializeField]
  public LocalizedString reactionFrozenRef;
  [SerializeField]
  public LocalizedString reactionSilencedRef;
  public Entity hover;
  public bool hoverEntityIsSnowed;
  public bool hoverEntitySilenced;
  public const string buffedColour = "#5F5";
  public const string debuffedColour = "#e8a0a0";

  public void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(this.HoverChanged);
    global::Events.OnPopupCreated += new UnityAction<KeywordData, CardPopUpPanel>(this.PopupCreated);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.HoverChanged);
    global::Events.OnPopupCreated -= new UnityAction<KeywordData, CardPopUpPanel>(this.PopupCreated);
  }

  public void HoverChanged(Entity entity)
  {
    this.hover = entity;
    this.hoverEntityIsSnowed = entity.IsSnowed;
    this.hoverEntitySilenced = entity.silenced;
  }

  public void PopupCreated(KeywordData keyword, CardPopUpPanel panel)
  {
    if (!(bool) (UnityEngine.Object) this.hover)
      return;
    switch (keyword.name)
    {
      case "Health":
        string str1 = "<color=white>";
        string text1 = (this.hover.hp.current >= this.hover.hp.max ? (this.hover.hp.current <= this.hover.hp.max ? str1 + string.Format("{0}", (object) this.hover.hp.current) : str1 + string.Format("<color={0}>{1}</color>", (object) "#5F5", (object) this.hover.hp.current)) : str1 + string.Format("<color={0}>{1}</color>", (object) "#e8a0a0", (object) this.hover.hp.current)) + string.Format("/{0}</color>", (object) this.hover.hp.max);
        panel.AddToTitle(text1);
        panel.BuildTextElement();
        break;
      case "Attack":
        string str2 = "<color=white>";
        int num = this.hover.damage.current + this.hover.tempDamage.Value;
        string text2 = (num >= this.hover.damage.max ? (num <= this.hover.damage.max ? str2 + string.Format("{0}", (object) num) : str2 + string.Format("<color={0}>{1}</color>", (object) "#5F5", (object) num)) : str2 + string.Format("<color={0}>{1}</color>", (object) "#e8a0a0", (object) num)) + string.Format("/{0}</color>", (object) this.hover.damage.max);
        panel.AddToTitle(text2);
        panel.BuildTextElement();
        break;
      case "Counter":
        string str3 = "<color=white>";
        string text3 = (this.hover.counter.current <= this.hover.counter.max ? str3 + string.Format("{0}", (object) this.hover.counter.current) : str3 + string.Format("<color={0}>{1}</color>", (object) "#e8a0a0", (object) this.hover.counter.current)) + string.Format("/{0}</color>", (object) this.hover.counter.max);
        panel.AddToTitle(text3);
        panel.AddToBody(this.BuildCounterBodyText(this.hoverEntityIsSnowed, this.hover.counter.current));
        panel.BuildTextElement();
        break;
      case "Reaction":
        panel.AddToBody(this.BuildReactionBodyText(this.hoverEntityIsSnowed, this.hoverEntitySilenced));
        panel.BuildTextElement();
        break;
    }
  }

  public string BuildCounterBodyText(bool frozen, int turnsTilTrigger)
  {
    if (frozen)
      return this.counterFrozenRef.GetLocalizedString();
    if (turnsTilTrigger <= 1)
      return this.counterThisTurnRef.GetLocalizedString();
    return this.counterRef.GetLocalizedString().Format((object) turnsTilTrigger);
  }

  public string BuildReactionBodyText(bool frozen, bool silenced)
  {
    if (silenced)
      return this.reactionSilencedRef.GetLocalizedString();
    if (frozen)
      return this.reactionFrozenRef.GetLocalizedString();
    List<string> values = new List<string>();
    foreach (StatusEffectData statusEffect in this.hover.statusEffects)
    {
      if (statusEffect.isReaction && !statusEffect.textKey.IsEmpty)
        values.Add(PopUpAddStatsSystem.FormatReactionText(statusEffect));
    }
    foreach (Entity.TraitStacks trait in this.hover.traits)
    {
      if (trait.data.isReaction)
        values.Add("<" + PopUpAddStatsSystem.FirstCharToLowerCase(trait.data.keyword.body) + ">");
    }
    return this.reactionRef.GetLocalizedString().Format((object) string.Join(this.reactionJoinRef.GetLocalizedString(), (IEnumerable<string>) values));
  }

  public static string FormatReactionText(StatusEffectData effect)
  {
    string str1 = Text.GetEffectText(effect.textKey, effect.textInsert, effect.count);
    for (int index = 0; index < str1.Length; ++index)
    {
      if (str1[index] == '<')
      {
        int num = str1.IndexOf('>', index);
        string str2 = str1.Substring(index + 1, num - index - 1);
        string newValue = str2;
        if (str2.Contains('='))
        {
          string[] strArray = str2.Split('=', StringSplitOptions.None);
          switch (strArray[0].Trim())
          {
            case "keyword":
              KeywordData keyword = Text.ToKeyword(strArray[1]);
              newValue = !keyword.iconName.IsNullOrWhitespace() ? "><sprite name=" + keyword.iconName + "><" : keyword.title;
              break;
            case "card":
              newValue = AddressableLoader.Get<CardData>("CardData", strArray[1].Trim()).title;
              break;
          }
        }
        str1 = str1.Replace(str1.Substring(index, num - index + 1), newValue);
        index += newValue.Length;
      }
    }
    return ("<" + PopUpAddStatsSystem.FirstCharToLowerCase(str1) + ">").Replace("<>", "");
  }

  public static string FirstCharToLowerCase(string str)
  {
    if (!char.IsUpper(str[0]))
      return str;
    if (str.Length == 1)
      return str.ToLower();
    string str1 = char.ToLower(str[0]).ToString();
    string str2 = str;
    int length1 = str2.Length;
    int startIndex = 1;
    int num = startIndex;
    int length2 = length1 - num;
    string str3 = str2.Substring(startIndex, length2);
    return str1 + str3;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PositionBasedOnAspect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class PositionBasedOnAspect : MonoBehaviourRect
{
  [SerializeField]
  public AnimationCurve curve;
  [SerializeField]
  public Vector3 maxPosition;
  [SerializeField]
  public Vector3 minPosition;

  public void UpdatePosition(RectTransform canvas)
  {
    Vector2 sizeDelta = canvas.sizeDelta;
    this.rectTransform.anchoredPosition3D = this.minPosition + (this.maxPosition - this.minPosition) * this.curve.Evaluate(sizeDelta.x / sizeDelta.y);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PositionBasedOnScene
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class PositionBasedOnScene : MonoBehaviour
{
  [SerializeField]
  public PositionBasedOnScene.ScenePosition[] positions;
  public bool hasRectTransform;
  public RectTransform rt;
  public Transform t;

  public void OnEnable()
  {
    this.t = this.transform;
    if (this.t is RectTransform t)
    {
      this.hasRectTransform = true;
      this.rt = t;
    }
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.ActiveSceneChanged);
  }

  public void OnDisable() => global::Events.OnSceneChanged -= new UnityAction<Scene>(this.ActiveSceneChanged);

  public void ActiveSceneChanged(Scene to)
  {
    PositionBasedOnScene.ScenePosition scenePosition = ((IEnumerable<PositionBasedOnScene.ScenePosition>) this.positions).FirstOrDefault<PositionBasedOnScene.ScenePosition>((Func<PositionBasedOnScene.ScenePosition, bool>) (a => a.sceneName == to.name));
    if (scenePosition == null)
      return;
    this.SetPosition(scenePosition.position);
  }

  public void SetPosition(Vector3 pos)
  {
    if (this.hasRectTransform)
      this.rt.anchoredPosition = (Vector2) pos;
    else
      this.t.localPosition = pos;
  }

  [Serializable]
  public class ScenePosition
  {
    [SerializeField]
    public string sceneName;
    [SerializeField]
    public Vector3 position;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PrefabCollection
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "PrefabCollection", menuName = "Character/Prefab Collection")]
public class PrefabCollection : Collection<GameObject>
{
}
﻿// Decompiled with JetBrains decompiler
// Type: PrefabLoaderAsync
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Events;
using UnityEngine.ResourceManagement.AsyncOperations;

public class PrefabLoaderAsync : MonoBehaviour
{
  [SerializeField]
  public bool onAwake;
  [ShowIf("onAwake")]
  [SerializeField]
  public AssetReferenceGameObject prefabRef;
  [ShowIf("onAwake")]
  [SerializeField]
  public UnityEvent<GameObject> onComplete;
  public AsyncOperationHandle<GameObject> handle;
  public bool busy;

  public void Awake()
  {
    if (!this.onAwake)
      return;
    this.StartCoroutine(this.Load(this.prefabRef));
  }

  public IEnumerator Load(AssetReferenceGameObject prefabRef)
  {
    PrefabLoaderAsync prefabLoaderAsync = this;
    while (prefabLoaderAsync.busy)
      yield return (object) null;
    prefabLoaderAsync.busy = true;
    if (prefabLoaderAsync.handle.IsValid())
      Addressables.Release<GameObject>(prefabLoaderAsync.handle);
    prefabLoaderAsync.handle = prefabRef.InstantiateAsync(prefabLoaderAsync.transform);
    yield return (object) prefabLoaderAsync.handle;
    prefabLoaderAsync.onComplete?.Invoke(prefabLoaderAsync.handle.Result);
    prefabLoaderAsync.busy = false;
  }

  public void OnDestroy()
  {
    if (!this.handle.IsValid())
      return;
    Addressables.Release<GameObject>(this.handle);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PreloadAddressableGroup
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class PreloadAddressableGroup : MonoBehaviour
{
  [SerializeField]
  public string[] groups;
  public static bool done;

  public async void Start()
  {
    PreloadAddressableGroup addressableGroup = this;
    if (PreloadAddressableGroup.done)
    {
      Object.Destroy((Object) addressableGroup.gameObject);
    }
    else
    {
      PreloadAddressableGroup.done = true;
      Object.DontDestroyOnLoad((Object) addressableGroup.gameObject);
      Debug.Log((object) string.Format("~ ASSET PRELOADER: {0} group(s) to load", (object) addressableGroup.groups.Length));
      string[] strArray = addressableGroup.groups;
      for (int index = 0; index < strArray.Length; ++index)
      {
        string group = strArray[index];
        Debug.Log((object) ("~ ASSET PRELOADER: Loading Group [" + group + "]"));
        StopWatch.Start();
        await AddressableLoader.PreLoadGroup(group);
        Debug.Log((object) string.Format("~ ASSET PRELOADER: Group [{0}] Loaded! ({1}ms)", (object) group, (object) StopWatch.Stop()));
        group = (string) null;
      }
      strArray = (string[]) null;
      Debug.Log((object) "~ ASSET PRELOADER: Finished");
      Object.Destroy((Object) addressableGroup.gameObject);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Profile
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public class Profile
{
  public string @string;
  public Sprite sprite;
}
﻿// Decompiled with JetBrains decompiler
// Type: Progression
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public class Progression
{
  public float current;
  public float previousRequired;
  public float required = 1f;
  [SerializeField]
  public float randomness = 0.1f;
  [SerializeField]
  public float minProgressAdd = 2f;
  [SerializeField]
  public float maxProgressAdd = 4f;

  public Progression()
  {
  }

  public Progression(float startAmount, float startRequirement, float randomness)
  {
    this.current = startAmount;
    this.previousRequired = 0.0f;
    this.required = startRequirement;
    this.randomness = randomness;
  }

  public bool Add(float amount)
  {
    if (this.RequirementMet())
      return false;
    this.current += amount + UnityEngine.Random.Range(-this.randomness, this.randomness);
    return true;
  }

  public bool RequirementMet() => (double) this.current >= (double) this.required;

  public void SetNextRequirement()
  {
    this.previousRequired = this.required;
    this.required += Mathf.Clamp(this.required, this.minProgressAdd, this.maxProgressAdd);
  }

  public float ProgressToNextUnlock() => (float) (((double) this.current - (double) this.previousRequired) / ((double) this.required - (double) this.previousRequired));
}
﻿// Decompiled with JetBrains decompiler
// Type: ProgressSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Serializable]
public class ProgressSaveData
{
  public int nextSeed;
  public int tutorialProgress;
  public bool tutorialCharmDone;
  public bool tutorialInjuryDone;
  public CardSaveData[] finalBossEnemies;

  public static ProgressSaveData Default() => new ProgressSaveData()
  {
    nextSeed = Dead.Random.Seed()
  };
}
﻿// Decompiled with JetBrains decompiler
// Type: ProgressSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class ProgressSystem : GameSystem
{
}
﻿// Decompiled with JetBrains decompiler
// Type: Prompt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;
using UnityEngine.UI;

public class Prompt : MonoBehaviourRect
{
  [SerializeField]
  public TMP_Text textAsset;
  [SerializeField]
  public LayoutElement layoutElement;
  [SerializeField]
  public RectTransform textBox;
  [SerializeField]
  public float noteSize = 0.3f;
  [SerializeField]
  public string noteColorHex = "fffa";
  [SerializeField]
  public Prompt.Emote[] emotes;
  [SerializeField]
  public Image emoteImage;
  [SerializeField]
  public string focusFormat = "<#fff>{0}</color>";
  public Prompt.GetTextCallback SetTextAction;
  [CompilerGenerated]
  public bool \u003Cactive\u003Ek__BackingField;
  public float width;
  public Prompt.Emote.Type emoteType;
  public Prompt.Emote.Position emotePosition;

  public bool active
  {
    get => this.\u003Cactive\u003Ek__BackingField;
    set => this.\u003Cactive\u003Ek__BackingField = value;
  }

  public void OnEnable() => LocalizationSettings.Instance.OnSelectedLocaleChanged += new Action<Locale>(this.LocaleChanged);

  public void OnDisable() => LocalizationSettings.Instance.OnSelectedLocaleChanged -= new Action<Locale>(this.LocaleChanged);

  public void LocaleChanged(Locale locale) => this.RunSetTextAction();

  public void RunSetTextAction()
  {
    Prompt.GetTextCallback setTextAction = this.SetTextAction;
    this.SetText(setTextAction != null ? setTextAction() : (string) null);
  }

  public void SetAnchor(Prompt.Anchor anchor)
  {
    switch (anchor)
    {
      case Prompt.Anchor.Mid:
        this.SetAnchor(0.5f, 0.5f);
        break;
      case Prompt.Anchor.Top:
        this.SetAnchor(0.5f, 1f);
        break;
      case Prompt.Anchor.Left:
        this.SetAnchor(0.0f, 0.5f);
        break;
      case Prompt.Anchor.Right:
        this.SetAnchor(1f, 0.5f);
        break;
      case Prompt.Anchor.Bottom:
        this.SetAnchor(0.5f, 0.0f);
        break;
      case Prompt.Anchor.TopLeft:
        this.SetAnchor(0.0f, 1f);
        break;
      case Prompt.Anchor.TopRight:
        this.SetAnchor(1f, 1f);
        break;
      case Prompt.Anchor.BottomLeft:
        this.SetAnchor(0.0f, 0.0f);
        break;
      case Prompt.Anchor.BottomRight:
        this.SetAnchor(1f, 0.0f);
        break;
      default:
        throw new ArgumentException(string.Format("Invalid Anchor {0}", (object) anchor));
    }
  }

  public void SetAnchor(float x, float y) => this.SetAnchor(new Vector2(x, y));

  public void SetAnchor(Vector2 anchor)
  {
    this.rectTransform.anchorMin = anchor;
    this.rectTransform.anchorMax = anchor;
    this.rectTransform.pivot = anchor;
  }

  public void SetPosition(Vector2 position) => this.rectTransform.anchoredPosition = position;

  public void SetPosition(Vector2 position, Prompt.Anchor anchor)
  {
    this.SetAnchor(anchor);
    this.rectTransform.anchoredPosition = position;
  }

  public void SetMaxWidth(float value)
  {
    this.layoutElement.preferredWidth = value;
    this.width = value;
  }

  public void SetText(string text)
  {
    float num = 0.0f;
    int length1 = text.IndexOf('+');
    if (length1 >= 0)
    {
      string s = text.Substring(length1 + 1);
      text = text.Substring(0, length1);
      ref float local = ref num;
      float.TryParse(s, out local);
    }
    this.layoutElement.preferredWidth = this.width + num;
    string note = "";
    if (text.Contains("|"))
    {
      int length2 = text.IndexOf('|');
      note = text.Substring(length2 + 1);
      text = text.Substring(0, length2);
    }
    this.SetText(this.ProcessText(text), note);
    this.SetEmote(this.emoteType, this.emotePosition);
  }

  public void SetText(string text, string note = "")
  {
    if (!note.IsNullOrWhitespace())
      text += string.Format("\n\n<size={0}><#{1}>{2}", (object) this.noteSize, (object) this.noteColorHex, (object) note);
    this.textAsset.text = text;
  }

  public string ProcessText(string input)
  {
    string str1 = input.Trim();
    int length = input.Length;
    while (true)
    {
      int num1 = str1.IndexOf('[');
      if (num1 >= 0)
      {
        int num2 = str1.IndexOf(']', num1);
        if (num2 > num1)
        {
          string str2 = this.ProcessTag(str1.Substring(num1, num2 - num1).Substring(1, num2 - num1 - 1));
          string str3 = str1.Substring(0, num1);
          string str4 = str1.Substring(num2 + 1);
          str1 = str3 + str2 + str4;
        }
        else
          break;
      }
      else
        break;
    }
    return str1;
  }

  public string ProcessTag(string tag) => string.Format(this.focusFormat, (object) tag);

  public void SetEmote(Prompt.Emote.Type emoteType, Prompt.Emote.Position position)
  {
    this.emoteType = emoteType;
    this.emotePosition = position;
    Prompt.Emote emote = ((IEnumerable<Prompt.Emote>) this.emotes).FirstOrDefault<Prompt.Emote>((Func<Prompt.Emote, bool>) (e => e.type == emoteType));
    if ((bool) (UnityEngine.Object) emote.sprite)
    {
      this.emoteImage.gameObject.SetActive(true);
      this.emoteImage.sprite = emote.sprite;
      this.SetEmotePosition(position);
    }
    else
      this.emoteImage.gameObject.SetActive(false);
  }

  public void SetEmotePosition(
    Prompt.Emote.Position position,
    float offsetX = 0.0f,
    float offsetY = 0.0f,
    float forceFlip = 0.0f)
  {
    this.StopAllCoroutines();
    this.StartCoroutine(this.SetEmotePositionRoutine(position, offsetX, offsetY, forceFlip));
  }

  public IEnumerator SetEmotePositionRoutine(
    Prompt.Emote.Position position,
    float offsetX = 0.0f,
    float offsetY = 0.0f,
    float forceFlip = 0.0f)
  {
    Rect rect = this.textBox.rect;
    while (rect == this.textBox.rect)
      yield return (object) null;
    rect = this.textBox.rect;
    float num1 = (float) ((double) rect.width * 0.5 + 0.10000000149011612);
    float num2 = (float) ((double) rect.height * 0.5 + 0.68999999761581421);
    RectTransform transform = (RectTransform) this.emoteImage.transform;
    switch (position)
    {
      case Prompt.Emote.Position.Left:
        transform.anchoredPosition = new Vector2(-num1 + offsetX, 0.0f + offsetY);
        break;
      case Prompt.Emote.Position.Right:
        transform.anchoredPosition = new Vector2(num1 + offsetX, 0.0f + offsetY);
        break;
      case Prompt.Emote.Position.Above:
        transform.anchoredPosition = new Vector2((float) (-(double) num1 * 0.5) + offsetX, num2 + offsetY);
        break;
      case Prompt.Emote.Position.Below:
        transform.anchoredPosition = new Vector2(0.0f + offsetX, -num2 + offsetY);
        break;
    }
    float x = (double) forceFlip == 0.0 ? ((double) transform.position.x < 0.0 ? 1f : -1f) : forceFlip;
    transform.localScale = new Vector3(x, 1f, 1f);
  }

  public void Ping()
  {
    LeanTween.cancel(this.gameObject);
    this.transform.localScale = Vector3.one * 0.0f;
    LeanTween.scale(this.gameObject, Vector3.one, 1.5f).setEase(LeanTweenType.easeOutElastic);
  }

  public void Hide()
  {
    this.active = false;
    LeanTween.cancel(this.gameObject);
    this.transform.localScale = Vector3.one;
    LeanTween.scale(this.gameObject, Vector3.zero, 0.167f).setEase(LeanTweenType.easeInBack).setOnComplete((System.Action) (() => this.gameObject.SetActive(false)));
  }

  public void Enable()
  {
    this.active = true;
    this.gameObject.SetActive(true);
  }

  [CompilerGenerated]
  public void \u003CHide\u003Eb__36_0() => this.gameObject.SetActive(false);

  public delegate string GetTextCallback();

  public enum Anchor
  {
    Mid,
    Top,
    Left,
    Right,
    Bottom,
    TopLeft,
    TopRight,
    BottomLeft,
    BottomRight,
  }

  [Serializable]
  public struct Emote
  {
    public Prompt.Emote.Type type;
    public Sprite sprite;

    public enum Type
    {
      None,
      Basic,
      Point,
      Scared,
      Talk,
      Explain,
      Sad,
      Happy,
    }

    public enum Position
    {
      Left,
      Right,
      Above,
      Below,
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: PromptShower
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Localization;

public class PromptShower : MonoBehaviour
{
  [SerializeField]
  public bool showOnEnable = true;
  [SerializeField]
  public bool showOnce = true;
  [SerializeField]
  [ShowIf("showOnce")]
  public string saveDataString;
  [SerializeField]
  public Prompt.Anchor anchor;
  [SerializeField]
  public Vector2 position;
  [SerializeField]
  public float width;
  [SerializeField]
  public Prompt.Emote.Type emote;
  [SerializeField]
  public LocalizedString localizedString;

  public void OnEnable()
  {
    if (!this.showOnEnable)
      return;
    this.Show((object) null);
  }

  public void Show(object insert)
  {
    if (this.showOnce)
    {
      if (SaveSystem.LoadProgressData<bool>(this.saveDataString, false))
        return;
      SaveSystem.SaveProgressData<bool>(this.saveDataString, true);
    }
    PromptSystem.Hide();
    PromptSystem.Create(this.anchor, this.position.x, this.position.y, this.width, this.emote);
    if (insert != null)
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => string.Format(this.localizedString.GetLocalizedString(), insert)));
    else
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => this.localizedString.GetLocalizedString()));
  }

  public void Hide() => PromptSystem.Hide();
}
﻿// Decompiled with JetBrains decompiler
// Type: PromptSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class PromptSystem : GameSystem
{
  public static PromptSystem instance;
  [SerializeField]
  public Prompt prompt;
  [SerializeField]
  public EventReference popUpSfx;
  [SerializeField]
  public EventReference denySfx;

  public static Prompt Prompt => PromptSystem.instance.prompt;

  public static void SetSortingLayer(string layerName, int sortingOrder)
  {
    Canvas component = PromptSystem.instance.GetComponent<Canvas>();
    if (!(bool) (Object) component)
      return;
    component.sortingLayerName = layerName;
    component.sortingOrder = sortingOrder;
  }

  public void OnEnable()
  {
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    PromptSystem.instance = this;
  }

  public void OnDisable() => global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);

  public void SceneChanged(Scene scene)
  {
    if (!(bool) (Object) this.prompt || !this.prompt.gameObject.activeSelf)
      return;
    this.prompt.gameObject.SetActive(false);
  }

  public static void Create(
    Prompt.Anchor anchor,
    Vector2 anchoredPosition,
    float maxWidth,
    Prompt.Emote.Type emoteType = Prompt.Emote.Type.Basic,
    Prompt.Emote.Position emotePosition = Prompt.Emote.Position.Above)
  {
    if (!(bool) (Object) PromptSystem.instance)
      return;
    PromptSystem.instance.DoCreate(anchor, anchoredPosition, maxWidth, emoteType, emotePosition);
  }

  public static void Create(
    Prompt.Anchor anchor,
    float x,
    float y,
    float maxWidth,
    Prompt.Emote.Type emoteType = Prompt.Emote.Type.Basic,
    Prompt.Emote.Position emotePosition = Prompt.Emote.Position.Above)
  {
    PromptSystem.Create(anchor, new Vector2(x, y), maxWidth, emoteType, emotePosition);
  }

  public static void SetTextAction(Prompt.GetTextCallback action)
  {
    PromptSystem.Prompt.SetTextAction = action;
    PromptSystem.Prompt.RunSetTextAction();
  }

  public void DoCreate(
    Prompt.Anchor anchor,
    Vector2 anchoredPosition,
    float maxWidth,
    Prompt.Emote.Type emoteType = Prompt.Emote.Type.Basic,
    Prompt.Emote.Position emotePosition = Prompt.Emote.Position.Above)
  {
    this.prompt.Enable();
    this.prompt.SetPosition(anchoredPosition, anchor);
    this.prompt.SetMaxWidth(maxWidth);
    this.prompt.SetEmote(emoteType, emotePosition);
    this.prompt.Ping();
    SfxSystem.OneShot(this.popUpSfx);
    SfxSystem.OneShot("event:/sfx/map/location_showup");
  }

  public static void Hide() => Object.FindObjectOfType<PromptSystem>()?.DoHide();

  public void DoHide()
  {
    if (!(bool) (Object) this.prompt || !this.prompt.active)
      return;
    this.prompt.Hide();
  }

  public static void Shake()
  {
    if (!(bool) (Object) PromptSystem.instance)
      return;
    GameObject gameObject = PromptSystem.instance.gameObject;
    LeanTween.cancel(gameObject);
    gameObject.transform.localPosition = new Vector3(0.25f, 0.0f, -3f);
    LeanTween.moveLocal(gameObject, new Vector3(0.0f, 0.0f, -3f), 1f).setEase(LeanTweenType.easeOutElastic);
    SfxSystem.OneShot(PromptSystem.instance.denySfx);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: RandomInclusive
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public static class RandomInclusive
{
  public static int Range(int min, int max) => Random.Range(min, max + 1);

  public static float Range(float min, float max) => Random.Range(min, max);
}
﻿// Decompiled with JetBrains decompiler
// Type: RandomPosition
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

public class RandomPosition : MonoBehaviour
{
  [SerializeField]
  public Vector2 x;
  [SerializeField]
  public Vector2 y;

  public void OnEnable() => this.Randomize();

  [Button(null, EButtonEnableMode.Always)]
  public void Randomize() => this.transform.localPosition = (Vector3) new Vector2(this.x.Random(), this.y.Random());
}
﻿// Decompiled with JetBrains decompiler
// Type: RecallChargeRedrawBellModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class RecallChargeRedrawBellModifierSystem : GameSystem
{
  public RedrawBellSystem _redrawBellSystem;

  public RedrawBellSystem redrawBellSystem => this._redrawBellSystem ?? (this._redrawBellSystem = Object.FindObjectOfType<RedrawBellSystem>());

  public void OnEnable() => global::Events.OnDiscard += new UnityAction<Entity>(this.EntityDiscard);

  public void OnDisable() => global::Events.OnDiscard -= new UnityAction<Entity>(this.EntityDiscard);

  public void EntityDiscard(Entity entity)
  {
    if (!(entity.data.cardType.tag == "Friendly"))
      return;
    this.redrawBellSystem.SetCounter(Mathf.Max(0, this.redrawBellSystem.counter.current - 2));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: RedrawBellStartChargedModifierSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine.Events;

public class RedrawBellStartChargedModifierSystem : GameSystem
{
  public void OnEnable() => global::Events.OnRedrawBellRevealed += new UnityAction<RedrawBellSystem>(RedrawBellStartChargedModifierSystem.RedrawBellRevealed);

  public void OnDisable() => global::Events.OnRedrawBellRevealed -= new UnityAction<RedrawBellSystem>(RedrawBellStartChargedModifierSystem.RedrawBellRevealed);

  public static void RedrawBellRevealed(RedrawBellSystem redrawBellSystem) => redrawBellSystem.SetCounter(0);
}
﻿// Decompiled with JetBrains decompiler
// Type: RedrawBellSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;
using UnityEngine.SceneManagement;

public class RedrawBellSystem : GameSystem
{
  public RectTransform _rectTransform;
  [SerializeField]
  public GameObject bell;
  [SerializeField]
  public GameObject bellActive;
  [SerializeField]
  public ParticleSystem chargeParticleSystem;
  [SerializeField]
  public ParticleSystem hitParticleSystem;
  [SerializeField]
  public UINavigationItem navigationItem;
  [Header("Counter")]
  [SerializeField]
  public int counterChange = -1;
  [SerializeField]
  public StatusIcon counterIcon;
  [Header("Keyword Popup")]
  [SerializeField]
  public KeywordData popUpKeyword;
  [SerializeField]
  public Vector2 popUpOffset = new Vector2(-1f, -1f);
  [SerializeField]
  public LocalizedString textNotCharged;
  [SerializeField]
  public LocalizedString textCharged;
  public UnityEngine.Animator _animator;
  public Character owner;
  public CardController controller;
  public Stat counter;
  public bool reset;
  [HideInInspector]
  public bool interactable;
  public bool poppedUp;
  public static UINavigationItem nav;

  public RectTransform rectTransform => this._rectTransform ?? (this._rectTransform = (RectTransform) this.transform);

  public UnityEngine.Animator animator => this._animator ?? (this._animator = this.GetComponent<UnityEngine.Animator>());

  public bool IsCharged => this.counter.current <= 0;

  public void OnEnable()
  {
    RedrawBellSystem.nav = this.navigationItem;
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnBattleTurnEnd += new UnityAction<int>(this.CounterIncrement);
  }

  public void OnDisable()
  {
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnBattleTurnEnd -= new UnityAction<int>(this.CounterIncrement);
  }

  public void BecomeInteractable()
  {
    if (this.interactable)
      return;
    this.interactable = true;
    this.Assign(Battle.instance.player, Battle.instance.playerCardController);
    this.Show();
  }

  public void Show()
  {
    this.bell.SetActive(true);
    this.interactable = true;
    this.reset = false;
    this.counter.max = this.owner.data.redrawBell;
    this.SetCounter(this.counter.max);
    global::Events.InvokeRedrawBellRevealed(this);
    this.AnimatorTrigger("Enter");
    SfxSystem.OneShot("event:/sfx/inventory/redraw_bell_showup");
  }

  public void Hide()
  {
    this.bell.SetActive(false);
    this.interactable = false;
    if (this.poppedUp)
      this.UnPop();
    this.bellActive.SetActive(false);
  }

  public void SceneChanged(Scene scene)
  {
    if (!this.interactable || !(scene.name != "Battle"))
      return;
    this.Hide();
  }

  public void BattlePhaseStart(Battle.Phase phase)
  {
    if (phase != Battle.Phase.Play)
    {
      if (phase != Battle.Phase.End)
        return;
      this.Hide();
    }
    else
      this.BecomeInteractable();
  }

  public void CounterIncrement(int turnNumber)
  {
    if (Battle.instance.phase == Battle.Phase.End)
      return;
    this.Counter();
  }

  public void Assign(Character owner, CardController controller)
  {
    this.owner = owner;
    this.controller = controller;
    this.GetComponentInChildren<ToggleBasedOnCardController>(true)?.AssignCardController(controller);
  }

  public void Activate()
  {
    if (!this.interactable)
      return;
    ActionRedraw action = new ActionRedraw(this.owner, global::Events.GetHandSize(References.PlayerData.handSize));
    if (!global::Events.CheckAction((PlayAction) action))
      return;
    ActionQueue.Add((PlayAction) action);
    ActionQueue.Add((PlayAction) new ActionEndTurn(this.owner));
    this.controller.Disable();
    if (this.IsCharged)
    {
      this.owner.freeAction = true;
      this.reset = false;
    }
    else
      this.reset = true;
    global::Events.InvokeRedrawBellHit(this);
    SfxSystem.OneShot("event:/sfx/inventory/redraw_bell_use");
    this.SetCounter(this.counter.max);
    this.AnimatorTrigger("Ring");
    global::Events.InvokeScreenShake();
    global::Events.InvokeUINavigationReset();
    this.hitParticleSystem.Play();
  }

  public void Counter()
  {
    if (this.reset)
    {
      this.reset = false;
    }
    else
    {
      int num = Mathf.Clamp(this.counter.current + this.counterChange, 0, this.counter.max);
      if (num == this.counter.current)
        return;
      this.SetCounter(num);
      this.AnimatorTrigger("Shake");
      SfxSystem.OneShot("event:/sfx/inventory/redraw_bell_countdown");
    }
  }

  public void SetCounter(int value)
  {
    int num = this.IsCharged ? 1 : 0;
    this.counter.current = value;
    if ((bool) (Object) this.counterIcon)
      this.counterIcon.SetValue(this.counter);
    this.animator.SetBool("Charged", this.IsCharged);
    if (num != 0 || !this.IsCharged)
      return;
    SfxSystem.OneShot("event:/sfx/inventory/redraw_bell_charged");
  }

  public void Pop()
  {
    if (this.poppedUp || !(bool) (Object) this.popUpKeyword)
      return;
    string forceBody = this.popUpKeyword.body.Format((object) global::Events.GetHandSize(References.PlayerData.handSize)) + (this.IsCharged ? "\n\n" + this.textCharged.GetLocalizedString() : "\n\n" + this.textNotCharged.GetLocalizedString());
    CardPopUp.AssignTo(this.rectTransform, this.popUpOffset.x, this.popUpOffset.y);
    CardPopUp.AddPanel(this.popUpKeyword, forceBody);
    this.poppedUp = true;
  }

  public void UnPop()
  {
    if (!this.poppedUp)
      return;
    CardPopUp.RemovePanel(this.popUpKeyword.name);
    this.poppedUp = false;
  }

  public void AnimatorTrigger(string name) => this.animator.SetTrigger(name);

  public void AnimatorSetHover(bool value) => this.animator.SetBool("Hover", value);

  public void AnimatorSetPress(bool value) => this.animator.SetBool("Press", value);

  public void PlayChargeParticleSystem() => this.chargeParticleSystem.Play();
}
﻿// Decompiled with JetBrains decompiler
// Type: References
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Linq;
using UnityEngine;

public class References : MonoBehaviourSingleton<References>
{
  public static PlayerData PlayerData;
  public static Character Player;
  public static MapNew Map;
  public static Campaign Campaign;
  public static Battle Battle;
  public ClassData[] classes;
  public AreaData[] areas;
  public HardModeModifierData[] hardModeModifiers;
  public static Transform _minibossCameraMover;
  public const string DefaultGameModeName = "GameModeNormal";
  public const string TutorialGameModeName = "GameModeTutorial";

  public static CardData LeaderData => References.PlayerData.inventory.deck.First<CardData>((Func<CardData, bool>) (a => a.cardType.miniboss));

  public static ClassData[] Classes => MonoBehaviourSingleton<References>.instance.classes;

  public static AreaData[] Areas => MonoBehaviourSingleton<References>.instance.areas;

  public static Transform MinibossCameraMover
  {
    get
    {
      if ((bool) (UnityEngine.Object) References._minibossCameraMover)
        return References._minibossCameraMover;
      GameObject withTag = GameObject.FindWithTag("MinibossCameraTransform");
      if (withTag != null)
        References._minibossCameraMover = withTag.transform;
      return References._minibossCameraMover;
    }
  }

  public static AreaData GetCurrentArea() => References.Areas[Campaign.FindCharacterNode(References.Player).areaIndex];
}
﻿// Decompiled with JetBrains decompiler
// Type: RenameCompanionSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Steamworks;
using System;
using System.Collections;
using TMPro;
using UnityEngine;

public class RenameCompanionSequence : UISequence
{
  [Header("Custom Values")]
  [SerializeField]
  public Transform cardHolder;
  [SerializeField]
  public TMP_InputField inputField;
  public Entity unit;
  public Transform unitPreParent;
  public Vector3 unitPrePosition;
  public Vector3 unitPreRotation;
  public Vector3 unitPreScale;
  [SerializeField]
  public float unitMoveWobble = 1.5f;
  [SerializeField]
  public AnimationCurve unitMoveCurve;
  [SerializeField]
  public float unitMoveDur = 0.33f;
  public bool endImmediate;

  public void OnEnable() => SteamUtils.OnGamepadTextInputDismissed += new Action<bool>(this.GamepadTextInputDismissed);

  public void OnDisable() => SteamUtils.OnGamepadTextInputDismissed -= new Action<bool>(this.GamepadTextInputDismissed);

  public void GamepadTextInputDismissed(bool success)
  {
    if (success)
    {
      this.inputField.text = SteamUtils.GetEnteredGamepadText();
      this.Confirm();
    }
    else
      this.Cancel();
  }

  public void SetUnit(Entity unit)
  {
    this.unit = unit;
    if (!(this.inputField.placeholder is TMP_Text placeholder))
      return;
    placeholder.text = unit.data.title;
  }

  public override IEnumerator Run()
  {
    RenameCompanionSequence companionSequence = this;
    companionSequence.endImmediate = false;
    companionSequence.inputField.text = "";
    UIAnchors anchors = companionSequence.GetComponent<UIAnchors>();
    foreach (UIAnchors.AnchorPoint anchorPoint in anchors.list)
    {
      anchorPoint.Deactivate();
      anchorPoint.SetUp();
    }
    yield return (object) Sequences.Wait(companionSequence.startDelay);
    companionSequence.gameObject.SetActive(true);
    if ((double) companionSequence.unitMoveWobble != 0.0 && (UnityEngine.Object) companionSequence.unit.wobbler != (UnityEngine.Object) null)
      companionSequence.unit.wobbler.WobbleRandom(companionSequence.unitMoveWobble);
    Transform transform = companionSequence.unit.transform;
    companionSequence.unitPreParent = transform.parent;
    companionSequence.unitPrePosition = transform.localPosition;
    companionSequence.unitPreRotation = transform.localEulerAngles;
    companionSequence.unitPreScale = transform.localScale;
    companionSequence.unit.transform.SetParent(companionSequence.cardHolder, true);
    LeanTween.cancel(companionSequence.unit.gameObject);
    LeanTween.moveLocal(companionSequence.unit.gameObject, Vector3.zero, companionSequence.unitMoveDur).setEase(companionSequence.unitMoveCurve);
    LeanTween.rotateLocal(companionSequence.unit.gameObject, Vector3.zero, companionSequence.unitMoveDur).setEase(companionSequence.unitMoveCurve);
    LeanTween.scale(companionSequence.unit.gameObject, Vector3.one, companionSequence.unitMoveDur).setEase(companionSequence.unitMoveCurve);
    SfxSystem.OneShot("event:/sfx/ui/card_renaming_open");
    int c = anchors.Count;
    for (int i = 0; i < c; ++i)
    {
      anchors.Activate(i);
      yield return (object) null;
      companionSequence.StartCoroutine(anchors.Reveal(i));
      yield return (object) Sequences.Wait(companionSequence.delayBetween);
    }
    companionSequence.StartCoroutine(anchors.UpdatePositions());
    if (SteamManager.init)
      SteamUtils.ShowGamepadTextInput(GamepadTextInputMode.Normal, GamepadTextInputLineMode.SingleLine, "", 20, companionSequence.unit.data.title);
    while (!companionSequence.promptEnd)
      yield return (object) null;
    companionSequence.promptEnd = false;
    if (!companionSequence.endImmediate && (UnityEngine.Object) companionSequence.unit != (UnityEngine.Object) null)
    {
      companionSequence.unit.transform.SetParent(companionSequence.unitPreParent, true);
      LeanTween.cancel(companionSequence.unit.gameObject);
      LeanTween.moveLocal(companionSequence.unit.gameObject, companionSequence.unitPrePosition, companionSequence.unitMoveDur).setEase(companionSequence.unitMoveCurve);
      LeanTween.rotateLocal(companionSequence.unit.gameObject, companionSequence.unitPreRotation, companionSequence.unitMoveDur).setEase(companionSequence.unitMoveCurve);
      LeanTween.scale(companionSequence.unit.gameObject, companionSequence.unitPreScale, companionSequence.unitMoveDur).setEase(companionSequence.unitMoveCurve);
    }
    companionSequence.gameObject.SetActive(false);
  }

  public void Confirm()
  {
    if (!this.inputField.text.IsNullOrWhitespace())
    {
      Entity unit = this.unit;
      string text = this.inputField.text;
      if (Events.CheckRename(ref unit, ref text))
      {
        SfxSystem.OneShot("event:/sfx/ui/card_renaming_accept");
        unit.data.forceTitle = text;
        if (unit.display is Card display)
          display.SetName(unit.data.title);
        Events.InvokeRename(unit, text);
      }
    }
    this.End();
  }

  public void Cancel() => this.End();

  public void EndImmediate()
  {
    this.endImmediate = true;
    this.End();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: RenameMidBattleSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class RenameMidBattleSystem : MonoBehaviour
{
  public void OnEnable() => global::Events.OnRename += new UnityAction<Entity, string>(this.Rename);

  public void OnDisable() => global::Events.OnRename -= new UnityAction<Entity, string>(this.Rename);

  public void Rename(Entity entity, string newName)
  {
    foreach (Entity card in References.Battle.cards)
    {
      if (card.inPlay && (long) card.data.id == (long) entity.data.id && card.display is Card display)
        display.SetName(newName);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: RenderTextureCreator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;

public class RenderTextureCreator : MonoBehaviour
{
  [SerializeField]
  public int width;
  [SerializeField]
  public int height;
  [SerializeField]
  public GraphicsFormat colorFormat;
  [SerializeField]
  public GraphicsFormat depthStencilFormat;
  [SerializeField]
  public int mipCount;
  [SerializeField]
  public bool destroyOnDisable = true;
  [SerializeField]
  public UnityEvent<RenderTexture> onCreate;
  public RenderTexture rt;

  public void OnEnable()
  {
    if ((Object) this.rt != (Object) null)
      this.rt.Destroy();
    this.rt = new RenderTexture(this.width, this.height, this.colorFormat, this.depthStencilFormat, this.mipCount);
    this.onCreate.Invoke(this.rt);
  }

  public void OnDisable()
  {
    if (!this.destroyOnDisable || !((Object) this.rt != (Object) null))
      return;
    this.rt.Destroy();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: RewardData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "RewardData", menuName = "Reward Data")]
public class RewardData : ScriptableObject
{
  public string title;
  public string description;
  public Sprite icon;
  public GameObject buttonPrefab;
  public UISequence selectionScreenPrefab;
  public string acquireScript;
  public string[] acquireScriptArgs;
  public Sprite setCampaignNodeIcon;
}
﻿// Decompiled with JetBrains decompiler
// Type: RewardPool
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Reward Pool", fileName = "RewardPool")]
public class RewardPool : ScriptableObject
{
  public string type;
  public int copies = 1;
  public List<DataFile> list;
  public bool isGeneralPool;

  public enum Type
  {
    Items,
    Units,
    Charms,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: RewiredControllerManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Rewired;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class RewiredControllerManager : MonoBehaviour
{
  public static RewiredControllerManager instance;
  public int maxPlayers = 4;
  public static readonly List<RewiredControllerManager.PlayerMap> playerMaps = new List<RewiredControllerManager.PlayerMap>();
  public static int gamePlayerIdCounter = 0;
  public static Player leadPlayer;
  public const int maxJoysticksPerPlayer = 1;

  public void Awake()
  {
    if ((bool) (UnityEngine.Object) RewiredControllerManager.instance && (UnityEngine.Object) RewiredControllerManager.instance != (UnityEngine.Object) this)
    {
      UnityEngine.Object.Destroy((UnityEngine.Object) this);
    }
    else
    {
      RewiredControllerManager.instance = this;
      this.AssignNextPlayer(0);
    }
  }

  public void OnEnable()
  {
    ReInput.ControllerConnectedEvent += new Action<ControllerStatusChangedEventArgs>(RewiredControllerManager.ControllerConnected);
    ReInput.ControllerDisconnectedEvent += new Action<ControllerStatusChangedEventArgs>(RewiredControllerManager.ControllerDisconnected);
  }

  public void OnDisable()
  {
    ReInput.ControllerConnectedEvent -= new Action<ControllerStatusChangedEventArgs>(RewiredControllerManager.ControllerConnected);
    ReInput.ControllerDisconnectedEvent -= new Action<ControllerStatusChangedEventArgs>(RewiredControllerManager.ControllerDisconnected);
  }

  public static void ControllerConnected(ControllerStatusChangedEventArgs args)
  {
    Player playerController = RewiredControllerManager.GetPlayerController(0);
    bool flag = false;
    for (int index = playerController.controllers.joystickCount + 1; index > 1; --index)
    {
      playerController.controllers.RemoveController((Controller) playerController.controllers.Joysticks[0]);
      flag = true;
    }
    if (!playerController.controllers.ContainsController(args.controller))
    {
      playerController.controllers.AddController(args.controller, true);
      flag = true;
    }
    if (!flag)
      return;
    Debug.LogWarning((object) ("Rewired: [" + playerController.name + "] controllers → " + string.Join(", ", playerController.controllers.Controllers.Select<Controller, string>((Func<Controller, string>) (a => a.name)))));
    Events.InvokeControllerSwitched();
  }

  public static void ControllerDisconnected(ControllerStatusChangedEventArgs args)
  {
    Player playerController = RewiredControllerManager.GetPlayerController(0);
    bool flag = false;
    if (playerController.controllers.ContainsController(args.controller))
    {
      playerController.controllers.RemoveController(args.controller);
      flag = true;
    }
    int num = playerController.controllers.joystickCount - 1;
    if (num < 1)
    {
      foreach (Joystick joystick in (IEnumerable<Joystick>) ReInput.controllers.Joysticks)
      {
        if (!playerController.controllers.ContainsController((Controller) joystick))
        {
          playerController.controllers.AddController((Controller) joystick, true);
          flag = true;
          if (++num >= 1)
            break;
        }
      }
    }
    if (!flag)
      return;
    Debug.LogWarning((object) ("Rewired: [" + playerController.name + "] controllers → " + string.Join(", ", playerController.controllers.Controllers.Select<Controller, string>((Func<Controller, string>) (a => a.name)))));
    Events.InvokeControllerSwitched();
  }

  public Player AssignNextPlayer(int rewiredPlayerId)
  {
    RewiredControllerManager.PlayerMap playerMap = RewiredControllerManager.playerMaps.FirstOrDefault<RewiredControllerManager.PlayerMap>((Func<RewiredControllerManager.PlayerMap, bool>) (a => a.rewiredPlayerId == rewiredPlayerId));
    if (playerMap != null)
      return ReInput.players.GetPlayer(playerMap.rewiredPlayerId);
    Debug.Log((object) string.Format("ControllerManager → Assigning Player {0}", (object) rewiredPlayerId));
    if (RewiredControllerManager.playerMaps.Count >= this.maxPlayers)
    {
      Debug.LogError((object) "Max player limit already reached!");
      return (Player) null;
    }
    int nextGamePlayerId = this.GetNextGamePlayerId();
    RewiredControllerManager.playerMaps.Add(new RewiredControllerManager.PlayerMap(rewiredPlayerId, nextGamePlayerId));
    Player player = ReInput.players.GetPlayer(rewiredPlayerId);
    Debug.Log((object) string.Format("Assigning Rewired Player id {0} to Game Player {1}", (object) rewiredPlayerId, (object) nextGamePlayerId));
    if (RewiredControllerManager.leadPlayer == null)
    {
      Debug.Log((object) string.Format("Player {0} set as lead player", (object) rewiredPlayerId));
      RewiredControllerManager.leadPlayer = player;
    }
    if (player.controllers.joystickCount < 1)
    {
      foreach (Joystick joystick in (IEnumerable<Joystick>) ReInput.controllers.Joysticks)
      {
        if (!player.controllers.Joysticks.Contains(joystick))
        {
          player.controllers.AddController((Controller) joystick, true);
          if (player.controllers.joystickCount >= 1)
            break;
        }
      }
    }
    Debug.LogWarning((object) ("Rewired: [" + player.name + "] controllers → " + string.Join(", ", player.controllers.Controllers.Select<Controller, string>((Func<Controller, string>) (a => a.name)))));
    return player;
  }

  public void AssignJoystickMap(Player rewiredPlayer, string newMap)
  {
    rewiredPlayer.controllers.maps.SetAllMapsEnabled(false);
    rewiredPlayer.controllers.maps.SetMapsEnabled(true, newMap);
  }

  public void AssignJoystickMap(int playerNumber, string newMap) => this.AssignJoystickMap(RewiredControllerManager.GetPlayerController(playerNumber), newMap);

  public int GetNextGamePlayerId() => RewiredControllerManager.gamePlayerIdCounter++;

  public List<RewiredControllerManager.PlayerMap> GetActiveDevices() => RewiredControllerManager.playerMaps;

  public IList<Player> GetPlayers() => ReInput.players.GetPlayers();

  public static Player GetPlayerController(int gamePlayerId)
  {
    if (!ReInput.isReady)
      return (Player) null;
    if (!(bool) (UnityEngine.Object) RewiredControllerManager.instance)
    {
      Debug.LogError((object) "Not initialized. Do you have a PressStartToJoinPlayerSelector in your scene?");
      return (Player) null;
    }
    RewiredControllerManager.PlayerMap playerMap = RewiredControllerManager.playerMaps.FirstOrDefault<RewiredControllerManager.PlayerMap>((Func<RewiredControllerManager.PlayerMap, bool>) (a => a.gamePlayerId == gamePlayerId));
    return playerMap == null ? RewiredControllerManager.instance.AssignNextPlayer(gamePlayerId) : ReInput.players.GetPlayer(playerMap.rewiredPlayerId);
  }

  public static int GetPlayerID(int rewiredControllerID)
  {
    if (!ReInput.isReady)
      return -1;
    if ((UnityEngine.Object) RewiredControllerManager.instance == (UnityEngine.Object) null)
    {
      Debug.LogError((object) "Not initialized. Do you have a PressStartToJoinPlayerSelector in your scehe?");
      return -1;
    }
    foreach (RewiredControllerManager.PlayerMap playerMap in RewiredControllerManager.playerMaps)
    {
      if (playerMap.rewiredPlayerId == rewiredControllerID)
        return playerMap.gamePlayerId;
    }
    return -1;
  }

  public void ClearAssignedControllers()
  {
    foreach (RewiredControllerManager.PlayerMap playerMap in RewiredControllerManager.playerMaps)
      playerMap.gamePlayerId = -1;
  }

  public bool IsPlayerControllerConnected(int playerIndex) => RewiredControllerManager.playerMaps.Count<RewiredControllerManager.PlayerMap>((Func<RewiredControllerManager.PlayerMap, bool>) (x => x.gamePlayerId == playerIndex)) > 0;

  public bool IsControllerConnected(int controllerIndex) => ReInput.players.Players.Count<Player>((Func<Player, bool>) (x => x.id == controllerIndex)) > 0;

  public void AssignControllerToPlayer(int i, int controllerIndex) => RewiredControllerManager.playerMaps.First<RewiredControllerManager.PlayerMap>((Func<RewiredControllerManager.PlayerMap, bool>) (x => x.rewiredPlayerId == controllerIndex)).gamePlayerId = i;

  public bool AnyControllerConnected() => RewiredControllerManager.playerMaps.Count > 0;

  public bool IsButtonPressed(string input = "", bool IsPositive = true)
  {
    if (!this.enabled)
      return false;
    int callingPlayer = -1;
    return this.IsButtonPressed(out callingPlayer, input, IsPositive);
  }

  public bool IsButtonPressed(out int callingPlayer, string input = "", bool IsPositive = true)
  {
    bool state = false;
    callingPlayer = -1;
    if (IsPositive)
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (player.GetAnyButtonDown() ? 1 : 0) : (player.GetButtonDown(input) ? 1 : 0)) != 0)
        {
          RewiredControllerManager.instance.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    else
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (player.GetAnyNegativeButtonDown() ? 1 : 0) : (player.GetNegativeButtonDown(input) ? 1 : 0)) != 0)
        {
          RewiredControllerManager.instance.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    return state;
  }

  public bool IsButtonHeld(string input = "", bool IsPositive = true)
  {
    if (!this.enabled)
      return false;
    int callingPlayer = -1;
    return this.IsButtonHeld(out callingPlayer, input, IsPositive);
  }

  public bool IsButtonHeld(out int callingPlayer, string input = "", bool IsPositive = true)
  {
    bool state = false;
    callingPlayer = -1;
    if (IsPositive)
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (player.GetAnyButton() ? 1 : (player.GetAnyNegativeButton() ? 1 : 0)) : (player.GetButton(input) ? 1 : 0)) != 0)
        {
          this.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    else
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (player.GetAnyButton() ? 1 : (player.GetAnyNegativeButton() ? 1 : 0)) : (player.GetNegativeButton(input) ? 1 : 0)) != 0)
        {
          this.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    return state;
  }

  public bool IsButtonLongHeld(string input = "", bool IsPositive = true)
  {
    if (!this.enabled)
      return false;
    int callingPlayer = -1;
    return this.IsButtonLongHeld(out callingPlayer, input, IsPositive);
  }

  public bool IsButtonLongHeld(out int callingPlayer, string input = "", bool IsPositive = true)
  {
    bool state = false;
    callingPlayer = -1;
    if (IsPositive)
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (player.GetAnyButton() ? 1 : 0) : (player.GetButtonLongPress(input) ? 1 : 0)) != 0)
        {
          this.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    else
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (player.GetAnyNegativeButton() ? 1 : 0) : (player.GetNegativeButtonLongPress(input) ? 1 : 0)) != 0)
        {
          this.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    return state;
  }

  public bool IsButtonReleased(string input = "", bool IsPositive = true)
  {
    if (!this.enabled)
      return false;
    int callingPlayer = -1;
    return this.IsButtonReleased(out callingPlayer, input, IsPositive);
  }

  public bool IsButtonReleased(out int callingPlayer, string input = "", bool IsPositive = true)
  {
    bool state = false;
    callingPlayer = -1;
    if (IsPositive)
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (player.GetAnyButtonUp() ? 1 : 0) : (player.GetButtonUp(input) ? 1 : 0)) != 0)
        {
          this.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    else
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (player.GetAnyNegativeButtonUp() ? 1 : 0) : (player.GetNegativeButtonUp(input) ? 1 : 0)) != 0)
        {
          this.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    return state;
  }

  public bool WasButtonReleased(string input = "", bool IsPositive = true)
  {
    int callingPlayer = -1;
    return this.WasButtonReleased(out callingPlayer, input, IsPositive);
  }

  public bool WasButtonReleased(out int callingPlayer, string input = "", bool IsPositive = true)
  {
    bool state = false;
    callingPlayer = -1;
    if (IsPositive)
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (!player.GetAnyButtonPrev() ? 1 : 0) : (!player.GetButtonPrev(input) ? 1 : 0)) != 0)
        {
          this.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    else
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (!player.GetAnyNegativeButtonPrev() ? 1 : 0) : (!player.GetNegativeButtonPrev(input) ? 1 : 0)) != 0)
        {
          this.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    return state;
  }

  public bool WasButtonPressed(string input = "", bool IsPositive = true)
  {
    int callingPlayer = -1;
    return this.WasButtonPressed(out callingPlayer, input, IsPositive);
  }

  public bool WasButtonPressed(out int callingPlayer, string input = "", bool IsPositive = true)
  {
    bool state = false;
    callingPlayer = -1;
    if (IsPositive)
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (player.GetAnyButtonPrev() ? 1 : 0) : (player.GetButtonPrev(input) ? 1 : 0)) != 0)
        {
          this.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    else
    {
      foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
      {
        if ((input == "" ? (player.GetAnyNegativeButtonPrev() ? 1 : 0) : (player.GetNegativeButtonPrev(input) ? 1 : 0)) != 0)
        {
          this.ReturnTrueWithPlayer(out callingPlayer, out state, player);
          break;
        }
      }
    }
    return state;
  }

  public float GetAnalogPositive(string input = "")
  {
    if (!this.enabled)
      return 0.0f;
    int callingPlayer = -1;
    return this.GetAnalog(out callingPlayer, input, true);
  }

  public float GetAnalogNegative(string input = "")
  {
    if (!this.enabled)
      return 0.0f;
    int callingPlayer = -1;
    return this.GetAnalog(out callingPlayer, input, false);
  }

  public float GetAnalog(string input = "")
  {
    if (!this.enabled)
      return 0.0f;
    float f = 0.0f;
    foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
    {
      float axis = player.GetAxis(input);
      if ((double) Mathf.Abs(axis) > (double) Mathf.Abs(f))
        f = axis;
    }
    return f;
  }

  public float GetAnalog(out int callingPlayer, string input, bool lookingForPositive)
  {
    float analog = 0.0f;
    callingPlayer = -1;
    foreach (Player player in (IEnumerable<Player>) ReInput.players.GetPlayers())
    {
      Player x = player;
      if (lookingForPositive)
      {
        if ((double) x.GetAxis(input) > (double) analog)
        {
          callingPlayer = RewiredControllerManager.playerMaps.Count<RewiredControllerManager.PlayerMap>((Func<RewiredControllerManager.PlayerMap, bool>) (y => y.rewiredPlayerId == x.id)) <= 0 ? -1 : RewiredControllerManager.playerMaps.First<RewiredControllerManager.PlayerMap>((Func<RewiredControllerManager.PlayerMap, bool>) (y => y.rewiredPlayerId == x.id)).gamePlayerId;
          analog = x.GetAxis(input);
        }
      }
      else if ((double) x.GetAxis(input) < (double) analog)
      {
        callingPlayer = RewiredControllerManager.playerMaps.Count<RewiredControllerManager.PlayerMap>((Func<RewiredControllerManager.PlayerMap, bool>) (y => y.rewiredPlayerId == x.id)) <= 0 ? -1 : RewiredControllerManager.playerMaps.First<RewiredControllerManager.PlayerMap>((Func<RewiredControllerManager.PlayerMap, bool>) (y => y.rewiredPlayerId == x.id)).gamePlayerId;
        analog = x.GetAxis(input);
      }
    }
    return analog;
  }

  public void ReturnTrueWithPlayer(out int callingPlayer, out bool state, Player x)
  {
    callingPlayer = RewiredControllerManager.playerMaps.Count<RewiredControllerManager.PlayerMap>((Func<RewiredControllerManager.PlayerMap, bool>) (y => y.rewiredPlayerId == x.id)) <= 0 ? -1 : RewiredControllerManager.playerMaps.First<RewiredControllerManager.PlayerMap>((Func<RewiredControllerManager.PlayerMap, bool>) (y => y.rewiredPlayerId == x.id)).gamePlayerId;
    state = true;
  }

  public int GetDeviceCount() => RewiredControllerManager.playerMaps.Count<RewiredControllerManager.PlayerMap>();

  public void SetActiveControllersToMap(string newControllerMap)
  {
    foreach (RewiredControllerManager.PlayerMap activeDevice in RewiredControllerManager.instance.GetActiveDevices())
      RewiredControllerManager.instance.AssignJoystickMap(activeDevice.gamePlayerId, newControllerMap);
  }

  public class PlayerMap
  {
    public int rewiredPlayerId;
    public int gamePlayerId;

    public PlayerMap(int rewiredPlayerId, int gamePlayerId)
    {
      this.rewiredPlayerId = rewiredPlayerId;
      this.gamePlayerId = gamePlayerId;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: RewiredHotKeyController
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class RewiredHotKeyController : MonoBehaviour
{
  [SerializeField]
  public string HotKeyString;
  public UINavigationLayer uINavigationLayer;
  public Button uiButton;
  public EventTrigger eventTrigger;
  public UnityEvent OnHotKeyPressed;
  public bool ignoreLayers;
  public bool ignoreActivateCooldown;
  public HotKeyDisplay display;
  [Header("Keyboard")]
  [SerializeField]
  public bool hasKeyboardInput;
  [SerializeField]
  [ShowIf("hasKeyboardInput")]
  public KeyCode keyboardAction;
  public bool press;
  public static int ActivateCooldown;
  public static RewiredHotKeyController ActivateCooldownInstance;

  public bool IsHotKeyHeld()
  {
    if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      return InputSystem.IsButtonHeld(this.HotKeyString);
    return this.hasKeyboardInput && Input.GetKey(this.keyboardAction);
  }

  public bool IsHotKeyPressed()
  {
    if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      return InputSystem.IsButtonPressed(this.HotKeyString);
    return this.hasKeyboardInput && Input.GetKeyDown(this.keyboardAction);
  }

  public void SetActionName(string value)
  {
    this.HotKeyString = value;
    if (!(bool) (Object) this.display)
      return;
    this.display.SetActionName(value);
  }

  public void Update()
  {
    if (RewiredHotKeyController.ActivateCooldown > 0 && (Object) RewiredHotKeyController.ActivateCooldownInstance == (Object) this && --RewiredHotKeyController.ActivateCooldown <= 0)
      RewiredHotKeyController.ActivateCooldownInstance = (RewiredHotKeyController) null;
    if ((this.ignoreLayers ? 1 : ((Object) MonoBehaviourSingleton<UINavigationSystem>.instance.lastActiveNavigationLayer == (Object) this.uINavigationLayer ? 1 : 0)) != 0 && (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse || this.hasKeyboardInput))
    {
      if (this.press)
      {
        if (!InputSystem.Enabled || InputSystem.reset)
        {
          this.press = false;
          this.Release();
        }
        else
        {
          if (this.IsHotKeyHeld())
            return;
          if (RewiredHotKeyController.ActivateCooldown > 0 && (bool) (Object) RewiredHotKeyController.ActivateCooldownInstance)
          {
            if (!this.ignoreActivateCooldown)
              this.press = false;
          }
          else
          {
            RewiredHotKeyController.ActivateCooldown = 5;
            RewiredHotKeyController.ActivateCooldownInstance = this;
          }
          this.Release();
        }
      }
      else
      {
        if (!this.IsHotKeyPressed())
          return;
        this.Press();
      }
    }
    else
    {
      if (!this.press)
        return;
      this.press = false;
      this.Release();
    }
  }

  public void OnDisable()
  {
    if (RewiredHotKeyController.ActivateCooldown <= 0 || !((Object) RewiredHotKeyController.ActivateCooldownInstance == (Object) this))
      return;
    RewiredHotKeyController.ActivateCooldown = 0;
    RewiredHotKeyController.ActivateCooldownInstance = (RewiredHotKeyController) null;
  }

  public void Press()
  {
    this.press = true;
    if (!(bool) (Object) this.eventTrigger || !this.eventTrigger.enabled)
      return;
    this.eventTrigger.OnPointerDown((PointerEventData) null);
  }

  public void Release()
  {
    if (this.press)
      this.Invoke();
    if ((bool) (Object) this.eventTrigger)
    {
      if (this.press && this.eventTrigger.enabled)
        this.eventTrigger.OnPointerClick((PointerEventData) null);
      this.eventTrigger.OnPointerUp((PointerEventData) null);
    }
    this.press = false;
  }

  public void Invoke()
  {
    if (this.OnHotKeyPressed != null && this.OnHotKeyPressed.GetPersistentEventCount() > 0)
    {
      this.OnHotKeyPressed.Invoke();
    }
    else
    {
      if (!(bool) (Object) this.uiButton || !this.uiButton.interactable)
        return;
      this.uiButton.onClick?.Invoke();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Routine
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;

public class Routine
{
  public readonly CoroutineManager.State task;

  public event Routine.FinishedHandler Finished;

  public bool IsRunning => this.task.IsRunning;

  public bool IsPaused => this.task.IsPaused;

  public Routine(IEnumerator c, bool autoStart = true)
  {
    this.task = CoroutineManager.Create(c);
    this.task.Finished += new CoroutineManager.State.FinishedHandler(this.TaskFinished);
    if (!autoStart)
      return;
    this.Start();
  }

  public static Routine Create(IEnumerator c, bool autoStart = true) => new Routine(c, autoStart);

  public void Start() => this.task.Start();

  public void Stop() => this.task.Stop();

  public void Pause() => this.task.Pause();

  public void Unpause() => this.task.Unpause();

  public void TaskFinished(bool manual)
  {
    Routine.FinishedHandler finished = this.Finished;
    if (finished == null)
      return;
    finished(manual);
  }

  public delegate void FinishedHandler(bool manualStop);

  public class Clump
  {
    public readonly List<Routine> list = new List<Routine>();

    public int Count => this.list.Count;

    public static Routine.Clump Create(params IEnumerator[] routines)
    {
      Routine.Clump clump = new Routine.Clump();
      foreach (IEnumerator routine in routines)
        clump.Add(routine);
      return clump;
    }

    public void Add(Routine item) => this.list.Add(item);

    public void Add(IEnumerator c) => this.Add(new Routine(c));

    public IEnumerator WaitForEnd()
    {
      while (this.Count > 0)
      {
        bool flag = false;
        foreach (Routine routine in this.list)
        {
          if (routine != null && routine.IsRunning)
          {
            flag = true;
            break;
          }
        }
        if (!flag)
          break;
        yield return (object) null;
      }
    }

    public void Clear()
    {
      foreach (Routine routine in this.list)
        routine.Stop();
      this.list.Clear();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: RunHistory
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class RunHistory
{
  public string gameModeName;
  public Campaign.Result result;
  public CampaignStats stats;
  public ClassSaveData tribe;
  public InventorySaveData inventory;

  public RunHistory()
  {
  }

  public RunHistory(
    GameMode gameMode,
    Campaign.Result result,
    CampaignStats stats,
    PlayerData playerData)
  {
    this.gameModeName = gameMode.name;
    this.result = result;
    this.stats = stats;
    this.tribe = playerData.classData.Save();
    this.inventory = playerData.inventory.Save();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: RunHistorySystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class RunHistorySystem : GameSystem
{
  public const int max = 50;

  public void OnEnable() => global::Events.OnCampaignEnd += new UnityAction<Campaign.Result, CampaignStats, PlayerData>(RunHistorySystem.CampaignEnd);

  public void OnDisable() => global::Events.OnCampaignEnd -= new UnityAction<Campaign.Result, CampaignStats, PlayerData>(RunHistorySystem.CampaignEnd);

  public static void CampaignEnd(
    Campaign.Result result,
    CampaignStats stats,
    PlayerData playerData)
  {
    Debug.Log((object) "Saving Run History...");
    List<RunHistory> runHistoryList = SaveSystem.LoadHistoryData<List<RunHistory>>("list") ?? new List<RunHistory>();
    runHistoryList.Add(new RunHistory(Campaign.Data.GameMode, result, stats, playerData));
    if (runHistoryList.Count > 50)
      runHistoryList.RemoveAt(0);
    SaveSystem.SaveHistoryData<List<RunHistory>>("list", runHistoryList);
    Debug.Log((object) "Run History Saved!");
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: RunMultipleSequences
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class RunMultipleSequences : MonoBehaviour
{
  [SerializeField]
  public UISequence[] sequences;
  [SerializeField]
  public bool unloadSceneAfter = true;

  public IEnumerator Start()
  {
    RunMultipleSequences multipleSequences = this;
    UISequence[] uiSequenceArray = multipleSequences.sequences;
    for (int index = 0; index < uiSequenceArray.Length; ++index)
    {
      UISequence sequence = uiSequenceArray[index];
      sequence.gameObject.SetActive(true);
      yield return (object) sequence.Run();
      sequence.gameObject.SetActive(false);
      sequence = (UISequence) null;
    }
    uiSequenceArray = (UISequence[]) null;
    if (multipleSequences.unloadSceneAfter)
    {
      Routine routine = new Routine(SceneManager.Unload(multipleSequences.gameObject.scene.name));
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SaveBackupSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class SaveBackupSystem : GameSystem
{
  public const float backupCampaignTimer = 5f;
  public static float backupCampaignCooldown = 5f;

  public void OnEnable()
  {
    global::Events.OnCampaignStart += new UnityAction(SaveBackupSystem.CampaignStart);
    global::Events.OnCampaignSaved += new UnityAction(SaveBackupSystem.CampaignSaved);
  }

  public void OnDisable()
  {
    global::Events.OnCampaignStart -= new UnityAction(SaveBackupSystem.CampaignStart);
    global::Events.OnCampaignSaved -= new UnityAction(SaveBackupSystem.CampaignSaved);
  }

  public void Update()
  {
    if ((double) SaveBackupSystem.backupCampaignCooldown <= 0.0)
      return;
    SaveBackupSystem.backupCampaignCooldown -= Time.unscaledDeltaTime;
  }

  public static void CampaignStart()
  {
    string str = SaveSystem.folderName + "/";
    SaveBackupSystem.Backup(str + "Save.sav");
    SaveBackupSystem.Backup(str + "Stats.sav");
    SaveBackupSystem.Backup(str + "History.sav");
  }

  public static void CampaignSaved()
  {
    if ((double) SaveBackupSystem.backupCampaignCooldown > 0.0 || !(bool) (Object) References.Campaign || !Campaign.Data.GameMode.doSave)
      return;
    SaveBackupSystem.Backup(SaveSystem.folderName + "/" + "Campaign" + Campaign.Data.GameMode.saveFileName + ".sav");
    SaveBackupSystem.backupCampaignCooldown = 5f;
  }

  public static void Backup(string filePath)
  {
    StopWatch.Start();
    ES3.CreateBackup(filePath, SaveSystem.settings);
    Debug.Log((object) string.Format("Backup Created ({0}) ({1} ms)", (object) filePath, (object) StopWatch.Stop()));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SaveCollection`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;

[Serializable]
public struct SaveCollection<T> : ICloneable
{
  public T[] collection;

  public int Count => this.collection.Length;

  public T this[int index]
  {
    get => this.collection[index];
    set => this.collection[index] = value;
  }

  public SaveCollection(T[] collection) => this.collection = collection;

  public SaveCollection(List<T> collection) => this.collection = collection.ToArray();

  public SaveCollection(T item) => this.collection = new T[1]
  {
    item
  };

  public void Add(T item)
  {
    List<T> list = this.collection.ToList<T>();
    list.Add(item);
    this.collection = list.ToArray();
  }

  public void Remove(int index)
  {
    List<T> list = this.collection.ToList<T>();
    list.RemoveAt(index);
    this.collection = list.ToArray();
  }

  public object Clone() => (object) new SaveCollection<T>()
  {
    collection = ((IEnumerable<T>) this.collection).ToArray<T>()
  };
}
﻿// Decompiled with JetBrains decompiler
// Type: SaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Serializable]
public class SaveData
{
  public StatsSaveData stats;
  public CampaignSaveData[] runHistory;
}
﻿// Decompiled with JetBrains decompiler
// Type: SaveFileChecker
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class SaveFileChecker : MonoBehaviour
{
  public static bool saveRequired;

  public void Start()
  {
    Debug.Log((object) "~SAVE FILE CHECKER~");
    List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
    SaveFileChecker.GainUnlocksFromCompletedChallenges(unlockedList);
    SaveFileChecker.CheckChallengeUnlocks(unlockedList);
    SaveFileChecker.CheckUnlockRequirements(unlockedList);
    SaveFileChecker.saveRequired = unlockedList.RemoveDuplicates<string>() || SaveFileChecker.saveRequired;
    if (!SaveFileChecker.saveRequired)
      return;
    SaveSystem.SaveProgressData<List<string>>("unlocked", unlockedList);
  }

  public static void GainUnlocksFromCompletedChallenges(List<string> unlocksList)
  {
    IEnumerable<ChallengeData> allChallenges = ChallengeSystem.GetAllChallenges();
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>("completedChallenges", new List<string>());
    HashSet<string> stringSet = new HashSet<string>();
    foreach (string str in stringList)
    {
      string challengeName = str;
      ChallengeData challengeData = allChallenges.FirstOrDefault<ChallengeData>((Func<ChallengeData, bool>) (a => a.name == challengeName));
      if ((UnityEngine.Object) challengeData != (UnityEngine.Object) null)
      {
        UnlockData reward = challengeData.reward;
        if (reward != null)
          stringSet.AddRange<string>((IEnumerable<string>) SaveFileChecker.GetUnlockAndRequirements(reward));
      }
    }
    if (stringSet.Count <= 0)
      return;
    foreach (string str in stringSet.Where<string>((Func<string, bool>) (add => !unlocksList.Contains(add))))
      unlocksList.Add(str);
  }

  public static HashSet<string> GetUnlockAndRequirements(UnlockData unlockData)
  {
    HashSet<string> list = new HashSet<string>()
    {
      unlockData.name
    };
    foreach (UnlockData require in unlockData.requires)
      list.AddRange<string>((IEnumerable<string>) SaveFileChecker.GetUnlockAndRequirements(require));
    SaveFileChecker.saveRequired = true;
    return list;
  }

  public static void CheckChallengeUnlocks(List<string> unlocksList)
  {
    List<string> completedChallenges = SaveSystem.LoadProgressData<List<string>>("completedChallenges", new List<string>());
    ChallengeData[] array = ChallengeSystem.GetAllChallenges().Where<ChallengeData>((Func<ChallengeData, bool>) (a => !completedChallenges.Contains(a.name))).ToArray<ChallengeData>();
    List<string> removed = new List<string>();
    foreach (ChallengeData challengeData in array)
    {
      if (unlocksList.Remove(challengeData.reward.name))
      {
        removed.Add(challengeData.reward.name);
        Debug.Log((object) ("[" + challengeData.reward.name + "] removed from unlocks since [" + challengeData.name + "] is not completed"));
      }
    }
    if (removed.Count <= 0)
      return;
    SaveFileChecker.saveRequired = true;
    SaveSystem.SaveProgressData<List<string>>("inventorHutUnlocks", SaveSystem.LoadProgressData<List<string>>("inventorHutUnlocks", new List<string>()).Where<string>((Func<string, bool>) (a => !removed.Contains(a))).ToList<string>());
    SaveSystem.SaveProgressData<List<string>>("petHutUnlocks", SaveSystem.LoadProgressData<List<string>>("petHutUnlocks", new List<string>()).Where<string>((Func<string, bool>) (a => !removed.Contains(a))).ToList<string>());
  }

  public static void CheckUnlockRequirements(List<string> unlocksList)
  {
    bool flag = true;
    while (flag)
    {
      flag = false;
      for (int index = unlocksList.Count - 1; index >= 0; --index)
      {
        string unlocks = unlocksList[index];
        UnlockData unlockData = AddressableLoader.Get<UnlockData>("UnlockData", unlocks);
        if ((UnityEngine.Object) unlockData == (UnityEngine.Object) null)
        {
          Debug.Log((object) ("[" + unlocks + "] no longer exists. removing from save data"));
          unlocksList.RemoveAt(index);
          flag = true;
          SaveFileChecker.saveRequired = true;
        }
        else if (unlockData.requires != null && unlockData.requires.Length != 0)
        {
          foreach (UnlockData require in unlockData.requires)
          {
            if (!unlocksList.Contains(require.name))
            {
              Debug.Log((object) ("[" + unlocks + "] requirements are not met (requires [" + require.name + "]). removing from save data"));
              unlocksList.RemoveAt(index);
              flag = true;
              SaveFileChecker.saveRequired = true;
              break;
            }
          }
        }
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SaveSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using UnityEngine;
using UnityEngine.Events;

public class SaveSystem : GameSystem
{
  public static SaveSystem instance;
  [CompilerGenerated]
  public static string \u003CProfile\u003Ek__BackingField = "";
  public bool encode;
  [HideIf("encode")]
  public bool beautify;
  public bool promptSave;
  public bool busy;
  public static readonly string profileFolder = "Profiles";
  public static string folderName = "SaveData";
  public static SaveSystem.Saver progressSaver;
  public static SaveSystem.Saver campaignSaver;
  public static SaveSystem.Saver battleSaver;
  public static SaveSystem.Saver statsSaver;
  public static SaveSystem.Saver historySaver;
  public static ES3Settings settings;
  public static bool gotSaveTimestamp;
  public static DateTime saveTimestamp;

  public static bool Enabled => (UnityEngine.Object) SaveSystem.instance != (UnityEngine.Object) null && SaveSystem.instance.enabled;

  public static string Profile
  {
    get => SaveSystem.\u003CProfile\u003Ek__BackingField;
    set => SaveSystem.\u003CProfile\u003Ek__BackingField = value;
  }

  public void OnEnable() => global::Events.InvokeSaveSystemEnabled();

  public void OnDisable() => global::Events.InvokeSaveSystemDisabled();

  public void Awake() => SaveSystem.instance = this;

  public void Start()
  {
    SaveSystem.settings = new ES3Settings(new Enum[1]
    {
      (Enum) ES3.Directory.PersistentDataPath
    })
    {
      encryptionType = ES3.EncryptionType.AES,
      compressionType = ES3.CompressionType.Gzip,
      prettyPrint = false
    };
    SaveSystem.SetProfile(SaveSystem.GetProfile(), false);
    if (ES3.FileExists(SaveSystem.folderName + "/Save.sav"))
    {
      SaveSystem.gotSaveTimestamp = true;
      SaveSystem.saveTimestamp = ES3.GetTimestamp(SaveSystem.folderName + "/Save.sav");
    }
    SaveSystem.progressSaver = new SaveSystem.Saver("Save{0}.sav", SaveSystem.settings);
    SaveSystem.campaignSaver = new SaveSystem.Saver("Campaign{0}.sav", SaveSystem.settings);
    SaveSystem.battleSaver = new SaveSystem.Saver("Battle{0}.sav", SaveSystem.settings);
    SaveSystem.statsSaver = new SaveSystem.Saver("Stats{0}.sav", SaveSystem.settings);
    SaveSystem.historySaver = new SaveSystem.Saver("History{0}.sav", SaveSystem.settings);
    SaveSystem.EncryptSaveData();
    global::Events.OnSaveSystemProfileChanged += new UnityAction(SaveSystem.EncryptSaveData);
    SaveSystem.progressSaver.CheckBackup(SaveSystem.folderName);
    SaveSystem.campaignSaver.CheckBackup(SaveSystem.folderName);
    SaveSystem.campaignSaver.CheckBackup(SaveSystem.folderName, "Demo");
    SaveSystem.campaignSaver.CheckBackup(SaveSystem.folderName, "PressDemo");
    SaveSystem.battleSaver.CheckBackup(SaveSystem.folderName);
    SaveSystem.statsSaver.CheckBackup(SaveSystem.folderName);
    SaveSystem.historySaver.CheckBackup(SaveSystem.folderName);
  }

  public void OnDestroy() => global::Events.OnSaveSystemProfileChanged -= new UnityAction(SaveSystem.EncryptSaveData);

  public static void SaveProgressData<T>(string key, T value)
  {
    if (!SaveSystem.Enabled)
      return;
    SaveSystem.progressSaver.SaveValue<T>(key, value, SaveSystem.folderName);
  }

  public static void SaveCampaignData<T>(GameMode gameMode, string key, T value)
  {
    if (!SaveSystem.Enabled)
      return;
    SaveSystem.campaignSaver.SaveValue<T>(key, value, SaveSystem.folderName, gameMode.saveFileName);
  }

  public static void SaveStatsData<T>(string key, T value)
  {
    if (!SaveSystem.Enabled)
      return;
    SaveSystem.statsSaver.SaveValue<T>(key, value, SaveSystem.folderName);
  }

  public static void SaveHistoryData<T>(string key, T value)
  {
    if (!SaveSystem.Enabled)
      return;
    SaveSystem.historySaver.SaveValue<T>(key, value, SaveSystem.folderName);
  }

  public static T LoadProgressData<T>(string key) where T : class => SaveSystem.LoadProgressData<T>(key, default (T));

  public static T LoadCampaignData<T>(GameMode gameMode, string key) where T : class => SaveSystem.LoadCampaignData<T>(gameMode, key, default (T));

  public static T LoadStatsData<T>(string key) where T : class => SaveSystem.LoadStatsData<T>(key, default (T));

  public static T LoadHistoryData<T>(string key) where T : class => SaveSystem.LoadHistoryData<T>(key, default (T));

  public static T LoadProgressData<T>(string key, T defaultValue) => !SaveSystem.Enabled ? defaultValue : SaveSystem.progressSaver.LoadValue<T>(key, SaveSystem.folderName, defaultValue);

  public static T LoadCampaignData<T>(GameMode gameMode, string key, T defaultValue) => !SaveSystem.Enabled ? defaultValue : SaveSystem.campaignSaver.LoadValue<T>(key, SaveSystem.folderName, defaultValue, gameMode.saveFileName);

  public static T LoadStatsData<T>(string key, T defaultValue) => !SaveSystem.Enabled ? defaultValue : SaveSystem.statsSaver.LoadValue<T>(key, SaveSystem.folderName, defaultValue);

  public static T LoadHistoryData<T>(string key, T defaultValue) => !SaveSystem.Enabled ? defaultValue : SaveSystem.historySaver.LoadValue<T>(key, SaveSystem.folderName, defaultValue);

  public static bool ProgressExists() => SaveSystem.Enabled && SaveSystem.progressSaver.FileExists(SaveSystem.folderName);

  public static bool CampaignExists(GameMode gameMode) => SaveSystem.Enabled && SaveSystem.campaignSaver.FileExists(SaveSystem.folderName, gameMode.saveFileName);

  public static bool StatsExists() => SaveSystem.Enabled && SaveSystem.statsSaver.FileExists(SaveSystem.folderName);

  public static bool HistoryExists() => SaveSystem.Enabled && SaveSystem.historySaver.FileExists(SaveSystem.folderName);

  public static bool ProgressDataExists(string key) => SaveSystem.Enabled && SaveSystem.progressSaver.KeyExists(key, SaveSystem.folderName);

  public static bool CampaignDataExists(GameMode gameMode, string key) => SaveSystem.Enabled && SaveSystem.campaignSaver.KeyExists(key, SaveSystem.folderName, gameMode.saveFileName);

  public static bool StatsDataExists(string key) => SaveSystem.Enabled && SaveSystem.statsSaver.KeyExists(key, SaveSystem.folderName);

  public static bool HistoryDataExists(string key) => SaveSystem.Enabled && SaveSystem.historySaver.KeyExists(key, SaveSystem.folderName);

  public static void DeleteProgress()
  {
    if (!SaveSystem.Enabled)
      return;
    SaveSystem.progressSaver.Delete(SaveSystem.folderName);
  }

  public static void DeleteCampaign(GameMode gameMode)
  {
    if (!SaveSystem.Enabled)
      return;
    SaveSystem.campaignSaver.Delete(SaveSystem.folderName, gameMode.saveFileName);
  }

  public static void DeleteProfile(string profileName)
  {
    if (!SaveSystem.Enabled)
      return;
    ES3.DeleteDirectory(SaveSystem.folderName);
  }

  public static void DeleteStats()
  {
    if (!SaveSystem.Enabled)
      return;
    SaveSystem.statsSaver.Delete(SaveSystem.folderName);
  }

  public static void DeleteHistory()
  {
    if (!SaveSystem.Enabled)
      return;
    SaveSystem.historySaver.Delete(SaveSystem.folderName);
  }

  public static void DeleteProgressData(string key)
  {
    if (!SaveSystem.Enabled)
      return;
    SaveSystem.progressSaver.DeleteKey(key, SaveSystem.folderName);
  }

  public static string GetProfile()
  {
    try
    {
      return ES3.Load<string>("profile", "data.sav", "Default");
    }
    catch (Exception ex)
    {
      Debug.LogWarning((object) ex);
      return "Default";
    }
  }

  public static void SetProfile(string name, bool save = true)
  {
    Debug.Log((object) ("Save Profile Set: " + name));
    SaveSystem.Profile = name;
    SaveSystem.folderName = SaveSystem.profileFolder + "/" + name;
    if (SaveSystem.Enabled)
      global::Events.InvokeSaveSystemProfileChanged();
    if (!save)
      return;
    try
    {
      ES3.Save<string>("profile", name, "data.sav");
    }
    catch (Exception ex)
    {
      Debug.LogWarning((object) ex);
      ES3.DeleteFile("data.sav");
      ES3.Save<string>("profile", name, "data.sav");
    }
  }

  public static void EncryptSaveData()
  {
    ES3Settings defaultSettings = ES3Settings.defaultSettings;
    ES3Settings settings = SaveSystem.settings;
    SaveSystem.ConvertSaveFile(SaveSystem.progressSaver, SaveSystem.folderName, "", defaultSettings, settings);
    SaveSystem.ConvertSaveFile(SaveSystem.campaignSaver, SaveSystem.folderName, "", defaultSettings, settings);
    SaveSystem.ConvertSaveFile(SaveSystem.campaignSaver, SaveSystem.folderName, "Demo", defaultSettings, settings);
    SaveSystem.ConvertSaveFile(SaveSystem.statsSaver, SaveSystem.folderName, "", defaultSettings, settings);
  }

  public static void ConvertSaveFile(
    SaveSystem.Saver saver,
    string folder,
    string fileName,
    ES3Settings oldSettings,
    ES3Settings newSettings)
  {
    string str = string.Format(saver.baseFileName, (object) fileName);
    string filePath1 = SaveSystem.folderName + "/" + str;
    try
    {
      ES3.KeyExists("a", filePath1, newSettings);
      Debug.Log((object) ("[" + str + "] save file does not need converting"));
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      int num;
      switch (ex1)
      {
        case FormatException _:
        case ArgumentException _:
          num = 1;
          break;
        default:
          num = ex1 is CryptographicException ? 1 : 0;
          break;
      }
      if ((uint) num > 0U)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      Debug.LogWarning((object) ex1);
      Debug.LogWarning((object) ("[" + str + "] save file needs converting"));
      try
      {
        string filePath2 = folder + "/" + str;
        ES3.SaveRaw(ES3.LoadRawString(filePath2, oldSettings), filePath2, newSettings);
        Debug.Log((object) ("Successfully converted [" + str + "] to new file format"));
      }
      catch (Exception ex2)
      {
        Debug.LogWarning((object) ex2);
        Debug.LogWarning((object) ("Failed to convert [" + str + "] to new file format"));
      }
    }
  }

  public class Saver
  {
    public readonly string baseFileName;
    public readonly ES3Settings settings;

    public Saver(string baseFileName, ES3Settings settings = null)
    {
      this.baseFileName = baseFileName;
      this.settings = settings ?? ES3Settings.defaultSettings;
    }

    public void SaveValue<TValue>(string key, TValue value, string folderName, string fileName = "")
    {
      StopWatch.Start();
      string str = string.Format(this.baseFileName, (object) fileName);
      Debug.Log((object) ("Saving [" + str + "] (" + key + ")..."));
      string filePath = folderName + "/" + str;
      try
      {
        ES3.Save<TValue>(key, value, filePath, this.settings);
      }
      catch (InvalidOperationException ex)
      {
        Debug.LogWarning((object) ex);
      }
      catch (IOException ex)
      {
        Debug.LogWarning((object) ex);
      }
      Debug.Log((object) string.Format("Saving Done! ({0}ms)", (object) StopWatch.Stop()));
    }

    public TValue LoadValue<TValue>(
      string key,
      string folderName,
      TValue defaultValue,
      string fileName = "")
    {
      StopWatch.Start();
      string str = string.Format(this.baseFileName, (object) fileName);
      Debug.Log((object) ("Loading [" + str + "] (" + key + ")..."));
      string filePath = folderName + "/" + str;
      TValue obj = defaultValue;
      try
      {
        obj = ES3.Load<TValue>(key, filePath, defaultValue, this.settings);
      }
      catch (Exception ex1)
      {
        Debug.LogWarning((object) ex1);
        Debug.LogWarning((object) (filePath + " data appears to be corrupt, attempting to restore backup"));
        ES3.RestoreBackup(filePath, this.settings);
        try
        {
          obj = ES3.Load<TValue>(key, filePath, defaultValue, this.settings);
        }
        catch (Exception ex2)
        {
          Debug.LogWarning((object) "Failed to restore backup :( returning default value...");
        }
      }
      Debug.Log((object) string.Format("Loading Done! ({0}ms)", (object) StopWatch.Stop()));
      return obj;
    }

    public bool FileExists(string folderName, string fileName = "")
    {
      string str = string.Format(this.baseFileName, (object) fileName);
      return ES3.FileExists(folderName + "/" + str, this.settings);
    }

    public bool KeyExists(string key, string folderName, string fileName = "")
    {
      string str = string.Format(this.baseFileName, (object) fileName);
      string filePath = folderName + "/" + str;
      try
      {
        return ES3.KeyExists(key, filePath, this.settings);
      }
      catch (Exception ex1)
      {
        Debug.LogWarning((object) ex1);
        Debug.LogWarning((object) (filePath + " data appears to be corrupt, attempting to restore backup"));
        ES3.RestoreBackup(filePath, this.settings);
        try
        {
          return ES3.KeyExists(key, filePath, this.settings);
        }
        catch (Exception ex2)
        {
          Debug.LogWarning((object) "Failed to restore backup :( returning default value...");
          return false;
        }
      }
    }

    public void Delete(string folderName, string fileName = "")
    {
      string str = string.Format(this.baseFileName, (object) fileName);
      ES3.DeleteFile(folderName + "/" + str, this.settings);
    }

    public void DeleteKey(string key, string folderName, string fileName = "")
    {
      string str = string.Format(this.baseFileName, (object) fileName);
      ES3.DeleteKey(key, folderName + "/" + str, this.settings);
    }

    public void CheckBackup(string folderName, string fileName = "")
    {
      string str = string.Format(this.baseFileName, (object) fileName);
      string filePath = folderName + "/" + str;
      Debug.Log((object) ("Checking " + str + " for corrupt data..."));
      try
      {
        ES3.KeyExists("a", filePath, this.settings);
      }
      catch (Exception ex1)
      {
        Debug.LogWarning((object) ex1);
        Debug.LogWarning((object) (filePath + " data appears to be corrupt, attempting to restore backup"));
        ES3.RestoreBackup(filePath, this.settings);
        try
        {
          ES3.KeyExists("a", filePath, this.settings);
          Debug.Log((object) ("Successfully retrieved " + str + " backup"));
        }
        catch (Exception ex2)
        {
          Debug.LogWarning((object) "Failed to restore backup :(");
        }
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScaleBasedOnAspect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class ScaleBasedOnAspect : MonoBehaviour
{
  [SerializeField]
  public AnimationCurve curve;
  [SerializeField]
  public Vector3 maxScale;
  [SerializeField]
  public Vector3 minScale;
  [SerializeField]
  public bool autoLinkToParent;

  public void Awake()
  {
    if (!this.autoLinkToParent)
      return;
    WorldSpaceCanvasFitScreen componentInParent = this.transform.GetComponentInParent<WorldSpaceCanvasFitScreen>();
    if (!(bool) (Object) componentInParent)
      return;
    componentInParent.onUpdate.AddListener(new UnityAction<RectTransform>(this.UpdateScale));
    this.UpdateScale(componentInParent.rectTransform);
  }

  public void UpdateScale(RectTransform canvas)
  {
    Vector2 sizeDelta = canvas.sizeDelta;
    this.transform.localScale = this.minScale + (this.maxScale - this.minScale) * this.curve.Evaluate(sizeDelta.x / sizeDelta.y);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SceneLoader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class SceneLoader : MonoBehaviour
{
  public string sceneKey;
  public SceneType sceneType = SceneType.Temporary;
  public bool loading;

  public void Load()
  {
    if (this.loading)
      return;
    this.StopAllCoroutines();
    this.StartCoroutine(this.LoadRoutine());
  }

  public IEnumerator LoadRoutine()
  {
    this.loading = true;
    yield return (object) SceneManager.Load(this.sceneKey, this.sceneType);
    this.loading = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SceneManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.SceneManagement;

public static class SceneManager
{
  [CompilerGenerated]
  public static string \u003CActiveSceneKey\u003Ek__BackingField;
  [CompilerGenerated]
  public static string \u003CActiveSceneName\u003Ek__BackingField;
  public static readonly Dictionary<string, Scene> Loaded = new Dictionary<string, Scene>();
  public static readonly List<string> Temporary = new List<string>();
  public static readonly List<string> Loading = new List<string>();
  public static int jobsActive;

  public static string ActiveSceneKey
  {
    get => SceneManager.\u003CActiveSceneKey\u003Ek__BackingField;
    set => SceneManager.\u003CActiveSceneKey\u003Ek__BackingField = value;
  }

  public static string ActiveSceneName
  {
    get => SceneManager.\u003CActiveSceneName\u003Ek__BackingField;
    set => SceneManager.\u003CActiveSceneName\u003Ek__BackingField = value;
  }

  public static Scene GetActive() => SceneManager.Loaded[SceneManager.ActiveSceneKey];

  public static bool HasNoActiveJobs => SceneManager.jobsActive <= 0;

  public static IEnumerator Load(string sceneKey, SceneType type, Action<Scene> onComplete = null)
  {
    SceneManager.JobStart();
    sceneKey = sceneKey.Replace("Scenes/", "").Replace(".unity", "");
    Debug.Log((object) ("SceneManager → Loading Scene \"" + sceneKey + "\""));
    if (SceneManager.Loading.Contains(sceneKey))
      yield return (object) new WaitUntil((Func<bool>) (() => !SceneManager.Loading.Contains(sceneKey)));
    if (!SceneManager.IsLoaded(sceneKey))
    {
      yield return (object) SceneManager.Load(sceneKey, type, true);
      Events.InvokeSceneLoaded(SceneManager.Loaded[sceneKey]);
    }
    else
      Debug.Log((object) ("\"" + sceneKey + "\" already loaded"));
    if (type == SceneType.Active)
      yield return (object) SceneManager.SetActive(sceneKey);
    Action<Scene> action = onComplete;
    if (action != null)
      action(SceneManager.Loaded[sceneKey]);
    SceneManager.JobEnd();
  }

  public static IEnumerator Load(string sceneKey, SceneType type, bool activateOnLoad)
  {
    SceneManager.Loading.Add(sceneKey);
    AsyncOperation handle = UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(sceneKey, LoadSceneMode.Additive);
    while (!handle.isDone)
      yield return (object) null;
    SceneManager.Loaded[sceneKey] = UnityEngine.SceneManagement.SceneManager.GetSceneByName(sceneKey);
    SceneManager.Loading.Remove(sceneKey);
    Debug.Log((object) ("\"" + sceneKey + "\" Loaded"));
    if (type == SceneType.Temporary)
      SceneManager.Temporary.Add(sceneKey);
  }

  public static IEnumerator SetActive(string sceneKey)
  {
    Scene scene = SceneManager.Loaded[sceneKey];
    SceneManager.ActiveSceneName = scene.name;
    SceneManager.ActiveSceneKey = sceneKey;
    Events.InvokeSceneChanged(scene);
    yield return (object) SceneManager.UnloadTemporary();
  }

  public static IEnumerator Unload(string sceneKey)
  {
    if (!sceneKey.IsNullOrWhitespace())
    {
      Debug.Log((object) ("SceneManager → Unloading Scene \"" + sceneKey + "\""));
      if (SceneManager.IsLoaded(sceneKey))
      {
        Scene scene = SceneManager.Loaded[sceneKey];
        Events.InvokeSceneUnload(scene);
        AsyncOperation handle = UnityEngine.SceneManagement.SceneManager.UnloadSceneAsync(scene);
        while (!handle.isDone)
          yield return (object) null;
        Debug.Log((object) "Scene successfully unloaded");
        SceneManager.Loaded.Remove(sceneKey);
        SceneManager.Temporary.Remove(sceneKey);
        handle = (AsyncOperation) null;
      }
      else
        Debug.Log((object) "Scene is already unloaded...");
    }
  }

  public static IEnumerator UnloadActive()
  {
    Routine.Clump clump = new Routine.Clump();
    if (!SceneManager.ActiveSceneKey.IsNullOrWhitespace())
      clump.Add(SceneManager.Unload(SceneManager.ActiveSceneKey));
    clump.Add(SceneManager.UnloadTemporary());
    yield return (object) clump.WaitForEnd();
  }

  public static IEnumerator UnloadTemporary()
  {
    Routine.Clump clump = new Routine.Clump();
    foreach (string sceneKey in SceneManager.Temporary)
      clump.Add(SceneManager.Unload(sceneKey));
    yield return (object) clump.WaitForEnd();
  }

  public static bool IsLoaded(string sceneKey) => SceneManager.Loaded.ContainsKey(sceneKey);

  public static IEnumerator WaitUntilUnloaded(string sceneKey)
  {
    yield return (object) new WaitUntil((Func<bool>) (() => !SceneManager.Loaded.ContainsKey(sceneKey)));
  }

  public static void JobStart() => ++SceneManager.jobsActive;

  public static void JobEnd() => --SceneManager.jobsActive;
}
﻿// Decompiled with JetBrains decompiler
// Type: SceneRoutine
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

public class SceneRoutine : MonoBehaviour
{
  public virtual IEnumerator Run() => (IEnumerator) null;

  [Button(null, EButtonEnableMode.Always)]
  public void PromptRun()
  {
    if (!Application.isPlaying)
      return;
    Routine routine = new Routine(this.Run());
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SceneType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public enum SceneType
{
  Persistent,
  Active,
  Temporary,
}
﻿// Decompiled with JetBrains decompiler
// Type: SceneUnloader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class SceneUnloader : MonoBehaviour
{
  public bool active = true;

  public void Unload()
  {
    if (!this.active)
      return;
    this.active = false;
    Routine routine = new Routine(SceneManager.Unload(this.gameObject.scene.name));
  }

  public void UnloadAfter(float delay)
  {
    this.StopAllCoroutines();
    this.StartCoroutine(this.UnloadAfterRoutine(delay));
  }

  public IEnumerator UnloadAfterRoutine(float delay)
  {
    yield return (object) new WaitForSeconds(delay);
    this.Unload();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Scores
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Steamworks;
using Steamworks.Data;
using System;
using System.Threading.Tasks;
using UnityEngine;

public static class Scores
{
  public static string GetLeaderboardName(Scores.Type boardType, DateTime date)
  {
    string leaderboardName;
    switch (boardType)
    {
      case Scores.Type.TopScores:
        leaderboardName = nameof (Scores);
        break;
      case Scores.Type.Daily:
        leaderboardName = DailyFetcher.GetLeaderboardName(date);
        break;
      default:
        leaderboardName = "Unknown";
        break;
    }
    return leaderboardName;
  }

  public static async Task<LeaderboardUpdate?> Submit(
    Scores.Type type,
    DateTime date,
    int score,
    params int[] details)
  {
    string leaderboardName = Scores.GetLeaderboardName(type, date);
    Debug.Log((object) string.Format("> Submitting Score [{0}] to Leaderboard [{1}]", (object) score, (object) leaderboardName));
    Leaderboard? leaderboard = await Scores.GetLeaderboard(leaderboardName);
    return leaderboard.HasValue ? await leaderboard.Value.SubmitScoreAsync(score, details.Length != 0 ? details : (int[]) null) : new LeaderboardUpdate?();
  }

  public static async Task<Leaderboard?> GetLeaderboard(Scores.Type type, DateTime date) => !SteamManager.init ? new Leaderboard?() : await Scores.GetLeaderboard(Scores.GetLeaderboardName(type, date));

  public static async Task<Leaderboard?> GetLeaderboard(string leaderboardName) => !SteamManager.init ? new Leaderboard?() : await SteamUserStats.FindOrCreateLeaderboardAsync(leaderboardName, LeaderboardSort.Descending, LeaderboardDisplay.Numeric);

  public static async Task<LeaderboardEntry[]> GetGlobal(
    Leaderboard board,
    int entries,
    int offset)
  {
    return !SteamManager.init ? (LeaderboardEntry[]) null : await board.GetScoresAsync(entries, offset);
  }

  public static async Task<LeaderboardEntry[]> GetFriends(Leaderboard board, int entries) => !SteamManager.init ? (LeaderboardEntry[]) null : await board.GetScoresFromFriendsAsync();

  public static async Task<LeaderboardEntry[]> GetAround(Leaderboard board, int entries)
  {
    if (!SteamManager.init)
      return (LeaderboardEntry[]) null;
    int end = entries / 2;
    return await board.GetScoresAroundUserAsync(-end, end);
  }

  public enum Type
  {
    TopScores,
    Daily,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScoreSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using Steamworks.Data;
using System;
using System.Collections;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Localization;

public class ScoreSequence : MonoBehaviour
{
  [SerializeField]
  public TMP_Text timeText;
  [SerializeField]
  public TMP_Text timeScoreText;
  [SerializeField]
  public TMP_Text battlesText;
  [SerializeField]
  public TMP_Text battlesScoreText;
  [SerializeField]
  public TMP_Text goldText;
  [SerializeField]
  public TMP_Text goldScoreText;
  [SerializeField]
  public TMP_Text totalScoreText;
  [SerializeField]
  public TMP_Text globalRankText;
  [SerializeField]
  public LocalizedString totalStringRef;
  [SerializeField]
  public LocalizedString submittingStringRef;
  [SerializeField]
  public LocalizedString failedToSubmitStringRef;
  [SerializeField]
  public LocalizedString globalRankStringRef;
  [Header("SFX")]
  [SerializeField]
  public EventReference countSfx;
  [SerializeField]
  public EventReference countFinishSfx;
  [SerializeField]
  public EventReference countFinishFirstSfx;
  [CompilerGenerated]
  public bool \u003Crunning\u003Ek__BackingField;

  public bool running
  {
    get => this.\u003Crunning\u003Ek__BackingField;
    set => this.\u003Crunning\u003Ek__BackingField = value;
  }

  public IEnumerator Start()
  {
    yield return (object) this.Sequence();
  }

  public void OnDisable() => this.StopAllCoroutines();

  public IEnumerator Sequence()
  {
    this.running = true;
    this.totalScoreText.gameObject.SetActive(false);
    this.globalRankText.gameObject.SetActive(false);
    int submittedTime = ScoreSubmitSystem.SubmittedTime;
    int gold = ScoreSubmitSystem.SubmittedGold;
    int battlesWon = ScoreSubmitSystem.SubmittedBattlesWon;
    this.timeText.text = TimeSpan.FromSeconds((double) submittedTime).ToString();
    this.battlesText.text = battlesWon.ToString();
    this.goldText.text = gold.ToString();
    this.timeScoreText.text = "";
    this.battlesScoreText.text = "";
    this.goldScoreText.text = "";
    int scoreFromTime = ScoreSubmitSystem.GetScoreFromTime(References.Campaign.result == Campaign.Result.Win, submittedTime);
    Debug.Log((object) string.Format("Time Taken: {0} = {1} points", (object) this.timeText.text, (object) scoreFromTime));
    yield return (object) this.CountScoreUp(this.timeScoreText, "+{0}", "<#f40>{0}", scoreFromTime);
    int scoreFromBattlesWon = ScoreSubmitSystem.GetScoreFromBattlesWon(battlesWon);
    Debug.Log((object) string.Format("Battles Won: {0} = {1} points", (object) this.battlesText.text, (object) scoreFromBattlesWon));
    yield return (object) this.CountScoreUp(this.battlesScoreText, "+{0}", "<#f40>{0}", scoreFromBattlesWon);
    int scoreFromGold = ScoreSubmitSystem.GetScoreFromGold(gold);
    Debug.Log((object) string.Format("Blings: {0} = {1} points", (object) this.goldText.text, (object) scoreFromGold));
    yield return (object) this.CountScoreUp(this.goldScoreText, "+{0}", "<#f40>{0}", scoreFromGold);
    this.totalScoreText.gameObject.SetActive(true);
    int submittedScore = ScoreSubmitSystem.SubmittedScore;
    Debug.Log((object) string.Format("Final Score: {0}", (object) submittedScore));
    string localizedString = this.totalStringRef.GetLocalizedString();
    yield return (object) this.CountScoreUp(this.totalScoreText, string.Format(localizedString, (object) "<#ff0>{0}"), string.Format(localizedString, (object) "<#f40>{0}"), submittedScore);
    if (!this.countFinishSfx.IsNull)
      SfxSystem.OneShot(this.countFinishSfx);
    LeaderboardUpdate? result = ScoreSubmitSystem.result;
    if (result.HasValue && result.GetValueOrDefault().Changed)
    {
      result = ScoreSubmitSystem.result;
      int newGlobalRank = result.Value.NewGlobalRank;
      if (newGlobalRank > 0)
      {
        Debug.Log((object) string.Format("Global Rank: {0}", (object) newGlobalRank));
        this.globalRankText.gameObject.SetActive(true);
        this.globalRankText.text = string.Format(this.globalRankStringRef.GetLocalizedString(), (object) newGlobalRank);
        if (newGlobalRank == 1 && !this.countFinishFirstSfx.IsNull)
          SfxSystem.OneShot(this.countFinishFirstSfx);
      }
    }
    this.running = false;
  }

  public IEnumerator SetSubmitScoreText()
  {
    this.globalRankText.gameObject.SetActive(true);
    if (ScoreSubmitSystem.status == ScoreSubmitSystem.Status.Submitting)
    {
      string text = this.submittingStringRef.GetLocalizedString();
      this.globalRankText.text = text;
      float t = 1f;
      string dots = "";
      yield return (object) null;
      while (ScoreSubmitSystem.status == ScoreSubmitSystem.Status.Submitting)
      {
        t -= Time.deltaTime;
        if ((double) t <= 0.0)
        {
          ++t;
          dots = dots.Length < 3 ? dots + "." : "";
          this.globalRankText.text = text + dots;
        }
        yield return (object) null;
      }
      text = (string) null;
      dots = (string) null;
    }
    switch (ScoreSubmitSystem.status)
    {
      case ScoreSubmitSystem.Status.Failed:
        this.globalRankText.text = this.failedToSubmitStringRef.GetLocalizedString();
        break;
      case ScoreSubmitSystem.Status.Success:
        int? playerRank = ScoreSubmitSystem.playerRank;
        if (playerRank.HasValue)
        {
          playerRank = ScoreSubmitSystem.playerRank;
          int num = playerRank.Value;
          Debug.Log((object) string.Format("Global Rank: {0}", (object) num));
          this.globalRankText.text = string.Format(this.globalRankStringRef.GetLocalizedString(), (object) num);
          if (num != 1 || this.countFinishFirstSfx.IsNull)
            break;
          SfxSystem.OneShot(this.countFinishFirstSfx);
          break;
        }
        this.globalRankText.gameObject.SetActive(false);
        break;
    }
  }

  public IEnumerator CountScoreUp(
    TMP_Text element,
    string positiveFormat,
    string negativeFormat,
    int toScore,
    int fromScore = 0)
  {
    int v = fromScore;
    element.text = ScoreSequence.Format(positiveFormat, negativeFormat, fromScore);
    float time = Mathf.Clamp((float) toScore / 100f, 1f, 3f);
    float t = 0.0f;
    yield return (object) null;
    while ((double) t < (double) time)
    {
      t += Time.deltaTime;
      int num = fromScore + Mathf.RoundToInt(Mathf.Min(1f, t / time) * (float) (toScore - fromScore));
      element.text = ScoreSequence.Format(positiveFormat, negativeFormat, num);
      if (v != num && !this.countSfx.IsNull)
        SfxSystem.OneShot(this.countSfx);
      v = num;
      yield return (object) null;
    }
  }

  public static string Format(string positive, string negative, int value) => value < 0 ? string.Format(negative, (object) value) : string.Format(positive, (object) value);
}
﻿// Decompiled with JetBrains decompiler
// Type: ScoreSubmitSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Steamworks.Data;
using System;
using System.Collections;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Events;

public class ScoreSubmitSystem : GameSystem
{
  public static ScoreSubmitSystem instance;
  public const int StartScore = -100;
  [CompilerGenerated]
  public static ScoreSubmitSystem.Status \u003Cstatus\u003Ek__BackingField;
  [CompilerGenerated]
  public static int? \u003CplayerRank\u003Ek__BackingField;
  [CompilerGenerated]
  public static int \u003CSubmittedTime\u003Ek__BackingField;
  [CompilerGenerated]
  public static int \u003CSubmittedGold\u003Ek__BackingField;
  [CompilerGenerated]
  public static int \u003CSubmittedBattlesWon\u003Ek__BackingField;
  [CompilerGenerated]
  public static int \u003CSubmittedScore\u003Ek__BackingField;
  [CompilerGenerated]
  public static LeaderboardUpdate? \u003Cresult\u003Ek__BackingField;

  public static ScoreSubmitSystem.Status status
  {
    get => ScoreSubmitSystem.\u003Cstatus\u003Ek__BackingField;
    set => ScoreSubmitSystem.\u003Cstatus\u003Ek__BackingField = value;
  }

  public static int? playerRank
  {
    get => ScoreSubmitSystem.\u003CplayerRank\u003Ek__BackingField;
    set => ScoreSubmitSystem.\u003CplayerRank\u003Ek__BackingField = value;
  }

  public static int SubmittedTime
  {
    get => ScoreSubmitSystem.\u003CSubmittedTime\u003Ek__BackingField;
    set => ScoreSubmitSystem.\u003CSubmittedTime\u003Ek__BackingField = value;
  }

  public static int SubmittedGold
  {
    get => ScoreSubmitSystem.\u003CSubmittedGold\u003Ek__BackingField;
    set => ScoreSubmitSystem.\u003CSubmittedGold\u003Ek__BackingField = value;
  }

  public static int SubmittedBattlesWon
  {
    get => ScoreSubmitSystem.\u003CSubmittedBattlesWon\u003Ek__BackingField;
    set => ScoreSubmitSystem.\u003CSubmittedBattlesWon\u003Ek__BackingField = value;
  }

  public static int SubmittedScore
  {
    get => ScoreSubmitSystem.\u003CSubmittedScore\u003Ek__BackingField;
    set => ScoreSubmitSystem.\u003CSubmittedScore\u003Ek__BackingField = value;
  }

  public void OnEnable()
  {
    ScoreSubmitSystem.instance = this;
    global::Events.OnCampaignEnd += new UnityAction<Campaign.Result, CampaignStats, PlayerData>(ScoreSubmitSystem.CampaignEnd);
  }

  public void OnDisable() => global::Events.OnCampaignEnd -= new UnityAction<Campaign.Result, CampaignStats, PlayerData>(ScoreSubmitSystem.CampaignEnd);

  public static LeaderboardUpdate? result
  {
    get => ScoreSubmitSystem.\u003Cresult\u003Ek__BackingField;
    set => ScoreSubmitSystem.\u003Cresult\u003Ek__BackingField = value;
  }

  public static void CampaignEnd(
    Campaign.Result result,
    CampaignStats stats,
    PlayerData playerData)
  {
    if (!Campaign.Data.GameMode.submitScore)
      return;
    bool win = result == Campaign.Result.Win;
    ScoreSubmitSystem.instance.StartCoroutine(ScoreSubmitSystem.SubmitScore(win, stats));
  }

  public static IEnumerator SubmitScore(bool win, CampaignStats stats)
  {
    yield return (object) null;
    ScoreSubmitSystem.playerRank = new int?();
    ScoreSubmitSystem.status = ScoreSubmitSystem.Status.Submitting;
    DateTime exact = DateTime.ParseExact(SaveSystem.LoadCampaignData<string>(Campaign.Data.GameMode, "startDate", ""), "dd/MM/yyyy", (IFormatProvider) GameManager.CultureInfo);
    int num = win ? 1 : 0;
    ScoreSubmitSystem.SubmittedTime = Mathf.RoundToInt((float) (stats.hours * 3600) + stats.time);
    ScoreSubmitSystem.SubmittedGold = stats.Count("goldGained");
    ScoreSubmitSystem.SubmittedBattlesWon = stats.Count("battlesWon");
    ScoreSubmitSystem.SubmittedScore = ScoreSubmitSystem.GetScore(win, ScoreSubmitSystem.SubmittedTime, ScoreSubmitSystem.SubmittedGold, ScoreSubmitSystem.SubmittedBattlesWon);
    if (SteamManager.init)
    {
      Task<LeaderboardUpdate?> task = Scores.Submit(Campaign.Data.GameMode.leaderboardType, exact, ScoreSubmitSystem.SubmittedScore, ScoreSubmitSystem.SubmittedTime, num);
      yield return (object) new WaitUntil((Func<bool>) (() => task.IsCompleted));
      ScoreSubmitSystem.result = task.Result;
    }
    else
      ScoreSubmitSystem.result = new LeaderboardUpdate?();
    LeaderboardUpdate? result = ScoreSubmitSystem.result;
    if (result.HasValue)
    {
      result = ScoreSubmitSystem.result;
      ScoreSubmitSystem.playerRank = new int?(result.Value.NewGlobalRank);
      result = ScoreSubmitSystem.result;
      Debug.Log((object) string.Format("Score Changed? {0}", (object) result.Value.Changed));
      result = ScoreSubmitSystem.result;
      if (result.Value.Changed)
      {
        result = ScoreSubmitSystem.result;
        // ISSUE: variable of a boxed type
        __Boxed<int> oldGlobalRank = (ValueType) result.Value.OldGlobalRank;
        result = ScoreSubmitSystem.result;
        // ISSUE: variable of a boxed type
        __Boxed<int> newGlobalRank = (ValueType) result.Value.NewGlobalRank;
        Debug.Log((object) string.Format("Global Rank: {0} → {1}", (object) oldGlobalRank, (object) newGlobalRank));
      }
      ScoreSubmitSystem.status = ScoreSubmitSystem.Status.Success;
    }
    else
    {
      Debug.LogWarning((object) "Submitting score failed!");
      ScoreSubmitSystem.status = ScoreSubmitSystem.Status.Failed;
    }
  }

  public static int GetScore(bool win, int seconds, int gold, int battlesWon)
  {
    int scoreFromTime = ScoreSubmitSystem.GetScoreFromTime(win, seconds);
    int scoreFromGold = ScoreSubmitSystem.GetScoreFromGold(gold);
    int scoreFromBattlesWon = ScoreSubmitSystem.GetScoreFromBattlesWon(battlesWon);
    int num = scoreFromGold;
    return scoreFromTime + num + scoreFromBattlesWon;
  }

  public static int GetScoreFromTime(bool win, int seconds) => !win ? 0 : Mathf.Max(0, 3600 - seconds);

  public static int GetScoreFromGold(int goldRemaining) => goldRemaining;

  public static int GetScoreFromBattlesWon(int battlesWon) => battlesWon * 100 - 100;

  public enum Status
  {
    Submitting,
    Failed,
    Success,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScreenFlashSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ScreenFlashSystem : GameSystem
{
  public static ScreenFlashSystem instance;
  [SerializeField]
  public SpriteRenderer renderer;
  [SerializeField]
  public AnimationCurve curve;
  [SerializeField]
  public Material basicMaterial;
  [SerializeField]
  public Material additiveMaterial;
  public Color color;
  public float current;
  public float duration;
  public float amount = 1f;

  public void Awake() => ScreenFlashSystem.instance = this;

  public void Update()
  {
    if (!this.renderer.enabled)
      return;
    this.current += Time.deltaTime;
    this.renderer.color = this.color.WithAlpha(this.curve.Evaluate(Mathf.Min(1f, this.current / this.duration)) * this.amount);
    if ((double) this.current < (double) this.duration)
      return;
    this.renderer.enabled = false;
    this.renderer.material = this.basicMaterial;
  }

  public static void SetDrawOrder(string sortingLayer, int orderInLayer) => ScreenFlashSystem.instance._SetDrawOrder(sortingLayer, orderInLayer);

  public static void SetColour(Color color) => ScreenFlashSystem.instance.color = color;

  public static void SetMaterialAdditive() => ScreenFlashSystem.instance.renderer.material = ScreenFlashSystem.instance.additiveMaterial;

  public static void Run(float duration) => ScreenFlashSystem.instance._Run(duration);

  public void _SetDrawOrder(string sortingLayer, int orderInLayer)
  {
    this.renderer.sortingLayerName = sortingLayer;
    this.renderer.sortingOrder = orderInLayer;
  }

  public void _Run(float duration)
  {
    this.current = 0.0f;
    this.renderer.enabled = true;
    this.duration = duration;
    this.amount = Mathf.Max(0.2f, Settings.Load<float>("ScreenFlash", 1f));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScreenSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class ScreenSystem : GameSystem
{
  public static ScreenSystem instance;
  public int windowedWidth = 1920;
  public int windowedHeight = 1080;
  public FullScreenMode windowedMode = FullScreenMode.Windowed;
  public FullScreenMode fullMode = FullScreenMode.FullScreenWindow;
  public int _displayIndex;
  public int current;
  public int vsync;
  public int targetFramerate;

  public int fullScreenWidth => this.display.systemWidth;

  public int fullScreenHeight => this.display.systemHeight;

  public int displayIndex
  {
    get
    {
      if (this._displayIndex >= Display.displays.Length)
        this._displayIndex = Display.displays.Length - 1;
      return this._displayIndex;
    }
  }

  public Display display => Display.displays[this.displayIndex];

  public static bool IsWindowed => Screen.fullScreenMode == FullScreenMode.Windowed || Screen.fullScreenMode == FullScreenMode.MaximizedWindow;

  public void OnEnable()
  {
    ScreenSystem.instance = this;
    switch (Screen.fullScreenMode)
    {
      case FullScreenMode.ExclusiveFullScreen:
        this.current = 1;
        break;
      case FullScreenMode.FullScreenWindow:
        this.current = 2;
        break;
      case FullScreenMode.MaximizedWindow:
      case FullScreenMode.Windowed:
        this.current = 0;
        break;
    }
    global::Events.OnSettingChanged += new UnityAction<string, object>(this.SettingChanged);
    int mode = Settings.Load<int>("DisplayMode", 2);
    if (mode != this.current)
      this.Set(mode);
    this.vsync = Settings.Load<int>("Vsync", 1);
    ScreenSystem.SetVsync(this.vsync);
    this.targetFramerate = Settings.Load<int>("TargetFramerate", 2);
    ScreenSystem.SetTargetFramerate(this.targetFramerate);
  }

  public void OnDisable() => global::Events.OnSettingChanged -= new UnityAction<string, object>(this.SettingChanged);

  public void SettingChanged(string key, object value)
  {
    if (!(value is int mode))
      return;
    switch (key)
    {
      case "DisplayMode":
        this.Set(mode);
        break;
      case "TargetFramerate":
        ScreenSystem.SetTargetFramerate(mode);
        break;
      case "Vsync":
        ScreenSystem.SetVsync(mode);
        break;
    }
  }

  public void Update()
  {
    if (!Input.GetKeyDown(KeyCode.Return) || !Input.GetKey(KeyCode.LeftAlt))
      return;
    if (ScreenSystem.IsWindowed)
      Settings.Save<int>("DisplayMode", this.fullMode == FullScreenMode.ExclusiveFullScreen ? 1 : 2);
    else
      Settings.Save<int>("DisplayMode", 0);
    SetSettingInt setSettingInt = ((IEnumerable<SetSettingInt>) UnityEngine.Object.FindObjectsOfType<SetSettingInt>()).FirstOrDefault<SetSettingInt>((Func<SetSettingInt, bool>) (a => a.Key == "DisplayMode"));
    if (setSettingInt == null)
      return;
    setSettingInt.enabled = false;
    setSettingInt.enabled = true;
  }

  public void Set(int mode)
  {
    this.current = mode;
    switch (mode.Mod(3))
    {
      case 0:
        this.SetWindowed();
        break;
      case 1:
        this.SetFull();
        break;
      case 2:
        this.SetBorderless();
        break;
    }
  }

  public void SetWindowed(int forceWidth = 0, int forceHeight = 0)
  {
    Debug.Log((object) "Screen Mode: Windowed");
    if (!ScreenSystem.IsWindowed)
      this.fullMode = Screen.fullScreenMode;
    Screen.fullScreenMode = this.windowedMode;
    Screen.SetResolution(forceWidth > 0 ? forceWidth : this.windowedWidth, forceHeight > 0 ? forceHeight : this.windowedHeight, this.windowedMode);
  }

  public void SetFull(int forceWidth = 0, int forceHeight = 0)
  {
    Debug.Log((object) "Screen Mode: Fullscreen");
    if (ScreenSystem.IsWindowed)
    {
      this.windowedWidth = Screen.width;
      this.windowedHeight = Screen.height;
      this.windowedMode = Screen.fullScreenMode;
    }
    Screen.fullScreenMode = FullScreenMode.ExclusiveFullScreen;
    Screen.SetResolution(forceWidth > 0 ? forceWidth : this.fullScreenWidth, forceHeight > 0 ? forceHeight : this.fullScreenHeight, FullScreenMode.ExclusiveFullScreen);
  }

  public void SetBorderless(int forceWidth = 0, int forceHeight = 0)
  {
    Debug.Log((object) "Screen Mode: Borderless");
    if (ScreenSystem.IsWindowed)
    {
      this.windowedWidth = Screen.width;
      this.windowedHeight = Screen.height;
      this.windowedMode = Screen.fullScreenMode;
    }
    Screen.fullScreenMode = FullScreenMode.FullScreenWindow;
    Screen.SetResolution(forceWidth > 0 ? forceWidth : this.fullScreenWidth, forceHeight > 0 ? forceHeight : this.fullScreenHeight, FullScreenMode.FullScreenWindow);
  }

  public static void SetTargetFramerate(int mode)
  {
    mode = Mathf.Clamp(mode, 0, 4);
    int num;
    switch (mode)
    {
      case 0:
        num = -1;
        break;
      case 1:
        num = 30;
        break;
      case 2:
        num = 60;
        break;
      case 3:
        num = 120;
        break;
      case 4:
        num = 240;
        break;
      default:
        num = Application.targetFrameRate;
        break;
    }
    Application.targetFrameRate = num;
  }

  public static void SetVsync(int mode) => QualitySettings.vSyncCount = Mathf.Clamp(mode, 0, 1);

  public static void SetResolutionFullscreen(int width, int height) => ScreenSystem.instance.SetFull(width, height);

  public static void SetResolutionBorderless(int width, int height) => ScreenSystem.instance.SetBorderless(width, height);

  public static void SetResolutionWindowed(int width, int height) => ScreenSystem.instance.SetWindowed(width, height);
}
﻿// Decompiled with JetBrains decompiler
// Type: Script
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public abstract class Script : ScriptableObject
{
  public virtual IEnumerator Run() => (IEnumerator) null;
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptableAmount
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public abstract class ScriptableAmount : ScriptableObject
{
  public virtual int Get(Entity entity) => 0;
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptableCardImage
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ScriptableCardImage : MonoBehaviour
{
  public Entity entity;

  public void Assign(Entity entity)
  {
    this.entity = entity;
    this.AssignEvent();
  }

  public virtual void AssignEvent()
  {
  }

  public virtual void UpdateEvent()
  {
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptableCurrentAttack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Amount/Current Attack", fileName = "CurrentAttack")]
public class ScriptableCurrentAttack : ScriptableAmount
{
  public override int Get(Entity entity) => !(bool) (Object) entity ? 0 : entity.damage.current + entity.tempDamage.Value;
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptableCurrentStatus
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Amount/Current Status", fileName = "CurrentStatus")]
public class ScriptableCurrentStatus : ScriptableAmount
{
  [SerializeField]
  public string statusType = "shroom";
  [SerializeField]
  public int offset;

  public override int Get(Entity entity)
  {
    if (!(bool) (Object) entity)
      return this.offset;
    StatusEffectData status = entity.FindStatus(this.statusType);
    return status == null ? this.offset : status.count + this.offset;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptableFixedAmount
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Amount/Fixed Amount", fileName = "One")]
public class ScriptableFixedAmount : ScriptableAmount
{
  [SerializeField]
  public int amount = 1;

  public override int Get(Entity entity) => this.amount;
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptableGold
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Amount/Gold", fileName = "Gold")]
public class ScriptableGold : ScriptableAmount
{
  [SerializeField]
  public float factor;

  public override int Get(Entity entity) => Mathf.FloorToInt((float) (References.PlayerData.inventory.gold + References.PlayerData.inventory.goldOwed).Value * this.factor);
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptableHealthLost
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Amount/Health Lost", fileName = "HealthLost")]
public class ScriptableHealthLost : ScriptableAmount
{
  public override int Get(Entity entity)
  {
    if (!(bool) (Object) entity)
      return 0;
    Hit lastHit = entity.lastHit;
    return lastHit == null ? 0 : lastHit.damageDealt;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptAddCampaignNodes
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Add Campaign Nodes", menuName = "Scripts/Add Campaign Nodes")]
public class ScriptAddCampaignNodes : Script
{
  [SerializeField]
  public ScriptAddCampaignNodes.Event[] events;

  public override IEnumerator Run()
  {
    Routine.Clump clump = new Routine.Clump();
    foreach (ScriptAddCampaignNodes.Event @event in this.events)
    {
      int tier = @event.tierRange.Random();
      List<CampaignNode> list = new List<CampaignNode>();
      foreach (CampaignNode node in References.Campaign.nodes)
      {
        if (node.tier == tier && node.type.interactable && node.connections.Count > 1)
          list.Add(node);
      }
      CampaignNode campaignNode1 = list.RandomItem<CampaignNode>();
      int num1 = References.Campaign.nodes.IndexOf(campaignNode1);
      CampaignNode campaignNode2 = new CampaignNode(@event.type, campaignNode1.position.x, campaignNode1.position.y, tier, campaignNode1.positionIndex, campaignNode1.areaIndex, campaignNode1.radius);
      References.Campaign.nodes.Insert(num1 + 1, campaignNode2);
      campaignNode2.id = num1;
      campaignNode2.connections = campaignNode1.connections.Clone<CampaignNode.Connection>();
      int count = References.Campaign.nodes.Count;
      for (int index = num1 + 1; index < count; ++index)
      {
        CampaignNode node = References.Campaign.nodes[index];
        ++node.id;
        foreach (CampaignNode.Connection connection in node.connections)
          ++connection.otherId;
      }
      List<int> intList = new List<int>()
      {
        campaignNode2.id
      };
      while (intList.Count > 0)
      {
        CampaignNode node = Campaign.GetNode(intList[0]);
        ++node.position.x;
        intList.RemoveAt(0);
        foreach (int num2 in node.connections.Select<CampaignNode.Connection, int>((Func<CampaignNode.Connection, int>) (a => a.otherId)))
        {
          if (!intList.Contains(num2))
            intList.Add(num2);
        }
      }
      campaignNode1.connections.Clear();
      campaignNode1.ConnectTo(campaignNode2);
      clump.Add(campaignNode2.type.SetUp(campaignNode2));
    }
    yield return (object) clump.WaitForEnd();
    CampaignGenerator.ShuffleNodes(References.Campaign.nodes);
  }

  [Serializable]
  public class Event
  {
    public CampaignNodeType type;
    public Vector2Int tierRange;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptAddEnemies
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Add Enemies", menuName = "Scripts/Add Enemies")]
public class ScriptAddEnemies : Script
{
  [SerializeField]
  public ScriptAddEnemies.Profile[] profiles;

  public override IEnumerator Run()
  {
    using (List<CampaignNode>.Enumerator enumerator = References.Campaign.nodes.GetEnumerator())
    {
      while (enumerator.MoveNext())
      {
        CampaignNode current = enumerator.Current;
        if (current.type.isBattle)
        {
          string targetBattleName = (string) current.data["battle"];
          ScriptAddEnemies.Profile profile = ((IEnumerable<ScriptAddEnemies.Profile>) this.profiles).FirstOrDefault<ScriptAddEnemies.Profile>((Func<ScriptAddEnemies.Profile, bool>) (a => a.battleData.name == targetBattleName));
          if (profile != null)
          {
            BattleWaveManager.WaveData save = current.data.GetSaveCollection<BattleWaveManager.WaveData>("waves")[profile.toWave];
            int count = save.Count;
            ScriptAddEnemies.InsertTo(save, profile.randomPosition ? Dead.Random.Range(0, count) : count, profile.add, profile.pool);
          }
        }
      }
      yield break;
    }
  }

  public static void InsertTo(
    BattleWaveManager.WaveData waveData,
    int insertPos,
    int count,
    CardData[] fromPool)
  {
    List<CardData> list = new List<CardData>();
    for (int index = 0; index < count; ++index)
    {
      if (list.Count <= 0)
        list.AddRange((IEnumerable<CardData>) fromPool);
      CardData random = list.TakeRandom<CardData>();
      if (waveData is BattleWaveManager.WaveDataFull)
        waveData.InsertCard(insertPos, random.Clone());
      else
        waveData.InsertCard(insertPos, random);
    }
  }

  [Serializable]
  public class Profile
  {
    public BattleData battleData;
    public int add = 2;
    public int toWave = 1;
    public bool randomPosition;
    public CardData[] pool;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptAddRandomCards
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Add Random Cards", menuName = "Scripts/Add Random Cards")]
public class ScriptAddRandomCards : Script
{
  [SerializeField]
  public int replaceIndex = -1;
  [SerializeField]
  public bool anyCard;
  [SerializeField]
  [ShowIf("anyCard")]
  public CardType[] ofType;
  [SerializeField]
  [HideIf("anyCard")]
  public CardData[] pool;
  [SerializeField]
  public Vector2Int countRange;

  public override IEnumerator Run()
  {
    // ISSUE: reference to a compiler-generated field
    int num1 = this.\u003C\u003E1__state;
    ScriptAddRandomCards scriptAddRandomCards = this;
    if (num1 != 0)
      return false;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    CardDataList deck = References.PlayerData.inventory.deck;
    if (scriptAddRandomCards.replaceIndex >= 0)
      deck.RemoveAt(scriptAddRandomCards.replaceIndex);
    List<CardData> list = new List<CardData>();
    int num2 = scriptAddRandomCards.countRange.Random();
    for (int index = 0; index < num2; ++index)
    {
      if (list.Count <= 0)
        scriptAddRandomCards.PopulateCardList(list);
      CardData cardData = list.TakeRandom<CardData>().Clone();
      Debug.Log((object) (scriptAddRandomCards.name + " → Adding [" + cardData.name + "] to player's deck"));
      if (scriptAddRandomCards.replaceIndex >= 0)
        deck.Insert(scriptAddRandomCards.replaceIndex, cardData);
      else
        deck.Add(cardData);
    }
    return false;
  }

  public void PopulateCardList(List<CardData> list)
  {
    if (this.anyCard)
    {
      foreach (RewardPool rewardPool in References.PlayerData.classData.rewardPools)
      {
        foreach (DataFile dataFile in rewardPool.list)
        {
          if (dataFile is CardData cardData && this.ofType.Contains<CardType>(cardData.cardType))
            list.Add(cardData);
        }
      }
    }
    else
      list.AddRange((IEnumerable<CardData>) this.pool);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptAddUpgrades
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Add Upgrades", menuName = "Scripts/Add Upgrades")]
public class ScriptAddUpgrades : Script
{
  [SerializeField]
  public int count = 1;
  [SerializeField]
  public CardUpgradeData[] upgradePool;
  [SerializeField]
  [HideIf("addToRandom")]
  public bool addToFirstEligible = true;
  [SerializeField]
  [HideIf("addToFirstEligible")]
  public bool addToRandom;
  [SerializeField]
  public bool ofCardType;
  [SerializeField]
  [ShowIf("ofCardType")]
  public CardType[] eligibleCardTypes;

  public override IEnumerator Run()
  {
    for (int index = 0; index < this.count; ++index)
      this.AddUpgrade();
    yield break;
  }

  public void AddUpgrade()
  {
    using (IEnumerator<CardUpgradeData> enumerator = ((IEnumerable<CardUpgradeData>) this.upgradePool).InRandomOrder<CardUpgradeData>().GetEnumerator())
    {
      do
        ;
      while (enumerator.MoveNext() && !this.TryAddUpgrade(enumerator.Current));
    }
  }

  public bool TryAddUpgrade(CardUpgradeData upgradeData)
  {
    bool flag = false;
    if (this.addToFirstEligible)
    {
      foreach (CardData cardData in References.PlayerData.inventory.deck)
      {
        if (this.Eligible(cardData) && upgradeData.CanAssign(cardData))
        {
          upgradeData.Clone().Assign(cardData);
          flag = true;
          break;
        }
      }
    }
    else if (this.addToRandom)
    {
      foreach (CardData cardData in (IEnumerable<CardData>) References.PlayerData.inventory.deck.InRandomOrder<CardData>())
      {
        if (this.Eligible(cardData) && upgradeData.CanAssign(cardData))
        {
          upgradeData.Clone().Assign(cardData);
          flag = true;
          break;
        }
      }
    }
    else
    {
      References.PlayerData.inventory.upgrades.Add(upgradeData.Clone());
      flag = true;
    }
    return flag;
  }

  public bool Eligible(CardData cardData) => !this.ofCardType || this.eligibleCardTypes.Contains<CardType>(cardData.cardType);
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptAdjustShopPrices
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Adjust Shop Prices", menuName = "Scripts/Adjust Shop Prices")]
public class ScriptAdjustShopPrices : Script
{
  [SerializeField]
  public Vector2Int cardPrices = new Vector2Int(5, 5);
  [SerializeField]
  public Vector2Int charmPrices = new Vector2Int(5, 5);
  [SerializeField]
  public Vector2Int charmMachinePrice = new Vector2Int(5, 5);
  [SerializeField]
  public Vector2Int charmMachineAddPrice = new Vector2Int(5, 5);
  [SerializeField]
  public Vector2Int crownPrice = new Vector2Int(5, 5);
  [SerializeField]
  public Vector2Int crownAddPrice = new Vector2Int(5, 5);

  public override IEnumerator Run()
  {
    using (List<CampaignNode>.Enumerator enumerator = References.Campaign.nodes.GetEnumerator())
    {
      while (enumerator.MoveNext())
      {
        CampaignNode current = enumerator.Current;
        CampaignNodeType type = current.type;
        if (!(type is CampaignNodeTypeShop))
        {
          if (type is CampaignNodeTypeCharmShop)
          {
            EventRoutineCharmShop.Data data = current.data.Get<EventRoutineCharmShop.Data>("data");
            foreach (EventRoutineCharmShop.UpgradedCard card in data.cards)
              card.price += this.cardPrices.Random();
            foreach (EventRoutineCharmShop.CharmShopItemData charmShopItemData in data.items)
              charmShopItemData.price += this.charmPrices.Random();
          }
        }
        else
        {
          ShopRoutine.Data data = current.data.Get<ShopRoutine.Data>("shopData");
          data.charmPrice += this.charmMachinePrice.Random();
          data.charmPriceAdd += this.charmMachineAddPrice.Random();
          data.crownPrice += this.crownPrice.Random();
          data.crownPriceAdd += this.crownAddPrice.Random();
          foreach (ShopRoutine.Item obj in data.items)
            obj.price += this.cardPrices.Random();
        }
      }
      yield break;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptBattleSetUp
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "BattleSetUp", menuName = "Scripts/Battle Set Up")]
public class ScriptBattleSetUp : Script
{
  public override IEnumerator Run()
  {
    Character player = References.Player;
    Character enemy = References.Battle.enemy;
    CampaignNode node = Campaign.FindCharacterNode(player);
    Events.InvokePreBattleSetUp(node);
    ScriptBattleSetUp.SetUpEnemyWaves(enemy, node);
    UnityEngine.Random.InitState(node.seed);
    yield return (object) ScriptBattleSetUp.CreateCards(player, enemy);
    Events.InvokePostBattleSetUp(node);
  }

  public static void SetUpEnemyWaves(Character enemy, CampaignNode node)
  {
    BattleWaveManager component = enemy.GetComponent<BattleWaveManager>();
    component.list = new List<BattleWaveManager.Wave>();
    foreach (BattleWaveManager.WaveData save in node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves"))
    {
      BattleWaveManager.Wave wave = new BattleWaveManager.Wave(save);
      component.list.Add(wave);
    }
  }

  public static IEnumerator CreateCards(Character player, Character enemy)
  {
    CardController objectOfType = UnityEngine.Object.FindObjectOfType<CardController>();
    Routine.Clump clump = new Routine.Clump();
    List<Entity> enemyCards = new List<Entity>();
    List<Entity> playerCards = new List<Entity>();
    clump.Add(ScriptBattleSetUp.CreateEnemyCards(enemy, objectOfType, (IList<Entity>) enemyCards));
    clump.Add(ScriptBattleSetUp.CreatePlayerCards(player, objectOfType, (IList<Entity>) playerCards));
    yield return (object) clump.WaitForEnd();
    Vector3 vector3_1 = Vector3.one * enemy.reserveContainer.CardScale;
    foreach (Entity entity in enemyCards)
    {
      enemy.reserveContainer.Add(entity);
      entity.transform.localScale = vector3_1;
    }
    enemy.reserveContainer.SetChildPositions();
    Vector3 vector3_2 = Vector3.one * player.drawContainer.CardScale;
    foreach (Entity entity in (IEnumerable<Entity>) playerCards.InRandomOrder<Entity>())
    {
      player.drawContainer.Add(entity);
      entity.transform.localScale = vector3_2;
    }
    player.drawContainer.SetChildPositions();
  }

  public static IEnumerator CreateEnemyCards(
    Character enemy,
    CardController cardController,
    IList<Entity> entities)
  {
    Routine.Clump clump = new Routine.Clump();
    BattleWaveManager waveManager = enemy.GetComponent<BattleWaveManager>();
    int num = waveManager.list.Sum<BattleWaveManager.Wave>((Func<BattleWaveManager.Wave, int>) (a => a.units.Count));
    while (entities.Count < num)
      entities.Add((Entity) null);
    int entityIndex = 0;
    for (int waveIndex = 0; waveIndex < waveManager.list.Count; ++waveIndex)
    {
      BattleWaveManager.Wave wave = waveManager.list[waveIndex];
      List<Entity> entitiesThisWave = new List<Entity>();
      while (entitiesThisWave.Count < wave.units.Count)
        entitiesThisWave.Add((Entity) null);
      for (int index = 0; index < wave.units.Count; ++index)
      {
        Card card = CardManager.Get(wave.units[index], cardController, enemy, true, false);
        entitiesThisWave[index] = card.entity;
        card.entity.flipper.FlipDownInstant();
        entities[entityIndex++] = card.entity;
        clump.Add(card.UpdateData(false));
      }
      yield return (object) clump.WaitForEnd();
      waveManager.AddEntities(entitiesThisWave.ToArray());
      Debug.Log((object) string.Format("{0} Created", (object) wave));
      wave = (BattleWaveManager.Wave) null;
      entitiesThisWave = (List<Entity>) null;
    }
  }

  public static IEnumerator CreatePlayerCards(
    Character player,
    CardController cardController,
    IList<Entity> entities)
  {
    Routine.Clump clump = new Routine.Clump();
    int count = player.data.inventory.deck.Count;
    while (entities.Count < count)
      entities.Add((Entity) null);
    for (int index = 0; index < count; ++index)
    {
      Card card = CardManager.Get(player.data.inventory.deck[index], cardController, player, true, true);
      entities[index] = card.entity;
      card.entity.flipper.FlipDownInstant();
      clump.Add(card.UpdateData(false));
    }
    yield return (object) clump.WaitForEnd();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptChangeCardStats
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Change Card Stats", menuName = "Scripts/Change Card Stats")]
public class ScriptChangeCardStats : Script
{
  [SerializeField]
  public int cardIndex;
  [SerializeField]
  public CardScript[] scriptPool;
  [SerializeField]
  public Vector2Int countRange;

  public override IEnumerator Run()
  {
    int num = this.countRange.Random();
    CardData target = References.PlayerData.inventory.deck[this.cardIndex];
    foreach (CardScript cardScript in (IEnumerable<CardScript>) ((IEnumerable<CardScript>) this.scriptPool).InRandomOrder<CardScript>())
    {
      if (num <= 0)
      {
        yield break;
      }
      else
      {
        cardScript.Run(target);
        --num;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptChangeComboFactor
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Change Combo Factor", menuName = "Scripts/Change Combo Factor")]
public class ScriptChangeComboFactor : Script
{
  [SerializeField]
  public float value = 1f;

  public override IEnumerator Run()
  {
    References.PlayerData.comboGoldFactor = this.value;
    yield break;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptChangeCompanionLimit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Change Companion Limit", menuName = "Scripts/Change Companion Limit")]
public class ScriptChangeCompanionLimit : Script
{
  [SerializeField]
  public bool set;
  [SerializeField]
  [HideIf("set")]
  public bool add = true;
  [SerializeField]
  public int value = 1;

  public override IEnumerator Run()
  {
    if (this.set)
      References.PlayerData.companionLimit = this.value;
    else if (this.add)
    {
      References.PlayerData.companionLimit += this.value;
      yield break;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptChangeEnemyGoldFactor
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Change Enemy Gold Factor", menuName = "Scripts/Change Enemy Gold Factor")]
public class ScriptChangeEnemyGoldFactor : Script
{
  [SerializeField]
  public float value = 1f;

  public override IEnumerator Run()
  {
    References.PlayerData.enemyGoldFactor = this.value;
    yield break;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptChangeHandSize
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Change Hand Size", menuName = "Scripts/Change Hand Size")]
public class ScriptChangeHandSize : Script
{
  [SerializeField]
  public bool set;
  [SerializeField]
  [HideIf("set")]
  public bool add = true;
  [SerializeField]
  public int value = 1;

  public override IEnumerator Run()
  {
    if (this.set)
      References.PlayerData.handSize = this.value;
    else if (this.add)
    {
      References.PlayerData.handSize += this.value;
      yield break;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptChangeRedrawBellCounter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Change Redraw Bell Counter", menuName = "Scripts/Change Redraw Bell Counter")]
public class ScriptChangeRedrawBellCounter : Script
{
  [SerializeField]
  public bool set;
  [SerializeField]
  [HideIf("set")]
  public bool add = true;
  [SerializeField]
  public int value = 1;

  public override IEnumerator Run()
  {
    if (this.set)
      References.PlayerData.redrawBell = this.value;
    else if (this.add)
    {
      References.PlayerData.redrawBell += this.value;
      yield break;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptChangeShopPrices
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Change Shop Prices", menuName = "Scripts/Change Shop Prices")]
public class ScriptChangeShopPrices : Script
{
  [SerializeField]
  public Vector2Int itemsToAffect = new Vector2Int(2, 3);
  [SerializeField]
  public Vector2 affectPriceRange = new Vector2(1f, 1.5f);
  [SerializeField]
  public Vector2 charmPriceRange = new Vector2(1f, 1.5f);
  [SerializeField]
  public Vector2 crownPriceRange = new Vector2(1f, 1.5f);
  [SerializeField]
  public float removeDiscountChance = 0.5f;

  public override IEnumerator Run()
  {
    using (IEnumerator<CampaignNode> enumerator = Campaign.instance.nodes.Where<CampaignNode>((Func<CampaignNode, bool>) (node => node.type is CampaignNodeTypeShop)).GetEnumerator())
    {
      while (enumerator.MoveNext())
      {
        object obj1;
        if (enumerator.Current.data.TryGetValue("shopData", out obj1) && obj1 is ShopRoutine.Data data)
        {
          int num1 = this.itemsToAffect.Random();
          foreach (ShopRoutine.Item obj2 in (IEnumerable<ShopRoutine.Item>) data.items.OrderBy<ShopRoutine.Item, float>((Func<ShopRoutine.Item, float>) (a => UnityEngine.Random.Range(0.0f, 1f))))
          {
            float num2 = this.affectPriceRange.Random();
            obj2.price = Mathf.RoundToInt((float) obj2.price * num2);
            if ((double) num2 < 1.0 && (double) UnityEngine.Random.Range(0.0f, 1f) < (double) this.removeDiscountChance)
              ;
            --num1;
            if (num1 <= 0)
              break;
          }
          data.charmPrice = Mathf.RoundToInt((float) data.charmPrice * this.charmPriceRange.Random());
          data.crownPrice = Mathf.RoundToInt((float) data.crownPrice * this.crownPriceRange.Random());
        }
      }
      yield break;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptChangeWaveBellCounter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(fileName = "Change Wave Bell Counter", menuName = "Scripts/Change Wave Bell Counter")]
public class ScriptChangeWaveBellCounter : Script
{
  [SerializeField]
  public bool set;
  [SerializeField]
  [HideIf("set")]
  public bool add = true;
  [SerializeField]
  public int value = 1;

  public override IEnumerator Run()
  {
    if (this.set)
      this.Set();
    else if (this.add)
    {
      this.Add();
      yield break;
    }
  }

  public void Add()
  {
    foreach (CampaignNode node in Campaign.instance.nodes)
    {
      object obj;
      if (!node.cleared && node.type.isBattle && node.data.TryGetValue("waves", out obj) && obj is SaveCollection<BattleWaveManager.WaveData> waves)
        this.Add(waves);
    }
  }

  public void Set()
  {
    foreach (CampaignNode node in Campaign.instance.nodes)
    {
      object obj;
      if (!node.cleared && node.type.isBattle && node.data.TryGetValue("waves", out obj) && obj is SaveCollection<BattleWaveManager.WaveData> waves)
        this.Set(waves);
    }
  }

  public void Add(SaveCollection<BattleWaveManager.WaveData> waves)
  {
    for (int index = 0; index < waves.Count; ++index)
      waves[index].counter += this.value;
  }

  public void Set(SaveCollection<BattleWaveManager.WaveData> waves)
  {
    for (int index = 0; index < waves.Count; ++index)
      waves[index].counter = this.value;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptCurseCrowns
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Curse Crowns", menuName = "Scripts/Curse Crowns")]
public class ScriptCurseCrowns : Script
{
  [SerializeField]
  public int curseBossCrowns = 1;
  [SerializeField]
  public int curseShopCrowns = 1;
  [SerializeField]
  public int[] legalBossTiers = new int[1]{ 2 };
  [SerializeField]
  public int[] legalShopTiers = new int[4]{ 2, 3, 4, 5 };
  [SerializeField]
  public CardUpgradeData[] cursedCrowns;

  public override IEnumerator Run()
  {
    List<CardUpgradeData> pool = this.PopulatePool();
    int curseBossCrowns = this.curseBossCrowns;
    int curseShopCrowns = this.curseShopCrowns;
    foreach (CampaignNode node in (IEnumerable<CampaignNode>) References.Campaign.nodes.Where<CampaignNode>((Func<CampaignNode, bool>) (a => a.type.interactable && a.dataLinkedTo == -1 && a.tier >= 0 && a.data != null)).InRandomOrder<CampaignNode>())
    {
      if (node.type is CampaignNodeTypeBoss && this.TryCurseBossCrown(node, pool))
      {
        if (--curseBossCrowns <= 0 && curseShopCrowns <= 0)
          break;
      }
      else if (node.type is CampaignNodeTypeShop && this.TryCurseShopCrown(node, pool) && --curseShopCrowns <= 0 && curseBossCrowns <= 0)
        yield break;
    }
  }

  public bool TryCurseBossCrown(CampaignNode node, List<CardUpgradeData> pool)
  {
    if (!this.legalBossTiers.Contains<int>(node.tier))
      return false;
    CampaignNodeTypeBoss.RewardData rewardData = node.data.Get<CampaignNodeTypeBoss.RewardData>("rewards");
    if (rewardData != null)
    {
      foreach (BossRewardData.Data reward in rewardData.rewards)
      {
        CardUpgradeData upgradeData;
        if (reward.type == BossRewardData.Type.Crown && reward is BossRewardDataCrown.Data data && ScriptCurseCrowns.TryPullFromPool(pool, out upgradeData))
        {
          data.upgradeDataName = upgradeData.name;
          return true;
        }
      }
    }
    return false;
  }

  public bool TryCurseShopCrown(CampaignNode node, List<CardUpgradeData> pool)
  {
    if (!this.legalShopTiers.Contains<int>(node.tier))
      return false;
    ShopRoutine.Data data = node.data.Get<ShopRoutine.Data>("shopData");
    CardUpgradeData upgradeData;
    if (data == null || !ScriptCurseCrowns.TryPullFromPool(pool, out upgradeData))
      return false;
    data.crownType = upgradeData.name;
    return true;
  }

  public static bool TryPullFromPool(List<CardUpgradeData> pool, out CardUpgradeData upgradeData)
  {
    if (pool.Count > 0)
    {
      upgradeData = pool.TakeRandom<CardUpgradeData>();
      return true;
    }
    upgradeData = (CardUpgradeData) null;
    return false;
  }

  public List<CardUpgradeData> PopulatePool()
  {
    List<CardUpgradeData> cardUpgradeDataList = new List<CardUpgradeData>();
    cardUpgradeDataList.AddRange((IEnumerable<CardUpgradeData>) this.cursedCrowns);
    return cardUpgradeDataList;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptDowngradeCardRewards
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Downgrade Card Rewards", menuName = "Scripts/Downgrade Card Rewards")]
public class ScriptDowngradeCardRewards : Script
{
  [SerializeField]
  public CardUpgradeData[] charms;
  [SerializeField]
  public int downgradesPerTier = 2;
  [SerializeField]
  public ScriptDowngradeCardRewards.FixedCharmSet[] charmSets;

  public override IEnumerator Run()
  {
    List<CardUpgradeData> pool = this.PopulatePool();
    Dictionary<int, int> dictionary = new Dictionary<int, int>();
    for (int key = 0; key <= 8; ++key)
      dictionary[key] = this.downgradesPerTier;
    using (IEnumerator<CampaignNode> enumerator = References.Campaign.nodes.Where<CampaignNode>((Func<CampaignNode, bool>) (a => a.type.interactable && a.dataLinkedTo == -1 && a.tier >= 0 && a.data != null)).InRandomOrder<CampaignNode>().GetEnumerator())
    {
      while (enumerator.MoveNext())
      {
        CampaignNode current = enumerator.Current;
        if (dictionary[current.tier] > 0 && this.TryAddDowngrade(current, pool))
          --dictionary[current.tier];
      }
      yield break;
    }
  }

  public bool TryAddDowngrade(CampaignNode node, List<CardUpgradeData> pool)
  {
    bool flag = false;
    switch (node.type)
    {
      case CampaignNodeTypeItem _:
      case CampaignNodeTypeCompanion _:
      case CampaignNodeTypeCurseItems _:
        int appliedToIndex1;
        CardUpgradeData downgradeApplied1;
        if (this.TryAddDowngrade(node.data.GetSaveCollection<string>("cards"), pool, out appliedToIndex1, out downgradeApplied1))
        {
          flag = true;
          ScriptDowngradeCardRewards.AddUpgradeToCardInNodeData(node, appliedToIndex1, downgradeApplied1.name);
          break;
        }
        break;
      default:
        if (node.type is CampaignNodeTypeShop)
        {
          ShopRoutine.Data data = node.data.Get<ShopRoutine.Data>("shopData");
          int appliedToIndex2;
          CardUpgradeData downgradeApplied2;
          if (this.TryAddDowngrade(data.items.Select<ShopRoutine.Item, string>((Func<ShopRoutine.Item, string>) (a => a.cardDataName)).ToArray<string>(), pool, out appliedToIndex2, out downgradeApplied2))
          {
            flag = true;
            for (int index = 0; index <= appliedToIndex2; ++index)
            {
              if (data.upgrades.Count <= index)
              {
                string[] strArray1;
                if (index != appliedToIndex2)
                  strArray1 = (string[]) null;
                else
                  strArray1 = new string[1]
                  {
                    downgradeApplied2.name
                  };
                string[] strArray2 = strArray1;
                data.upgrades.Add(strArray2);
              }
              else if (index == appliedToIndex2)
              {
                string[] upgrade = data.upgrades[index];
                string[] strArray;
                if (upgrade == null)
                {
                  strArray = new string[1]
                  {
                    downgradeApplied2.name
                  };
                }
                else
                {
                  List<string> list = upgrade.ToList<string>();
                  list.Add(downgradeApplied2.name);
                  strArray = list.ToArray();
                }
                data.upgrades[index] = strArray;
              }
            }
            break;
          }
          break;
        }
        if (node.type is CampaignNodeTypeCharmShop)
        {
          EventRoutineCharmShop.Data data = node.data.Get<EventRoutineCharmShop.Data>("data");
          int appliedToIndex3;
          CardUpgradeData downgradeApplied3;
          if (this.TryAddDowngrade(data.cards.Select<EventRoutineCharmShop.UpgradedCard, string>((Func<EventRoutineCharmShop.UpgradedCard, string>) (a => a.cardDataName)).ToArray<string>(), pool, out appliedToIndex3, out downgradeApplied3))
          {
            flag = true;
            EventRoutineCharmShop.UpgradedCard card = data.cards[appliedToIndex3];
            List<string> stringList = card.upgradeNames == null ? new List<string>() : card.upgradeNames.ToList<string>();
            stringList.Add(downgradeApplied3.name);
            card.upgradeNames = stringList.ToArray();
            break;
          }
          break;
        }
        break;
    }
    return flag;
  }

  public static void AddUpgradeToCardInNodeData(
    CampaignNode node,
    int cardIndex,
    string upgradeName)
  {
    string key = string.Format("upgrades{0}", (object) cardIndex);
    if (node.data.ContainsKey(key))
      node.data.Get<SaveCollection<string>>(key).Add(upgradeName);
    else
      node.data[key] = (object) new SaveCollection<string>(upgradeName);
    if (node.linkedToThis == null)
      return;
    foreach (int linkedToThi in node.linkedToThis)
      ScriptDowngradeCardRewards.AddUpgradeToCardInNodeData(Campaign.GetNode(linkedToThi), cardIndex, upgradeName);
  }

  public bool TryAddDowngrade(
    string[] cardNames,
    List<CardUpgradeData> pool,
    out int appliedToIndex,
    out CardUpgradeData downgradeApplied)
  {
    appliedToIndex = -1;
    downgradeApplied = (CardUpgradeData) null;
    bool flag = false;
    foreach (int index in (IEnumerable<int>) ((IList<string>) cardNames).GetIndices<string>().InRandomOrder<int>())
    {
      CardData cardData = AddressableLoader.Get<CardData>("CardData", cardNames[index]);
      downgradeApplied = this.FindDowngrade(cardData, pool);
      if ((bool) (UnityEngine.Object) downgradeApplied)
      {
        pool.Remove(downgradeApplied);
        flag = true;
        appliedToIndex = index;
        break;
      }
    }
    return flag;
  }

  public CardUpgradeData FindDowngrade(CardData cardData, List<CardUpgradeData> pool)
  {
    foreach (ScriptDowngradeCardRewards.FixedCharmSet charmSet in this.charmSets)
    {
      if (charmSet.cards.Contains<string>(cardData.name))
        return charmSet.charmOptions.RandomItem<CardUpgradeData>();
    }
    for (int index = 0; index < pool.Count; ++index)
    {
      if (pool[index].CanAssign(cardData))
        return pool[index];
    }
    return (CardUpgradeData) null;
  }

  public List<CardUpgradeData> PopulatePool()
  {
    List<CardUpgradeData> cardUpgradeDataList = new List<CardUpgradeData>();
    cardUpgradeDataList.AddRange((IEnumerable<CardUpgradeData>) ((IEnumerable<CardUpgradeData>) this.charms).InRandomOrder<CardUpgradeData>());
    cardUpgradeDataList.AddRange((IEnumerable<CardUpgradeData>) ((IEnumerable<CardUpgradeData>) this.charms).InRandomOrder<CardUpgradeData>());
    return cardUpgradeDataList;
  }

  [Serializable]
  public struct FixedCharmSet
  {
    public string[] cards;
    public CardUpgradeData[] charmOptions;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptEarlyMinibosses
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Early Minibosses", menuName = "Scripts/Early Minibosses")]
public class ScriptEarlyMinibosses : Script
{
  public override IEnumerator Run()
  {
    using (List<CampaignNode>.Enumerator enumerator = References.Campaign.nodes.GetEnumerator())
    {
      while (enumerator.MoveNext())
      {
        CampaignNode current = enumerator.Current;
        if (current.type.isBattle && !current.type.isBoss)
        {
          List<BattleWaveManager.WaveData> list = current.data.GetSaveCollection<BattleWaveManager.WaveData>("waves").ToList<BattleWaveManager.WaveData>();
          BattleWaveManager.WaveData waveData = list.FirstOrDefault<BattleWaveManager.WaveData>((Func<BattleWaveManager.WaveData, bool>) (a => a.isBossWave));
          if (waveData != null)
          {
            int index = list.IndexOf(waveData);
            list.RemoveAt(index);
            list.Insert(index - 1, waveData);
            current.data["waves"] = (object) new SaveCollection<BattleWaveManager.WaveData>(list);
          }
        }
      }
      yield break;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptModifyWaveCounters
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Modify Wave Counters", menuName = "Scripts/Modify Wave Counters")]
public class ScriptModifyWaveCounters : Script
{
  [SerializeField]
  public int change = -1;
  [SerializeField]
  public bool normalBattles = true;
  [SerializeField]
  public bool bossBattles = true;
  [SerializeField]
  public bool finalBossBattles = true;

  public override IEnumerator Run()
  {
    using (List<CampaignNode>.Enumerator enumerator = References.Campaign.nodes.GetEnumerator())
    {
      while (enumerator.MoveNext())
      {
        CampaignNode current = enumerator.Current;
        if (current.type.isBattle && (this.normalBattles || !(current.type.name == "CampaignNodeBattle")) && (this.bossBattles || !(current.type.name == "CampaignNodeBoss")))
        {
          if (!this.finalBossBattles)
          {
            string name = current.type.name;
            if (name == "CampaignNodeFinalBoss" || name == "CampaignNodeFinalFinalBoss")
              continue;
          }
          BattleWaveManager.WaveData[] saveCollection = current.data.GetSaveCollection<BattleWaveManager.WaveData>("waves");
          foreach (BattleWaveManager.WaveData waveData in saveCollection)
            waveData.counter += this.change;
          current.data["waves"] = (object) new SaveCollection<BattleWaveManager.WaveData>(saveCollection);
        }
      }
      yield break;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptRandomizeDeck
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Randomize Deck", menuName = "Scripts/Randomize Deck")]
public class ScriptRandomizeDeck : Script
{
  [SerializeField]
  public Vector2Int cardsToRemove = new Vector2Int(0, 2);
  [SerializeField]
  public Vector2Int cardsToAdd = new Vector2Int(1, 4);
  [SerializeField]
  public Vector2Int charmsToAdd = new Vector2Int(1, 3);
  [SerializeField]
  [Range(0.0f, 1f)]
  public float addCharmChance = 0.25f;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float replaceChance = 0.5f;

  public override IEnumerator Run()
  {
    List<CardData> cards;
    List<CardUpgradeData> charms;
    ScriptRandomizeDeck.GetPools(out cards, out charms);
    this.RemoveCards();
    this.AddCards(cards);
    if ((double) UnityEngine.Random.Range(0.0f, 1f) < (double) this.addCharmChance)
      this.AddCharms(charms);
    References.PlayerData.inventory.deck.Sort((Comparison<CardData>) ((a, b) => a.cardType.sortPriority.CompareTo(b.cardType.sortPriority)));
    yield break;
  }

  public static void GetPools(out List<CardData> cards, out List<CardUpgradeData> charms)
  {
    cards = new List<CardData>();
    charms = new List<CardUpgradeData>();
    foreach (RewardPool rewardPool in References.PlayerData.classData.rewardPools)
    {
      foreach (DataFile dataFile in rewardPool.list)
      {
        if (!(dataFile is CardData cardData))
        {
          if (dataFile is CardUpgradeData cardUpgradeData)
            charms.Add(cardUpgradeData);
        }
        else
          cards.Add(cardData);
      }
    }
  }

  public void RemoveCards()
  {
    int num = this.cardsToRemove.Random();
    for (int index1 = 0; index1 < num; ++index1)
    {
      int index2 = UnityEngine.Random.Range(1, References.PlayerData.inventory.deck.Count);
      References.PlayerData.inventory.deck.RemoveAt(index2);
    }
  }

  public void AddCards(List<CardData> cards)
  {
    int num = this.cardsToAdd.Random();
    List<CardData> added = new List<CardData>();
    for (int index = 0; index < num; ++index)
      this.AddCard(References.PlayerData.inventory.deck, cards.TakeRandom<CardData>().Clone(), added);
  }

  public void AddCard(CardDataList deck, CardData cardDataClone, List<CardData> added)
  {
    int num = (double) UnityEngine.Random.Range(0.0f, 1f) < (double) this.replaceChance ? 1 : 0;
    int index = UnityEngine.Random.Range(1, deck.Count);
    if (num != 0 && !added.Contains(deck[index]))
      deck.RemoveAt(index);
    deck.Insert(index, cardDataClone);
  }

  public void AddCharms(List<CardUpgradeData> charms)
  {
    int num = this.charmsToAdd.Random();
    for (int index = 0; index < num; ++index)
    {
      bool flag = false;
      while (!flag && charms.Count > 0)
        flag = ScriptRandomizeDeck.TryAddCharm(References.PlayerData.inventory.deck, charms.TakeRandom<CardUpgradeData>());
      if (charms.Count <= 0)
        break;
    }
  }

  public static bool TryAddCharm(CardDataList deck, CardUpgradeData upgradeData)
  {
    bool flag = false;
    foreach (CardData cardData in (IEnumerable<CardData>) deck.InRandomOrder<CardData>())
    {
      if (upgradeData.CanAssign(cardData))
      {
        upgradeData.Clone().Assign(cardData);
        flag = true;
        break;
      }
    }
    return flag;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptRemoveRandomCards
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Remove Random Cards", menuName = "Scripts/Remove Random Cards")]
public class ScriptRemoveRandomCards : Script
{
  [SerializeField]
  public Vector2Int countRange;
  [SerializeField]
  public CardType[] cardTypes;

  public override IEnumerator Run()
  {
    // ISSUE: reference to a compiler-generated field
    int num1 = this.\u003C\u003E1__state;
    ScriptRemoveRandomCards removeRandomCards = this;
    if (num1 != 0)
      return false;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    CardData[] array = References.PlayerData.inventory.deck.Where<CardData>(new Func<CardData, bool>(removeRandomCards.Eligible)).InRandomOrder<CardData>().ToArray<CardData>();
    int num2 = removeRandomCards.countRange.Random();
    for (int index = 0; index < num2; ++index)
    {
      CardData cardData = array[index];
      References.PlayerData.inventory.deck.Remove(cardData);
      Debug.Log((object) (removeRandomCards.name + " → Removing " + cardData.name + " from player's deck"));
    }
    return false;
  }

  public bool Eligible(CardData cardData) => this.cardTypes.Length == 0 || this.cardTypes.Contains<CardType>(cardData.cardType);
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptRunScriptsOnDeck
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.AddressableAssets;

[CreateAssetMenu(fileName = "Run Scripts On Deck", menuName = "Scripts/Run Scripts On Deck")]
public class ScriptRunScriptsOnDeck : Script
{
  [SerializeField]
  public AssetReferenceT<CardScript>[] scriptRefs;
  [SerializeField]
  public TargetConstraint[] constraints;
  [SerializeField]
  public Vector2Int countRange;
  [SerializeField]
  public bool includeReserve;

  public override IEnumerator Run()
  {
    List<CardData> cardDataList = new List<CardData>();
    ScriptRunScriptsOnDeck.AddRangeIfConstraints((ICollection<CardData>) cardDataList, References.PlayerData.inventory.deck, this.constraints);
    if (this.includeReserve)
      ScriptRunScriptsOnDeck.AddRangeIfConstraints((ICollection<CardData>) cardDataList, References.PlayerData.inventory.reserve, this.constraints);
    if (cardDataList.Count > 0)
    {
      this.Affect((IReadOnlyCollection<CardData>) cardDataList);
      yield break;
    }
  }

  public static void AddRangeIfConstraints(
    ICollection<CardData> collection,
    CardDataList toAdd,
    TargetConstraint[] constraints)
  {
    foreach (CardData cardData in toAdd)
      ScriptRunScriptsOnDeck.AddIfConstraints(collection, cardData, constraints);
  }

  public static void AddIfConstraints(
    ICollection<CardData> collection,
    CardData item,
    TargetConstraint[] constraints)
  {
    if (((IEnumerable<TargetConstraint>) constraints).Any<TargetConstraint>((Func<TargetConstraint, bool>) (c => !c.Check(item))))
      return;
    collection.Add(item);
  }

  public void Affect(IReadOnlyCollection<CardData> cards)
  {
    int num = this.countRange.Random();
    Debug.Log((object) ("[" + this.name + "] Affecting [" + string.Join<CardData>(", ", (IEnumerable<CardData>) cards) + "]"));
    using (AddressableGroup<CardScript> addressableGroup = new AddressableGroup<CardScript>(this.scriptRefs))
    {
      foreach (CardData target in (IEnumerable<CardData>) cards.InRandomOrder<CardData>())
      {
        foreach (CardScript cardScript in addressableGroup)
          cardScript.Run(target);
        --num;
        if (num <= 0)
          break;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptUpgradeEnemies
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Pool;

[CreateAssetMenu(fileName = "Upgrade Enemies", menuName = "Scripts/Upgrade Enemies")]
public class ScriptUpgradeEnemies : Script
{
  [SerializeField]
  public string[] illegalCards = new string[1]{ "Gobling" };
  [SerializeField]
  public CardUpgradeData[] upgradePool;
  [SerializeField]
  public ScriptUpgradeEnemies.Tier[] tiers;

  public override IEnumerator Run()
  {
    List<CardUpgradeData> currentPool = new List<CardUpgradeData>();
    using (List<CampaignNode>.Enumerator enumerator = References.Campaign.nodes.GetEnumerator())
    {
      while (enumerator.MoveNext())
      {
        CampaignNode current = enumerator.Current;
        if (current.type.isBattle)
        {
          BattleWaveManager.WaveData[] saveCollection = current.data.GetSaveCollection<BattleWaveManager.WaveData>("waves");
          int upgradeCount = this.tiers.Length > current.tier ? this.tiers[current.tier].upgradesRange.Random() : 0;
          if (upgradeCount > 0)
            this.AddUpgrades(currentPool, saveCollection, upgradeCount, this.tiers[current.tier].canAffectMiniboss);
        }
      }
      yield break;
    }
  }

  public void AddUpgrades(
    List<CardUpgradeData> currentPool,
    BattleWaveManager.WaveData[] waves,
    int upgradeCount,
    bool canUpgradeMiniboss)
  {
    foreach (BattleWaveManager.WaveData wave in waves)
    {
      if (this.TryAddUpgrade(currentPool, wave, canUpgradeMiniboss) && --upgradeCount <= 0)
        break;
    }
  }

  public bool TryAddUpgrade(
    List<CardUpgradeData> currentPool,
    BattleWaveManager.WaveData wave,
    bool canUpgradeMiniboss)
  {
    bool flag = false;
    List<int> intList = GenericPool<List<int>>.Get();
    intList.Clear();
    for (int index = 0; index < wave.Count; ++index)
      intList.Add(index);
    foreach (int cardIndex in (IEnumerable<int>) intList.InRandomOrder<int>())
    {
      if (this.TryAddUpgrade(currentPool, wave, cardIndex, canUpgradeMiniboss))
      {
        flag = true;
        break;
      }
    }
    GenericPool<List<int>>.Release(intList);
    return flag;
  }

  public bool TryAddUpgrade(
    List<CardUpgradeData> currentPool,
    BattleWaveManager.WaveData wave,
    int cardIndex,
    bool canUpgradeMiniboss)
  {
    if (this.IllegalCard(wave.GetCardName(cardIndex)))
      return false;
    CardData cardData = wave.PeekCardData(cardIndex);
    if (!(bool) (UnityEngine.Object) cardData || cardData.cardType.miniboss && !canUpgradeMiniboss)
      return false;
    CardUpgradeData cardUpgradeData = currentPool.Count > 0 ? currentPool.FirstOrDefault<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => wave.AddUpgradeToCard(cardIndex, a))) : (CardUpgradeData) null;
    if (!(bool) (UnityEngine.Object) cardUpgradeData)
    {
      currentPool.AddRange((IEnumerable<CardUpgradeData>) ((IEnumerable<CardUpgradeData>) this.upgradePool).InRandomOrder<CardUpgradeData>());
      cardUpgradeData = currentPool.FirstOrDefault<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => wave.AddUpgradeToCard(cardIndex, a)));
    }
    if (!(bool) (UnityEngine.Object) cardUpgradeData)
      return false;
    currentPool.Remove(cardUpgradeData);
    return true;
  }

  public bool IllegalCard(string cardDataName) => this.illegalCards.Contains<string>(cardDataName);

  [Serializable]
  public struct Tier
  {
    public Vector2Int upgradesRange;
    public bool canAffectMiniboss;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptUpgradeFinalBoss
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Upgrade Final Boss", menuName = "Scripts/Upgrade Final Boss")]
public class ScriptUpgradeFinalBoss : Script
{
  [SerializeField]
  public CardUpgradeData attackUpgrade;
  [SerializeField]
  public CardUpgradeData effectsUpgrade;
  [SerializeField]
  public TargetConstraint canBeBoostedConstraint;

  public override IEnumerator Run()
  {
    using (List<CampaignNode>.Enumerator enumerator = References.Campaign.nodes.GetEnumerator())
    {
      while (enumerator.MoveNext())
        this.AddUpgrade(enumerator.Current);
      yield break;
    }
  }

  public void AddUpgrade(CampaignNode node)
  {
    if (!node.type.isBattle || !node.type.isBoss || !(node.type.name == "CampaignNodeFinalBoss"))
      return;
    foreach (BattleWaveManager.WaveData save in node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves"))
    {
      if (save.isBossWave)
      {
        for (int index = 0; index < save.Count; ++index)
        {
          CardData cardData = save.GetCardData(index);
          if (cardData.cardType.miniboss)
          {
            CardUpgradeData upgradeData = this.GetUpgrade(cardData).Clone();
            save.AddUpgradeToCard(index, upgradeData);
          }
        }
      }
    }
  }

  public CardUpgradeData GetUpgrade(CardData cardData) => !this.canBeBoostedConstraint.Check(cardData) ? this.attackUpgrade : this.effectsUpgrade;
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptUpgradeMinibosses
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Upgrade Minibosses", menuName = "Scripts/Upgrade Minibosses")]
public class ScriptUpgradeMinibosses : Script
{
  [SerializeField]
  public ScriptUpgradeMinibosses.Profile[] profiles;
  [SerializeField]
  public CardUpgradeData[] defaultUpgrades;

  public override IEnumerator Run()
  {
    using (List<CampaignNode>.Enumerator enumerator = References.Campaign.nodes.GetEnumerator())
    {
      while (enumerator.MoveNext())
      {
        CampaignNode current = enumerator.Current;
        if (current.type.isBattle && !(current.type.name == "CampaignNodeFinalBoss"))
          this.AddUpgrade(current.data.GetSaveCollection<BattleWaveManager.WaveData>("waves"));
      }
      yield break;
    }
  }

  public void AddUpgrade(BattleWaveManager.WaveData[] waves)
  {
    foreach (BattleWaveManager.WaveData wave in waves)
    {
      if (wave.isBossWave)
      {
        for (int index = 0; index < wave.Count; ++index)
        {
          CardData cardData = wave.PeekCardData(index);
          if (cardData.cardType.miniboss)
          {
            CardUpgradeData upgrade = this.GetUpgrade(cardData.name);
            if (upgrade != null)
              wave.AddUpgradeToCard(index, upgrade);
          }
        }
      }
    }
  }

  public CardUpgradeData GetUpgrade(string cardDataName)
  {
    foreach (ScriptUpgradeMinibosses.Profile profile in this.profiles)
    {
      if (profile.cardDataNames.Contains<string>(cardDataName))
        return profile.possibleUpgrades.RandomItem<CardUpgradeData>();
    }
    return this.defaultUpgrades.RandomItem<CardUpgradeData>();
  }

  [Serializable]
  public struct Profile
  {
    public string[] cardDataNames;
    public CardUpgradeData[] possibleUpgrades;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScriptUpgradeSpecificEnemies
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Upgrade Specific Enemies", menuName = "Scripts/Upgrade Specific Enemies")]
public class ScriptUpgradeSpecificEnemies : Script
{
  [SerializeField]
  public ScriptUpgradeSpecificEnemies.Profile[] profiles;

  public override IEnumerator Run()
  {
    using (List<CampaignNode>.Enumerator enumerator = References.Campaign.nodes.GetEnumerator())
    {
      while (enumerator.MoveNext())
      {
        CampaignNode current = enumerator.Current;
        if (current.type.isBattle)
        {
          foreach (BattleWaveManager.WaveData save in current.data.GetSaveCollection<BattleWaveManager.WaveData>("waves"))
          {
            for (int index = 0; index < save.Count; ++index)
            {
              string cardName = save.GetCardName(index);
              ScriptUpgradeSpecificEnemies.Profile profile = ((IEnumerable<ScriptUpgradeSpecificEnemies.Profile>) this.profiles).FirstOrDefault<ScriptUpgradeSpecificEnemies.Profile>((Func<ScriptUpgradeSpecificEnemies.Profile, bool>) (a => a.cardData.name == cardName));
              if (profile != null)
              {
                foreach (CardUpgradeData upgrade in profile.upgrades)
                  save.AddUpgradeToCard(index, upgrade);
              }
            }
          }
        }
      }
      yield break;
    }
  }

  [Serializable]
  public class Profile
  {
    public CardData cardData;
    public CardUpgradeData[] upgrades;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Scroller
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;

public class Scroller : MonoBehaviourRect
{
  [SerializeField]
  public UINavigationLayer navLayer;
  public bool interactable = true;
  public float scrollSpeed = 0.2f;
  public float scrollAmount = 1f;
  public bool horizontal;
  public RectTransform bounds;
  [Range(0.0f, 1f)]
  public float boundsHardness = 0.2f;
  public UnityEvent onScroll;
  public UnityEvent<float> afterScroll;
  public Vector2 targetPos;
  public Vector2 preTargetPos;
  [SerializeField]
  public bool hasStartScroll;
  [SerializeField]
  [ShowIf("hasStartScroll")]
  [Range(0.0f, 1f)]
  public float startScroll;
  [SerializeField]
  public bool ignoreTimeScale;
  [Header("Scroll Knob")]
  [SerializeField]
  public RectTransform scrollKnob;
  [SerializeField]
  public RectTransform scrollKnobBounds;
  public float boundsDelay;
  public static float boundsDelayMax;
  public bool checkBounds;

  public float DeltaTime => !this.ignoreTimeScale ? Time.deltaTime : Time.unscaledDeltaTime;

  public float s => this.GetRelevant(this.rectTransform.rect.size) - this.GetRelevant(this.bounds.rect.size);

  public float TargetPos
  {
    get => !this.horizontal ? this.targetPos.y : this.targetPos.x;
    set
    {
      if (this.horizontal)
        this.targetPos.x = value;
      else
        this.targetPos.y = value;
    }
  }

  public float ScrollAmount
  {
    get => (this.s * 0.5f - this.TargetPos) / this.s;
    set => this.TargetPos = (float) (-(double) this.s * 0.5 + (double) value * (double) this.s);
  }

  public void Awake()
  {
    if (!(bool) (Object) this.bounds && this.transform.parent.transform is RectTransform transform)
      this.bounds = transform;
    if (this.navLayer == null)
      this.navLayer = this.FindComponentInParents<UINavigationLayer>(this.transform);
    this.UpdateScrollKnob();
    this.boundsDelay = Scroller.boundsDelayMax;
    this.InvokeAfterScroll();
    this.preTargetPos = this.targetPos;
  }

  public T FindComponentInParents<T>(Transform parent) where T : Component
  {
    T component;
    while (true)
    {
      component = parent.GetComponent<T>();
      if (!((Object) component != (Object) null))
      {
        if (!((Object) parent.parent == (Object) null))
          parent = parent.parent;
        else
          goto label_3;
      }
      else
        break;
    }
    return component;
label_3:
    return default (T);
  }

  public void OnEnable()
  {
    if (!this.hasStartScroll)
      return;
    this.ScrollTo(this.startScroll);
    this.rectTransform.anchoredPosition = this.targetPos;
  }

  public bool CheckNavigationLayer() => !(bool) (Object) this.navLayer || (Object) UINavigationSystem.ActiveNavigationLayer == (Object) this.navLayer;

  public void Update()
  {
    if (this.interactable && this.CheckNavigationLayer())
    {
      float num = 0.0f;
      if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        num = this.horizontal ? -Input.mouseScrollDelta.y : Input.mouseScrollDelta.y;
      if ((double) num != 0.0)
        this.Scroll(num * this.scrollAmount);
    }
    if ((double) this.boundsDelay > 0.0)
      this.boundsDelay -= this.DeltaTime;
    else if (this.checkBounds && (bool) (Object) this.bounds)
      this.CheckBounds();
    Vector2 anchoredPosition = this.rectTransform.anchoredPosition;
    if (!(anchoredPosition != this.targetPos))
      return;
    this.rectTransform.anchoredPosition = Delta.Lerp(anchoredPosition, this.targetPos, this.scrollSpeed, this.DeltaTime);
  }

  public void LateUpdate()
  {
    if (!(this.preTargetPos != this.targetPos))
      return;
    this.InvokeAfterScroll();
    this.preTargetPos = this.targetPos;
  }

  public void InvokeAfterScroll()
  {
    if (this.afterScroll == null || !(bool) (Object) this.bounds)
      return;
    float s = this.s;
    this.afterScroll.Invoke((float) (1.0 - ((double) this.TargetPos + (double) (s * 0.5f) - (double) this.GetRelevant((Vector2) this.bounds.localPosition)) / (double) s));
  }

  public void Scroll(float amount)
  {
    this.TargetPos -= amount;
    this.onScroll?.Invoke();
    this.UpdateScrollKnob();
    this.checkBounds = true;
  }

  public void ScrollImmediate(float amount)
  {
    this.TargetPos -= amount;
    this.onScroll?.Invoke();
    this.CheckBounds();
    this.rectTransform.anchoredPosition = this.targetPos;
    this.UpdateScrollKnob();
  }

  public void ScrollTo(float position)
  {
    this.ScrollAmount = position;
    this.onScroll?.Invoke();
    this.UpdateScrollKnob();
  }

  public void ScrollTo(Vector2 targetPos)
  {
    this.targetPos = targetPos;
    this.onScroll?.Invoke();
    this.UpdateScrollKnob();
    this.checkBounds = true;
  }

  public void CheckBounds()
  {
    Vector2 vector2_1 = this.bounds.rect.size * 0.5f;
    Vector2 anchoredPosition = this.bounds.anchoredPosition;
    float num1 = this.GetRelevant(anchoredPosition) - this.GetRelevant(vector2_1);
    float num2 = this.GetRelevant(anchoredPosition) + this.GetRelevant(vector2_1);
    Vector2 vector2_2 = this.rectTransform.rect.size * 0.5f;
    float num3 = this.TargetPos - this.GetRelevant(vector2_2);
    float num4 = this.TargetPos + this.GetRelevant(vector2_2);
    bool flag1 = (double) num3 >= (double) num1;
    bool flag2 = (double) num4 <= (double) num2;
    Vector2 targetPos = this.targetPos;
    if (flag1 | flag2)
    {
      Vector2 target = !(flag1 & flag2) ? (!flag1 ? this.AddRelevant(targetPos, num2 - num4) : this.AddRelevant(targetPos, num1 - num3)) : this.SetRelevant(targetPos, 0.0f);
      this.targetPos = (double) this.boundsHardness < 1.0 ? Delta.Lerp(this.targetPos, target, this.boundsHardness, this.DeltaTime) : target;
    }
    else
      this.checkBounds = false;
  }

  public float GetRelevant(Vector2 vector2) => !this.horizontal ? vector2.y : vector2.x;

  public Vector2 SetRelevant(Vector2 vector2, float value)
  {
    if (this.horizontal)
      vector2.x = value;
    else
      vector2.y = value;
    return vector2;
  }

  public Vector2 AddRelevant(Vector2 vector2, float value)
  {
    if (this.horizontal)
      vector2.x += value;
    else
      vector2.y += value;
    return vector2;
  }

  public void UpdateScrollKnob()
  {
    if (!(bool) (Object) this.scrollKnob || !(bool) (Object) this.scrollKnobBounds)
      return;
    float relevant = this.GetRelevant(this.scrollKnobBounds.rect.size);
    float num = (float) (-(double) relevant * 0.5 + (double) relevant * (double) Mathf.Clamp(this.ScrollAmount, 0.0f, 1f));
    LeanTween.cancel(this.scrollKnob);
    LeanTween.move(this.scrollKnob, (Vector3) (this.horizontal ? this.scrollKnob.anchoredPosition.WithX(num) : this.scrollKnob.anchoredPosition.WithY(num)), 0.2f).setEase(LeanTweenType.easeOutQuart);
  }

  public void SetInteractable(bool value) => this.interactable = value;

  public bool ContentLargerThanBounds() => !this.horizontal ? (double) this.rectTransform.sizeDelta.y > (double) this.bounds.sizeDelta.y : (double) this.rectTransform.sizeDelta.x > (double) this.bounds.sizeDelta.x;
}
﻿// Decompiled with JetBrains decompiler
// Type: ScrollerScrollTo
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class ScrollerScrollTo : MonoBehaviour
{
  [SerializeField]
  public Scroller scroller;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float scrollTo = 1f;
  [SerializeField]
  public bool onAwake;
  [SerializeField]
  public bool onEnable = true;
  [SerializeField]
  public float delay;
  [SerializeField]
  public bool instant;

  public void Awake()
  {
    if (!this.onAwake)
      return;
    this.StartCoroutine(this.Run());
  }

  public void OnEnable()
  {
    if (!this.onEnable)
      return;
    this.StartCoroutine(this.Run());
  }

  public IEnumerator Run()
  {
    if ((double) this.delay > 0.0)
      yield return (object) new WaitForSeconds(this.delay);
    this.scroller.ScrollTo(this.scrollTo);
    if (this.instant)
      this.scroller.rectTransform.anchoredPosition = this.scroller.targetPos;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScrollKnob
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ScrollKnob : MonoBehaviourRect
{
  [SerializeField]
  public RectTransform bounds;
  [SerializeField]
  public bool horizontal;
  public Vector2 targetPosition;

  public void Update() => this.rectTransform.anchoredPosition = Delta.Lerp(this.rectTransform.anchoredPosition, this.targetPosition, 0.33f, Time.deltaTime);

  public void SetPosition(Vector2 position) => this.SetPosition(this.GetRelevantAxis(position));

  public void SetPosition(float normalizedPosition)
  {
    float relevantAxis = this.GetRelevantAxis(this.bounds.rect.size);
    float num = (float) (-(double) relevantAxis * 0.5 + (double) relevantAxis * (double) Mathf.Clamp(normalizedPosition, 0.0f, 1f));
    if (this.horizontal)
      this.targetPosition.x = num;
    else
      this.targetPosition.y = num;
  }

  public float GetRelevantAxis(Vector2 vector2) => !this.horizontal ? vector2.y : vector2.x;
}
﻿// Decompiled with JetBrains decompiler
// Type: ScrollRectAuto
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof (ScrollRect))]
public class ScrollRectAuto : MonoBehaviour, IDragHandler, IEventSystemHandler, IScrollHandler
{
  public ScrollRect _scrollRect;
  [SerializeField]
  public float activateTime = 1f;
  [SerializeField]
  public float scrollSpeed = 1f;
  [SerializeField]
  public float acceleration = 1f;
  [SerializeField]
  public bool disableAtBottom = true;
  [SerializeField]
  public bool disableOnDrag = true;
  [SerializeField]
  public bool disableOnMouseScroll = true;
  [SerializeField]
  public bool reactivate = true;
  [SerializeField]
  [ShowIf("reactivate")]
  public float reactivateTime = 1f;
  [SerializeField]
  public UnityEvent onReachBottom;
  public float scrollSpeedCurrent;
  public static readonly Vector2 scroll = new Vector2(0.0f, 1f);
  public bool active = true;
  public float reactivateTimer;

  public ScrollRect scrollRect => this._scrollRect ?? (this._scrollRect = this.GetComponent<ScrollRect>());

  public void Update()
  {
    if (!(bool) (Object) this.scrollRect.content)
      return;
    if ((double) this.activateTime > 0.0)
      this.activateTime -= Time.deltaTime;
    else if (!this.active)
    {
      if ((double) this.reactivateTimer <= 0.0)
        return;
      this.reactivateTimer -= Time.deltaTime;
      if ((double) this.reactivateTimer > 0.0)
        return;
      this.active = true;
    }
    else
    {
      this.scrollSpeedCurrent = Delta.Lerp(this.scrollSpeedCurrent, this.scrollSpeed, this.acceleration, Time.deltaTime);
      this.scrollRect.content.anchoredPosition += ScrollRectAuto.scroll * (this.scrollSpeedCurrent * Time.deltaTime);
      if ((double) this.scrollRect.normalizedPosition.y > 0.0)
        return;
      this.onReachBottom?.Invoke();
      if (!this.disableAtBottom)
        return;
      this.Stop();
      this.reactivateTimer = 0.0f;
    }
  }

  public void OnDrag(PointerEventData eventData)
  {
    if (!this.disableOnDrag)
      return;
    this.Stop();
  }

  public void OnScroll(PointerEventData eventData)
  {
    if (!this.disableOnMouseScroll)
      return;
    this.Stop();
  }

  public void Stop()
  {
    this.active = false;
    if (this.reactivate)
      this.reactivateTimer = this.reactivateTime;
    this.scrollSpeedCurrent = 0.0f;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ScrollToNavigation
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class ScrollToNavigation : MonoBehaviour
{
  [SerializeField]
  public Scroller scroller;
  [SerializeField]
  public SmoothScrollRect scrollRect;

  public bool HasScroller => (bool) (Object) this.scroller;

  public bool HasScrollRect => (bool) (Object) this.scrollRect;

  public void OnEnable() => global::Events.OnUINavigation += new UnityAction(this.Navigation);

  public void OnDisable() => global::Events.OnUINavigation -= new UnityAction(this.Navigation);

  public void Navigation()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      return;
    UINavigationItem currentNavigationItem = MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem;
    if (this.HasScroller && this.scroller.ContentLargerThanBounds())
    {
      this.TryScrollScroller(currentNavigationItem.transform);
    }
    else
    {
      if (!this.HasScrollRect)
        return;
      this.TryScrollScrollRect(currentNavigationItem.transform);
    }
  }

  public void TryScrollScroller(Transform target)
  {
    if (!target.IsChildOf(this.scroller.transform))
      return;
    if (this.scroller.horizontal)
      this.ScrollScrollerHorizontal(target);
    else
      this.ScrollScrollerVertical(target);
  }

  public void ScrollScrollerVertical(Transform target) => this.scroller.ScrollTo(this.scroller.targetPos.WithY(this.scroller.transform.position.y - target.position.y));

  public void ScrollScrollerHorizontal(Transform target) => this.scroller.ScrollTo(this.scroller.targetPos.WithX(this.scroller.transform.position.x - target.position.x));

  public void TryScrollScrollRect(Transform target)
  {
    if (!target.IsChildOf(this.scrollRect.transform))
      return;
    if (this.scrollRect.horizontal)
      this.ScrollScrollRectHorizontal(target);
    else
      this.ScrollScrollRectVertical(target);
  }

  public void ScrollScrollRectVertical(Transform target) => this.scrollRect.ScrollTo(this.scrollRect.content.anchoredPosition.WithY((float) -((double) target.position.y - (double) this.scrollRect.content.position.y + (double) this.scrollRect.viewport.rect.size.y * 0.5)));

  public void ScrollScrollRectHorizontal(Transform target) => this.scrollRect.ScrollTo(this.scrollRect.content.anchoredPosition.WithX((float) -((double) target.position.x - (double) this.scrollRect.content.position.x + (double) this.scrollRect.viewport.rect.size.x * 0.5)));
}
﻿// Decompiled with JetBrains decompiler
// Type: SecretFinalBossSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class SecretFinalBossSystem : GameSystem
{
  [SerializeField]
  public string[] requireInDeck = new string[1]
  {
    "LuminVase"
  };
  [SerializeField]
  public string targetNodeName = "CampaignNodeFinalBoss";

  public void OnEnable() => global::Events.OnBattleEnd += new UnityAction(this.BattleEnd);

  public void OnDisable() => global::Events.OnBattleEnd -= new UnityAction(this.BattleEnd);

  public void BattleEnd() => this.CheckContinuePastFinalBoss(Campaign.FindCharacterNode(References.Player));

  public void CheckContinuePastFinalBoss(CampaignNode node)
  {
    if (!node.finalNode || !(node.type.name == this.targetNodeName) || !this.PlayerHasRequiredCards())
      return;
    SaveSystem.SaveCampaignData<bool>(Campaign.Data.GameMode, "trueWin", true);
    node.finalNode = false;
  }

  public bool PlayerHasRequiredCards()
  {
    List<string> list = this.requireInDeck.ToList<string>();
    foreach (CardData cardData in References.PlayerData.inventory.deck)
    {
      int index = list.IndexOf(cardData.name);
      if (index >= 0)
      {
        list.RemoveAt(index);
        if (list.Count <= 0)
          break;
      }
    }
    return list.Count <= 0;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SecretNakedGnomeSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class SecretNakedGnomeSystem : GameSystem
{
  public const string nakedGnomeDataName = "NakedGnome";
  public const string nakedGnomeFriendlyDataName = "NakedGnomeFriendly";
  public static bool nakedGnomeSaved;
  [SerializeField]
  public InspectNewUnitSequence gainNakedGnomeSequencePrefab;
  public static Vector3 startPos = new Vector3(0.0f, 8f, 0.0f);

  public void OnEnable()
  {
    global::Events.OnBattleEnd += new UnityAction(SecretNakedGnomeSystem.BattleEnd);
    global::Events.PostBattle += new UnityAction<CampaignNode>(this.PostBattle);
  }

  public void OnDisable()
  {
    global::Events.OnBattleEnd -= new UnityAction(SecretNakedGnomeSystem.BattleEnd);
    global::Events.PostBattle -= new UnityAction<CampaignNode>(this.PostBattle);
  }

  public static void BattleEnd() => SecretNakedGnomeSystem.nakedGnomeSaved = (bool) (UnityEngine.Object) Battle.GetCards(References.Battle.enemy).FirstOrDefault<Entity>((Func<Entity, bool>) (a => a.data.name == "NakedGnome"));

  public void PostBattle(CampaignNode campaignNode)
  {
    if (!SecretNakedGnomeSystem.nakedGnomeSaved)
      return;
    ActionQueue.Add((PlayAction) new ActionSequence(this.Sequence()));
    SecretNakedGnomeSystem.nakedGnomeSaved = false;
  }

  public IEnumerator Sequence()
  {
    InspectNewUnitSequence sequence = UnityEngine.Object.Instantiate<InspectNewUnitSequence>(this.gainNakedGnomeSequencePrefab, References.Player.entity.display.transform);
    sequence.cardSelector.character = References.Player;
    sequence.GetComponent<CardSelector>()?.selectEvent.AddListener(new UnityAction<Entity>(global::Events.InvokeEntityChosen));
    Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", "NakedGnomeFriendly").Clone(), (CardController) null, References.Player, false, true);
    card.transform.SetParent(sequence.cardHolder);
    card.transform.localPosition = SecretNakedGnomeSystem.startPos;
    yield return (object) card.UpdateData(false);
    sequence.SetUnit(card.entity, false);
    global::Events.InvokeEntityOffered(card.entity);
    yield return (object) sequence.Run();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SelectLeader
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

public class SelectLeader : MonoBehaviour, IRerollable
{
  [SerializeField]
  public int options = 3;
  [SerializeField]
  public int differentTribes = 3;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardContainer leaderCardContainer;
  [SerializeField]
  public InspectNewUnitSequence selectionSequence;
  [SerializeField]
  public TitleSetter titleSetter;
  [Header("Tribe Flags")]
  [SerializeField]
  public Transform flagGroup;
  [SerializeField]
  public TribeFlagDisplay flagBase;
  [SerializeField]
  public Vector3 flagOffset = new Vector3(0.0f, -4f);
  [SerializeField]
  public TribeDisplaySequence tribeDisplay;
  public readonly List<GameObject> flags = new List<GameObject>();
  [CompilerGenerated]
  public SelectLeader.Character \u003Ccurrent\u003Ek__BackingField;
  public List<SelectLeader.Character> characters;
  public Dictionary<ClassData, SelectLeader.LeaderPool> leaderPools;
  [CompilerGenerated]
  public bool \u003Cgenerating\u003Ek__BackingField;
  [CompilerGenerated]
  public bool \u003Crunning\u003Ek__BackingField;
  public int seed;

  public SelectLeader.Character current
  {
    get => this.\u003Ccurrent\u003Ek__BackingField;
    set => this.\u003Ccurrent\u003Ek__BackingField = value;
  }

  public bool generating
  {
    get => this.\u003Cgenerating\u003Ek__BackingField;
    set => this.\u003Cgenerating\u003Ek__BackingField = value;
  }

  public bool running
  {
    get => this.\u003Crunning\u003Ek__BackingField;
    set => this.\u003Crunning\u003Ek__BackingField = value;
  }

  public void Run(List<ClassData> tribes)
  {
    this.running = true;
    this.titleSetter.Set();
    this.leaderPools = new Dictionary<ClassData, SelectLeader.LeaderPool>();
    foreach (ClassData tribe in tribes)
      this.leaderPools[tribe] = new SelectLeader.LeaderPool(tribe);
  }

  public void Hide()
  {
    this.gameObject.SetActive(false);
    this.running = false;
  }

  public void Return()
  {
    this.running = true;
    this.gameObject.SetActive(true);
    LeanTween.cancel(this.gameObject);
    LeanTween.moveLocal(this.gameObject, Vector3.zero, 0.3f).setEaseOutQuint();
  }

  public void SetSeed(int seed)
  {
    this.seed = seed;
    UnityEngine.Random.InitState(seed);
    Names.Reset();
  }

  public IEnumerator GenerateLeaders(bool useSeed)
  {
    SelectLeader selectLeader1 = this;
    if (useSeed)
    {
      UnityEngine.Random.InitState(selectLeader1.seed);
      Names.Reset();
    }
    selectLeader1.generating = true;
    selectLeader1.Clear();
    List<ClassData> availableTribes = selectLeader1.leaderPools.Keys.ToList<ClassData>();
    availableTribes.Shuffle<ClassData>();
    List<ClassData> list = new List<ClassData>();
    for (int index = 0; index < Mathf.Min(selectLeader1.options, selectLeader1.differentTribes); ++index)
      list.Add(availableTribes[index % availableTribes.Count]);
    while (list.Count < selectLeader1.options)
      list.Add(availableTribes.RandomItem<ClassData>());
    if (list.Count > 1)
      list.Shuffle<ClassData>();
    List<Card> cardList = new List<Card>();
    for (int index = 0; index < selectLeader1.options; ++index)
      cardList.Add(selectLeader1.CreateLeader(list[index]));
    selectLeader1.SetLeaderPositions();
    foreach (EntityDisplay entityDisplay in cardList)
      yield return (object) entityDisplay.UpdateData();
    if (availableTribes.Count > 1)
    {
      foreach (SelectLeader.Character character in selectLeader1.characters)
      {
        SelectLeader selectLeader = selectLeader1;
        SelectLeader.Character c = character;
        Vector3 position = c.entity.transform.position + selectLeader1.flagOffset;
        TribeFlagDisplay tribeFlagDisplay = UnityEngine.Object.Instantiate<TribeFlagDisplay>(selectLeader1.flagBase, position, Quaternion.identity, selectLeader1.flagGroup);
        tribeFlagDisplay.SetFlagSprite(c.data.classData.flag);
        tribeFlagDisplay.AddPressAction((UnityAction) (() => selectLeader.tribeDisplay.Run(c.data.classData.name)));
        tribeFlagDisplay.gameObject.SetActive(true);
        selectLeader1.flags.Add(tribeFlagDisplay.gameObject);
      }
    }
    selectLeader1.generating = false;
  }

  public Card CreateLeader(ClassData classData)
  {
    CardData data1 = this.leaderPools[classData].Pull().Clone();
    PlayerData data2 = new PlayerData(classData, classData.startingInventory.Clone());
    CardController cardController = this.cardController;
    Card leader = CardManager.Get(data1, cardController, (global::Character) null, false, true);
    this.leaderCardContainer.Add(leader.entity);
    leader.entity.flipper.FlipDownInstant();
    this.characters.Add(new SelectLeader.Character(data2, leader.entity));
    return leader;
  }

  public void Clear()
  {
    if (this.characters == null)
      this.characters = new List<SelectLeader.Character>();
    foreach (SelectLeader.Character character in this.characters)
      character.Clear();
    this.current = (SelectLeader.Character) null;
    this.characters.Clear();
    this.StopAllCoroutines();
    this.flags.DestroyAllAndClear();
  }

  public void SetLeaderPositions()
  {
    List<MonoBehaviour> monoBehaviourList = new List<MonoBehaviour>();
    foreach (SelectLeader.Character character in this.characters)
    {
      foreach (AngleWobbler componentsInChild in character.entity.GetComponentsInChildren<AngleWobbler>())
      {
        if (componentsInChild.enabled)
        {
          componentsInChild.enabled = false;
          monoBehaviourList.Add((MonoBehaviour) componentsInChild);
        }
      }
    }
    this.leaderCardContainer.SetChildPositions();
    foreach (Behaviour behaviour in monoBehaviourList)
      behaviour.enabled = true;
  }

  public void FlipUpLeaders() => this.StartCoroutine(this.FlipUpRoutine());

  public void FlipUpLeadersInstant()
  {
    foreach (Entity entity in this.leaderCardContainer)
      entity.flipper.FlipUpInstant();
  }

  public IEnumerator FlipUpRoutine()
  {
    foreach (Entity entity in this.leaderCardContainer)
    {
      entity.flipper.FlipUp(true);
      yield return (object) Sequences.Wait(PettyRandom.Range(0.0f, 0.1f));
    }
  }

  public bool Reroll()
  {
    if (!this.generating)
    {
      InspectNewUnitSequence objectOfType = UnityEngine.Object.FindObjectOfType<InspectNewUnitSequence>();
      if (!InspectSystem.IsActive() && (!(bool) (UnityEngine.Object) objectOfType || !objectOfType.gameObject.activeSelf))
      {
        this.StartCoroutine(this.GenerateLeaders(false));
        CardPopUp.Clear();
        return true;
      }
    }
    return false;
  }

  public void Select(Entity entity)
  {
    if (!this.running)
      return;
    SelectLeader.Character character = this.characters.FirstOrDefault<SelectLeader.Character>((Func<SelectLeader.Character, bool>) (a => (UnityEngine.Object) a.entity == (UnityEngine.Object) entity));
    if (character == null)
      return;
    this.Select(character);
    this.selectionSequence.SetUnit(entity);
    this.selectionSequence.Begin();
    this.cardController.enabled = false;
    this.cardController.UnHover();
  }

  public void Select(SelectLeader.Character character) => this.current = character;

  public void Cancel()
  {
    this.current = (SelectLeader.Character) null;
    this.running = false;
    this.Clear();
  }

  public class Character
  {
    public PlayerData data;
    public Entity entity;

    public Character(PlayerData data, Entity entity)
    {
      this.data = data;
      this.entity = entity;
    }

    public void Clear()
    {
      if ((bool) (UnityEngine.Object) this.entity)
      {
        this.entity.RemoveFromContainers();
        CardManager.ReturnToPool(this.entity);
        UnityEngine.Object.Destroy((UnityEngine.Object) this.entity.data);
        UnityEngine.Object.Destroy((UnityEngine.Object) this.data.inventory);
      }
      this.data = (PlayerData) null;
    }

    public void AddLeaderToInventory()
    {
      global::Events.InvokeEntityChosen(this.entity);
      this.data.inventory.deck.Insert(0, this.entity.data);
    }
  }

  public class LeaderPool
  {
    public readonly ClassData classData;
    public readonly List<CardData> pool = new List<CardData>();

    public LeaderPool(ClassData classData) => this.classData = classData;

    public CardData Pull()
    {
      if (this.pool.Count <= 0)
      {
        this.pool.AddRange((IEnumerable<CardData>) this.classData.leaders);
        this.pool.Shuffle<CardData>();
      }
      CardData cardData = this.pool[0];
      this.pool.RemoveAt(0);
      return cardData;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SelectStartingPet
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

public class SelectStartingPet : MonoBehaviour, IRerollable
{
  [SerializeField]
  public SelectLeader leaderSelect;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardContainer leaderContainer;
  [SerializeField]
  public CardContainer group;
  [SerializeField]
  public InspectNewUnitSequence selectionSequence;
  [SerializeField]
  public GameObject text;
  [SerializeField]
  public Vector3 startPos = new Vector3(0.0f, -7f, 0.0f);
  [SerializeField]
  public GameObject winStreakDisplay;
  [SerializeField]
  public TitleSetter titleSetter;
  public string[] petData;
  public readonly List<Entity> pets = new List<Entity>();
  [CompilerGenerated]
  public bool \u003Crunning\u003Ek__BackingField;
  [CompilerGenerated]
  public int \u003CselectedPetIndex\u003Ek__BackingField = -1;
  public Entity leader;
  public CardContainer leaderPreContainer;
  public int leaderPreContainerIndex;

  public bool CanRun => this.petData != null && this.petData.Length > 1;

  public bool running
  {
    get => this.\u003Crunning\u003Ek__BackingField;
    set => this.\u003Crunning\u003Ek__BackingField = value;
  }

  public int selectedPetIndex
  {
    get => this.\u003CselectedPetIndex\u003Ek__BackingField;
    set => this.\u003CselectedPetIndex\u003Ek__BackingField = value;
  }

  public IEnumerator SetUp()
  {
    if (Campaign.Data.GameMode.takeStartingPet)
    {
      this.petData = MetaprogressionSystem.GetUnlockedPets();
      global::Routine.Clump clump = new global::Routine.Clump();
      foreach (string cardDataName in this.petData)
        clump.Add(this.CreateCard(cardDataName));
      yield return (object) clump.WaitForEnd();
    }
  }

  public IEnumerator CreateCard(string cardDataName)
  {
    Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", cardDataName).Clone(), this.cardController, (Character) null, false, true);
    this.group.Insert(0, card.entity);
    this.pets.Add(card.entity);
    card.transform.localScale = this.group.GetChildScale(card.entity);
    card.transform.localPosition = this.startPos;
    card.hover.SetHoverable(false);
    yield return (object) card.UpdateData(false);
  }

  public void Run(Entity leader)
  {
    if (this.running)
      return;
    this.StartCoroutine(this.Routine(leader));
  }

  public void Stop() => this.running = false;

  public void Cancel()
  {
    this.Stop();
    this.selectedPetIndex = -1;
    this.leader.RemoveFromContainers();
    this.leader.wobbler.WobbleRandom();
    this.leaderPreContainer.Insert(this.leaderPreContainerIndex, this.leader);
    this.leaderPreContainer.TweenChildPositions();
    if ((bool) (UnityEngine.Object) this.text)
      this.text.SetActive(false);
    foreach (Entity entity in (IEnumerable<Entity>) this.pets.OrderBy<Entity, float>((Func<Entity, float>) (a => UnityEngine.Random.Range(0.0f, 1f))))
    {
      LeanTween.moveLocal(entity.gameObject, this.startPos, 0.1f).setEaseInQuad().setDelay(UnityEngine.Random.Range(0.0f, 0.1f));
      entity.display.hover.SetHoverable(false);
    }
    this.winStreakDisplay.SetActive(true);
  }

  public IEnumerator Routine(Entity leader)
  {
    SelectStartingPet selectStartingPet = this;
    if (!selectStartingPet.running)
    {
      selectStartingPet.running = true;
      selectStartingPet.leader = leader;
      selectStartingPet.titleSetter.Set();
      selectStartingPet.winStreakDisplay.SetActive(false);
      selectStartingPet.leaderPreContainer = leader.actualContainers[0];
      selectStartingPet.leaderPreContainerIndex = selectStartingPet.leaderPreContainer.IndexOf(leader);
      leader.RemoveFromContainers();
      leader.wobbler.WobbleRandom();
      selectStartingPet.leaderContainer.Add(leader);
      selectStartingPet.leaderContainer.TweenChildPositions();
      selectStartingPet.leaderSelect.Hide();
      foreach (Entity child in (IEnumerable<Entity>) selectStartingPet.pets.OrderBy<Entity, float>((Func<Entity, float>) (a => UnityEngine.Random.Range(0.0f, 1f))))
      {
        selectStartingPet.group.TweenChildPosition(child);
        child.display.hover.SetHoverable(true);
        yield return (object) new WaitForSeconds(UnityEngine.Random.Range(0.0f, 0.1f));
      }
      if ((bool) (UnityEngine.Object) selectStartingPet.text)
      {
        selectStartingPet.text.SetActive(true);
        selectStartingPet.text.transform.localScale = Vector3.zero;
        LeanTween.scale(selectStartingPet.text, Vector3.one, 1f).setEaseOutElastic();
      }
      yield return (object) new WaitUntil(new Func<bool>(selectStartingPet.\u003CRoutine\u003Eb__29_0));
    }
  }

  public bool Reroll() => throw new NotImplementedException();

  public void Select(Entity entity)
  {
    if (!this.running)
      return;
    int num = this.pets.IndexOf(entity);
    if (num < 0)
      return;
    this.selectedPetIndex = num;
    this.selectionSequence.SetUnit(entity);
    this.selectionSequence.Begin();
    this.cardController.enabled = false;
    this.cardController.UnHover();
  }

  public void Gain(PlayerData playerData)
  {
    if (this.selectedPetIndex < 0 && this.pets.Count > 0)
      this.selectedPetIndex = 0;
    Entity pet = this.selectedPetIndex >= 0 ? this.pets[this.selectedPetIndex] : (Entity) null;
    if (!(bool) (UnityEngine.Object) pet)
      return;
    Events.InvokeEntityChosen(pet);
    playerData.inventory.deck.Insert(0, pet.data);
    MetaprogressionSystem.Set<int>("selectedPet", this.selectedPetIndex);
  }

  [CompilerGenerated]
  public bool \u003CRoutine\u003Eb__29_0() => !this.running;
}
﻿// Decompiled with JetBrains decompiler
// Type: SelectTribe
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class SelectTribe : MonoBehaviour
{
  [SerializeField]
  public TribeFlagDisplay tribeFlagPrefab;
  [SerializeField]
  public Transform tribeFlagGroup;
  [SerializeField]
  public SelectLeader leaderSelection;
  [SerializeField]
  public Transform selectedFlagAnchor;
  [SerializeField]
  public TitleSetter titleSetter;
  [SerializeField]
  public ParticleSystem selectParticleSystem;
  public readonly List<TribeFlagDisplay> flags = new List<TribeFlagDisplay>();
  public readonly List<ClassData> tribes = new List<ClassData>();

  public void SetAvailableTribes(List<ClassData> tribes)
  {
    this.tribes.Clear();
    this.tribes.AddRange((IEnumerable<ClassData>) tribes);
  }

  public void Run()
  {
    this.titleSetter.Set();
    foreach (ClassData tribe1 in this.tribes)
    {
      ClassData tribe = tribe1;
      TribeFlagDisplay flag = Object.Instantiate<TribeFlagDisplay>(this.tribeFlagPrefab, this.tribeFlagGroup);
      flag.SetAvailable();
      flag.SetUnlocked();
      flag.SetFlagSprite(tribe.flag);
      flag.AddPressAction((UnityAction) (() => this.StartSelectRoutine(flag, tribe)));
      this.flags.Add(flag);
    }
    this.selectedFlagAnchor.DestroyAllChildren();
  }

  public void RevealAnimation()
  {
    foreach (TribeFlagDisplay flag in this.flags)
    {
      Transform transform = flag.flagImage.transform;
      if (transform != null)
      {
        transform.localRotation = Quaternion.Euler(0.0f, 0.0f, PettyRandom.Range(-15f, -5f));
        LeanTween.cancel(transform.gameObject);
        LeanTween.rotateLocal(transform.gameObject, Vector3.zero, PettyRandom.Range(1f, 1.5f)).setEaseOutElastic();
        LeanTween.moveLocal(transform.gameObject, Vector3.zero, PettyRandom.Range(0.25f, 0.35f)).setFrom(Vector3.up * PettyRandom.Range(1f, 2f)).setEaseOutQuart();
      }
    }
  }

  public void StartSelectRoutine(TribeFlagDisplay flag, ClassData classData)
  {
    Routine routine = new Routine(this.SelectRoutine(flag, classData));
  }

  public IEnumerator SelectRoutine(TribeFlagDisplay flag, ClassData classData)
  {
    this.selectParticleSystem.transform.position = Cursor3d.PositionWithZ;
    this.selectParticleSystem.Play();
    if (!classData.selectSfxEvent.IsNull)
      SfxSystem.OneShot(classData.selectSfxEvent);
    flag.transform.SetParent(this.selectedFlagAnchor);
    this.tribeFlagGroup.DestroyAllChildren();
    this.flags.Clear();
    flag.ClearPressActions();
    flag.SetInteractable(false);
    this.tribes.Clear();
    this.tribes.Add(classData);
    flag.transform.localPosition = Vector3.up * 3f;
    LeanTween.cancel(flag.gameObject);
    LeanTween.moveLocal(flag.gameObject, Vector3.zero, PettyRandom.Range(0.2f, 0.3f)).setEaseOutQuart();
    Transform transform = flag.flagImage.transform;
    if (transform != null)
    {
      transform.localRotation = Quaternion.Euler(0.0f, 0.0f, PettyRandom.Range(10f, 15f));
      LeanTween.cancel(transform.gameObject);
      LeanTween.rotateLocal(transform.gameObject, Vector3.zero, PettyRandom.Range(1f, 1.5f)).setEaseOutElastic();
    }
    this.leaderSelection.Run(this.tribes);
    yield return (object) this.leaderSelection.GenerateLeaders(true);
    this.leaderSelection.FlipUpLeaders();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Sequences
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using UnityEngine;

public static class Sequences
{
  public static IEnumerator Wait(float seconds)
  {
    while ((double) seconds > 0.0)
    {
      seconds -= Time.deltaTime;
      if ((double) seconds <= 0.0)
        break;
      yield return (object) null;
    }
  }

  public static IEnumerator Null()
  {
    if (!GameManager.paused)
      yield return (object) new WaitForFixedUpdate();
  }

  public static IEnumerator WaitForAnimationEnd(Entity entity)
  {
    yield return (object) new WaitUntil((Func<bool>) (() => !entity.IsAliveAndExists() || !(bool) (UnityEngine.Object) entity.curveAnimator || !entity.curveAnimator.active));
  }

  public static IEnumerator WaitForStatusEffectEvents()
  {
    while (StatusEffectSystem.EventsRunning)
      yield return (object) null;
  }

  public static IEnumerator ShuffleTo(
    CardContainer fromContainer,
    CardContainer toContainer,
    float delayBetween = 0.05f)
  {
    if ((bool) (UnityEngine.Object) toContainer && toContainer.Empty && (bool) (UnityEngine.Object) fromContainer)
    {
      while (!fromContainer.Empty)
      {
        yield return (object) Sequences.CardMove(fromContainer[UnityEngine.Random.Range(0, fromContainer.Count)], new CardContainer[1]
        {
          toContainer
        });
        if ((double) delayBetween > 0.0)
          yield return (object) Sequences.Wait(delayBetween);
      }
      if ((double) delayBetween <= 0.0)
        toContainer.SetChildPositions();
    }
  }

  public static IEnumerator CardDiscard(Entity entity)
  {
    Debug.Log((object) string.Format("Discarding [{0}]", (object) entity));
    yield return (object) Sequences.CardMove(entity, new CardContainer[1]
    {
      entity.owner.discardContainer
    });
  }

  public static IEnumerator CardMove(
    Entity entity,
    CardContainer[] toContainers,
    int insertPos = -1,
    bool tweenAll = true)
  {
    bool enabled = entity.enabled;
    entity.RemoveFromContainers();
    if (insertPos >= 0)
    {
      foreach (CardContainer toContainer in toContainers)
        toContainer.Insert(insertPos, entity);
    }
    else
    {
      foreach (CardContainer toContainer in toContainers)
        toContainer.Add(entity);
    }
    entity.ResetDrawOrder();
    if (!entity.enabled & enabled)
      yield return (object) StatusEffectSystem.EntityDisableEvent(entity);
    if (tweenAll)
    {
      foreach (CardContainer toContainer in toContainers)
        toContainer.TweenChildPositions();
      if (toContainers.Length == 1 && toContainers[0] is CardSlotLane toContainer1)
      {
        foreach (Entity entity1 in (CardContainer) toContainer1)
        {
          if (entity1.height > 1)
          {
            foreach (CardContainer container in entity1.containers)
            {
              if ((UnityEngine.Object) container != (UnityEngine.Object) toContainer1)
                container.TweenChildPositions();
            }
          }
        }
      }
    }
    Events.InvokeEntityMove(entity);
    yield return (object) StatusEffectSystem.CardMoveEvent(entity);
  }

  public static IEnumerator CardRecall(Entity entity)
  {
    if ((bool) (UnityEngine.Object) entity.owner.discardContainer)
    {
      yield return (object) Sequences.Wait(0.3f);
      yield return (object) Sequences.CardMove(entity, new CardContainer[1]
      {
        entity.owner.discardContainer
      });
    }
    else if ((bool) (UnityEngine.Object) entity.owner.reserveContainer)
    {
      yield return (object) Sequences.Wait(0.3f);
      int insertPos = RandomInclusive.Range(0, entity.owner.reserveContainer.Count - 1);
      yield return (object) Sequences.CardMove(entity, new CardContainer[1]
      {
        entity.owner.reserveContainer
      }, insertPos);
    }
  }

  public static IEnumerator EndCampaign(string newSceneKey)
  {
    yield return (object) Transition.WaitUntilDone(Transition.Begin());
    if ((bool) (UnityEngine.Object) References.Campaign)
      References.Campaign.Final();
    Routine.Clump clump = new Routine.Clump();
    clump.Add(SceneManager.Unload("Campaign"));
    clump.Add(SceneManager.Unload("UI"));
    yield return (object) clump.WaitForEnd();
    yield return (object) Sequences.SceneChange(newSceneKey);
  }

  public static IEnumerator SceneChange(string newSceneKey)
  {
    string preActive = SceneManager.ActiveSceneKey;
    CardPopUp.Clear();
    yield return (object) SceneManager.Load(newSceneKey, SceneType.Active);
    yield return (object) SceneManager.Unload(preActive);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SetLanguage
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;

public class SetLanguage : MonoBehaviour
{
  [SerializeField]
  public TMP_Dropdown dropdown;
  [SerializeField]
  public Setting<int> setting;
  public bool init;

  public IEnumerator Start()
  {
    yield return (object) LocalizationSettings.InitializationOperation;
    this.dropdown.options = LocalizationSettings.AvailableLocales.Locales.Select<Locale, TMP_Dropdown.OptionData>((Func<Locale, TMP_Dropdown.OptionData>) (locale => new TMP_Dropdown.OptionData(locale.name))).ToList<TMP_Dropdown.OptionData>();
    this.init = true;
    this.OnEnable();
  }

  public void OnEnable()
  {
    if (!this.init || !((UnityEngine.Object) this.setting != (UnityEngine.Object) null))
      return;
    this.setting.SetValue(LocalizationSettings.AvailableLocales.Locales.IndexOf(LocalizationSettings.SelectedLocale));
  }

  public void Set(int value)
  {
    global::Settings.Save<string>("Language", LocalizationSettings.AvailableLocales.Locales[value].Identifier.Code);
    LocalizationSettings.SelectedLocale = LocalizationSettings.AvailableLocales.Locales[value];
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SetOtherActive
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class SetOtherActive : MonoBehaviour
{
  [SerializeField]
  public GameObject other;
  [SerializeField]
  public bool setOnEnable = true;
  [SerializeField]
  public float delay;
  [SerializeField]
  public bool setOnDisable;

  public void OnEnable()
  {
    if ((double) this.delay > 0.0)
      this.StartCoroutine(SetOtherActive.SetActiveAfter(this.other, this.setOnEnable, this.delay));
    else
      this.other.SetActive(this.setOnEnable);
  }

  public static IEnumerator SetActiveAfter(GameObject obj, bool active, float delay)
  {
    yield return (object) new WaitForSeconds(delay);
    obj.SetActive(active);
  }

  public void OnDisable()
  {
    this.StopAllCoroutines();
    this.other.SetActive(this.setOnDisable);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SetSettingFloat
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class SetSettingFloat : MonoBehaviour
{
  [SerializeField]
  public Setting<float> setting;
  [SerializeField]
  public string key = "ScreenShake";
  [SerializeField]
  public float defaultValue = 1f;

  public void OnEnable()
  {
    if (!((Object) this.setting != (Object) null))
      return;
    this.setting.SetValue(Settings.Load<float>(this.key, this.defaultValue));
  }

  public void Set(float value) => Settings.Save<float>(this.key, value);
}
﻿// Decompiled with JetBrains decompiler
// Type: SetSettingInt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class SetSettingInt : MonoBehaviour
{
  [SerializeField]
  public Setting<int> setting;
  [SerializeField]
  public string key = "Language";
  [SerializeField]
  public int defaultValue;

  public string Key => this.key;

  public void OnEnable()
  {
    if (!((Object) this.setting != (Object) null))
      return;
    this.setting.SetValue(Settings.Load<int>(this.key, this.defaultValue));
  }

  public void Set(int value) => Settings.Save<int>(this.key, value);
}
﻿// Decompiled with JetBrains decompiler
// Type: SetStartingHand
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class SetStartingHand : MonoBehaviour
{
  [SerializeField]
  public CardData[] startingHand;

  public void OnEnable() => global::Events.OnBattleStart += new UnityAction(this.BattleStart);

  public void OnDisable() => global::Events.OnBattleStart -= new UnityAction(this.BattleStart);

  public void BattleStart() => References.Player.OrderNextCards(((IEnumerable<CardData>) this.startingHand).Select<CardData, string>((Func<CardData, string>) (a => a.name)).ToArray<string>());
}
﻿// Decompiled with JetBrains decompiler
// Type: SettingOptions
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class SettingOptions : Setting<int>
{
  [SerializeField]
  public TMP_Dropdown dropdown;
  [SerializeField]
  public GameObject tweener;
  [SerializeField]
  public AnimationCurve tweenCurve;
  [SerializeField]
  public float tweenDur = 0.33f;
  [SerializeField]
  public UnityEvent<int> onValueChanged;

  public override void SetValue(int value)
  {
    if (value < 0)
      value += this.dropdown.options.Count;
    value %= this.dropdown.options.Count;
    this.dropdown.value = value;
  }

  public void Add(float single)
  {
    if ((double) single > 0.0)
    {
      this.Increase();
    }
    else
    {
      if ((double) single >= 0.0)
        return;
      this.Decrease();
    }
  }

  public void Increase()
  {
    this.SetValue(this.dropdown.value + 1);
    this.Tween(1);
    this.onValueChanged?.Invoke(this.dropdown.value);
  }

  public void Decrease()
  {
    this.SetValue(this.dropdown.value - 1);
    this.Tween(-1);
    this.onValueChanged?.Invoke(this.dropdown.value);
  }

  public void Tween(int dir)
  {
    LeanTween.cancel(this.tweener);
    LeanTween.moveLocalX(this.tweener, 0.1f * (float) dir, this.tweenDur).setFrom(0.0f).setEase(this.tweenCurve).setIgnoreTimeScale(true);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Settings
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public static class Settings
{
  public static readonly ES3Settings settings = new ES3Settings(new Enum[1]
  {
    (Enum) ES3.Directory.PersistentDataPath
  })
  {
    path = "settings.json",
    encryptionType = ES3.EncryptionType.None,
    compressionType = ES3.CompressionType.None,
    prettyPrint = true
  };

  public static void Save<T>(string key, T value)
  {
    try
    {
      ES3.Save<T>(key, value, Settings.settings);
    }
    catch (FormatException ex1)
    {
      Debug.LogWarning((object) ex1);
      ES3.DeleteFile(Settings.settings);
      try
      {
        ES3.Save<T>(key, value, Settings.settings);
      }
      catch (Exception ex2)
      {
        Debug.LogError((object) string.Format("ES3 Failed to save Settings even after deleting file.\n{0}", (object) ex2));
      }
    }
    Events.InvokeSettingChanged(key, (object) value);
    Debug.Log((object) string.Format("Setting Saved [{0} = {1}]", (object) key, (object) value));
  }

  public static T Load<T>(string key, T defaultValue)
  {
    T obj = defaultValue;
    try
    {
      obj = ES3.Load<T>(key, defaultValue, Settings.settings);
    }
    catch (Exception ex)
    {
      Debug.LogWarning((object) ex);
    }
    Debug.Log((object) string.Format("Setting Loaded [{0} = {1}]", (object) key, (object) obj));
    return obj;
  }

  public static bool Exists(string key)
  {
    try
    {
      return ES3.KeyExists(key, Settings.settings);
    }
    catch (Exception ex)
    {
      Debug.LogWarning((object) ex);
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SettingSlider
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class SettingSlider : Setting<float>
{
  [SerializeField]
  public Slider slider;

  public override void SetValue(float value) => this.slider.value = value;
}
﻿// Decompiled with JetBrains decompiler
// Type: SettingsLocaleSelector
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;

[Serializable]
public class SettingsLocaleSelector : IStartupLocaleSelector
{
  [SerializeField]
  public string settingsKey = "Language";

  public Locale GetStartupLocale(ILocalesProvider availableLocales)
  {
    if (global::Settings.Exists(this.settingsKey))
    {
      string str = global::Settings.Load<string>(this.settingsKey, "");
      if (!str.IsNullOrWhitespace())
        return availableLocales.GetLocale((LocaleIdentifier) str);
    }
    return (Locale) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Setting`1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public abstract class Setting<T> : MonoBehaviour
{
  public virtual void SetValue(T value)
  {
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SetVolume
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class SetVolume : MonoBehaviour
{
  [SerializeField]
  public string busName = "Master";
  [SerializeField]
  public Setting<float> setting;

  public void OnEnable()
  {
    if (!((Object) this.setting != (Object) null))
      return;
    this.setting.SetValue(AudioSettingsSystem.GetVolume(this.busName));
  }

  public void Set(float value) => AudioSettingsSystem.Volume(this.busName, value);
}
﻿// Decompiled with JetBrains decompiler
// Type: SfxLoop
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMOD.Studio;
using FMODUnity;
using NaughtyAttributes;
using System;
using UnityEngine;

public class SfxLoop : MonoBehaviour
{
  [SerializeField]
  public bool onEnable = true;
  [SerializeField]
  public bool useAreaAmbience;
  [SerializeField]
  [HideIf("useAreaAmbience")]
  public EventReference eventRef;
  [SerializeField]
  public SfxLoop.Param[] @params;
  public EventInstance loop;
  public bool playing;

  public EventReference e => !this.useAreaAmbience ? this.eventRef : References.GetCurrentArea().ambienceEvent;

  public void OnEnable()
  {
    if (!this.onEnable)
      return;
    this.Play();
  }

  public void OnDisable() => this.Stop();

  public void Play()
  {
    this.loop = SfxSystem.Loop(this.e);
    foreach (SfxLoop.Param obj in this.@params)
      this.SetParam(obj.name, obj.value);
    this.playing = true;
  }

  public void Stop()
  {
    if (!this.playing)
      return;
    SfxSystem.EndLoop(new EventInstance?(this.loop));
    this.playing = false;
  }

  public void SetParam(string name, float value) => SfxSystem.SetParam(this.loop, name, value);

  public void SetParam(float value)
  {
    if (this.@params.Length == 0)
      return;
    this.SetParam(this.@params[0].name, value);
  }

  [Serializable]
  public struct Param
  {
    public string name;
    public float value;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SfxOneshot
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using NaughtyAttributes;
using System.Collections;
using UnityEngine;

public class SfxOneshot : MonoBehaviour
{
  [SerializeField]
  public EventReference eventRef;
  [SerializeField]
  [HideIf("onEnable")]
  public bool onAwake;
  [SerializeField]
  [HideIf("onAwake")]
  public bool onEnable = true;
  [SerializeField]
  public float pitch = 1f;
  [SerializeField]
  public float delay;

  public void Awake()
  {
    if (!this.onAwake || this.onEnable)
      return;
    if ((double) this.delay > 0.0)
      this.StartCoroutine(this.FireAfterDelay());
    else
      this.Fire();
  }

  public void OnEnable()
  {
    if (!this.onEnable)
      return;
    if ((double) this.delay > 0.0)
      this.StartCoroutine(this.FireAfterDelay());
    else
      this.Fire();
  }

  public void Fire()
  {
    int num = (int) SfxSystem.OneShot(this.eventRef).setPitch(this.pitch);
  }

  public IEnumerator FireAfterDelay()
  {
    yield return (object) new WaitForSeconds(this.delay);
    this.Fire();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SfxSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMOD;
using FMOD.Studio;
using FMODUnity;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class SfxSystem : GameSystem
{
  public static SfxSystem instance;
  public const float DRAG_THRESHOLD = 0.35f;
  public static readonly Dictionary<string, float> cooldownTimers = new Dictionary<string, float>()
  {
    {
      "event:/sfx/card/hover",
      0.1f
    },
    {
      "event:/sfx/card/flip_single",
      0.075f
    },
    {
      "event:/sfx/card/enter_pocket",
      0.1f
    },
    {
      "event:/sfx/status/block",
      0.05f
    },
    {
      "event:/sfx/status/demonize",
      0.05f
    },
    {
      "event:/sfx/status/heal",
      0.05f
    },
    {
      "event:/sfx/status/power",
      0.05f
    },
    {
      "event:/sfx/status/shell",
      0.05f
    },
    {
      "event:/sfx/status/shroom",
      0.05f
    },
    {
      "event:/sfx/status/snow",
      0.05f
    },
    {
      "event:/sfx/status/spice",
      0.05f
    },
    {
      "event:/sfx/status/sun",
      0.05f
    },
    {
      "event:/sfx/status/teeth",
      0.05f
    },
    {
      "event:/sfx/status/overburn",
      0.05f
    },
    {
      "event:/sfx/status/scrap",
      0.05f
    },
    {
      "event:/sfx/status/frenzy",
      0.05f
    },
    {
      "event:/sfx/status/frost",
      0.05f
    },
    {
      "event:/sfx/status/haze",
      0.05f
    },
    {
      "event:/sfx/status/ink",
      0.05f
    },
    {
      "event:/sfx/status/bom",
      0.05f
    },
    {
      "event:/sfx/location/shop/crown_hover",
      0.05f
    },
    {
      "event:/sfx/location/shop/charm_hover",
      0.05f
    },
    {
      "event:/sfx/card/ping",
      0.05f
    }
  };
  public static readonly Dictionary<string, SfxSystem.Cooldown> cooldowns = new Dictionary<string, SfxSystem.Cooldown>();
  [SerializeField]
  public AnimationCurve pathRevealPitch;
  [SerializeField]
  public EventReference test;
  public List<EventInstance> running;
  public Entity dragging;
  public Entity draggingItem;
  public bool dragTrigger;
  public Vector2 dragFrom;
  public EventInstance itemAim;
  public int revealActionsInQueue;
  public EventInstance flipMulti;
  public EventInstance transitionSnow;
  public EventInstance goldCounter;
  public EventInstance muncherFeed;
  public EventInstance drawMulti;
  public EventInstance townProgressionLoop;
  public GoldDisplay goldDisplay;

  public void OnEnable()
  {
    SfxSystem.instance = this;
    global::Events.OnEntityHit += new UnityAction<Hit>(SfxSystem.EntityHit);
    global::Events.OnEntityHover += new UnityAction<Entity>(SfxSystem.EntityHover);
    global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(SfxSystem.EntityKilled);
    global::Events.OnEntitySelect += new UnityAction<Entity>(SfxSystem.EntitySelect);
    global::Events.OnEntityDrag += new UnityAction<Entity>(this.EntityDrag);
    global::Events.OnEntityRelease += new UnityAction<Entity>(this.EntityRelease);
    global::Events.OnEntityPlace += new UnityAction<Entity, CardContainer[], bool>(SfxSystem.EntityPlace);
    global::Events.OnEntityFlipUp += new UnityAction<Entity>(SfxSystem.EntityFlipUp);
    global::Events.OnEntityFlipDown += new UnityAction<Entity>(SfxSystem.EntityFlipDown);
    global::Events.OnEntityTrigger += new global::Events.UnityActionRef<Trigger>(SfxSystem.EntityTrigger);
    global::Events.OnEntityMove += new UnityAction<Entity>(SfxSystem.EntityMove);
    global::Events.OnEntityFocus += new UnityAction<Entity>(SfxSystem.Focus);
    global::Events.OnEntityEnterPocket += new UnityAction<Entity, CardPocket>(SfxSystem.EntityEnterPocket);
    global::Events.OnEntityEnterBackpack += new UnityAction<Entity>(SfxSystem.EntityEnterBackpack);
    global::Events.OnNoomlinShow += new UnityAction<Entity>(SfxSystem.NoomlinShow);
    global::Events.OnNoomlinUsed += new UnityAction<Entity>(SfxSystem.NoomlinUsed);
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(SfxSystem.BattlePhaseStart);
    global::Events.OnStatusEffectApplied += new UnityAction<StatusEffectApply>(SfxSystem.StatusApplied);
    global::Events.OnCardDraw += new UnityAction<int>(this.CardDraw);
    global::Events.OnCardDrawEnd += new UnityAction(this.CardDrawEnd);
    global::Events.OnStatusIconChanged += new UnityAction<StatusIcon, Stat, Stat>(SfxSystem.StatusIconChanged);
    global::Events.OnDropGold += new UnityAction<int, string, Character, Vector3>(SfxSystem.DropGold);
    global::Events.OnGoldFlyToBag += new UnityAction<int, Character, Vector3>(SfxSystem.GoldFlyToBag);
    global::Events.OnCollectGold += new UnityAction<int>(SfxSystem.CollectGold);
    global::Events.OnDeckpackOpen += new UnityAction(SfxSystem.DeckpackOpen);
    global::Events.OnDeckpackClose += new UnityAction(SfxSystem.DeckpackClose);
    global::Events.OnMapPathReveal += new UnityAction<float>(this.MapPathReveal);
    global::Events.OnMapNodeReveal += new UnityAction<MapNode>(SfxSystem.MapNodeReveal);
    global::Events.OnMapNodeHover += new UnityAction<MapNode>(SfxSystem.MapNodeHover);
    global::Events.OnMapNodeSelect += new UnityAction<MapNode>(SfxSystem.MapNodeSelect);
    global::Events.OnActionQueued += new UnityAction<PlayAction>(this.ActionQueued);
    global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerform);
    global::Events.OnActionFinished += new UnityAction<PlayAction>(this.ActionFinished);
    global::Events.OnTransitionStart += new UnityAction<TransitionType>(this.TransitionStart);
    global::Events.OnTransitionEnd += new UnityAction<TransitionType>(this.TransitionEnd);
    global::Events.OnGoldCounterStart += new UnityAction<GoldDisplay, float>(this.GoldCounterStart);
    global::Events.OnMuncherDrag += new UnityAction(this.MuncherDrag);
    global::Events.OnMuncherDragCancel += new UnityAction(this.MuncherDragEnd);
    global::Events.OnMuncherFeed += new UnityAction<Entity>(this.MuncherFeed);
    global::Events.OnBombardShoot += new UnityAction<Entity>(SfxSystem.BombardShoot);
    global::Events.OnBombardRocketFall += new UnityAction<BombardRocket>(SfxSystem.BombardRocketFall);
    global::Events.OnBombardRocketExplode += new UnityAction<BombardRocket>(SfxSystem.BombardRocketExplode);
    global::Events.OnButtonHover += new UnityAction<ButtonType>(SfxSystem.ButtonHover);
    global::Events.OnButtonPress += new UnityAction<ButtonType>(SfxSystem.ButtonPress);
    global::Events.OnProgressStart += new UnityAction<float>(this.ProgressStart);
    global::Events.OnProgressUpdate += new UnityAction<float>(this.ProgressUpdate);
    global::Events.OnProgressStop += new UnityAction(this.ProgressStop);
    global::Events.OnProgressDing += new UnityAction(SfxSystem.ProgressDing);
    global::Events.OnProgressBlip += new UnityAction(SfxSystem.ProgressBlip);
    global::Events.OnTownUnlock += new UnityAction<UnlockData>(SfxSystem.TownUnlockPopUp);
    global::Events.OnUpgradeHover += new UnityAction<UpgradeDisplay>(SfxSystem.UpgradeHover);
    global::Events.OnUpgradePickup += new UnityAction<UpgradeDisplay>(SfxSystem.UpgradePickup);
    global::Events.OnUpgradeDrop += new UnityAction<UpgradeDisplay>(SfxSystem.UpgradeDrop);
    global::Events.OnUpgradeAssign += new UnityAction<Entity, CardUpgradeData>(SfxSystem.UpgradeAssign);
    global::Events.OnShopItemHover += new UnityAction<ShopItem>(SfxSystem.ShopItemHover);
    global::Events.OnAbilityTargetAdd += new UnityAction<CardContainer>(SfxSystem.AbilityTargetAdd);
    global::Events.OnEntityPing += new UnityAction<GameObject>(SfxSystem.EntityPing);
    this.running = new List<EventInstance>();
    SfxSystem.cooldowns.Clear();
    foreach (KeyValuePair<string, float> cooldownTimer in SfxSystem.cooldownTimers)
      SfxSystem.cooldowns[cooldownTimer.Key] = new SfxSystem.Cooldown(cooldownTimer.Key, cooldownTimer.Value);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHit -= new UnityAction<Hit>(SfxSystem.EntityHit);
    global::Events.OnEntityHover -= new UnityAction<Entity>(SfxSystem.EntityHover);
    global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(SfxSystem.EntityKilled);
    global::Events.OnEntitySelect -= new UnityAction<Entity>(SfxSystem.EntitySelect);
    global::Events.OnEntityDrag -= new UnityAction<Entity>(this.EntityDrag);
    global::Events.OnEntityRelease -= new UnityAction<Entity>(this.EntityRelease);
    global::Events.OnEntityPlace -= new UnityAction<Entity, CardContainer[], bool>(SfxSystem.EntityPlace);
    global::Events.OnEntityFlipUp -= new UnityAction<Entity>(SfxSystem.EntityFlipUp);
    global::Events.OnEntityFlipDown -= new UnityAction<Entity>(SfxSystem.EntityFlipDown);
    global::Events.OnEntityTrigger -= new global::Events.UnityActionRef<Trigger>(SfxSystem.EntityTrigger);
    global::Events.OnEntityMove -= new UnityAction<Entity>(SfxSystem.EntityMove);
    global::Events.OnEntityFocus -= new UnityAction<Entity>(SfxSystem.Focus);
    global::Events.OnEntityEnterPocket -= new UnityAction<Entity, CardPocket>(SfxSystem.EntityEnterPocket);
    global::Events.OnEntityEnterBackpack -= new UnityAction<Entity>(SfxSystem.EntityEnterBackpack);
    global::Events.OnNoomlinShow -= new UnityAction<Entity>(SfxSystem.NoomlinShow);
    global::Events.OnNoomlinUsed -= new UnityAction<Entity>(SfxSystem.NoomlinUsed);
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(SfxSystem.BattlePhaseStart);
    global::Events.OnStatusEffectApplied -= new UnityAction<StatusEffectApply>(SfxSystem.StatusApplied);
    global::Events.OnCardDraw -= new UnityAction<int>(this.CardDraw);
    global::Events.OnCardDrawEnd -= new UnityAction(this.CardDrawEnd);
    global::Events.OnStatusIconChanged -= new UnityAction<StatusIcon, Stat, Stat>(SfxSystem.StatusIconChanged);
    global::Events.OnDropGold -= new UnityAction<int, string, Character, Vector3>(SfxSystem.DropGold);
    global::Events.OnGoldFlyToBag -= new UnityAction<int, Character, Vector3>(SfxSystem.GoldFlyToBag);
    global::Events.OnCollectGold -= new UnityAction<int>(SfxSystem.CollectGold);
    global::Events.OnDeckpackOpen -= new UnityAction(SfxSystem.DeckpackOpen);
    global::Events.OnDeckpackClose -= new UnityAction(SfxSystem.DeckpackClose);
    global::Events.OnMapPathReveal -= new UnityAction<float>(this.MapPathReveal);
    global::Events.OnMapNodeReveal -= new UnityAction<MapNode>(SfxSystem.MapNodeReveal);
    global::Events.OnMapNodeHover -= new UnityAction<MapNode>(SfxSystem.MapNodeHover);
    global::Events.OnMapNodeSelect -= new UnityAction<MapNode>(SfxSystem.MapNodeSelect);
    global::Events.OnActionQueued -= new UnityAction<PlayAction>(this.ActionQueued);
    global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerform);
    global::Events.OnActionFinished -= new UnityAction<PlayAction>(this.ActionFinished);
    global::Events.OnTransitionStart -= new UnityAction<TransitionType>(this.TransitionStart);
    global::Events.OnTransitionEnd -= new UnityAction<TransitionType>(this.TransitionEnd);
    global::Events.OnGoldCounterStart -= new UnityAction<GoldDisplay, float>(this.GoldCounterStart);
    global::Events.OnMuncherDrag -= new UnityAction(this.MuncherDrag);
    global::Events.OnMuncherDragCancel -= new UnityAction(this.MuncherDragEnd);
    global::Events.OnMuncherFeed -= new UnityAction<Entity>(this.MuncherFeed);
    global::Events.OnBombardShoot -= new UnityAction<Entity>(SfxSystem.BombardShoot);
    global::Events.OnBombardRocketFall -= new UnityAction<BombardRocket>(SfxSystem.BombardRocketFall);
    global::Events.OnBombardRocketExplode -= new UnityAction<BombardRocket>(SfxSystem.BombardRocketExplode);
    global::Events.OnButtonHover -= new UnityAction<ButtonType>(SfxSystem.ButtonHover);
    global::Events.OnButtonPress -= new UnityAction<ButtonType>(SfxSystem.ButtonPress);
    global::Events.OnProgressStart -= new UnityAction<float>(this.ProgressStart);
    global::Events.OnProgressUpdate -= new UnityAction<float>(this.ProgressUpdate);
    global::Events.OnProgressStop -= new UnityAction(this.ProgressStop);
    global::Events.OnProgressDing -= new UnityAction(SfxSystem.ProgressDing);
    global::Events.OnProgressBlip -= new UnityAction(SfxSystem.ProgressBlip);
    global::Events.OnTownUnlock -= new UnityAction<UnlockData>(SfxSystem.TownUnlockPopUp);
    global::Events.OnUpgradeHover -= new UnityAction<UpgradeDisplay>(SfxSystem.UpgradeHover);
    global::Events.OnUpgradePickup -= new UnityAction<UpgradeDisplay>(SfxSystem.UpgradePickup);
    global::Events.OnUpgradeDrop -= new UnityAction<UpgradeDisplay>(SfxSystem.UpgradeDrop);
    global::Events.OnUpgradeAssign -= new UnityAction<Entity, CardUpgradeData>(SfxSystem.UpgradeAssign);
    global::Events.OnShopItemHover -= new UnityAction<ShopItem>(SfxSystem.ShopItemHover);
    global::Events.OnAbilityTargetAdd -= new UnityAction<CardContainer>(SfxSystem.AbilityTargetAdd);
    global::Events.OnEntityPing -= new UnityAction<GameObject>(SfxSystem.EntityPing);
    this.StopAll();
    this.running = (List<EventInstance>) null;
  }

  public void Update()
  {
    for (int index = this.running.Count - 1; index >= 0; --index)
    {
      EventInstance eventInstance = this.running[index];
      if (!SfxSystem.IsRunning(eventInstance))
      {
        int num = (int) eventInstance.release();
        this.running.RemoveAt(index);
      }
    }
    foreach (KeyValuePair<string, SfxSystem.Cooldown> cooldown in SfxSystem.cooldowns)
    {
      if ((double) cooldown.Value.current > 0.0)
        cooldown.Value.current -= Time.deltaTime;
    }
    if (this.dragTrigger)
    {
      if (!(bool) (Object) this.dragging)
        this.dragTrigger = false;
      else if ((double) ((Vector2) this.dragging.transform.position - this.dragFrom).sqrMagnitude > 0.34999999403953552)
      {
        this.dragTrigger = false;
        SfxSystem.OneShot("event:/sfx/card/drag");
      }
    }
    if (!SfxSystem.IsRunning(this.goldCounter) || (bool) (Object) this.goldDisplay && (double) this.goldDisplay.add != 0.0)
      return;
    SfxSystem.Stop(this.goldCounter);
    this.goldDisplay = (GoldDisplay) null;
  }

  public static EventInstance OneShot(EventReference eventRef) => SfxSystem.OneShot(eventRef.Guid);

  public static EventInstance OneShot(GUID guid)
  {
    EventInstance instance = RuntimeManager.CreateInstance(guid);
    int num = (int) instance.start();
    return instance;
  }

  public static void OneShot(string eventName) => RuntimeManager.PlayOneShot(eventName);

  public static void OneShotCheckCooldown(string eventName, bool resetCooldown = true)
  {
    if (!SfxSystem.CheckCooldown(eventName))
      return;
    SfxSystem.OneShot(eventName);
    if (!resetCooldown)
      return;
    SfxSystem.SetCooldown(eventName);
  }

  public static void OneShot(string eventName, params SfxSystem.Param[] parameters)
  {
    EventInstance instance = RuntimeManager.CreateInstance(eventName);
    foreach (SfxSystem.Param parameter in parameters)
    {
      int num = (int) instance.setParameterByName(parameter.name, parameter.value);
    }
    int num1 = (int) instance.start();
    int num2 = (int) instance.release();
  }

  public EventInstance Play(string eventPath, params SfxSystem.Param[] parameters)
  {
    try
    {
      EventInstance instance = RuntimeManager.CreateInstance(eventPath);
      foreach (SfxSystem.Param parameter in parameters)
      {
        int num = (int) instance.setParameterByName(parameter.name, parameter.value);
      }
      this.running.Add(instance);
      int num1 = (int) instance.start();
      return instance;
    }
    catch (EventNotFoundException ex)
    {
      UnityEngine.Debug.LogWarning((object) ex);
      return new EventInstance();
    }
  }

  public EventInstance Play(EventReference eventRef, params SfxSystem.Param[] parameters)
  {
    try
    {
      EventInstance instance = RuntimeManager.CreateInstance(eventRef);
      foreach (SfxSystem.Param parameter in parameters)
      {
        int num = (int) instance.setParameterByName(parameter.name, parameter.value);
      }
      this.running.Add(instance);
      int num1 = (int) instance.start();
      return instance;
    }
    catch (EventNotFoundException ex)
    {
      UnityEngine.Debug.LogWarning((object) ex);
      return new EventInstance();
    }
  }

  public static void SetParam(EventInstance eventInstance, string param, float value)
  {
    if (!SfxSystem.IsRunning(eventInstance))
      return;
    int num = (int) eventInstance.setParameterByName(param, value);
  }

  public static void Stop(EventInstance eventInstance, FMOD.Studio.STOP_MODE stopMode = FMOD.Studio.STOP_MODE.ALLOWFADEOUT)
  {
    if (!SfxSystem.IsRunning(eventInstance))
      return;
    int num1 = (int) eventInstance.stop(stopMode);
    int num2 = (int) eventInstance.release();
  }

  public static bool IsRunning(EventInstance eventInstance)
  {
    if (eventInstance.isValid())
    {
      PLAYBACK_STATE state;
      int playbackState = (int) eventInstance.getPlaybackState(out state);
      if (state != PLAYBACK_STATE.STOPPED)
        return true;
    }
    return false;
  }

  public static void SetCooldown(string eventName)
  {
    if (!SfxSystem.cooldowns.ContainsKey(eventName))
      return;
    SfxSystem.cooldowns[eventName].Max();
  }

  public static bool CheckCooldown(string eventName) => !SfxSystem.cooldowns.ContainsKey(eventName) || (double) SfxSystem.cooldowns[eventName].current <= 0.0;

  public static void SetGlobalParam(string paramName, float value)
  {
    int num = (int) RuntimeManager.StudioSystem.setParameterByName(paramName, value);
  }

  public static EventInstance Loop(string eventName) => SfxSystem.instance.Play(eventName);

  public static EventInstance Loop(EventReference eventRef) => SfxSystem.instance.Play(eventRef);

  public static void EndLoop(EventInstance? inst)
  {
    if (!inst.HasValue)
      return;
    EventInstance valueOrDefault = inst.GetValueOrDefault();
    if (!SfxSystem.IsRunning(valueOrDefault))
      return;
    SfxSystem.Stop(valueOrDefault);
  }

  public static int GetHitPower(Hit hit) => hit.damage + hit.damageBlocked + hit.extraOffensiveness;

  public static void EntityHit(Hit hit)
  {
    if (!hit.Offensive || !hit.doAnimation || !hit.countsAsHit || !(bool) (Object) hit.target)
      return;
    int hitPower = SfxSystem.GetHitPower(hit);
    if (hitPower < 0)
      return;
    switch (hit.damageType)
    {
      case "basic":
        SfxSystem.OneShot("event:/sfx/attack/hit_level", new SfxSystem.Param("power", (float) Mathf.Max(1, hitPower)));
        break;
      case "shroom":
        SfxSystem.OneShot("event:/sfx/status/shroom_damage");
        break;
      case "spikes":
        SfxSystem.OneShot("event:/sfx/status/teeth_damage");
        break;
      case "overload":
        SfxSystem.OneShot("event:/sfx/status/overburn_damage");
        break;
    }
  }

  public static void EntityHover(Entity entity) => SfxSystem.OneShotCheckCooldown("event:/sfx/card/hover", false);

  public static void EntityKilled(Entity entity, DeathType deathType)
  {
    if (deathType == DeathType.Normal || deathType == DeathType.Eaten)
      SfxSystem.OneShot("event:/sfx/card/destroy");
    if (!(bool) (Object) entity || !(bool) (Object) entity.data)
      return;
    CardType cardType = entity.data.cardType;
    if (cardType == null || !cardType.miniboss)
      return;
    SfxSystem.OneShot("event:/sfx/card/destroy_boss");
  }

  public static void EntitySelect(Entity entity) => SfxSystem.OneShot("event:/sfx/card/click");

  public void EntityDrag(Entity entity)
  {
    this.dragging = entity;
    if (!entity.inPlay)
    {
      this.dragTrigger = true;
      this.dragFrom = (Vector2) entity.transform.position;
    }
    else
    {
      if (entity.data.cardType.item)
      {
        this.itemAim = this.Play(entity.IsOffensive() ? "event:/sfx/attack/item_aim_offensive" : "event:/sfx/attack/item_aim_supportive");
        this.draggingItem = entity;
      }
      if (entity.data.playType != Card.PlayType.Place)
        return;
      this.dragTrigger = true;
      this.dragFrom = (Vector2) entity.transform.position;
    }
  }

  public void EntityRelease(Entity entity)
  {
    if ((Object) this.dragging == (Object) entity)
    {
      this.dragging = (Entity) null;
      SfxSystem.SetCooldown("event:/sfx/card/hover");
    }
    if (!((Object) this.draggingItem == (Object) entity) || !SfxSystem.IsRunning(this.itemAim))
      return;
    SfxSystem.SetParam(this.itemAim, "stop", 1f);
    this.draggingItem = (Entity) null;
  }

  public static void EntityPlace(Entity entity, CardContainer[] containers, bool freeMove) => SfxSystem.OneShot("event:/sfx/card/place");

  public static void EntityFlipUp(Entity entity) => SfxSystem.OneShotCheckCooldown("event:/sfx/card/flip_single");

  public static void EntityFlipDown(Entity entity) => SfxSystem.OneShotCheckCooldown("event:/sfx/card/flip_single");

  public static void EntityTrigger(ref Trigger trigger)
  {
    CardType cardType = trigger.entity.data.cardType;
    if (cardType == null || !cardType.item || !((Object) trigger.triggeredBy == (Object) trigger.entity.owner.entity))
      return;
    SfxSystem.OneShot("event:/sfx/attack/item_use");
  }

  public static void EntityMove(Entity entity)
  {
    Character enemy = Battle.instance.enemy;
    if (enemy == null || !((Object) entity.owner == (Object) enemy) || !entity.preContainers.Contains<CardContainer>(enemy.reserveContainer))
      return;
    SfxSystem.OneShot("event:/sfx/card/enemy_showup");
  }

  public static void Focus(Entity entity) => SfxSystem.OneShot("event:/sfx/card/drag");

  public static void EntityEnterPocket(Entity entity, CardPocket pocket) => SfxSystem.OneShotCheckCooldown("event:/sfx/card/enter_pocket");

  public static void EntityEnterBackpack(Entity entity) => SfxSystem.OneShotCheckCooldown("event:/sfx/card/enter_backpack");

  public static void NoomlinShow(Entity entity)
  {
    if (!entity.inPlay)
      return;
    SfxSystem.OneShot("event:/sfx/keyword/noomlin_showup");
  }

  public static void NoomlinUsed(Entity entity)
  {
    if (!entity.inPlay)
      return;
    SfxSystem.OneShot("event:/sfx/keyword/noomlin_use");
  }

  public static void BattlePhaseStart(Battle.Phase phase)
  {
    if (phase == Battle.Phase.Battle)
    {
      SfxSystem.OneShot("event:/sfx/inventory/battle_zoom_in");
    }
    else
    {
      if (Battle.instance.phase != Battle.Phase.Battle)
        return;
      SfxSystem.OneShot("event:/sfx/inventory/battle_zoom_out");
    }
  }

  public static void StatusApplied(StatusEffectApply apply)
  {
    if (!(bool) (Object) apply?.effectData || !apply.target.display.init || !apply.target.startingEffectsApplied || Transition.Running)
      return;
    string type = apply.effectData.type;
    // ISSUE: reference to a compiler-generated method
    switch (\u003CPrivateImplementationDetails\u003E.ComputeStringHash(type))
    {
      case 300022785:
        if (!(type == "shell"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/shell");
        break;
      case 612613805:
        if (!(type == "damage up"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/power");
        break;
      case 782257799:
        if (!(type == "frenzy"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/frenzy");
        break;
      case 979982427:
        if (!(type == "heal"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/heal");
        break;
      case 1224417970:
        if (!(type == "scrap"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/scrap");
        break;
      case 1601927818:
        if (!(type == "demonize"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/demonize");
        break;
      case 1964130039:
        if (!(type == "vim"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/bom");
        break;
      case 2223183858:
        if (!(type == "snow"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/snow");
        break;
      case 2699661231:
        if (!(type == "ink"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/ink");
        break;
      case 2884297373:
        if (!(type == "spice"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/spice");
        break;
      case 2989549779:
        if (!(type == "max counter down"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/sun");
        break;
      case 3121317895:
        if (!(type == "overload"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/overburn");
        break;
      case 3376736801:
        if (!(type == "teeth"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/teeth");
        break;
      case 3587623927:
        if (!(type == "haze"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/haze");
        break;
      case 3735618345:
        if (!(type == "counter down"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/sun");
        break;
      case 3881701069:
        if (!(type == "frost"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/frost");
        break;
      case 3903208501:
        if (!(type == "shroom"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/shroom");
        break;
      case 3943480674:
        if (!(type == "block"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/block");
        break;
      case 4164197074:
        if (!(type == "max health up"))
          break;
        SfxSystem.OneShotCheckCooldown("event:/sfx/status/heal");
        break;
    }
  }

  public void CardDraw(int amount)
  {
    if (SfxSystem.IsRunning(this.drawMulti))
      SfxSystem.Stop(this.drawMulti);
    this.drawMulti = this.Play("event:/sfx/card/draw_multi");
  }

  public void CardDrawEnd()
  {
    if (!SfxSystem.IsRunning(this.drawMulti))
      return;
    SfxSystem.SetParam(this.drawMulti, "draw_stop", 1f);
  }

  public static void StatusIconChanged(StatusIcon icon, Stat previousValue, Stat newValue)
  {
    if (Transition.Running)
      return;
    switch (icon.type)
    {
      case "counter":
        if (newValue.current < previousValue.current)
        {
          SfxSystem.OneShot("event:/sfx/status_icon/counter_decrease");
          break;
        }
        if (newValue.current <= previousValue.current)
          break;
        SfxSystem.OneShot("event:/sfx/status_icon/counter_increase");
        break;
      case "snow":
        if (newValue.current >= previousValue.current)
          break;
        SfxSystem.OneShot("event:/sfx/status_icon/snow_decrease");
        break;
      case "scrap":
        if (newValue.current >= previousValue.current)
          break;
        SfxSystem.OneShot("event:/sfx/status_icon/scrap_decrease");
        break;
      case "shell":
        if (newValue.current >= previousValue.current)
          break;
        SfxSystem.OneShot("event:/sfx/status_icon/shell_decrease");
        break;
    }
  }

  public static void DropGold(int amount, string source, Character owner, Vector3 position)
  {
    if (source == "Flee")
      return;
    SfxSystem.OneShot("event:/sfx/inventory/bling_dropping", new SfxSystem.Param("battle", (float) (SceneManager.ActiveSceneName == "Battle" ? 1 : 0)));
  }

  public static void GoldFlyToBag(int amount, Character owner, Vector3 position) => SfxSystem.OneShot("event:/sfx/inventory/bling_flying");

  public static void CollectGold(int amount) => SfxSystem.OneShot("event:/sfx/inventory/bling_collect");

  public static void DeckpackOpen() => SfxSystem.OneShot("event:/sfx/inventory/backpack_opening");

  public static void DeckpackClose() => SfxSystem.OneShot("event:/sfx/inventory/backpack_closing");

  public void MapPathReveal(float totalTime)
  {
    EventInstance mapPathReveal = this.Play("event:/sfx/map/path_showup");
    UnityEngine.Debug.Log((object) "> Playing path_showup");
    this.StartCoroutine(this.MapPathRevealRoutine(mapPathReveal, totalTime));
  }

  public IEnumerator MapPathRevealRoutine(EventInstance mapPathReveal, float totalTime)
  {
    float time = 0.0f;
    while ((double) time < (double) totalTime && SfxSystem.IsRunning(mapPathReveal))
    {
      time += Time.deltaTime;
      float time1 = time / totalTime;
      int num = (int) mapPathReveal.setPitch(this.pathRevealPitch.Evaluate(time1));
      if ((double) time >= (double) totalTime)
      {
        SfxSystem.Stop(mapPathReveal);
        break;
      }
      yield return (object) new WaitForFixedUpdate();
    }
  }

  public static void MapNodeReveal(MapNode node) => SfxSystem.OneShot("event:/sfx/map/location_showup");

  public static void MapNodeHover(MapNode node) => SfxSystem.OneShot("event:/sfx/map/location_hover");

  public static void MapNodeSelect(MapNode node)
  {
    if ((Object) node != (Object) null)
    {
      SfxSystem.OneShot("event:/sfx/map/location_select");
      if (!node.campaignNode.type.isBattle)
        return;
      SfxSystem.OneShot(node.campaignNode.type.isBoss ? "event:/sfx/map/location_select_battle_boss" : "event:/sfx/map/location_select_battle");
    }
    else
      SfxSystem.OneShot("event:/sfx/ui/deny");
  }

  public void ActionQueued(PlayAction action)
  {
    if (!(action is ActionReveal))
      return;
    ++this.revealActionsInQueue;
  }

  public void ActionPerform(PlayAction action)
  {
    if (!(action is ActionReveal) || this.revealActionsInQueue <= 1 || SfxSystem.IsRunning(this.flipMulti))
      return;
    this.flipMulti = this.Play("event:/sfx/card/flip_multi");
  }

  public void ActionFinished(PlayAction action)
  {
    if (!(action is ActionReveal) || --this.revealActionsInQueue > 0)
      return;
    SfxSystem.SetParam(this.flipMulti, "flip_stop", 1f);
  }

  public void TransitionStart(TransitionType transition)
  {
    if (!(transition is TransitionSnow))
      return;
    this.transitionSnow = this.Play("event:/sfx/transition/snow");
  }

  public void TransitionEnd(TransitionType transition)
  {
    if (!(transition is TransitionSnow) || !SfxSystem.IsRunning(this.transitionSnow))
      return;
    SfxSystem.SetParam(this.transitionSnow, "transition_end", 1f);
  }

  public void GoldCounterStart(GoldDisplay display, float addAmount)
  {
    this.GoldCounterStop();
    if ((double) addAmount > 0.0)
    {
      this.goldDisplay = display;
      this.goldCounter = this.Play("event:/sfx/inventory/bling_counter_up");
    }
    else
    {
      if ((double) addAmount >= 0.0)
        return;
      this.goldDisplay = display;
      this.goldCounter = this.Play("event:/sfx/inventory/bling_counter_down");
    }
  }

  public void GoldCounterStop()
  {
    if (!SfxSystem.IsRunning(this.goldCounter))
      return;
    SfxSystem.Stop(this.goldCounter);
  }

  public void MuncherDrag() => this.muncherFeed = this.Play("event:/sfx/location/muncher/feed");

  public void MuncherDragEnd()
  {
    if (!SfxSystem.IsRunning(this.muncherFeed))
      return;
    SfxSystem.Stop(this.muncherFeed);
  }

  public void MuncherFeed(Entity entity)
  {
    if (!SfxSystem.IsRunning(this.muncherFeed))
      return;
    SfxSystem.Stop(this.muncherFeed);
    SfxSystem.OneShot("event:/sfx/location/muncher/eat");
  }

  public static void BombardShoot(Entity entity) => SfxSystem.OneShot("event:/sfx/specific/boss_shooting");

  public static void BombardRocketFall(BombardRocket rocket) => SfxSystem.OneShot("event:/sfx/specific/boss_rockets_flying");

  public static void BombardRocketExplode(BombardRocket rocket) => SfxSystem.OneShot("event:/sfx/specific/boss_rockets_impact");

  public static void ButtonHover(ButtonType buttonType)
  {
    if (buttonType != ButtonType.Bell)
      SfxSystem.OneShot("event:/sfx/ui/menu_hover");
    else
      SfxSystem.OneShot("event:/sfx/modifiers/bell_hovering");
  }

  public static void ButtonPress(ButtonType buttonType)
  {
    if (buttonType != ButtonType.Sub)
    {
      if (buttonType != ButtonType.Back)
        SfxSystem.OneShot("event:/sfx/ui/menu_click");
      else
        SfxSystem.OneShot("event:/sfx/ui/menu_click_back");
    }
    else
      SfxSystem.OneShot("event:/sfx/ui/menu_click_sub");
  }

  public void ProgressStart(float fill)
  {
    this.townProgressionLoop = SfxSystem.Loop("event:/sfx/town_progress/ramp");
    SfxSystem.SetParam(this.townProgressionLoop, "townramp", fill);
  }

  public void ProgressUpdate(float fill)
  {
    if (!SfxSystem.IsRunning(this.townProgressionLoop))
      return;
    SfxSystem.SetParam(this.townProgressionLoop, "townramp", fill);
  }

  public void ProgressStop() => SfxSystem.Stop(this.townProgressionLoop);

  public static void ProgressDing() => SfxSystem.OneShot("event:/sfx/town_progress/achieved");

  public static void ProgressBlip() => SfxSystem.OneShot("event:/sfx/town_progress/blip");

  public static void TownUnlockPopUp(UnlockData unlockData) => SfxSystem.OneShot("event:/sfx/town_progress/notification");

  public static void UpgradeHover(UpgradeDisplay upgradeDisplay)
  {
    if (upgradeDisplay.data.type != CardUpgradeData.Type.Crown)
      SfxSystem.OneShot("event:/sfx/inventory/charm_hover");
    else
      SfxSystem.OneShot("event:/sfx/inventory/crown_hover");
  }

  public static void UpgradePickup(UpgradeDisplay upgradeDisplay)
  {
    if (upgradeDisplay.data.type != CardUpgradeData.Type.Crown)
      SfxSystem.OneShot("event:/sfx/inventory/charm_pickup");
    else
      SfxSystem.OneShot("event:/sfx/inventory/crown_pickup");
  }

  public static void UpgradeDrop(UpgradeDisplay upgradeDisplay)
  {
    if (upgradeDisplay.data.type != CardUpgradeData.Type.Crown)
      SfxSystem.OneShot("event:/sfx/inventory/charm_return");
    else
      SfxSystem.OneShot("event:/sfx/inventory/crown_return");
  }

  public static void UpgradeAssign(Entity entity, CardUpgradeData upgradeData)
  {
    if (upgradeData.type != CardUpgradeData.Type.Crown)
      return;
    SfxSystem.OneShot("event:/sfx/inventory/crown_assign");
  }

  public static void ShopItemHover(ShopItem shopItem)
  {
    CrownHolderShop component1 = shopItem.GetComponent<CrownHolderShop>();
    if (component1 != null && component1.hasCrown && component1.enabled)
    {
      SfxSystem.OneShotCheckCooldown("event:/sfx/location/shop/crown_hover");
    }
    else
    {
      CharmMachine component2 = shopItem.GetComponent<CharmMachine>();
      if (component2 == null || !component2.enabled)
        return;
      SfxSystem.OneShotCheckCooldown("event:/sfx/location/shop/charm_hover");
    }
  }

  public static void AbilityTargetAdd(CardContainer container) => SfxSystem.OneShot("event:/sfx/specific/boss_targets");

  public static void EntityPing(GameObject obj) => SfxSystem.OneShot("event:/sfx/card/ping");

  public void StopAll(FMOD.Studio.STOP_MODE stopMode = FMOD.Studio.STOP_MODE.IMMEDIATE)
  {
    foreach (EventInstance eventInstance in this.running)
    {
      int num1 = (int) eventInstance.stop(stopMode);
      int num2 = (int) eventInstance.release();
    }
    SfxSystem.cooldowns.Clear();
  }

  public readonly struct Param
  {
    public readonly string name;
    public readonly float value;

    public Param(string name, float value)
    {
      this.name = name;
      this.value = value;
    }
  }

  public class Cooldown
  {
    public string eventName;
    public float current;
    public readonly float max;

    public Cooldown(string eventName, float value)
    {
      this.eventName = eventName;
      this.current = 0.0f;
      this.max = value;
    }

    public void Max() => this.current = this.max;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Shadow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof (Graphic))]
public class Shadow : MonoBehaviourCacheTransform
{
  [SerializeField]
  public Graphic graphic;
  [SerializeField]
  public Vector2 alphaRange;
  public Transform target;
  public CanvasGroup canvasGroup;
  public float preAlpha = -1f;

  public void Assign(Entity entity)
  {
    this.target = entity.offset.transform;
    if (!(entity.display is Card display))
      return;
    CanvasGroup canvasGroup = display.canvasGroup;
    if (canvasGroup == null)
      return;
    this.canvasGroup = canvasGroup;
  }

  public void UpdateAlpha()
  {
    if ((double) Mathf.Abs(this.canvasGroup.alpha - this.preAlpha) > 0.0099999997764825821)
      this.graphic.color = this.graphic.color.WithAlpha(Mathf.Lerp(this.alphaRange.x, this.alphaRange.y, this.canvasGroup.alpha));
    this.preAlpha = this.canvasGroup.alpha;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ShadowManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class ShadowManager : MonoBehaviour
{
  [SerializeField]
  public Shadow shadowPrefab;
  [SerializeField]
  public Vector2 limitX = new Vector2(-999f, 999f);
  [SerializeField]
  public Vector2 limitY = new Vector2(-999f, 999f);
  [SerializeField]
  public Vector2 limitZ = new Vector2(0.0f, 999f);
  [Header("Offset")]
  [SerializeField]
  public Vector3 offset = new Vector3(0.18f, -3.1f, 0.0f);
  [SerializeField]
  public Vector3 offsetBasedOnScale = new Vector3(0.0f, 0.0f, 0.0f);
  [Header("Scale")]
  [SerializeField]
  [Range(0.0f, 1f)]
  public float considerScale = 0.5f;
  [SerializeField]
  public Vector3 baseScale = new Vector3(0.6666667f, 0.6666667f, 0.6666667f);
  public readonly Dictionary<ulong, Shadow> active = new Dictionary<ulong, Shadow>();
  public readonly Queue<Shadow> pool = new Queue<Shadow>();

  public void OnEnable()
  {
    global::Events.OnEntityCreated += new UnityAction<Entity>(this.Assign);
    global::Events.OnEntityDestroyed += new UnityAction<Entity>(this.EntityDestroyed);
  }

  public void OnDisable()
  {
    global::Events.OnEntityCreated -= new UnityAction<Entity>(this.Assign);
    global::Events.OnEntityDestroyed -= new UnityAction<Entity>(this.EntityDestroyed);
  }

  public void Assign(Entity entity)
  {
    if (!entity.inPlay)
      return;
    Shadow shadow = this.Get();
    this.active[entity.data.id] = shadow;
    shadow.Assign(entity);
  }

  public void EntityDestroyed(Entity entity)
  {
    Shadow shadow;
    if (!(bool) (Object) entity.data || !this.active.TryGetValue(entity.data.id, out shadow))
      return;
    this.active.Remove(entity.data.id);
    this.Pool(shadow);
  }

  public void LateUpdate()
  {
    foreach (Shadow shadow in this.active.Values)
    {
      Transform transform = shadow.transform;
      Vector3 b1 = shadow.target.lossyScale - this.baseScale;
      Vector3 b2 = this.baseScale + b1 * this.considerScale;
      Vector3 vector3_1 = Vector3.Scale(this.offset, b2) + Vector3.Scale(this.offsetBasedOnScale, b1);
      transform.localScale = b2;
      Vector3 vector3_2 = shadow.target.position + vector3_1;
      vector3_2.x = Mathf.Clamp(vector3_2.x, this.limitX.x, this.limitX.y);
      vector3_2.y = Mathf.Clamp(vector3_2.y, this.limitY.x, this.limitY.y);
      vector3_2.z = Mathf.Clamp(vector3_2.z, this.limitZ.x, this.limitZ.y);
      transform.position = vector3_2;
      transform.localEulerAngles = new Vector3(0.0f, 0.0f, shadow.target.eulerAngles.z);
      shadow.UpdateAlpha();
    }
  }

  public Shadow Get()
  {
    Shadow shadow = this.pool.Count > 0 ? this.pool.Dequeue() : Object.Instantiate<Shadow>(this.shadowPrefab, this.transform);
    shadow.gameObject.SetActive(true);
    return shadow;
  }

  public void Pool(Shadow shadow)
  {
    shadow.gameObject.SetActive(false);
    this.pool.Enqueue(shadow);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ShopItem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class ShopItem : MonoBehaviour, IRemoveWhenPooled
{
  public int price;
  public float priceFactor;

  public int GetPrice() => Mathf.RoundToInt((float) this.price * this.priceFactor);
}
﻿// Decompiled with JetBrains decompiler
// Type: ShopPrice
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class ShopPrice : MonoBehaviour
{
  public ShopItem target;
  public Transform follow;
  [SerializeField]
  public Vector3 offset;
  [SerializeField]
  public TMP_Text textAsset;
  [SerializeField]
  public string format = "{0}<sprite name=bling>";
  [SerializeField]
  public string discountedFormat = "<color=red><s>{1}</s></color> {0}<sprite name=bling>";
  public float scaleWithTarget = 0.5f;
  public float scaleOffsetWithTarget = 0.5f;

  public void Set(ShopItem target, Vector3 offset)
  {
    this.target = target;
    this.follow = target.transform;
    this.offset = offset;
  }

  public void SetOffset(Vector3 offset) => this.offset = offset;

  public void SetPrice(int price, float priceFactor = 1f)
  {
    this.target.price = price;
    this.target.priceFactor = priceFactor;
    if ((double) priceFactor != 1.0)
      this.SetText(string.Format(this.discountedFormat, (object) this.target.GetPrice(), (object) price));
    else
      this.SetText(string.Format(this.format, (object) price));
  }

  public void SetText(string text) => this.textAsset.text = text;

  public bool Check() => (Object) this.follow != (Object) null;

  public void UpdatePosition()
  {
    if ((Object) this.follow == (Object) null)
    {
      this.gameObject.Destroy();
    }
    else
    {
      Vector3 a = this.offset;
      if ((double) this.scaleOffsetWithTarget > 0.0)
        a = Vector3.Scale(a, Vector3.Lerp(Vector3.one, this.follow.localScale, this.scaleOffsetWithTarget));
      this.transform.position = this.follow.position + a;
      if ((double) this.scaleWithTarget <= 0.0)
        return;
      this.transform.localScale = Vector3.Lerp(Vector3.one, this.follow.localScale, this.scaleWithTarget);
    }
  }

  public enum Position
  {
    Top,
    Bottom,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ShopPriceManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class ShopPriceManager : MonoBehaviour
{
  [SerializeField]
  public ShopPrice pricePrefab;
  [SerializeField]
  public List<ShopPrice> targets = new List<ShopPrice>();
  [SerializeField]
  public ShopPriceManager.PositionProfile[] positionProfiles;

  public void LateUpdate()
  {
    for (int index = this.targets.Count - 1; index >= 0; --index)
    {
      ShopPrice target = this.targets[index];
      if (!(bool) (UnityEngine.Object) target)
        this.targets.RemoveAt(index);
      else
        target.UpdatePosition();
    }
  }

  public ShopPrice Add(ShopItem target, ShopPrice.Position position)
  {
    ShopPriceManager.PositionProfile positionProfile = ((IEnumerable<ShopPriceManager.PositionProfile>) this.positionProfiles).FirstOrDefault<ShopPriceManager.PositionProfile>((Func<ShopPriceManager.PositionProfile, bool>) (a => a.type == position));
    ShopPrice shopPrice = UnityEngine.Object.Instantiate<ShopPrice>(this.pricePrefab, this.transform, false);
    shopPrice.Set(target, positionProfile.offset);
    shopPrice.gameObject.SetActive(true);
    this.targets.Add(shopPrice);
    return shopPrice;
  }

  public ShopPrice Get(ShopItem target) => this.targets.Find((Predicate<ShopPrice>) (a => (UnityEngine.Object) a.target == (UnityEngine.Object) target));

  public void Remove(ShopItem target)
  {
    ShopPrice shopPrice = this.Get(target);
    shopPrice.gameObject.Destroy();
    this.targets.Remove(shopPrice);
  }

  public void Clear()
  {
    foreach (Component target in this.targets)
      target.Destroy();
    this.targets.Clear();
  }

  [Serializable]
  public struct PositionProfile
  {
    public ShopPrice.Position type;
    public Vector3 offset;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ShopRoutine
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using FMODUnity;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.Localization;

public class ShopRoutine : EventRoutine
{
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardSelector cardSelector;
  [SerializeField]
  public float cardContainerRandomAngle = 2f;
  [SerializeField]
  public ShopPriceManager priceManager;
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public LocalizedString enterKey;
  [SerializeField]
  public string brokenVaseCardName = "BrokenVase";
  [Header("Card Containers")]
  [SerializeField]
  public ShopRoutine.Container[] containers;
  [Header("Charms")]
  [SerializeField]
  public CharmMachine charmMachine;
  [SerializeField]
  public OpenCharmBlockSequence openSequence;
  [SerializeField]
  public Transform charmBlock;
  [Header("Crown")]
  [SerializeField]
  public CrownHolderShop crownHolder;
  [SerializeField]
  public GainCrownSequence gainCrownSequence;
  [Header("Speech Bubs")]
  [SerializeField]
  public Talker talker;
  [SerializeField]
  public Vector2 sayDelay = new Vector2(0.8f, 1f);
  [SerializeField]
  public float speechBubDelay = 1f;
  [Header("Music")]
  [SerializeField]
  public EventReference music;
  [SerializeField]
  public SfxLoop ovenCrackleLoop;
  public bool open;
  public bool promptOpen;
  public bool promptClose;
  public bool promptEnd;
  public bool promptBuyCharm;
  public bool promptBuyCrown;
  public bool endWhenClosed = true;
  public List<Entity> entities;
  public ShopItem currentHover;
  public float speechBubTimer;
  public int secretCount;
  public ShopItem secretClick;
  public int secretClickCount;

  public void OnEnable()
  {
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
  }

  public void EntityHover(Entity entity)
  {
    ShopItem component = entity.GetComponent<ShopItem>();
    if (component == null)
      return;
    this.Hover(component);
  }

  public void EntityUnHover(Entity entity)
  {
    ShopItem component = entity.GetComponent<ShopItem>();
    if (component == null)
      return;
    this.UnHover(component);
  }

  public void Update()
  {
    if ((double) this.speechBubTimer <= 0.0)
      return;
    this.speechBubTimer -= Time.deltaTime;
  }

  public override IEnumerator Run()
  {
    ShopRoutine shopRoutine = this;
    shopRoutine.secretCount = UnityEngine.Random.Range(7, 10);
    CinemaBarSystem.Top.SetPrompt(shopRoutine.enterKey.GetLocalizedString(), "Select");
    MusicSystem.StopMusic();
    MusicSystem.StartMusic(shopRoutine.music);
    MusicSystem.SetParam("shop_enter", 0.0f);
    shopRoutine.cardController.owner = shopRoutine.player;
    shopRoutine.cardSelector.character = shopRoutine.player;
    while (!shopRoutine.promptEnd)
    {
      if (shopRoutine.promptBuyCharm)
        yield return (object) shopRoutine.BuyCharmRoutine();
      else if (shopRoutine.promptBuyCrown)
        yield return (object) shopRoutine.BuyCrownRoutine();
      else if (!shopRoutine.open && shopRoutine.promptOpen)
      {
        yield return (object) shopRoutine.OpenRoutine();
        shopRoutine.ovenCrackleLoop.Play();
      }
      else if (shopRoutine.open && shopRoutine.promptClose)
      {
        yield return (object) shopRoutine.CloseRoutine();
        if (shopRoutine.endWhenClosed)
          shopRoutine.End();
      }
      else
        yield return (object) null;
    }
    shopRoutine.promptEnd = false;
    shopRoutine.ovenCrackleLoop.Stop();
    shopRoutine.cardController.enabled = false;
    shopRoutine.cardSelector.enabled = false;
    if (shopRoutine.player.entity.display is CharacterDisplay display && (bool) (UnityEngine.Object) display.goldDisplay)
      display.goldDisplay.HideChange();
  }

  public void Bub(string speechType, params object[] inserts)
  {
    if ((double) this.speechBubTimer > 0.0)
      return;
    this.talker.Say(speechType, 0.0f, inserts);
    this.speechBubTimer = this.speechBubDelay;
  }

  public void Open(BaseEventData eventData)
  {
    if (eventData is PointerEventData pointerEventData && pointerEventData.button != PointerEventData.InputButton.Left || this.open || this.promptOpen)
      return;
    this.promptOpen = true;
  }

  public void Close()
  {
    if (!this.open || this.promptClose)
      return;
    this.promptClose = true;
  }

  public IEnumerator OpenRoutine()
  {
    ShopRoutine shopRoutine = this;
    SfxSystem.OneShot("event:/sfx/location/shop/visit");
    shopRoutine.animator.SetBool("Zoom", true);
    shopRoutine.promptOpen = false;
    shopRoutine.open = true;
    int valueOrDefault = (int) shopRoutine.data.GetValueOrDefault<string, object>("openCount", (object) 0);
    if (valueOrDefault <= 0)
    {
      float delay = shopRoutine.sayDelay.Random() - 0.5f;
      if (shopRoutine.data.Get<ShopRoutine.Data>("shopData").items.Count<ShopRoutine.Item>(new Func<ShopRoutine.Item, bool>(shopRoutine.\u003COpenRoutine\u003Eb__40_0)) > 0)
      {
        shopRoutine.talker.Say("broken vase", delay);
        shopRoutine.talker.Say("broken vase price", delay + 1f);
      }
      else
      {
        shopRoutine.talker.Say("greet1", delay);
        shopRoutine.talker.Say("greet2", delay + 1f);
      }
      shopRoutine.speechBubTimer = shopRoutine.speechBubDelay;
      foreach (ShopRoutine.Container container in shopRoutine.containers)
      {
        foreach (Entity entity in container.container)
          global::Events.InvokeEntityOffered(entity);
      }
    }
    shopRoutine.data["openCount"] = (object) (valueOrDefault + 1);
    yield return (object) new WaitForSeconds(0.5f);
    yield return (object) ShopRoutine.AdjustMusicToInside(0.5f);
  }

  public IEnumerator CloseRoutine()
  {
    this.animator.SetBool("Zoom", false);
    this.promptClose = false;
    this.open = false;
    yield return (object) null;
  }

  public static IEnumerator AdjustMusicToInside(float totalTime)
  {
    float v = 0.0f;
    float add = 1f / totalTime;
    while ((double) v < 1.0)
    {
      v += Time.deltaTime * add;
      MusicSystem.SetParam("shop_enter", v);
      AmbienceSystem.SetParam("shop_enter", v);
      yield return (object) null;
    }
  }

  public void End() => this.promptEnd = true;

  public void TryBuy(Entity entity)
  {
    ShopItem component = entity.GetComponent<ShopItem>();
    if (component == null)
      return;
    int price = component.GetPrice();
    int goldDiff = this.player.data.inventory.gold.Value - price;
    if (goldDiff >= 0)
    {
      this.Bub("thanks");
      SfxSystem.OneShot("event:/sfx/location/shop/buying");
      this.priceManager.Remove(component);
      this.player.SpendGold(price);
      this.cardSelector.TakeCard(entity);
      this.data.Get<ShopRoutine.Data>("shopData").items.Find((Predicate<ShopRoutine.Item>) (a => a.cardDataName == entity.data.name)).purchased = true;
      global::Events.InvokeShopItemPurchase(component);
    }
    else if (this.SecretCheck(goldDiff, component))
      this.TryBuy(entity);
    else
      this.Bub("not enough gold");
  }

  public void TryBuyCharm(BaseEventData eventData)
  {
    if (eventData is PointerEventData pointerEventData && pointerEventData.button != PointerEventData.InputButton.Left)
      return;
    ShopRoutine.Data data = this.data.Get<ShopRoutine.Data>("shopData");
    if (data.charms.Count <= 0)
      return;
    int goldDiff = this.player.data.inventory.gold.Value - data.charmPrice;
    if (goldDiff >= 0)
    {
      if (!this.charmMachine.CanRun())
        return;
      this.Bub("thanks");
      this.promptBuyCharm = true;
    }
    else if (this.SecretCheck(goldDiff, this.charmMachine.GetComponent<ShopItem>()))
      this.TryBuyCharm(eventData);
    else
      this.Bub("not enough gold");
  }

  public void TryBuyCrown(BaseEventData eventData)
  {
    if (eventData is PointerEventData pointerEventData && pointerEventData.button != PointerEventData.InputButton.Left)
      return;
    ShopRoutine.Data shopData = this.data.Get<ShopRoutine.Data>("shopData");
    if (!shopData.hasCrown)
      return;
    int goldDiff = this.player.data.inventory.gold.Value - ShopRoutine.GetCrownPrice(shopData);
    if (goldDiff >= 0)
    {
      if (!this.crownHolder.CanTake())
        return;
      this.Bub("thanks");
      this.promptBuyCrown = true;
    }
    else if (this.SecretCheck(goldDiff, this.crownHolder.GetComponent<ShopItem>()))
      this.TryBuyCrown(eventData);
    else
      this.Bub("not enough gold");
  }

  public bool SecretCheck(int goldDiff, ShopItem item)
  {
    if (goldDiff == -1)
    {
      if ((UnityEngine.Object) this.secretClick != (UnityEngine.Object) item)
      {
        this.secretClick = item;
        this.secretClickCount = 1;
      }
      else if (++this.secretClickCount >= this.secretCount)
      {
        this.speechBubTimer = 0.0f;
        this.Bub("secret", (object) (item.GetPrice() - 1));
        ++this.player.data.inventory.gold.Value;
        this.secretClick = (ShopItem) null;
        return true;
      }
    }
    return false;
  }

  public IEnumerator BuyCharmRoutine()
  {
    ShopRoutine shopRoutine = this;
    shopRoutine.promptBuyCharm = false;
    SfxSystem.OneShot("event:/sfx/location/shop/buying");
    ShopRoutine.Data shopData = shopRoutine.data.Get<ShopRoutine.Data>("shopData");
    shopRoutine.cardController.enabled = false;
    shopRoutine.crownHolder.enabled = false;
    shopRoutine.charmMachine.enabled = false;
    shopRoutine.player.SpendGold(shopData.charmPrice);
    string c = shopData.charms[0];
    ShopItem item = shopRoutine.charmMachine.GetComponent<ShopItem>();
    shopRoutine.priceManager.Remove(item);
    yield return (object) shopRoutine.charmMachine.Run();
    shopData.charms.RemoveAt(0);
    shopData.charmPrice += shopData.charmPriceAdd;
    CardUpgradeData charmData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", c).Clone();
    shopRoutine.openSequence.SetCharm(charmData, shopRoutine.charmBlock);
    shopRoutine.openSequence.SetCharacter(shopRoutine.player);
    yield return (object) shopRoutine.openSequence.Run();
    if (shopData.charms.Count > 0)
    {
      shopRoutine.charmMachine.enabled = true;
      shopRoutine.CreateCharmPrice();
    }
    shopRoutine.cardController.enabled = true;
    shopRoutine.crownHolder.enabled = true;
    global::Events.InvokeShopItemPurchase(item);
  }

  public IEnumerator BuyCrownRoutine()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    ShopRoutine shopRoutine = this;
    ShopItem item;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      global::Events.InvokeShopItemPurchase(item);
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    shopRoutine.promptBuyCrown = false;
    ShopRoutine.Data shopData = shopRoutine.data.Get<ShopRoutine.Data>("shopData");
    SfxSystem.OneShot("event:/sfx/location/shop/buying");
    shopRoutine.player.SpendGold(ShopRoutine.GetCrownPrice(shopData));
    shopRoutine.crownHolder.TakeCrown();
    shopData.hasCrown = false;
    item = shopRoutine.crownHolder.GetComponent<ShopItem>();
    shopRoutine.priceManager.Remove(item);
    shopRoutine.gainCrownSequence.SetData(shopRoutine.crownHolder.GetCrownData().Clone());
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) shopRoutine.gainCrownSequence.Run();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public void Hover(ShopItem item)
  {
    if ((bool) (UnityEngine.Object) this.currentHover)
      this.UnHover(this.currentHover);
    this.currentHover = item;
    if (this.player.entity.display is CharacterDisplay display && (bool) (UnityEngine.Object) display.goldDisplay && (bool) (UnityEngine.Object) this.priceManager.Get(item))
    {
      int price = item.GetPrice();
      if (price <= this.player.data.inventory.gold)
        display.goldDisplay.ShowChange(-price);
    }
    global::Events.InvokeShopItemHover(item);
  }

  public void UnHover(ShopItem item)
  {
    if (!((UnityEngine.Object) this.currentHover == (UnityEngine.Object) item))
      return;
    this.currentHover = (ShopItem) null;
    if (this.player.entity.display is CharacterDisplay display && (bool) (UnityEngine.Object) display.goldDisplay)
      display.goldDisplay.HideChange();
    global::Events.InvokeShopItemUnHover(item);
  }

  public override IEnumerator Populate()
  {
    ShopRoutine shopRoutine = this;
    yield return (object) shopRoutine.UnPopulate();
    ShopRoutine.Data shopData = shopRoutine.data.Get<ShopRoutine.Data>("shopData");
    shopRoutine.entities = new List<Entity>();
    ShopRoutine.Container[] containerArray = shopRoutine.containers;
    for (int index = 0; index < containerArray.Length; ++index)
    {
      ShopRoutine.Container c = containerArray[index];
      List<ShopRoutine.Item> all = shopData.items.FindAll((Predicate<ShopRoutine.Item>) (a => a.category == c.category));
      c.container.SetSize(all.Count, c.cardScale);
      CardContainer container = c.container;
      container.owner = shopRoutine.player;
      container.transform.localEulerAngles = container.transform.localEulerAngles.WithZ(PettyRandom.Range(-shopRoutine.cardContainerRandomAngle, shopRoutine.cardContainerRandomAngle));
      foreach (ShopRoutine.Item item in all)
      {
        CardData cardDataClone = AddressableLoader.GetCardDataClone(item.cardDataName);
        int index1 = shopData.items.IndexOf(item);
        if (shopData.upgrades.Count > index1)
        {
          string[] upgrade = shopData.upgrades[index1];
          if (upgrade != null)
          {
            foreach (string assetName in upgrade)
              AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", assetName).Clone().Assign(cardDataClone);
          }
        }
        Card card = CardManager.Get(cardDataClone, shopRoutine.cardController, shopRoutine.player, false, true);
        yield return (object) card.UpdateData(false);
        container.Add(card.entity);
        shopRoutine.entities.Add(card.entity);
        ShopItem target = card.entity.gameObject.AddComponent<ShopItem>();
        shopRoutine.priceManager.Add(target, c.pricePosition).SetPrice(item.price, item.priceFactor);
        card = (Card) null;
      }
      foreach (Entity child in container)
      {
        Transform transform = child.transform;
        transform.localPosition = container.GetChildPosition(child);
        transform.localScale = container.GetChildScale(child);
        transform.localEulerAngles = container.GetChildRotation(child);
      }
      container = (CardContainer) null;
    }
    containerArray = (ShopRoutine.Container[]) null;
    foreach (ShopRoutine.Item obj in shopData.items)
    {
      ShopRoutine.Item item = obj;
      if (item.purchased)
      {
        Entity entity = shopRoutine.entities.Find((Predicate<Entity>) (a => a.data.name == item.cardDataName));
        if ((bool) (UnityEngine.Object) entity)
        {
          shopRoutine.priceManager.Remove(entity.GetComponent<ShopItem>());
          entity.RemoveFromContainers();
          CardManager.ReturnToPool(entity);
        }
      }
    }
    if ((bool) (UnityEngine.Object) shopRoutine.charmMachine && shopData.charms.Count <= 0)
      shopRoutine.charmMachine.enabled = false;
    else
      shopRoutine.CreateCharmPrice();
    if ((bool) (UnityEngine.Object) shopRoutine.crownHolder && !shopData.hasCrown)
    {
      shopRoutine.crownHolder.TakeCrown();
    }
    else
    {
      CardUpgradeData crownData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", shopData.crownType.IsNullOrWhitespace() ? "Crown" : shopData.crownType);
      if ((bool) (UnityEngine.Object) crownData)
        shopRoutine.crownHolder.SetCrownData(crownData);
      shopRoutine.CreateCrownPrice();
    }
  }

  public void CreateCharmPrice()
  {
    ShopRoutine.Data data = this.data.Get<ShopRoutine.Data>("shopData");
    if (!((UnityEngine.Object) this.charmMachine != (UnityEngine.Object) null) || data.charms.Count <= 0)
      return;
    ShopPrice shopPrice = this.priceManager.Add(this.charmMachine.GetComponent<ShopItem>(), ShopPrice.Position.Bottom);
    shopPrice.SetPrice(data.charmPrice);
    shopPrice.SetOffset(new Vector3(0.0f, -0.33f, 0.0f));
    shopPrice.scaleWithTarget = 0.0f;
    shopPrice.scaleOffsetWithTarget = 0.0f;
  }

  public void CreateCrownPrice()
  {
    ShopRoutine.Data shopData = this.data.Get<ShopRoutine.Data>("shopData");
    if (!((UnityEngine.Object) this.crownHolder != (UnityEngine.Object) null) || !shopData.hasCrown)
      return;
    ShopPrice shopPrice = this.priceManager.Add(this.crownHolder.GetComponent<ShopItem>(), ShopPrice.Position.Bottom);
    shopPrice.SetPrice(ShopRoutine.GetCrownPrice(shopData));
    shopPrice.SetOffset(new Vector3(0.0f, -0.3f, 0.0f));
    shopPrice.scaleWithTarget = 0.0f;
    shopPrice.scaleOffsetWithTarget = 0.0f;
  }

  public static int GetCrownPrice(ShopRoutine.Data shopData) => shopData.crownPrice + shopData.crownPriceAdd * StatsSystem.Get().Get("shopItemsBought", "crown", 0);

  public IEnumerator UnPopulate()
  {
    List<Entity> entityList = new List<Entity>();
    foreach (ShopRoutine.Container container in this.containers)
    {
      foreach (Entity entity in container.container)
        entityList.Add(entity);
      container.container.Clear();
    }
    foreach (Entity entity in entityList)
      CardManager.ReturnToPool(entity);
    this.priceManager.Clear();
    yield return (object) null;
  }

  [CompilerGenerated]
  public bool \u003COpenRoutine\u003Eb__40_0(ShopRoutine.Item a) => a.cardDataName == this.brokenVaseCardName;

  [Serializable]
  public class Data : ICloneable
  {
    public List<ShopRoutine.Item> items = new List<ShopRoutine.Item>();
    public List<string[]> upgrades = new List<string[]>();
    public List<string> charms = new List<string>();
    public int charmPrice = 50;
    public int charmPriceAdd = 20;
    public bool hasCrown = true;
    public string crownType;
    public int crownPrice = 120;
    public int crownPriceAdd = 30;
    public int openCount;

    public object Clone() => (object) new ShopRoutine.Data()
    {
      items = this.items.Select<ShopRoutine.Item, ShopRoutine.Item>((Func<ShopRoutine.Item, ShopRoutine.Item>) (a => (ShopRoutine.Item) a.Clone())).ToList<ShopRoutine.Item>(),
      upgrades = this.upgrades.Clone<string[]>(),
      charms = this.charms.Clone<string>(),
      charmPrice = this.charmPrice,
      charmPriceAdd = this.charmPriceAdd,
      hasCrown = this.hasCrown,
      crownType = this.crownType,
      crownPrice = this.crownPrice,
      crownPriceAdd = this.crownPriceAdd,
      openCount = this.openCount
    };
  }

  [Serializable]
  public class Item : ICloneable
  {
    public string category;
    public string cardDataName;
    public int price;
    public float priceFactor = 1f;
    public bool purchased;

    public Item()
    {
    }

    public Item(string category, CardData cardData, int priceOffset, float priceFactor = 1f)
    {
      this.category = category;
      this.cardDataName = cardData.name;
      this.price = Mathf.RoundToInt((float) cardData.value * priceFactor) + priceOffset;
    }

    public object Clone() => (object) new ShopRoutine.Item()
    {
      category = this.category,
      cardDataName = this.cardDataName,
      price = this.price,
      priceFactor = this.priceFactor,
      purchased = this.purchased
    };
  }

  [Serializable]
  public struct Container
  {
    public string category;
    public CardContainer container;
    public float cardScale;
    public ShopPrice.Position pricePosition;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ShoveSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

public class ShoveSystem : GameSystem
{
  [CompilerGenerated]
  public static bool \u003CActive\u003Ek__BackingField;
  [CompilerGenerated]
  public static CardSlot \u003CSlot\u003Ek__BackingField;
  [CompilerGenerated]
  public static bool \u003CFix\u003Ek__BackingField;
  public static readonly List<Entity> shovedFrom = new List<Entity>();
  public static Entity dragging;
  public static readonly int[] shoveDirs = new int[2]
  {
    -1,
    1
  };

  public static bool Active
  {
    get => ShoveSystem.\u003CActive\u003Ek__BackingField;
    set => ShoveSystem.\u003CActive\u003Ek__BackingField = value;
  }

  public static CardSlot Slot
  {
    get => ShoveSystem.\u003CSlot\u003Ek__BackingField;
    set => ShoveSystem.\u003CSlot\u003Ek__BackingField = value;
  }

  public static Vector3 Position => ShoveSystem.Slot.transform.position - Vector3.Scale(ShoveSystem.dragging.offset.localPosition, ShoveSystem.dragging.transform.localScale);

  public static bool Fix
  {
    get => ShoveSystem.\u003CFix\u003Ek__BackingField;
    set => ShoveSystem.\u003CFix\u003Ek__BackingField = value;
  }

  public void OnEnable()
  {
    global::Events.OnEntityDrag += new UnityAction<Entity>(ShoveSystem.DragStart);
    global::Events.OnEntityRelease += new UnityAction<Entity>(ShoveSystem.DragEnd);
    global::Events.OnSlotHover += new UnityAction<CardSlot>(ShoveSystem.SlotHover);
    global::Events.OnSlotUnHover += new UnityAction<CardSlot>(ShoveSystem.SlotUnHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityDrag -= new UnityAction<Entity>(ShoveSystem.DragStart);
    global::Events.OnEntityRelease -= new UnityAction<Entity>(ShoveSystem.DragEnd);
    global::Events.OnSlotHover -= new UnityAction<CardSlot>(ShoveSystem.SlotHover);
    global::Events.OnSlotUnHover -= new UnityAction<CardSlot>(ShoveSystem.SlotUnHover);
  }

  public static void DragStart(Entity entity) => ShoveSystem.dragging = entity;

  public static void DragEnd(Entity entity)
  {
    ShoveSystem.dragging = (Entity) null;
    if (!ShoveSystem.Active || ShoveSystem.Fix)
      return;
    ShoveSystem.ClearShove();
  }

  public static void SlotHover(CardSlot slot)
  {
    if (!((UnityEngine.Object) ShoveSystem.Slot != (UnityEngine.Object) null) || !((UnityEngine.Object) ShoveSystem.Slot != (UnityEngine.Object) slot))
      return;
    ShoveSystem.ClearShove();
  }

  public static void SlotUnHover(CardSlot slot)
  {
    if (!ShoveSystem.Active || !((UnityEngine.Object) ShoveSystem.Slot != (UnityEngine.Object) null) || !((UnityEngine.Object) ShoveSystem.Slot == (UnityEngine.Object) slot) || ShoveSystem.Fix)
      return;
    ShoveSystem.ClearShove();
  }

  public static bool CanShove(
    Entity shovee,
    Entity shover,
    out Dictionary<Entity, List<CardSlot>> shoveData)
  {
    shoveData = new Dictionary<Entity, List<CardSlot>>();
    if (!global::Events.CheckEntityShove(shovee))
      return false;
    List<int> list = ShoveSystem.shoveDirs.ToList<int>();
    if (shover.positionPriority > shovee.positionPriority)
      list.Remove(-1);
    if (shovee.positionPriority > shover.positionPriority)
      list.Remove(1);
    bool flag = false;
    foreach (int dir in list)
    {
      CardSlot[] slots = ShoveSystem.FindSlots(shovee, dir);
      if (slots != null && slots.Length != 0)
      {
        flag = ShoveSystem.CanShoveTo(shovee, shover, dir, slots, out shoveData);
        if (flag)
          break;
      }
    }
    if (!flag && ((UnityEngine.Object) shover == (UnityEngine.Object) null || (UnityEngine.Object) shover.data == (UnityEngine.Object) null || shover.data.canShoveToOtherRow))
      flag = ShoveSystem.CanShoveToOtherRow(shovee, shover, out shoveData);
    return flag;
  }

  public static CardSlot[] FindSlots(Entity shovee, int dir)
  {
    bool flag = false;
    List<CardSlot> cardSlotList = new List<CardSlot>();
    foreach (CardContainer container in shovee.containers)
    {
      if (!(container is CardSlotLane cardSlotLane))
      {
        flag = true;
        break;
      }
      int index = cardSlotLane.IndexOf(shovee) + dir;
      if (index < 0 || index >= cardSlotLane.max)
      {
        flag = true;
        break;
      }
      cardSlotList.Add(cardSlotLane.slots[index]);
    }
    return !flag ? cardSlotList.ToArray() : (CardSlot[]) null;
  }

  public static bool CanShoveTo(
    Entity shovee,
    Entity shover,
    int dir,
    CardSlot[] slots,
    out Dictionary<Entity, List<CardSlot>> shoveData)
  {
    shoveData = new Dictionary<Entity, List<CardSlot>>();
    int num = 1;
    Queue<KeyValuePair<Entity, CardSlot[]>> source = new Queue<KeyValuePair<Entity, CardSlot[]>>();
    source.Enqueue(new KeyValuePair<Entity, CardSlot[]>(shovee, slots));
    List<Entity> entityList = new List<Entity>();
    bool flag = false;
    while (source.Count > 0)
    {
      KeyValuePair<Entity, CardSlot[]> keyValuePair = source.Dequeue();
      Entity key = keyValuePair.Key;
      entityList.Add(key);
      CardSlot[] cardSlotArray = keyValuePair.Value;
      if (cardSlotArray != null && cardSlotArray.Length != 0)
      {
        List<CardSlot> cardSlotList = new List<CardSlot>();
        foreach (CardSlot cardSlot in cardSlotArray)
        {
          if (shoveData.ContainsKey(key))
            shoveData[key].Add(cardSlot);
          else
            shoveData[key] = new List<CardSlot>()
            {
              cardSlot
            };
          Entity top = cardSlot.GetTop();
          if ((UnityEngine.Object) top != (UnityEngine.Object) null && (UnityEngine.Object) top != (UnityEngine.Object) shover)
            cardSlotList.Add(cardSlot);
        }
        --num;
        foreach (CardSlot cardSlot in cardSlotList)
        {
          Entity blockingEntity = cardSlot.GetTop();
          if (!entityList.Contains(blockingEntity) && !source.Any<KeyValuePair<Entity, CardSlot[]>>((Func<KeyValuePair<Entity, CardSlot[]>, bool>) (p => (UnityEngine.Object) p.Key == (UnityEngine.Object) blockingEntity)))
          {
            CardSlot[] slots1 = ShoveSystem.FindSlots(blockingEntity, dir);
            source.Enqueue(new KeyValuePair<Entity, CardSlot[]>(blockingEntity, slots1));
            ++num;
          }
        }
      }
      else
        break;
    }
    if (num <= 0)
      flag = true;
    return flag;
  }

  public static bool CanShoveToOtherRow(
    Entity shovee,
    Entity shover,
    out Dictionary<Entity, List<CardSlot>> shoveData)
  {
    shoveData = new Dictionary<Entity, List<CardSlot>>();
    if (shovee.containers.Length != 1 || !(shovee.containers[0] is CardSlotLane container))
      return false;
    int a = container.IndexOf(shovee);
    bool otherRow = false;
    foreach (CardContainer cardContainer in container.shoveTo)
    {
      if (cardContainer is CardSlotLane cardSlotLane)
      {
        int num = cardSlotLane.max - cardSlotLane.Count;
        if (cardSlotLane.Contains(shover))
          ++num;
        if (num > 0)
        {
          int index = Mathf.Min(a, cardSlotLane.max - 1);
          CardSlot slot = cardSlotLane.slots[index];
          foreach (int shoveDir in ShoveSystem.shoveDirs)
          {
            otherRow = ShoveSystem.CanShoveTo(shovee, shover, shoveDir, new CardSlot[1]
            {
              slot
            }, out shoveData);
            if (otherRow)
              break;
          }
          if (otherRow)
            break;
        }
      }
    }
    return otherRow;
  }

  public static void ShowShove(CardSlot fromContainer, Dictionary<Entity, List<CardSlot>> shoveData)
  {
    ShoveSystem.Active = true;
    ShoveSystem.Slot = fromContainer;
    float time = 0.3f;
    LeanTweenType easeType = LeanTweenType.easeOutQuart;
    foreach (KeyValuePair<Entity, List<CardSlot>> keyValuePair in shoveData)
    {
      Entity key = keyValuePair.Key;
      List<CardSlot> cardSlotList = keyValuePair.Value;
      GameObject gameObject = key.gameObject;
      LeanTween.cancel(gameObject);
      Vector3 zero = Vector3.zero;
      foreach (CardSlot cardSlot in cardSlotList)
        zero += cardSlot.transform.position;
      Vector3 to = zero / (float) cardSlotList.Count;
      LeanTween.move(gameObject, to, time).setEase(easeType);
      ShoveSystem.shovedFrom.Add(key);
    }
  }

  public static IEnumerator DoShove(
    Dictionary<Entity, List<CardSlot>> shoveData,
    bool updatePositions = false)
  {
    foreach (KeyValuePair<Entity, List<CardSlot>> keyValuePair in shoveData)
      keyValuePair.Key.RemoveFromContainers();
    HashSet<CardContainer> cardContainerSet = new HashSet<CardContainer>();
    foreach (KeyValuePair<Entity, List<CardSlot>> keyValuePair in shoveData)
    {
      Entity key = keyValuePair.Key;
      foreach (CardSlot cardSlot in keyValuePair.Value)
      {
        cardSlot.Add(key);
        cardContainerSet.Add((CardContainer) cardSlot);
      }
    }
    if (updatePositions)
    {
      foreach (CardContainer cardContainer in cardContainerSet)
        cardContainer.TweenChildPositions();
    }
    Routine.Clump clump = new Routine.Clump();
    foreach (KeyValuePair<Entity, List<CardSlot>> keyValuePair in shoveData)
    {
      global::Events.InvokeEntityMove(keyValuePair.Key);
      clump.Add(StatusEffectSystem.CardMoveEvent(keyValuePair.Key));
    }
    yield return (object) clump.WaitForEnd();
    ShoveSystem.Deactivate();
  }

  public static void ClearShove()
  {
    foreach (Entity child in ShoveSystem.shovedFrom)
    {
      foreach (CardContainer actualContainer in child.actualContainers)
        actualContainer.TweenChildPosition(child);
    }
    ShoveSystem.Deactivate();
  }

  public static void Deactivate()
  {
    ShoveSystem.shovedFrom.Clear();
    ShoveSystem.Slot = (CardSlot) null;
    ShoveSystem.Fix = false;
    ShoveSystem.Active = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SliderSfx
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class SliderSfx : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
{
  [SerializeField]
  public Slider slider;
  [SerializeField]
  public EventReference sfxEvent;
  public bool drag;

  public void Fire() => SfxSystem.OneShot(this.sfxEvent);

  public void OnPointerDown(PointerEventData eventData) => this.drag = true;

  public void OnPointerUp(PointerEventData eventData)
  {
    if (this.drag)
      this.Fire();
    this.drag = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SliderUINavigationScript
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class SliderUINavigationScript : MonoBehaviour
{
  public float valueMultiplier = 0.1f;
  public Slider slider;
  [SerializeField]
  public SliderSfx sfx;

  public void OnChangeSliderValue(float inValueChange)
  {
    inValueChange *= this.valueMultiplier;
    this.slider.value += inValueChange;
    if (!(bool) (Object) this.sfx)
      return;
    this.sfx.Fire();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SmoothScrollRect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class SmoothScrollRect : ScrollRect
{
  [SerializeField]
  public float speed = 1f;
  public const float smoothScrollTime = 0.1f;
  public const LeanTweenType smoothScrollEase = LeanTweenType.easeOutQuart;
  public LTDescr tween;

  public override void OnScroll(PointerEventData data)
  {
    if (!this.isActiveAndEnabled)
      return;
    Vector2 normalizedPosition = this.normalizedPosition;
    if (this.tween != null)
      LeanTween.cancel(this.tween.uniqueId);
    base.OnScroll(data);
    Vector2 to = this.normalizedPosition.Clamp(Vector2.zero, Vector2.one);
    this.normalizedPosition = normalizedPosition;
    this.tween = LeanTween.value(this.gameObject, normalizedPosition, to, this.scrollSensitivity * 0.1f).setEase(LeanTweenType.easeOutQuart).setOnUpdateVector2((Action<Vector2>) (a => this.normalizedPosition = a));
    this.tween.setIgnoreTimeScale(true);
  }

  public void ScrollTo(Vector2 targetPosition)
  {
    Vector2 normalizedPosition = this.normalizedPosition;
    if (this.tween != null)
      LeanTween.cancel(this.tween.uniqueId);
    this.content.anchoredPosition = targetPosition;
    Vector2 to = this.normalizedPosition.Clamp(Vector2.zero, Vector2.one);
    this.normalizedPosition = normalizedPosition;
    this.tween = LeanTween.value(this.gameObject, normalizedPosition, to, this.scrollSensitivity * 0.1f / this.speed).setEase(LeanTweenType.easeOutQuart).setOnUpdateVector2((Action<Vector2>) (a => this.normalizedPosition = a));
    this.tween.setIgnoreTimeScale(true);
  }

  public void SetContent(GameObject comp)
  {
    RectTransform component = comp.GetComponent<RectTransform>();
    if (component == null)
      return;
    this.content = component;
  }

  public void SetContent(RectTransform rectTransform) => this.content = rectTransform;

  public void ScrollToTop() => this.verticalNormalizedPosition = 1f;

  public void ScrollToTopAfterFrame() => this.StartCoroutine(this.ScrollToTopAfterFrameRoutine());

  public IEnumerator ScrollToTopAfterFrameRoutine()
  {
    yield return (object) new WaitForEndOfFrame();
    this.ScrollToTop();
  }

  [CompilerGenerated]
  public void \u003COnScroll\u003Eb__4_0(Vector2 a) => this.normalizedPosition = a;

  [CompilerGenerated]
  public void \u003CScrollTo\u003Eb__5_0(Vector2 a) => this.normalizedPosition = a;
}
﻿// Decompiled with JetBrains decompiler
// Type: SnowBear
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class SnowBear : ScriptableCardImage
{
  [SerializeField]
  public Transform main;
  [SerializeField]
  public Transform ball;
  [SerializeField]
  public AnimationCurve curve;
  [SerializeField]
  public AnimationCurve ballScaleCurve;
  [SerializeField]
  public AnimationCurve ballYCurve;
  [SerializeField]
  public AnimationCurve yCurve;
  [Header("Tween")]
  [SerializeField]
  public AnimationCurve tweenCurve;
  [SerializeField]
  public float tweenDur;
  public float tweenFrom;
  public float tweenTo;
  public float tweenT;
  public bool tween;
  public bool currentSet;
  public int current;

  public override void UpdateEvent()
  {
    if (this.currentSet && this.current == this.entity.damage.current)
      return;
    this.currentSet = true;
    this.current = this.entity.damage.current;
    this.Set();
  }

  public void Set()
  {
    this.tweenFrom = this.tweenTo;
    this.tweenTo = this.curve.Evaluate((float) this.current);
    this.StartTween();
  }

  public void StartTween()
  {
    this.tween = true;
    this.tweenT = 0.0f;
  }

  public void Update()
  {
    if (!this.tween)
      return;
    this.tweenT += Time.deltaTime / this.tweenDur;
    this.UpdateValues(this.tweenFrom + this.tweenCurve.Evaluate(this.tweenT) * (this.tweenTo - this.tweenFrom));
    if ((double) this.tweenT <= 1.0)
      return;
    this.tween = false;
  }

  public void UpdateValues(float progress)
  {
    float num1 = this.ballScaleCurve.Evaluate(progress);
    float num2 = this.ballYCurve.Evaluate(progress);
    float num3 = this.yCurve.Evaluate(progress);
    this.ball.localScale = new Vector3(num1, num1, 1f);
    this.ball.localPosition = this.ball.localPosition.WithY(num2);
    this.main.localPosition = this.main.localPosition.WithY(num3);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SnowfallParticles
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;

public class SnowfallParticles : MonoBehaviour
{
  [SerializeField]
  [Range(0.0f, 1f)]
  [OnValueChanged("Evaluate")]
  public float storminess;
  [SerializeField]
  public AnimationCurve updateCurve;
  [Header("References")]
  [SerializeField]
  public ParticleSystem backSnow;
  [SerializeField]
  public ParticleSystem midSnow;
  [SerializeField]
  public ParticleSystem frontSnow;
  [SerializeField]
  public ParticleSystem bloops;
  [SerializeField]
  public SpriteRenderer fade;
  [Header("Values To Adjust")]
  [SerializeField]
  public AnimationCurve angleRange;
  [SerializeField]
  public AnimationCurve backEmissionRange;
  [SerializeField]
  public AnimationCurve midEmissionRange;
  [SerializeField]
  public AnimationCurve frontEmissionRange;
  [SerializeField]
  public AnimationCurve bloopsEmissionRange;
  [SerializeField]
  public AnimationCurve fadeAlphaRange;
  [SerializeField]
  public AnimationCurve simulationSpeedRange;
  [SerializeField]
  public AnimationCurve backSnowGravityRange;
  [SerializeField]
  public AnimationCurve midSnowGravityRange;
  [SerializeField]
  public AnimationCurve frontSnowGravityRange;
  [SerializeField]
  public AnimationCurve bloopsGravityRange;
  [SerializeField]
  public AnimationCurve xRange;
  [SerializeField]
  public AnimationCurve backSnowXSpeedRange;
  [SerializeField]
  public AnimationCurve midSnowXSpeedRange;
  [SerializeField]
  public AnimationCurve frontSnowXSpeedRange;
  [SerializeField]
  public AnimationCurve bloopsXSpeedRange;
  public ParticleSystem.MainModule backSnowMain;
  public ParticleSystem.MainModule midSnowMain;
  public ParticleSystem.MainModule frontSnowMain;
  public ParticleSystem.MainModule bloopsMain;
  public ParticleSystem.EmissionModule backSnowEmission;
  public ParticleSystem.EmissionModule midSnowEmission;
  public ParticleSystem.EmissionModule frontSnowEmission;
  public ParticleSystem.EmissionModule bloopsEmission;
  public ParticleSystem.VelocityOverLifetimeModule backSnowVel;
  public ParticleSystem.VelocityOverLifetimeModule midSnowVel;
  public ParticleSystem.VelocityOverLifetimeModule frontSnowVel;
  public ParticleSystem.VelocityOverLifetimeModule bloopsVel;
  public float t = 1f;
  public float storminessFrom;
  public float storminessTo;
  public float d = 1f;

  public void Awake()
  {
    this.backSnowMain = this.backSnow.main;
    this.midSnowMain = this.midSnow.main;
    this.frontSnowMain = this.frontSnow.main;
    this.bloopsMain = this.bloops.main;
    this.backSnowEmission = this.backSnow.emission;
    this.midSnowEmission = this.midSnow.emission;
    this.frontSnowEmission = this.frontSnow.emission;
    this.bloopsEmission = this.bloops.emission;
    this.backSnowVel = this.backSnow.velocityOverLifetime;
    this.midSnowVel = this.midSnow.velocityOverLifetime;
    this.frontSnowVel = this.frontSnow.velocityOverLifetime;
    this.bloopsVel = this.bloops.velocityOverLifetime;
  }

  public void OnEnable()
  {
    global::Events.OnSetWeatherIntensity += new UnityAction<float, float>(this.SetStorminess);
    this.Evaluate();
  }

  public void OnDisable() => global::Events.OnSetWeatherIntensity -= new UnityAction<float, float>(this.SetStorminess);

  public void SetStorminess(float amount, float duration)
  {
    this.storminessFrom = this.storminess;
    this.storminessTo = amount;
    this.t = 0.0f;
    this.d = duration;
  }

  public void Update()
  {
    if ((double) this.t >= 1.0)
      return;
    this.t += Time.deltaTime / this.d;
    this.storminess = this.storminessFrom + (this.storminessTo - this.storminessFrom) * this.updateCurve.Evaluate(this.t);
    this.Evaluate();
  }

  public void Evaluate()
  {
    this.transform.localEulerAngles = new Vector3(0.0f, 0.0f, this.angleRange.Evaluate(this.storminess));
    this.backSnowEmission.rateOverTime = (ParticleSystem.MinMaxCurve) this.backEmissionRange.Evaluate(this.storminess);
    this.midSnowEmission.rateOverTime = (ParticleSystem.MinMaxCurve) this.midEmissionRange.Evaluate(this.storminess);
    this.frontSnowEmission.rateOverTime = (ParticleSystem.MinMaxCurve) this.frontEmissionRange.Evaluate(this.storminess);
    this.bloopsEmission.rateOverTime = (ParticleSystem.MinMaxCurve) this.bloopsEmissionRange.Evaluate(this.storminess);
    this.fade.color = this.fade.color.With(alpha: this.fadeAlphaRange.Evaluate(this.storminess));
    float num = this.simulationSpeedRange.Evaluate(this.storminess);
    this.backSnowMain.simulationSpeed = num;
    this.midSnowMain.simulationSpeed = num;
    this.frontSnowMain.simulationSpeed = num;
    this.bloopsMain.simulationSpeed = num;
    float max1 = this.backSnowGravityRange.Evaluate(this.storminess);
    this.backSnowMain.gravityModifier = new ParticleSystem.MinMaxCurve(-max1, max1);
    float max2 = this.midSnowGravityRange.Evaluate(this.storminess);
    this.midSnowMain.gravityModifier = new ParticleSystem.MinMaxCurve(-max2, max2);
    float max3 = this.frontSnowGravityRange.Evaluate(this.storminess);
    this.frontSnowMain.gravityModifier = new ParticleSystem.MinMaxCurve(-max3, max3);
    float max4 = this.bloopsGravityRange.Evaluate(this.storminess);
    this.bloopsMain.gravityModifier = new ParticleSystem.MinMaxCurve(-max4, max4);
    this.transform.SetLocalX(this.xRange.Evaluate(this.storminess));
    this.backSnowVel.xMultiplier = this.backSnowXSpeedRange.Evaluate(this.storminess);
    this.midSnowVel.xMultiplier = this.midSnowXSpeedRange.Evaluate(this.storminess);
    this.frontSnowVel.xMultiplier = this.frontSnowXSpeedRange.Evaluate(this.storminess);
    this.bloopsVel.xMultiplier = this.bloopsXSpeedRange.Evaluate(this.storminess);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SpacingBasedOnAspect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof (HorizontalOrVerticalLayoutGroup))]
public class SpacingBasedOnAspect : MonoBehaviour
{
  [SerializeField]
  public AnimationCurve curve;
  [SerializeField]
  public float maxSpacing;
  [SerializeField]
  public float minSpacing;
  public HorizontalOrVerticalLayoutGroup _layout;

  public HorizontalOrVerticalLayoutGroup layout => this._layout ?? (this._layout = this.GetComponent<HorizontalOrVerticalLayoutGroup>());

  public void UpdatePosition(RectTransform canvas)
  {
    Vector2 sizeDelta = canvas.sizeDelta;
    this.layout.spacing = this.minSpacing + (this.maxSpacing - this.minSpacing) * this.curve.Evaluate(sizeDelta.x / sizeDelta.y);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Sparkle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof (Image))]
public class Sparkle : MonoBehaviourRect
{
  public Vector2 moveSpeed = new Vector2(0.1f, -1f);
  public Vector2 moveSway = new Vector2(0.6f, 0.3f);
  public Vector2 moveSwayTime = new Vector2(0.62f, 0.49f);
  public Vector3 rotation = new Vector3(0.0f, 0.0f, 0.0f);
  public float time;
  public Image _image;
  public float _size;

  public Image image
  {
    get
    {
      if ((Object) this._image == (Object) null)
        this._image = this.GetComponent<Image>();
      return this._image;
    }
  }

  public float size
  {
    get => this._size;
    set
    {
      this._size = value;
      this.rectTransform.sizeDelta = new Vector2(this._size, this._size);
    }
  }

  public Color color
  {
    get => this.image.color;
    set => this.image.color = value;
  }

  public Sprite sprite
  {
    get => this.image.sprite;
    set => this.image.sprite = value;
  }

  public void Start()
  {
    LeanTween.cancel(this.gameObject);
    LeanTween.scale(this.gameObject, Vector3.one * 0.5f, Random.Range(1.5f, 1.75f)).setEase(LeanTweenType.easeInOutSine).setLoopPingPong();
  }

  public void Update()
  {
    this.time += Time.deltaTime;
    this.transform.localPosition = this.transform.localPosition.Add((this.moveSpeed + this.moveSway * this.moveSwayTime * Mathf.Sin(this.time)) * this.size * Time.deltaTime);
    this.transform.localEulerAngles = this.transform.localEulerAngles.Add(this.rotation * Time.deltaTime);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SparkleSpawner
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class SparkleSpawner : MonoBehaviourRect
{
  public int sparkleCount;
  public Sprite sparkleSprite;
  public Queue<Sparkle> pool = new Queue<Sparkle>();
  public List<Transform> activeSparkles = new List<Transform>();
  public Vector2 sizeRange = new Vector2(0.25f, 0.75f);
  public Color colour = Color.white;
  public Vector2 spawnTimeRange = new Vector2(0.75f, 1f);
  public float timer;

  public void Update()
  {
    float y = this.rectTransform.rect.position.y;
    for (int index = this.activeSparkles.Count - 1; index >= 0; --index)
    {
      Transform activeSparkle = this.activeSparkles[index];
      Vector3 localPosition = activeSparkle.localPosition;
      if ((double) localPosition.y < (double) y)
      {
        this.pool.Enqueue(activeSparkle.GetComponent<Sparkle>());
        activeSparkle.gameObject.SetActive(false);
        this.activeSparkles.Remove(activeSparkle);
      }
      else
        activeSparkle.localPosition = localPosition;
    }
    this.timer -= Time.deltaTime;
    if ((double) this.timer > 0.0)
      return;
    this.NewSparkle();
    this.timer = this.spawnTimeRange.PettyRandom();
  }

  public void NewSparkle()
  {
    Sparkle sparkle;
    if (this.pool.Count <= 0)
    {
      sparkle = new GameObject(string.Format("Sparkle {0}", (object) this.sparkleCount++)).AddComponent<Sparkle>();
      sparkle.sprite = this.sparkleSprite;
      sparkle.transform.SetParent(this.transform);
    }
    else
    {
      sparkle = this.pool.Dequeue();
      sparkle.gameObject.SetActive(true);
    }
    float num = this.sizeRange.PettyRandom();
    float a = Mathf.Min(1f, num * 2f) * 0.5f;
    Rect rect = this.rectTransform.rect;
    Vector3 vector3 = (rect.position + new Vector2(Random.Range(0.0f, rect.width), rect.height)).WithZ(0.0f);
    RectTransform component = sparkle.GetComponent<RectTransform>();
    component.localPosition = vector3;
    component.localEulerAngles = Vector3.zero;
    component.localScale = Vector3.one;
    sparkle.size = num;
    sparkle.color = new Color(this.colour.r, this.colour.g, this.colour.b, a);
    this.activeSparkles.Add(sparkle.transform);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SpecialEventsSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class SpecialEventsSystem : MonoBehaviour
{
  [SerializeField]
  public SpecialEventsSystem.Event[] events;

  public void OnEnable() => global::Events.OnPreCampaignPopulate += new UnityAction(this.PreCampaignPopulate);

  public void OnDisable() => global::Events.OnPreCampaignPopulate -= new UnityAction(this.PreCampaignPopulate);

  public void PreCampaignPopulate()
  {
    List<List<CampaignNode>> listOfNodes = SpecialEventsSystem.CreateListOfNodes();
    foreach (SpecialEventsSystem.Event specialEvent in this.events)
      SpecialEventsSystem.InsertSpecialEvent(listOfNodes, specialEvent);
  }

  public static void InsertSpecialEvent(
    List<List<CampaignNode>> tiers,
    SpecialEventsSystem.Event specialEvent)
  {
    if ((bool) (UnityEngine.Object) specialEvent.requiresUnlock && Campaign.Data.GameMode.mainGameMode && !MetaprogressionSystem.IsUnlocked(specialEvent.requiresUnlock))
      return;
    int num1 = specialEvent.perRun.Random();
    int num2 = 0;
    int[] numArray = new int[tiers.Count];
    do
    {
      foreach (List<CampaignNode> campaignNodeList in (IEnumerable<List<CampaignNode>>) tiers.InRandomOrder<List<CampaignNode>>())
      {
        int num3 = specialEvent.perTier.Random();
        if (num3 > 0)
        {
          foreach (CampaignNode campaignNode in campaignNodeList)
          {
            if (campaignNode.tier >= specialEvent.minTier)
            {
              if (numArray[campaignNode.tier] < specialEvent.perTier.y)
              {
                if (specialEvent.replaceNodeTypes.Contains<string>(campaignNode.type.name))
                {
                  Debug.Log((object) string.Format("SpecialEventSystem → Replacing [{0} ({1}) tier {2}] with ({3})", (object) campaignNode, (object) campaignNode.type.name, (object) campaignNode.tier, (object) specialEvent.nodeType.name));
                  campaignNode.SetType(specialEvent.nodeType);
                  ++numArray[campaignNode.tier];
                  ++num2;
                  if (numArray[campaignNode.tier] < num3)
                  {
                    if (num2 >= num1)
                      break;
                  }
                  else
                    break;
                }
              }
              else
                break;
            }
            else
              break;
          }
        }
        if (num2 >= num1)
          break;
      }
    }
    while (num2 < specialEvent.perRun.x);
  }

  public static List<List<CampaignNode>> CreateListOfNodes()
  {
    List<List<CampaignNode>> listOfNodes = new List<List<CampaignNode>>();
    int a = 0;
    foreach (CampaignNode node in Campaign.instance.nodes)
    {
      if (node.tier >= 0)
      {
        a = Mathf.Max(a, node.tier + 1);
        while (listOfNodes.Count <= node.tier)
          listOfNodes.Add(new List<CampaignNode>());
        int index = UnityEngine.Random.Range(0, listOfNodes[node.tier].Count - 1);
        listOfNodes[node.tier].Insert(index, node);
      }
    }
    return listOfNodes;
  }

  [Serializable]
  public struct Event
  {
    public CampaignNodeType nodeType;
    public UnlockData requiresUnlock;
    public string[] replaceNodeTypes;
    public int minTier;
    public Vector2Int perTier;
    public Vector2Int perRun;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SpeechBub
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;

public class SpeechBub : MonoBehaviourRect
{
  [SerializeField]
  public TMP_Text textAsset;
  [SerializeField]
  public Transform tail;
  [SerializeField]
  public float minHeight = 1f;
  [SerializeField]
  public float tailOffsetX = -0.225f;
  [SerializeField]
  public float tailOffsetY = -0.125f;
  [SerializeField]
  public float tailAngleOffset = 45f;
  [SerializeField]
  public bool constantAngle = true;
  [SerializeField]
  public string highlightHex = "328AD7";
  [Header("Animations")]
  [SerializeField]
  public TweenUI destroyTween;
  [SerializeField]
  public AnimationCurve moveCurve;
  [SerializeField]
  public Vector2 moveDurRange = new Vector2(0.75f, 1f);
  public float tailAnchorX = 1f;
  public float tailAnchorY = -1f;
  public Transform target;
  public float duration;
  public float durationMax;
  public bool _hasTail = true;
  public bool destroying;
  [CompilerGenerated]
  public bool \u003CsizeUpdated\u003Ek__BackingField;

  public float durationFactor => this.duration / this.durationMax;

  public bool hasTail
  {
    get => this._hasTail;
    set
    {
      this._hasTail = value;
      this.tail.gameObject.SetActive(value);
    }
  }

  public bool sizeUpdated
  {
    get => this.\u003CsizeUpdated\u003Ek__BackingField;
    set => this.\u003CsizeUpdated\u003Ek__BackingField = value;
  }

  public void OnEnable() => SfxSystem.OneShot("event:/sfx/ui/speech_bubble");

  public void Set(SpeechBubbleData data)
  {
    this.textAsset.text = this.ProcessText(data.text);
    this.target = data.target;
    this.hasTail = (Object) this.target != (Object) null;
    this.duration = data.duration;
    this.durationMax = data.duration;
    this.StartCoroutine(this.UpdateSizeNextFrame());
  }

  public void SetPosition(Vector3 localPos)
  {
    this.sizeUpdated = false;
    LeanTween.cancel(this.gameObject);
    LeanTween.moveLocal(this.gameObject, localPos, this.moveDurRange.PettyRandom()).setEase(this.moveCurve);
  }

  [Button(null, EButtonEnableMode.Always)]
  public void UpdateSize()
  {
    this.rectTransform.sizeDelta = this.rectTransform.sizeDelta.WithY(Mathf.Max(this.minHeight, this.textAsset.textBounds.size.y + (this.textAsset.margin.y + this.textAsset.margin.w)));
    if (!this.hasTail)
      return;
    Vector2 sizeDelta = this.rectTransform.sizeDelta;
    this.tail.localPosition = (Vector3) new Vector2((float) ((double) this.tailAnchorX * 0.5 * (double) sizeDelta.x + (double) this.tailOffsetX * (double) this.tailAnchorX), (float) ((double) this.tailAnchorY * 0.5 * (double) sizeDelta.y + (double) this.tailOffsetY * (double) this.tailAnchorY));
  }

  public IEnumerator UpdateSizeNextFrame()
  {
    yield return (object) null;
    this.UpdateSize();
    this.sizeUpdated = true;
  }

  public void LateUpdate()
  {
    if (this.destroying)
      return;
    Transform transform = this.transform;
    if (this.constantAngle && (double) transform.eulerAngles.z != 0.0)
      transform.eulerAngles = transform.eulerAngles.WithZ(0.0f);
    this.duration -= Time.deltaTime;
    if ((double) this.duration <= 0.0)
    {
      this.destroying = true;
      this.StartCoroutine(this.Destroy());
    }
    if (!this.hasTail || !((Object) this.target != (Object) null))
      return;
    this.tail.eulerAngles = this.tail.eulerAngles.WithZ(SpeechBub.Angle((Vector2) this.tail.position, (Vector2) this.target.position) + this.tailAngleOffset);
  }

  public static float Angle(Vector2 from, Vector2 to)
  {
    Vector2 to1 = to - from;
    int num = (double) to1.y >= 0.0 ? 1 : -1;
    return Vector2.Angle(Vector2.right, to1) * (float) num;
  }

  public IEnumerator Destroy()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    SpeechBub speechBub = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      speechBub.gameObject.Destroy();
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    speechBub.destroyTween.Fire();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) new WaitForSeconds(speechBub.destroyTween.GetDuration());
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public string ProcessText(string input)
  {
    string text = input.Trim();
    int length = text.Length;
    for (int index = 0; index < length; ++index)
    {
      if (text[index] == '<')
      {
        string str1 = Text.FindTag(text, index);
        if (str1.Length > 0)
        {
          string str2 = this.highlightHex;
          string str3 = text.Remove(index, str1.Length + 2);
          int num1 = str1.IndexOf(' ');
          if (num1 > 0)
          {
            string str4 = str1.Substring(0, num1);
            if (str4[0] == '#')
            {
              str2 = str4.Substring(1);
              str1 = str1.Substring(num1);
            }
          }
          string str5 = "<#" + str2 + ">" + str1 + "</color>";
          text = str3.Insert(index, str5);
          int num2 = index + str5.Length;
          length = text.Length;
          index = num2 - 1;
        }
      }
    }
    return text;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SpeechBubble
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class SpeechBubble : MonoBehaviour
{
  [SerializeField]
  public TMP_Text textElement;

  public void SetSize(float size) => this.textElement.fontSize = size;

  public void SetTextColour(Color color) => this.textElement.color = color;

  public void SetTextSpriteAsset(TMP_SpriteAsset spriteAsset) => this.textElement.spriteAsset = spriteAsset;

  public void SetText(string text) => this.textElement.text = text;
}
﻿// Decompiled with JetBrains decompiler
// Type: SpeechBubbleData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Runtime.CompilerServices;
using UnityEngine;

public class SpeechBubbleData
{
  public Transform target;
  public string targetName;
  public string text;
  public float delay;
  [CompilerGenerated]
  public float \u003Cduration\u003Ek__BackingField;

  public float duration
  {
    get => this.\u003Cduration\u003Ek__BackingField;
    set => this.\u003Cduration\u003Ek__BackingField = value;
  }

  public SpeechBubbleData(Transform target, string targetName, string text, float delay = 0.0f)
  {
    this.target = target;
    this.targetName = targetName;
    this.text = text;
    this.delay = delay;
  }

  public void SetDuration(float duration) => this.duration = duration;
}
﻿// Decompiled with JetBrains decompiler
// Type: SpeechBubbleSpawn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class SpeechBubbleSpawn : MonoBehaviourRect
{
  public float spacing = 0.01f;
  public readonly List<SpeechBub> bubbles = new List<SpeechBub>();

  public void OnEnable() => Object.FindObjectOfType<SpeechBubbleSystem>()?.AddSpawnPoint(this);

  public void OnDisable() => Object.FindObjectOfType<SpeechBubbleSystem>()?.RemoveSpawnPoint(this);

  public void Update()
  {
    bool flag = false;
    for (int index = this.bubbles.Count - 1; index >= 0; --index)
    {
      SpeechBub bubble = this.bubbles[index];
      if (!(bool) (Object) bubble)
        this.bubbles.RemoveAt(index);
      else if (!flag)
        flag = bubble.sizeUpdated;
    }
    if (!flag)
      return;
    this.UpdateSize();
    this.UpdatePositions();
  }

  public SpeechBub Create(SpeechBub prefab, SpeechBubbleData data)
  {
    SpeechBub speechBub = Object.Instantiate<SpeechBub>(prefab, this.transform);
    Transform transform = speechBub.transform;
    transform.localPosition = Vector3.zero;
    if (transform is RectTransform rectTransform)
      rectTransform.sizeDelta = rectTransform.sizeDelta.WithX(this.rectTransform.sizeDelta.x);
    this.bubbles.Add(speechBub);
    speechBub.Set(data);
    this.UpdateSize();
    this.UpdatePositions();
    return speechBub;
  }

  public void UpdateSize()
  {
    Vector2 vector2 = new Vector2(0.0f, 0.0f);
    int count = this.bubbles.Count;
    for (int index = 0; index < count; ++index)
    {
      SpeechBub bubble = this.bubbles[index];
      if ((bool) (Object) bubble)
      {
        Vector2 sizeDelta = bubble.rectTransform.sizeDelta;
        vector2.x = Mathf.Max(vector2.x, sizeDelta.x);
        vector2.y += sizeDelta.y + (index > 0 ? this.spacing : 0.0f);
      }
    }
    if (!(bool) (Object) this.rectTransform)
      return;
    this.rectTransform.sizeDelta = vector2;
  }

  public void UpdatePositions()
  {
    if (!(bool) (Object) this.rectTransform)
      return;
    Vector2 sizeDelta1 = this.rectTransform.sizeDelta;
    Vector2 vector2 = new Vector2((float) (-(double) sizeDelta1.x * 0.5), sizeDelta1.y * 0.5f);
    int count = this.bubbles.Count;
    for (int index = 0; index < count; ++index)
    {
      SpeechBub bubble = this.bubbles[index];
      if ((bool) (Object) bubble)
      {
        if (index < count - 1 && bubble.hasTail)
          bubble.hasTail = false;
        Vector2 sizeDelta2 = bubble.rectTransform.sizeDelta;
        Vector2 localPos = vector2 + new Vector2(sizeDelta2.x * 0.5f, (float) (-(double) sizeDelta2.y * 0.5));
        bubble.SetPosition((Vector3) localPos);
        vector2.y -= sizeDelta2.y;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SpeechBubbleSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SpeechBubbleSystem : GameSystem
{
  public static SpeechBubbleSystem instance;
  public SpeechBub bubblePrefab;
  public AnimationCurve wordToDurationCurve;
  public float durationFactor = 1f;
  public List<SpeechBubbleSpawn> spawnPoints;
  public List<SpeechBubbleData> queue;
  public SpeechBub current;

  public static event SpeechBubbleSystem.NotifyCreate OnCreate;

  public static void Create(SpeechBubbleData data)
  {
    SpeechBubbleSystem.NotifyCreate onCreate = SpeechBubbleSystem.OnCreate;
    if (onCreate == null)
      return;
    onCreate(data);
  }

  public void OnEnable()
  {
    SpeechBubbleSystem.instance = this;
    this.spawnPoints = new List<SpeechBubbleSpawn>();
    this.queue = new List<SpeechBubbleData>();
    SpeechBubbleSystem.OnCreate += new SpeechBubbleSystem.NotifyCreate(this.QueueBubble);
  }

  public void OnDisable()
  {
    SpeechBubbleSystem.OnCreate -= new SpeechBubbleSystem.NotifyCreate(this.QueueBubble);
    this.StopAllCoroutines();
  }

  public void Update()
  {
    if (this.queue.Count <= 0 || (bool) (UnityEngine.Object) this.current && (double) this.current.durationFactor >= 0.5)
      return;
    this.CreateBubble(this.queue[0]);
    this.queue.RemoveAt(0);
  }

  public void QueueBubble(SpeechBubbleData data) => this.queue.Add(data);

  public void CreateBubble(SpeechBubbleData data)
  {
    if ((double) data.delay > 0.0)
      this.StartCoroutine(this.CreateBubbleAfter(data, data.delay));
    else if (this.spawnPoints.Count > 0)
    {
      SpeechBubbleSpawn speechBubbleSpawn = (SpeechBubbleSpawn) null;
      data.SetDuration(SpeechBubbleSystem.GetDuration(data.text));
      if (!(bool) (UnityEngine.Object) data.target)
      {
        speechBubbleSpawn = this.spawnPoints.RandomItem<SpeechBubbleSpawn>();
      }
      else
      {
        Vector3 position = data.target.position;
        float num1 = float.MaxValue;
        foreach (SpeechBubbleSpawn spawnPoint in this.spawnPoints)
        {
          float num2 = spawnPoint.transform.position.DistanceTo(position);
          if ((double) num2 < (double) num1)
          {
            num1 = num2;
            speechBubbleSpawn = spawnPoint;
          }
        }
      }
      if (!(bool) (UnityEngine.Object) speechBubbleSpawn)
        return;
      this.current = speechBubbleSpawn.Create(this.bubblePrefab, data);
    }
    else
      Debug.LogWarning((object) "Speech Bubble could not be created: No anchor points in scene!");
  }

  public IEnumerator CreateBubbleAfter(SpeechBubbleData data, float delay)
  {
    yield return (object) new WaitForSeconds(delay);
    data.delay = 0.0f;
    this.CreateBubble(data);
  }

  public static float GetDuration(string text)
  {
    string[] strArray = text.Split(new char[1]{ ' ' }, StringSplitOptions.RemoveEmptyEntries);
    return SpeechBubbleSystem.instance.wordToDurationCurve.Evaluate((float) strArray.Length) * SpeechBubbleSystem.instance.durationFactor;
  }

  public void AddSpawnPoint(SpeechBubbleSpawn spawnPoint) => this.spawnPoints.Add(spawnPoint);

  public void RemoveSpawnPoint(SpeechBubbleSpawn spawnPoint) => this.spawnPoints.Remove(spawnPoint);

  public delegate void NotifyCreate(SpeechBubbleData data);
}
﻿// Decompiled with JetBrains decompiler
// Type: Spinner
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

public class Spinner : MonoBehaviour
{
  [SerializeField]
  public bool ignoreTimeScale;
  public Vector3 speed = new Vector3(0.0f, 0.0f, 1f);
  public bool setTargetSpeed;
  [ShowIf("setTargetSpeed")]
  public Vector3 targetSpeed;
  [ShowIf("setTargetSpeed")]
  public float targetSpeedAcc = 100f;

  public void Update()
  {
    if (this.setTargetSpeed)
      this.speed = Vector3.MoveTowards(this.speed, this.targetSpeed, this.targetSpeedAcc * Time.deltaTime);
    this.transform.localEulerAngles = this.transform.localEulerAngles + this.speed * (this.ignoreTimeScale ? Time.unscaledDeltaTime : Time.deltaTime);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SplashScreenSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMOD.Studio;
using FMODUnity;
using System;
using System.Collections;
using UnityEngine;

public class SplashScreenSequence : MonoBehaviour
{
  [SerializeField]
  public SplashScreenSequence.Phase[] phases;
  public int phase;
  public EventInstance sfxInstance;

  public IEnumerator Run()
  {
    PauseMenu.Block();
    while (this.phase < this.phases.Length)
    {
      this.phases[this.phase].gameObject.SetActive(true);
      if (!this.phases[this.phase].sfxEvent.IsNull)
        this.sfxInstance = SfxSystem.OneShot(this.phases[this.phase].sfxEvent);
      float time = 0.0f;
      while ((double) time < (double) this.phases[this.phase].autoSkipTime)
      {
        yield return (object) null;
        time += Time.deltaTime;
        if ((double) time > (double) this.phases[this.phase].canSkipTime && InputSystem.Enabled && SplashScreenSequence.AnyButtonPressed())
          break;
      }
      ++this.phase;
      if (this.sfxInstance.isValid())
      {
        int num = (int) this.sfxInstance.stop(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);
      }
    }
    PauseMenu.Unblock();
  }

  public static bool AnyButtonPressed() => Input.anyKeyDown || Input.GetMouseButtonDown(0) || InputSystem.IsSelectPressed();

  [Serializable]
  public struct Phase
  {
    public GameObject gameObject;
    public float canSkipTime;
    public float autoSkipTime;
    public EventReference sfxEvent;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Splatter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UI;

public class Splatter : MonoBehaviour
{
  [SerializeField]
  public Sprite[] spriteOptions;
  [SerializeField]
  public Vector2 sizeRange = new Vector2(1.5f, 2f);
  [SerializeField]
  public Vector2 angleRange = new Vector2(0.0f, 360f);
  [SerializeField]
  public Image image;
  [CompilerGenerated]
  public bool \u003Cfading\u003Ek__BackingField;

  public bool fading
  {
    get => this.\u003Cfading\u003Ek__BackingField;
    set => this.\u003Cfading\u003Ek__BackingField = value;
  }

  public Sprite sprite
  {
    get => this.image.sprite;
    set => this.image.sprite = value;
  }

  public Color color
  {
    get => this.image.color;
    set => this.image.color = value;
  }

  public void Awake()
  {
    this.image.sprite = this.spriteOptions[PettyRandom.Range(0, this.spriteOptions.Length - 1)];
    this.transform.localEulerAngles = new Vector3(0.0f, 0.0f, this.angleRange.PettyRandom());
    this.transform.localScale = Vector3.one * this.sizeRange.PettyRandom();
  }

  public void FadeOut()
  {
    if (this.fading)
      return;
    LeanTween.cancel(this.gameObject);
    LeanTween.value(this.gameObject, this.image.color.a, 0.0f, PettyRandom.Range(10f, 15f)).setOnUpdate((Action<float>) (a => this.image.color = this.image.color.With(alpha: a))).setEase(LeanTweenType.easeInOutQuint).setOnComplete((System.Action) (() => this.gameObject.Destroy()));
    this.fading = true;
  }

  [CompilerGenerated]
  public void \u003CFadeOut\u003Eb__15_0(float a) => this.image.color = this.image.color.With(alpha: a);

  [CompilerGenerated]
  public void \u003CFadeOut\u003Eb__15_1() => this.gameObject.Destroy();
}
﻿// Decompiled with JetBrains decompiler
// Type: SplatterParticle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class SplatterParticle : MonoBehaviour
{
  public Splatter splatterPrefab;
  public bool canHitSource;
  public SplatterSurface source;
  [SerializeField]
  public Canvas canvas;
  [SerializeField]
  public Image image;
  [SerializeField]
  public Vector2 sizeRange = new Vector2(0.3f, 0.4f);
  public Vector3 velocity;
  public Vector3 gravity = new Vector3(0.0f, 0.0f, 1f);
  public Vector3 frictMult = new Vector3(0.99f, 0.99f, 0.99f);
  public bool isInBackground;
  [SerializeField]
  public float backgroundZThreshold = 1f;

  public Color color
  {
    get => this.image.color;
    set => this.image.color = value;
  }

  public void Awake() => this.transform.localScale = Vector3.one * this.sizeRange.PettyRandom();

  public void Update()
  {
    this.transform.position += this.velocity * Time.deltaTime;
    this.velocity += this.gravity * Time.deltaTime;
    this.velocity = Delta.Multiply(this.velocity, this.frictMult, Time.deltaTime);
    if (!this.isInBackground)
    {
      if ((double) this.transform.position.z > (double) this.backgroundZThreshold)
      {
        this.canvas.sortingLayerName = "Background";
        this.isInBackground = true;
        this.canHitSource = true;
      }
    }
    else if ((double) this.transform.position.z < (double) this.backgroundZThreshold)
    {
      this.canvas.sortingLayerName = "Default";
      this.isInBackground = true;
    }
    if ((double) this.transform.position.z <= 10.0)
      return;
    Object.Destroy((Object) this.gameObject);
  }

  public void SetSource(SplatterSurface source) => this.source = source;

  public void OnTriggerEnter(Collider other)
  {
    SplatterSurface component = other.gameObject.GetComponent<SplatterSurface>();
    if (!((Object) component != (Object) null) || !this.canHitSource && !((Object) component != (Object) this.source))
      return;
    component.Splat(this);
    this.gameObject.Destroy();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SplatterPersistenceSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class SplatterPersistenceSystem : GameSystem
{
  [SerializeField]
  public int[] teamsToSave;
  [SerializeField]
  public Splatter basicSplatterPrefab;
  [SerializeField]
  [ReadOnly]
  public int savedCount;
  [SerializeField]
  [ReadOnly]
  public bool saveRequired;
  public Dictionary<ulong, SplatterPersistenceSystem.SplatterData[]> storedSplatters;

  public void OnEnable()
  {
    global::Events.OnEntityCreated += new UnityAction<Entity>(this.EntityCreated);
    global::Events.OnEntityDestroyed += new UnityAction<Entity>(this.EntityDestroyed);
    global::Events.OnCampaignSaved += new UnityAction(this.CheckSave);
    global::Events.OnCampaignLoaded += new UnityAction(this.Load);
    global::Events.OnCampaignFinal += new UnityAction(this.Clear);
  }

  public void OnDisable()
  {
    global::Events.OnEntityCreated -= new UnityAction<Entity>(this.EntityCreated);
    global::Events.OnEntityDestroyed -= new UnityAction<Entity>(this.EntityDestroyed);
    global::Events.OnCampaignSaved -= new UnityAction(this.CheckSave);
    global::Events.OnCampaignLoaded -= new UnityAction(this.Load);
    global::Events.OnCampaignFinal -= new UnityAction(this.Clear);
  }

  public void EntityCreated(Entity entity)
  {
    if (this.storedSplatters == null || !(bool) (UnityEngine.Object) entity.data || !this.storedSplatters.ContainsKey(entity.data.id) || !(bool) (UnityEngine.Object) entity.splatterSurface)
      return;
    SplatterPersistenceSystem.SplatterData[] storedSplatter = this.storedSplatters[entity.data.id];
    foreach (SplatterPersistenceSystem.SplatterData data in storedSplatter)
      entity.splatterSurface.Load(data, this.basicSplatterPrefab);
    Debug.Log((object) string.Format("Creating [{0}] splatters on [{1}]", (object) storedSplatter.Length, (object) entity));
  }

  public void EntityDestroyed(Entity entity)
  {
    if (!((UnityEngine.Object) entity.data != (UnityEngine.Object) null) || !((UnityEngine.Object) entity.owner != (UnityEngine.Object) null) || !this.teamsToSave.Contains<int>(entity.owner.team) || !entity.owner.data.inventory.deck.Contains(entity.data) && !entity.owner.data.inventory.reserve.Contains(entity.data) || !((UnityEngine.Object) entity.splatterSurface != (UnityEngine.Object) null))
      return;
    Splatter[] activeSplatters = entity.splatterSurface.GetActiveSplatters();
    if (activeSplatters == null || activeSplatters.Length <= 0)
      return;
    List<SplatterPersistenceSystem.SplatterData> list = ((IEnumerable<Splatter>) activeSplatters).Select<Splatter, SplatterPersistenceSystem.SplatterData>((Func<Splatter, SplatterPersistenceSystem.SplatterData>) (splatter => new SplatterPersistenceSystem.SplatterData(splatter))).ToList<SplatterPersistenceSystem.SplatterData>();
    if (this.storedSplatters == null)
      this.storedSplatters = new Dictionary<ulong, SplatterPersistenceSystem.SplatterData[]>();
    if (this.storedSplatters.ContainsKey(entity.data.id))
    {
      this.storedSplatters[entity.data.id] = list.ToArray();
    }
    else
    {
      this.storedSplatters.Add(entity.data.id, list.ToArray());
      ++this.savedCount;
    }
    this.saveRequired = true;
    Debug.Log((object) string.Format("Storing [{0}] splatters on data for [{1}]", (object) list.Count, (object) entity));
  }

  public void CheckSave()
  {
    if (!this.saveRequired || !Campaign.Data.GameMode.doSave)
      return;
    SaveSystem.SaveCampaignData<Dictionary<ulong, SplatterPersistenceSystem.SplatterData[]>>(Campaign.Data.GameMode, "splatter", this.storedSplatters);
    this.saveRequired = false;
  }

  public void Load()
  {
    if (SaveSystem.CampaignDataExists(Campaign.Data.GameMode, "splatter"))
    {
      this.storedSplatters = SaveSystem.LoadCampaignData<Dictionary<ulong, SplatterPersistenceSystem.SplatterData[]>>(Campaign.Data.GameMode, "splatter");
      Dictionary<ulong, SplatterPersistenceSystem.SplatterData[]> storedSplatters = this.storedSplatters;
      // ISSUE: explicit non-virtual call
      this.savedCount = storedSplatters != null ? __nonvirtual (storedSplatters.Count) : 0;
    }
    else
      this.Clear();
  }

  public void Clear()
  {
    this.storedSplatters = (Dictionary<ulong, SplatterPersistenceSystem.SplatterData[]>) null;
    this.savedCount = 0;
  }

  [Serializable]
  public class SplatterData
  {
    public Sprite sprite;
    public Color color;
    public Vector3 offset;
    public Vector3 scale;
    public float angle;

    public SplatterData()
    {
    }

    public SplatterData(Splatter splatter)
    {
      this.sprite = splatter.sprite;
      this.color = splatter.color;
      Transform transform = splatter.transform;
      this.offset = transform.localPosition;
      this.scale = transform.localScale;
      this.angle = transform.localEulerAngles.z;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SplatterSurface
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using NaughtyAttributes;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class SplatterSurface : MonoBehaviour, IPoolable
{
  public RectTransform splatterContainer;
  [SerializeField]
  public Vector2 splatterScaleRange = new Vector2(1f, 1f);
  [SerializeField]
  public Vector2 splatterAlphaRange = new Vector2(1f, 1f);
  [SerializeField]
  public bool limitSplatters;
  [SerializeField]
  [ShowIf("limitSplatters")]
  public int maxSplatters = 10;
  [SerializeField]
  public bool colorBlend;
  [SerializeField]
  [ShowIf("colorBlend")]
  public Vector2 colorBlendRange = new Vector2(0.2f, 0.4f);
  [SerializeField]
  [ShowIf("colorBlend")]
  public Color blend = Color.white;
  [SerializeField]
  public bool fadeSplatters;
  [SerializeField]
  [ShowIf("fadeSplatters")]
  public Color fadeToColour;
  [SerializeField]
  [ShowIf("fadeSplatters")]
  public float fadeToDelay;
  public readonly List<Splatter> splatters = new List<Splatter>();

  public void Splat(SplatterParticle particle)
  {
    Splatter splatter = UnityEngine.Object.Instantiate<Splatter>(particle.splatterPrefab, (Transform) this.splatterContainer);
    Transform transform = splatter.transform;
    this.splatters.Add(splatter);
    Color color = particle.color;
    if (this.colorBlend)
    {
      float t = this.colorBlendRange.PettyRandom();
      color = Color.Lerp(color, this.blend, t);
    }
    splatter.color = color.With(alpha: particle.color.a * this.splatterAlphaRange.PettyRandom());
    if (this.fadeSplatters)
    {
      Color from = splatter.color;
      Color to = this.fadeToColour;
      LeanTween.value(splatter.gameObject, 0.0f, 1f, PettyRandom.Range(10f, 15f)).setEase(LeanTweenType.easeInOutQuint).setDelay(this.fadeToDelay).setOnUpdate((Action<float>) (a => splatter.color = Color.Lerp(from, to, a)));
    }
    Vector3 to1 = transform.localScale * this.splatterScaleRange.PettyRandom();
    transform.localScale = to1 * 0.5f;
    LeanTween.scale(splatter.gameObject, to1, PettyRandom.Range(0.12f, 0.18f)).setEase(LeanTweenType.easeOutBack);
    transform.position = particle.transform.position;
    transform.localPosition = transform.localPosition.WithZ(0.0f);
    if (!this.limitSplatters)
      return;
    int num = this.splatters.Count - this.maxSplatters;
    for (int index = 0; index < num; ++index)
    {
      this.splatters[0].FadeOut();
      this.splatters.RemoveAt(0);
    }
  }

  public void Load(SplatterPersistenceSystem.SplatterData data, Splatter prefab)
  {
    Splatter splatter = UnityEngine.Object.Instantiate<Splatter>(prefab, (Transform) this.splatterContainer);
    this.splatters.Add(splatter);
    splatter.sprite = data.sprite;
    splatter.color = data.color;
    Transform transform = splatter.transform;
    transform.localPosition = data.offset;
    transform.localScale = data.scale;
    transform.localEulerAngles = new Vector3(0.0f, 0.0f, data.angle);
  }

  public Splatter[] GetActiveSplatters() => this.splatters.Where<Splatter>((Func<Splatter, bool>) (a => !a.fading)).ToArray<Splatter>();

  public void OnGetFromPool()
  {
  }

  public void OnReturnToPool()
  {
    foreach (Component splatter in this.splatters)
      UnityEngine.Object.Destroy((UnityEngine.Object) splatter.gameObject);
    this.splatters.Clear();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SplatterSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using UnityEngine;
using UnityEngine.Events;

public class SplatterSystem : GameSystem
{
  [SerializeField]
  [Range(0.0f, 2f)]
  public float spread = 1f;
  [SerializeField]
  public Vector2 speedRange = new Vector2(1f, 10f);
  [SerializeField]
  public Vector2 upSpeedRange = new Vector2(-1f, 0.0f);
  [SerializeField]
  [Range(0.0f, 2f)]
  public float bloodAmount = 1f;
  [SerializeField]
  [Range(1f, 10f)]
  public int maxPerHit = 6;
  [SerializeField]
  public Gradient rainbow;
  public static int BloodType;
  public static float BloodAmount;

  public void OnEnable()
  {
    global::Events.OnEntityHit += new UnityAction<Hit>(this.EntityHit);
    global::Events.OnSettingChanged += new UnityAction<string, object>(SplatterSystem.SettingChanged);
    SplatterSystem.BloodType = Settings.Load<int>("Blood", 0);
    SplatterSystem.BloodAmount = Settings.Load<float>("BloodAmount", 1f);
  }

  public void OnDisable()
  {
    global::Events.OnEntityHit -= new UnityAction<Hit>(this.EntityHit);
    global::Events.OnSettingChanged -= new UnityAction<string, object>(SplatterSystem.SettingChanged);
  }

  public static void SettingChanged(string key, object value)
  {
    switch (key)
    {
      case "BloodAmount":
        if (!(value is float num1))
          break;
        SplatterSystem.BloodAmount = num1;
        break;
      case "Blood":
        if (!(value is int num2))
          break;
        SplatterSystem.BloodType = num2;
        break;
    }
  }

  public void EntityHit(Hit hit)
  {
    if (!hit.Offensive || hit.nullified || !hit.BasicHit || !hit.countsAsHit || !(bool) (Object) hit.target)
      return;
    BloodProfile bloodProfile = hit.target.data.bloodProfile;
    if (!(bool) (Object) bloodProfile)
      return;
    int num = Mathf.RoundToInt((float) Mathf.Min(hit.damage, this.maxPerHit) * this.bloodAmount * bloodProfile.bleedFactor * SplatterSystem.BloodAmount);
    Vector3 vector3_1 = !(bool) (Object) hit.attacker || !(bool) (Object) hit.target ? new Vector3(PettyRandom.Range(-1f, 1f), PettyRandom.Range(-1f, 1f), 0.0f).normalized : (hit.target.transform.position - hit.attacker.transform.position).normalized;
    for (int index = 0; index < num; ++index)
    {
      SplatterParticle splatterParticle = Object.Instantiate<SplatterParticle>(bloodProfile.splatterParticlePrefab);
      Vector3 vector3_2 = new Vector3(PettyRandom.Range(-1f, 1f), PettyRandom.Range(-1.5f, 1.5f), 0.0f);
      splatterParticle.transform.position = hit.target.transform.position + vector3_2;
      splatterParticle.color = this.GetBloodColour(hit.target);
      splatterParticle.velocity = (vector3_1 * this.speedRange.PettyRandom() + PettyRandom.Vector3() * this.spread).WithZ(this.upSpeedRange.PettyRandom());
      splatterParticle.SetSource(hit.target.GetComponentInChildren<SplatterSurface>());
    }
  }

  public Color GetBloodColour(Entity entity) => SplatterSystem.BloodType != 1 ? ((bool) (Object) entity.data.bloodProfile ? (entity.data.bloodProfile.variableColor ? entity.data.bloodProfile.colorRange.Evaluate(entity.data.random3.x.Mod(1f)) : entity.data.bloodProfile.color) : Color.white) : this.rainbow.Evaluate(entity.data.random3.x.Mod(1f));
}
﻿// Decompiled with JetBrains decompiler
// Type: SpriteCollection
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "SpriteCollection", menuName = "Character/Sprite Collection")]
public class SpriteCollection : Collection<Sprite>
{
}
﻿// Decompiled with JetBrains decompiler
// Type: SpriteSet
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public class SpriteSet
{
  public Sprite[] set;

  public Sprite this[int index] => this.set[index];
}
﻿// Decompiled with JetBrains decompiler
// Type: SpriteSetCollection
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "SpriteSetCollection", menuName = "Character/Sprite Set Collection")]
public class SpriteSetCollection : Collection<SpriteSet>
{
}
﻿// Decompiled with JetBrains decompiler
// Type: SpriteSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class SpriteSetter : MonoBehaviour
{
  [SerializeField]
  public Image image;
  [SerializeField]
  public Profile[] sprites;

  public void Set(string @in)
  {
    Profile profile = ((IEnumerable<Profile>) this.sprites).FirstOrDefault<Profile>((Func<Profile, bool>) (a => a.@string == @in));
    if (profile == null)
      return;
    this.image.sprite = profile.sprite;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StartTransition
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class StartTransition : MonoBehaviour
{
  public void GoTo(string sceneName)
  {
    if (!this.enabled)
      return;
    Routine routine = new Routine(Transition.To(sceneName));
    this.enabled = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Stat
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using UnityEngine;

[Serializable]
public struct Stat
{
  public static readonly Stat Default = new Stat(1, 0);
  [SerializeField]
  public SafeInt safeCurrent;
  [SerializeField]
  public SafeInt safeMax;

  public int current
  {
    get => this.safeCurrent.Value;
    set => this.safeCurrent = new SafeInt(value);
  }

  public int max
  {
    get => this.safeMax.Value;
    set => this.safeMax = new SafeInt(value);
  }

  public Stat(int value)
  {
    this.safeCurrent = new SafeInt(value);
    this.safeMax = new SafeInt(value);
  }

  public Stat(int current, int max)
  {
    this.safeCurrent = new SafeInt(current);
    this.safeMax = new SafeInt(max);
  }

  public void Max() => this.safeCurrent.Value = this.safeMax.Value;

  public static Stat operator +(Stat a, int b) => new Stat(a.safeCurrent.Value + b, a.safeMax.Value);

  public static Stat operator -(Stat a, int b) => new Stat(a.safeCurrent.Value - b, a.safeMax.Value);

  public static Stat operator *(Stat a, int b) => new Stat(a.safeCurrent.Value * b, a.safeMax.Value);

  public static Stat operator +(Stat a, SafeInt b) => new Stat(a.safeCurrent.Value + b.Value, a.safeMax.Value);

  public static Stat operator -(Stat a, SafeInt b) => new Stat(a.safeCurrent.Value - b.Value, a.safeMax.Value);

  public static Stat operator *(Stat a, SafeInt b) => new Stat(a.safeCurrent.Value * b.Value, a.safeMax.Value);

  public static bool operator ==(Stat a, int b) => a.safeCurrent.Value == b;

  public static bool operator !=(Stat a, int b) => a.safeCurrent.Value != b;

  public static bool operator >(Stat a, int b) => a.safeCurrent.Value > b;

  public static bool operator >=(Stat a, int b) => a.safeCurrent.Value >= b;

  public static bool operator <(Stat a, int b) => a.safeCurrent.Value < b;

  public static bool operator <=(Stat a, int b) => a.safeCurrent.Value <= b;

  public static bool operator ==(int a, Stat b) => a == b.safeCurrent.Value;

  public static bool operator !=(int a, Stat b) => a != b.safeCurrent.Value;

  public static bool operator >(int a, Stat b) => a > b.safeCurrent.Value;

  public static bool operator >=(int a, Stat b) => a >= b.safeCurrent.Value;

  public static bool operator <(int a, Stat b) => a < b.safeCurrent.Value;

  public static bool operator <=(int a, Stat b) => a <= b.safeCurrent.Value;

  public override string ToString() => string.Format("{0}/{1}", (object) this.safeCurrent.Value, (object) this.safeMax.Value);

  public override bool Equals(object obj) => obj is int num ? this.safeCurrent.Value == num : base.Equals(obj);

  public override int GetHashCode() => base.GetHashCode();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;
using UnityEngine.Localization.Components;

public class StatDisplay : MonoBehaviour
{
  [SerializeField]
  public TMP_Text textElement;
  [SerializeField]
  public LocalizeStringEvent localizeStringEvent;
  public string statValue;

  public void Assign(GameStatData statData, string stringValue)
  {
    this.statValue = stringValue;
    this.localizeStringEvent.StringReference = statData.stringKey;
  }

  public void SetText(string text) => this.textElement.text = text.Replace("{0}", "<#fff>" + this.statValue);
}
﻿// Decompiled with JetBrains decompiler
// Type: StatNumberDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class StatNumberDisplay : MonoBehaviour
{
  [SerializeField]
  public bool disableIfZero = true;
  [SerializeField]
  public string statName = "damageDealt";
  [SerializeField]
  public string statKey = "basic";
  [SerializeField]
  public TMP_Text text;

  public void OnEnable()
  {
    int num = OverallStatsSystem.Get().Get(this.statName, this.statKey, 0);
    if (this.disableIfZero && num <= 0)
      this.gameObject.SetActive(false);
    else
      this.text.text = num.ToString();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatsPanel
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;

public class StatsPanel : MonoBehaviour
{
  [SerializeField]
  public TMP_Text titleElement;
  [SerializeField]
  public TMP_Text subtitleElement;
  [SerializeField]
  public Transform statsGroup;
  [SerializeField]
  public StatDisplay statPrefab;
  [SerializeField]
  public int maxStats = 6;
  [SerializeField]
  public GameStatData[] stats;

  public void Awake()
  {
    this.titleElement.text = References.LeaderData.title;
    this.subtitleElement.gameObject.SetActive(false);
    CampaignStats runStats = StatsSystem.Get();
    ((IList<GameStatData>) this.stats).Shuffle<GameStatData>();
    foreach (StatsPanel.Stat stat in (IEnumerable<StatsPanel.Stat>) ((IEnumerable<GameStatData>) this.stats).Select<GameStatData, StatsPanel.Stat>((Func<GameStatData, StatsPanel.Stat>) (s => new StatsPanel.Stat(s, runStats))).Where<StatsPanel.Stat>((Func<StatsPanel.Stat, bool>) (s => (double) s.value > 0.0)).OrderByDescending<StatsPanel.Stat, float>((Func<StatsPanel.Stat, float>) (s => UnityEngine.Random.Range(0.0f, s.priority))).Take<StatsPanel.Stat>(this.maxStats).OrderByDescending<StatsPanel.Stat, float>((Func<StatsPanel.Stat, float>) (s => s.statData.displayOrder)))
    {
      StatDisplay statDisplay = UnityEngine.Object.Instantiate<StatDisplay>(this.statPrefab, this.statsGroup);
      statDisplay.gameObject.SetActive(true);
      statDisplay.Assign(stat.statData, stat.stringValue);
    }
  }

  public struct Stat
  {
    public readonly GameStatData statData;
    public readonly float value;
    public readonly string stringValue;
    public readonly float priority;

    public Stat(GameStatData statData, CampaignStats runStats)
    {
      this.statData = statData;
      this.value = statData.GetValue(runStats);
      this.stringValue = statData.GetStringValue(runStats, this.value);
      this.priority = statData.GetPriority(this.value);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatsPanelSplatters
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class StatsPanelSplatters : MonoBehaviour
{
  [SerializeField]
  public Sprite[] splatterSprites;
  [SerializeField]
  public ImageSprite[] splatters;
  public static readonly StatsPanelSplatters.Profile[] profiles = new StatsPanelSplatters.Profile[8]
  {
    new StatsPanelSplatters.Profile(1f, 1f, 1f, 1f, 0.0f, -2f),
    new StatsPanelSplatters.Profile(1f, 0.5f, 1f, 0.5f, 0.0f, -2f),
    new StatsPanelSplatters.Profile(1f, 0.0f, 1f, 0.0f, -2f, 0.0f),
    new StatsPanelSplatters.Profile(0.0f, 1f, 0.0f, 1f, 2f, 0.0f),
    new StatsPanelSplatters.Profile(0.0f, 0.5f, 0.0f, 0.5f, 0.0f, 2f),
    new StatsPanelSplatters.Profile(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 2f),
    new StatsPanelSplatters.Profile(0.5f, 1f, 0.5f, 1f, 2f, 0.0f),
    new StatsPanelSplatters.Profile(0.5f, 0.0f, 0.5f, 0.0f, -2f, 0.0f)
  };
  public readonly List<Sprite> spritePool = new List<Sprite>();
  public readonly List<StatsPanelSplatters.Profile> profilePool = new List<StatsPanelSplatters.Profile>();

  public void OnEnable()
  {
    List<Color> list = new List<Color>();
    SplatterPersistenceSystem objectOfType = UnityEngine.Object.FindObjectOfType<SplatterPersistenceSystem>();
    if (objectOfType.storedSplatters != null && objectOfType.storedSplatters.Count > 0)
    {
      foreach (SplatterPersistenceSystem.SplatterData[] source in objectOfType.storedSplatters.Values)
        list.AddRange(((IEnumerable<SplatterPersistenceSystem.SplatterData>) source).Select<SplatterPersistenceSystem.SplatterData, Color>((Func<SplatterPersistenceSystem.SplatterData, Color>) (a => a.color)));
    }
    int num = Mathf.Min(this.splatters.Length, list.Count);
    for (int index = 0; index < num; ++index)
    {
      ImageSprite splatter = this.splatters[index];
      StatsPanelSplatters.Profile profile1 = this.PullProfile();
      Sprite sprite1 = this.PullSprite();
      StatsPanelSplatters.Profile profile2 = profile1;
      Sprite sprite2 = sprite1;
      Color color = list.RandomItem<Color>();
      StatsPanelSplatters.Set(splatter, profile2, sprite2, color);
    }
  }

  public StatsPanelSplatters.Profile PullProfile()
  {
    if (this.profilePool.Count <= 0)
      this.profilePool.AddRange((IEnumerable<StatsPanelSplatters.Profile>) StatsPanelSplatters.profiles);
    return this.profilePool.TakeRandom<StatsPanelSplatters.Profile>();
  }

  public Sprite PullSprite()
  {
    if (this.spritePool.Count <= 0)
      this.spritePool.AddRange((IEnumerable<Sprite>) this.splatterSprites);
    return this.spritePool.TakeRandom<Sprite>();
  }

  public static void Set(
    ImageSprite image,
    StatsPanelSplatters.Profile profile,
    Sprite sprite,
    Color color)
  {
    image.gameObject.SetActive(true);
    image.SetSprite(sprite);
    image.color = color;
    if (!(image.transform is RectTransform transform))
      return;
    transform.anchorMax = profile.anchorMax;
    transform.anchorMin = profile.anchorMin;
    transform.anchoredPosition = new Vector2(UnityEngine.Random.Range(0.0f, profile.moveRange.x), UnityEngine.Random.Range(0.0f, profile.moveRange.y));
    transform.localEulerAngles = new Vector3(0.0f, 0.0f, UnityEngine.Random.Range(0.0f, 360f));
  }

  public struct Profile
  {
    public readonly Vector2 anchorMin;
    public readonly Vector2 anchorMax;
    public readonly Vector2 moveRange;

    public Profile(float minX, float minY, float maxX, float maxY, float moveX, float moveY)
    {
      this.anchorMin = new Vector2(minX, minY);
      this.anchorMax = new Vector2(maxX, maxY);
      this.moveRange = new Vector2(moveX, moveY);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatsSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public class StatsSaveData
{
  public float playTime;
  public int gamesPlayed;
  public int wins;
  public int trueWins;
  public int cardsPlayed;
  [Header("Combat")]
  public int kills;
  public int bossesKilled;
  public int damageDealt;
  public int damageTaken;
  public int highestDamageHit;
  public int battlesWon;
  public int goldGained;
  public int goldSpent;
  public float quickestBattleWin;
  [Header("Score")]
  public int bestScore;
  public float bestTime;
}
﻿// Decompiled with JetBrains decompiler
// Type: StatsSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class StatsSystem : GameSystem
{
  public static StatsSystem instance;
  [SerializeField]
  public CampaignStats stats;
  public int goldThisBattle;
  public int sacrificedThisBattle;
  public bool kingMokoExists;
  public bool campaignEnded;

  public static CampaignStats Get() => StatsSystem.instance.Stats;

  public static void Set(CampaignStats stats)
  {
    if (stats == null)
      stats = new CampaignStats();
    StatsSystem.instance.stats = stats;
  }

  public CampaignStats Stats => this.stats;

  public void OnEnable()
  {
    StatsSystem.instance = this;
    global::Events.OnCampaignEnd += new UnityAction<Campaign.Result, CampaignStats, PlayerData>(this.CampaignEnd);
    global::Events.OnCampaignSaved += new UnityAction(this.CampaignSaved);
    global::Events.OnEntityHit += new UnityAction<Hit>(this.EntityHit);
    global::Events.OnEntityPostHit += new UnityAction<Hit>(this.PostEntityHit);
    global::Events.OnStatusEffectApplied += new UnityAction<StatusEffectApply>(this.StatusApplied);
    global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnEntityOffered += new UnityAction<Entity>(this.EntityOffered);
    global::Events.OnEntityChosen += new UnityAction<Entity>(this.EntityChosen);
    global::Events.OnEntityFlee += new UnityAction<Entity>(this.EntityFlee);
    global::Events.OnDiscard += new UnityAction<Entity>(this.EntityDiscarded);
    global::Events.OnEntitySummoned += new UnityAction<Entity, Entity>(this.EntitySummoned);
    global::Events.OnEntityTriggered += new global::Events.UnityActionRef<Trigger>(this.EntityTriggered);
    global::Events.OnCardInjured += new UnityAction<CardData>(this.CardInjured);
    global::Events.OnBattleStart += new UnityAction(this.BattleStart);
    global::Events.OnBattleEnd += new UnityAction(this.BattleEnd);
    global::Events.OnDropGold += new UnityAction<int, string, Character, Vector3>(this.DropGold);
    global::Events.OnSpendGold += new UnityAction<int>(this.SpendGold);
    global::Events.OnShopItemPurchase += new UnityAction<ShopItem>(this.ShopItemPurchase);
    global::Events.OnKillCombo += new UnityAction<int>(this.KillCombo);
    global::Events.OnRedrawBellHit += new UnityAction<RedrawBellSystem>(this.RedrawBellHit);
    global::Events.OnBattleTurnStart += new UnityAction<int>(this.BattleTurnStart);
    global::Events.OnRename += new UnityAction<Entity, string>(this.Rename);
    global::Events.OnMuncherFeed += new UnityAction<Entity>(this.MuncherFeed);
    global::Events.OnUpgradeGained += new UnityAction<CardUpgradeData>(this.UpgradeGained);
    global::Events.OnUpgradeAssign += new UnityAction<Entity, CardUpgradeData>(this.UpgradeAssigned);
  }

  public void OnDisable()
  {
    global::Events.OnCampaignEnd -= new UnityAction<Campaign.Result, CampaignStats, PlayerData>(this.CampaignEnd);
    global::Events.OnCampaignSaved -= new UnityAction(this.CampaignSaved);
    global::Events.OnEntityHit -= new UnityAction<Hit>(this.EntityHit);
    global::Events.OnEntityPostHit -= new UnityAction<Hit>(this.PostEntityHit);
    global::Events.OnStatusEffectApplied -= new UnityAction<StatusEffectApply>(this.StatusApplied);
    global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);
    global::Events.OnEntityOffered -= new UnityAction<Entity>(this.EntityOffered);
    global::Events.OnEntityChosen -= new UnityAction<Entity>(this.EntityChosen);
    global::Events.OnEntityFlee -= new UnityAction<Entity>(this.EntityFlee);
    global::Events.OnDiscard -= new UnityAction<Entity>(this.EntityDiscarded);
    global::Events.OnEntitySummoned -= new UnityAction<Entity, Entity>(this.EntitySummoned);
    global::Events.OnEntityTriggered -= new global::Events.UnityActionRef<Trigger>(this.EntityTriggered);
    global::Events.OnCardInjured -= new UnityAction<CardData>(this.CardInjured);
    global::Events.OnBattleStart -= new UnityAction(this.BattleStart);
    global::Events.OnBattleEnd -= new UnityAction(this.BattleEnd);
    global::Events.OnDropGold -= new UnityAction<int, string, Character, Vector3>(this.DropGold);
    global::Events.OnSpendGold -= new UnityAction<int>(this.SpendGold);
    global::Events.OnShopItemPurchase -= new UnityAction<ShopItem>(this.ShopItemPurchase);
    global::Events.OnKillCombo -= new UnityAction<int>(this.KillCombo);
    global::Events.OnRedrawBellHit -= new UnityAction<RedrawBellSystem>(this.RedrawBellHit);
    global::Events.OnBattleTurnStart -= new UnityAction<int>(this.BattleTurnStart);
    global::Events.OnRename -= new UnityAction<Entity, string>(this.Rename);
    global::Events.OnMuncherFeed -= new UnityAction<Entity>(this.MuncherFeed);
    global::Events.OnUpgradeGained -= new UnityAction<CardUpgradeData>(this.UpgradeGained);
    global::Events.OnUpgradeAssign -= new UnityAction<Entity, CardUpgradeData>(this.UpgradeAssigned);
  }

  public void Update()
  {
    if (this.campaignEnded)
      return;
    this.stats.time += Time.deltaTime;
    if ((double) this.stats.time < 3600.0)
      return;
    ++this.stats.hours;
    this.stats.time -= 3600f;
  }

  public void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData) => this.campaignEnded = true;

  public void CampaignSaved()
  {
    if (!Campaign.Data.GameMode.doSave)
      return;
    SaveSystem.SaveCampaignData<CampaignStats>(Campaign.Data.GameMode, "stats", this.stats);
  }

  public void EntityHit(Hit hit)
  {
    bool flag = (UnityEngine.Object) hit.target.owner == (UnityEngine.Object) References.Player;
    if (!hit.Offensive)
      return;
    if ((UnityEngine.Object) hit.owner == (UnityEngine.Object) References.Player)
    {
      if (hit.damage > 0)
      {
        this.Stats.Add("damageDealt", hit.damageType, hit.damage);
        this.Stats.Max("highestDamageDealt", hit.damageType, hit.damage);
        if (flag)
          this.Stats.Add("friendlyDamageDealt", hit.target.data.name, hit.damage);
      }
      this.Stats.Add("cardsHit", hit.target.data.name, 1);
    }
    if (!flag)
      return;
    this.Stats.Add("hitsTakenByCardType", hit.target.data.cardType.name, 1);
    if (hit.damage > 0)
      this.Stats.Add("damageTaken", hit.damageType, hit.damage);
    if (hit.damageBlocked <= 0)
      return;
    this.Stats.Add("damageBlocked", hit.damageType, hit.damageBlocked);
  }

  public void PostEntityHit(Hit hit)
  {
    if (hit.dodged || hit.damageDealt >= 0 || !((UnityEngine.Object) hit.target.owner == (UnityEngine.Object) References.Player) || !((UnityEngine.Object) hit.owner == (UnityEngine.Object) References.Player))
      return;
    this.Stats.Add("amountHealedTo", hit.target.data.name, -hit.damageDealt);
    if (!(bool) (UnityEngine.Object) hit.attacker || !(bool) (UnityEngine.Object) hit.attacker.data)
      return;
    this.Stats.Add("amountHealedFrom", hit.attacker.data.name, -hit.damageDealt);
  }

  public void StatusApplied(StatusEffectApply apply)
  {
    if (!(bool) (UnityEngine.Object) apply.applier)
      return;
    string type = (bool) (UnityEngine.Object) apply.effectData ? apply.effectData.type : (string) null;
    if (type.IsNullOrWhitespace() || !((UnityEngine.Object) apply.applier.owner == (UnityEngine.Object) References.Player))
      return;
    this.Stats.Add("statusesApplied", type, apply.count);
    StatusEffectData status = apply.target.FindStatus(apply.effectData);
    if (!(bool) (UnityEngine.Object) status)
      return;
    this.Stats.Max("highestStatusEffect", type, status.count);
  }

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    if ((UnityEngine.Object) entity.owner == (UnityEngine.Object) References.Player)
    {
      this.Stats.Add("friendliesDied", entity.data.name, 1);
      if (!DeathSystem.KilledByOwnTeam(entity))
        return;
      this.Stats.Add("friendliesSacrificed", entity.data.name, 1);
      ++this.sacrificedThisBattle;
      this.Stats.Max("highestSacrificesInBattle", this.sacrificedThisBattle);
    }
    else
    {
      this.Stats.Add("enemiesKilled", entity.data.name, 1);
      Hit lastHit = entity.lastHit;
      if (lastHit == null)
        return;
      Entity attacker = lastHit.attacker;
      if (attacker == null)
        return;
      Character owner = attacker.owner;
      if (owner == null)
        return;
      CardData data = attacker.data;
      if (data == null)
        return;
      if (entity.data.name == "FinalBoss")
        this.Stats.Add("finalBossKills", data.name, 1);
      if (!((UnityEngine.Object) owner == (UnityEngine.Object) References.Player))
        return;
      this.Stats.Add("kills", data.name, 1);
      this.Stats.Add("enemiesKilledByCardType", data.cardType.name, 1);
      this.Stats.Add("enemiesKilledDamageType", entity.lastHit.damageType, 1);
      if (entity.lastHit.trigger != null)
        this.Stats.Add("enemiesKilledTriggerType", entity.lastHit.trigger.type, 1);
      if (entity.data.cardType.name == "Boss")
        this.Stats.Add("bossesKilled", entity.data.name, 1);
      if (entity.data.cardType.miniboss)
        this.Stats.Add("minibossesKilledByCardType", data.cardType.name, 1);
      if (!(bool) (UnityEngine.Object) entity.statusEffects.Find((Predicate<StatusEffectData>) (a => a.type == "demonize")))
        return;
      this.Stats.Add("demonizedEnemiesKilled", data.name, 1);
    }
  }

  public void EntityOffered(Entity entity) => this.Stats.Add("cardsOffered", entity.data.name, 1);

  public void EntityChosen(Entity entity)
  {
    this.Stats.Add("cardsChosen", entity.data.name, 1);
    this.Stats.Add("cardTypesChosen", entity.data.cardType.name, 1);
  }

  public void EntityFlee(Entity entity)
  {
    if (!((UnityEngine.Object) entity.owner != (UnityEngine.Object) References.Player))
      return;
    this.Stats.Add("enemiesEscaped", entity.data.name, 1);
  }

  public void EntityDiscarded(Entity entity)
  {
    if (!((UnityEngine.Object) entity.owner == (UnityEngine.Object) References.Player))
      return;
    this.Stats.Add("friendliesRecalled", entity.data.name, 1);
  }

  public void EntitySummoned(Entity entity, Entity summonedBy)
  {
    if (!entity.data.cardType.unit)
      return;
    this.Stats.Add("cardsSummoned", entity.data.name, 1);
  }

  public void EntityTriggered(ref Trigger trigger)
  {
    if ((UnityEngine.Object) trigger.entity.owner == (UnityEngine.Object) References.Player && !trigger.type.IsNullOrWhitespace())
      this.Stats.Add("totalTriggers", trigger.type, 1);
    this.Stats.Add("cardsTriggered", trigger.entity.data.name, 1);
  }

  public void CardInjured(CardData cardData) => this.Stats.Add("friendliesInjured", cardData.name, 1);

  public void BattleStart()
  {
    this.goldThisBattle = 0;
    this.sacrificedThisBattle = 0;
    this.kingMokoExists = (bool) (UnityEngine.Object) Battle.GetCards(References.Battle.enemy).FirstOrDefault<Entity>((Func<Entity, bool>) (a => a.data.cardType.miniboss && a.data.name == "MonkeyKing"));
  }

  public void BattleEnd()
  {
    string battleName = StatsSystem.GetBattleName();
    if ((UnityEngine.Object) References.Battle.winner == (UnityEngine.Object) References.Player)
    {
      this.Stats.Add("battlesWon", battleName, 1);
      if (Battle.GetCardsOnBoard(References.Battle.player).Count == 1)
        this.Stats.Add("winBattleWithOnlyLeaderRemaining", 1);
      if (this.kingMokoExists && this.Stats.Get("cardsTriggered", "MonkeyKing", 0) > 0)
        this.Stats.Add("winBattleSurviveKingMokoAttack", 1);
    }
    else
      this.Stats.Add("battlesLost", battleName, 1);
    this.Stats.Max("highestGoldFromBattle", battleName, this.goldThisBattle);
  }

  public void DropGold(int amount, string source, Character owner, Vector3 position)
  {
    this.Stats.Add("goldGained", source, amount);
    this.goldThisBattle += amount;
  }

  public void SpendGold(int amount) => this.Stats.Add("goldSpent", amount);

  public void ShopItemPurchase(ShopItem item)
  {
    if ((double) item.priceFactor < 1.0)
      this.Stats.Add("discountsBought", 1);
    string key = (string) null;
    if (item.GetComponent<CharmMachine>() != null || item.GetComponent<CardCharm>() != null)
      key = "charm";
    else if (item.GetComponent<CrownHolderShop>() != null)
      key = "crown";
    else if (item.GetComponent<Card>() != null)
      key = "card";
    int id = Campaign.FindCharacterNode(References.Player).id;
    if (this.Stats.Get("preShopId", -1) != id)
    {
      this.Stats.Set("preShopId", id);
      this.Stats.Delete("boughtInSingleShop");
      this.Stats.Set("boughtInSingleShop", key, 1);
    }
    else
      this.Stats.Add("boughtInSingleShop", key, 1);
    this.Stats.Add("shopItemsBought", key, 1);
  }

  public void KillCombo(int combo) => this.Stats.Max("highestKillCombo", combo);

  public void RedrawBellHit(RedrawBellSystem redrawBellSystem) => this.Stats.Add("redrawBellHits", 1);

  public void BattleTurnStart(int turnCount) => this.Stats.Add("turnsTaken", 1);

  public void Rename(Entity entity, string newName)
  {
    this.Stats.Add("renames", newName, 1);
    this.Stats.Add("bestRename", newName, PettyRandom.Range(1, 1000));
  }

  public void MuncherFeed(Entity entity)
  {
    this.Stats.Add("cardsMunched", entity.data.name, 1);
    if (entity.data.traits == null)
      return;
    foreach (CardData.TraitStacks trait in entity.data.traits)
    {
      if (trait.data.name == "Consume")
        this.Stats.Add("consumeCardsMunched", 1);
    }
  }

  public void UpgradeGained(CardUpgradeData upgradeData)
  {
    switch (upgradeData.type)
    {
      case CardUpgradeData.Type.Charm:
        this.Stats.Add("charmsGained", upgradeData.name, 1);
        break;
      case CardUpgradeData.Type.Crown:
        this.Stats.Add("crownsGained", upgradeData.name, 1);
        break;
    }
  }

  public void UpgradeAssigned(Entity entity, CardUpgradeData upgradeData)
  {
    if (upgradeData.type != CardUpgradeData.Type.Charm)
      return;
    this.Stats.Add("charmsAssigned", upgradeData.name, 1);
    this.Stats.Add("charmsAssignedTo", entity.data.name, 1);
  }

  public static string GetBattleName()
  {
    object obj;
    return Campaign.FindCharacterNode(References.Player).data.TryGetValue("battle", out obj) && obj is string str ? str : (string) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public abstract class StatusEffect : ScriptableObject
{
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectAffectAllXApplied
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Affect All X Applied", fileName = "Affect All X Applied")]
public class StatusEffectAffectAllXApplied : StatusEffectData
{
  [SerializeField]
  public StatusEffectData effectToAffect;
  [SerializeField]
  public bool setToSpecificValue;
  [SerializeField]
  [ShowIf("setToSpecificValue")]
  public int specificValue;
  [SerializeField]
  [HideIf("setToSpecificValue")]
  public int add;
  [SerializeField]
  [HideIf("setToSpecificValue")]
  public float multiplyBy = 2f;
  [SerializeField]
  public bool targetCanBeFriendly = true;
  [SerializeField]
  public bool targetCanBeEnemy = true;
  [SerializeField]
  public bool applierCanBeFriendly = true;
  [SerializeField]
  public bool applierCanBeEnemy = true;

  public override bool RunApplyStatusEvent(StatusEffectApply apply)
  {
    if ((Object) apply?.effectData != (Object) null && apply.effectData.type == this.effectToAffect.type && apply.count > 0 && this.CheckTeamOfTarget(apply.target) && this.CheckTeamOfApplier(apply.applier))
    {
      if (this.setToSpecificValue)
      {
        apply.count = this.specificValue;
      }
      else
      {
        apply.count += this.add * this.GetAmount();
        apply.count = Mathf.CeilToInt((float) apply.count * this.multiplyBy);
      }
    }
    return false;
  }

  public bool CheckTeamOfTarget(Entity target)
  {
    if (this.targetCanBeFriendly && (Object) target.owner == (Object) this.target.owner)
      return true;
    return this.targetCanBeEnemy && (Object) target.owner != (Object) this.target.owner;
  }

  public bool CheckTeamOfApplier(Entity applier)
  {
    if (this.applierCanBeFriendly && (Object) applier.owner == (Object) this.target.owner)
      return true;
    return this.applierCanBeEnemy && (Object) applier.owner != (Object) this.target.owner;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApply
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class StatusEffectApply
{
  public Entity applier;
  public Entity target;
  public StatusEffectData effectData;
  public int count;

  public StatusEffectApply(Entity applier, Entity target, StatusEffectData effectData, int count)
  {
    this.applier = applier;
    this.target = target;
    this.effectData = effectData;
    this.count = count;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyToSummon
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Traits/Apply To Summon", fileName = "Apply To Summon")]
public class StatusEffectApplyToSummon : StatusEffectData
{
  [SerializeField]
  public StatusEffectData effectToApply;

  public override void Init() => global::Events.OnEntitySummoned += new UnityAction<Entity, Entity>(this.EntitySummoned);

  public void OnDestroy() => global::Events.OnEntitySummoned -= new UnityAction<Entity, Entity>(this.EntitySummoned);

  public void EntitySummoned(Entity entity, Entity summonedBy)
  {
    if ((long) summonedBy.data.id != (long) this.target.data.id)
      return;
    int amount = this.GetAmount();
    if (amount <= 0)
      return;
    ActionApplyStatus action = new ActionApplyStatus(entity, summonedBy, this.effectToApply, amount);
    action.fixedPosition = true;
    ActionQueue.Stack((PlayAction) action);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

public abstract class StatusEffectApplyX : StatusEffectData
{
  [Header("Status Effect To Apply")]
  public bool dealDamage;
  [HideIf("dealDamage")]
  public StatusEffectData effectToApply;
  public TargetConstraint[] applyConstraints;
  public bool applyEqualAmount;
  [ShowIf("applyEqualAmount")]
  [SerializeField]
  public ScriptableAmount contextEqualAmount;
  [ShowIf("applyEqualAmount")]
  [SerializeField]
  public float equalAmountBonusMult;
  [HideIf("applyEqualAmount")]
  [SerializeField]
  public ScriptableAmount scriptableAmount;
  [Header("Who/What To Apply To")]
  public StatusEffectApplyX.ApplyToFlags applyToFlags;
  public bool applyInReverseOrder;
  public bool canRetaliate;
  public bool countsAsHit;
  public bool waitForAnimationEnd;
  public bool waitForApplyToAnimationEnd;
  public bool queue;
  public bool separateActions;
  public bool doPing = true;
  public bool targetMustBeAlive = true;
  public float pauseAfter;
  [SerializeField]
  public NoTargetType noTargetType;
  [SerializeField]
  public string[] noTargetTypeArgs;
  public ActionEffectApply action;

  public override bool CanTrigger() => base.CanTrigger() && this.dealDamage || (bool) (UnityEngine.Object) this.effectToApply;

  public virtual int GetAmount(Entity entity, bool equalAmount = false, int equalTo = 0)
  {
    if (!(bool) (UnityEngine.Object) this.target || this.TargetSilenced())
      return 0;
    if ((bool) (UnityEngine.Object) this.scriptableAmount)
      return this.scriptableAmount.Get(entity);
    return !equalAmount ? this.GetAmount() : equalTo;
  }

  public virtual bool TargetSilenced() => this.target.silenced;

  public bool AppliesTo(StatusEffectApplyX.ApplyToFlags applyTo) => (this.applyToFlags & applyTo) != 0;

  public IEnumerator Run(List<Entity> targets, int amount = 0)
  {
    StatusEffectApplyX effect = this;
    if ((bool) (UnityEngine.Object) effect.target && effect.CanTrigger())
    {
      for (int index = targets.Count - 1; index >= 0; --index)
      {
        Entity target = targets[index];
        if (!effect.CanAffect(target))
          targets.RemoveAt(index);
      }
      foreach (TargetConstraint applyConstraint in effect.applyConstraints)
      {
        for (int index = targets.Count - 1; index >= 0; --index)
        {
          Entity target = targets[index];
          if (!applyConstraint.Check(target))
            targets.RemoveAt(index);
        }
      }
      if (targets.Count > 0)
      {
        int amount1 = effect.GetAmount(effect.target, effect.applyEqualAmount, Mathf.RoundToInt((float) amount * (1f + effect.equalAmountBonusMult)));
        if (!effect.TargetSilenced() && (amount1 > 0 || effect.CheckMultipleEffectsForUnboostable()))
        {
          if (effect.queue && effect.target.IsAliveAndExists())
          {
            bool flag = false;
            if (effect.effectToApply.CanStackActions)
            {
              ActionEffectApply action = effect.action;
              if (action != null && !action.running)
              {
                effect.action.Stack(targets, amount1);
                flag = true;
              }
            }
            if (!flag)
            {
              StatusEffectApplyX statusEffectApplyX = effect;
              ActionEffectApply actionEffectApply = new ActionEffectApply(effect, targets, amount1);
              actionEffectApply.note = effect.name;
              statusEffectApplyX.action = actionEffectApply;
              ActionQueue.Stack((PlayAction) effect.action, true);
            }
          }
          else
            yield return (object) effect.Sequence(targets, amount1);
        }
      }
      else if (effect.noTargetType != NoTargetType.None && NoTargetTextSystem.Exists())
        yield return (object) NoTargetTextSystem.Run(effect.target, effect.noTargetType, (object[]) effect.noTargetTypeArgs);
    }
  }

  public bool CheckMultipleEffectsForUnboostable()
  {
    if (this.effectToApply is StatusEffectInstantMultiple effectToApply)
    {
      foreach (StatusEffectData effect in effectToApply.effects)
      {
        if (!effect.canBeBoosted)
          return true;
      }
    }
    return false;
  }

  public IEnumerator Sequence(List<Entity> targets, int amount)
  {
    StatusEffectApplyX statusEffectApplyX = this;
    if ((bool) (UnityEngine.Object) statusEffectApplyX.target && (statusEffectApplyX.target.alive || !statusEffectApplyX.targetMustBeAlive))
    {
      if (statusEffectApplyX.waitForAnimationEnd)
        yield return (object) Sequences.WaitForAnimationEnd(statusEffectApplyX.target);
      if (statusEffectApplyX.waitForApplyToAnimationEnd)
      {
        foreach (Entity target in targets)
          yield return (object) Sequences.WaitForAnimationEnd(target);
      }
      if (statusEffectApplyX.separateActions)
      {
        if (statusEffectApplyX.queue)
        {
          foreach (Entity t in targets.AsEnumerable<Entity>().Reverse<Entity>())
          {
            ActionSequence action = new ActionSequence(statusEffectApplyX.SequenceSingle(t, amount));
            action.note = statusEffectApplyX.name + " - " + t.name;
            ActionQueue.Stack((PlayAction) action);
          }
        }
        else
        {
          foreach (Entity t in targets.AsEnumerable<Entity>())
            yield return (object) statusEffectApplyX.SequenceSingle(t, amount);
        }
      }
      else
      {
        Routine.Clump clump = new Routine.Clump();
        if (statusEffectApplyX.doPing && (bool) (UnityEngine.Object) statusEffectApplyX.target && (bool) (UnityEngine.Object) statusEffectApplyX.target.curveAnimator)
        {
          double num = (double) statusEffectApplyX.target.curveAnimator.Ping();
          clump.Add(Sequences.Wait(0.13f));
        }
        foreach (Entity target in targets.Where<Entity>((Func<Entity, bool>) (t => (bool) (UnityEngine.Object) t)))
        {
          int damage = statusEffectApplyX.dealDamage ? amount : 0;
          Hit hit = new Hit(statusEffectApplyX.target, target, damage)
          {
            canRetaliate = statusEffectApplyX.canRetaliate,
            countsAsHit = statusEffectApplyX.countsAsHit
          };
          if (!statusEffectApplyX.dealDamage)
            hit.AddStatusEffect(statusEffectApplyX.effectToApply, amount);
          clump.Add(hit.Process());
        }
        yield return (object) clump.WaitForEnd();
      }
      if ((double) statusEffectApplyX.pauseAfter > 0.0)
        yield return (object) Sequences.Wait(statusEffectApplyX.pauseAfter);
    }
  }

  public IEnumerator SequenceSingle(Entity t, int amount)
  {
    StatusEffectApplyX statusEffectApplyX = this;
    if ((bool) (UnityEngine.Object) t && statusEffectApplyX.CheckConstraints(t))
    {
      Routine.Clump clump = new Routine.Clump();
      if (statusEffectApplyX.doPing && (bool) (UnityEngine.Object) statusEffectApplyX.target && (bool) (UnityEngine.Object) statusEffectApplyX.target.curveAnimator)
      {
        double num = (double) statusEffectApplyX.target.curveAnimator.Ping();
        clump.Add(Sequences.Wait(0.13f));
      }
      Hit hit = new Hit(statusEffectApplyX.target, t, 0)
      {
        canRetaliate = statusEffectApplyX.canRetaliate,
        countsAsHit = statusEffectApplyX.countsAsHit
      };
      hit.AddStatusEffect(statusEffectApplyX.effectToApply, amount);
      clump.Add(hit.Process());
      yield return (object) clump.WaitForEnd();
      if (statusEffectApplyX.waitForAnimationEnd)
        yield return (object) Sequences.WaitForAnimationEnd(statusEffectApplyX.target);
    }
  }

  public List<Entity> GetTargets(
    Hit hit = null,
    CardContainer[] wasInRows = null,
    CardContainer[] wasInSlots = null,
    Entity[] targets = null)
  {
    List<Entity> targets1 = new List<Entity>();
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Self) && this.CanAffect(this.target))
      targets1.Add(this.target);
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Hand))
    {
      CardContainer handContainer = References.Player.handContainer;
      if (handContainer != null && handContainer.Count > 0)
      {
        targets1.AddRange(References.Player.handContainer.Where<Entity>((Func<Entity, bool>) (card => (UnityEngine.Object) card != (UnityEngine.Object) this.target && this.CheckConstraints(card))));
        goto label_18;
      }
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.RightCardInHand))
    {
      CardContainer handContainer = References.Player.handContainer;
      if (handContainer != null && handContainer.Count > 0)
        targets1.Add(References.Player.handContainer[0]);
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.RandomCardInHand))
    {
      CardContainer handContainer = References.Player.handContainer;
      if (handContainer != null && handContainer.Count > 0)
      {
        foreach (Entity entity in (IEnumerable<Entity>) References.Player.handContainer.InRandomOrder<Entity>())
        {
          if ((UnityEngine.Object) entity != (UnityEngine.Object) this.target && this.CheckConstraints(entity))
          {
            targets1.Add(entity);
            break;
          }
        }
      }
    }
label_18:
    this.AppliesTo(StatusEffectApplyX.ApplyToFlags.EnemyHand);
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Allies))
      targets1.AddRange((IEnumerable<Entity>) this.target.GetAllAllies());
    else if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.AlliesInRow))
    {
      if (Battle.IsOnBoard(this.target))
        targets1.AddRange((IEnumerable<Entity>) this.target.GetAlliesInRow());
      else if (wasInRows != null)
      {
        foreach (CardContainer wasInRow in wasInRows)
        {
          foreach (Entity entity in this.target.GetAlliesInRow(References.Battle.GetRowIndex(wasInRow)))
          {
            if (!targets1.Contains(entity))
              targets1.Add(entity);
          }
        }
      }
    }
    else
    {
      if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.FrontAlly))
      {
        List<int> source = new List<int>();
        if (wasInRows != null)
        {
          source.AddRange((IEnumerable<int>) References.Battle.GetRowIndices((IEnumerable<CardContainer>) wasInRows));
        }
        else
        {
          Entity entity = hit != null ? hit.target : this.target;
          List<int> intList = source;
          CardContainer[] containers = entity.containers;
          int[] collection = containers == null || containers.Length <= 0 ? References.Battle.GetRowIndices((IEnumerable<CardContainer>) entity.preContainers) : References.Battle.GetRowIndices((IEnumerable<CardContainer>) entity.containers);
          intList.AddRange((IEnumerable<int>) collection);
        }
        foreach (CardContainer cardContainer in source.Select<int, CardContainer>((Func<int, CardContainer>) (i => References.Battle.GetRow(this.target.owner, i))))
        {
          foreach (Entity entity in cardContainer)
          {
            if ((bool) (UnityEngine.Object) entity)
            {
              targets1.Add(entity);
              break;
            }
          }
        }
      }
      if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.BackAlly))
      {
        List<int> source = new List<int>();
        if (wasInRows != null)
          source.AddRange((IEnumerable<int>) References.Battle.GetRowIndices((IEnumerable<CardContainer>) wasInRows));
        else if (hit != null)
          source.AddRange((IEnumerable<int>) References.Battle.GetRowIndices(hit.target));
        else
          source.AddRange((IEnumerable<int>) References.Battle.GetRowIndices((IEnumerable<CardContainer>) this.target.containers));
        foreach (CardContainer cardContainer in source.Select<int, CardContainer>((Func<int, CardContainer>) (i => References.Battle.GetRow(this.target.owner, i))))
        {
          for (int index = cardContainer.Count - 1; index >= 0; --index)
          {
            Entity entity = cardContainer[index];
            if ((bool) (UnityEngine.Object) entity)
            {
              targets1.Add(entity);
              break;
            }
          }
        }
      }
      if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.AllyInFrontOf))
      {
        foreach (CardContainer cardContainer in wasInSlots ?? this.target.actualContainers.ToArray())
        {
          Entity entity = (Entity) null;
          if (cardContainer is CardSlot cardSlot && cardContainer.Group is CardSlotLane group)
          {
            for (int index = group.slots.IndexOf(cardSlot) - 1; index >= 0; --index)
            {
              entity = group.slots[index].GetTop();
              if ((bool) (UnityEngine.Object) entity)
                break;
            }
          }
          if ((bool) (UnityEngine.Object) entity)
          {
            targets1.Add(entity);
            break;
          }
        }
      }
      if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.AllyBehind))
      {
        foreach (CardContainer cardContainer in wasInSlots ?? this.target.actualContainers.ToArray())
        {
          Entity entity = (Entity) null;
          if (cardContainer is CardSlot cardSlot && cardContainer.Group is CardSlotLane group)
          {
            for (int index = group.slots.IndexOf(cardSlot) + 1; index < group.slots.Count; ++index)
            {
              entity = group.slots[index].GetTop();
              if ((bool) (UnityEngine.Object) entity)
                break;
            }
          }
          if ((bool) (UnityEngine.Object) entity)
          {
            targets1.Add(entity);
            break;
          }
        }
      }
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Enemies))
      targets1.AddRange((IEnumerable<Entity>) this.target.GetAllEnemies());
    else if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.EnemiesInRow))
    {
      foreach (CardContainer rowContainer in wasInRows ?? this.target.containers)
      {
        List<Entity> enemiesInRow = this.target.GetEnemiesInRow(References.Battle.GetRowIndex(rowContainer));
        if (enemiesInRow != null && enemiesInRow.Count > 0)
          targets1.AddRange((IEnumerable<Entity>) enemiesInRow);
      }
    }
    else if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.FrontEnemy))
    {
      foreach (CardContainer rowContainer in wasInRows ?? this.target.containers)
      {
        List<Entity> enemiesInRow = this.target.GetEnemiesInRow(References.Battle.GetRowIndex(rowContainer));
        if (enemiesInRow != null && enemiesInRow.Count > 0)
          targets1.Add(enemiesInRow[0]);
      }
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Applier) && (bool) (UnityEngine.Object) this.applier && this.CanAffect(this.applier))
      targets1.Add(this.applier);
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Attacker))
    {
      if (hit == null)
        hit = this.target.lastHit;
      if ((bool) (UnityEngine.Object) hit?.attacker && this.CanAffect(hit.attacker))
        targets1.Add(hit.attacker);
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Target))
    {
      if (targets != null)
      {
        targets1.AddRange(((IEnumerable<Entity>) targets).Where<Entity>(new Func<Entity, bool>(this.CanAffect)));
      }
      else
      {
        if (hit == null)
          hit = this.target.lastHit;
        if ((bool) (UnityEngine.Object) hit?.target && this.CanAffect(hit.target))
          targets1.Add(hit.target);
      }
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.RandomUnit))
    {
      List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(this.target.owner);
      cardsOnBoard.AddRange((IEnumerable<Entity>) Battle.GetCardsOnBoard(Battle.GetOpponent(this.target.owner)));
      cardsOnBoard.Remove(this.target);
      this.RemoveIneligible((IList<Entity>) cardsOnBoard);
      if (cardsOnBoard.Count > 0)
        targets1.Add(cardsOnBoard.RandomItem<Entity>());
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.RandomAlly))
    {
      List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(this.target.owner);
      cardsOnBoard.Remove(this.target);
      this.RemoveIneligible((IList<Entity>) cardsOnBoard);
      if (cardsOnBoard.Count > 0)
        targets1.Add(cardsOnBoard.RandomItem<Entity>());
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.RandomEnemy))
    {
      List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(Battle.GetOpponent(this.target.owner));
      this.RemoveIneligible((IList<Entity>) cardsOnBoard);
      if (cardsOnBoard.Count > 0)
        targets1.Add(cardsOnBoard.RandomItem<Entity>());
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.RandomAllyInRow))
    {
      List<Entity> list = new List<Entity>();
      foreach (CardContainer cardContainer in wasInRows ?? this.target.containers)
      {
        foreach (Entity entity in cardContainer)
        {
          if (!list.Contains(entity))
            list.Add(entity);
        }
      }
      this.RemoveIneligible((IList<Entity>) list);
      if (list.Count > 0)
        targets1.Add(list.RandomItem<Entity>());
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.RandomEnemyInRow))
    {
      List<Entity> list = new List<Entity>();
      foreach (CardContainer rowContainer in wasInRows ?? this.target.containers)
      {
        foreach (Entity entity in this.target.GetEnemiesInRow(References.Battle.GetRowIndex(rowContainer)))
        {
          if (!list.Contains(entity))
            list.Add(entity);
        }
      }
      this.RemoveIneligible((IList<Entity>) list);
      if (list.Count > 0)
        targets1.Add(list.RandomItem<Entity>());
    }
    if (this.applyInReverseOrder)
      targets1.Reverse();
    return targets1;
  }

  public void RemoveIneligible(IList<Entity> list)
  {
    for (int index = list.Count - 1; index >= 0; --index)
    {
      if (!this.CheckConstraints(list[index]))
        list.RemoveAt(index);
    }
  }

  public bool CanAffect(Entity entity) => !this.dealDamage ? this.effectToApply.CanPlayOn(entity) : entity.canBeHit;

  public bool CheckConstraints(Entity entity) => this.CanAffect(entity) && ((IEnumerable<TargetConstraint>) this.applyConstraints).All<TargetConstraint>((Func<TargetConstraint, bool>) (c => c.Check(entity)));

  [CompilerGenerated]
  public bool \u003CGetTargets\u003Eb__30_0(Entity card) => (UnityEngine.Object) card != (UnityEngine.Object) this.target && this.CheckConstraints(card);

  [CompilerGenerated]
  public CardContainer \u003CGetTargets\u003Eb__30_1(int i) => References.Battle.GetRow(this.target.owner, i);

  [CompilerGenerated]
  public CardContainer \u003CGetTargets\u003Eb__30_2(int i) => References.Battle.GetRow(this.target.owner, i);

  [Flags]
  public enum ApplyToFlags
  {
    None = 0,
    Self = 1,
    Hand = 2,
    EnemyHand = 4,
    Allies = 8,
    AlliesInRow = 16, // 0x00000010
    FrontAlly = 32, // 0x00000020
    BackAlly = 64, // 0x00000040
    AllyInFrontOf = 128, // 0x00000080
    AllyBehind = 256, // 0x00000100
    Enemies = 512, // 0x00000200
    EnemiesInRow = 1024, // 0x00000400
    FrontEnemy = 2048, // 0x00000800
    Attacker = 4096, // 0x00001000
    Target = 8192, // 0x00002000
    RandomAlly = 16384, // 0x00004000
    RandomEnemy = 32768, // 0x00008000
    RandomUnit = 65536, // 0x00010000
    Applier = 131072, // 0x00020000
    RightCardInHand = 262144, // 0x00040000
    RandomCardInHand = 524288, // 0x00080000
    RandomAllyInRow = 1048576, // 0x00100000
    RandomEnemyInRow = 2097152, // 0x00200000
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXEveryTurn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X Every Turn", fileName = "Apply X Every Turn")]
public class StatusEffectApplyXEveryTurn : StatusEffectApplyX
{
  [SerializeField]
  public StatusEffectApplyXEveryTurn.Mode mode;

  public override void Init()
  {
    this.OnTurn += new StatusEffectData.EffectEntityEventHandler(this.CheckTurn);
    this.OnTurnStart += new StatusEffectData.EffectEntityEventHandler(this.CheckTurnStart);
  }

  public override bool RunTurnEvent(Entity entity) => this.mode == StatusEffectApplyXEveryTurn.Mode.AfterTurn && this.target.enabled && (Object) entity == (Object) this.target && Battle.IsOnBoard(this.target);

  public IEnumerator CheckTurn(Entity entity) => this.Run(this.GetTargets());

  public override bool RunTurnStartEvent(Entity entity) => this.mode == StatusEffectApplyXEveryTurn.Mode.TurnStart && this.target.enabled && (Object) entity == (Object) this.target && Battle.IsOnBoard(this.target);

  public IEnumerator CheckTurnStart(Entity entity) => this.Run(this.GetTargets());

  public enum Mode
  {
    AfterTurn,
    TurnStart,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXInstant
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Instant Apply X", fileName = "Instant Apply X")]
public class StatusEffectApplyXInstant : StatusEffectApplyX
{
  public override bool Instant => true;

  public override int GetAmount(Entity entity, bool equalAmount = false, int equalTo = 0)
  {
    if ((bool) (Object) this.scriptableAmount)
      return this.scriptableAmount.Get(entity);
    return !equalAmount ? this.GetAmount() : equalTo;
  }

  public override int GetAmount() => this.count;

  public override bool TargetSilenced() => false;

  public override void Init() => this.OnBegin += new StatusEffectData.EffectEventHandler(this.Process);

  public IEnumerator Process()
  {
    StatusEffectApplyXInstant effectApplyXinstant = this;
    yield return (object) effectApplyXinstant.Run(effectApplyXinstant.GetTargets());
    yield return (object) effectApplyXinstant.Remove();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXOnCardPlayed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X On Card Played", fileName = "Apply X On Card Played")]
public class StatusEffectApplyXOnCardPlayed : StatusEffectApplyX
{
  public override void Init() => this.OnCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.Check);

  public static CardContainer[] GetWasInRows(Entity entity, IEnumerable<Entity> targets)
  {
    if (entity.data.playType != Card.PlayType.Play || !entity.NeedsTarget)
      return entity.containers;
    HashSet<CardContainer> list = new HashSet<CardContainer>();
    foreach (Entity target in targets)
    {
      if (target.containers != null && target.containers.Length != 0)
        list.AddRange<CardContainer>((IEnumerable<CardContainer>) target.containers);
      else
        list.AddRange<CardContainer>((IEnumerable<CardContainer>) target.preContainers);
    }
    return list.ToArray<CardContainer>();
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets) => this.target.enabled && (Object) entity == (Object) this.target;

  public IEnumerator Check(Entity entity, Entity[] targets) => this.Run(this.GetTargets(wasInRows: StatusEffectApplyXOnCardPlayed.GetWasInRows(entity, (IEnumerable<Entity>) targets), targets: targets));
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXOnHit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X On Hit", fileName = "Apply X On Hit")]
public class StatusEffectApplyXOnHit : StatusEffectApplyX
{
  [SerializeField]
  public bool postHit;
  [Header("Modify Damage")]
  [SerializeField]
  public int addDamageFactor;
  [SerializeField]
  public float multiplyDamageFactor = 1f;
  public readonly List<Hit> storedHit = new List<Hit>();

  public override void Init()
  {
    if (this.postHit)
      this.PostHit += new StatusEffectData.EffectHitEventHandler(this.CheckHit);
    else
      this.OnHit += new StatusEffectData.EffectHitEventHandler(this.CheckHit);
  }

  public override bool RunPreAttackEvent(Hit hit)
  {
    if ((Object) hit.attacker == (Object) this.target && this.target.alive && this.target.enabled && (bool) (Object) hit.target)
    {
      if (this.addDamageFactor != 0 || (double) this.multiplyDamageFactor != 1.0)
      {
        bool flag = true;
        foreach (TargetConstraint applyConstraint in this.applyConstraints)
        {
          if (!applyConstraint.Check(hit.target) && (!(applyConstraint is TargetConstraintHasStatus constraintHasStatus) || !constraintHasStatus.CheckWillApply(hit)))
          {
            flag = false;
            break;
          }
        }
        if (flag)
        {
          int amount = this.GetAmount();
          if (this.addDamageFactor != 0)
            hit.damage += amount * this.addDamageFactor;
          if ((double) this.multiplyDamageFactor != 1.0)
            hit.damage = Mathf.RoundToInt((float) hit.damage * this.multiplyDamageFactor);
        }
      }
      if (!hit.Offensive && (hit.damage > 0 || (bool) (Object) this.effectToApply && this.effectToApply.offensive))
        hit.FlagAsOffensive();
      this.storedHit.Add(hit);
    }
    return false;
  }

  public override bool RunPostHitEvent(Hit hit) => this.storedHit.Contains(hit) && hit.Offensive;

  public override bool RunHitEvent(Hit hit) => this.storedHit.Contains(hit) && hit.Offensive;

  public IEnumerator CheckHit(Hit hit)
  {
    StatusEffectApplyXOnHit effectApplyXonHit = this;
    if ((bool) (Object) effectApplyXonHit.effectToApply)
      yield return (object) effectApplyXonHit.Run(effectApplyXonHit.GetTargets(hit), hit.damage + hit.damageBlocked);
    effectApplyXonHit.storedHit.Remove(hit);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXOnKill
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X On Kill", fileName = "Apply X On Kill")]
public class StatusEffectApplyXOnKill : StatusEffectApplyX
{
  public override void Init() => this.OnEntityDestroyed += new StatusEffectData.EffectEntityDeathEventHandler(this.CheckDestroy);

  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType) => entity.lastHit != null && (Object) entity.lastHit.attacker == (Object) this.target;

  public IEnumerator CheckDestroy(Entity entity, DeathType deathType) => this.Run(this.GetTargets(entity.lastHit));
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXOnOverheal
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X On Overheal", fileName = "Apply X On Overheal")]
public class StatusEffectApplyXOnOverheal : StatusEffectApplyX
{
  public override void Init() => this.OnHit += new StatusEffectData.EffectHitEventHandler(this.Check);

  public override bool RunHitEvent(Hit hit) => (Object) hit.target == (Object) this.target && hit.damage < 0 && this.target.hp.current - hit.damage - this.target.hp.max > 0;

  public IEnumerator Check(Hit hit) => this.Run(this.GetTargets(hit), this.target.hp.current - hit.damage - this.target.hp.max);
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXOnTurn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X On Turn", fileName = "Apply X On Turn")]
public class StatusEffectApplyXOnTurn : StatusEffectApplyX
{
  [SerializeField]
  public bool trueOnTurn;
  public bool turnTaken;

  public override void Init()
  {
    this.OnCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.CheckCardPlay);
    this.OnTurn += new StatusEffectData.EffectEntityEventHandler(this.CheckTurn);
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (this.turnTaken || !this.target.enabled || !((Object) entity == (Object) this.target) || !Battle.IsOnBoard(this.target))
      return false;
    if (!this.trueOnTurn)
      return true;
    this.turnTaken = true;
    return false;
  }

  public IEnumerator CheckCardPlay(Entity entity, Entity[] targets) => this.Run(this.GetTargets());

  public override bool RunTurnEvent(Entity entity) => this.trueOnTurn && this.turnTaken && (Object) entity == (Object) this.target && Battle.IsOnBoard(this.target);

  public IEnumerator CheckTurn(Entity entity)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectApplyXOnTurn effectApplyXonTurn = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      effectApplyXonTurn.turnTaken = false;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) effectApplyXonTurn.Run(effectApplyXonTurn.GetTargets());
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXPostAttack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X Post Attack", fileName = "Apply X Post Attack")]
public class StatusEffectApplyXPostAttack : StatusEffectApplyX
{
  public override void Init() => this.PostAttack += new StatusEffectData.EffectHitEventHandler(this.CheckHit);

  public override bool RunPostAttackEvent(Hit hit) => this.target.enabled && (Object) hit.attacker == (Object) this.target && this.target.alive && Battle.IsOnBoard(this.target);

  public IEnumerator CheckHit(Hit hit)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectApplyXPostAttack applyXpostAttack = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) applyXpostAttack.Run(applyXpostAttack.GetTargets(hit));
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXPreTrigger
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X Pre Trigger", fileName = "Apply X Pre Trigger")]
public class StatusEffectApplyXPreTrigger : StatusEffectApplyX
{
  [SerializeField]
  public bool mustHaveTarget;
  [SerializeField]
  public bool oncePerTurn = true;
  public bool running;
  public bool hasRunThisTurn;
  public List<Entity> runAgainst;

  public override void Init() => this.PreTrigger += new StatusEffectData.EffectTriggerEventHandler(this.EntityPreTrigger);

  public override bool RunPreTriggerEvent(Trigger trigger) => this.CheckTrigger(trigger);

  public IEnumerator EntityPreTrigger(Trigger trigger)
  {
    StatusEffectApplyXPreTrigger applyXpreTrigger = this;
    if (applyXpreTrigger.oncePerTurn)
      applyXpreTrigger.hasRunThisTurn = true;
    applyXpreTrigger.running = true;
    yield return (object) applyXpreTrigger.Run(applyXpreTrigger.runAgainst);
    applyXpreTrigger.runAgainst = (List<Entity>) null;
    applyXpreTrigger.running = false;
  }

  public bool CheckTrigger(Trigger trigger)
  {
    if (this.hasRunThisTurn || this.running || !this.target.enabled || (Object) trigger.entity != (Object) this.target)
      return false;
    this.runAgainst = this.GetTargets();
    if (!this.mustHaveTarget || this.runAgainst != null && this.runAgainst.Count > 0)
      return true;
    trigger.nullified = true;
    return false;
  }

  public override bool RunTurnEndEvent(Entity entity)
  {
    if (this.hasRunThisTurn && (Object) entity == (Object) this.target)
      this.hasRunThisTurn = false;
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXPreTurn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X Pre Turn", fileName = "Apply X Pre Turn")]
public class StatusEffectApplyXPreTurn : StatusEffectApplyX
{
  [SerializeField]
  public bool mustHaveTarget;
  public bool running;
  public List<Entity> runAgainst;

  public override void Init()
  {
    if (this.queue)
    {
      global::Events.OnPreProcessTrigger += new UnityAction<Entity>(this.PreProcessTrigger);
    }
    else
    {
      global::Events.OnEntityTrigger += new global::Events.UnityActionRef<Trigger>(this.CheckTrigger);
      this.PreCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.CheckPreCardPlay);
    }
  }

  public void OnDestroy()
  {
    if (this.queue)
      global::Events.OnPreProcessTrigger -= new UnityAction<Entity>(this.PreProcessTrigger);
    else
      global::Events.OnEntityTrigger -= new global::Events.UnityActionRef<Trigger>(this.CheckTrigger);
  }

  public void PreProcessTrigger(Entity entity)
  {
    if (!((Object) entity == (Object) this.target) || this.running || !this.target.enabled)
      return;
    ActionQueue.Stack((PlayAction) new ActionSequence(this.Run(this.GetTargets())), true);
  }

  public void CheckTrigger(ref Trigger trigger)
  {
    if (this.running || !this.target.enabled || !((Object) trigger.entity == (Object) this.target))
      return;
    this.runAgainst = this.GetTargets();
    if (!this.mustHaveTarget || this.runAgainst != null && this.runAgainst.Count > 0)
      return;
    trigger.nullified = true;
  }

  public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (!this.running && this.target.enabled)
    {
      List<Entity> runAgainst = this.runAgainst;
      if (runAgainst != null && runAgainst.Count > 0)
        return (Object) entity == (Object) this.target;
    }
    return false;
  }

  public IEnumerator CheckPreCardPlay(Entity entity, Entity[] targets)
  {
    yield return (object) this.RunSequence(this.runAgainst);
  }

  public IEnumerator RunSequence(List<Entity> targets)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectApplyXPreTurn effectApplyXpreTurn = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      effectApplyXpreTurn.runAgainst = (List<Entity>) null;
      effectApplyXpreTurn.running = false;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    effectApplyXpreTurn.running = true;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) effectApplyXpreTurn.Run(targets);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXToFrontAllies
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X To Front Allies", fileName = "Apply X To Front Allies")]
public class StatusEffectApplyXToFrontAllies : StatusEffectApplyX
{
  public override void Init() => this.OnCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.Run);

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets) => (Object) entity == (Object) this.target;

  public IEnumerator Run(Entity entity, Entity[] targets)
  {
    StatusEffectApplyXToFrontAllies applyXtoFrontAllies = this;
    int a = applyXtoFrontAllies.GetAmount();
    List<Entity> toAffect = new List<Entity>();
    foreach (CardContainer row in Battle.instance.GetRows(applyXtoFrontAllies.target.owner))
      toAffect.AddIfNotNull<Entity>(row.GetTop());
    if (toAffect.Count > 0)
    {
      double num = (double) applyXtoFrontAllies.target.curveAnimator.Ping();
      yield return (object) Sequences.Wait(0.13f);
      Routine.Clump clump = new Routine.Clump();
      foreach (Entity target in toAffect)
      {
        Hit hit = new Hit(applyXtoFrontAllies.target, target, 0);
        hit.AddStatusEffect(applyXtoFrontAllies.effectToApply, a);
        clump.Add(hit.Process());
      }
      yield return (object) clump.WaitForEnd();
      yield return (object) Sequences.Wait(0.13f);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXToFrontAllyBasedOnDamageDealt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X To Front Ally Based On Damage Dealt", fileName = "Apply X To Front Ally Based On Damage Dealt")]
public class StatusEffectApplyXToFrontAllyBasedOnDamageDealt : StatusEffectApplyX
{
  public Dictionary<Entity, int[]> entitiesHitInRows = new Dictionary<Entity, int[]>();
  public Dictionary<int, int> damageDealtInRows = new Dictionary<int, int>();

  public override void Init() => this.OnCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.Check);

  public override bool RunHitEvent(Hit hit)
  {
    if ((Object) hit.attacker == (Object) this.target && (Object) hit.target != (Object) null && hit.Offensive)
      this.entitiesHitInRows.Add(hit.target, Battle.instance.GetRowIndices(hit.target));
    return false;
  }

  public override bool RunPostHitEvent(Hit hit)
  {
    if ((Object) hit.attacker == (Object) this.target && this.entitiesHitInRows.ContainsKey(hit.target) && hit.damageDealt > 0)
    {
      int[] entitiesHitInRow = this.entitiesHitInRows[hit.target];
      int damageDealt = hit.damageDealt;
      foreach (int key in entitiesHitInRow)
      {
        if (this.damageDealtInRows.ContainsKey(key))
          this.damageDealtInRows[key] += damageDealt;
        else
          this.damageDealtInRows[key] = damageDealt;
      }
    }
    return false;
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (!((Object) entity == (Object) this.target))
      return false;
    return this.damageDealtInRows.Count > 0 || this.entitiesHitInRows.Count > 0;
  }

  public IEnumerator Check(Entity entity, Entity[] targets)
  {
    StatusEffectApplyXToFrontAllyBasedOnDamageDealt basedOnDamageDealt = this;
    Dictionary<Entity, int> toAffect = new Dictionary<Entity, int>();
    foreach (int key in basedOnDamageDealt.damageDealtInRows.Keys)
    {
      CardContainer row = Battle.instance.GetRow(basedOnDamageDealt.target.owner, key);
      if ((Object) row != (Object) null)
      {
        Entity top = row.GetTop();
        if ((Object) top != (Object) null)
          toAffect[top] = basedOnDamageDealt.damageDealtInRows[key];
      }
    }
    if (toAffect.Count > 0)
    {
      yield return (object) Sequences.WaitForAnimationEnd(basedOnDamageDealt.target);
      double num1 = (double) basedOnDamageDealt.target.curveAnimator.Ping();
      yield return (object) Sequences.Wait(0.1f);
      Routine.Clump clump = new Routine.Clump();
      foreach (Entity key in toAffect.Keys)
      {
        int count = toAffect[key];
        Hit hit = new Hit(basedOnDamageDealt.target, key, 0);
        hit.AddStatusEffect(basedOnDamageDealt.effectToApply, count);
        clump.Add(hit.Process());
        if (basedOnDamageDealt.doPing)
        {
          double num2 = (double) key.curveAnimator.Ping();
        }
      }
      yield return (object) clump.WaitForEnd();
    }
    yield return (object) Sequences.Wait(0.1f);
    basedOnDamageDealt.damageDealtInRows.Clear();
    basedOnDamageDealt.entitiesHitInRows.Clear();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenAlliesAttack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Allies Attack", fileName = "Apply X When Allies Attack")]
public class StatusEffectApplyXWhenAlliesAttack : StatusEffectApplyX
{
  public override void Init() => this.PreAttack += new StatusEffectData.EffectHitEventHandler(this.HitCheck);

  public override bool RunPreAttackEvent(Hit hit) => this.target.enabled && this.target.alive && (Object) hit.attacker.owner == (Object) this.target.owner && (Object) hit.attacker != (Object) this.target && hit.Offensive;

  public IEnumerator HitCheck(Hit hit) => this.Run(this.GetTargets(hit));
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenAllyHealed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Ally Is Healed", fileName = "Apply X When Ally Is Healed")]
public class StatusEffectApplyXWhenAllyHealed : StatusEffectApplyX
{
  public override void Init()
  {
    this.PostHit += new StatusEffectData.EffectHitEventHandler(this.Check);
    this.OnApplyStatus += new StatusEffectData.EffectApplyEventHandler(this.CheckStatus);
  }

  public override bool RunPostHitEvent(Hit hit) => this.target.enabled && (Object) hit.target != (Object) this.target && (Object) hit.target.owner == (Object) this.target.owner && hit.damage < 0 && Battle.IsOnBoard(this.target);

  public IEnumerator Check(Hit hit) => this.Run(this.GetTargets(hit), -hit.damage);

  public override bool RunApplyStatusEvent(StatusEffectApply apply) => this.target.enabled && (Object) apply.target != (Object) this.target && (Object) apply.target.owner == (Object) this.target.owner && apply.effectData.type == "max health up" && Battle.IsOnBoard(this.target) && Battle.IsOnBoard(apply.target);

  public IEnumerator CheckStatus(StatusEffectApply apply) => this.Run(this.GetTargets(targets: new Entity[1]
  {
    apply.target
  }), apply.count);
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenAllyIsHit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Ally Is Hit", fileName = "Apply X When Ally Is Hit")]
public class StatusEffectApplyXWhenAllyIsHit : StatusEffectApplyX
{
  [SerializeField]
  public bool includeSelf;

  public override void Init() => this.PostHit += new StatusEffectData.EffectHitEventHandler(this.Check);

  public override bool RunPostHitEvent(Hit hit) => this.target.enabled && (this.includeSelf || (Object) hit.target != (Object) this.target) && hit.canRetaliate && (Object) hit.target.owner == (Object) this.target.owner && hit.Offensive && hit.BasicHit && Battle.IsOnBoard(this.target) && Battle.IsOnBoard(hit.target);

  public IEnumerator Check(Hit hit) => this.Run(this.GetTargets(hit));
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenAllyIsKilled
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Ally Is Killed", fileName = "Apply X When Ally Is Killed")]
public class StatusEffectApplyXWhenAllyIsKilled : StatusEffectApplyX
{
  [SerializeField]
  public bool sacrificed;

  public override void Init() => this.OnEntityDestroyed += new StatusEffectData.EffectEntityDeathEventHandler(this.Check);

  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
  {
    if (!this.target.enabled || !this.target.alive || !((Object) this.target.owner == (Object) entity.owner) || !Battle.IsOnBoard(this.target) || !Battle.IsOnBoard(entity))
      return false;
    return !this.sacrificed || DeathSystem.KilledByOwnTeam(entity);
  }

  public IEnumerator Check(Entity entity, DeathType deathType)
  {
    StatusEffectApplyXWhenAllyIsKilled xwhenAllyIsKilled = this;
    if ((bool) (Object) xwhenAllyIsKilled.contextEqualAmount)
    {
      int amount = xwhenAllyIsKilled.contextEqualAmount.Get(entity);
      yield return (object) xwhenAllyIsKilled.Run(xwhenAllyIsKilled.GetTargets(), amount);
    }
    else
      yield return (object) xwhenAllyIsKilled.Run(xwhenAllyIsKilled.GetTargets());
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenAnyoneTakesDamage
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Anyone Takes Damage", fileName = "Apply X When Anyone Takes Damage")]
public class StatusEffectApplyXWhenAnyoneTakesDamage : StatusEffectApplyX
{
  [SerializeField]
  public string targetDamageType = "basic";

  public override void Init() => this.PostHit += new StatusEffectData.EffectHitEventHandler(this.CheckHit);

  public override bool RunPostHitEvent(Hit hit) => this.target.enabled && this.target.alive && hit.Offensive && hit.damageType == this.targetDamageType && Battle.IsOnBoard(this.target);

  public IEnumerator CheckHit(Hit hit) => this.Run(this.GetTargets(hit));
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenBuilt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Built", fileName = "Apply X When Built")]
public class StatusEffectApplyXWhenBuilt : StatusEffectApplyX
{
  public override void Init() => this.OnBuild += new StatusEffectData.EffectEntityEventHandler(this.Build);

  public override bool RunBuildEvent(Entity entity) => (Object) entity == (Object) this.target;

  public IEnumerator Build(Entity entity)
  {
    StatusEffectApplyXWhenBuilt effectApplyXwhenBuilt = this;
    yield return (object) effectApplyXwhenBuilt.Run(effectApplyXwhenBuilt.GetTargets());
    yield return (object) effectApplyXwhenBuilt.Remove();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenCardDestroyed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Card Destroyed", fileName = "Apply X When Card Destroyed")]
public class StatusEffectApplyXWhenCardDestroyed : StatusEffectApplyX
{
  [SerializeField]
  public bool canBeAlly = true;
  [SerializeField]
  public bool canBeEnemy = true;
  [SerializeField]
  public bool mustBeSacrificed;
  [SerializeField]
  public bool mustBeOnBoard = true;
  [SerializeField]
  public TargetConstraint[] constraints;

  public override void Init() => this.OnEntityDestroyed += new StatusEffectData.EffectEntityDeathEventHandler(this.Check);

  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
  {
    if (!this.target.enabled || !this.target.alive || !this.CheckTeam(entity) || !Battle.IsOnBoard(this.target) || this.mustBeOnBoard && !Battle.IsOnBoard(entity) || !this.CheckConstraints(entity))
      return false;
    return !this.mustBeSacrificed || DeathSystem.KilledByOwnTeam(entity);
  }

  public IEnumerator Check(Entity entity, DeathType deathType)
  {
    StatusEffectApplyXWhenCardDestroyed xwhenCardDestroyed = this;
    if ((bool) (UnityEngine.Object) xwhenCardDestroyed.contextEqualAmount)
    {
      int amount = xwhenCardDestroyed.contextEqualAmount.Get(entity);
      yield return (object) xwhenCardDestroyed.Run(xwhenCardDestroyed.GetTargets(entity.lastHit), amount);
    }
    else
      yield return (object) xwhenCardDestroyed.Run(xwhenCardDestroyed.GetTargets(entity.lastHit));
  }

  public bool CheckTeam(Entity entity)
  {
    if ((UnityEngine.Object) this.target.owner == (UnityEngine.Object) entity.owner)
      return this.canBeAlly;
    return (UnityEngine.Object) this.target.owner != (UnityEngine.Object) entity.owner && this.canBeEnemy;
  }

  public new bool CheckConstraints(Entity entity) => this.constraints == null || ((IEnumerable<TargetConstraint>) this.constraints).All<TargetConstraint>((Func<TargetConstraint, bool>) (c => c.Check(entity)));
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenClunkerDestroyed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Clunker Destroyed", fileName = "Apply X When Clunker Destroyed")]
public class StatusEffectApplyXWhenClunkerDestroyed : StatusEffectApplyX
{
  public override void Init() => this.OnEntityDestroyed += new StatusEffectData.EffectEntityDeathEventHandler(this.Check);

  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType) => this.target.enabled && entity.data.cardType.name == "Clunker" && Battle.IsOnBoard(this.target);

  public IEnumerator Check(Entity entity, DeathType deathType) => this.Run(this.GetTargets());
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenDamageTaken
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Damage Taken", fileName = "Apply X When Damage Taken")]
public class StatusEffectApplyXWhenDamageTaken : StatusEffectApplyX
{
  [SerializeField]
  public string targetDamageType = "basic";

  public override void Init() => this.PostHit += new StatusEffectData.EffectHitEventHandler(this.CheckHit);

  public override bool RunPostHitEvent(Hit hit) => (Object) hit.target == (Object) this.target && this.target.enabled && this.target.alive && hit.Offensive && hit.damageType == this.targetDamageType && Battle.IsOnBoard(this.target);

  public IEnumerator CheckHit(Hit hit) => this.Run(this.GetTargets(hit));
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenDeployed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Deployed", fileName = "Apply X When Deployed")]
public class StatusEffectApplyXWhenDeployed : StatusEffectApplyX
{
  [SerializeField]
  public bool whenSelfDeployed = true;
  [SerializeField]
  public bool whenAllyDeployed;
  [SerializeField]
  public bool whenEnemyDeployed;
  public Hit hackyHit;
  public bool isAlreadyOnBoard;

  public override object GetMidBattleData() => (object) Battle.IsOnBoard(this.target);

  public override void RestoreMidBattleData(object data)
  {
    if (!(data is bool flag))
      return;
    this.isAlreadyOnBoard = flag && Battle.IsOnBoard(this.target);
  }

  public override void Init()
  {
    this.OnEnable += new StatusEffectData.EffectEntityEventHandler(this.CheckEnable);
    this.OnCardMove += new StatusEffectData.EffectEntityEventHandler(this.CheckCardMove);
  }

  public override bool RunEnableEvent(Entity entity)
  {
    if (this.whenSelfDeployed && (Object) entity == (Object) this.target && Battle.IsOnBoard(this.target))
    {
      if (this.isAlreadyOnBoard)
      {
        this.isAlreadyOnBoard = false;
        return false;
      }
      this.hackyHit = (Hit) null;
      return true;
    }
    if (this.whenAllyDeployed && this.target.enabled && StatusEffectApplyXWhenDeployed.IsAlly(this.target, entity) && Battle.IsOnBoard(this.target) && Battle.IsOnBoard(entity))
    {
      this.hackyHit = new Hit(this.target, entity);
      return true;
    }
    if (!this.whenEnemyDeployed || !this.target.enabled || !StatusEffectApplyXWhenDeployed.IsEnemy(this.target, entity) || !Battle.IsOnBoard(this.target) || !Battle.IsOnBoard(entity))
      return false;
    this.hackyHit = new Hit(this.target, entity);
    return true;
  }

  public IEnumerator CheckEnable(Entity entity) => this.Run(this.GetTargets(this.hackyHit));

  public override bool RunCardMoveEvent(Entity entity)
  {
    if (!this.target.enabled || !entity.enabled)
      return false;
    if (this.whenSelfDeployed && (Object) entity == (Object) this.target && StatusEffectApplyXWhenDeployed.WasMovedOnToBoard(entity))
    {
      this.hackyHit = (Hit) null;
      return true;
    }
    if (this.whenAllyDeployed && StatusEffectApplyXWhenDeployed.IsAlly(this.target, entity) && StatusEffectApplyXWhenDeployed.WasMovedOnToBoard(entity))
    {
      this.hackyHit = new Hit(this.target, entity);
      return true;
    }
    if (!this.whenEnemyDeployed || !StatusEffectApplyXWhenDeployed.IsEnemy(this.target, entity) || !StatusEffectApplyXWhenDeployed.WasMovedOnToBoard(entity))
      return false;
    this.hackyHit = new Hit(this.target, entity);
    return true;
  }

  public IEnumerator CheckCardMove(Entity entity) => this.Run(this.GetTargets(this.hackyHit));

  public static bool WasMovedOnToBoard(Entity entity) => Battle.IsOnBoard(entity) && !Battle.IsOnBoard(entity.preContainers);

  public static bool IsAlly(Entity a, Entity b) => (Object) a != (Object) b && a.owner.team == b.owner.team;

  public static bool IsEnemy(Entity a, Entity b) => a.owner.team != b.owner.team;
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenDestroyed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Destroyed", fileName = "Apply X When Destroyed")]
public class StatusEffectApplyXWhenDestroyed : StatusEffectApplyX
{
  [SerializeField]
  public bool sacrificed;
  [SerializeField]
  public bool consumed;

  public override void Init() => this.OnEntityDestroyed += new StatusEffectData.EffectEntityDeathEventHandler(this.CheckDestroy);

  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType) => (Object) entity == (Object) this.target && this.CheckDeathType(deathType);

  public IEnumerator CheckDestroy(Entity entity, DeathType deathType)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectApplyXWhenDestroyed applyXwhenDestroyed = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) applyXwhenDestroyed.Run(applyXwhenDestroyed.GetTargets(wasInRows: applyXwhenDestroyed.GetTargetContainers(), wasInSlots: applyXwhenDestroyed.GetTargetActualContainers()));
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public bool CheckDeathType(DeathType deathType) => (!this.consumed || deathType == DeathType.Consume) && (!this.sacrificed || DeathSystem.KilledByOwnTeam(this.target));
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenDiscarded
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Discarded", fileName = "Apply X When Discarded")]
public class StatusEffectApplyXWhenDiscarded : StatusEffectApplyX
{
  public override void Init() => global::Events.OnActionQueued += new UnityAction<PlayAction>(this.ActionQueued);

  public void ActionQueued(PlayAction action)
  {
    if (!(action is ActionMove actionMove) || !((Object) actionMove.entity == (Object) this.target) || !(bool) (Object) this.target.owner || !actionMove.toContainers.Contains<CardContainer>(this.target.owner.discardContainer))
      return;
    ActionQueue.Insert(ActionQueue.IndexOf(action), (PlayAction) new ActionSequence(this.Sequence()));
  }

  public IEnumerator Sequence() => this.Run(this.GetTargets());
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenDrawn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Drawn", fileName = "Apply X When Drawn")]
public class StatusEffectApplyXWhenDrawn : StatusEffectApplyX
{
  public override void Init()
  {
    this.OnEnable += new StatusEffectData.EffectEntityEventHandler(this.CheckEnable);
    this.OnCardMove += new StatusEffectData.EffectEntityEventHandler(this.CheckCardMove);
  }

  public override bool RunEnableEvent(Entity entity) => (Object) entity == (Object) this.target && this.target.InHand();

  public IEnumerator CheckEnable(Entity entity) => this.Run(this.GetTargets());

  public override bool RunCardMoveEvent(Entity entity) => this.target.enabled && (Object) entity == (Object) this.target && this.target.InHand();

  public IEnumerator CheckCardMove(Entity entity) => this.Run(this.GetTargets());
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenEnemiesAttack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Enemies Attack", fileName = "Apply X When Enemies Attack")]
public class StatusEffectApplyXWhenEnemiesAttack : StatusEffectApplyX
{
  public Entity attacker;

  public override void Init() => this.PreAttack += new StatusEffectData.EffectHitEventHandler(this.HitCheck);

  public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (this.target.enabled && this.target.alive && (Object) entity.owner != (Object) this.target.owner && Battle.IsOnBoard(this.target))
      this.attacker = entity;
    return false;
  }

  public override bool RunPreAttackEvent(Hit hit) => (Object) this.attacker != (Object) null && (Object) hit.attacker == (Object) this.attacker && this.target.enabled && this.target.alive && hit.Offensive && Battle.IsOnBoard(this.target);

  public IEnumerator HitCheck(Hit hit)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectApplyXWhenEnemiesAttack xwhenEnemiesAttack = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    xwhenEnemiesAttack.attacker = (Entity) null;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) xwhenEnemiesAttack.Run(xwhenEnemiesAttack.GetTargets(hit));
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenHealed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Healed", fileName = "Apply X When Healed")]
public class StatusEffectApplyXWhenHealed : StatusEffectApplyX
{
  public override void Init()
  {
    this.OnHit += new StatusEffectData.EffectHitEventHandler(this.Check);
    this.OnApplyStatus += new StatusEffectData.EffectApplyEventHandler(this.CheckStatus);
  }

  public override bool RunHitEvent(Hit hit) => (Object) hit.target == (Object) this.target && hit.damage < 0;

  public IEnumerator Check(Hit hit) => this.Run(this.GetTargets(hit), -hit.damage);

  public override bool RunApplyStatusEvent(StatusEffectApply apply) => (Object) apply.target == (Object) this.target && apply.effectData.type == "max health up";

  public IEnumerator CheckStatus(StatusEffectApply apply) => this.Run(this.GetTargets(targets: new Entity[1]
  {
    apply.target
  }), apply.count);
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenHealthLost
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Health Lost", fileName = "Apply X When Health Lost")]
public class StatusEffectApplyXWhenHealthLost : StatusEffectApplyX
{
  [SerializeField]
  public bool hasThreshold;
  public bool active;
  public int currentHealth;

  public override void Init() => global::Events.OnEntityDisplayUpdated += new UnityAction<Entity>(this.EntityDisplayUpdated);

  public void OnDestroy() => global::Events.OnEntityDisplayUpdated -= new UnityAction<Entity>(this.EntityDisplayUpdated);

  public override bool RunBeginEvent()
  {
    this.active = true;
    this.currentHealth = this.target.hp.current;
    return false;
  }

  public void EntityDisplayUpdated(Entity entity)
  {
    if (!this.active || this.target.hp.current == this.currentHealth || !((Object) entity == (Object) this.target))
      return;
    int num = this.target.hp.current - this.currentHealth;
    this.currentHealth = this.target.hp.current;
    if (num >= 0 || !this.target.enabled || this.target.silenced || !this.CheckThreshold() || this.targetMustBeAlive && (!this.target.alive || !Battle.IsOnBoard(this.target)))
      return;
    ActionSequence action = new ActionSequence(this.HealthLost(-num));
    action.note = this.name;
    action.priority = this.eventPriority;
    ActionQueue.Stack((PlayAction) action, true);
  }

  public bool CheckThreshold() => !this.hasThreshold || this.target.hp.current <= this.target.hp.max - this.GetAmount();

  public IEnumerator HealthLost(int amount)
  {
    StatusEffectApplyXWhenHealthLost applyXwhenHealthLost = this;
    if ((bool) (Object) applyXwhenHealthLost && applyXwhenHealthLost.target.IsAliveAndExists())
      yield return (object) applyXwhenHealthLost.Run(applyXwhenHealthLost.GetTargets(), amount);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenHit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Hit", fileName = "Apply X When Hit")]
public class StatusEffectApplyXWhenHit : StatusEffectApplyX
{
  [SerializeField]
  public TargetConstraint[] attackerConstraints;

  public override void Init() => this.PostHit += new StatusEffectData.EffectHitEventHandler(this.CheckHit);

  public override bool RunPostHitEvent(Hit hit) => this.target.enabled && (Object) hit.target == (Object) this.target && hit.canRetaliate && (!this.targetMustBeAlive || this.target.alive && Battle.IsOnBoard(this.target)) && hit.Offensive && hit.BasicHit && this.CheckAttackerConstraints(hit.attacker);

  public IEnumerator CheckHit(Hit hit) => this.Run(this.GetTargets(hit, this.GetTargetContainers(), this.GetTargetActualContainers()), hit.damage + hit.damageBlocked);

  public bool CheckAttackerConstraints(Entity attacker)
  {
    if (this.attackerConstraints != null)
    {
      foreach (TargetConstraint attackerConstraint in this.attackerConstraints)
      {
        if (!attackerConstraint.Check(attacker))
          return false;
      }
    }
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenRedrawHit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Redraw Hit", fileName = "Apply X When Redraw Hit")]
public class StatusEffectApplyXWhenRedrawHit : StatusEffectApplyX
{
  public override void Init() => global::Events.OnRedrawBellHit += new UnityAction<RedrawBellSystem>(this.RedrawBellHit);

  public void OnDestroy() => global::Events.OnRedrawBellHit -= new UnityAction<RedrawBellSystem>(this.RedrawBellHit);

  public void RedrawBellHit(RedrawBellSystem redrawBellSystem) => ActionQueue.Stack((PlayAction) new ActionSequence(this.Run(this.GetTargets())), true);
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenUnitIsKilled
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Unit Is Killed", fileName = "Apply X When Unit Is Killed")]
public class StatusEffectApplyXWhenUnitIsKilled : StatusEffectApplyX
{
  [SerializeField]
  public bool ally = true;
  [SerializeField]
  public bool enemy;
  [SerializeField]
  public bool sacrificed;
  [SerializeField]
  public TargetConstraint[] unitConstraints;

  public override void Init() => this.OnEntityDestroyed += new StatusEffectData.EffectEntityDeathEventHandler(this.Check);

  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
  {
    if (!this.target.enabled || !this.target.alive || !this.CheckTeam(entity) || !Battle.IsOnBoard(entity) || !Battle.IsOnBoard(this.target) || !this.CheckConstraints(entity))
      return false;
    return !this.sacrificed || (UnityEngine.Object) entity.lastHit.owner == (UnityEngine.Object) entity.owner;
  }

  public IEnumerator Check(Entity entity, DeathType deathType)
  {
    StatusEffectApplyXWhenUnitIsKilled xwhenUnitIsKilled = this;
    if ((bool) (UnityEngine.Object) xwhenUnitIsKilled.contextEqualAmount)
    {
      int amount = xwhenUnitIsKilled.contextEqualAmount.Get(entity);
      yield return (object) xwhenUnitIsKilled.Run(xwhenUnitIsKilled.GetTargets(entity.lastHit), amount);
    }
    else
      yield return (object) xwhenUnitIsKilled.Run(xwhenUnitIsKilled.GetTargets(entity.lastHit));
  }

  public bool CheckTeam(Entity entity)
  {
    if ((UnityEngine.Object) this.target.owner == (UnityEngine.Object) entity.owner)
      return this.ally;
    return (UnityEngine.Object) this.target.owner != (UnityEngine.Object) entity.owner && this.enemy;
  }

  public new bool CheckConstraints(Entity entity) => this.unitConstraints == null || ((IEnumerable<TargetConstraint>) this.unitConstraints).All<TargetConstraint>((Func<TargetConstraint, bool>) (c => c.Check(entity)));
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenYAppliedTo
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Y Applied To", fileName = "Apply X When Y Applied To")]
public class StatusEffectApplyXWhenYAppliedTo : StatusEffectApplyX
{
  [SerializeField]
  public bool instead;
  public string whenAppliedType = "snow";
  [SerializeField]
  public StatusEffectApplyX.ApplyToFlags whenAppliedToFlags;
  [SerializeField]
  public bool mustReachAmount;
  [SerializeField]
  [ShowIf("mustReachAmount")]
  public int amountRequired;
  [Header("Adjust Amount Applied")]
  [SerializeField]
  public bool adjustAmount;
  [SerializeField]
  [ShowIf("adjustAmount")]
  public int addAmount;
  [SerializeField]
  [ShowIf("adjustAmount")]
  public float multiplyAmount = 1f;

  public override void Init() => this.PostApplyStatus += new StatusEffectData.EffectApplyEventHandler(this.Run);

  public override bool RunApplyStatusEvent(StatusEffectApply apply)
  {
    if ((this.adjustAmount || this.instead) && this.target.enabled && (this.target.alive || !this.targetMustBeAlive) && (bool) (Object) apply.effectData && apply.count > 0 && apply.effectData.type == this.whenAppliedType && this.CheckTarget(apply.target))
    {
      if (this.instead)
        apply.effectData = this.effectToApply;
      if (this.adjustAmount)
      {
        apply.count += this.addAmount;
        apply.count = Mathf.RoundToInt((float) apply.count * this.multiplyAmount);
      }
    }
    return false;
  }

  public override bool RunPostApplyStatusEvent(StatusEffectApply apply) => this.target.enabled && (bool) (Object) apply.effectData && apply.count > 0 && apply.effectData.type == this.whenAppliedType && this.CheckTarget(apply.target) && this.CheckAmount(apply);

  public IEnumerator Run(StatusEffectApply apply) => this.Run(this.GetTargets(), apply.count);

  public bool CheckFlag(StatusEffectApplyX.ApplyToFlags whenAppliedTo) => (this.whenAppliedToFlags & whenAppliedTo) != 0;

  public bool CheckTarget(Entity entity)
  {
    if (!Battle.IsOnBoard(this.target))
      return false;
    if ((Object) entity == (Object) this.target)
      return this.CheckFlag(StatusEffectApplyX.ApplyToFlags.Self);
    if ((Object) entity.owner == (Object) this.target.owner)
      return this.CheckFlag(StatusEffectApplyX.ApplyToFlags.Allies);
    return (Object) entity.owner != (Object) this.target.owner && this.CheckFlag(StatusEffectApplyX.ApplyToFlags.Enemies);
  }

  public bool CheckAmount(StatusEffectApply apply)
  {
    if (!this.mustReachAmount)
      return true;
    StatusEffectData status = apply.target.FindStatus(apply.effectData.type);
    return (Object) status != (Object) null && status.count >= this.amountRequired;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenYAppliedToAlly
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Y Applied To Ally", fileName = "Apply X When Y Applied To Ally")]
public class StatusEffectApplyXWhenYAppliedToAlly : StatusEffectApplyX
{
  public string whenAppliedType = "snow";

  public override void Init() => this.PostApplyStatus += new StatusEffectData.EffectApplyEventHandler(this.Check);

  public override bool RunPostApplyStatusEvent(StatusEffectApply apply) => this.target.enabled && (Object) apply.target.owner == (Object) this.target.owner && (Object) apply.effectData != (Object) null && apply.count > 0 && apply.effectData.type == this.whenAppliedType;

  public IEnumerator Check(StatusEffectApply apply) => this.Run(this.GetTargets());
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectApplyXWhenYAppliedToSelf
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Y Applied To Self", fileName = "Apply X When Y Applied To Self")]
public class StatusEffectApplyXWhenYAppliedToSelf : StatusEffectApplyX
{
  public string whenAppliedType = "spice";

  public override void Init() => this.PostApplyStatus += new StatusEffectData.EffectApplyEventHandler(this.Check);

  public override bool RunPostApplyStatusEvent(StatusEffectApply apply) => this.target.enabled && (Object) apply.target == (Object) this.target && (Object) apply.effectData != (Object) null && apply.count > 0 && apply.effectData.type == this.whenAppliedType;

  public IEnumerator Check(StatusEffectApply apply) => this.Run(this.GetTargets());
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectBlock
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Block", fileName = "Block")]
public class StatusEffectBlock : StatusEffectData
{
  public override void Init() => this.OnHit += new StatusEffectData.EffectHitEventHandler(this.Check);

  public override bool RunHitEvent(Hit hit) => (Object) hit.target == (Object) this.target && hit.Offensive && hit.canBeNullified && hit.damage > 0;

  public IEnumerator Check(Hit hit)
  {
    StatusEffectBlock statusEffectBlock = this;
    SfxSystem.OneShot("event:/sfx/status_icon/block_decrease");
    hit.damageBlocked = hit.damage;
    hit.damage = 0;
    --statusEffectBlock.count;
    if (statusEffectBlock.count <= 0)
      yield return (object) statusEffectBlock.Remove();
    statusEffectBlock.target.PromptUpdate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectBombard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Bombard", fileName = "Bombard")]
public class StatusEffectBombard : StatusEffectData
{
  [SerializeField]
  public Vector2Int targetCountRange = new Vector2Int(2, 2);
  [SerializeField]
  [Range(0.0f, 1f)]
  public float hitFriendlyChance = 0.1f;
  [SerializeField]
  public float delayBetweenTargets = 0.1f;
  [SerializeField]
  public float delayAfter = 0.1f;
  [SerializeField]
  public int maxFrontTargets;
  public List<CardContainer> targetList = new List<CardContainer>();
  public bool triggered;
  public int[] storedTargetList;

  public override object GetMidBattleData()
  {
    List<CardContainer> targetList = this.targetList;
    if (targetList == null || targetList.Count <= 0)
      return (object) null;
    List<int> intList = new List<int>();
    List<CardSlot> slots = References.Battle.GetSlots();
    foreach (CardContainer target in this.targetList)
    {
      if (target is CardSlot cardSlot)
      {
        int num = slots.IndexOf(cardSlot);
        if (num >= 0)
          intList.Add(num);
      }
    }
    return (object) new StatusEffectBombard.SlotList()
    {
      list = intList.ToArray()
    };
  }

  public override void RestoreMidBattleData(object data)
  {
    if (!(data is StatusEffectBombard.SlotList slotList))
      return;
    this.storedTargetList = slotList.list;
  }

  public override void Init()
  {
    this.OnEnable += new StatusEffectData.EffectEntityEventHandler(this.Enable);
    this.OnCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.CardPlayed);
    this.OnActionPerformed += new StatusEffectData.EffectActionPerformedHandler(this.ActionPerformed);
    Events.OnEntityTrigger += new Events.UnityActionRef<Trigger>(this.EntityTrigger);
  }

  public void OnDestroy() => Events.OnEntityTrigger -= new Events.UnityActionRef<Trigger>(this.EntityTrigger);

  public void EntityTrigger(ref Trigger trigger)
  {
    if (!((UnityEngine.Object) trigger.entity == (UnityEngine.Object) this.target) || !this.CanTrigger() || !(trigger.type == "basic"))
      return;
    trigger = (Trigger) new TriggerBombard(trigger.entity, trigger.triggeredBy, "bombard", trigger.targets, this.targetList.ToArray());
  }

  public override bool RunEnableEvent(Entity entity) => (UnityEngine.Object) entity == (UnityEngine.Object) this.target;

  public IEnumerator Enable(Entity entity)
  {
    yield return (object) this.SetTargets();
  }

  public override bool RunDisableEvent(Entity entity)
  {
    if ((UnityEngine.Object) entity == (UnityEngine.Object) this.target)
    {
      foreach (CardContainer target in this.targetList)
        Events.InvokeAbilityTargetRemove(target);
    }
    return false;
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets) => (UnityEngine.Object) entity == (UnityEngine.Object) this.target;

  public IEnumerator CardPlayed(Entity entity, Entity[] targets)
  {
    StatusEffectBombard statusEffectBombard = this;
    if (statusEffectBombard.CanTrigger())
    {
      statusEffectBombard.triggered = true;
      yield return (object) Sequences.WaitForAnimationEnd(statusEffectBombard.target);
      yield return (object) Sequences.Wait(statusEffectBombard.delayAfter);
    }
  }

  public override bool RunActionPerformedEvent(PlayAction action) => this.triggered && ActionQueue.Empty;

  public IEnumerator ActionPerformed(PlayAction action)
  {
    this.triggered = false;
    yield return (object) this.SetTargets();
  }

  public override bool RunEndEvent()
  {
    foreach (CardContainer target in this.targetList)
      Events.InvokeAbilityTargetRemove(target);
    return false;
  }

  public IEnumerator SetTargets()
  {
    StatusEffectBombard statusEffectBombard = this;
    foreach (CardContainer target in statusEffectBombard.targetList)
      Events.InvokeAbilityTargetRemove(target);
    if (statusEffectBombard.storedTargetList != null)
    {
      List<CardSlot> slots = References.Battle.GetSlots();
      foreach (int storedTarget in statusEffectBombard.storedTargetList)
      {
        CardSlot cardSlot = slots[storedTarget];
        statusEffectBombard.targetList.Add((CardContainer) cardSlot);
      }
      statusEffectBombard.storedTargetList = (int[]) null;
    }
    else
    {
      List<StatusEffectBombard.Slot> list = new List<StatusEffectBombard.Slot>();
      List<CardContainer> rows1 = Battle.instance.GetRows(statusEffectBombard.target.owner);
      List<CardContainer> rows2 = Battle.instance.GetRows(Battle.GetOpponent(statusEffectBombard.target.owner));
      for (int index = 0; index < Battle.instance.rowCount; ++index)
      {
        if (rows1[index] is CardSlotLane cardSlotLane1)
          list.AddRange(cardSlotLane1.slots.Select<CardSlot, StatusEffectBombard.Slot>((Func<CardSlot, int, StatusEffectBombard.Slot>) ((t, i) => new StatusEffectBombard.Slot(t, true, i == 0))));
        if (rows2[index] is CardSlotLane cardSlotLane2)
          list.AddRange(cardSlotLane2.slots.Select<CardSlot, StatusEffectBombard.Slot>((Func<CardSlot, int, StatusEffectBombard.Slot>) ((t, i) => new StatusEffectBombard.Slot(t, false, i == 0))));
      }
      list.Shuffle<StatusEffectBombard.Slot>();
      if (statusEffectBombard.maxFrontTargets <= 0)
        list.RemoveAll((Predicate<StatusEffectBombard.Slot>) (a => a.front));
      (statusEffectBombard.targetList ?? (statusEffectBombard.targetList = new List<CardContainer>())).Clear();
      int num1 = 0;
      int num2 = statusEffectBombard.targetCountRange.Random();
      while (num2 > 0 && list.Count > 0)
      {
        bool friendly = (double) UnityEngine.Random.Range(0.0f, 1f) < (double) statusEffectBombard.hitFriendlyChance;
        StatusEffectBombard.Slot slot = list.Find((Predicate<StatusEffectBombard.Slot>) (a => a.friendly == friendly)) ?? list[0];
        statusEffectBombard.targetList.Add((CardContainer) slot.slot);
        --num2;
        list.Remove(slot);
        if (slot.front && ++num1 >= statusEffectBombard.maxFrontTargets)
          list.RemoveAll((Predicate<StatusEffectBombard.Slot>) (a => a.front));
      }
    }
    if ((bool) (UnityEngine.Object) statusEffectBombard.target)
      statusEffectBombard.targetList.Sort(new Comparison<CardContainer>(statusEffectBombard.\u003CSetTargets\u003Eb__21_0));
    foreach (CardContainer target in statusEffectBombard.targetList)
    {
      Events.InvokeAbilityTargetAdd(target);
      yield return (object) Sequences.Wait(statusEffectBombard.delayBetweenTargets);
    }
  }

  [CompilerGenerated]
  public int \u003CSetTargets\u003Eb__21_0(CardContainer a, CardContainer b)
  {
    int num = Mathf.RoundToInt(Mathf.Sign(this.target.transform.position.x));
    float x1 = a.holder.position.x;
    float x2 = b.holder.position.x;
    return num != 1 ? x2.CompareTo(x1) : x1.CompareTo(x2);
  }

  public class Slot
  {
    public readonly CardSlot slot;
    public readonly bool friendly;
    public readonly bool front;

    public Slot(CardSlot slot, bool friendly, bool front)
    {
      this.slot = slot;
      this.friendly = friendly;
      this.front = front;
    }
  }

  [Serializable]
  public class SlotList
  {
    public int[] list;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectBonusDamageEqualToCards
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Bonus Damage Equal To Cards", fileName = "Bonus Damage Equal To Cards")]
public class StatusEffectBonusDamageEqualToCards : StatusEffectData
{
  [SerializeField]
  public string cardName = "Dart";
  [SerializeField]
  public bool inHand = true;
  [SerializeField]
  public bool onBoard;
  [SerializeField]
  public bool includeSelf = true;
  [SerializeField]
  public bool ping = true;
  public int currentAmount;

  public override void Init() => this.PreCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.Gain);

  public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets) => (UnityEngine.Object) entity == (UnityEngine.Object) this.target && this.currentAmount == 0 && this.CanTrigger();

  public IEnumerator Gain(Entity entity, Entity[] targets)
  {
    StatusEffectBonusDamageEqualToCards damageEqualToCards = this;
    int num1 = damageEqualToCards.Count();
    if (num1 > 0)
    {
      damageEqualToCards.currentAmount = num1;
      damageEqualToCards.target.tempDamage += damageEqualToCards.currentAmount;
      damageEqualToCards.target.PromptUpdate();
      if (damageEqualToCards.ping)
      {
        CurveAnimator curveAnimator = damageEqualToCards.target.curveAnimator;
        if (curveAnimator != null)
        {
          double num2 = (double) curveAnimator.Ping();
        }
        yield return (object) Sequences.Wait(0.5f);
      }
    }
  }

  public override bool RunTurnEndEvent(Entity entity)
  {
    if (this.currentAmount > 0 && (bool) (UnityEngine.Object) this.target.owner && (bool) (UnityEngine.Object) this.target.owner.entity && (UnityEngine.Object) entity == (UnityEngine.Object) this.target.owner.entity)
    {
      this.target.tempDamage -= this.currentAmount;
      this.currentAmount = 0;
      this.target.PromptUpdate();
    }
    return false;
  }

  public int Count() => 0 + (this.inHand ? this.CountInHand() : 0) + (this.onBoard ? this.CountOnBoard() : 0);

  public int CountInHand()
  {
    int num = 0;
    CardContainer handContainer = this.target.owner.handContainer;
    if ((bool) (UnityEngine.Object) handContainer)
      num += handContainer.Where<Entity>((Func<Entity, bool>) (entity => entity.data.name == this.cardName)).Count<Entity>((Func<Entity, bool>) (entity => this.includeSelf || (UnityEngine.Object) entity != (UnityEngine.Object) this.target));
    return num;
  }

  public int CountOnBoard() => Battle.GetAllUnits().Where<Entity>((Func<Entity, bool>) (entity => entity.data.name == this.cardName)).Count<Entity>((Func<Entity, bool>) (entity => this.includeSelf || (UnityEngine.Object) entity != (UnityEngine.Object) this.target));

  [CompilerGenerated]
  public bool \u003CCountInHand\u003Eb__11_0(Entity entity) => entity.data.name == this.cardName;

  [CompilerGenerated]
  public bool \u003CCountInHand\u003Eb__11_1(Entity entity) => this.includeSelf || (UnityEngine.Object) entity != (UnityEngine.Object) this.target;

  [CompilerGenerated]
  public bool \u003CCountOnBoard\u003Eb__12_0(Entity entity) => entity.data.name == this.cardName;

  [CompilerGenerated]
  public bool \u003CCountOnBoard\u003Eb__12_1(Entity entity) => this.includeSelf || (UnityEngine.Object) entity != (UnityEngine.Object) this.target;
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectBonusDamageEqualToX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Bonus Damage Equal To X", fileName = "Bonus Damage Equal To X")]
public class StatusEffectBonusDamageEqualToX : StatusEffectData
{
  [SerializeField]
  public StatusEffectBonusDamageEqualToX.On on;
  [SerializeField]
  [ShowIf("useScriptableAmount")]
  public ScriptableAmount scriptableAmount;
  [SerializeField]
  public bool add = true;
  [SerializeField]
  [HideIf("useScriptableAmount")]
  public bool health;
  [HideIf("health")]
  public string effectType = "shell";
  [SerializeField]
  public bool ping = true;
  public int currentAmount;
  public bool toReset;

  public bool useScriptableAmount => this.on == StatusEffectBonusDamageEqualToX.On.ScriptableAmount;

  public override void Init() => this.PreCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.Gain);

  public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets) => (UnityEngine.Object) entity == (UnityEngine.Object) this.target && !this.toReset && this.CanTrigger();

  public IEnumerator Gain(Entity entity, Entity[] targets)
  {
    StatusEffectBonusDamageEqualToX bonusDamageEqualToX = this;
    int num1 = bonusDamageEqualToX.Find();
    if (num1 != 0)
    {
      bonusDamageEqualToX.toReset = true;
      int num2 = bonusDamageEqualToX.target.tempDamage.Value;
      if (bonusDamageEqualToX.add)
        bonusDamageEqualToX.target.tempDamage += num1;
      else
        bonusDamageEqualToX.target.tempDamage.Value = num1;
      bonusDamageEqualToX.currentAmount = bonusDamageEqualToX.target.tempDamage.Value - num2;
      bonusDamageEqualToX.target.PromptUpdate();
      if (bonusDamageEqualToX.ping)
      {
        double num3 = (double) bonusDamageEqualToX.target.curveAnimator.Ping();
        yield return (object) Sequences.Wait(0.5f);
      }
    }
  }

  public override bool RunTurnEndEvent(Entity entity)
  {
    if ((UnityEngine.Object) entity == (UnityEngine.Object) this.target.owner.entity && this.toReset)
    {
      this.toReset = false;
      if (this.currentAmount != 0)
      {
        this.target.tempDamage -= this.currentAmount;
        this.currentAmount = 0;
        this.target.PromptUpdate();
      }
    }
    return false;
  }

  public int Find()
  {
    int num;
    switch (this.on)
    {
      case StatusEffectBonusDamageEqualToX.On.Self:
        num = this.FindOnSelf();
        break;
      case StatusEffectBonusDamageEqualToX.On.Board:
        num = this.FindOnBoard();
        break;
      case StatusEffectBonusDamageEqualToX.On.ScriptableAmount:
        num = this.scriptableAmount.Get(this.target);
        break;
      default:
        num = 0;
        break;
    }
    return num;
  }

  public int FindOnSelf()
  {
    int onSelf = 0;
    if (this.health)
    {
      onSelf = this.target.hp.current;
    }
    else
    {
      StatusEffectData status = this.target.FindStatus(this.effectType);
      if ((bool) (UnityEngine.Object) status && status.count > 0)
        onSelf = status.count;
    }
    return onSelf;
  }

  public int FindOnBoard()
  {
    int num = 0;
    return !this.health ? num + Battle.GetCardsOnBoard().Select<Entity, StatusEffectData>((Func<Entity, StatusEffectData>) (entity => entity.FindStatus(this.effectType))).Where<StatusEffectData>((Func<StatusEffectData, bool>) (effect => (bool) (UnityEngine.Object) effect && effect.count > 0)).Sum<StatusEffectData>((Func<StatusEffectData, int>) (effect => effect.count)) : num + Battle.GetCardsOnBoard().Sum<Entity>((Func<Entity, int>) (e => this.target.hp.current));
  }

  [CompilerGenerated]
  public int \u003CFindOnBoard\u003Eb__17_0(Entity e) => this.target.hp.current;

  [CompilerGenerated]
  public StatusEffectData \u003CFindOnBoard\u003Eb__17_1(Entity entity) => entity.FindStatus(this.effectType);

  public enum On
  {
    Self,
    Board,
    ScriptableAmount,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectBuild
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Build", fileName = "Build")]
public class StatusEffectBuild : StatusEffectData
{
  [SerializeField]
  public int requires = 3;

  public override bool RunCardMoveEvent(Entity entity)
  {
    if ((UnityEngine.Object) this.target == (UnityEngine.Object) entity && Battle.IsOnBoard(entity.containers) && !Battle.IsOnBoard(entity.preContainers))
    {
      List<Entity> list = entity.GetAllies().Where<Entity>((Func<Entity, bool>) (ally => ally.statusEffects.Exists((Predicate<StatusEffectData>) (a => a.name == this.name)))).ToList<Entity>();
      list.Add(entity);
      if (list.Count >= this.requires)
        ActionQueue.Stack((PlayAction) new ActionCombine(list.ToArray()), true);
    }
    return false;
  }

  [CompilerGenerated]
  public bool \u003CRunCardMoveEvent\u003Eb__1_0(Entity ally) => ally.statusEffects.Exists((Predicate<StatusEffectData>) (a => a.name == this.name));

  [CompilerGenerated]
  public bool \u003CRunCardMoveEvent\u003Eb__1_1(StatusEffectData a) => a.name == this.name;
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectCannotBeRecalled
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Cannot Recall", fileName = "Cannot Recall")]
public class StatusEffectCannotBeRecalled : StatusEffectData
{
  public bool active;

  public override bool RunBeginEvent()
  {
    if (!this.active && (bool) (Object) this.target && this.GetAmount() > 0)
      this.Activate();
    return false;
  }

  public override bool RunEndEvent()
  {
    if (this.active && (bool) (Object) this.target)
      this.Deactivate();
    return false;
  }

  public override bool RunEffectBonusChangedEvent()
  {
    if ((bool) (Object) this.target)
    {
      int amount = this.GetAmount();
      if (amount > 0 && !this.active)
        this.Activate();
      else if (amount <= 0 && this.active)
        this.Deactivate();
    }
    return false;
  }

  public void Activate()
  {
    ++this.target.blockRecall;
    this.active = true;
  }

  public void Deactivate()
  {
    --this.target.blockRecall;
    this.active = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectChangePriorityPosition
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Change Priority Position", fileName = "Change Priority Position")]
public class StatusEffectChangePriorityPosition : StatusEffectData
{
  [Header("-1 = Backline, 2 = Frontline")]
  [SerializeField]
  public int positionPriorityChange = -1;
  public int pre;

  public override bool RunBeginEvent()
  {
    this.pre = this.target.positionPriority;
    if (!this.target.silenced)
      this.target.positionPriority = this.positionPriorityChange;
    return false;
  }

  public override bool RunEndEvent()
  {
    this.target.positionPriority = this.pre;
    return false;
  }

  public override bool RunEffectBonusChangedEvent()
  {
    this.RunEndEvent();
    this.RunBeginEvent();
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectChangeRecycleRequirement
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Change Recycle Requirement", fileName = "Change Recycle Requirement")]
public class StatusEffectChangeRecycleRequirement : StatusEffectData
{
  [SerializeField]
  public bool lower = true;

  public override void Init() => Events.OnCheckRecycleAmount += new Events.UnityActionRef<Entity, int>(this.CheckRecycleAmount);

  public void OnDestroy() => Events.OnCheckRecycleAmount -= new Events.UnityActionRef<Entity, int>(this.CheckRecycleAmount);

  public void CheckRecycleAmount(ref Entity entity, ref int amount)
  {
    if ((Object) entity != (Object) this.target)
      return;
    int amount1 = this.GetAmount();
    amount = Mathf.Max(0, this.lower ? amount - amount1 : amount + amount1);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectChangeTargetMode
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Change Target Mode", fileName = "Change Target Mode")]
public class StatusEffectChangeTargetMode : StatusEffectData
{
  [SerializeField]
  public TargetMode targetMode;
  public TargetMode pre;

  public override bool RunBeginEvent()
  {
    this.pre = this.target.targetMode;
    if (!this.target.silenced)
      this.target.targetMode = this.targetMode;
    return false;
  }

  public override bool RunEndEvent()
  {
    this.target.targetMode = this.pre;
    return false;
  }

  public override bool RunEffectBonusChangedEvent()
  {
    this.RunEndEvent();
    this.RunBeginEvent();
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectCrush
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Crush", fileName = "Crush")]
public class StatusEffectCrush : StatusEffectData
{
  public override void Init() => this.OnCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.Check);

  public static CardContainer[] GetWasInRows(Entity entity, IEnumerable<Entity> targets)
  {
    if (entity.data.playType != Card.PlayType.Play || !entity.NeedsTarget)
      return entity.containers;
    HashSet<CardContainer> list = new HashSet<CardContainer>();
    foreach (Entity target in targets)
    {
      if (target.containers != null && target.containers.Length != 0)
        list.AddRange<CardContainer>((IEnumerable<CardContainer>) target.containers);
      else
        list.AddRange<CardContainer>((IEnumerable<CardContainer>) target.preContainers);
    }
    return list.ToArray<CardContainer>();
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets) => this.target.enabled && (UnityEngine.Object) entity == (UnityEngine.Object) this.target;

  public IEnumerator Check(Entity entity, Entity[] targets)
  {
    StatusEffectCrush statusEffectCrush = this;
    int c = statusEffectCrush.GetAmount();
    for (int i = 0; i < c; ++i)
      yield return (object) statusEffectCrush.DestroyCard();
  }

  public IEnumerator DestroyCard()
  {
    StatusEffectCrush statusEffectCrush = this;
    Entity entity = References.Player.handContainer.InRandomOrder<Entity>().FirstOrDefault<Entity>(new Func<Entity, bool>(statusEffectCrush.\u003CDestroyCard\u003Eb__4_0));
    if (!(bool) (UnityEngine.Object) entity)
      entity = References.Player.handContainer.InRandomOrder<Entity>().FirstOrDefault<Entity>(new Func<Entity, bool>(statusEffectCrush.\u003CDestroyCard\u003Eb__4_1));
    if ((bool) (UnityEngine.Object) entity)
    {
      double num = (double) statusEffectCrush.target.curveAnimator.Ping();
      Routine.Clump clump = new Routine.Clump();
      clump.Add(entity.Kill());
      clump.Add(Sequences.Wait(0.5f));
      yield return (object) clump.WaitForEnd();
    }
  }

  [CompilerGenerated]
  public bool \u003CDestroyCard\u003Eb__4_0(Entity a) => a.name == "Junk" && (UnityEngine.Object) a != (UnityEngine.Object) this.target;

  [CompilerGenerated]
  public bool \u003CDestroyCard\u003Eb__4_1(Entity a) => a.data.cardType.item && (UnityEngine.Object) a != (UnityEngine.Object) this.target;
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectDamageEnemiesWhenDrawn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X To Enemies When Drawn", fileName = "Apply X To Enemies When Drawn")]
public class StatusEffectDamageEnemiesWhenDrawn : StatusEffectApplyX
{
  public override void Init() => this.OnEnable += new StatusEffectData.EffectEntityEventHandler(this.Check);

  public override bool RunEnableEvent(Entity entity) => (Object) entity == (Object) this.target && this.target.InHand();

  public IEnumerator Check(Entity entity) => this.Run(this.GetTargets());
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Localization;

public abstract class StatusEffectData : DataFile
{
  public static ulong idCurrent;
  public ulong id;
  public StatusEffectData original;
  public bool isClone;
  public bool isStatus;
  public bool isReaction;
  public bool isKeyword;
  public string type;
  public string keyword;
  public string iconGroupName;
  public bool visible;
  public bool stackable = true;
  public bool offensive;
  public bool makesOffensive;
  public bool doesDamage;
  public bool canBeBoosted;
  [InfoBox("Description that will be added to the card", EInfoBoxType.Normal)]
  public LocalizedString textKey;
  public string textInsert;
  public int textOrder;
  [TextArea]
  [SerializeField]
  public string desc;
  [SerializeField]
  public string descColorHex;
  [SerializeField]
  public int descOrder;
  public KeywordData[] hiddenKeywords;
  public string applyFormat;
  public LocalizedString applyFormatKey;
  [InfoBox("\"Reaction\" Effects should be affected by snow", EInfoBoxType.Normal)]
  [SerializeField]
  public bool affectedBySnow;
  [InfoBox("Higher priority effects will run FIRST", EInfoBoxType.Normal)]
  public int eventPriority;
  public bool removeOnDiscard;
  public bool preventDeath;
  [Header("Constraints that must be met for this to be applied")]
  public TargetConstraint[] targetConstraints;
  public bool removing;
  public int temporary;
  [HideInInspector]
  public Entity applier;
  [HideInInspector]
  public Character applierOwner;
  [HideInInspector]
  public Entity target;
  [ReadOnly]
  public int count;

  public StatusEffectData Instantiate()
  {
    StatusEffectData original = this.GetOriginal();
    StatusEffectData statusEffectData = Object.Instantiate<StatusEffectData>(original);
    statusEffectData.id = StatusEffectData.idCurrent++;
    statusEffectData.name = this.name;
    statusEffectData.original = original;
    statusEffectData.isClone = true;
    return statusEffectData;
  }

  public StatusEffectData GetOriginal() => !this.isClone ? this : this.original;

  public bool HasDesc => !this.Instant && !this.textKey.IsEmpty;

  public bool HasDescOrIsKeyword => this.isKeyword || this.HasDesc;

  public string GetDesc(int amount, bool silenced = false)
  {
    string desc = Text.GetEffectText(this.textKey, this.textInsert, amount, silenced);
    if (!this.descColorHex.IsNullOrWhitespace())
      desc = "<color=#" + this.descColorHex + ">" + desc + "</color>";
    return desc;
  }

  public string GetPlainDesc() => this.desc;

  public string GetApplyFormat()
  {
    LocalizedString applyFormatKey = this.applyFormatKey;
    return applyFormatKey == null || applyFormatKey.IsEmpty ? (string) null : Text.HandleBracketTags(this.applyFormatKey.GetLocalizedString());
  }

  public virtual object GetMidBattleData() => (object) null;

  public virtual void RestoreMidBattleData(object data)
  {
  }

  public virtual bool Instant => false;

  public virtual bool CanStackActions => true;

  public bool CanPlayOn(Entity target)
  {
    foreach (TargetConstraint targetConstraint in this.targetConstraints)
    {
      if (!targetConstraint.Check(target))
        return false;
    }
    return true;
  }

  public virtual bool CanTrigger()
  {
    if (!this.target.enabled || this.target.silenced)
      return false;
    if (!this.affectedBySnow)
      return true;
    return !this.target.IsSnowed && !this.target.paused;
  }

  public event StatusEffectData.EffectEventHandler OnBegin;

  public event StatusEffectData.EffectEventHandler OnEnd;

  public event StatusEffectData.EffectEntityEventHandler OnEnable;

  public event StatusEffectData.EffectEntityEventHandler OnDisable;

  public event StatusEffectData.EffectStackEventHandler OnStack;

  public event StatusEffectData.EffectEntityEventHandler OnTurnStart;

  public event StatusEffectData.EffectEntityEventHandler OnTurn;

  public event StatusEffectData.EffectEntityEventHandler OnTurnEnd;

  public event StatusEffectData.EffectHitEventHandler PreAttack;

  public event StatusEffectData.EffectHitEventHandler OnHit;

  public event StatusEffectData.EffectHitEventHandler PostHit;

  public event StatusEffectData.EffectHitEventHandler PostAttack;

  public event StatusEffectData.EffectApplyEventHandler OnApplyStatus;

  public event StatusEffectData.EffectApplyEventHandler PostApplyStatus;

  public event StatusEffectData.EffectEntityDeathEventHandler OnEntityDestroyed;

  public event StatusEffectData.EffectEntityEventHandler OnCardMove;

  public event StatusEffectData.EffectTriggerEventHandler PreTrigger;

  public event StatusEffectData.EffectCardPlayEventHandler PreCardPlayed;

  public event StatusEffectData.EffectCardPlayEventHandler OnCardPlayed;

  public event StatusEffectData.EffectEventHandler OnEffectBonusChanged;

  public event StatusEffectData.EffectActionPerformedHandler OnActionPerformed;

  public event StatusEffectData.EffectEntityEventHandler OnBuild;

  public virtual bool HasBeginRoutine => this.OnBegin != null;

  public virtual bool HasEndRoutine => this.OnEnd != null;

  public virtual bool HasEnableRoutine => this.OnEnable != null;

  public virtual bool HasDisableRoutine => this.OnDisable != null;

  public virtual bool HasStackRoutine => this.OnStack != null;

  public virtual bool HasTurnStartRoutine => this.OnTurnStart != null && this.HasActiveTarget;

  public virtual bool HasTurnRoutine => this.OnTurn != null && this.HasActiveTarget;

  public virtual bool HasTurnEndRoutine => this.OnTurnEnd != null && this.HasActiveTarget;

  public virtual bool HasPreAttackRoutine => this.PreAttack != null && this.HasActiveTarget;

  public virtual bool HasHitRoutine => this.OnHit != null && this.HasActiveTarget;

  public virtual bool HasPostHitRoutine => this.PostHit != null && this.HasActiveTarget;

  public virtual bool HasPostAttackRoutine => this.PostAttack != null && this.HasActiveTarget;

  public virtual bool HasApplyStatusRoutine => this.OnApplyStatus != null && this.HasActiveTarget;

  public virtual bool HasPostApplyStatusRoutine => this.PostApplyStatus != null && this.HasActiveTarget;

  public virtual bool HasEntityDestroyedRoutine => this.OnEntityDestroyed != null && this.HasActiveTarget;

  public virtual bool HasPreTriggerRoutine => this.PreTrigger != null && this.HasActiveTarget;

  public virtual bool HasPreCardPlayedRoutine => this.PreCardPlayed != null && this.HasActiveTarget;

  public virtual bool HasCardMoveRoutine => this.OnCardMove != null && this.HasActiveTarget;

  public virtual bool HasCardPlayedRoutine => this.OnCardPlayed != null && this.HasActiveTarget;

  public virtual bool HasEffectBonusChangedRoutine => this.OnEffectBonusChanged != null && this.HasActiveTarget;

  public virtual bool HasActionPerformedRoutine => this.OnActionPerformed != null && this.HasActiveTarget;

  public virtual bool HasBuildRoutine => this.OnBuild != null && this.HasActiveTarget;

  public virtual bool RunBeginEvent() => true;

  public virtual bool RunEndEvent() => true;

  public virtual bool RunEnableEvent(Entity entity) => true;

  public virtual bool RunDisableEvent(Entity entity) => true;

  public virtual bool RunStackEvent(int stacks) => true;

  public virtual bool RunTurnStartEvent(Entity entity) => true;

  public virtual bool RunTurnEvent(Entity entity) => true;

  public virtual bool RunTurnEndEvent(Entity entity) => true;

  public virtual bool RunPreAttackEvent(Hit hit) => true;

  public virtual bool RunHitEvent(Hit hit) => true;

  public virtual bool RunPostHitEvent(Hit hit) => true;

  public virtual bool RunPostAttackEvent(Hit hit) => true;

  public virtual bool RunApplyStatusEvent(StatusEffectApply apply) => true;

  public virtual bool RunPostApplyStatusEvent(StatusEffectApply apply) => true;

  public virtual bool RunEntityDestroyedEvent(Entity entity, DeathType deathType) => true;

  public virtual bool RunCardMoveEvent(Entity entity) => true;

  public virtual bool RunPreTriggerEvent(Trigger trigger) => true;

  public virtual bool RunPreCardPlayedEvent(Entity entity, Entity[] targets) => true;

  public virtual bool RunCardPlayedEvent(Entity entity, Entity[] targets) => true;

  public virtual bool RunEffectBonusChangedEvent() => true;

  public virtual bool RunActionPerformedEvent(PlayAction action) => true;

  public virtual bool RunBuildEvent(Entity entity) => true;

  public bool HasActiveTarget => (Object) this.target != (Object) null && this.target.enabled;

  public virtual IEnumerator BeginRoutine() => this.OnBegin();

  public virtual IEnumerator EndRoutine() => this.OnEnd();

  public virtual IEnumerator EnableRoutine(Entity entity) => this.OnEnable(entity);

  public virtual IEnumerator DisableRoutine(Entity entity) => this.OnDisable(entity);

  public virtual IEnumerator StackRoutine(int stacks) => this.OnStack(stacks);

  public virtual IEnumerator TurnStartRoutine(Entity entity) => this.OnTurnStart(entity);

  public virtual IEnumerator TurnRoutine(Entity entity) => this.OnTurn(entity);

  public virtual IEnumerator TurnEndRoutine(Entity entity) => this.OnTurnEnd(entity);

  public virtual IEnumerator PreAttackRoutine(Hit hit) => this.PreAttack(hit);

  public virtual IEnumerator HitRoutine(Hit hit) => this.OnHit(hit);

  public virtual IEnumerator PostHitRoutine(Hit hit) => this.PostHit(hit);

  public virtual IEnumerator PostAttackRoutine(Hit hit) => this.PostAttack(hit);

  public virtual IEnumerator ApplyStatusRoutine(StatusEffectApply apply) => this.OnApplyStatus(apply);

  public virtual IEnumerator PostApplyStatusRoutine(StatusEffectApply apply) => this.PostApplyStatus(apply);

  public virtual IEnumerator EntityDestroyedRoutine(Entity entity, DeathType deathType) => this.OnEntityDestroyed(entity, deathType);

  public virtual IEnumerator CardMoveRoutine(Entity entity) => this.OnCardMove(entity);

  public virtual IEnumerator PreTriggerRoutine(Trigger trigger) => this.PreTrigger(trigger);

  public virtual IEnumerator PreCardPlayedRoutine(Entity entity, Entity[] targets) => this.PreCardPlayed(entity, targets);

  public virtual IEnumerator CardPlayedRoutine(Entity entity, Entity[] targets) => this.OnCardPlayed(entity, targets);

  public virtual IEnumerator EffectBonusChangedRoutine() => this.OnEffectBonusChanged();

  public virtual IEnumerator ActionPerformedRoutine(PlayAction action) => this.OnActionPerformed(action);

  public virtual IEnumerator BuildRoutine(Entity entity) => this.OnBuild(entity);

  public void Apply(int count, Entity target, Entity applier)
  {
    this.count = count;
    this.target = target;
    this.applier = applier;
    target.statusEffects.Add(this);
    this.Init();
  }

  public virtual void Init()
  {
  }

  public IEnumerator CountDown(Entity entity, int amount)
  {
    if ((bool) (Object) this.target && this.target.enabled && (Object) entity == (Object) this.target)
      yield return (object) this.RemoveStacks(amount, false);
  }

  public virtual IEnumerator RemoveStacks(int amount, bool removeTemporary)
  {
    this.count -= amount;
    if (removeTemporary)
      this.temporary -= amount;
    if (this.count <= 0)
      yield return (object) this.Remove();
    this.target.PromptUpdate();
  }

  public IEnumerator Remove()
  {
    StatusEffectData statusEffectData = this;
    if (!statusEffectData.removing)
    {
      statusEffectData.removing = true;
      statusEffectData.target.statusEffects.Remove(statusEffectData);
      StatusEffectSystem.activeEffects.Remove(statusEffectData);
      statusEffectData.target.PromptUpdate();
      if (statusEffectData.RunEndEvent() && statusEffectData.HasEndRoutine)
        yield return (object) statusEffectData.EndRoutine();
      statusEffectData.Destroy();
    }
  }

  public void Destroy()
  {
    if (!(bool) (Object) this)
      return;
    Debug.Log((object) string.Format("[{0} {1}] removed from [{2}]", (object) this.name, (object) this.count, (bool) (Object) this.target ? (object) this.target.name : (object) "null"));
    StatusEffectSystem.activeEffects.Remove(this);
    Object.Destroy((Object) this);
  }

  public virtual int GetAmount()
  {
    if (!(bool) (Object) this.target || this.target.silenced)
      return 0;
    return !this.canBeBoosted ? this.count : Mathf.Max(0, Mathf.RoundToInt((float) (this.count + this.target.effectBonus) * this.target.effectFactor));
  }

  public Entity GetDamager()
  {
    if ((bool) (Object) this.applier)
      return this.applier;
    return !(bool) (Object) this.applierOwner || !(bool) (Object) this.applierOwner.entity ? (Entity) null : this.applierOwner.entity;
  }

  public CardContainer[] GetTargetContainers()
  {
    CardContainer[] containers = this.target.containers;
    return containers != null && containers.Length != 0 ? containers : this.target.preContainers;
  }

  public CardContainer[] GetTargetActualContainers()
  {
    List<CardContainer> actualContainers = this.target.actualContainers;
    return actualContainers != null && actualContainers.Count != 0 ? actualContainers.ToArray() : this.target.preActualContainers;
  }

  public delegate IEnumerator EffectEventHandler();

  public delegate IEnumerator EffectStackEventHandler(int stacks);

  public delegate IEnumerator EffectCharacterEventHandler(Character character);

  public delegate IEnumerator EffectEntityEventHandler(Entity entity);

  public delegate IEnumerator EffectEntityDeathEventHandler(Entity entity, DeathType deathType);

  public delegate IEnumerator EffectCardPlayEventHandler(Entity entity, Entity[] targets);

  public delegate IEnumerator EffectTriggerEventHandler(Trigger trigger);

  public delegate IEnumerator EffectCardMoveEventHandler(
    Entity entity,
    CardContainer[] fromContainers);

  public delegate IEnumerator EffectHitEventHandler(Hit hit);

  public delegate IEnumerator EffectApplyEventHandler(StatusEffectApply apply);

  public delegate IEnumerator EffectActionPerformedHandler(PlayAction action);
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectDemonize
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Demonize", fileName = "Demonize")]
public class StatusEffectDemonize : StatusEffectData
{
  public override void Init() => this.OnHit += new StatusEffectData.EffectHitEventHandler(this.DemonizeHit);

  public override bool RunHitEvent(Hit hit) => hit.Offensive && this.count > 0 && hit.damage > 0 && (Object) hit.target == (Object) this.target;

  public IEnumerator DemonizeHit(Hit hit)
  {
    hit.damage = Mathf.RoundToInt((float) hit.damage * 2f);
    ActionSequence action = new ActionSequence(this.CountDown());
    action.fixedPosition = true;
    action.note = "Count Down Demonize";
    ActionQueue.Stack((PlayAction) action);
    yield break;
  }

  public IEnumerator CountDown()
  {
    StatusEffectDemonize status = this;
    if ((bool) (Object) status && (bool) (Object) status.target && status.target.alive)
    {
      int amount = 1;
      Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref amount);
      if (amount != 0)
        yield return (object) status.CountDown(status.target, amount);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectDeployDraw
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Draw When Deployed", fileName = "Draw When Deployed")]
public class StatusEffectDeployDraw : StatusEffectData
{
  public override bool RunCardMoveEvent(Entity entity)
  {
    CardContainer[] preContainers = entity.preContainers;
    if ((Object) entity == (Object) this.target && (preContainers.Contains<CardContainer>(this.target.owner.handContainer) || preContainers.Contains<CardContainer>(this.target.owner.reserveContainer)) && Battle.IsOnBoard(entity))
      ActionQueue.Stack((PlayAction) new ActionDraw(this.target.owner, this.GetAmount()));
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectDestroyAfterUse
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Traits/Destroy After Use", fileName = "Destroy After Use")]
public class StatusEffectDestroyAfterUse : StatusEffectData
{
  public bool subbed;
  public bool destroy;

  public void OnDestroy() => this.Unsub();

  public void Sub()
  {
    global::Events.OnActionPerform += new UnityAction<PlayAction>(this.CheckAction);
    this.subbed = true;
  }

  public void Unsub()
  {
    if (!this.subbed)
      return;
    global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.CheckAction);
    this.subbed = false;
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (!this.subbed && (Object) entity == (Object) this.target && !this.target.silenced)
    {
      this.Sub();
      if (this.target.uses.current <= 1)
        this.destroy = true;
    }
    return false;
  }

  public void CheckAction(PlayAction action)
  {
    if (!(action is ActionReduceUses actionReduceUses) || !((Object) actionReduceUses.entity == (Object) this.target))
      return;
    this.Unsub();
    if (!this.destroy)
      return;
    this.target.alive = false;
    ActionSequence action1 = new ActionSequence(this.Consume());
    action1.note = "Consume";
    ActionQueue.Stack((PlayAction) action1);
  }

  public IEnumerator Consume()
  {
    StatusEffectDestroyAfterUse effectDestroyAfterUse = this;
    yield return (object) Sequences.WaitForAnimationEnd(effectDestroyAfterUse.target);
    effectDestroyAfterUse.target.alive = true;
    yield return (object) effectDestroyAfterUse.target.Kill(DeathType.Consume);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectDestroySelfAfterTurn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Destroy Self After Turn", fileName = "Destroy Self After Turn")]
public class StatusEffectDestroySelfAfterTurn : StatusEffectData
{
  public bool cardPlayed;

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (!this.cardPlayed && (Object) entity == (Object) this.target && !this.target.silenced)
    {
      ActionQueue.Add((PlayAction) new ActionKill(entity));
      this.cardPlayed = true;
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectDoubleAllXWhenDestroyed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Double All X When Destroyed", fileName = "Double All X When Destroyed")]
public class StatusEffectDoubleAllXWhenDestroyed : StatusEffectData
{
  [SerializeField]
  public StatusEffectData effectToDouble;

  public override void Init() => this.OnEntityDestroyed += new StatusEffectData.EffectEntityDeathEventHandler(this.DestroyCheck);

  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType) => (Object) entity == (Object) this.target;

  public IEnumerator DestroyCheck(Entity entity, DeathType deathType)
  {
    StatusEffectDoubleAllXWhenDestroyed allXwhenDestroyed = this;
    foreach (Entity allCard in Battle.GetAllCards())
    {
      if (allCard.enabled)
      {
        StatusEffectData status = allCard.FindStatus(allXwhenDestroyed.effectToDouble.type);
        if ((Object) status != (Object) null)
        {
          Hit hit = new Hit(allXwhenDestroyed.target, allCard, 0);
          hit.AddStatusEffect(allXwhenDestroyed.effectToDouble, status.count);
          yield return (object) hit.Process();
        }
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectDrawCards
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Draw Cards", fileName = "Draw Cards")]
public class StatusEffectDrawCards : StatusEffectData
{
  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if ((Object) entity == (Object) this.target)
      ActionQueue.Stack((PlayAction) new ActionDraw(this.target.owner, this.GetAmount()));
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectDrawOnKill
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Draw On Kill", fileName = "Draw On Kill")]
public class StatusEffectDrawOnKill : StatusEffectData
{
  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
  {
    if (entity.lastHit != null && (Object) entity.lastHit.attacker == (Object) this.target)
      ActionQueue.Stack((PlayAction) new ActionDraw(this.target.owner, this.GetAmount()));
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectFocus
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Focus", fileName = "Focus")]
public class StatusEffectFocus : StatusEffectData
{
  public override void Init() => this.PostApplyStatus += new StatusEffectData.EffectApplyEventHandler(this.ApplyStatus);

  public override bool RunPostApplyStatusEvent(StatusEffectApply apply) => (bool) (Object) apply.effectData && apply.count > 0 && apply.effectData.type == this.type && (Object) apply.target != (Object) this.target;

  public IEnumerator ApplyStatus(StatusEffectApply apply)
  {
    StatusEffectFocus status = this;
    int count = status.count;
    Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref count);
    if (count != 0)
      yield return (object) status.CountDown(status.target, count);
  }

  public override bool RunPreTriggerEvent(Trigger trigger)
  {
    if (!trigger.nullified && trigger.countsAsTrigger && trigger.entity.owner.team != this.target.owner.team && trigger.type == "basic" && Battle.IsOnBoard(trigger.entity))
      trigger.targets = trigger.entity.targetMode.GetTargets(trigger.entity, this.target, this.target.containers.RandomItem<CardContainer>());
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectFreeAction
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Free Action", fileName = "Free Action")]
public class StatusEffectFreeAction : StatusEffectData
{
  public bool hasEffect;

  public override void Init() => this.OnCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.CardPlayed);

  public override bool RunBeginEvent()
  {
    if (!this.target.inPlay || this.target.enabled)
    {
      this.hasEffect = true;
      if (!GameManager.paused && this.target.display is Card display)
      {
        display.itemHolderPet?.Show();
        Events.InvokeNoomlinShow(this.target);
      }
    }
    return false;
  }

  public override bool RunCardMoveEvent(Entity entity)
  {
    if ((Object) entity == (Object) this.target)
    {
      if (this.target.InHand())
        this.RunBeginEvent();
      else if (this.hasEffect && !Battle.IsOnBoard(entity.preContainers) && Battle.IsOnBoard(entity))
      {
        this.hasEffect = false;
        if (this.target.display is Card display)
          display.itemHolderPet?.Used();
        this.target.owner.freeAction = true;
      }
    }
    return false;
  }

  public override bool RunEnableEvent(Entity entity)
  {
    if ((Object) entity == (Object) this.target)
      this.RunBeginEvent();
    return false;
  }

  public override bool RunDisableEvent(Entity entity)
  {
    if ((Object) entity == (Object) this.target)
      this.RunEndEvent();
    return false;
  }

  public override bool RunEndEvent()
  {
    this.hasEffect = false;
    if ((Object) this.target != (Object) null && this.target.display is Card display)
      display.itemHolderPet?.Hide();
    return false;
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets) => this.hasEffect && (Object) entity == (Object) this.target && !this.target.silenced;

  public IEnumerator CardPlayed(Entity entity, Entity[] targets)
  {
    StatusEffectFreeAction effectFreeAction = this;
    effectFreeAction.hasEffect = false;
    if (effectFreeAction.target.display is Card display)
    {
      display.itemHolderPet?.Used();
      Events.InvokeNoomlinUsed(effectFreeAction.target);
      Mover mover = display.gameObject.AddComponent<Mover>();
      mover.velocity = new Vector3(PettyRandom.Range(0.0f, 1f).WithRandomSign(), -12f, 0.0f);
      mover.frictMult = 0.8f;
      effectFreeAction.target.wobbler?.WobbleRandom();
      yield return (object) Sequences.Wait(0.6f);
    }
    effectFreeAction.target.owner.freeAction = true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectFrost
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Frost", fileName = "Frost")]
public class StatusEffectFrost : StatusEffectData
{
  public int toClear;
  public int current;
  public int addedThisTurn;

  public override void Init() => this.OnActionPerformed += new StatusEffectData.EffectActionPerformedHandler(this.ActionPerformed);

  public override bool RunPreTriggerEvent(Trigger trigger)
  {
    if ((Object) trigger.entity == (Object) this.target)
      this.addedThisTurn = 0;
    return false;
  }

  public override bool RunStackEvent(int stacks)
  {
    this.current += stacks;
    this.target.tempDamage -= stacks;
    this.addedThisTurn += stacks;
    return false;
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (this.toClear == 0 && (Object) entity == (Object) this.target && this.count > 0 && targets != null && targets.Length > 0)
      this.toClear = this.current - this.addedThisTurn;
    return false;
  }

  public override bool RunActionPerformedEvent(PlayAction action) => this.toClear > 0 && ActionQueue.Empty;

  public IEnumerator ActionPerformed(PlayAction action)
  {
    yield return (object) this.Clear(this.toClear);
    this.toClear = 0;
  }

  public IEnumerator Clear(int amount)
  {
    StatusEffectFrost status = this;
    Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref amount);
    if (amount != 0)
    {
      status.current -= amount;
      status.target.tempDamage += amount;
      yield return (object) status.CountDown(status.target, amount);
    }
  }

  public override bool RunEndEvent()
  {
    this.target.tempDamage += this.current;
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectHaltX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Halt X", fileName = "Halt X")]
public class StatusEffectHaltX : StatusEffectData
{
  [SerializeField]
  public StatusEffectData effectToHalt;

  public override void Init()
  {
    Debug.Log((object) string.Format("→ Halting Count Down of [{0}] for [{1}]", (object) this.effectToHalt.name, (object) this.target));
    Events.OnStatusEffectCountDown += new Events.UnityActionCheck<StatusEffectData, int>(this.StatusCountDown);
  }

  public void OnDestroy()
  {
    Debug.Log((object) string.Format("→ Resuming Count Down of [{0}] for [{1}]", (object) this.effectToHalt.name, (object) this.target));
    Events.OnStatusEffectCountDown -= new Events.UnityActionCheck<StatusEffectData, int>(this.StatusCountDown);
  }

  public void StatusCountDown(StatusEffectData status, ref int amount)
  {
    if (!(status.type == this.effectToHalt.type) || !((Object) status.target == (Object) this.target))
      return;
    amount = 0;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectHaze
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Haze", fileName = "Haze")]
public class StatusEffectHaze : StatusEffectData
{
  public override void Init() => this.PreTrigger += new StatusEffectData.EffectTriggerEventHandler(this.EntityPreTrigger);

  public override bool RunPreTriggerEvent(Trigger trigger) => (Object) trigger.entity == (Object) this.target && trigger.type != "haze";

  public IEnumerator EntityPreTrigger(Trigger trigger)
  {
    StatusEffectHaze statusEffectHaze = this;
    if (statusEffectHaze.TryTargetRandomAlly(trigger))
    {
      trigger.type = "haze";
    }
    else
    {
      trigger.nullified = true;
      if (NoTargetTextSystem.Exists())
        yield return (object) NoTargetTextSystem.Run(statusEffectHaze.target, NoTargetType.NoAllyToAttack);
    }
    yield return (object) statusEffectHaze.RemoveStacks(1, false);
  }

  public bool TryTargetRandomAlly(Trigger trigger)
  {
    bool flag = false;
    Entity randomAlly = this.GetRandomAlly();
    if ((bool) (Object) randomAlly)
    {
      CardContainer targetContainer = randomAlly.containers.RandomItem<CardContainer>();
      Entity[] subsequentTargets = this.target.targetMode.GetSubsequentTargets(trigger.entity, randomAlly, targetContainer);
      trigger.targets = subsequentTargets;
      flag = true;
    }
    return flag;
  }

  public Entity GetRandomAlly()
  {
    List<Entity> allAllies = this.target.GetAllAllies();
    return allAllies.Count > 0 ? allAllies.RandomItem<Entity>() : (Entity) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectHitAlliesInRow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Hit Allies In Row", fileName = "Hit Allies In Row")]
public class StatusEffectHitAlliesInRow : StatusEffectData
{
  public override void Init() => this.PostAttack += new StatusEffectData.EffectHitEventHandler(this.CheckHit);

  public override bool RunPostAttackEvent(Hit hit) => (Object) hit.attacker == (Object) this.target && (Object) hit.target != (Object) null;

  public IEnumerator CheckHit(Hit hit)
  {
    StatusEffectHitAlliesInRow effectHitAlliesInRow = this;
    foreach (Entity target in hit.target.GetAlliesInRow())
      yield return (object) new Hit(effectHitAlliesInRow.target, target, effectHitAlliesInRow.GetAmount()).Process();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectHitAlliesInRowAndSelf
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Hit Allies In Row And Self", fileName = "Hit Allies In Row And Self")]
public class StatusEffectHitAlliesInRowAndSelf : StatusEffectData
{
  public override void Init() => this.PostAttack += new StatusEffectData.EffectHitEventHandler(this.CheckHit);

  public override bool RunPostAttackEvent(Hit hit) => (Object) hit.attacker == (Object) this.target;

  public IEnumerator CheckHit(Hit hit)
  {
    StatusEffectHitAlliesInRowAndSelf alliesInRowAndSelf = this;
    foreach (Entity target in alliesInRowAndSelf.target.GetAlliesInRow())
    {
      Hit hit1 = new Hit(alliesInRowAndSelf.target, target);
      hit1.AddAttackerStatuses();
      yield return (object) hit1.Process();
    }
    Hit hit2 = new Hit(alliesInRowAndSelf.target, alliesInRowAndSelf.target)
    {
      doAnimation = false
    };
    hit2.AddAttackerStatuses();
    yield return (object) hit2.Process();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectImmuneToX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Immunity/Immune To X", fileName = "Immune To X")]
public class StatusEffectImmuneToX : StatusEffectData
{
  [SerializeField]
  public string immunityType = "snow";
  public const int max = 1;

  public override void Init() => this.OnBegin += new StatusEffectData.EffectEventHandler(this.Begin);

  public IEnumerator Begin()
  {
    StatusEffectImmuneToX statusEffectImmuneToX = this;
    StatusEffectData status = statusEffectImmuneToX.target.FindStatus(statusEffectImmuneToX.immunityType);
    if ((bool) (Object) status && status.count > 1)
      yield return (object) status.RemoveStacks(status.count - 1, false);
  }

  public override bool RunApplyStatusEvent(StatusEffectApply apply)
  {
    if ((Object) apply.target == (Object) this.target && (bool) (Object) apply.effectData && apply.effectData.type == this.immunityType)
    {
      StatusEffectData status = this.target.FindStatus(this.immunityType);
      int count = (bool) (Object) status ? status.count : 0;
      apply.count = Mathf.Max(new int[1]{ 1 - count });
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectIncreaseAttackWhileAlone
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Increase Attack While Alone", fileName = "Increase Attack While Alone")]
public class StatusEffectIncreaseAttackWhileAlone : StatusEffectData
{
  [SerializeField]
  public bool active;
  [SerializeField]
  public int currentBonus;

  public override bool RunCardMoveEvent(Entity entity)
  {
    if ((Object) entity == (Object) this.target && this.active && !this.CanTrigger())
      this.Deactivate();
    else if ((((IList<CardContainer>) entity.preContainers).ContainsAny<CardContainer>((IEnumerable<CardContainer>) this.target.containers) || ((IList<CardContainer>) this.target.containers).ContainsAny<CardContainer>((IEnumerable<CardContainer>) entity.containers)) && this.CanTrigger())
      this.Check();
    return false;
  }

  public override bool RunEnableEvent(Entity entity)
  {
    this.Check();
    return false;
  }

  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
  {
    if (this.CanTrigger())
      this.Check();
    return false;
  }

  public override bool RunEffectBonusChangedEvent()
  {
    if (this.active)
    {
      this.Deactivate();
      this.Activate();
    }
    return false;
  }

  public void Check()
  {
    int num = this.CountOthersInMyRows();
    if (!this.active)
    {
      if (num > 0)
        return;
      this.Activate();
    }
    else
    {
      if (num <= 0)
        return;
      this.Deactivate();
    }
  }

  public override bool HasStackRoutine => this.active;

  public override bool RunStackEvent(int stacks)
  {
    if (this.active)
    {
      this.currentBonus += stacks;
      this.target.tempDamage += stacks;
      this.target.PromptUpdate();
    }
    return false;
  }

  public int CountOthersInMyRows()
  {
    int num = 0;
    foreach (CardContainer container in this.target.containers)
    {
      foreach (Entity entity in container)
      {
        if (entity.IsAliveAndExists() && (Object) entity != (Object) this.target)
          ++num;
      }
    }
    return num;
  }

  public void Activate()
  {
    this.active = true;
    this.currentBonus = this.GetAmount();
    this.target.tempDamage += this.currentBonus;
    this.target.PromptUpdate();
  }

  public void Deactivate()
  {
    this.active = false;
    this.target.tempDamage -= this.currentBonus;
    this.target.PromptUpdate();
  }

  public override bool CanTrigger() => base.CanTrigger() && Battle.IsOnBoard(this.target);
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectIncreaseAttackWhileDamaged
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Increase Attack While Damaged", fileName = "Increase Attack While Damaged")]
public class StatusEffectIncreaseAttackWhileDamaged : StatusEffectData
{
  [SerializeField]
  public StatusEffectData effectToGain;
  public int currentAmount;
  public bool active;

  public override bool RunEnableEvent(Entity entity) => (Object) entity == (Object) this.target;

  public override bool HasEnableRoutine => true;

  public override IEnumerator EnableRoutine(Entity entity) => this.Check();

  public override bool RunDisableEvent(Entity entity) => (Object) entity == (Object) this.target && this.currentAmount != 0;

  public override bool HasDisableRoutine => true;

  public override IEnumerator DisableRoutine(Entity entity) => this.Deactivate();

  public override bool RunPostHitEvent(Hit hit) => (Object) hit.target == (Object) this.target;

  public override bool HasPostHitRoutine => true;

  public override IEnumerator PostHitRoutine(Hit hit) => this.Check();

  public IEnumerator Check()
  {
    StatusEffectIncreaseAttackWhileDamaged attackWhileDamaged = this;
    if (attackWhileDamaged.target.alive)
    {
      if (!attackWhileDamaged.active)
      {
        if (attackWhileDamaged.target.hp.current < attackWhileDamaged.target.hp.max)
          yield return (object) attackWhileDamaged.Activate();
      }
      else if (attackWhileDamaged.target.hp.current >= attackWhileDamaged.target.hp.max)
        yield return (object) attackWhileDamaged.Deactivate();
    }
  }

  public IEnumerator Activate()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectIncreaseAttackWhileDamaged attackWhileDamaged = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      attackWhileDamaged.active = true;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    attackWhileDamaged.currentAmount = attackWhileDamaged.GetAmount();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) StatusEffectSystem.Apply(attackWhileDamaged.target, attackWhileDamaged.target, attackWhileDamaged.effectToGain, attackWhileDamaged.currentAmount, true);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public IEnumerator Deactivate()
  {
    StatusEffectIncreaseAttackWhileDamaged attackWhileDamaged = this;
    for (int index = attackWhileDamaged.target.statusEffects.Count - 1; index >= 0; --index)
    {
      StatusEffectData statusEffect = attackWhileDamaged.target.statusEffects[index];
      if ((bool) (Object) statusEffect && statusEffect.name == attackWhileDamaged.effectToGain.name)
      {
        yield return (object) statusEffect.RemoveStacks(attackWhileDamaged.currentAmount, true);
        break;
      }
    }
    attackWhileDamaged.currentAmount = 0;
    attackWhileDamaged.active = false;
  }

  public override bool RunEffectBonusChangedEvent()
  {
    if (this.target.enabled && this.active)
      ActionQueue.Add((PlayAction) new ActionSequence(this.ReAffect()));
    return false;
  }

  public IEnumerator ReAffect()
  {
    yield return (object) this.Deactivate();
    yield return (object) this.Activate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectIncreaseCountDown
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Increase Count Down", fileName = "Increase Count Down")]
public class StatusEffectIncreaseCountDown : StatusEffectData
{
  public override void Init() => Events.OnEntityCountDown += new Events.UnityActionCheck<Entity, int>(this.EntityCountDown);

  public void OnDestroy() => Events.OnEntityCountDown -= new Events.UnityActionCheck<Entity, int>(this.EntityCountDown);

  public void EntityCountDown(Entity entity, ref int amount)
  {
    if (!((Object) entity == (Object) this.target))
      return;
    amount += this.GetAmount();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInjury
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Injuries/Injury", fileName = "Injury")]
public class StatusEffectInjury : StatusEffectData
{
  [SerializeField]
  public float healthFactor = 0.5f;
  [SerializeField]
  public float damageFactor = 0.5f;
  [SerializeField]
  public int counterIncrease;
  public bool hasRun;

  public override void Init() => global::Events.OnBattleStart += new UnityAction(this.BattleStart);

  public void OnDestroy() => global::Events.OnBattleStart -= new UnityAction(this.BattleStart);

  public void BattleStart() => this.Run();

  public override bool RunBeginEvent()
  {
    if (!this.target.inPlay)
      this.Run();
    return false;
  }

  public void Run()
  {
    if (this.hasRun)
      return;
    this.hasRun = true;
    if (this.counterIncrease > 0 && this.target.counter.max > 0)
    {
      this.target.counter.max += this.counterIncrease;
      this.target.counter.current += this.counterIncrease;
    }
    this.target.damage.current = Mathf.CeilToInt((float) this.target.damage.current * this.damageFactor);
    this.target.hp.current = Mathf.CeilToInt((float) this.target.hp.current * this.healthFactor);
    this.target.PromptUpdate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInk
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Ink", fileName = "Ink")]
public class StatusEffectInk : StatusEffectData
{
  public bool primed;

  public override void Init() => this.OnCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.Check);

  public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (!this.primed && this.target.enabled && (Object) entity == (Object) this.target)
      this.primed = true;
    return false;
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets) => this.primed && this.target.enabled && (Object) entity == (Object) this.target;

  public IEnumerator Check(Entity entity, Entity[] targets)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectInk statusEffectInk = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    Hit hit = new Hit(statusEffectInk.target, statusEffectInk.target);
    hit.AddAttackerStatuses();
    ActionQueue.Stack((PlayAction) new ActionSequence(statusEffectInk.CountDown()), true);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) hit.Process();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public IEnumerator CountDown()
  {
    StatusEffectInk status = this;
    int amount = 1;
    Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref amount);
    if (amount != 0)
      yield return (object) status.CountDown(status.target, amount);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstant
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;

public abstract class StatusEffectInstant : StatusEffectData
{
  public override bool Instant => true;

  public override void Init() => this.OnBegin += new StatusEffectData.EffectEventHandler(this.Process);

  public override IEnumerator BeginRoutine()
  {
    StatusEffectInstant statusEffectInstant = this;
    if (statusEffectInstant.count > 0 || !statusEffectInstant.canBeBoosted || statusEffectInstant is StatusEffectInstantMultiple)
      yield return (object) statusEffectInstant.\u003C\u003En__0();
    else
      yield return (object) statusEffectInstant.Remove();
  }

  public virtual IEnumerator Process()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectInstant statusEffectInstant = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) statusEffectInstant.Remove();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override int GetAmount() => this.count;

  [CompilerGenerated]
  [DebuggerHidden]
  public IEnumerator \u003C\u003En__0() => base.BeginRoutine();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantApplyEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Apply Status Effect", fileName = "Apply Status Effect")]
public class StatusEffectInstantApplyEffect : StatusEffectInstant
{
  [SerializeField]
  public StatusEffectData effectToApply;
  [SerializeField]
  public ScriptableAmount scriptableAmount;

  public override IEnumerator Process()
  {
    StatusEffectInstantApplyEffect instantApplyEffect = this;
    int count = (bool) (Object) instantApplyEffect.scriptableAmount ? instantApplyEffect.scriptableAmount.Get(instantApplyEffect.target) : instantApplyEffect.GetAmount();
    yield return (object) StatusEffectSystem.Apply(instantApplyEffect.target, instantApplyEffect.applier, instantApplyEffect.effectToApply, count);
    yield return (object) instantApplyEffect.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantBudge
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Budge", fileName = "Budge")]
public class StatusEffectInstantBudge : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    StatusEffectInstantBudge effectInstantBudge = this;
    int[] rowIndices = Battle.instance.GetRowIndices(effectInstantBudge.target);
    if (rowIndices.Length == 1)
    {
      int rowIndex1 = rowIndices[0];
      int rowIndex2 = (rowIndex1 + 1) % Battle.instance.rowCount;
      if (rowIndex2 != rowIndex1)
      {
        CardContainer row = Battle.instance.GetRow(effectInstantBudge.target.owner, rowIndex2);
        if (row.Count < row.max)
        {
          Battle.instance.GetRow(effectInstantBudge.target.owner, rowIndex1);
          yield return (object) Sequences.CardMove(effectInstantBudge.target, new CardContainer[1]
          {
            row
          });
        }
      }
    }
    yield return (object) effectInstantBudge.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantCleanse
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Cleanse", fileName = "Cleanse")]
public class StatusEffectInstantCleanse : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    StatusEffectInstantCleanse effectInstantCleanse = this;
    for (int i = effectInstantCleanse.target.statusEffects.Count - 1; i >= 0; --i)
    {
      StatusEffectData statusEffect = effectInstantCleanse.target.statusEffects[i];
      if (statusEffect.offensive && statusEffect.visible && statusEffect.isStatus)
        yield return (object) statusEffect.Remove();
    }
    effectInstantCleanse.target.PromptUpdate();
    yield return (object) effectInstantCleanse.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantCopyEffects
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Copy Effects", fileName = "Copy Effects")]
public class StatusEffectInstantCopyEffects : StatusEffectInstant
{
  [SerializeField]
  public bool replaceAllEffects = true;
  [SerializeField]
  [HideIf("replaceAllEffects")]
  public int replaceEffectNumber;

  public override IEnumerator Process()
  {
    StatusEffectInstantCopyEffects instantCopyEffects = this;
    yield return instantCopyEffects.replaceAllEffects ? (object) instantCopyEffects.RemoveAllEffects() : (object) instantCopyEffects.RemoveEffect(instantCopyEffects.replaceEffectNumber);
    yield return (object) instantCopyEffects.AddEffectCopies();
    if (instantCopyEffects.applier.display is Card display)
      display.promptUpdateDescription = true;
    instantCopyEffects.applier.PromptUpdate();
    yield return (object) instantCopyEffects.\u003C\u003En__0();
  }

  public IEnumerator RemoveAllEffects()
  {
    StatusEffectInstantCopyEffects instantCopyEffects = this;
    foreach (Entity.TraitStacks trait in instantCopyEffects.applier.traits)
      trait.count = 0;
    yield return (object) instantCopyEffects.applier.UpdateTraits();
    Routine.Clump clump = new Routine.Clump();
    foreach (StatusEffectData statusEffectData in instantCopyEffects.applier.statusEffects.Where<StatusEffectData>((Func<StatusEffectData, bool>) (e => !e.visible)))
      clump.Add(statusEffectData.Remove());
    yield return (object) clump.WaitForEnd();
  }

  public IEnumerator RemoveEffect(int effectNumber)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectInstantCopyEffects instantCopyEffects = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) instantCopyEffects.applier.statusEffects[effectNumber].Remove();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public IEnumerator AddEffectCopies()
  {
    StatusEffectInstantCopyEffects instantCopyEffects = this;
    List<StatusEffectData> list = instantCopyEffects.target.statusEffects.Where<StatusEffectData>(new Func<StatusEffectData, bool>(instantCopyEffects.\u003CAddEffectCopies\u003Eb__5_0)).ToList<StatusEffectData>();
    foreach (Entity.TraitStacks trait in instantCopyEffects.target.traits)
    {
      foreach (StatusEffectData passiveEffect in trait.passiveEffects)
        list.Remove(passiveEffect);
      int count = trait.count - trait.tempCount;
      if (count > 0)
        instantCopyEffects.applier.GainTrait(trait.data, count);
    }
    foreach (StatusEffectData effectData in list)
      yield return (object) StatusEffectSystem.Apply(instantCopyEffects.applier, effectData.applier, effectData, effectData.count - effectData.temporary);
    instantCopyEffects.applier.attackEffects = ((IEnumerable<CardData.StatusEffectStacks>) CardData.StatusEffectStacks.Stack((IEnumerable<CardData.StatusEffectStacks>) instantCopyEffects.applier.attackEffects, (IEnumerable<CardData.StatusEffectStacks>) instantCopyEffects.target.attackEffects)).Select<CardData.StatusEffectStacks, CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, CardData.StatusEffectStacks>) (a => a.Clone())).ToList<CardData.StatusEffectStacks>();
    yield return (object) instantCopyEffects.applier.UpdateTraits();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();

  [CompilerGenerated]
  public bool \u003CAddEffectCopies\u003Eb__5_0(StatusEffectData e) => e.count > e.temporary && !e.isStatus && (UnityEngine.Object) e != (UnityEngine.Object) this && e.HasDescOrIsKeyword;
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantDoubleNegativeEffects
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Double Negative Effects", fileName = "Double Negative Effects")]
public class StatusEffectInstantDoubleNegativeEffects : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    StatusEffectInstantDoubleNegativeEffects doubleNegativeEffects = this;
    Hit hit = new Hit(doubleNegativeEffects.applier, doubleNegativeEffects.target, 0);
    for (int index = doubleNegativeEffects.target.statusEffects.Count - 1; index >= 0; --index)
    {
      StatusEffectData statusEffect = doubleNegativeEffects.target.statusEffects[index];
      if (statusEffect.offensive && statusEffect.visible)
        hit.AddStatusEffect(statusEffect, statusEffect.count);
    }
    if (hit.Offensive)
      yield return (object) hit.Process();
    yield return (object) doubleNegativeEffects.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantDoubleX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Double X", fileName = "Double X")]
public class StatusEffectInstantDoubleX : StatusEffectInstant
{
  public StatusEffectData statusToDouble;
  [SerializeField]
  public bool countsAsHit = true;

  public override IEnumerator Process()
  {
    StatusEffectInstantDoubleX effectInstantDoubleX = this;
    StatusEffectData statusEffectData = effectInstantDoubleX.target.statusEffects.Find(new Predicate<StatusEffectData>(effectInstantDoubleX.\u003CProcess\u003Eb__2_0));
    if ((bool) (UnityEngine.Object) statusEffectData)
    {
      double num = (double) effectInstantDoubleX.target.curveAnimator.Ping();
      Hit hit = new Hit(effectInstantDoubleX.applier, effectInstantDoubleX.target, 0)
      {
        countsAsHit = effectInstantDoubleX.countsAsHit
      };
      hit.AddStatusEffect(effectInstantDoubleX.statusToDouble, statusEffectData.count);
      yield return (object) hit.Process();
    }
    yield return (object) effectInstantDoubleX.\u003C\u003En__0();
  }

  [CompilerGenerated]
  public bool \u003CProcess\u003Eb__2_0(StatusEffectData a) => a.name == this.statusToDouble.name;

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantDraw
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Draw", fileName = "Instant Draw")]
public class StatusEffectInstantDraw : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    StatusEffectInstantDraw effectInstantDraw = this;
    Character player = References.Player;
    if (player.drawContainer.Empty && player.discardContainer.Empty)
    {
      if (NoTargetTextSystem.Exists())
        yield return (object) NoTargetTextSystem.Run(effectInstantDraw.target, NoTargetType.NoCardsToDraw);
    }
    else
      ActionQueue.Stack((PlayAction) new ActionDraw(player, effectInstantDraw.GetAmount()), true);
    yield return (object) effectInstantDraw.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantEat
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Eat", fileName = "Eat")]
public class StatusEffectInstantEat : StatusEffectInstant
{
  [SerializeField]
  public bool gainHealth = true;
  [SerializeField]
  public bool gainAttack = true;
  [SerializeField]
  public bool gainEffects = true;
  [SerializeField]
  [ShowIf("gainEffects")]
  public TraitData[] illegalTraits;
  [SerializeField]
  [ShowIf("gainEffects")]
  public StatusEffectData[] illegalEffects;

  public override IEnumerator Process()
  {
    StatusEffectInstantEat effectInstantEat = this;
    if ((bool) (UnityEngine.Object) effectInstantEat.applier && effectInstantEat.applier.alive && (bool) (UnityEngine.Object) effectInstantEat.target && effectInstantEat.target.alive && (effectInstantEat.gainHealth || effectInstantEat.gainAttack || effectInstantEat.gainEffects))
      yield return (object) effectInstantEat.Eat();
    effectInstantEat.target.forceKill = true;
    yield return (object) effectInstantEat.target.Kill(DeathType.Eaten);
    yield return (object) effectInstantEat.\u003C\u003En__0();
  }

  public IEnumerator Eat()
  {
    StatusEffectInstantEat effectInstantEat = this;
    if (effectInstantEat.gainHealth)
      effectInstantEat.GainHealth();
    if (effectInstantEat.gainAttack)
      effectInstantEat.GainAttack();
    if (effectInstantEat.gainEffects)
    {
      yield return (object) effectInstantEat.GainEffects();
      effectInstantEat.applier.PromptUpdate();
    }
  }

  public void GainHealth()
  {
    this.applier.hp.current += this.target.hp.current;
    this.applier.hp.max += this.target.hp.max;
  }

  public void GainAttack()
  {
    this.applier.damage.current += this.target.damage.current;
    this.applier.damage.max += this.target.damage.max;
  }

  public IEnumerator GainEffects()
  {
    StatusEffectInstantEat effectInstantEat = this;
    effectInstantEat.applier.attackEffects = CardData.StatusEffectStacks.Stack((IEnumerable<CardData.StatusEffectStacks>) effectInstantEat.applier.attackEffects, (IEnumerable<CardData.StatusEffectStacks>) effectInstantEat.target.attackEffects).ToList<CardData.StatusEffectStacks>();
    List<StatusEffectData> list = effectInstantEat.target.statusEffects.Where<StatusEffectData>(new Func<StatusEffectData, bool>(effectInstantEat.\u003CGainEffects\u003Eb__9_0)).ToList<StatusEffectData>();
    foreach (Entity.TraitStacks trait in effectInstantEat.target.traits)
    {
      foreach (StatusEffectData passiveEffect in trait.passiveEffects)
        list.Remove(passiveEffect);
      int count = trait.count - trait.tempCount;
      if (count > 0 && !((IEnumerable<TraitData>) effectInstantEat.illegalTraits).Select<TraitData, string>((Func<TraitData, string>) (t => t.name)).Contains<string>(trait.data.name))
        effectInstantEat.applier.GainTrait(trait.data, count);
    }
    foreach (StatusEffectData effectData in list)
      yield return (object) StatusEffectSystem.Apply(effectInstantEat.applier, effectInstantEat.target, effectData, effectData.count);
    yield return (object) effectInstantEat.applier.UpdateTraits();
    effectInstantEat.applier.display.promptUpdateDescription = true;
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();

  [CompilerGenerated]
  public bool \u003CGainEffects\u003Eb__9_0(StatusEffectData e1) => (UnityEngine.Object) e1 != (UnityEngine.Object) this && !((IEnumerable<StatusEffectData>) this.illegalEffects).Select<StatusEffectData, string>((Func<StatusEffectData, string>) (e2 => e2.name)).Contains<string>(e1.name);
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantEatSomething
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Eat Something", fileName = "Eat Something")]
public class StatusEffectInstantEatSomething : StatusEffectInstant
{
  [SerializeField]
  public float delayAfter = 0.25f;
  [SerializeField]
  public StatusEffectData eatEffect;
  [SerializeField]
  public Targets.Flag targetFlags;

  public override IEnumerator Process()
  {
    StatusEffectInstantEatSomething instantEatSomething = this;
    List<Entity> entityList = Targets.Get(instantEatSomething.target, instantEatSomething.targetFlags, instantEatSomething.eatEffect, instantEatSomething.targetConstraints);
    if (entityList != null && entityList.Count > 0)
    {
      foreach (Entity entity in entityList)
      {
        if (entity.IsAliveAndExists())
        {
          Trigger trigger = new Trigger(instantEatSomething.target, instantEatSomething.target, "eat", new Entity[1]
          {
            entity
          })
          {
            countsAsTrigger = false
          };
          Hit hit = new Hit(instantEatSomething.target, entity, 0)
          {
            canBeNullified = false,
            canRetaliate = false,
            damageType = "eat",
            trigger = trigger
          };
          hit.AddStatusEffect(instantEatSomething.eatEffect, 1);
          trigger.hits = new Hit[1]{ hit };
          yield return (object) trigger.Process();
        }
      }
      yield return (object) Sequences.Wait(instantEatSomething.delayAfter);
    }
    yield return (object) instantEatSomething.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantEscape
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Escape", fileName = "Escape")]
public class StatusEffectInstantEscape : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectInstantEscape effectInstantEscape = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    ActionQueue.Add((PlayAction) new ActionFlee(effectInstantEscape.target));
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) effectInstantEscape.\u003C\u003En__0();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantFillBoard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Fill Board", fileName = "Fill Board")]
public class StatusEffectInstantFillBoard : StatusEffectInstant
{
  [SerializeField]
  public bool doPing = true;
  [SerializeField]
  public EventReference sfxEvent;
  [SerializeField]
  public CardData[] withCards;
  public readonly List<CardData> pool = new List<CardData>();

  public override IEnumerator Process()
  {
    StatusEffectInstantFillBoard instantFillBoard = this;
    if (instantFillBoard.doPing)
    {
      double num = (double) instantFillBoard.target.curveAnimator.Ping();
      SfxSystem.OneShot(instantFillBoard.sfxEvent);
      Events.InvokeScreenRumble(0.0f, 0.4f, 0.0f, 0.4f, 0.1f, 0.4f);
    }
    List<CardContainer> rows = References.Battle.GetRows(instantFillBoard.target.owner);
    List<CardSlot> cardSlotList = new List<CardSlot>();
    foreach (CardContainer cardContainer in rows)
    {
      if (cardContainer is CardSlotLane cardSlotLane)
        cardSlotList.AddRange(cardSlotLane.slots.Where<CardSlot>((Func<CardSlot, bool>) (slot => slot.Empty)));
    }
    foreach (CardSlot slot in cardSlotList)
    {
      Card card = CardManager.Get(instantFillBoard.Pull().Clone(), References.Battle.playerCardController, instantFillBoard.target.owner, true, instantFillBoard.target.owner.team == References.Player.team);
      yield return (object) card.UpdateData(false);
      instantFillBoard.target.owner.reserveContainer.Add(card.entity);
      instantFillBoard.target.owner.reserveContainer.SetChildPosition(card.entity);
      ActionQueue.Stack((PlayAction) new ActionMove(card.entity, new CardContainer[1]
      {
        (CardContainer) slot
      }), true);
      ActionQueue.Stack((PlayAction) new ActionRunEnableEvent(card.entity), true);
      card = (Card) null;
    }
    yield return (object) instantFillBoard.\u003C\u003En__0();
  }

  public CardData Pull()
  {
    if (this.pool.Count <= 0)
      this.pool.AddRange((IEnumerable<CardData>) this.withCards);
    return this.pool.TakeRandom<CardData>();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantFlee
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Flee", fileName = "Flee")]
public class StatusEffectInstantFlee : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    StatusEffectInstantFlee effectInstantFlee = this;
    yield return (object) Sequences.CardRecall(effectInstantFlee.target);
    yield return (object) effectInstantFlee.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantGainGold
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Gain Gold", fileName = "Gain Gold")]
public class StatusEffectInstantGainGold : StatusEffectInstant
{
  [SerializeField]
  public bool take;

  public override IEnumerator Process()
  {
    StatusEffectInstantGainGold effectInstantGainGold = this;
    if ((bool) (Object) effectInstantGainGold.target)
    {
      Character player = References.Player;
      if ((bool) (Object) player && player.data != null && (bool) (Object) player.data.inventory)
      {
        int amount1 = effectInstantGainGold.GetAmount();
        if (effectInstantGainGold.take)
        {
          int amount2 = Mathf.Min(player.data.inventory.gold.Value, amount1);
          if (amount2 > 0)
            player.SpendGold(amount2);
        }
        else
          Events.InvokeDropGold(amount1, effectInstantGainGold.applier.data.name, player, effectInstantGainGold.applier.transform.position);
      }
    }
    yield return (object) effectInstantGainGold.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantGainGoldRange
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Gain Gold Range", fileName = "Gain Gold Range")]
public class StatusEffectInstantGainGoldRange : StatusEffectInstant
{
  [SerializeField]
  public Vector2Int range;

  public override IEnumerator Process()
  {
    StatusEffectInstantGainGoldRange instantGainGoldRange = this;
    Character owner = instantGainGoldRange.target.owner;
    if ((Object) owner != (Object) null)
    {
      int amount = instantGainGoldRange.range.Random();
      owner.GainGold(amount);
    }
    yield return (object) instantGainGoldRange.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantGainTrait
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Gain Trait", fileName = "Gain Trait")]
public class StatusEffectInstantGainTrait : StatusEffectInstant
{
  public TraitData traitToGain;

  public override IEnumerator Process()
  {
    StatusEffectInstantGainTrait instantGainTrait = this;
    int a = instantGainTrait.GetAmount();
    TraitData traitData = Object.Instantiate<TraitData>(instantGainTrait.traitToGain);
    traitData.name = instantGainTrait.traitToGain.name;
    instantGainTrait.target.data.traits.Add(new CardData.TraitStacks()
    {
      data = traitData,
      count = a
    });
    StatusEffectData[] statusEffectDataArray = traitData.effects;
    for (int index = 0; index < statusEffectDataArray.Length; ++index)
    {
      StatusEffectData effectData = statusEffectDataArray[index];
      yield return (object) StatusEffectSystem.Apply(instantGainTrait.target, instantGainTrait.applier, effectData, a);
    }
    statusEffectDataArray = (StatusEffectData[]) null;
    instantGainTrait.target.display.promptUpdateDescription = true;
    instantGainTrait.target.PromptUpdate();
    yield return (object) instantGainTrait.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantHeal
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Heal", fileName = "Heal")]
public class StatusEffectInstantHeal : StatusEffectInstant
{
  [SerializeField]
  public bool doPing = true;

  public override IEnumerator Process()
  {
    StatusEffectInstantHeal effectInstantHeal = this;
    if (effectInstantHeal.target.alive)
    {
      if (effectInstantHeal.doPing)
      {
        CurveAnimator curveAnimator = effectInstantHeal.target.curveAnimator;
        if (curveAnimator != null)
        {
          double num = (double) curveAnimator.Ping();
        }
      }
      yield return (object) new Hit(effectInstantHeal.applier, effectInstantHeal.target, -effectInstantHeal.GetAmount()).Process();
    }
    yield return (object) effectInstantHeal.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantHealFullGainEqualX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Heal Full, Gain Equal X", fileName = "Heal Full, Gain Equal X")]
public class StatusEffectInstantHealFullGainEqualX : StatusEffectInstant
{
  [SerializeField]
  public StatusEffectData effectToGain;

  public override IEnumerator Process()
  {
    StatusEffectInstantHealFullGainEqualX healFullGainEqualX = this;
    int num1 = healFullGainEqualX.target.hp.max - healFullGainEqualX.target.hp.current;
    double num2 = (double) healFullGainEqualX.target.curveAnimator.Ping();
    healFullGainEqualX.target.hp.current = healFullGainEqualX.target.hp.max;
    Hit hit = new Hit(healFullGainEqualX.target, healFullGainEqualX.target, 0);
    hit.AddStatusEffect(healFullGainEqualX.effectToGain, healFullGainEqualX.GetAmount() * num1);
    yield return (object) hit.Process();
    yield return (object) healFullGainEqualX.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantIncreaseAttack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Increase Attack", fileName = "Increase Attack")]
public class StatusEffectInstantIncreaseAttack : StatusEffectInstant
{
  [SerializeField]
  public ScriptableAmount scriptableAmount;

  public override IEnumerator Process()
  {
    StatusEffectInstantIncreaseAttack instantIncreaseAttack = this;
    instantIncreaseAttack.target.damage.current += (bool) (Object) instantIncreaseAttack.scriptableAmount ? instantIncreaseAttack.scriptableAmount.Get(instantIncreaseAttack.target) : instantIncreaseAttack.GetAmount();
    instantIncreaseAttack.target.PromptUpdate();
    yield return (object) instantIncreaseAttack.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantIncreaseEffects
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Increase Effects", fileName = "Increase Effects")]
public class StatusEffectInstantIncreaseEffects : StatusEffectInstant
{
  [SerializeField]
  public bool allEffects = true;
  [SerializeField]
  [HideIf("allEffects")]
  public int attackEffectIndex = -1;
  [SerializeField]
  [HideIf("allEffects")]
  public int passiveEffectIndex = -1;

  public override IEnumerator Process()
  {
    StatusEffectInstantIncreaseEffects instantIncreaseEffects = this;
    int amount = instantIncreaseEffects.GetAmount();
    if ((bool) (Object) instantIncreaseEffects.target.curveAnimator)
    {
      double num = (double) instantIncreaseEffects.target.curveAnimator.Ping();
    }
    if (instantIncreaseEffects.allEffects)
    {
      instantIncreaseEffects.target.effectBonus += amount;
      instantIncreaseEffects.target.PromptUpdate();
    }
    else
    {
      if (instantIncreaseEffects.attackEffectIndex >= 0)
      {
        instantIncreaseEffects.target.attackEffects[instantIncreaseEffects.attackEffectIndex].count += amount;
        if (instantIncreaseEffects.target.display is Card display)
          display.promptUpdateDescription = true;
        instantIncreaseEffects.target.PromptUpdate();
      }
      if (instantIncreaseEffects.passiveEffectIndex >= 0)
      {
        instantIncreaseEffects.target.statusEffects[instantIncreaseEffects.passiveEffectIndex].count += amount;
        if (instantIncreaseEffects.target.display is Card display)
          display.promptUpdateDescription = true;
        instantIncreaseEffects.target.PromptUpdate();
      }
    }
    yield return (object) instantIncreaseEffects.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantIncreaseMaxCounter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Increase Max Counter", fileName = "Increase Max Counter")]
public class StatusEffectInstantIncreaseMaxCounter : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectInstantIncreaseMaxCounter increaseMaxCounter = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    increaseMaxCounter.target.counter.current += increaseMaxCounter.GetAmount();
    increaseMaxCounter.target.counter.max += increaseMaxCounter.GetAmount();
    increaseMaxCounter.target.PromptUpdate();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) increaseMaxCounter.\u003C\u003En__0();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantIncreaseMaxHealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Increase Max Health", fileName = "Increase Max Health")]
public class StatusEffectInstantIncreaseMaxHealth : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectInstantIncreaseMaxHealth increaseMaxHealth = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    increaseMaxHealth.target.hp.max += increaseMaxHealth.GetAmount();
    increaseMaxHealth.target.hp.current += increaseMaxHealth.GetAmount();
    increaseMaxHealth.target.PromptUpdate();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) increaseMaxHealth.\u003C\u003En__0();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantKill
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Kill", fileName = "Kill")]
public class StatusEffectInstantKill : StatusEffectInstant
{
  [SerializeField]
  public TargetConstraint[] killConstraints;
  [SerializeField]
  public string[] statusesToClear = new string[3]
  {
    "block",
    "shell",
    "scrap"
  };

  public override IEnumerator Process()
  {
    StatusEffectInstantKill effectInstantKill = this;
    Routine.Clump clump = new Routine.Clump();
    foreach (string type in effectInstantKill.statusesToClear)
    {
      StatusEffectData status = effectInstantKill.target.FindStatus(type);
      if ((UnityEngine.Object) status != (UnityEngine.Object) null)
        clump.Add(status.Remove());
    }
    yield return (object) clump.WaitForEnd();
    if (effectInstantKill.killConstraints == null || effectInstantKill.killConstraints.Length == 0 || ((IEnumerable<TargetConstraint>) effectInstantKill.killConstraints).Any<TargetConstraint>(new Func<TargetConstraint, bool>(effectInstantKill.\u003CProcess\u003Eb__2_0)))
      effectInstantKill.target.forceKill = true;
    yield return (object) effectInstantKill.\u003C\u003En__0();
  }

  [CompilerGenerated]
  public bool \u003CProcess\u003Eb__2_0(TargetConstraint a) => a.Check(this.target);

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantLoseX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Lose X", fileName = "Lose X")]
public class StatusEffectInstantLoseX : StatusEffectInstant
{
  [SerializeField]
  public StatusEffectData statusToLose;
  [SerializeField]
  public bool doPing;

  public override IEnumerator Process()
  {
    StatusEffectInstantLoseX effectInstantLoseX = this;
    StatusEffectData statusEffectData = effectInstantLoseX.target.statusEffects.Find(new Predicate<StatusEffectData>(effectInstantLoseX.\u003CProcess\u003Eb__2_0));
    if ((bool) (UnityEngine.Object) statusEffectData)
    {
      if (effectInstantLoseX.doPing)
      {
        double num = (double) effectInstantLoseX.target.curveAnimator.Ping();
      }
      yield return (object) statusEffectData.RemoveStacks(effectInstantLoseX.count, false);
    }
    yield return (object) effectInstantLoseX.\u003C\u003En__0();
  }

  [CompilerGenerated]
  public bool \u003CProcess\u003Eb__2_0(StatusEffectData a) => a.name == this.statusToLose.name;

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantMultiple
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Multiple", fileName = "Instant Apply X")]
public class StatusEffectInstantMultiple : StatusEffectInstant
{
  public StatusEffectInstant[] effects;

  public override bool CanStackActions => false;

  public override IEnumerator Process()
  {
    StatusEffectInstantMultiple effectInstantMultiple = this;
    int amount = effectInstantMultiple.GetAmount();
    Routine.Clump clump = new Routine.Clump();
    foreach (StatusEffectInstant effect in effectInstantMultiple.effects)
    {
      if (!effect.canBeBoosted || amount > 0)
        clump.Add(StatusEffectSystem.Apply(effectInstantMultiple.target, effectInstantMultiple.applier, (StatusEffectData) effect, amount, true));
    }
    yield return (object) clump.WaitForEnd();
    yield return (object) effectInstantMultiple.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantPull
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Pull", fileName = "Pull")]
public class StatusEffectInstantPull : StatusEffectInstant
{
  public const int insertPos = 0;

  public override IEnumerator Process()
  {
    StatusEffectInstantPull effectInstantPull = this;
    int[] rowIndices = Battle.instance.GetRowIndices(effectInstantPull.target);
    if (rowIndices.Length == 1)
    {
      CardContainer row1 = Battle.instance.GetRow(effectInstantPull.target.owner, rowIndices[0]);
      int index = row1.IndexOf(effectInstantPull.target);
      if (index != 0)
      {
        row1.RemoveAt(index);
        bool flag = false;
        if (row1 is CardSlotLane)
        {
          flag = (Object) row1[0] == (Object) null;
          if (!flag)
          {
            flag = row1.PushBackwards(0);
            if (!flag)
              flag = row1.PushForwards(0);
          }
        }
        row1.Insert(flag ? 0 : index, effectInstantPull.target);
        if (flag)
        {
          foreach (CardContainer row2 in References.Battle.GetRows(effectInstantPull.target.owner))
            row2.TweenChildPositions();
        }
      }
    }
    yield return (object) effectInstantPull.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantPush
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Push", fileName = "Push")]
public class StatusEffectInstantPush : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    StatusEffectInstantPush effectInstantPush = this;
    int[] rowIndices = Battle.instance.GetRowIndices(effectInstantPush.target);
    if (rowIndices.Length == 1)
    {
      CardContainer row = Battle.instance.GetRow(effectInstantPush.target.owner, rowIndices[0]);
      int index1 = row.IndexOf(effectInstantPush.target);
      int index2 = Mathf.Min(index1 + effectInstantPush.GetAmount(), row.max - 1);
      if (index1 != index2)
      {
        row.RemoveAt(index1);
        row.Insert(index2, effectInstantPush.target);
        foreach (Entity child in row)
          row.TweenChildPosition(child);
      }
    }
    yield return (object) effectInstantPush.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantReduceAttack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Reduce Attack", fileName = "Reduce Attack")]
public class StatusEffectInstantReduceAttack : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectInstantReduceAttack instantReduceAttack = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    instantReduceAttack.target.damage.current -= instantReduceAttack.GetAmount();
    instantReduceAttack.target.PromptUpdate();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) instantReduceAttack.\u003C\u003En__0();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantReduceCounter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Reduce Counter", fileName = "Reduce Counter")]
public class StatusEffectInstantReduceCounter : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    StatusEffectInstantReduceCounter instantReduceCounter = this;
    yield return (object) new Hit(instantReduceCounter.applier, instantReduceCounter.target, 0)
    {
      countsAsHit = false,
      counterReduction = instantReduceCounter.GetAmount()
    }.Process();
    yield return (object) instantReduceCounter.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantReduceEffects
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Reduce Effects", fileName = "Reduce Effects")]
public class StatusEffectInstantReduceEffects : StatusEffectInstant
{
  [SerializeField]
  public bool allEffects = true;
  [SerializeField]
  [HideIf("allEffects")]
  public int attackEffectIndex = -1;
  [SerializeField]
  [HideIf("allEffects")]
  public int passiveEffectIndex = -1;

  public override IEnumerator Process()
  {
    StatusEffectInstantReduceEffects instantReduceEffects = this;
    int amount = instantReduceEffects.GetAmount();
    if ((bool) (Object) instantReduceEffects.target.curveAnimator)
    {
      double num = (double) instantReduceEffects.target.curveAnimator.Ping();
    }
    if (instantReduceEffects.allEffects)
    {
      instantReduceEffects.target.effectBonus -= amount;
      instantReduceEffects.target.PromptUpdate();
    }
    else
    {
      if (instantReduceEffects.attackEffectIndex >= 0)
      {
        instantReduceEffects.target.attackEffects[instantReduceEffects.attackEffectIndex].count -= amount;
        if (instantReduceEffects.target.display is Card display)
          display.promptUpdateDescription = true;
        instantReduceEffects.target.PromptUpdate();
      }
      if (instantReduceEffects.passiveEffectIndex >= 0)
      {
        instantReduceEffects.target.statusEffects[instantReduceEffects.passiveEffectIndex].count -= amount;
        if (instantReduceEffects.target.display is Card display)
          display.promptUpdateDescription = true;
        instantReduceEffects.target.PromptUpdate();
      }
    }
    yield return (object) instantReduceEffects.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantReduceMaxCounter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Reduce Max Counter", fileName = "Reduce Max Counter")]
public class StatusEffectInstantReduceMaxCounter : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectInstantReduceMaxCounter reduceMaxCounter = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    reduceMaxCounter.target.counter.current = Mathf.Max(0, reduceMaxCounter.target.counter.current - reduceMaxCounter.GetAmount());
    reduceMaxCounter.target.counter.max = Mathf.Max(1, reduceMaxCounter.target.counter.max - reduceMaxCounter.GetAmount());
    reduceMaxCounter.target.PromptUpdate();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) reduceMaxCounter.\u003C\u003En__0();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantReduceMaxHealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Reduce Max Health", fileName = "Reduce Max Health")]
public class StatusEffectInstantReduceMaxHealth : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectInstantReduceMaxHealth instantReduceMaxHealth = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    instantReduceMaxHealth.target.hp.max -= instantReduceMaxHealth.GetAmount();
    instantReduceMaxHealth.target.hp.current -= instantReduceMaxHealth.GetAmount();
    instantReduceMaxHealth.target.PromptUpdate();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) instantReduceMaxHealth.\u003C\u003En__0();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantSacrifice
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Sacrifice", fileName = "Sacrifice")]
public class StatusEffectInstantSacrifice : StatusEffectInstant
{
  public override IEnumerator Process()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectInstantSacrifice instantSacrifice = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) instantSacrifice.target.Kill();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantSetHealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Set Health", fileName = "Set Health")]
public class StatusEffectInstantSetHealth : StatusEffectInstant
{
  [SerializeField]
  public bool maxOnly;
  [SerializeField]
  public bool equalAmount = true;
  [SerializeField]
  [HideIf("equalAmount")]
  public StatusEffectInstantSetHealth setMaxHealthEffect;
  [SerializeField]
  [HideIf("equalAmount")]
  public float factor = 1f;

  public override IEnumerator Process()
  {
    StatusEffectInstantSetHealth instantSetHealth = this;
    if (instantSetHealth.equalAmount)
    {
      int amount = instantSetHealth.GetAmount();
      instantSetHealth.target.hp.max = amount;
      instantSetHealth.target.hp.current = instantSetHealth.maxOnly ? Mathf.Min(instantSetHealth.target.hp.current, instantSetHealth.target.hp.max) : amount;
    }
    else if ((double) instantSetHealth.factor < 1.0)
    {
      int count = Mathf.CeilToInt((float) instantSetHealth.target.hp.max * instantSetHealth.factor);
      int damage = Mathf.FloorToInt((float) instantSetHealth.target.hp.current * instantSetHealth.factor);
      if (damage > 0)
      {
        Hit hit = new Hit((Entity) null, instantSetHealth.target, damage)
        {
          countsAsHit = false,
          screenShake = 0.0f
        };
        hit.AddStatusEffect((StatusEffectData) instantSetHealth.setMaxHealthEffect, count);
        yield return (object) hit.Process();
      }
    }
    else
    {
      instantSetHealth.target.hp.max = Mathf.CeilToInt((float) instantSetHealth.target.hp.max * instantSetHealth.factor);
      instantSetHealth.target.hp.current = Mathf.CeilToInt((float) instantSetHealth.target.hp.current * instantSetHealth.factor);
    }
    instantSetHealth.target.PromptUpdate();
    yield return (object) instantSetHealth.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantSplit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Instant/Split", fileName = "Split")]
public class StatusEffectInstantSplit : StatusEffectInstant
{
  [SerializeField]
  public StatusEffectInstantSplit.Profile[] profiles;
  public readonly List<Entity> newCards = new List<Entity>();

  public bool CanSplit()
  {
    if (this.target.height > 1)
      return true;
    foreach (CardContainer cardContainer in References.Battle.rows[this.target.owner])
    {
      if (cardContainer.Count < cardContainer.max)
        return true;
    }
    return false;
  }

  public override IEnumerator Process()
  {
    StatusEffectInstantSplit effectInstantSplit = this;
    if (effectInstantSplit.CanSplit())
      yield return effectInstantSplit.target.height > 1 ? (object) effectInstantSplit.SplitDoubleHeight() : (object) effectInstantSplit.Split();
    else if (NoTargetTextSystem.Exists())
      yield return (object) NoTargetTextSystem.Run(effectInstantSplit.target, NoTargetType.CantSplit);
    yield return (object) effectInstantSplit.\u003C\u003En__0();
  }

  public IEnumerator Split()
  {
    StatusEffectInstantSplit effectInstantSplit = this;
    effectInstantSplit.target.hp.current = Mathf.CeilToInt((float) effectInstantSplit.target.hp.current * 0.5f);
    effectInstantSplit.target.hp.max = effectInstantSplit.target.hp.current;
    effectInstantSplit.target.data.value = Mathf.CeilToInt((float) effectInstantSplit.target.data.value * 0.5f);
    StatusEffectInstantSplit.UpdateWhenHealthLostEffects(effectInstantSplit.target);
    List<StatusEffectApply> statusesToApply = effectInstantSplit.target.statusEffects.Where<StatusEffectData>((Func<StatusEffectData, bool>) (e => e.count > e.temporary && e.isStatus)).Select<StatusEffectData, StatusEffectApply>((Func<StatusEffectData, StatusEffectApply>) (e => new StatusEffectApply(e.applier, (Entity) null, e.GetOriginal(), Mathf.CeilToInt((float) (e.count - e.temporary) * 0.5f)))).ToList<StatusEffectApply>();
    Routine.Clump clump = new Routine.Clump();
    foreach (StatusEffectData statusEffectData in effectInstantSplit.target.statusEffects.Where<StatusEffectData>((Func<StatusEffectData, bool>) (e => e.isStatus && e.count > e.temporary)))
    {
      int amount = statusEffectData.count - statusEffectData.temporary;
      if (amount > 0)
        clump.Add(statusEffectData.RemoveStacks(amount, false));
    }
    yield return (object) clump.WaitForEnd();
    yield return (object) effectInstantSplit.CreateNewCards(1);
    Entity newCard = effectInstantSplit.newCards[0];
    foreach (StatusEffectApply statusEffectApply in statusesToApply)
    {
      clump.Add(StatusEffectSystem.Apply(newCard, statusEffectApply.applier, statusEffectApply.effectData, statusEffectApply.count, fireEvents: false));
      clump.Add(StatusEffectSystem.Apply(effectInstantSplit.target, statusEffectApply.applier, statusEffectApply.effectData, statusEffectApply.count, fireEvents: false));
    }
    yield return (object) clump.WaitForEnd();
    Dictionary<Entity, List<CardSlot>> shoveData;
    if (ShoveSystem.CanShove(effectInstantSplit.target, effectInstantSplit.target.owner.entity, out shoveData))
    {
      CardContainer toContainer = effectInstantSplit.target.actualContainers[0];
      yield return (object) ShoveSystem.DoShove(shoveData, true);
      toContainer.Add(newCard);
      newCard.transform.position = newCard.GetContainerWorldPosition();
      newCard.wobbler.WobbleRandom();
      effectInstantSplit.target.wobbler.WobbleRandom();
      toContainer = (CardContainer) null;
    }
    yield return (object) effectInstantSplit.EnableCards((IEnumerable<Entity>) effectInstantSplit.newCards);
  }

  public IEnumerator SplitDoubleHeight()
  {
    StatusEffectInstantSplit effectInstantSplit = this;
    effectInstantSplit.target.hp.current = Mathf.CeilToInt((float) effectInstantSplit.target.hp.current * 0.5f);
    effectInstantSplit.target.hp.max = effectInstantSplit.target.hp.current;
    effectInstantSplit.target.data.value = Mathf.CeilToInt((float) effectInstantSplit.target.data.value * 0.5f);
    yield return (object) effectInstantSplit.CreateNewCards(2);
    List<StatusEffectData> list = effectInstantSplit.target.statusEffects.Where<StatusEffectData>((Func<StatusEffectData, bool>) (e => e.count > e.temporary && e.isStatus)).ToList<StatusEffectData>();
    Routine.Clump clump = new Routine.Clump();
    foreach (StatusEffectData effectData in list)
    {
      int count = Mathf.CeilToInt((float) (effectData.count - effectData.temporary) * 0.5f);
      foreach (Entity newCard in effectInstantSplit.newCards)
        clump.Add(StatusEffectSystem.Apply(newCard, effectData.applier, effectData, count, fireEvents: false));
    }
    yield return (object) clump.WaitForEnd();
    Vector3 position = effectInstantSplit.target.transform.position;
    for (int index = 0; index < effectInstantSplit.newCards.Count; ++index)
    {
      Entity newCard = effectInstantSplit.newCards[index];
      effectInstantSplit.target.actualContainers[index % effectInstantSplit.target.actualContainers.Count].Add(newCard);
      Transform transform = newCard.transform;
      Vector3 containerWorldPosition = newCard.GetContainerWorldPosition();
      Vector3 vector3 = Vector3.Lerp(position, containerWorldPosition, 0.1f);
      transform.position = vector3;
      LeanTween.move(newCard.gameObject, containerWorldPosition, PettyRandom.Range(0.8f, 1.2f)).setEaseOutElastic();
      newCard.wobbler.WobbleRandom();
    }
    foreach (PlayAction action in ActionQueue.GetActions())
    {
      if (action is ActionTriggerAgainst actionTriggerAgainst)
      {
        int[] rows = References.Battle.GetRowIndices(actionTriggerAgainst.entity);
        Entity[] array = effectInstantSplit.newCards.Where<Entity>((Func<Entity, bool>) (a => ((IList<int>) References.Battle.GetRowIndices(a)).ContainsAny<int>((IEnumerable<int>) rows))).ToArray<Entity>();
        actionTriggerAgainst.target = array.Length != 0 ? array.RandomItem<Entity>() : effectInstantSplit.newCards.RandomItem<Entity>();
      }
    }
    effectInstantSplit.target.RemoveFromContainers();
    CardManager.ReturnToPool(effectInstantSplit.target);
    yield return (object) effectInstantSplit.EnableCards((IEnumerable<Entity>) effectInstantSplit.newCards);
  }

  public IEnumerator EnableCards(IEnumerable<Entity> cards)
  {
    StatusEffectInstantSplit effectInstantSplit = this;
    MinibossIntroSystem minibossIntroSystem = UnityEngine.Object.FindObjectOfType<MinibossIntroSystem>();
    foreach (Entity card in cards)
    {
      if ((bool) (UnityEngine.Object) minibossIntroSystem)
        minibossIntroSystem.Ignore(card);
      CardContainer[] array = card.actualContainers.ToArray();
      card.enabled = true;
      card.RemoveFromContainers();
      card.owner.reserveContainer.Add(card);
      yield return (object) new ActionMove(card, array).Run();
      ActionRunEnableEvent action = new ActionRunEnableEvent(card);
      action.priority = effectInstantSplit.eventPriority;
      ActionQueue.Stack((PlayAction) action, true);
    }
  }

  public IEnumerator CreateNewCards(int count)
  {
    StatusEffectInstantSplit effectInstantSplit = this;
    CardController controller = effectInstantSplit.target.display.hover.controller;
    Character owner = effectInstantSplit.target.owner;
    Routine.Clump clump = new Routine.Clump();
    for (int index = 0; index < count; ++index)
    {
      CardData data = effectInstantSplit.target.data;
      foreach (StatusEffectInstantSplit.Profile profile in effectInstantSplit.profiles)
      {
        if (profile.cardName == data.name)
        {
          data = AddressableLoader.Get<CardData>("CardData", profile.changeToCardName);
          break;
        }
      }
      clump.Add(StatusEffectInstantSplit.CreateCard(effectInstantSplit.target.data, data, controller, owner, new UnityAction<Card>(effectInstantSplit.\u003CCreateNewCards\u003Eb__7_0)));
    }
    yield return (object) clump.WaitForEnd();
    foreach (Entity newCard in effectInstantSplit.newCards)
      clump.Add(effectInstantSplit.CopyEntity(newCard, effectInstantSplit.target));
    yield return (object) clump.WaitForEnd();
  }

  public static IEnumerator CreateCard(
    CardData original,
    CardData cardData,
    CardController controller,
    Character owner,
    UnityAction<Card> onComplete)
  {
    CardData data = cardData.Clone();
    ulong num;
    original.TryGetCustomData<ulong>("splitOriginalId", out num, original.id);
    data.SetCustomData("splitOriginalId", (object) num);
    Card card = CardManager.Get(data, controller, owner, true, owner.team == References.Player.team);
    card.entity.startingEffectsApplied = true;
    UnityAction<Card> unityAction = onComplete;
    if (unityAction != null)
      unityAction(card);
    yield return (object) card.UpdateData(false);
  }

  public IEnumerator CopyEntity(Entity entity, Entity toCopy)
  {
    StatusEffectInstantSplit effectInstantSplit = this;
    foreach (StatusEffectData effectData in toCopy.statusEffects.Where<StatusEffectData>(new Func<StatusEffectData, bool>(effectInstantSplit.\u003CCopyEntity\u003Eb__9_0)).ToList<StatusEffectData>())
      yield return (object) StatusEffectSystem.Apply(entity, effectData.applier, effectData, effectData.count - effectData.temporary, fireEvents: false);
    foreach (Entity.TraitStacks trait in toCopy.traits)
    {
      int count = trait.count - trait.tempCount;
      if (count > 0)
        entity.GainTrait(trait.data, count);
    }
    entity.attackEffects = ((IEnumerable<CardData.StatusEffectStacks>) CardData.StatusEffectStacks.Stack((IEnumerable<CardData.StatusEffectStacks>) entity.attackEffects, (IEnumerable<CardData.StatusEffectStacks>) toCopy.attackEffects)).Select<CardData.StatusEffectStacks, CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, CardData.StatusEffectStacks>) (a => a.Clone())).ToList<CardData.StatusEffectStacks>();
    entity.hp = toCopy.hp;
    entity.damage = toCopy.damage;
    entity.counter = toCopy.counter;
    if (entity.counter.current <= 0)
      entity.counter.Max();
    entity.uses = toCopy.uses;
    entity.display.promptUpdateDescription = true;
    StatusEffectInstantSplit.UpdateWhenHealthLostEffects(entity);
    entity.PromptUpdate();
    yield return (object) entity.UpdateTraits();
  }

  public static void UpdateWhenHealthLostEffects(Entity target)
  {
    foreach (StatusEffectData statusEffect in target.statusEffects)
    {
      if (statusEffect is StatusEffectApplyXWhenHealthLost applyXwhenHealthLost)
        applyXwhenHealthLost.currentHealth = target.hp.current;
    }
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();

  [CompilerGenerated]
  public void \u003CCreateNewCards\u003Eb__7_0(Card c) => this.newCards.Add(c.entity);

  [CompilerGenerated]
  public bool \u003CCopyEntity\u003Eb__9_0(StatusEffectData e) => e.count > e.temporary && e.HasDescOrIsKeyword && (UnityEngine.Object) e != (UnityEngine.Object) this;

  [Serializable]
  public struct Profile
  {
    public string cardName;
    public string changeToCardName;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantSummon
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Summon", fileName = "Summon X")]
public class StatusEffectInstantSummon : StatusEffectInstant
{
  [SerializeField]
  public bool canSummonMultiple;
  public StatusEffectSummon targetSummon;
  [SerializeField]
  public bool summonCopy;
  [SerializeField]
  public StatusEffectInstantSummon.Position summonPosition;
  [SerializeField]
  public StatusEffectData[] withEffects;
  [SerializeField]
  public bool queue = true;

  public override IEnumerator Process()
  {
    StatusEffectInstantSummon effectInstantSummon = this;
    if (effectInstantSummon.canSummonMultiple)
    {
      Routine.Clump clump = new Routine.Clump();
      int amount = effectInstantSummon.GetAmount();
      for (int index = 0; index < amount; ++index)
        clump.Add(effectInstantSummon.TrySummon());
      yield return (object) clump.WaitForEnd();
    }
    else if (effectInstantSummon.queue)
    {
      ActionSequence action = new ActionSequence(effectInstantSummon.TrySummon());
      action.note = "Instant Summon";
      ActionQueue.Stack((PlayAction) action, true);
    }
    else
      yield return (object) effectInstantSummon.TrySummon();
    yield return (object) effectInstantSummon.\u003C\u003En__0();
  }

  public IEnumerator TrySummon()
  {
    StatusEffectInstantSummon effectInstantSummon = this;
    CardContainer container;
    Dictionary<Entity, List<CardSlot>> shoveData;
    if (effectInstantSummon.CanSummon(out container, out shoveData))
    {
      if (shoveData != null)
        yield return (object) ShoveSystem.DoShove(shoveData, true);
      int amount = effectInstantSummon.GetAmount();
      yield return effectInstantSummon.summonCopy ? (object) effectInstantSummon.targetSummon.SummonCopy(effectInstantSummon.target, container, effectInstantSummon.applier.display.hover.controller, effectInstantSummon.applier, effectInstantSummon.withEffects, amount) : (object) effectInstantSummon.targetSummon.Summon(container, effectInstantSummon.applier.display.hover.controller, effectInstantSummon.applier, effectInstantSummon.withEffects, amount);
    }
    else if (NoTargetTextSystem.Exists())
      yield return (object) NoTargetTextSystem.Run(effectInstantSummon.target, NoTargetType.NoSpaceToSummon);
    yield return (object) null;
  }

  public static IEnumerator ApplyEffects(
    Entity applier,
    Entity entity,
    IEnumerable<StatusEffectData> effects,
    int count)
  {
    Hit hit = new Hit(applier, entity, 0)
    {
      countsAsHit = false,
      canRetaliate = false
    };
    foreach (StatusEffectData effect in effects)
      hit.AddStatusEffect(effect, count);
    yield return (object) hit.Process();
  }

  public bool CanSummon(
    out CardContainer container,
    out Dictionary<Entity, List<CardSlot>> shoveData)
  {
    bool flag = false;
    container = (CardContainer) null;
    shoveData = (Dictionary<Entity, List<CardSlot>>) null;
    switch (this.summonPosition)
    {
      case StatusEffectInstantSummon.Position.InFrontOf:
        if (!this.target.alive || !Battle.IsOnBoard(this.target) || ShoveSystem.CanShove(this.target, this.target.owner.entity, out shoveData))
        {
          if (this.target.actualContainers.Count > 0)
          {
            container = this.target.actualContainers.RandomItem<CardContainer>();
            flag = true;
            break;
          }
          if (this.target.preActualContainers.Length != 0)
          {
            container = this.target.preActualContainers.RandomItem<CardContainer>();
            flag = true;
            break;
          }
          break;
        }
        break;
      case StatusEffectInstantSummon.Position.EnemyRow:
        CardContainer[] list = this.target.containers;
        if (list == null || list.Length == 0)
          list = this.target.preContainers;
        if (list != null && list.Length != 0)
        {
          ((IList<CardContainer>) list).Shuffle<CardContainer>();
          foreach (CardContainer cardContainer in list)
          {
            if (cardContainer is CardSlotLane row)
            {
              CardSlotLane oppositeRow = References.Battle.GetOppositeRow(row);
              if (oppositeRow != null)
              {
                CardSlot slot = oppositeRow.slots[0];
                Entity top = slot.GetTop();
                if ((Object) top == (Object) null || ShoveSystem.CanShove(top, this.target.owner.entity, out shoveData))
                {
                  container = (CardContainer) slot;
                  flag = true;
                  break;
                }
              }
            }
          }
          break;
        }
        break;
      case StatusEffectInstantSummon.Position.Hand:
        container = References.Player.handContainer;
        flag = true;
        break;
    }
    return flag;
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();

  public enum Position
  {
    InFrontOf,
    EnemyRow,
    Hand,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantTakeHealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Take Health", fileName = "Take Health")]
public class StatusEffectInstantTakeHealth : StatusEffectInstant
{
  [SerializeField]
  public StatusEffectData increaseHealthEffect;

  public override IEnumerator Process()
  {
    StatusEffectInstantTakeHealth instantTakeHealth = this;
    int amount = instantTakeHealth.GetAmount();
    int count = Mathf.Min(instantTakeHealth.target.hp.current, amount);
    instantTakeHealth.target.hp.max -= amount;
    instantTakeHealth.target.hp.current -= amount;
    instantTakeHealth.target.PromptUpdate();
    Hit hit = new Hit(instantTakeHealth.target, instantTakeHealth.applier, 0)
    {
      canRetaliate = false,
      countsAsHit = false
    };
    hit.AddStatusEffect(instantTakeHealth.increaseHealthEffect, count);
    yield return (object) hit.Process();
    yield return (object) instantTakeHealth.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantTrigger
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Trigger", fileName = "Trigger")]
public class StatusEffectInstantTrigger : StatusEffectInstant
{
  [SerializeField]
  public bool againstRandomEnemy;
  [SerializeField]
  public bool reduceUses;
  [SerializeField]
  public int priority = -1;

  public override IEnumerator Process()
  {
    StatusEffectInstantTrigger effectInstantTrigger = this;
    if (effectInstantTrigger.againstRandomEnemy && effectInstantTrigger.target.NeedsTarget)
    {
      List<Entity> allEnemies = effectInstantTrigger.target.GetAllEnemies();
      if (allEnemies.Count > 0)
      {
        Entity target = allEnemies.RandomItem<Entity>();
        CardContainer targetContainer = target.containers.RandomItem<CardContainer>();
        ActionQueue.Stack((PlayAction) new ActionTriggerAgainst(effectInstantTrigger.target, effectInstantTrigger.applier, target, targetContainer), true);
      }
    }
    else
    {
      ActionTrigger action = new ActionTrigger(effectInstantTrigger.target, effectInstantTrigger.applier);
      action.priority = effectInstantTrigger.priority;
      ActionQueue.Stack((PlayAction) action, true);
    }
    if (effectInstantTrigger.reduceUses)
      ActionQueue.Add((PlayAction) new ActionReduceUses(effectInstantTrigger.target));
    yield return (object) effectInstantTrigger.\u003C\u003En__0();
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectInstantTriggerAgainst
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Instant/Trigger Against", fileName = "TriggerAgainst")]
public class StatusEffectInstantTriggerAgainst : StatusEffectInstant
{
  [SerializeField]
  public bool countsAsTrigger = true;
  [SerializeField]
  public string triggerType = "basic";
  [SerializeField]
  public bool reduceUses;

  public override IEnumerator Process()
  {
    StatusEffectInstantTriggerAgainst instantTriggerAgainst = this;
    if (instantTriggerAgainst.applier.IsAliveAndExists() && instantTriggerAgainst.target.IsAliveAndExists())
    {
      ActionQueue.Stack((PlayAction) new ActionTriggerAgainst(instantTriggerAgainst.applier, instantTriggerAgainst.target, instantTriggerAgainst.target, instantTriggerAgainst.target.containers[0])
      {
        countsAsTrigger = instantTriggerAgainst.countsAsTrigger
      }, true);
      if (instantTriggerAgainst.reduceUses)
        ActionQueue.Add((PlayAction) new ActionReduceUses(instantTriggerAgainst.applier));
      yield return (object) instantTriggerAgainst.\u003C\u003En__0();
    }
  }

  [CompilerGenerated]
  [DebuggerHidden]
  public new IEnumerator \u003C\u003En__0() => base.Process();
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectJuice
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Juice", fileName = "Juice")]
public class StatusEffectJuice : StatusEffectData
{
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectLastStand
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Misc/Last Stand", fileName = "Last Stand")]
public class StatusEffectLastStand : StatusEffectData
{
  public bool activated;

  public override bool RunPostHitEvent(Hit hit)
  {
    if (!this.activated && (Object) hit.target == (Object) this.target && this.target.hp.current <= 0 && hit.attacker.owner.team != this.target.owner.team && Battle.IsOnBoard(hit.attacker))
      this.Activate(hit);
    return false;
  }

  public void Activate(Hit hit)
  {
    LastStandSystem.target = this;
    LastStandSystem.subject = this.target;
    LastStandSystem.attacker = hit.attacker;
    LastStandSystem.previousPhase = References.Battle.phase;
    this.Disable();
    References.Battle.phase = Battle.Phase.LastStand;
  }

  public void Disable() => this.activated = true;

  public void ReEnable()
  {
    this.target.hp.current = 1;
    this.target.PromptUpdate();
    this.activated = false;
    this.preventDeath = true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectLumin
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Lumin", fileName = "Lumin")]
public class StatusEffectLumin : StatusEffectData
{
  public override bool RunPostApplyStatusEvent(StatusEffectApply apply)
  {
    if ((bool) (Object) apply.effectData && apply.count > 0 && apply.effectData.type == this.type && (Object) apply.target != (Object) this.target)
    {
      ActionSequence action = new ActionSequence(this.Remove());
      action.note = "Remove Lumin from [" + this.target.name + "]";
      ActionQueue.Stack((PlayAction) action, true);
    }
    return false;
  }

  public override bool RunBeginEvent()
  {
    ++this.target.effectFactor;
    return false;
  }

  public override bool RunEndEvent()
  {
    --this.target.effectFactor;
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectMultiHit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Multi Hit", fileName = "Multi Hit")]
public class StatusEffectMultiHit : StatusEffectData
{
  [SerializeField]
  public bool clearAfter;
  public int attackCount;
  public Trigger originalTrigger;
  public List<ActionTrigger> additionalTriggers;

  public override void Init() => Events.OnEntityTrigger += new Events.UnityActionRef<Trigger>(this.EntityTrigger);

  public void OnDestroy() => Events.OnEntityTrigger -= new Events.UnityActionRef<Trigger>(this.EntityTrigger);

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if ((Object) entity == (Object) this.target && this.target.alive && this.target.enabled)
    {
      --this.attackCount;
      if (entity.IsSnowed)
        this.attackCount = 0;
      if (this.attackCount <= 0)
        this.Cancel();
    }
    return false;
  }

  public void EntityTrigger(ref Trigger trigger)
  {
    if ((Object) trigger.entity != (Object) this.target || !trigger.countsAsTrigger)
      return;
    if (this.originalTrigger != null)
    {
      if (!this.target.IsSnowed)
        return;
      this.Cancel();
    }
    else
    {
      this.attackCount = 1;
      this.originalTrigger = trigger;
      if (trigger.triggerAgainst)
      {
        for (int index = 0; index < this.count; ++index)
        {
          ActionTriggerSubsequent trigger1 = new ActionTriggerSubsequent(this.target, (Entity) null, trigger.triggerAgainstTarget, trigger.triggerAgainstContainer);
          trigger1.note = "[" + this.target.name + "] Frenzy";
          this.AddTrigger((ActionTrigger) trigger1);
        }
      }
      else
      {
        for (int index = 0; index < this.count; ++index)
        {
          ActionTrigger trigger2 = new ActionTrigger(this.target, (Entity) null);
          trigger2.note = "[" + this.target.name + "] Frenzy";
          this.AddTrigger(trigger2);
        }
      }
    }
  }

  public void Cancel()
  {
    this.attackCount = 0;
    this.originalTrigger = (Trigger) null;
    if (this.additionalTriggers != null)
    {
      foreach (PlayAction additionalTrigger in this.additionalTriggers)
        ActionQueue.Remove(additionalTrigger);
    }
    this.additionalTriggers = (List<ActionTrigger>) null;
    if (!this.clearAfter)
      return;
    ActionSequence action = new ActionSequence(this.Clear());
    action.note = "Clear Temporary MultiHit";
    ActionQueue.Stack((PlayAction) action, true);
  }

  public void AddTrigger(ActionTrigger trigger)
  {
    ActionQueue.Stack((PlayAction) trigger);
    if (this.additionalTriggers == null)
      this.additionalTriggers = new List<ActionTrigger>();
    this.additionalTriggers.Add(trigger);
    ++this.attackCount;
  }

  public IEnumerator Clear()
  {
    StatusEffectMultiHit status = this;
    int count = status.count;
    Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref count);
    if (count != 0)
      yield return (object) status.CountDown(status.target, count);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectNextPhase
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Misc/Next Phase", fileName = "Next Phase")]
public class StatusEffectNextPhase : StatusEffectData
{
  [SerializeField]
  public CardData nextPhase;
  [SerializeField]
  public CardData[] splitOptions;
  [SerializeField]
  public int splitCount;
  [SerializeField]
  public CardAnimation animation;
  public bool goToNextPhase;
  public bool activated;

  public override void Init() => global::Events.OnEntityDisplayUpdated += new UnityAction<Entity>(this.EntityDisplayUpdated);

  public void OnDestroy() => global::Events.OnEntityDisplayUpdated -= new UnityAction<Entity>(this.EntityDisplayUpdated);

  public void EntityDisplayUpdated(Entity entity)
  {
    if (this.activated || this.target.hp.current > 0 || !((UnityEngine.Object) entity == (UnityEngine.Object) this.target))
      return;
    this.TryActivate();
  }

  public override bool RunPostHitEvent(Hit hit)
  {
    if (!this.activated && (UnityEngine.Object) hit.target == (UnityEngine.Object) this.target && this.target.hp.current <= 0)
      this.TryActivate();
    return false;
  }

  public void TryActivate()
  {
    bool flag = true;
    foreach (StatusEffectData statusEffect in this.target.statusEffects)
    {
      if ((UnityEngine.Object) statusEffect != (UnityEngine.Object) this && statusEffect.preventDeath)
      {
        flag = false;
        break;
      }
    }
    if (!flag)
      return;
    this.activated = true;
    UnityEngine.Object.FindObjectOfType<ChangePhaseAnimationSystem>()?.Flash();
    if ((bool) (UnityEngine.Object) this.nextPhase)
    {
      ActionChangePhase action = new ActionChangePhase(this.target, this.nextPhase.Clone(), this.animation);
      action.priority = 10;
      ActionQueue.Stack((PlayAction) action, true);
    }
    else
    {
      if (this.splitCount > 0)
      {
        CardData[] splitOptions = this.splitOptions;
        if (splitOptions != null && splitOptions.Length > 0)
        {
          ActionChangePhase action = new ActionChangePhase(this.target, ((IEnumerable<CardData>) this.splitOptions.RandomItems<CardData>(this.splitCount)).Select<CardData, CardData>((Func<CardData, CardData>) (a => a.Clone())).ToArray<CardData>(), this.animation);
          action.priority = 10;
          ActionQueue.Stack((PlayAction) action, true);
          return;
        }
      }
      throw new ArgumentException("Next phase not given!");
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectNull
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Null", fileName = "Null")]
public class StatusEffectNull : StatusEffectData
{
  public bool primed;

  public override void Init() => this.OnTurnEnd += new StatusEffectData.EffectEntityEventHandler(this.TurnEnd);

  public override bool RunBeginEvent()
  {
    ++this.target.silenceCount;
    return false;
  }

  public override bool RunEndEvent()
  {
    --this.target.silenceCount;
    return false;
  }

  public override bool RunTurnStartEvent(Entity entity)
  {
    if (!this.primed && (Object) entity == (Object) this.target)
      this.primed = true;
    return false;
  }

  public override bool RunTurnEndEvent(Entity entity) => (Object) entity == (Object) this.target && this.primed;

  public IEnumerator TurnEnd(Entity entity)
  {
    StatusEffectNull status = this;
    int amount = 1;
    Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref amount);
    if (amount != 0)
      yield return (object) status.CountDown(entity, amount);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectOngoing
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

public abstract class StatusEffectOngoing : StatusEffectData
{
  [InfoBox("\"Reverse\" to reduce instead of increase", EInfoBoxType.Normal)]
  [SerializeField]
  public bool reverse;

  public virtual IEnumerator Add(int add) => (IEnumerator) null;

  public virtual IEnumerator Remove(int remove) => (IEnumerator) null;

  public override bool HasStackRoutine => true;

  public override IEnumerator StackRoutine(int stacks)
  {
    yield return (object) this.Add(this.reverse ? -stacks : stacks);
  }

  public override IEnumerator RemoveStacks(int amount, bool removeTemporary)
  {
    StatusEffectOngoing statusEffectOngoing = this;
    int num = Mathf.Min(statusEffectOngoing.count, amount);
    yield return (object) statusEffectOngoing.Remove(statusEffectOngoing.reverse ? -num : num);
    yield return (object) statusEffectOngoing.\u003C\u003En__0(amount, removeTemporary);
  }

  public override bool HasEndRoutine => true;

  public override IEnumerator EndRoutine() => this.Remove(this.reverse ? -this.count : this.count);

  [CompilerGenerated]
  [DebuggerHidden]
  public IEnumerator \u003C\u003En__0(int amount, bool removeTemporary) => base.RemoveStacks(amount, removeTemporary);
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectOngoingAttack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Ongoing/Increase Attack", fileName = "Ongoing Increase Attack")]
public class StatusEffectOngoingAttack : StatusEffectOngoing
{
  public override IEnumerator Add(int add)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectOngoingAttack effectOngoingAttack = this;
    if (num != 0)
      return false;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    effectOngoingAttack.target.tempDamage += add;
    effectOngoingAttack.target.PromptUpdate();
    return false;
  }

  public override IEnumerator Remove(int remove)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectOngoingAttack effectOngoingAttack = this;
    if (num != 0)
      return false;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    effectOngoingAttack.target.tempDamage -= remove;
    effectOngoingAttack.target.PromptUpdate();
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectOngoingEffects
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Ongoing/Increase Effects", fileName = "Ongoing Increase Effects")]
public class StatusEffectOngoingEffects : StatusEffectOngoing
{
  [SerializeField]
  public bool add = true;
  [SerializeField]
  [HideIf("add")]
  public bool multiply;

  public override IEnumerator Add(int add)
  {
    StatusEffectOngoingEffects effectOngoingEffects = this;
    if (effectOngoingEffects.add)
      effectOngoingEffects.target.effectBonus += add;
    else if (effectOngoingEffects.multiply)
      effectOngoingEffects.target.effectFactor += (float) add;
    effectOngoingEffects.target.PromptUpdate();
    yield return (object) Sequences.Null();
  }

  public override IEnumerator Remove(int remove)
  {
    StatusEffectOngoingEffects effectOngoingEffects = this;
    if (effectOngoingEffects.add)
      effectOngoingEffects.target.effectBonus -= remove;
    else if (effectOngoingEffects.multiply)
      effectOngoingEffects.target.effectFactor -= (float) remove;
    effectOngoingEffects.target.PromptUpdate();
    yield return (object) Sequences.Null();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectOngoingMaxCounter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Ongoing/Increase Max Counter", fileName = "Ongoing Increase Max Counter")]
public class StatusEffectOngoingMaxCounter : StatusEffectOngoing
{
  public override IEnumerator Add(int add)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectOngoingMaxCounter ongoingMaxCounter = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    ongoingMaxCounter.target.counter.current = Mathf.Max(0, ongoingMaxCounter.target.counter.current + add);
    ongoingMaxCounter.target.counter.max = Mathf.Max(1, ongoingMaxCounter.target.counter.max + add);
    ongoingMaxCounter.target.PromptUpdate();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) Sequences.Null();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override IEnumerator Remove(int remove)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectOngoingMaxCounter ongoingMaxCounter = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    ongoingMaxCounter.target.counter.current = Mathf.Max(0, ongoingMaxCounter.target.counter.current - remove);
    ongoingMaxCounter.target.counter.max = Mathf.Max(1, ongoingMaxCounter.target.counter.max - remove);
    ongoingMaxCounter.target.PromptUpdate();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) Sequences.Null();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectOngoingMaxHealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Ongoing/Increase Max Health", fileName = "Ongoing Increase Max Health")]
public class StatusEffectOngoingMaxHealth : StatusEffectOngoing
{
  public override IEnumerator Add(int add)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectOngoingMaxHealth ongoingMaxHealth = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    ongoingMaxHealth.target.hp.max += add;
    ongoingMaxHealth.target.hp.current += add;
    ongoingMaxHealth.target.PromptUpdate();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) Sequences.Null();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override IEnumerator Remove(int remove)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectOngoingMaxHealth ongoingMaxHealth = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    ongoingMaxHealth.target.hp.max -= remove;
    ongoingMaxHealth.target.hp.current -= remove;
    ongoingMaxHealth.target.PromptUpdate();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) Sequences.Null();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectOverload
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Overload", fileName = "Overload")]
public class StatusEffectOverload : StatusEffectData
{
  [SerializeField]
  public CardAnimation buildupAnimation;
  public bool overloading;

  public override void Init()
  {
    this.OnStack += new StatusEffectData.EffectStackEventHandler(this.Stack);
    global::Events.OnEntityDisplayUpdated += new UnityAction<Entity>(this.EntityDisplayUpdated);
  }

  public void OnDestroy() => global::Events.OnEntityDisplayUpdated -= new UnityAction<Entity>(this.EntityDisplayUpdated);

  public void EntityDisplayUpdated(Entity entity)
  {
    if (!((Object) entity == (Object) this.target) || !this.target.enabled)
      return;
    this.Check();
  }

  public IEnumerator Stack(int stacks)
  {
    this.Check();
    yield return (object) null;
  }

  public void Check()
  {
    if (this.count < this.target.hp.current || this.overloading)
      return;
    ActionSequence action1 = new ActionSequence(this.DealDamage(this.count));
    action1.fixedPosition = true;
    action1.priority = this.eventPriority;
    action1.note = "Overload";
    ActionQueue.Stack((PlayAction) action1);
    ActionSequence action2 = new ActionSequence(this.Clear());
    action2.fixedPosition = true;
    action2.priority = this.eventPriority;
    action2.note = "Clear Overload";
    ActionQueue.Stack((PlayAction) action2);
    this.overloading = true;
  }

  public IEnumerator DealDamage(int damage)
  {
    StatusEffectOverload statusEffectOverload = this;
    if ((bool) (Object) statusEffectOverload && (bool) (Object) statusEffectOverload.target && statusEffectOverload.target.alive)
    {
      HashSet<Entity> targets = new HashSet<Entity>();
      foreach (IEnumerable<Entity> container in statusEffectOverload.target.containers)
        targets.AddRange<Entity>(container);
      if ((bool) (Object) statusEffectOverload.buildupAnimation)
        yield return (object) statusEffectOverload.buildupAnimation.Routine((object) statusEffectOverload.target);
      Entity damager = statusEffectOverload.GetDamager();
      Routine.Clump clump = new Routine.Clump();
      foreach (Entity target in targets)
      {
        Hit hit = new Hit(damager, target, damage)
        {
          damageType = "overload"
        };
        clump.Add(hit.Process());
      }
      clump.Add(Sequences.Wait(0.5f));
      yield return (object) clump.WaitForEnd();
    }
  }

  public IEnumerator Clear()
  {
    StatusEffectOverload statusEffectOverload = this;
    if ((bool) (Object) statusEffectOverload && (bool) (Object) statusEffectOverload.target && statusEffectOverload.target.alive)
    {
      yield return (object) statusEffectOverload.Remove();
      statusEffectOverload.overloading = false;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectPullTarget
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Pull Target", fileName = "Pull Target")]
public class StatusEffectPullTarget : StatusEffectData
{
  public Hit storedHit;

  public override bool RunPreAttackEvent(Hit hit)
  {
    if ((Object) hit.attacker == (Object) this.target && this.target.alive && this.target.enabled && (Object) hit.target != (Object) null && hit.target.containers != null)
    {
      hit.FlagAsOffensive();
      this.storedHit = hit;
    }
    return false;
  }

  public override bool RunHitEvent(Hit hit)
  {
    if (hit == this.storedHit)
    {
      Entity target = hit.target;
      CardContainer container = target.containers[0];
      int index = container.IndexOf(target);
      int num = Mathf.Max(index - this.GetAmount(), 0);
      if (index != num)
      {
        container.RemoveAt(index);
        container.PushBackwards(num);
        container.Insert(num, target);
        foreach (Entity child in container)
          container.TweenChildPosition(child);
      }
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectPushTarget
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Push Target", fileName = "Push Target")]
public class StatusEffectPushTarget : StatusEffectData
{
  public Hit storedHit;

  public override bool RunPreAttackEvent(Hit hit)
  {
    if ((Object) hit.attacker == (Object) this.target && this.target.alive && this.target.enabled && (Object) hit.target != (Object) null && hit.target.containers != null)
    {
      hit.FlagAsOffensive();
      this.storedHit = hit;
    }
    return false;
  }

  public override bool RunHitEvent(Hit hit)
  {
    if (hit == this.storedHit)
    {
      Entity target = hit.target;
      CardContainer container = target.containers[0];
      int index1 = container.IndexOf(target);
      int index2 = Mathf.Min(index1 + this.GetAmount(), container.max - 1);
      if (index1 != index2)
      {
        container.RemoveAt(index1);
        container.Insert(index2, target);
        foreach (Entity child in container)
          container.TweenChildPosition(child);
      }
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectReaction
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;

public class StatusEffectReaction : StatusEffectData
{
  public override bool CanTrigger() => base.CanTrigger() && this.target.alive;

  public bool PlayedInThisRow(Entity entity, Entity[] targets)
  {
    bool flag = false;
    int[] rowIndices1 = Battle.instance.GetRowIndices(this.target);
    foreach (Entity target in targets)
    {
      int[] rowIndices2 = Battle.instance.GetRowIndices(target);
      if (((IList<int>) rowIndices1).ContainsAny<int>((IEnumerable<int>) rowIndices2))
      {
        flag = true;
        break;
      }
    }
    return flag;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectRecycle
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Recycle", fileName = "Recycle")]
public class StatusEffectRecycle : StatusEffectData
{
  [SerializeField]
  public string cardToRecycle = "Junk";
  public bool running;
  public readonly List<Entity> toDestroy = new List<Entity>();

  public override void Init()
  {
    Events.OnCheckAction += new Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
    this.PreTrigger += new StatusEffectData.EffectTriggerEventHandler(this.EntityPreTrigger);
  }

  public void OnDestroy() => Events.OnCheckAction -= new Events.UnityActionRef<PlayAction, bool>(this.CheckAction);

  public void CheckAction(ref PlayAction action, ref bool allow)
  {
    if (this.running || !this.target.enabled || this.target.silenced || !allow || !(action is ActionTrigger actionTrigger) || !((Object) actionTrigger.entity == (Object) this.target))
      return;
    int amount = this.GetAmount();
    Events.CheckRecycleAmount(this.target, ref amount);
    if (amount <= 0 || this.GetTargets(amount))
      return;
    allow = false;
    if (!NoTargetTextSystem.Exists())
      return;
    Routine routine = new Routine(NoTargetTextSystem.Run(this.target, NoTargetType.RequiresJunk, (object) amount));
  }

  public override bool RunPreTriggerEvent(Trigger trigger) => this.toDestroy.Count > 0;

  public IEnumerator EntityPreTrigger(Trigger trigger)
  {
    StatusEffectRecycle statusEffectRecycle = this;
    statusEffectRecycle.running = true;
    foreach (Entity entity in statusEffectRecycle.toDestroy)
    {
      double num = (double) statusEffectRecycle.target.curveAnimator.Ping();
      yield return (object) entity.Kill();
    }
    statusEffectRecycle.toDestroy.Clear();
    statusEffectRecycle.running = false;
  }

  public bool GetTargets(int requiredAmount)
  {
    bool targets = false;
    this.toDestroy.Clear();
    foreach (Entity entity in References.Player.handContainer)
    {
      if (entity.data.name == this.cardToRecycle)
      {
        this.toDestroy.Add(entity);
        if (--requiredAmount <= 0)
        {
          targets = true;
          break;
        }
      }
    }
    if (!targets)
      this.toDestroy.Clear();
    return targets;
  }

  public bool IsEnoughJunkInHand()
  {
    int amount = this.GetAmount();
    foreach (Entity entity in References.Player.handContainer)
    {
      if (entity.data.name == this.cardToRecycle && --amount <= 0)
        return true;
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectRedrawCards
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Redraw Cards", fileName = "Redraw Cards")]
public class StatusEffectRedrawCards : StatusEffectData
{
  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if ((Object) entity == (Object) this.target && !this.target.silenced)
      ActionQueue.Stack((PlayAction) new ActionRedraw(this.target.owner));
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectRemoveEffects
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization.Tables;

[CreateAssetMenu(menuName = "Status Effects/Specific/Remove Effects", fileName = "Remove Effects")]
public class StatusEffectRemoveEffects : StatusEffectData
{
  public override bool RunBeginEvent()
  {
    if (this.target.data.playType != Card.PlayType.Place)
    {
      this.target.data.playType = Card.PlayType.Play;
      this.target.data.needsTarget = true;
      this.target.data.canPlayOnBoard = true;
      this.target.data.canPlayOnHand = false;
      this.target.data.canPlayOnFriendly = true;
      this.target.data.canPlayOnEnemy = true;
      this.target.data.playOnSlot = false;
      this.target.data.defaultPlayPosition = CardData.PlayPosition.None;
      this.target.data.targetConstraints = (TargetConstraint[]) null;
      this.target.data.textKey.TableReference = new TableReference();
      this.target.data.desc = "";
      this.target.display.promptUpdateDescription = true;
      this.target.PromptUpdate();
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectResistX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Immunity/Resist X", fileName = "Resist X")]
public class StatusEffectResistX : StatusEffectData
{
  [SerializeField]
  public string resistType = "snow";

  public override bool RunApplyStatusEvent(StatusEffectApply apply)
  {
    if ((Object) apply.target == (Object) this.target && apply.effectData?.type == this.resistType)
    {
      apply.count -= this.count;
      if (apply.count <= 0)
      {
        apply.effectData = (StatusEffectData) null;
        apply.count = 0;
      }
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Serializable]
public class StatusEffectSaveData : ILoadable<CardData.StatusEffectStacks>
{
  public string name;
  public int count;

  public CardData.StatusEffectStacks Load()
  {
    StatusEffectData statusEffectData = AddressableLoader.Get<StatusEffectData>("StatusEffectData", this.name);
    if (!(bool) (UnityEngine.Object) statusEffectData)
      return (CardData.StatusEffectStacks) null;
    return new CardData.StatusEffectStacks()
    {
      data = statusEffectData,
      count = this.count
    };
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectScrap
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Scrap", fileName = "Scrap")]
public class StatusEffectScrap : StatusEffectData
{
  public override void Init() => this.OnHit += new StatusEffectData.EffectHitEventHandler(this.Check);

  public override bool RunHitEvent(Hit hit) => (Object) hit.target == (Object) this.target && hit.damage > 0 && !hit.nullified;

  public IEnumerator Check(Hit hit)
  {
    StatusEffectScrap statusEffectScrap = this;
    hit.damageBlocked = hit.damage;
    hit.damage = 0;
    --statusEffectScrap.count;
    if (statusEffectScrap.count <= 0)
      yield return (object) statusEffectScrap.Remove();
    statusEffectScrap.target.PromptUpdate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectShell
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Shell", fileName = "Shell")]
public class StatusEffectShell : StatusEffectData
{
  public override void Init() => this.OnHit += new StatusEffectData.EffectHitEventHandler(this.Check);

  public override bool RunHitEvent(Hit hit) => (Object) hit.target == (Object) this.target && hit.damage > 0;

  public IEnumerator Check(Hit hit)
  {
    StatusEffectShell statusEffectShell = this;
    while (hit.damage > 0 && statusEffectShell.count > 0)
    {
      --statusEffectShell.count;
      --hit.damage;
      ++hit.damageBlocked;
    }
    if (statusEffectShell.count <= 0)
      yield return (object) statusEffectShell.Remove();
    statusEffectShell.target.PromptUpdate();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectShroom
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Shroom", fileName = "Shroom")]
public class StatusEffectShroom : StatusEffectData
{
  public bool subbed;
  public bool primed;

  public override void Init()
  {
    this.OnTurnEnd += new StatusEffectData.EffectEntityEventHandler(this.DealDamage);
    global::Events.OnPostProcessUnits += new UnityAction<Character>(this.Prime);
    this.subbed = true;
  }

  public void OnDestroy() => this.Unsub();

  public void Unsub()
  {
    if (!this.subbed)
      return;
    global::Events.OnPostProcessUnits -= new UnityAction<Character>(this.Prime);
    this.subbed = false;
  }

  public void Prime(Character character)
  {
    this.primed = true;
    this.Unsub();
  }

  public override bool RunTurnEndEvent(Entity entity) => this.primed && this.target.enabled && (Object) entity == (Object) this.target;

  public IEnumerator DealDamage(Entity entity)
  {
    StatusEffectShroom status = this;
    yield return (object) new Hit(status.GetDamager(), status.target, status.count)
    {
      screenShake = 0.25f,
      damageType = "shroom"
    }.Process();
    yield return (object) Sequences.Wait(0.2f);
    int amount = 1;
    global::Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref amount);
    if (amount != 0)
      yield return (object) status.CountDown(entity, amount);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectShuffleEnemiesAndAllies
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/Shuffle Enemies And Allies", fileName = "Shuffle Enemies And Allies")]
public class StatusEffectShuffleEnemiesAndAllies : StatusEffectData
{
  public override void Init() => this.OnCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.Run);

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets) => (Object) entity == (Object) this.target;

  public IEnumerator Run(Entity entity, Entity[] targets)
  {
    StatusEffectShuffleEnemiesAndAllies enemiesAndAllies = this;
    Debug.Log((object) string.Format("{0} Running...", (object) enemiesAndAllies));
    List<CardContainer> rows = Battle.instance.GetRows(enemiesAndAllies.target.owner);
    rows.AddRange((IEnumerable<CardContainer>) Battle.instance.GetRows(Battle.GetOpponent(enemiesAndAllies.target.owner)));
    foreach (CardContainer cardContainer in rows)
    {
      List<Entity> list = new List<Entity>();
      foreach (Entity entity1 in cardContainer)
        list.Add(entity1);
      if (list.Count > 0)
        list.Shuffle<Entity>();
      foreach (Entity entity2 in list)
        cardContainer.Remove(entity2);
      foreach (Entity entity3 in list)
        cardContainer.Add(entity3);
      cardContainer.TweenChildPositions();
    }
    double num = (double) enemiesAndAllies.target.curveAnimator.Ping();
    yield return (object) Sequences.Wait(0.13f);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectSilence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Silence", fileName = "Silence")]
public class StatusEffectSilence : StatusEffectData
{
  public override void Init() => this.OnTurnEnd += new StatusEffectData.EffectEntityEventHandler(this.CustomCountDown);

  public override bool RunBeginEvent()
  {
    ++this.target.silenceCount;
    this.target.PromptUpdate();
    return false;
  }

  public override bool RunTurnEndEvent(Entity entity) => (Object) entity == (Object) this.target && this.target.enabled;

  public IEnumerator CustomCountDown(Entity entity)
  {
    StatusEffectSilence status = this;
    int amount = 1;
    Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref amount);
    if (amount != 0)
      yield return (object) status.CountDown(entity, amount);
  }

  public override bool RunEndEvent()
  {
    --this.target.silenceCount;
    this.target.PromptUpdate();
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectSnow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Snow", fileName = "Snow")]
public class StatusEffectSnow : StatusEffectData
{
  [SerializeField]
  public StatusEffectSnow.CountDownType countDownType;
  public bool primed;

  public override void Init()
  {
    this.OnHit += new StatusEffectData.EffectHitEventHandler(this.Hit);
    this.OnTurnEnd += new StatusEffectData.EffectEntityEventHandler(this.CustomCountDown);
  }

  public override bool RunHitEvent(global::Hit hit) => (Object) hit.target == (Object) this.target && hit.counterReduction > 0;

  public IEnumerator Hit(global::Hit hit)
  {
    StatusEffectSnow statusEffectSnow;
    for (statusEffectSnow = this; hit.counterReduction > 0 && statusEffectSnow.count > 0; --hit.counterReduction)
    {
      if (statusEffectSnow.countDownType == StatusEffectSnow.CountDownType.OnCounter)
        --statusEffectSnow.count;
    }
    if (statusEffectSnow.count <= 0)
      yield return (object) statusEffectSnow.Remove();
  }

  public override bool RunTurnStartEvent(Entity entity)
  {
    if (!this.primed && (Object) entity == (Object) this.target && this.countDownType == StatusEffectSnow.CountDownType.OnTurnEnd && Battle.IsOnBoard(entity))
      this.primed = true;
    return false;
  }

  public override bool RunTurnEndEvent(Entity entity) => (Object) entity == (Object) this.target && this.primed && this.countDownType == StatusEffectSnow.CountDownType.OnTurnEnd;

  public IEnumerator CustomCountDown(Entity entity)
  {
    StatusEffectSnow status = this;
    int amount = 1;
    Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref amount);
    if (amount != 0)
      yield return (object) status.CountDown(entity, amount);
  }

  public enum CountDownType
  {
    OnCounter,
    OnTurnEnd,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectSpice
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Spice", fileName = "Spice")]
public class StatusEffectSpice : StatusEffectData
{
  public bool cardPlayed;
  public int current;
  public int amountToClear;

  public override void Init() => this.OnActionPerformed += new StatusEffectData.EffectActionPerformedHandler(this.ActionPerformed);

  public override bool RunStackEvent(int stacks)
  {
    this.current += stacks;
    this.target.tempDamage += stacks;
    return false;
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (!this.cardPlayed && (Object) entity == (Object) this.target && this.count > 0 && targets != null && targets.Length != 0)
    {
      this.cardPlayed = true;
      this.amountToClear = this.current;
    }
    return false;
  }

  public override bool RunActionPerformedEvent(PlayAction action) => this.cardPlayed && ActionQueue.Empty;

  public IEnumerator ActionPerformed(PlayAction action)
  {
    this.cardPlayed = false;
    yield return (object) this.Clear(this.amountToClear);
  }

  public IEnumerator Clear(int amount)
  {
    StatusEffectSpice status = this;
    int amount1 = amount;
    Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref amount1);
    if (amount1 != 0)
    {
      status.current -= amount1;
      status.target.tempDamage -= amount1;
      yield return (object) status.CountDown(status.target, amount1);
    }
  }

  public override bool RunEndEvent()
  {
    this.target.tempDamage -= this.current;
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectSpikes
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Spikes", fileName = "Spikes")]
public class StatusEffectSpikes : StatusEffectData
{
  public override void Init() => this.PostHit += new StatusEffectData.EffectHitEventHandler(this.Check);

  public override bool RunPostHitEvent(Hit hit) => (Object) hit.target == (Object) this.target && hit.canRetaliate && hit.Offensive && hit.BasicHit && (Object) hit.attacker != (Object) this.target;

  public IEnumerator Check(Hit hit)
  {
    StatusEffectSpikes statusEffectSpikes = this;
    if ((bool) (Object) hit.attacker && hit.attacker.canBeHit)
      yield return (object) new Hit(statusEffectSpikes.target, hit.attacker, statusEffectSpikes.count)
      {
        canRetaliate = false,
        damageType = "spikes"
      }.Process();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectStealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Stealth", fileName = "Stealth")]
public class StatusEffectStealth : StatusEffectData
{
  public bool cardPlayed;

  public override void Init() => this.OnActionPerformed += new StatusEffectData.EffectActionPerformedHandler(this.ActionPerformed);

  public override bool RunBeginEvent()
  {
    ++this.target.cannotBeHitCount;
    return false;
  }

  public override bool RunEndEvent()
  {
    --this.target.cannotBeHitCount;
    return false;
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (!this.cardPlayed && (Object) entity == (Object) this.target && this.count > 0 && targets != null && targets.Length != 0)
      this.cardPlayed = true;
    return false;
  }

  public override bool RunActionPerformedEvent(PlayAction action) => this.cardPlayed && ActionQueue.Empty;

  public IEnumerator ActionPerformed(PlayAction action)
  {
    yield return (object) this.CountDown();
  }

  public IEnumerator CountDown()
  {
    StatusEffectStealth status = this;
    int amount = 1;
    Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref amount);
    if (amount != 0)
      yield return (object) status.CountDown(status.target, amount);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectSummon
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Events;
using UnityEngine.ResourceManagement.AsyncOperations;

[CreateAssetMenu(menuName = "Status Effects/Summon", fileName = "Summon")]
public class StatusEffectSummon : StatusEffectData
{
  public CardData summonCard;
  [SerializeField]
  public StatusEffectData gainTrait;
  [SerializeField]
  public CardType setCardType;
  [SerializeField]
  public AssetReference effectPrefabRef;
  public bool unsubRequired;
  public CardSlot[] toSummon;

  public override void Init()
  {
    if (this.target.data.playOnSlot)
    {
      global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerform);
      this.unsubRequired = true;
    }
    this.OnCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.CardPlayed);
  }

  public void OnDestroy()
  {
    if (!this.unsubRequired)
      return;
    global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerform);
  }

  public void ActionPerform(PlayAction action)
  {
    if (!(action is ActionTriggerAgainst actionTriggerAgainst) || !((UnityEngine.Object) actionTriggerAgainst.targetContainer != (UnityEngine.Object) null) || !((UnityEngine.Object) actionTriggerAgainst.entity == (UnityEngine.Object) this.target))
      return;
    switch (actionTriggerAgainst.targetContainer)
    {
      case CardSlot cardSlot:
        this.toSummon = new CardSlot[1]{ cardSlot };
        break;
      case CardSlotLane row:
        this.toSummon = this.target.targetMode.GetTargetSlots(row);
        break;
    }
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets) => (UnityEngine.Object) entity == (UnityEngine.Object) this.target;

  public IEnumerator CardPlayed(Entity entity, Entity[] targets)
  {
    StatusEffectSummon statusEffectSummon = this;
    if (statusEffectSummon.toSummon == null)
    {
      HashSet<CardContainer> list = new HashSet<CardContainer>();
      list.AddRange<CardContainer>((IEnumerable<CardContainer>) entity.actualContainers);
      if (list.Count > 0 && list.ToArray<CardContainer>().RandomItem<CardContainer>() is CardSlot cardSlot)
        statusEffectSummon.toSummon = new CardSlot[1]
        {
          cardSlot
        };
    }
    if (statusEffectSummon.toSummon != null && statusEffectSummon.toSummon.Length != 0)
    {
      CardController controller = statusEffectSummon.target.display.hover.controller;
      double num = (double) statusEffectSummon.target.curveAnimator.Ping();
      CardSlot[] cardSlotArray = statusEffectSummon.toSummon;
      for (int index = 0; index < cardSlotArray.Length; ++index)
      {
        CardSlot container = cardSlotArray[index];
        yield return (object) statusEffectSummon.TrySummon((CardContainer) container, controller, statusEffectSummon.target);
      }
      cardSlotArray = (CardSlot[]) null;
      controller = (CardController) null;
    }
    statusEffectSummon.toSummon = (CardSlot[]) null;
    yield return (object) null;
  }

  public IEnumerator Summon(
    CardContainer container,
    CardController controller,
    Entity summonedBy,
    StatusEffectData[] withEffects = null,
    int withEffectsAmount = 0,
    UnityAction<Entity> onComplete = null)
  {
    StatusEffectSummon statusEffectSummon = this;
    if ((bool) (UnityEngine.Object) container)
    {
      Entity entity = (Entity) null;
      yield return (object) statusEffectSummon.CreateCard(statusEffectSummon.summonCard, container, controller, (UnityAction<Entity>) (e => entity = e));
      if (withEffectsAmount > 0 && withEffects != null)
      {
        StatusEffectData[] statusEffectDataArray = withEffects;
        for (int index = 0; index < statusEffectDataArray.Length; ++index)
          yield return (object) StatusEffectSystem.Apply(entity, (Entity) null, statusEffectDataArray[index], withEffectsAmount);
        statusEffectDataArray = (StatusEffectData[]) null;
      }
      if ((bool) (UnityEngine.Object) statusEffectSummon.gainTrait)
        ActionQueue.Stack((PlayAction) new ActionSequence(statusEffectSummon.Animate(entity, new CardData.StatusEffectStacks(statusEffectSummon.gainTrait, 1))), true);
      else
        ActionQueue.Stack((PlayAction) new ActionSequence(statusEffectSummon.Animate(entity)), true);
      ActionRunEnableEvent action1 = new ActionRunEnableEvent(entity);
      action1.fixedPosition = true;
      ActionQueue.Stack((PlayAction) action1);
      ActionMove action2 = new ActionMove(entity, new CardContainer[1]
      {
        container
      });
      action2.fixedPosition = true;
      ActionQueue.Stack((PlayAction) action2);
      global::Events.InvokeEntitySummoned(entity, summonedBy);
      UnityAction<Entity> unityAction = onComplete;
      if (unityAction != null)
        unityAction(entity);
    }
  }

  public IEnumerator SummonCopy(
    Entity toCopy,
    CardContainer container,
    CardController controller,
    Entity summonedBy,
    StatusEffectData[] withEffects = null,
    int withEffectsAmount = 0,
    UnityAction<Entity> onComplete = null)
  {
    StatusEffectSummon statusEffectSummon = this;
    Entity entity = (Entity) null;
    yield return (object) statusEffectSummon.CreateCard(toCopy.data, container, controller, (UnityAction<Entity>) (e =>
    {
      entity = e;
      e.startingEffectsApplied = true;
    }));
    ulong num;
    toCopy.data.TryGetCustomData<ulong>("splitOriginalId", out num, toCopy.data.id);
    entity.data.SetCustomData("splitOriginalId", (object) num);
    List<StatusEffectData> list = toCopy.statusEffects.Where<StatusEffectData>((Func<StatusEffectData, bool>) (e =>
    {
      if (e.count <= e.temporary)
        return false;
      return e.HasDescOrIsKeyword || e.isStatus;
    })).ToList<StatusEffectData>();
    foreach (Entity.TraitStacks trait in toCopy.traits)
    {
      foreach (StatusEffectData passiveEffect in trait.passiveEffects)
        list.Remove(passiveEffect);
      int count = trait.count - trait.tempCount;
      if (count > 0)
        entity.GainTrait(trait.data, count);
    }
    foreach (StatusEffectData effectData in list)
      yield return (object) StatusEffectSystem.Apply(entity, effectData.applier, effectData, effectData.count - effectData.temporary);
    entity.attackEffects = ((IEnumerable<CardData.StatusEffectStacks>) CardData.StatusEffectStacks.Stack((IEnumerable<CardData.StatusEffectStacks>) entity.attackEffects, (IEnumerable<CardData.StatusEffectStacks>) toCopy.attackEffects)).Select<CardData.StatusEffectStacks, CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, CardData.StatusEffectStacks>) (a => a.Clone())).ToList<CardData.StatusEffectStacks>();
    entity.damage = toCopy.damage;
    entity.hp = toCopy.hp;
    entity.counter = toCopy.counter;
    entity.counter.current = entity.counter.max;
    entity.uses = toCopy.uses;
    entity.display.promptUpdateDescription = true;
    entity.PromptUpdate();
    yield return (object) entity.UpdateTraits();
    if (withEffectsAmount > 0 && withEffects != null)
    {
      StatusEffectData[] statusEffectDataArray = withEffects;
      for (int index = 0; index < statusEffectDataArray.Length; ++index)
        yield return (object) StatusEffectSystem.Apply(entity, (Entity) null, statusEffectDataArray[index], withEffectsAmount);
      statusEffectDataArray = (StatusEffectData[]) null;
    }
    if ((bool) (UnityEngine.Object) statusEffectSummon.gainTrait)
      yield return (object) statusEffectSummon.Animate(entity, new CardData.StatusEffectStacks(statusEffectSummon.gainTrait, 1));
    else
      yield return (object) statusEffectSummon.Animate(entity);
    global::Events.InvokeEntitySummoned(entity, summonedBy);
    UnityAction<Entity> unityAction = onComplete;
    if (unityAction != null)
      unityAction(entity);
    yield return (object) new ActionRunEnableEvent(entity).Run();
    yield return (object) new ActionMove(entity, new CardContainer[1]
    {
      container
    }).Run();
  }

  public IEnumerator Animate(Entity entity, params CardData.StatusEffectStacks[] withEffects)
  {
    AsyncOperationHandle<GameObject> handle = this.effectPrefabRef.InstantiateAsync(entity.transform);
    yield return (object) handle;
    CreateCardAnimation component = handle.Result.GetComponent<CreateCardAnimation>();
    if (component != null)
      yield return (object) component.Run(entity, withEffects);
  }

  public IEnumerator CreateCard(
    CardData cardData,
    CardContainer container,
    CardController controller,
    UnityAction<Entity> onComplete = null)
  {
    CardData data = cardData.Clone(false);
    if ((bool) (UnityEngine.Object) this.setCardType)
      data.cardType = this.setCardType;
    data.upgrades.RemoveAll((Predicate<CardUpgradeData>) (a => a.type == CardUpgradeData.Type.Crown));
    Card card = CardManager.Get(data, controller, container.owner, true, container.owner.team == References.Player.team);
    card.entity.flipper.FlipUpInstant();
    card.canvasGroup.alpha = 0.0f;
    container.Add(card.entity);
    Transform transform = card.transform;
    transform.localPosition = card.entity.GetContainerLocalPosition();
    transform.localEulerAngles = card.entity.GetContainerLocalRotation();
    transform.localScale = card.entity.GetContainerScale();
    container.Remove(card.entity);
    card.entity.owner.reserveContainer.Add(card.entity);
    UnityAction<Entity> unityAction = onComplete;
    if (unityAction != null)
      unityAction(card.entity);
    yield return (object) card.UpdateData(false);
  }

  public static IEnumerator UpdateData(Entity entity, Entity toCopy = null)
  {
    yield return (object) entity.display.UpdateData();
    if ((UnityEngine.Object) toCopy != (UnityEngine.Object) null)
    {
      entity.hp = toCopy.hp;
      entity.damage = toCopy.damage;
      entity.counter.current = entity.counter.max;
      entity.PromptUpdate();
    }
  }

  public IEnumerator TrySummon(
    CardContainer container,
    CardController controller,
    Entity summonedBy)
  {
    StatusEffectSummon statusEffectSummon = this;
    if (container.Count < container.max)
    {
      yield return (object) statusEffectSummon.Summon(container, controller, summonedBy);
    }
    else
    {
      Dictionary<Entity, List<CardSlot>> shoveData;
      if (ShoveSystem.CanShove(container.GetTop(), statusEffectSummon.target, out shoveData))
      {
        yield return (object) ShoveSystem.DoShove(shoveData, true);
        yield return (object) statusEffectSummon.Summon(container, controller, summonedBy);
      }
      else if (NoTargetTextSystem.Exists())
        yield return (object) NoTargetTextSystem.Run(statusEffectSummon.target, NoTargetType.NoSpaceToSummon);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectSummoned
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Summoned", fileName = "Summoned")]
public class StatusEffectSummoned : StatusEffectData
{
  public bool triggered;

  public override void Init() => this.OnTurnEnd += new StatusEffectData.EffectEntityEventHandler(this.DealDamage);

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if ((Object) entity == (Object) this.target)
      this.triggered = true;
    return false;
  }

  public override bool RunTurnEndEvent(Entity entity) => this.CanTrigger() && (Object) entity == (Object) this.target && this.triggered;

  public IEnumerator DealDamage(Entity entity)
  {
    StatusEffectSummoned statusEffectSummoned = this;
    statusEffectSummoned.triggered = false;
    SfxSystem.OneShot("event:/sfx/status/shadeheart");
    yield return (object) new Hit(statusEffectSummoned.target, statusEffectSummoned.target, 1)
    {
      damageType = "summoned",
      countsAsHit = false,
      screenShake = 0.0f
    }.Process();
    yield return (object) Sequences.Wait(0.1f);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class StatusEffectSystem : GameSystem
{
  public static readonly FreezableList<StatusEffectData> activeEffects = new FreezableList<StatusEffectData>(true, (IComparer<StatusEffectData>) new StatusEffectSystem.StatusEffectComparer());
  public static int eventRoutineCount;

  public static bool EventsRunning => StatusEffectSystem.eventRoutineCount > 0;

  public static IEnumerator Apply(
    Entity target,
    Entity applier,
    StatusEffectData effectData,
    int count,
    bool temporary = false,
    Action<StatusEffectData> onEffectApplied = null,
    bool fireEvents = true,
    bool applyEvenIfZero = false)
  {
    bool flag = true;
    if (effectData.targetConstraints != null && ((IEnumerable<TargetConstraint>) effectData.targetConstraints).Any<TargetConstraint>((Func<TargetConstraint, bool>) (constraint => !constraint.Check(target))))
      flag = false;
    if (flag)
    {
      StatusEffectSystem.activeEffects.Freeze();
      StatusEffectApply s = new StatusEffectApply(applier, target, effectData, count);
      if (fireEvents)
        yield return (object) StatusEffectSystem.ApplyStatusEvent(s);
      if ((bool) (UnityEngine.Object) s.effectData && (s.count > 0 | applyEvenIfZero || !s.effectData.canBeBoosted || s.effectData is StatusEffectInstantMultiple))
      {
        StatusEffectData effect = target.statusEffects.Find((Predicate<StatusEffectData>) (a => a.name == s.effectData.name));
        if ((bool) (UnityEngine.Object) effect && effect.stackable)
        {
          Debug.Log((object) string.Format("Stacking [{0} {1}] on top of [{2}]", (object) s.effectData.name, (object) s.count, (object) target.name));
          effect.count += s.count;
          if (temporary)
            effect.temporary += s.count;
          effect.applier = applier;
        }
        else
        {
          Debug.Log((object) string.Format("[{0} {1}] applied to [{2}]", (object) s.effectData.name, (object) s.count, (object) target.name));
          effect = s.effectData.Instantiate();
          effect.Apply(s.count, target, applier);
          if (temporary)
            effect.temporary = s.count;
          StatusEffectSystem.activeEffects.Add(effect);
          Action<StatusEffectData> action = onEffectApplied;
          if (action != null)
            action(effect);
          if (effect.RunBeginEvent() && effect.HasBeginRoutine)
            yield return (object) effect.BeginRoutine();
        }
        if ((bool) (UnityEngine.Object) applier)
          effect.applierOwner = applier.owner;
        if (effect.RunStackEvent(s.count) && effect.HasStackRoutine)
          yield return (object) effect.StackRoutine(s.count);
        target.PromptUpdate();
        effect = (StatusEffectData) null;
      }
      if (target.startingEffectsApplied && target.display.init && fireEvents)
      {
        Events.InvokeStatusEffectApplied(s);
        yield return (object) StatusEffectSystem.PostApplyStatusEvent(s);
      }
      StatusEffectSystem.activeEffects.Thaw();
    }
  }

  public static IEnumerator Clear()
  {
    StatusEffectSystem.activeEffects.Freeze();
    for (int i = StatusEffectSystem.activeEffects.Count - 1; i >= 0; --i)
      yield return (object) StatusEffectSystem.activeEffects[i].Remove();
    StatusEffectSystem.activeEffects.Thaw();
  }

  public static IEnumerator EntityEnableEvent(Entity entity)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunEnableEvent(entity) && activeEffect.HasEnableRoutine)
          yield return (object) activeEffect.EnableRoutine(entity);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator EntityDisableEvent(Entity entity)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunDisableEvent(entity) && activeEffect.HasDisableRoutine)
          yield return (object) activeEffect.DisableRoutine(entity);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator TurnStartEvent(Entity entity)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunTurnStartEvent(entity) && activeEffect.HasTurnStartRoutine)
          yield return (object) activeEffect.TurnStartRoutine(entity);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator TurnEvent(Entity entity)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunTurnEvent(entity) && activeEffect.HasTurnRoutine)
          yield return (object) activeEffect.TurnRoutine(entity);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator TurnEndEvent(Entity entity)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunTurnEndEvent(entity) && activeEffect.HasTurnEndRoutine)
          yield return (object) activeEffect.TurnEndRoutine(entity);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator PreAttackEvent(Hit hit)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunPreAttackEvent(hit) && activeEffect.HasPreAttackRoutine)
          yield return (object) activeEffect.PreAttackRoutine(hit);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator HitEvent(Hit hit)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunHitEvent(hit) && activeEffect.HasHitRoutine)
          yield return (object) activeEffect.HitRoutine(hit);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator PostHitEvent(Hit hit)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunPostHitEvent(hit) && activeEffect.HasPostHitRoutine)
          yield return (object) activeEffect.PostHitRoutine(hit);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator PostAttackEvent(Hit hit)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunPostAttackEvent(hit) && activeEffect.HasPostAttackRoutine)
          yield return (object) activeEffect.PostAttackRoutine(hit);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator ApplyStatusEvent(StatusEffectApply apply)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunApplyStatusEvent(apply) && activeEffect.HasApplyStatusRoutine)
          yield return (object) activeEffect.ApplyStatusRoutine(apply);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator PostApplyStatusEvent(StatusEffectApply apply)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunPostApplyStatusEvent(apply) && activeEffect.HasPostApplyStatusRoutine)
          yield return (object) activeEffect.PostApplyStatusRoutine(apply);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator EntityDestroyedEvent(Entity entity, DeathType deathType)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    int i;
    for (i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunEntityDestroyedEvent(entity, deathType) && activeEffect.HasEntityDestroyedRoutine)
          yield return (object) activeEffect.EntityDestroyedRoutine(entity, deathType);
      }
      else
        break;
    }
    if (entity.statusEffects != null)
    {
      c = entity.statusEffects.Count;
      for (i = c - 1; i >= 0; --i)
      {
        int count = StatusEffectSystem.activeEffects.Count;
        if (count < c)
        {
          i -= c - count;
          c = count;
        }
        if (i >= 0)
        {
          StatusEffectData statusEffect = entity.statusEffects[i];
          if ((UnityEngine.Object) statusEffect.target != (UnityEngine.Object) null && statusEffect.RunDisableEvent(entity) && statusEffect.HasDisableRoutine)
            yield return (object) statusEffect.DisableRoutine(entity);
        }
        else
          break;
      }
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator CardMoveEvent(Entity entity)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunCardMoveEvent(entity) && activeEffect.HasCardMoveRoutine)
          yield return (object) activeEffect.CardMoveRoutine(entity);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator PreTriggerEvent(Trigger trigger)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunPreTriggerEvent(trigger) && activeEffect.HasPreTriggerRoutine)
          yield return (object) activeEffect.PreTriggerRoutine(trigger);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator PreCardPlayedEvent(Entity entity, Entity[] targets)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunPreCardPlayedEvent(entity, targets) && activeEffect.HasPreCardPlayedRoutine)
          yield return (object) activeEffect.PreCardPlayedRoutine(entity, targets);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator CardPlayedEvent(Entity entity, Entity[] targets)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunCardPlayedEvent(entity, targets) && activeEffect.HasCardPlayedRoutine)
          yield return (object) activeEffect.CardPlayedRoutine(entity, targets);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator EffectBonusChangedEvent(Entity entity)
  {
    ++StatusEffectSystem.eventRoutineCount;
    if (entity.statusEffects != null)
    {
      StatusEffectSystem.activeEffects.Freeze();
      int c = entity.statusEffects.Count;
      for (int i = c - 1; i >= 0; --i)
      {
        int count = StatusEffectSystem.activeEffects.Count;
        if (count < c)
        {
          i -= c - count;
          c = count;
        }
        if (i >= 0)
        {
          StatusEffectData statusEffect = entity.statusEffects[i];
          if ((UnityEngine.Object) statusEffect.target != (UnityEngine.Object) null && statusEffect.RunEffectBonusChangedEvent() && statusEffect.HasEffectBonusChangedRoutine)
            yield return (object) statusEffect.EffectBonusChangedRoutine();
        }
        else
          break;
      }
      StatusEffectSystem.activeEffects.Thaw();
    }
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator ActionPerformedEvent(PlayAction action)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunActionPerformedEvent(action) && activeEffect.HasActionPerformedRoutine)
          yield return (object) activeEffect.ActionPerformedRoutine(action);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public static IEnumerator BuildEvent(Entity entity)
  {
    ++StatusEffectSystem.eventRoutineCount;
    StatusEffectSystem.activeEffects.Freeze();
    int c = StatusEffectSystem.activeEffects.Count;
    for (int i = c - 1; i >= 0; --i)
    {
      int count = StatusEffectSystem.activeEffects.Count;
      if (count < c)
      {
        i -= c - count;
        c = count;
      }
      if (i >= 0)
      {
        StatusEffectData activeEffect = StatusEffectSystem.activeEffects[i];
        if ((UnityEngine.Object) activeEffect.target != (UnityEngine.Object) null && activeEffect.RunBuildEvent(entity) && activeEffect.HasBuildRoutine)
          yield return (object) activeEffect.BuildRoutine(entity);
      }
      else
        break;
    }
    StatusEffectSystem.activeEffects.Thaw();
    --StatusEffectSystem.eventRoutineCount;
    yield return (object) Sequences.Null();
  }

  public class StatusEffectComparer : IComparer<StatusEffectData>
  {
    public int Compare(StatusEffectData x, StatusEffectData y) => ((UnityEngine.Object) x != (UnityEngine.Object) null ? x.eventPriority : 0) >= ((UnityEngine.Object) y != (UnityEngine.Object) null ? y.eventPriority : 0) ? 1 : -1;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectTemporaryTrait
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific Effects/Temporary Trait", fileName = "Temporary Trait")]
public class StatusEffectTemporaryTrait : StatusEffectData
{
  [SerializeField]
  public TraitData trait;
  public List<Entity.TraitStacks> silenced;
  public Entity.TraitStacks added;
  public int addedAmount;

  public override bool HasStackRoutine => true;

  public override IEnumerator StackRoutine(int stacks)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectTemporaryTrait effectTemporaryTrait = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      effectTemporaryTrait.addedAmount += stacks;
      effectTemporaryTrait.target.display.promptUpdateDescription = true;
      effectTemporaryTrait.target.PromptUpdate();
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    effectTemporaryTrait.added = effectTemporaryTrait.target.GainTrait(effectTemporaryTrait.trait, stacks, true);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) effectTemporaryTrait.target.UpdateTraits();
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override bool HasEndRoutine => true;

  public override IEnumerator EndRoutine()
  {
    StatusEffectTemporaryTrait effectTemporaryTrait = this;
    if ((bool) (Object) effectTemporaryTrait.target)
    {
      if (effectTemporaryTrait.added != null)
      {
        effectTemporaryTrait.added.count -= effectTemporaryTrait.addedAmount;
        effectTemporaryTrait.added.tempCount -= effectTemporaryTrait.addedAmount;
      }
      effectTemporaryTrait.addedAmount = 0;
      yield return (object) effectTemporaryTrait.target.UpdateTraits(effectTemporaryTrait.added);
      effectTemporaryTrait.target.display.promptUpdateDescription = true;
      effectTemporaryTrait.target.PromptUpdate();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectTriggerAgainstAttackerWhenHit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Reactions/Trigger Against Attacker When Hit", fileName = "Trigger Against Attacker When Hit")]
public class StatusEffectTriggerAgainstAttackerWhenHit : StatusEffectReaction
{
  public Entity attacker;
  public Entity previousTarget;
  public int? effectiveHealthState;

  public override bool RunTurnEndEvent(Entity entity)
  {
    if (this.effectiveHealthState.HasValue && (Object) entity == (Object) this.target)
    {
      this.previousTarget = (Entity) null;
      this.effectiveHealthState = new int?();
    }
    return false;
  }

  public override bool RunHitEvent(Hit hit)
  {
    if ((Object) hit.target == (Object) this.target && hit.canRetaliate && !(bool) (Object) this.attacker && hit.Offensive && hit.BasicHit && (bool) (Object) hit.target && (bool) (Object) hit.attacker)
    {
      Trigger trigger = hit.trigger;
      if (trigger != null && trigger.countsAsTrigger)
        this.attacker = hit.attacker;
    }
    return false;
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if ((bool) (Object) this.attacker && (Object) entity == (Object) this.attacker)
    {
      this.attacker = (Entity) null;
      if (Battle.IsOnBoard(this.target) && this.CanTrigger())
        this.Run(entity);
    }
    return false;
  }

  public void Run(Entity entity)
  {
    if (!(bool) (Object) entity.data || !entity.data.cardType.unit)
    {
      Entity entity1 = entity.owner?.entity;
      if ((bool) (Object) entity1 && entity1.canBeHit)
      {
        entity = entity.owner?.entity;
        if ((Object) entity == (Object) this.target.owner?.entity)
          entity = (Entity) null;
      }
    }
    if (!(bool) (Object) entity || !entity.canBeHit || !entity.IsAliveAndExists())
      return;
    int effectiveHealthState = StatusEffectTriggerAgainstAttackerWhenHit.CalculateEffectiveHealthState();
    if (this.effectiveHealthState.HasValue && (bool) (Object) this.previousTarget && (Object) this.previousTarget == (Object) entity && effectiveHealthState == this.effectiveHealthState.Value)
    {
      Debug.LogWarning((object) "Smackback infinite loop detected!");
    }
    else
    {
      this.previousTarget = entity;
      this.effectiveHealthState = new int?(effectiveHealthState);
      CardContainer targetRow = Trigger.GetTargetRow(this.target, entity);
      ActionTriggerSubsequent action = new ActionTriggerSubsequent(this.target, entity, entity, targetRow);
      action.triggerType = "smackback";
      ActionQueue.Stack((PlayAction) action, true);
    }
  }

  public static int CalculateEffectiveHealthState()
  {
    int effectiveHealthState = 0;
    foreach (Entity entity in Battle.GetCardsOnBoard())
      effectiveHealthState += StatusEffectTriggerAgainstAttackerWhenHit.GetEffectiveHealth(entity);
    return effectiveHealthState;
  }

  public static int GetEffectiveHealth(Entity entity)
  {
    int current = entity.hp.current;
    foreach (StatusEffectData statusEffect in entity.statusEffects)
    {
      switch (statusEffect.type)
      {
        case "shell":
        case "scrap":
        case "block":
          current += statusEffect.count;
          continue;
        case "overload":
          current -= statusEffect.count;
          continue;
        case "shroom":
          current -= Mathf.Min(statusEffect.count, entity.hp.current);
          continue;
        default:
          continue;
      }
    }
    return current;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectTriggerWhenAllyAttacks
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Reactions/Trigger When Ally In Row Attacks", fileName = "Trigger When Ally In Row Attacks")]
public class StatusEffectTriggerWhenAllyAttacks : StatusEffectReaction
{
  [SerializeField]
  public bool allyInRow = true;
  [SerializeField]
  public bool againstTarget;
  public readonly HashSet<Entity> prime = new HashSet<Entity>();

  public override bool RunHitEvent(Hit hit)
  {
    if (this.target.enabled && Battle.IsOnBoard(this.target) && hit.countsAsHit && hit.Offensive && (bool) (Object) hit.target && this.CheckEntity(hit.attacker))
      this.prime.Add(hit.attacker);
    return false;
  }

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (this.prime.Count > 0 && this.prime.Contains(entity) && targets != null && targets.Length > 0)
    {
      this.prime.Remove(entity);
      if (Battle.IsOnBoard(this.target) && this.CanTrigger())
        this.Run(entity, targets);
    }
    return false;
  }

  public void Run(Entity attacker, Entity[] targets)
  {
    if (this.againstTarget)
    {
      foreach (Entity target in targets)
        ActionQueue.Stack((PlayAction) new ActionTriggerAgainst(this.target, attacker, target, (CardContainer) null), true);
    }
    else
      ActionQueue.Stack((PlayAction) new ActionTrigger(this.target, attacker), true);
  }

  public bool CheckEntity(Entity entity) => (bool) (Object) entity && entity.owner.team == this.target.owner.team && (Object) entity != (Object) this.target && this.CheckRow(entity) && Battle.IsOnBoard(entity) && this.CheckDuplicate(entity) && this.CheckDuplicate(entity.triggeredBy);

  public bool CheckRow(Entity entity) => !this.allyInRow || ((IList<CardContainer>) entity.containers).ContainsAny<CardContainer>((IEnumerable<CardContainer>) this.target.containers);

  public bool CheckDuplicate(Entity entity)
  {
    if (!entity.IsAliveAndExists())
      return true;
    foreach (Object statusEffect in entity.statusEffects)
    {
      if (statusEffect.name == this.name)
        return false;
    }
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectTriggerWhenCardTypeUsedOnAlly
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Reactions/Trigger When Card Type Used On Ally", fileName = "Trigger When Card Type Used On Ally")]
public class StatusEffectTriggerWhenCardTypeUsedOnAlly : StatusEffectReaction
{
  [SerializeField]
  public bool includeSelf;
  [SerializeField]
  public string[] cardTypeTriggers;

  public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
  {
    if (this.CheckCardType(entity) && this.CheckTargets(targets) && Battle.IsOnBoard(this.target) && this.CanTrigger())
      ActionQueue.Stack((PlayAction) new ActionTrigger(this.target, entity), true);
    return false;
  }

  public bool CheckCardType(Entity entity)
  {
    bool flag = false;
    string tag = entity.data?.cardType?.tag;
    if (tag != null)
    {
      foreach (string cardTypeTrigger in this.cardTypeTriggers)
      {
        if (tag.Equals(cardTypeTrigger))
        {
          flag = true;
          break;
        }
      }
    }
    return flag;
  }

  public bool CheckTargets(Entity[] targets)
  {
    bool flag = false;
    foreach (Entity target in targets)
    {
      if ((Object) target.owner == (Object) this.target.owner && ((Object) target != (Object) this.target || this.includeSelf))
      {
        flag = true;
        break;
      }
    }
    return flag;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectTriggerWhenDeployed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Trigger When Deployed", fileName = "Trigger When Deployed")]
public class StatusEffectTriggerWhenDeployed : StatusEffectData
{
  public bool isAlreadyOnBoard;

  public override object GetMidBattleData() => (object) Battle.IsOnBoard(this.target);

  public override void RestoreMidBattleData(object data)
  {
    if (!(data is bool flag))
      return;
    this.isAlreadyOnBoard = flag && Battle.IsOnBoard(this.target);
  }

  public override void Init()
  {
    this.OnEnable += new StatusEffectData.EffectEntityEventHandler(this.Enable);
    this.OnCardMove += new StatusEffectData.EffectEntityEventHandler(this.CardMove);
  }

  public override bool RunEnableEvent(Entity entity)
  {
    if (this.isAlreadyOnBoard)
    {
      this.isAlreadyOnBoard = false;
      return false;
    }
    return (Object) entity == (Object) this.target && Battle.IsOnBoard(this.target);
  }

  public IEnumerator Enable(Entity entity)
  {
    yield return (object) Sequences.Wait(0.2f);
    yield return (object) this.Activate();
  }

  public override bool RunCardMoveEvent(Entity entity) => (Object) this.target == (Object) entity && this.target.enabled && Battle.IsOnBoard(this.target) && !Battle.IsOnBoard(entity.preContainers);

  public IEnumerator CardMove(Entity entity)
  {
    yield return (object) Sequences.Wait(0.2f);
    yield return (object) this.Activate();
  }

  public IEnumerator Activate()
  {
    StatusEffectTriggerWhenDeployed triggerWhenDeployed = this;
    if (!triggerWhenDeployed.target.silenced)
    {
      yield return (object) Sequences.Wait(0.1f);
      CurveAnimator curveAnimator = triggerWhenDeployed.target.curveAnimator;
      if (curveAnimator != null)
      {
        double num = (double) curveAnimator.Ping();
      }
      yield return (object) Sequences.Wait(0.5f);
      ActionQueue.Stack((PlayAction) new ActionTrigger(triggerWhenDeployed.target, (Entity) null), true);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectTriggerWhenStatusApplied
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Reactions/Trigger When Status Applied", fileName = "Trigger When Status Applied")]
public class StatusEffectTriggerWhenStatusApplied : StatusEffectReaction
{
  [SerializeField]
  public StatusEffectData targetStatus;
  [SerializeField]
  public bool friendlyFire = true;
  [SerializeField]
  public bool selfFire = true;
  [SerializeField]
  public StatusEffectTriggerWhenStatusApplied.TriggerType triggerType;
  public int busy;
  public int triggerIndex;

  public override void Init() => this.PostApplyStatus += new StatusEffectData.EffectApplyEventHandler(this.Run);

  public override bool RunPostApplyStatusEvent(StatusEffectApply apply) => this.target.enabled && Battle.IsOnBoard(this.target) && this.Check(apply) && this.CanTrigger();

  public IEnumerator Run(StatusEffectApply apply)
  {
    StatusEffectTriggerWhenStatusApplied whenStatusApplied = this;
    int i = whenStatusApplied.triggerIndex + whenStatusApplied.busy;
    ++whenStatusApplied.busy;
    yield return (object) new WaitUntil((Func<bool>) (() => this.triggerIndex == i));
    switch (whenStatusApplied.triggerType)
    {
      case StatusEffectTriggerWhenStatusApplied.TriggerType.Normal:
        ActionQueue.Stack((PlayAction) new ActionTrigger(whenStatusApplied.target, apply.applier), true);
        break;
      case StatusEffectTriggerWhenStatusApplied.TriggerType.Target:
        if ((bool) (UnityEngine.Object) apply.target && apply.target.alive)
        {
          CardContainer targetRow = Trigger.GetTargetRow(whenStatusApplied.target, apply.target);
          ActionQueue.Stack((PlayAction) new ActionTriggerSubsequent(whenStatusApplied.target, apply.applier, apply.target, targetRow), true);
          break;
        }
        break;
      case StatusEffectTriggerWhenStatusApplied.TriggerType.Applier:
        if ((bool) (UnityEngine.Object) apply.applier && apply.applier.alive)
        {
          CardContainer targetRow = Trigger.GetTargetRow(whenStatusApplied.target, apply.target);
          ActionQueue.Stack((PlayAction) new ActionTriggerSubsequent(whenStatusApplied.target, apply.applier, apply.applier, targetRow), true);
          break;
        }
        break;
    }
    --whenStatusApplied.busy;
    ++whenStatusApplied.triggerIndex;
  }

  public bool Check(StatusEffectApply apply) => (this.friendlyFire || !((UnityEngine.Object) apply.applier?.owner == (UnityEngine.Object) this.target.owner)) && (this.selfFire || !((UnityEngine.Object) apply.applier == (UnityEngine.Object) this.target)) && apply.effectData?.type == this.targetStatus?.type && this.CheckDuplicate(apply.applier) && this.CheckDuplicate(apply.applier.triggeredBy);

  public bool CheckDuplicate(Entity entity)
  {
    if (!(bool) (UnityEngine.Object) entity)
      return true;
    foreach (UnityEngine.Object statusEffect in entity.statusEffects)
    {
      if (statusEffect.name == this.name)
        return false;
    }
    return true;
  }

  public enum TriggerType
  {
    Normal,
    Target,
    Applier,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectUnmovable
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Traits/Unmovable", fileName = "Unmovable")]
public class StatusEffectUnmovable : StatusEffectData
{
  public override void Init() => Events.OnCheckAction += new Events.UnityActionRef<PlayAction, bool>(this.CheckAction);

  public void OnDestroy() => Events.OnCheckAction -= new Events.UnityActionRef<PlayAction, bool>(this.CheckAction);

  public void CheckAction(ref PlayAction action, ref bool allow)
  {
    if (!allow || this.target.silenced || !(action is ActionMove actionMove) || !((Object) actionMove.entity == (Object) this.target) || !Battle.IsOnBoard(this.target) || !Battle.IsOnBoard(actionMove.toContainers))
      return;
    allow = false;
    if (!NoTargetTextSystem.Exists())
      return;
    Routine routine = new Routine(NoTargetTextSystem.Run(this.target, NoTargetType.CantMove));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectVim
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Vim", fileName = "Vim")]
public class StatusEffectVim : StatusEffectData
{
  public override void Init() => this.OnHit += new StatusEffectData.EffectHitEventHandler(this.Check);

  public override bool RunHitEvent(Hit hit) => (Object) hit.target == (Object) this.target && hit.Offensive && hit.canBeNullified && hit.BasicHit;

  public IEnumerator Check(Hit hit)
  {
    StatusEffectVim statusEffectVim = this;
    hit.dodged = true;
    hit.countsAsHit = false;
    hit.damageBlocked = hit.damage;
    hit.damage = 0;
    if ((bool) (Object) hit.attacker && hit.attacker.canBeHit && hit.canRetaliate)
      yield return (object) new Hit(statusEffectVim.target, hit.attacker, statusEffectVim.count)
      {
        canRetaliate = false,
        damageType = "vim"
      }.Process();
    ActionQueue.Stack((PlayAction) new ActionSequence(statusEffectVim.CountDown()), true);
  }

  public IEnumerator CountDown()
  {
    StatusEffectVim status = this;
    int count = status.count;
    Events.InvokeStatusEffectCountDown((StatusEffectData) status, ref count);
    if (count != 0)
      yield return (object) status.CountDown(status.target, count);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectWeakness
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Weakness", fileName = "Weakness")]
public class StatusEffectWeakness : StatusEffectData
{
  public override void Init() => this.OnHit += new StatusEffectData.EffectHitEventHandler(this.Hit);

  public override bool RunHitEvent(global::Hit hit) => hit.Offensive && this.count > 0 && (Object) hit.target == (Object) this.target;

  public IEnumerator Hit(global::Hit hit)
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectWeakness statusEffectWeakness = this;
    if (num != 0)
      return false;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    hit.damage += statusEffectWeakness.count;
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectWhileActiveAlliesImmuneToX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/While Active Allies Immune To X", fileName = "While Active Allies Immune To X")]
public class StatusEffectWhileActiveAlliesImmuneToX : StatusEffectData
{
  public List<Entity> affected = new List<Entity>();
  public bool pingDone;
  [SerializeField]
  public StatusEffectData immunityEffect;

  public override void Init()
  {
    this.OnEnable += new StatusEffectData.EffectEntityEventHandler(this.Enable);
    this.OnDisable += new StatusEffectData.EffectEntityEventHandler(this.Disable);
    this.OnCardMove += new StatusEffectData.EffectEntityEventHandler(this.CardMove);
  }

  public override bool RunEnableEvent(Entity entity) => (Object) entity == (Object) this.target;

  public IEnumerator Enable(Entity entity)
  {
    StatusEffectWhileActiveAlliesImmuneToX activeAlliesImmuneToX = this;
    if (!activeAlliesImmuneToX.pingDone)
    {
      CurveAnimator curveAnimator = activeAlliesImmuneToX.target.curveAnimator;
      if (curveAnimator != null)
      {
        double num = (double) curveAnimator.Ping();
      }
      activeAlliesImmuneToX.pingDone = true;
    }
    foreach (Entity ally in activeAlliesImmuneToX.target.GetAllies())
      yield return (object) activeAlliesImmuneToX.Affect(ally);
  }

  public override bool RunDisableEvent(Entity entity) => (Object) entity == (Object) this.target;

  public IEnumerator Disable(Entity entity)
  {
    foreach (Entity entity1 in this.affected)
      yield return (object) this.UnAffect(entity1);
    this.affected.Clear();
  }

  public override bool RunCardMoveEvent(Entity entity) => this.target.enabled && (Object) entity != (Object) this.target && (Object) entity.owner == (Object) this.target.owner && Battle.IsOnBoard(entity);

  public IEnumerator CardMove(Entity entity)
  {
    yield return (object) this.Affect(entity);
  }

  public IEnumerator Affect(Entity entity)
  {
    StatusEffectWhileActiveAlliesImmuneToX activeAlliesImmuneToX = this;
    if (!activeAlliesImmuneToX.affected.Contains(entity))
    {
      yield return (object) StatusEffectSystem.Apply(entity, activeAlliesImmuneToX.target, activeAlliesImmuneToX.immunityEffect, 1, true);
      entity.PromptUpdate();
      activeAlliesImmuneToX.affected.Add(entity);
    }
  }

  public IEnumerator UnAffect(Entity entity)
  {
    if (this.affected.Contains(entity))
    {
      for (int i = entity.statusEffects.Count - 1; i >= 0; --i)
      {
        StatusEffectData statusEffect = entity.statusEffects[i];
        if ((bool) (Object) statusEffect && statusEffect.name == this.immunityEffect.name)
          yield return (object) statusEffect.RemoveStacks(1, true);
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectWhileActiveApplyXToEachCardPlayed
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Reactions/While Active Apply X To Each Card Played", fileName = "While Active Apply X To Each Card Played")]
public class StatusEffectWhileActiveApplyXToEachCardPlayed : StatusEffectReaction
{
  [SerializeField]
  public StatusEffectData effectToApply;

  public override void Init() => this.PreCardPlayed += new StatusEffectData.EffectCardPlayEventHandler(this.Activate);

  public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets) => this.CheckEntity(entity) && this.CanTrigger() && Battle.IsOnBoard(this.target);

  public IEnumerator Activate(Entity entity, Entity[] targets)
  {
    yield return (object) this.Run(entity);
  }

  public IEnumerator Run(Entity entity)
  {
    StatusEffectWhileActiveApplyXToEachCardPlayed xtoEachCardPlayed = this;
    Hit hit = new Hit(xtoEachCardPlayed.target, entity, 0);
    hit.AddStatusEffect(xtoEachCardPlayed.effectToApply, xtoEachCardPlayed.GetAmount());
    Routine.Clump clump = new Routine.Clump();
    clump.Add(hit.Process());
    CurveAnimator curveAnimator = xtoEachCardPlayed.target.curveAnimator;
    if (curveAnimator != null)
    {
      double num = (double) curveAnimator.Ping();
    }
    clump.Add(Sequences.Wait(0.3f));
    yield return (object) clump.WaitForEnd();
  }

  public bool CheckEntity(Entity entity) => (Object) entity.owner == (Object) this.target.owner && (Object) entity.owner != (Object) null && (Object) entity.data != (Object) null && entity.data.cardType.item;
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectWhileActiveX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

[CreateAssetMenu(menuName = "Status Effects/Specific/While Active X", fileName = "While Active X")]
public class StatusEffectWhileActiveX : StatusEffectApplyX
{
  [SerializeField]
  public bool ifCloneAffectOriginal = true;
  [SerializeField]
  public bool affectOthersWithSameEffect = true;
  public bool active;
  public int currentAmount;
  public readonly List<Entity> affected = new List<Entity>();
  public bool pingDone;
  public readonly List<CardContainer> containersToAffect = new List<CardContainer>();
  public bool affectsSelf;
  public bool targetIsClone;
  public ulong cloneOriginalId;

  public bool AffectsRow() => this.applyToFlags.HasFlag((Enum) StatusEffectApplyX.ApplyToFlags.AlliesInRow) || this.applyToFlags.HasFlag((Enum) StatusEffectApplyX.ApplyToFlags.EnemiesInRow) || this.applyToFlags.HasFlag((Enum) StatusEffectApplyX.ApplyToFlags.FrontAlly) || this.applyToFlags.HasFlag((Enum) StatusEffectApplyX.ApplyToFlags.BackAlly) || this.applyToFlags.HasFlag((Enum) StatusEffectApplyX.ApplyToFlags.FrontEnemy);

  public bool AffectsSlot() => this.applyToFlags.HasFlag((Enum) StatusEffectApplyX.ApplyToFlags.AllyInFrontOf) || this.applyToFlags.HasFlag((Enum) StatusEffectApplyX.ApplyToFlags.AllyBehind) || this.applyToFlags.HasFlag((Enum) StatusEffectApplyX.ApplyToFlags.FrontAlly) || this.applyToFlags.HasFlag((Enum) StatusEffectApplyX.ApplyToFlags.BackAlly);

  public override void Init()
  {
    this.OnBegin += new StatusEffectData.EffectEventHandler(this.Begin);
    this.OnEnable += new StatusEffectData.EffectEntityEventHandler(this.Enable);
    this.OnDisable += new StatusEffectData.EffectEntityEventHandler(this.Disable);
    this.OnCardMove += new StatusEffectData.EffectEntityEventHandler(this.CardMove);
    this.OnEffectBonusChanged += new StatusEffectData.EffectEventHandler(this.EffectBonusChanged);
    global::Events.OnEntityDataUpdated += new UnityAction<Entity>(this.EntityDataUpdated);
    global::Events.OnEntityDisplayUpdated += new UnityAction<Entity>(this.EntityDisplayUpdated);
    this.pingDone = !this.doPing;
    this.targetIsClone = this.target.data.TryGetCustomData<ulong>("splitOriginalId", out this.cloneOriginalId, 0UL);
  }

  public virtual void OnDestroy()
  {
    global::Events.OnEntityDataUpdated -= new UnityAction<Entity>(this.EntityDataUpdated);
    global::Events.OnEntityDisplayUpdated -= new UnityAction<Entity>(this.EntityDisplayUpdated);
  }

  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
  {
    int index = this.affected.IndexOf(entity);
    if (index >= 0)
      this.affected.RemoveAt(index);
    return false;
  }

  public void EntityDataUpdated(Entity entity)
  {
    if (!this.active || !this.affected.Contains(entity))
      return;
    ActionQueue.Add((PlayAction) new ActionSequence(this.ReAffect(entity)));
  }

  public void EntityDisplayUpdated(Entity entity)
  {
    if (!this.active || !((UnityEngine.Object) entity == (UnityEngine.Object) this.target) || this.GetAmount(this.target) == this.currentAmount)
      return;
    ActionQueue.Add((PlayAction) new ActionRefreshWhileActiveEffect(this));
  }

  public virtual bool CanActivate() => Battle.IsOnBoard(this.target);

  public virtual bool CheckActivateOnMove(
    CardContainer[] fromContainers,
    CardContainer[] toContainers)
  {
    return Battle.IsOnBoard(toContainers) && !Battle.IsOnBoard(fromContainers);
  }

  public virtual bool CheckDeactivateOnMove(
    CardContainer[] fromContainers,
    CardContainer[] toContainers)
  {
    return !Battle.IsOnBoard(toContainers) && Battle.IsOnBoard(fromContainers);
  }

  public static bool CompareContainerArrays(
    IReadOnlyList<CardContainer> a,
    IReadOnlyList<CardContainer> b)
  {
    if (a.Count != b.Count)
      return false;
    for (int index = 0; index < a.Count; ++index)
    {
      if ((UnityEngine.Object) a[index] != (UnityEngine.Object) b[index])
        return false;
    }
    return true;
  }

  public override bool RunBeginEvent() => this.target.enabled && this.CanActivate();

  public IEnumerator Begin() => this.Activate();

  public override bool RunEnableEvent(Entity entity) => !this.active && (UnityEngine.Object) entity == (UnityEngine.Object) this.target && this.CanActivate();

  public IEnumerator Enable(Entity entity) => this.Activate();

  public override bool RunDisableEvent(Entity entity) => (UnityEngine.Object) entity == (UnityEngine.Object) this.target;

  public virtual IEnumerator Disable(Entity entity) => this.Deactivate();

  public override bool RunCardMoveEvent(Entity entity)
  {
    if (!this.target.enabled)
      return false;
    return (UnityEngine.Object) this.target == (UnityEngine.Object) entity || this.active;
  }

  public virtual IEnumerator CardMove(Entity entity)
  {
    StatusEffectWhileActiveX effectWhileActiveX = this;
    if ((UnityEngine.Object) effectWhileActiveX.target == (UnityEngine.Object) entity)
    {
      CardContainer[] preContainers = entity.preContainers;
      if (effectWhileActiveX.active)
      {
        if (effectWhileActiveX.CheckDeactivateOnMove(preContainers, entity.containers))
          yield return (object) effectWhileActiveX.Deactivate();
        else if (effectWhileActiveX.AffectsRow())
        {
          if (!StatusEffectWhileActiveX.CompareContainerArrays((IReadOnlyList<CardContainer>) preContainers, (IReadOnlyList<CardContainer>) entity.containers))
          {
            yield return (object) effectWhileActiveX.Deactivate();
            yield return (object) effectWhileActiveX.Activate();
          }
        }
        else if (effectWhileActiveX.AffectsSlot())
        {
          yield return (object) effectWhileActiveX.Deactivate();
          yield return (object) effectWhileActiveX.Activate();
        }
      }
      else if (effectWhileActiveX.CheckActivateOnMove(preContainers, entity.containers))
        yield return (object) effectWhileActiveX.Activate();
    }
    else if (effectWhileActiveX.active)
    {
      if (effectWhileActiveX.AffectsSlot())
      {
        CardContainer[] array = effectWhileActiveX.containersToAffect.Select<CardContainer, CardContainer>((Func<CardContainer, CardContainer>) (a => a.Group)).ToArray<CardContainer>();
        if (((IList<CardContainer>) entity.containers).ContainsAny<CardContainer>((IEnumerable<CardContainer>) array) || ((IList<CardContainer>) entity.preContainers).ContainsAny<CardContainer>((IEnumerable<CardContainer>) array))
        {
          yield return (object) effectWhileActiveX.Deactivate();
          yield return (object) effectWhileActiveX.Activate();
        }
      }
      else if (effectWhileActiveX.affected.Contains(entity))
      {
        if (!effectWhileActiveX.containersToAffect.ContainsAny<CardContainer>((IEnumerable<CardContainer>) entity.containers))
          yield return (object) effectWhileActiveX.UnAffect(entity);
      }
      else if (effectWhileActiveX.containersToAffect.ContainsAny<CardContainer>((IEnumerable<CardContainer>) entity.containers))
        yield return (object) effectWhileActiveX.Affect(entity);
    }
  }

  public override bool RunEffectBonusChangedEvent() => this.target.enabled && this.active;

  public IEnumerator EffectBonusChanged()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    StatusEffectWhileActiveX effect = this;
    if (num != 0)
      return false;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    ActionQueue.Add((PlayAction) new ActionRefreshWhileActiveEffect(effect));
    return false;
  }

  public IEnumerator Activate()
  {
    StatusEffectWhileActiveX effectWhileActiveX = this;
    effectWhileActiveX.active = true;
    if (!effectWhileActiveX.pingDone)
    {
      CurveAnimator curveAnimator = effectWhileActiveX.target.curveAnimator;
      if (curveAnimator != null)
      {
        double num = (double) curveAnimator.Ping();
      }
      effectWhileActiveX.pingDone = true;
    }
    effectWhileActiveX.currentAmount = effectWhileActiveX.GetAmount(effectWhileActiveX.target);
    effectWhileActiveX.FindContainers();
    List<Entity> entityList = new List<Entity>();
    if (effectWhileActiveX.affectsSelf)
      entityList.Add(effectWhileActiveX.target);
    foreach (CardContainer cardContainer in effectWhileActiveX.containersToAffect)
    {
      foreach (Entity entity in cardContainer)
      {
        if (!entityList.Contains(entity) && (UnityEngine.Object) entity != (UnityEngine.Object) effectWhileActiveX.target)
          entityList.Add(entity);
      }
    }
    Routine.Clump clump = new Routine.Clump();
    foreach (Entity entity in entityList)
      clump.Add(effectWhileActiveX.Affect(entity));
    yield return (object) clump.WaitForEnd();
  }

  public IEnumerator Deactivate()
  {
    this.active = false;
    Routine.Clump clump = new Routine.Clump();
    foreach (Entity entity in this.affected)
      clump.Add(this.UnAffect(entity));
    yield return (object) clump.WaitForEnd();
    this.affected.Clear();
  }

  public void FindContainers()
  {
    this.containersToAffect.Clear();
    Character opponent = Battle.GetOpponent(this.target.owner);
    int[] rowIndices = Battle.instance.GetRowIndices(this.target);
    this.affectsSelf = this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Self);
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Allies))
      this.containersToAffect.AddRange((IEnumerable<CardContainer>) Battle.instance.GetRows(this.target.owner));
    else if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.AlliesInRow))
    {
      foreach (int rowIndex in rowIndices)
        this.containersToAffect.Add(Battle.instance.GetRow(this.target.owner, rowIndex));
    }
    else
    {
      if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.FrontAlly))
      {
        foreach (int rowIndex in rowIndices)
        {
          if (Battle.instance.GetRow(this.target.owner, rowIndex) is CardSlotLane row)
            this.containersToAffect.AddIfNotNull<CardContainer>((CardContainer) row.slots.FirstOrDefault<CardSlot>((Func<CardSlot, bool>) (a => !a.Empty)));
        }
      }
      if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.BackAlly))
      {
        foreach (int rowIndex in rowIndices)
        {
          if (Battle.instance.GetRow(this.target.owner, rowIndex) is CardSlotLane row)
            this.containersToAffect.AddIfNotNull<CardContainer>((CardContainer) row.slots.LastOrDefault<CardSlot>((Func<CardSlot, bool>) (a => !a.Empty)));
        }
      }
      if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.AllyInFrontOf))
      {
        foreach (int rowIndex in rowIndices)
        {
          if (Battle.instance.GetRow(this.target.owner, rowIndex) is CardSlotLane row)
          {
            for (int index = row.IndexOf(this.target) - 1; index >= 0; --index)
            {
              CardSlot slot = row.slots[index];
              if (!slot.Empty)
              {
                this.containersToAffect.Add((CardContainer) slot);
                break;
              }
            }
          }
        }
      }
      if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.AllyBehind))
      {
        foreach (int rowIndex in rowIndices)
        {
          if (Battle.instance.GetRow(this.target.owner, rowIndex) is CardSlotLane row)
          {
            for (int index = row.IndexOf(this.target) + 1; index < row.slots.Count; ++index)
            {
              CardSlot slot = row.slots[index];
              if (!slot.Empty)
              {
                this.containersToAffect.Add((CardContainer) slot);
                break;
              }
            }
          }
        }
      }
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Enemies))
      this.containersToAffect.AddRange((IEnumerable<CardContainer>) Battle.instance.GetRows(opponent));
    else if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.EnemiesInRow))
    {
      foreach (int rowIndex in rowIndices)
        this.containersToAffect.Add(Battle.instance.GetRow(opponent, rowIndex));
    }
    if (this.AppliesTo(StatusEffectApplyX.ApplyToFlags.Hand) && (bool) (UnityEngine.Object) References.Player)
      this.containersToAffect.AddIfNotNull<CardContainer>(References.Player.handContainer);
    if (!this.AppliesTo(StatusEffectApplyX.ApplyToFlags.EnemyHand) || !(bool) (UnityEngine.Object) opponent)
      return;
    this.containersToAffect.AddIfNotNull<CardContainer>(opponent.handContainer);
  }

  public IEnumerator Affect(Entity entity)
  {
    StatusEffectWhileActiveX effectWhileActiveX = this;
    if (!effectWhileActiveX.affected.Contains(entity) && effectWhileActiveX.effectToApply.CanPlayOn(entity))
    {
      bool flag = false;
      if (effectWhileActiveX.targetIsClone && !effectWhileActiveX.ifCloneAffectOriginal)
      {
        ulong num;
        if (entity.data.TryGetCustomData<ulong>("splitOriginalId", out num, 0UL) && (long) effectWhileActiveX.cloneOriginalId == (long) num)
          flag = true;
        else if ((long) entity.data.id == (long) effectWhileActiveX.cloneOriginalId)
          flag = true;
      }
      if (!flag && !effectWhileActiveX.affectOthersWithSameEffect)
      {
        foreach (UnityEngine.Object statusEffect in entity.statusEffects)
        {
          if (statusEffect.name == effectWhileActiveX.name)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag && ((IEnumerable<TargetConstraint>) effectWhileActiveX.applyConstraints).All<TargetConstraint>((Func<TargetConstraint, bool>) (c => c.Check(entity))))
      {
        effectWhileActiveX.affected.Add(entity);
        if (effectWhileActiveX.currentAmount > 0)
        {
          yield return (object) StatusEffectSystem.Apply(entity, effectWhileActiveX.target, effectWhileActiveX.effectToApply, effectWhileActiveX.currentAmount, true);
          entity.PromptUpdate();
        }
      }
    }
  }

  public IEnumerator UnAffect(Entity entity)
  {
    StatusEffectWhileActiveX effectWhileActiveX = this;
    if (effectWhileActiveX.affected.Contains(entity))
    {
      for (int index = entity.statusEffects.Count - 1; index >= 0; --index)
      {
        StatusEffectData statusEffect = entity.statusEffects[index];
        if ((bool) (UnityEngine.Object) statusEffect && statusEffect.name == effectWhileActiveX.effectToApply.name)
        {
          yield return (object) statusEffect.RemoveStacks(effectWhileActiveX.currentAmount, true);
          break;
        }
      }
      effectWhileActiveX.affected.Remove(entity);
    }
  }

  public IEnumerator ReAffect(Entity entity)
  {
    if (this.affected.Contains(entity))
    {
      yield return (object) this.UnAffect(entity);
      yield return (object) this.Affect(entity);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectWhileInHandX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/While In Hand X", fileName = "While In Hand X")]
public class StatusEffectWhileInHandX : StatusEffectWhileActiveX
{
  public override bool CanActivate() => this.target.InHand();

  public override bool CheckActivateOnMove(
    CardContainer[] fromContainers,
    CardContainer[] toContainers)
  {
    return toContainers.Contains<CardContainer>(this.target.owner.handContainer) && !fromContainers.Contains<CardContainer>(this.target.owner.handContainer);
  }

  public override bool CheckDeactivateOnMove(
    CardContainer[] fromContainers,
    CardContainer[] toContainers)
  {
    return !toContainers.Contains<CardContainer>(this.target.owner.handContainer) && fromContainers.Contains<CardContainer>(this.target.owner.handContainer);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusEffectWhileLastInHandX
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(menuName = "Status Effects/Specific/While Last In Hand X", fileName = "While Last In Hand X")]
public class StatusEffectWhileLastInHandX : StatusEffectWhileActiveX
{
  public bool isInHand;

  public override void Init()
  {
    base.Init();
    this.OnEntityDestroyed += new StatusEffectData.EffectEntityDeathEventHandler(this.EntityDestroyed);
  }

  public override bool CanActivate() => this.isInHand && (UnityEngine.Object) this.target.owner.handContainer.FirstOrDefault<Entity>((Func<Entity, bool>) (a => a.alive)) == (UnityEngine.Object) this.target;

  public override bool RunBeginEvent()
  {
    this.isInHand = this.target.InHand();
    return base.RunBeginEvent();
  }

  public override bool RunEnableEvent(Entity entity)
  {
    if ((UnityEngine.Object) this.target == (UnityEngine.Object) entity)
      this.isInHand = this.target.InHand();
    return base.RunEnableEvent(entity);
  }

  public override bool RunCardMoveEvent(Entity entity) => this.target.enabled;

  public override IEnumerator CardMove(Entity entity)
  {
    StatusEffectWhileLastInHandX whileLastInHandX = this;
    if ((UnityEngine.Object) whileLastInHandX.target == (UnityEngine.Object) entity)
      whileLastInHandX.isInHand = whileLastInHandX.target.InHand();
    if (whileLastInHandX.active)
    {
      if (((UnityEngine.Object) whileLastInHandX.target == (UnityEngine.Object) entity || entity.containers.Contains<CardContainer>(whileLastInHandX.target.owner.handContainer)) && !whileLastInHandX.CanActivate())
        yield return (object) whileLastInHandX.Deactivate();
    }
    else if (whileLastInHandX.CanActivate())
      yield return (object) whileLastInHandX.Activate();
  }

  public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType) => !this.active && (UnityEngine.Object) entity != (UnityEngine.Object) this.target && this.EntityInHand(entity);

  public IEnumerator EntityDestroyed(Entity entity, DeathType deathType)
  {
    StatusEffectWhileLastInHandX whileLastInHandX = this;
    if (whileLastInHandX.CanActivate())
      yield return (object) whileLastInHandX.Activate();
  }

  public bool EntityInHand(Entity entity)
  {
    if ((bool) (UnityEngine.Object) entity)
    {
      CardContainer[] containers = entity.containers;
      if ((containers != null ? (containers.Length != 0 ? 1 : 0) : 0) != 0)
        return entity.containers.Contains<CardContainer>(this.target?.owner?.handContainer);
    }
    return entity.preContainers.Contains<CardContainer>(this.target?.owner?.handContainer);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusIcon
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class StatusIcon : MonoBehaviourRect
{
  [CompilerGenerated]
  public Entity \u003Ctarget\u003Ek__BackingField;
  public string type;
  public TMP_Text textElement;
  public bool persistent;
  [SerializeField]
  public bool alterTextColours = true;
  [ShowIf("alterTextColours")]
  public Color textColour = Color.black;
  [ShowIf("alterTextColours")]
  public Color textColourAboveMax = Color.white;
  [ShowIf("alterTextColours")]
  public Color textColourBelowMax = Color.white;
  [ShowIf("alterTextColours")]
  public Material textMaterialAboveMax;
  public Image fill;
  public Stat value;
  [SerializeField]
  public string textFormat = "{0}";
  [SerializeField]
  public int textAdd;
  public Material normalMaterial;
  public bool currentMaterialIsNormal = true;
  public UnityEvent onCreate;
  public UnityEventStatStat onValueDown;
  public UnityEventStatStat onValueUp;
  public UnityEvent afterUpdate;
  public UnityEvent onDestroy;

  public Entity target
  {
    get => this.\u003Ctarget\u003Ek__BackingField;
    set => this.\u003Ctarget\u003Ek__BackingField = value;
  }

  public virtual Stat GetValue() => this.value;

  public void SetValue(Stat value, bool doPing = true)
  {
    if (doPing)
      this.UpdateEvent(this.value, value);
    this.value = value;
    this.afterUpdate.Invoke();
    if (!(bool) (UnityEngine.Object) this.fill)
      return;
    this.fill.type = Image.Type.Filled;
    this.fill.fillAmount = Mathf.Clamp((float) value.current / (float) value.max, 0.0f, 1f);
  }

  public virtual void Assign(Entity entity) => this.target = entity;

  public void CreateEvent() => this.onCreate.Invoke();

  public void UpdateEvent(Stat previousValue, Stat newValue)
  {
    if (newValue.current < previousValue.current)
      this.onValueDown.Invoke(previousValue, newValue);
    else if (newValue.current > previousValue.current)
      this.onValueUp.Invoke(previousValue, newValue);
    global::Events.InvokeStatusIconChanged(this, previousValue, newValue);
  }

  public void DestroyEvent() => this.onDestroy.Invoke();

  public void SetText()
  {
    if (!(bool) (UnityEngine.Object) this.textElement)
      return;
    Stat stat = this.GetValue();
    this.textElement.text = string.Format(this.textFormat, (object) (stat.current + this.textAdd));
    if (!this.alterTextColours)
      return;
    this.textElement.color = stat.current > stat.max ? this.textColourAboveMax : (stat.current < stat.max ? this.textColourBelowMax : this.textColour);
    if (stat.current > stat.max)
    {
      if (!this.currentMaterialIsNormal || !(bool) (UnityEngine.Object) this.textMaterialAboveMax)
        return;
      this.normalMaterial = this.textElement.fontSharedMaterial;
      this.currentMaterialIsNormal = false;
      this.textElement.fontSharedMaterial = this.textMaterialAboveMax;
    }
    else
    {
      if (this.currentMaterialIsNormal || !(bool) (UnityEngine.Object) this.normalMaterial)
        return;
      this.currentMaterialIsNormal = true;
      this.textElement.fontSharedMaterial = this.normalMaterial;
    }
  }

  public void Ping()
  {
    if (!(bool) (UnityEngine.Object) this.rectTransform)
      return;
    this.rectTransform.LeanCancel();
    this.rectTransform.LeanScale(Vector3.one, 1f).setEaseOutElastic().setFrom(new Vector3(0.0f, 0.0f, 1f));
  }

  public virtual void CheckRemove()
  {
    if (this.persistent || (bool) (UnityEngine.Object) this.target.statusEffects.Find((Predicate<StatusEffectData>) (a => a.type == this.type)))
      return;
    this.SetValue(new Stat());
  }

  public void CheckDestroy(Stat previousValue, Stat newValue)
  {
    if (newValue.current > 0 || newValue.max > 0 || this.persistent)
      return;
    this.Destroy();
  }

  public void Destroy()
  {
    this.DestroyEvent();
    this.gameObject.Destroy();
  }

  [CompilerGenerated]
  public bool \u003CCheckRemove\u003Eb__31_0(StatusEffectData a) => a.type == this.type;
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusIconCharge
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class StatusIconCharge : StatusIcon
{
  public Sprite chargedSprite;
  public Material chargedMaterial;
  public Sprite snowSprite;
  public Material snowMaterial;
  public Image _image;
  public Sprite baseSprite;
  public Material baseMaterial;

  public Image image
  {
    get
    {
      if ((Object) this._image == (Object) null)
      {
        this._image = this.GetComponent<Image>();
        this.baseSprite = this._image.sprite;
      }
      return this._image;
    }
  }

  public void Awake() => this.baseMaterial = this.textElement.fontSharedMaterial;

  public void CheckSetSprite()
  {
    Stat stat = this.GetValue();
    Sprite sprite = this.baseSprite;
    Material material = this.baseMaterial;
    if ((Object) this.target != (Object) null && this.target.IsSnowed)
    {
      sprite = this.snowSprite ?? this.baseSprite;
      material = this.snowMaterial ?? this.baseMaterial;
      this.textElement.gameObject.SetActive(true);
    }
    else if (stat.current <= 0)
    {
      sprite = this.chargedSprite ?? this.baseSprite;
      material = this.chargedMaterial ?? this.baseMaterial;
      this.textElement.gameObject.SetActive(false);
    }
    else
      this.textElement.gameObject.SetActive(true);
    if ((Object) sprite != (Object) null)
      this.image.sprite = sprite;
    if (!((Object) material != (Object) null))
      return;
    this.textElement.fontSharedMaterial = material;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusIconCounter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class StatusIconCounter : StatusIcon
{
  [SerializeField]
  public Image image;
  [SerializeField]
  public Sprite customSprite;
  [SerializeField]
  public Material customMaterial;
  [SerializeField]
  public Sprite snowSprite;
  [SerializeField]
  public Material snowMaterial;
  public CardIdleAnimation imminentAnimation;
  public Sprite baseSprite;
  public Material baseMaterial;

  public void Awake()
  {
    this.baseSprite = this.image.sprite;
    this.baseMaterial = this.textElement.fontSharedMaterial;
  }

  public void CheckSetSprite()
  {
    Stat stat = this.GetValue();
    Sprite sprite = this.baseSprite;
    Material material = this.baseMaterial;
    if ((Object) this.target != (Object) null && this.target.IsSnowed)
    {
      sprite = this.snowSprite ?? this.baseSprite;
      material = this.snowMaterial ?? this.baseMaterial;
    }
    else if (stat.current <= 1)
    {
      sprite = this.customSprite ?? this.baseSprite;
      material = this.customMaterial ?? this.baseMaterial;
    }
    if ((Object) sprite != (Object) null)
      this.image.sprite = sprite;
    if (!((Object) material != (Object) null))
      return;
    this.textElement.fontSharedMaterial = material;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusIconHealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof (StatusIcon))]
public class StatusIconHealth : MonoBehaviour
{
  [SerializeField]
  public StatusIconHealth.Type[] types;
  [SerializeField]
  public GameObject current;
  public StatusIcon _icon;

  public StatusIcon icon => this._icon ?? (this._icon = this.GetComponent<StatusIcon>());

  public void SetType()
  {
    if ((UnityEngine.Object) this.icon.target == (UnityEngine.Object) null)
      return;
    string cardTypeName = this.icon.target.data.cardType.name;
    if (!((UnityEngine.Object) this.current == (UnityEngine.Object) null) && !(this.current.name != cardTypeName))
      return;
    StatusIconHealth.Type type = Array.Find<StatusIconHealth.Type>(this.types, (Predicate<StatusIconHealth.Type>) (a => a.name == cardTypeName));
    if (type == null)
      return;
    this.current.SetActive(false);
    type.Assign(this.icon);
    this.current = type.group;
  }

  [Serializable]
  public class Type
  {
    public string name;
    public GameObject group;
    public TMP_Text textElement;
    public Image fill;

    public void Assign(StatusIcon icon)
    {
      this.group.SetActive(true);
      icon.textElement = this.textElement;
      icon.fill = this.fill;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusIconReaction
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

public class StatusIconReaction : StatusIcon
{
  public Sprite snowSprite;
  public Image _image;
  public Sprite baseSprite;
  public int snowPre;

  public Image image
  {
    get
    {
      if ((UnityEngine.Object) this._image == (UnityEngine.Object) null)
      {
        this._image = this.GetComponent<Image>();
        this.baseSprite = this._image.sprite;
      }
      return this._image;
    }
  }

  public void UpdateDisplay()
  {
    int num = (bool) (UnityEngine.Object) this.target ? this.target.SnowAmount() : 0;
    this.image.sprite = num <= 0 || !(bool) (UnityEngine.Object) this.snowSprite ? this.baseSprite : this.snowSprite;
    this.snowPre = num;
  }

  public override void CheckRemove()
  {
    if (this.target.statusEffects.Any<StatusEffectData>((Func<StatusEffectData, bool>) (a => a.isReaction)))
      return;
    this.SetValue(new Stat());
    this.target.display.reactionIcon = (StatusIcon) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StatusIconSnow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class StatusIconSnow : StatusIcon
{
  public void CustomSetText()
  {
    TMP_Text textElement = this.textElement;
    Stat stat = this.GetValue();
    int num = stat.current + this.target.counter.current;
    if (!((Object) textElement != (Object) null))
      return;
    textElement.text = num.ToString();
    if (!this.alterTextColours)
      return;
    textElement.color = num > stat.max ? this.textColourAboveMax : this.textColour;
  }

  public void CustomDestroy()
  {
    Transform parent = this.transform.parent;
    if (!((Object) parent != (Object) null))
      return;
    foreach (Component component1 in parent)
    {
      StatusIcon component2 = component1.GetComponent<StatusIcon>();
      if (component2.type == "counter")
      {
        component2.Ping();
        break;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SteamManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Steamworks;
using Steamworks.Ugc;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

public class SteamManager : MonoBehaviour
{
  [CompilerGenerated]
  public static bool \u003Cinit\u003Ek__BackingField;
  public const int appId = 1811990;

  public static bool init
  {
    get => SteamManager.\u003Cinit\u003Ek__BackingField;
    set => SteamManager.\u003Cinit\u003Ek__BackingField = value;
  }

  public async void Awake()
  {
    try
    {
      SteamClient.Init(1811990U);
      if (SteamClient.RestartAppIfNecessary(1811990U))
        GameManager.Quit();
      else
        SteamManager.init = true;
    }
    catch (Exception ex)
    {
      Debug.LogError((object) string.Format("Steam failed to initialize! ({0})", (object) ex));
      Debug.Log((object) string.Format("Steam failed to initialize! ({0})", (object) ex));
      GameManager.Quit();
    }
    List<string> steamFiles = new List<string>();
    int i = 1;
    while (true)
    {
      Query query = Query.All;
      query = query.WhereUserSubscribed();
      ResultPage? pageAsync = await query.GetPageAsync(i);
      if (pageAsync.HasValue && pageAsync?.Entries.Any<Steamworks.Ugc.Item>())
      {
        foreach (Steamworks.Ugc.Item entry in pageAsync?.Entries)
        {
          Steamworks.Ugc.Item pageEntry = entry;
          string directory = pageEntry.Directory;
          if (directory == null || pageEntry.IsDownloadPending || pageEntry.NeedsUpdate)
          {
            int num = await pageEntry.DownloadAsync() ? 1 : 0;
            directory = pageEntry.Directory;
          }
          steamFiles.Add(directory);
          pageEntry = new Steamworks.Ugc.Item();
        }
        ++i;
      }
      else
        break;
    }
    foreach (string path in steamFiles)
      Bootstrap.LoadModAtPath(path);
    steamFiles = (List<string>) null;
  }

  public void OnEnable()
  {
    if (!SteamManager.init)
      return;
    Debug.Log((object) string.Format("Steam Initialized {0} ({1})", (object) SteamClient.Name, (object) SteamClient.SteamId));
  }

  public void OnDisable() => SteamClient.Shutdown();
}
﻿// Decompiled with JetBrains decompiler
// Type: StopWatch
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public static class StopWatch
{
  public static float? startTime;
  public static float? stopTime;

  public static int Milliseconds => StopWatch.GetMilliseconds();

  public static float Seconds => (float) StopWatch.Milliseconds / 1000f;

  public static float StopTime => StopWatch.stopTime ?? Time.realtimeSinceStartup;

  public static void Start()
  {
    StopWatch.startTime = new float?(Time.realtimeSinceStartup);
    StopWatch.stopTime = new float?();
  }

  public static int Stop()
  {
    StopWatch.stopTime = new float?(Time.realtimeSinceStartup);
    return StopWatch.Milliseconds;
  }

  public static int GetMilliseconds() => StopWatch.startTime.HasValue ? Mathf.RoundToInt((float) (((double) StopWatch.StopTime - (double) StopWatch.startTime.Value) * 1000.0)) : 0;
}
﻿// Decompiled with JetBrains decompiler
// Type: StormBellDifficulty
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Components;

public class StormBellDifficulty : MonoBehaviour
{
  [SerializeField]
  public bool setOnAwake = true;
  [SerializeField]
  public LocalizeStringEvent locEvent;
  [SerializeField]
  public TMP_Text text;
  [SerializeField]
  public StormBellDifficulty.Level[] levels;
  public int _points;

  public int points
  {
    get => this._points;
    set
    {
      this._points = value;
      this.locEvent.RefreshString();
    }
  }

  public void UpdateText(string text)
  {
    foreach (StormBellDifficulty.Level level in this.levels)
    {
      if (this.points >= level.threshold)
      {
        this.text.text = text.Format((object) level.name.GetLocalizedString());
        this.text.color = level.colour;
        break;
      }
    }
  }

  public void Awake()
  {
    if (!this.setOnAwake)
      return;
    int num = 0;
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers");
    foreach (HardModeModifierData hardModeModifier in MonoBehaviourSingleton<References>.instance.hardModeModifiers)
    {
      if (stringList.Contains(hardModeModifier.name))
        num += hardModeModifier.stormPoints;
    }
    this.points = num;
  }

  [Serializable]
  public struct Level
  {
    public int threshold;
    public LocalizedString name;
    public Color colour;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StormBellManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMOD.Studio;
using FMODUnity;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;

public class StormBellManager : MonoBehaviour
{
  public const int TrueFinalBossPointThreshold = 10;
  public const int PointLimit = 10;
  public const int MaxPointStart = 5;
  public const int MaxPointIncrease = 1;
  [SerializeField]
  public GameObject openButton;
  [SerializeField]
  public Transform[] bellGroups;
  [SerializeField]
  public ModifierIcon bellPrefab;
  [SerializeField]
  public ModifierIconMultiple[] stormBellDisplays;
  [SerializeField]
  public GameObject stormBellUnlockDisplay;
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public GameObject overcranker;
  [SerializeField]
  public GameObject pointLimitDisplay;
  [SerializeField]
  public GameObject overcrankDisplay;
  [SerializeField]
  public GameObject overcrankUnlockDisplay;
  [SerializeField]
  public ColourFader backgroundFader;
  [SerializeField]
  public LocalizedString stormStrengthAddString;
  [SerializeField]
  public GameObject additionalButtons;
  [Header("Smoke")]
  [SerializeField]
  public ParticleSystem normalSmoke;
  [SerializeField]
  public ParticleSystem overcrankSmoke;
  [Header("Storm Strength Increase Popup")]
  [SerializeField]
  public GameObject stormLimitAdd;
  [SerializeField]
  public LocalizedString stormLimitAddString;
  [SerializeField]
  public LocalizedString goldFramesRemainingString;
  [SerializeField]
  public TMP_Text stormLimitAddText;
  [Header("SFX")]
  [SerializeField]
  public EventReference stormBellActivateSfx;
  [SerializeField]
  public EventReference stormBellActivate10Sfx;
  [SerializeField]
  public EventReference stormBellRandomizeSfx;
  [SerializeField]
  public EventReference stormBellClearSfx;
  public List<string> activeNames;
  public List<string> golden;
  public List<string> newGolden;
  public List<HardModeModifierData> active;
  public readonly Dictionary<ModifierIcon, HardModeModifierData> modifierIcons = new Dictionary<ModifierIcon, HardModeModifierData>();
  public bool unlocked;
  public int points;
  public int maxPoints;
  public bool overcrank;
  public string stormStrengthAddText;
  public EventInstance bellActivateSfxInstance;
  public EventInstance bellActivate10SfxInstance;
  public EventInstance bellRandomizeSfxInstance;

  public void Awake()
  {
    this.overcrank = SaveSystem.LoadProgressData<bool>("stormPointOvercrank", false);
    this.maxPoints = Mathf.Min(SaveSystem.LoadProgressData<int>("maxStormPoints", 5), 10);
    this.unlocked = SaveSystem.LoadProgressData<bool>("stormBellsUnlocked", false);
    if (!this.unlocked && SaveSystem.LoadProgressData<int>("hardModeModifiersUnlocked", 0) > 0)
    {
      this.unlocked = true;
      SaveSystem.SaveProgressData<bool>("stormBellsUnlocked", true);
    }
    if (!this.unlocked)
    {
      this.openButton.SetActive(false);
    }
    else
    {
      this.golden = SaveSystem.LoadProgressData<List<string>>("goldHardModeModifiers") ?? new List<string>();
      this.newGolden = SaveSystem.LoadProgressData<List<string>>("goldHardModeModifiersNew");
      if (!SaveSystem.LoadProgressData<bool>("stormBellsUnlockedScreenShown", false))
      {
        this.stormBellUnlockDisplay.SetActive(true);
        SaveSystem.SaveProgressData<bool>("stormBellsUnlockedScreenShown", true);
      }
      List<string> newGolden = this.newGolden;
      if (newGolden != null && newGolden.Count > 0)
      {
        int num = ((IEnumerable<HardModeModifierData>) MonoBehaviourSingleton<References>.instance.hardModeModifiers).Count<HardModeModifierData>((Func<HardModeModifierData, bool>) (a => this.golden.Contains(a.name)));
        if (num > 0)
        {
          this.stormLimitAdd.SetActive(true);
          this.stormLimitAddText.text = this.goldFramesRemainingString.GetLocalizedString((object) num);
        }
      }
      int num1 = SaveSystem.LoadProgressData<int>("maxStormPointIncrease", 0);
      if (num1 > 0)
      {
        this.stormLimitAdd.SetActive(true);
        this.stormLimitAddText.text = this.stormLimitAddString.GetLocalizedString((object) num1);
        SaveSystem.SaveProgressData<int>("maxStormPointIncrease", 0);
      }
      this.activeNames = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers") ?? new List<string>();
      bool flag = false;
      for (int index = this.activeNames.Count - 1; index >= 0; --index)
      {
        string bellName = this.activeNames[index];
        if (((IEnumerable<HardModeModifierData>) MonoBehaviourSingleton<References>.instance.hardModeModifiers).All<HardModeModifierData>((Func<HardModeModifierData, bool>) (a => a.name != bellName)))
        {
          this.activeNames.RemoveAt(index);
          flag = true;
        }
      }
      if (this.active == null)
        this.active = new List<HardModeModifierData>();
      foreach (HardModeModifierData hardModeModifier in MonoBehaviourSingleton<References>.instance.hardModeModifiers)
      {
        if (this.activeNames.Contains(hardModeModifier.name))
          this.active.Add(hardModeModifier);
      }
      if (!this.overcrank)
      {
        int num2 = 0;
        for (int index = this.active.Count - 1; index >= 0; --index)
        {
          HardModeModifierData modeModifierData = this.active[index];
          if (num2 + modeModifierData.stormPoints > this.maxPoints)
          {
            this.active.RemoveAt(index);
            this.activeNames.Remove(modeModifierData.name);
            flag = true;
          }
          else
            num2 += modeModifierData.stormPoints;
        }
      }
      if (flag)
        SaveSystem.SaveProgressData<List<string>>("activeHardModeModifiers", this.activeNames);
      this.stormStrengthAddText = this.stormStrengthAddString.GetLocalizedString();
      ModifierIcon modifierIcon1 = (ModifierIcon) null;
      for (int index = 0; index < MonoBehaviourSingleton<References>.instance.hardModeModifiers.Length; ++index)
      {
        ModifierIcon bell = this.CreateBell(MonoBehaviourSingleton<References>.instance.hardModeModifiers[index], index);
        if ((UnityEngine.Object) modifierIcon1 != (UnityEngine.Object) null && index != 5 && index != 10)
        {
          StormBellManager.ConnectBellInputLeft(bell, modifierIcon1);
          StormBellManager.ConnectBellInputRight(modifierIcon1, bell);
        }
        modifierIcon1 = bell;
      }
      this.UpdateBells();
      if (this.overcrank)
      {
        foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon2 in this.modifierIcons)
          modifierIcon2.Key.GetComponent<ModifierToggle>().canToggle = false;
      }
      if (this.overcrank)
        this.overcrankSmoke.Play();
      else if (this.points >= 10)
        this.normalSmoke.Play();
      this.additionalButtons.SetActive(!this.overcrank);
      this.pointLimitDisplay.SetActive(!this.overcrank);
      this.overcrankDisplay.SetActive(this.overcrank);
      this.overcranker.SetActive(!((IEnumerable<HardModeModifierData>) MonoBehaviourSingleton<References>.instance.hardModeModifiers).Select<HardModeModifierData, string>((Func<HardModeModifierData, string>) (a => a.name)).Except<string>((IEnumerable<string>) this.golden).Any<string>());
      if (this.overcranker.activeSelf && !SaveSystem.LoadProgressData<bool>("overcrankUnlockedScreenShown", false))
      {
        this.overcrankUnlockDisplay.SetActive(true);
        SaveSystem.SaveProgressData<bool>("overcrankUnlockedScreenShown", true);
      }
      this.SetGlobalStormBellCountParam();
    }
  }

  public void OnEnable() => this.UpdatePointsDisplays();

  public void CheckStartGoldFrameRoutine()
  {
    foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in this.modifierIcons)
    {
      if (this.golden.Contains(modifierIcon.Value.name) && (this.newGolden == null || !this.newGolden.Contains(modifierIcon.Value.name)))
        modifierIcon.Key.GetComponent<UnityEngine.Animator>()?.SetBool("Gold", true);
    }
    List<string> newGolden = this.newGolden;
    if (newGolden == null || newGolden.Count <= 0)
      return;
    string[] array = this.newGolden.ToArray();
    this.newGolden = (List<string>) null;
    SaveSystem.DeleteProgressData("goldHardModeModifiersNew");
    this.StartCoroutine(this.GoldFrameRoutine(array));
  }

  public void UpdateBells()
  {
    foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in this.modifierIcons)
    {
      ModifierToggle component = modifierIcon.Key.GetComponent<ModifierToggle>();
      if (component != null && !component.IsActive)
      {
        component.canToggle = this.maxPoints - this.points - modifierIcon.Value.stormPoints >= 0;
        component.UpdateArt();
      }
    }
  }

  public ModifierIcon CreateBell(HardModeModifierData modifier, int index)
  {
    ModifierIcon key = UnityEngine.Object.Instantiate<ModifierIcon>(this.bellPrefab, this.bellGroups[index % this.bellGroups.Length]);
    key.Set(modifier.modifierData, Vector2.left);
    key.AddText(this.stormStrengthAddText.Format((object) modifier.stormPoints));
    ModifierToggle component = key.GetComponent<ModifierToggle>();
    if (this.activeNames.Contains(modifier.name))
    {
      this.points += modifier.stormPoints;
      ModifierSystem.AddModifier(Campaign.Data, modifier.modifierData);
    }
    else if ((bool) (UnityEngine.Object) component)
      component.Toggle();
    if ((bool) (UnityEngine.Object) component)
      component.onToggle.AddListener((UnityAction) (() => this.Toggle(modifier)));
    this.modifierIcons.Add(key, modifier);
    return key;
  }

  public static void ConnectBellInputLeft(ModifierIcon from, ModifierIcon to)
  {
    UINavigationItem component1 = from.GetComponent<UINavigationItem>();
    if (component1 == null)
      return;
    UINavigationItem component2 = to.GetComponent<UINavigationItem>();
    if (component2 == null)
      return;
    component1.overrideInputs = true;
    component1.inputLeft = component2;
  }

  public static void ConnectBellInputRight(ModifierIcon from, ModifierIcon to)
  {
    UINavigationItem component1 = from.GetComponent<UINavigationItem>();
    if (component1 == null)
      return;
    UINavigationItem component2 = to.GetComponent<UINavigationItem>();
    if (component2 == null)
      return;
    component1.overrideInputs = true;
    component1.inputRight = component2;
  }

  public void Toggle(HardModeModifierData modifier)
  {
    int points = this.points;
    this.ToggleEffect(modifier);
    this.UpdatePointsDisplays();
    this.UpdateBells();
    SaveSystem.SaveProgressData<List<string>>("activeHardModeModifiers", this.activeNames);
    this.animator.SetBool("Angry", this.points >= 10);
    this.animator.SetTrigger("Blip");
    this.SetGlobalStormBellCountParam();
    if (this.activeNames.Contains(modifier.name))
    {
      this.bellActivateSfxInstance = SfxSystem.OneShot(this.stormBellActivateSfx);
      SfxSystem.SetParam(this.bellActivateSfxInstance, "count", (float) this.activeNames.Count);
    }
    if (points < 10 && this.points >= 10)
    {
      this.backgroundFader.FadeToColour("Purple");
      this.bellActivate10SfxInstance = SfxSystem.OneShot(this.stormBellActivate10Sfx);
      this.normalSmoke.Play();
    }
    else
    {
      if (points < 10 || this.points >= 10)
        return;
      this.backgroundFader.FadeToColour("Normal");
      this.normalSmoke.Stop();
    }
  }

  public void SetGlobalStormBellCountParam() => SfxSystem.SetGlobalParam("stormbell_count", this.points >= 10 ? (float) Mathf.Max(10, this.active.Count) : (float) this.active.Count);

  public void ToggleEffect(HardModeModifierData modifier)
  {
    if (this.activeNames.Contains(modifier.name))
    {
      this.activeNames.Remove(modifier.name);
      this.active.Remove(modifier);
      this.points -= modifier.stormPoints;
      ModifierSystem.RemoveModifier(Campaign.Data, modifier.modifierData);
    }
    else
    {
      this.activeNames.Add(modifier.name);
      this.active.Add(modifier);
      this.points += modifier.stormPoints;
      ModifierSystem.AddModifier(Campaign.Data, modifier.modifierData);
    }
  }

  public void ForceEnableAllBells()
  {
    foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in this.modifierIcons)
    {
      if (!this.activeNames.Contains(modifierIcon.Value.name))
      {
        this.ToggleEffect(modifierIcon.Value);
        modifierIcon.Key.Ding();
        modifierIcon.Key.GetComponent<ModifierToggle>().SetActive(true);
      }
    }
    this.UpdatePointsDisplays();
    this.UpdateBells();
    foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in this.modifierIcons)
      modifierIcon.Key.GetComponent<ModifierToggle>().canToggle = false;
    SaveSystem.SaveProgressData<List<string>>("activeHardModeModifiers", this.activeNames);
    this.animator.SetBool("Angry", this.points >= 10);
    this.animator.SetTrigger("Blip");
  }

  public void DisableForcedBells()
  {
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiersBeforeOvercrank") ?? new List<string>();
    foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in this.modifierIcons)
    {
      if (!stringList.Contains(modifierIcon.Value.name))
      {
        this.ToggleEffect(modifierIcon.Value);
        modifierIcon.Key.GetComponent<ModifierToggle>().SetActive(false);
      }
    }
    this.UpdatePointsDisplays();
    this.UpdateBells();
    foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in this.modifierIcons)
      modifierIcon.Key.GetComponent<ModifierToggle>().canToggle = this.activeNames.Contains(modifierIcon.Value.name) || this.points + modifierIcon.Value.stormPoints <= this.maxPoints;
    SaveSystem.SaveProgressData<List<string>>("activeHardModeModifiers", this.activeNames);
    this.animator.SetBool("Angry", this.points >= 10);
    this.animator.SetTrigger("Blip");
  }

  public void UpdatePointsDisplays()
  {
    foreach (ModifierIconMultiple stormBellDisplay in this.stormBellDisplays)
    {
      stormBellDisplay.Clear();
      if (this.active != null)
      {
        foreach (HardModeModifierData modeModifierData in this.active)
        {
          if ((bool) (UnityEngine.Object) modeModifierData)
            stormBellDisplay.Add(modeModifierData.modifierData);
        }
      }
    }
  }

  public static List<string> GetActiveStormBells() => SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers");

  public static int GetCurrentStormPoints(List<string> active)
  {
    int currentStormPoints = 0;
    if (active != null)
    {
      foreach (HardModeModifierData hardModeModifier in MonoBehaviourSingleton<References>.instance.hardModeModifiers)
      {
        if (active.Contains(hardModeModifier.name))
          currentStormPoints += hardModeModifier.stormPoints;
      }
    }
    return currentStormPoints;
  }

  public void UpdateAnimator()
  {
    this.animator.SetBool("Angry", this.points >= 10);
    this.animator.SetBool("Overcrank", this.overcrank);
    this.backgroundFader.FadeToColour(this.overcrank ? "Red" : (this.points >= 10 ? "Purple" : "Normal"));
    if (this.overcrank)
    {
      this.overcrankSmoke.Play();
      this.normalSmoke.Stop();
    }
    else
    {
      this.overcrankSmoke.Stop();
      if (this.points >= 10)
        this.normalSmoke.Play();
      else
        this.normalSmoke.Stop();
    }
  }

  public void ToggleOvercrank()
  {
    this.overcrank = !this.overcrank;
    this.animator.SetBool("Overcrank", this.overcrank);
    SaveSystem.SaveProgressData<bool>("stormPointOvercrank", this.overcrank);
    if (this.overcrank)
    {
      SaveSystem.SaveProgressData<List<string>>("activeHardModeModifiersBeforeOvercrank", this.activeNames);
      this.ForceEnableAllBells();
      this.backgroundFader.FadeToColour("Red");
      SfxSystem.OneShot("event:/sfx/town/stormbell_overcrank");
      this.overcrankSmoke.Play();
      this.normalSmoke.Stop();
    }
    else
    {
      this.DisableForcedBells();
      this.backgroundFader.FadeToColour(this.points >= 10 ? "Purple" : "Normal");
      SfxSystem.OneShot("event:/sfx/town/stormbell_overcrank_deactivate");
      this.overcrankSmoke.Stop();
      if (this.points >= 10)
        this.normalSmoke.Play();
      else
        this.normalSmoke.Stop();
    }
    this.pointLimitDisplay.SetActive(!this.overcrank);
    this.overcrankDisplay.SetActive(this.overcrank);
    this.additionalButtons.SetActive(!this.overcrank);
    this.SetGlobalStormBellCountParam();
  }

  public static bool TrueFinalBossPointThresholdReached() => StormBellManager.GetCurrentStormPoints(StormBellManager.GetActiveStormBells()) >= 10;

  public IEnumerator GoldFrameRoutine(string[] modifierNames)
  {
    string[] strArray = modifierNames;
    for (int index = 0; index < strArray.Length; ++index)
    {
      string modifierName = strArray[index];
      KeyValuePair<ModifierIcon, HardModeModifierData> keyValuePair = this.modifierIcons.FirstOrDefault<KeyValuePair<ModifierIcon, HardModeModifierData>>((Func<KeyValuePair<ModifierIcon, HardModeModifierData>, bool>) (p => p.Value.name == modifierName));
      if ((bool) (UnityEngine.Object) keyValuePair.Key)
      {
        UnityEngine.Animator component = keyValuePair.Key.GetComponent<UnityEngine.Animator>();
        if (component != null)
        {
          component.SetBool("Gold", true);
          component.SetBool("BecomeGold", true);
          yield return (object) new WaitForSeconds(0.15f);
        }
      }
    }
    strArray = (string[]) null;
  }

  public void Randomize()
  {
    this.Clear();
    int num = 0;
    List<HardModeModifierData> modeModifierDataList = new List<HardModeModifierData>();
label_5:
    while (num != this.maxPoints)
    {
      modeModifierDataList.Clear();
      num = 0;
      List<HardModeModifierData> list = MonoBehaviourSingleton<References>.instance.hardModeModifiers.ToList<HardModeModifierData>();
      while (true)
      {
        HardModeModifierData random;
        do
        {
          if (num < this.maxPoints && list.Count > 0)
            random = list.TakeRandom<HardModeModifierData>();
          else
            goto label_5;
        }
        while (num + random.stormPoints > this.maxPoints);
        modeModifierDataList.Add(random);
        num += random.stormPoints;
      }
    }
    foreach (HardModeModifierData modeModifierData in modeModifierDataList)
    {
      HardModeModifierData modifier = modeModifierData;
      this.ToggleEffect(modifier);
      ModifierIcon key = this.modifierIcons.FirstOrDefault<KeyValuePair<ModifierIcon, HardModeModifierData>>((Func<KeyValuePair<ModifierIcon, HardModeModifierData>, bool>) (p => (UnityEngine.Object) p.Value == (UnityEngine.Object) modifier)).Key;
      if ((bool) (UnityEngine.Object) key)
      {
        key.Ding();
        key.GetComponent<ModifierToggle>().SetActive(true);
      }
    }
    SaveSystem.SaveProgressData<List<string>>("activeHardModeModifiers", this.activeNames);
    this.UpdatePointsDisplays();
    this.UpdateBells();
    this.UpdateAnimator();
    this.SetGlobalStormBellCountParam();
    SfxSystem.Stop(this.bellRandomizeSfxInstance);
    this.bellRandomizeSfxInstance = SfxSystem.OneShot(this.stormBellRandomizeSfx);
  }

  public void Clear()
  {
    foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in this.modifierIcons)
    {
      if (this.activeNames.Contains(modifierIcon.Value.name))
        modifierIcon.Key.GetComponent<ModifierToggle>().Toggle();
    }
  }

  public void ClearAndPlaySfx()
  {
    if (this.active.Count <= 0)
      return;
    SfxSystem.OneShot(this.stormBellClearSfx);
    SfxSystem.Stop(this.bellRandomizeSfxInstance);
    SfxSystem.Stop(this.bellActivateSfxInstance);
    SfxSystem.Stop(this.bellActivate10SfxInstance);
    this.Clear();
  }

  [CompilerGenerated]
  public bool \u003CAwake\u003Eb__40_1(HardModeModifierData a) => this.golden.Contains(a.name);
}
﻿// Decompiled with JetBrains decompiler
// Type: StormBellPointLimit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class StormBellPointLimit : MonoBehaviour
{
  [SerializeField]
  public bool setOnAwake = true;
  [SerializeField]
  public TMP_Text text;
  public int _pointLimit;

  public int pointLimit
  {
    get => this._pointLimit;
    set
    {
      this._pointLimit = value;
      this.text.text = value.ToString();
    }
  }

  public void Awake()
  {
    if (!this.setOnAwake)
      return;
    this.pointLimit = Mathf.Min(SaveSystem.LoadProgressData<int>("maxStormPoints", 5), 10);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StormBellPoints
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Localization.Components;

public class StormBellPoints : MonoBehaviour
{
  [SerializeField]
  public bool setOnAwake = true;
  [SerializeField]
  public LocalizeStringEvent locEvent;
  [SerializeField]
  public TMP_Text text;
  public int _points;

  public int points
  {
    get => this._points;
    set
    {
      this._points = value;
      this.locEvent.RefreshString();
    }
  }

  public void UpdateText(string text) => this.text.text = text.Format((object) this.points);

  public void Awake()
  {
    if (!this.setOnAwake)
      return;
    int num = 0;
    List<string> stringList = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers");
    foreach (HardModeModifierData hardModeModifier in MonoBehaviourSingleton<References>.instance.hardModeModifiers)
    {
      if (stringList.Contains(hardModeModifier.name))
        num += hardModeModifier.stormPoints;
    }
    this.points = num;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StormBellUnlockSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine.Events;

public class StormBellUnlockSystem : GameSystem
{
  public void OnEnable() => global::Events.OnCampaignEnd += new UnityAction<Campaign.Result, CampaignStats, PlayerData>(this.CampaignEnd);

  public void OnDisable() => global::Events.OnCampaignEnd -= new UnityAction<Campaign.Result, CampaignStats, PlayerData>(this.CampaignEnd);

  public void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
  {
    if (result != Campaign.Result.Win || !Campaign.Data.GameMode.mainGameMode)
      return;
    if (!SaveSystem.LoadProgressData<bool>("stormBellsUnlocked", false))
      SaveSystem.SaveProgressData<bool>("stormBellsUnlocked", true);
    List<string> active = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers") ?? new List<string>();
    int currentStormPoints = StormBellManager.GetCurrentStormPoints(active);
    int num1 = SaveSystem.LoadProgressData<int>("maxStormPoints", 5);
    int num2 = num1;
    if (currentStormPoints == num2 && num1 + 1 <= 10)
    {
      SaveSystem.SaveProgressData<int>("maxStormPoints", num1 + 1);
      SaveSystem.SaveProgressData<int>("maxStormPointIncrease", 1);
    }
    if (!SaveSystem.LoadCampaignData<bool>(Campaign.Data.GameMode, "trueWin", false))
      return;
    List<string> stringList1 = SaveSystem.LoadProgressData<List<string>>("goldHardModeModifiers") ?? new List<string>();
    List<string> stringList2 = SaveSystem.LoadProgressData<List<string>>("goldHardModeModifiersNew") ?? new List<string>();
    bool flag = false;
    foreach (string str in active)
    {
      if (!stringList1.Contains(str))
      {
        stringList1.Add(str);
        stringList2.Add(str);
        flag = true;
      }
    }
    if (!flag)
      return;
    SaveSystem.SaveProgressData<List<string>>("goldHardModeModifiers", stringList1);
    SaveSystem.SaveProgressData<List<string>>("goldHardModeModifiersNew", stringList2);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StormGlobe
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class StormGlobe : ScriptableCardImage
{
  [SerializeField]
  public Image image;
  [SerializeField]
  public Sprite[] sprites;
  [SerializeField]
  public AnimationCurve spriteIndexCurve;
  public int effectBonus;

  public override void UpdateEvent()
  {
    if (this.entity.effectBonus == this.effectBonus)
      return;
    this.effectBonus = this.entity.effectBonus;
    this.image.sprite = this.sprites[Mathf.Clamp(Mathf.RoundToInt(this.spriteIndexCurve.Evaluate((float) this.effectBonus)), 0, this.sprites.Length - 1)];
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: StringReference
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine.Localization;

public class StringReference : MonoBehaviourSingleton<StringReference>
{
  public LocalizedString injured;
  public LocalizedString tutorialCharm1;
  public LocalizedString tutorialCharm2;
  public LocalizedString tutorialCrown;
  public LocalizedString tutorialInjury;
  public LocalizedString tutorialInjuryMultiple;
  public LocalizedString tutorialCompanion1;
  public LocalizedString tutorialCompanion1Gamepad;
  public LocalizedString tutorialCompanion1Touch;
  public LocalizedString tutorialCompanion2;
  public LocalizedString tutorialItem;
  public LocalizedString tutorialBattle1_1;
  public LocalizedString tutorialBattle1_2;
  public LocalizedString tutorialBattle1_3;
  public LocalizedString tutorialBattle1_4;
  public LocalizedString tutorialBattle1_41;
  public LocalizedString tutorialBattle1_5;
  public LocalizedString tutorialBattle1_6;
  public LocalizedString tutorialBattle1_7;
  public LocalizedString tutorialBattle1_8;
  public LocalizedString tutorialBattle2_1;
  public LocalizedString tutorialBattle2_1Gamepad;
  public LocalizedString tutorialBattle2_2;
  public LocalizedString tutorialBattle2_3;
  public LocalizedString tutorialBattle2_4;
  public LocalizedString tutorialBattle2_41a;
  public LocalizedString tutorialBattle2_41b;
  public LocalizedString tutorialBattle2_5;
  public LocalizedString tutorialBattle2_6;
  public LocalizedString tutorialBattle3_1;
}
﻿// Decompiled with JetBrains decompiler
// Type: SummonCreateCardAnimation
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SummonCreateCardAnimation : CreateCardAnimation
{
  [SerializeField]
  public ParticleSystem inParticleSystem;
  [SerializeField]
  public ParticleSystem outParticleSystem;
  [SerializeField]
  public float chargeDelay = 0.54f;

  public override IEnumerator Run(Entity entity, params CardData.StatusEffectStacks[] withEffects)
  {
    SummonCreateCardAnimation createCardAnimation = this;
    Routine.Clump clump = new Routine.Clump();
    SfxSystem.OneShot("event:/sfx/card/summon");
    clump.Add(createCardAnimation.In());
    clump.Add(CreateCardAnimation.GainEffects(entity, (IEnumerable<CardData.StatusEffectStacks>) withEffects));
    yield return (object) clump.WaitForEnd();
    createCardAnimation.Out();
    yield return (object) new WaitForSeconds(createCardAnimation.chargeDelay);
    if (entity.display is Card display)
      LeanTween.alphaCanvas(display.canvasGroup, 1f, 0.1f);
    double num = (double) entity.curveAnimator.Ping();
    entity.wobbler.WobbleRandom();
    clump.Add(createCardAnimation.DestroyOnEnd(createCardAnimation.outParticleSystem));
  }

  public IEnumerator In()
  {
    this.inParticleSystem.Play();
    yield return (object) new WaitForSeconds(this.inParticleSystem.main.duration);
  }

  public void Out()
  {
    this.inParticleSystem.gameObject.Destroy();
    this.outParticleSystem.Play();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Swayer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using NaughtyAttributes;
using UnityEngine;

public class Swayer : MonoBehaviour
{
  [SerializeField]
  public bool randomStart;
  [Header("Position")]
  [OnValueChanged("SwayPositionToggled")]
  public bool swayPosition;
  [ShowIf("swayPosition")]
  public Vector3 positionInfluence = Vector3.one;
  [ShowIf("swayPosition")]
  public Vector3 positionSway = Vector3.one;
  [Header("Rotation")]
  [OnValueChanged("SwayRotationToggled")]
  public bool swayRotation;
  [ShowIf("swayRotation")]
  public Vector3 rotationInfluence = Vector3.one;
  [ShowIf("swayRotation")]
  public Vector3 rotationSway = Vector3.one;
  public Vector3 startPosition;
  public Vector3 startRotation;
  public float t;
  public Transform transform;

  public void Awake()
  {
    this.transform = this.GetComponent<Transform>();
    this.startPosition = this.transform.localPosition;
    this.startRotation = this.transform.localEulerAngles;
    if (!this.randomStart)
      return;
    this.t = PettyRandom.Range(0.0f, 10f);
  }

  public void Update()
  {
    float num = Time.timeSinceLevelLoad + this.t;
    if (this.swayPosition)
      this.transform.localPosition = this.startPosition + Vector3.Scale(new Vector3(Mathf.Sin(num * this.positionSway.x), Mathf.Sin(num * this.positionSway.y), Mathf.Sin(num * this.positionSway.z)), this.positionInfluence);
    if (!this.swayRotation)
      return;
    this.transform.localEulerAngles = this.startRotation + Vector3.Scale(new Vector3(Mathf.Sin(num * this.rotationSway.x), Mathf.Sin(num * this.rotationSway.y), Mathf.Sin(num * this.rotationSway.z)), this.rotationInfluence);
  }

  public void SwayPositionToggled()
  {
    if (this.swayPosition)
      return;
    this.transform.localPosition = this.startPosition;
  }

  public void SwayRotationToggled()
  {
    if (this.swayRotation)
      return;
    this.transform.localEulerAngles = this.startRotation;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: SwayerColour
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using NaughtyAttributes;
using UnityEngine;
using UnityEngine.UI;

public class SwayerColour : MonoBehaviour
{
  [SerializeField]
  public bool randomStart;
  [HideIf("sprite")]
  public Graphic graphic;
  [HideIf("ui")]
  public SpriteRenderer renderer;
  public Gradient gradient;
  public float speed = 1f;
  public AnimationCurve curve;
  public float t;

  public bool ui => (Object) this.graphic != (Object) null;

  public bool sprite => (Object) this.renderer != (Object) null;

  public void Awake()
  {
    if (!this.randomStart)
      return;
    this.t = PettyRandom.Range(0.0f, 10f);
  }

  public void Update()
  {
    this.t = (float) (((double) this.t + (double) Time.deltaTime * (double) this.speed) % 1.0);
    Color color = this.gradient.Evaluate(this.curve.Evaluate(this.t));
    if (this.ui)
      this.graphic.color = color;
    if (!this.sprite)
      return;
    this.renderer.color = color;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Talker
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using FMODUnity;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Localization;

public class Talker : MonoBehaviour
{
  [SerializeField]
  public LocalizedString nameKey;
  [SerializeField]
  public Transform talkFrom;
  [SerializeField]
  public AvatarPoser poser;
  [SerializeField]
  public Talker.Speech[] speech;
  public readonly Dictionary<string, Talker.Speech> speechLookup = new Dictionary<string, Talker.Speech>();
  public readonly List<Talker.Store> stored = new List<Talker.Store>();

  public string GetName() => !this.nameKey.IsEmpty ? this.nameKey.GetLocalizedString() : "";

  public void Awake()
  {
    foreach (Talker.Speech speech in this.speech)
      this.speechLookup[speech.type] = speech;
  }

  public void OnEnable()
  {
    foreach (Talker.Store store in this.stored)
      this.Say(store.speechType, store.delay, store.inserts);
    this.stored.Clear();
  }

  public void OnDisable() => this.StopAllCoroutines();

  public void Say(string speechType, float delay = 0.0f, params object[] inserts)
  {
    if (!this.enabled || !this.gameObject.activeInHierarchy)
    {
      this.stored.Add(new Talker.Store(speechType, delay, inserts));
    }
    else
    {
      Talker.Speech speech;
      if (!this.Get(speechType, out speech))
        return;
      string str = speech.Pull();
      EventReference? sfxEvent = new EventReference?(speech.sfxEvent);
      if (inserts.Length != 0)
        str = string.Format(str, inserts);
      if (str.Contains('|'))
      {
        string[] strArray = str.Split('|', StringSplitOptions.None);
        float num = 0.0f;
        foreach (string text in strArray)
        {
          this.StartCoroutine(this.SayAfterDelay(text, sfxEvent, delay + num));
          if (speech.poseOptions.Length != 0 && (bool) (UnityEngine.Object) this.poser)
            this.StartCoroutine(this.PoseAfterDelay(speech.poseOptions.RandomItem<string>(), delay + num));
          num += Mathf.Max(1.25f, SpeechBubbleSystem.GetDuration(text) * 0.5f);
          sfxEvent = new EventReference?();
        }
      }
      else
      {
        this.StartCoroutine(this.SayAfterDelay(str, sfxEvent, delay));
        if (speech.poseOptions.Length == 0 || !(bool) (UnityEngine.Object) this.poser)
          return;
        this.StartCoroutine(this.PoseAfterDelay(speech.poseOptions.RandomItem<string>(), delay));
      }
    }
  }

  public bool Get(string type, out Talker.Speech speech)
  {
    bool flag = this.speechLookup.TryGetValue(type, out speech);
    if (!flag)
    {
      Talker.Speech[] array = ((IEnumerable<Talker.Speech>) this.speech).Where<Talker.Speech>((Func<Talker.Speech, bool>) (a => a.type == type)).ToArray<Talker.Speech>();
      if (array.Length != 0)
      {
        flag = true;
        speech = array[0];
      }
    }
    return flag;
  }

  public IEnumerator SayAfterDelay(string text, EventReference? sfxEvent, float delay = 0.0f)
  {
    if ((double) delay > 0.0)
      yield return (object) new WaitForSeconds(delay);
    if (sfxEvent.HasValue && !sfxEvent.GetValueOrDefault().IsNull)
      SfxSystem.OneShot(sfxEvent.Value);
    SpeechBubbleSystem.Create(new SpeechBubbleData(this.talkFrom, this.GetName(), text));
  }

  public IEnumerator PoseAfterDelay(string pose, float delay = 0.0f)
  {
    if ((double) delay > 0.0)
      yield return (object) new WaitForSeconds(delay);
    this.poser.Set(pose);
  }

  public struct Store
  {
    public string speechType;
    public float delay;
    public object[] inserts;

    public Store(string speechType, float delay, object[] inserts)
    {
      this.speechType = speechType;
      this.delay = delay;
      this.inserts = inserts;
    }
  }

  [Serializable]
  public struct Speech
  {
    public string type;
    public string[] poseOptions;
    public LocalizedString[] options;
    public EventReference sfxEvent;
    public List<LocalizedString> optionPool;

    public string Pull()
    {
      if (this.optionPool == null)
        this.optionPool = new List<LocalizedString>();
      if (this.optionPool.Count <= 0)
        this.optionPool.AddRange((IEnumerable<LocalizedString>) this.options);
      int index = PettyRandom.Range(0, this.optionPool.Count - 1);
      LocalizedString localizedString = this.optionPool[index];
      this.optionPool.RemoveAt(index);
      return localizedString.GetLocalizedString();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraint
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public abstract class TargetConstraint : ScriptableObject
{
  [SerializeField]
  public bool not;

  public virtual bool Check(Entity target) => throw new NotImplementedException();

  public virtual bool Check(CardData targetData) => throw new NotImplementedException();
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintAnd
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "And", menuName = "Target Constraints/And")]
public class TargetConstraintAnd : TargetConstraint
{
  [SerializeField]
  public TargetConstraint[] constraints;

  public override bool Check(Entity target)
  {
    foreach (TargetConstraint constraint in this.constraints)
    {
      if (!constraint.Check(target))
        return this.not;
    }
    return !this.not;
  }

  public override bool Check(CardData targetData)
  {
    foreach (TargetConstraint constraint in this.constraints)
    {
      if (!constraint.Check(targetData))
        return this.not;
    }
    return !this.not;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintAttackMoreThan
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Attack More Than", menuName = "Target Constraints/Attack More Than")]
public class TargetConstraintAttackMoreThan : TargetConstraint
{
  [SerializeField]
  public int value;

  public override bool Check(Entity target) => target.damage.current + target.tempDamage.Value <= this.value ? this.not : !this.not;

  public override bool Check(CardData targetData) => targetData.damage <= this.value ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintCanBeBoosted
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Can Be Boosted", menuName = "Target Constraints/Can Be Boosted")]
public class TargetConstraintCanBeBoosted : TargetConstraint
{
  public override bool Check(Entity target)
  {
    if (TargetConstraintCanBeBoosted.CheckAttackEffects(target))
      return !this.not;
    return TargetConstraintCanBeBoosted.CheckPassiveEffects(target) ? !this.not : this.not;
  }

  public override bool Check(CardData targetData)
  {
    if (TargetConstraintCanBeBoosted.CheckAttackEffects(targetData))
      return !this.not;
    if (TargetConstraintCanBeBoosted.CheckPassiveEffects(targetData))
      return !this.not;
    return TargetConstraintCanBeBoosted.CheckTraits(targetData) ? !this.not : this.not;
  }

  public static bool CheckAttackEffects(Entity target) => TargetConstraintCanBeBoosted.CheckAttackEffects(target.attackEffects.Select<CardData.StatusEffectStacks, StatusEffectData>((Func<CardData.StatusEffectStacks, StatusEffectData>) (a => a.data)));

  public static bool CheckAttackEffects(CardData targetData) => TargetConstraintCanBeBoosted.CheckAttackEffects(((IEnumerable<CardData.StatusEffectStacks>) targetData.attackEffects).Select<CardData.StatusEffectStacks, StatusEffectData>((Func<CardData.StatusEffectStacks, StatusEffectData>) (a => a.data)));

  public static bool CheckAttackEffects(IEnumerable<StatusEffectData> effects) => effects != null && effects.Any<StatusEffectData>((Func<StatusEffectData, bool>) (e => e.stackable));

  public static bool CheckPassiveEffects(Entity target) => TargetConstraintCanBeBoosted.CheckPassiveEffects((IEnumerable<StatusEffectData>) target.statusEffects);

  public static bool CheckPassiveEffects(CardData targetData) => TargetConstraintCanBeBoosted.CheckPassiveEffects(((IEnumerable<CardData.StatusEffectStacks>) targetData.startWithEffects).Select<CardData.StatusEffectStacks, StatusEffectData>((Func<CardData.StatusEffectStacks, StatusEffectData>) (a => a.data)));

  public static bool CheckPassiveEffects(IEnumerable<StatusEffectData> effects) => effects != null && effects.Any<StatusEffectData>((Func<StatusEffectData, bool>) (e => e.canBeBoosted));

  public static bool CheckTraits(Entity target)
  {
    if (target.traits == null)
      return false;
    foreach (Entity.TraitStacks trait in target.traits)
    {
      if (TargetConstraintCanBeBoosted.CheckPassiveEffects((IEnumerable<StatusEffectData>) trait.data.effects))
        return true;
    }
    return false;
  }

  public static bool CheckTraits(CardData targetData)
  {
    if (targetData.traits == null)
      return false;
    foreach (CardData.TraitStacks trait in targetData.traits)
    {
      if (TargetConstraintCanBeBoosted.CheckPassiveEffects((IEnumerable<StatusEffectData>) trait.data.effects))
        return true;
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintCanBeHit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Can Be Hit", menuName = "Target Constraints/Can Be Hit")]
public class TargetConstraintCanBeHit : TargetConstraint
{
  public override bool Check(Entity target) => !target.canBeHit ? this.not : !this.not;

  public override bool Check(CardData targetData) => !targetData.canBeHit ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintCanTakeCrown
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Can Take Crown", menuName = "Target Constraints/Can Take Crown")]
public class TargetConstraintCanTakeCrown : TargetConstraint
{
  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData) => !targetData.cardType.canTakeCrown ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintDamaged
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Is Damaged", menuName = "Target Constraints/Is Damaged")]
public class TargetConstraintDamaged : TargetConstraint
{
  public override bool Check(Entity target) => target.hp.current >= target.hp.max ? this.not : !this.not;

  public override bool Check(CardData targetData) => this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintDoesAttack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Does Attack", menuName = "Target Constraints/Does Attack")]
public class TargetConstraintDoesAttack : TargetConstraint
{
  public override bool Check(Entity target) => !(bool) (Object) target.data || !target.data.hasAttack && target.attackEffects.Count <= 0 ? this.not : !this.not;

  public override bool Check(CardData targetData) => !(bool) (Object) targetData || !targetData.hasAttack && targetData.attackEffects.Length == 0 ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintDoesDamage
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Does Damage", menuName = "Target Constraints/Does Damage")]
public class TargetConstraintDoesDamage : TargetConstraint
{
  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData) => !(bool) (Object) targetData || !targetData.hasAttack ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintDoesKill
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Does Kill", menuName = "Target Constraints/Does Kill")]
public class TargetConstraintDoesKill : TargetConstraint
{
  public override bool Check(Entity target) => (!(bool) (UnityEngine.Object) target.data || !target.data.hasAttack) && !target.statusEffects.Any<StatusEffectData>((Func<StatusEffectData, bool>) (a => a.doesDamage)) && !target.attackEffects.Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (a => a.data.doesDamage)) ? this.not : !this.not;

  public override bool Check(CardData targetData) => (!(bool) (UnityEngine.Object) targetData || !targetData.hasAttack) && !((IEnumerable<CardData.StatusEffectStacks>) targetData.startWithEffects).Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (a => a.data.doesDamage)) && !((IEnumerable<CardData.StatusEffectStacks>) targetData.attackEffects).Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (a => a.data.doesDamage)) ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintDoesSummon
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Does Summon", menuName = "Target Constraints/Does Summon")]
public class TargetConstraintDoesSummon : TargetConstraint
{
  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData)
  {
    bool flag = false;
    foreach (CardData.StatusEffectStacks startWithEffect in targetData.startWithEffects)
    {
      if (startWithEffect.data is StatusEffectSummon data1 && data1.summonCard.cardType.unit || startWithEffect.data is StatusEffectApplyX data2 && data2.effectToApply is StatusEffectInstantSummon effectToApply && effectToApply.targetSummon.summonCard.cardType.unit)
      {
        flag = true;
        break;
      }
    }
    if (!flag)
    {
      foreach (CardData.StatusEffectStacks attackEffect in targetData.attackEffects)
      {
        if (attackEffect.data is StatusEffectInstantSummon data && data.targetSummon.summonCard.cardType.unit)
        {
          flag = true;
          break;
        }
      }
    }
    return !flag ? this.not : !this.not;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintEffectsMoreThan
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(fileName = "Effects More Than", menuName = "Target Constraints/Effects More Than")]
public class TargetConstraintEffectsMoreThan : TargetConstraint
{
  [SerializeField]
  public int amount;

  public override bool Check(Entity target)
  {
    if (this.CheckAttackEffects(target))
      return !this.not;
    return this.CheckPassiveEffects(target) ? !this.not : this.not;
  }

  public override bool Check(CardData targetData)
  {
    if (this.CheckAttackEffects(targetData))
      return !this.not;
    if (this.CheckPassiveEffects(targetData))
      return !this.not;
    return this.CheckTraits(targetData) ? !this.not : this.not;
  }

  public bool CheckAttackEffects(Entity target) => this.CheckAttackEffects((IEnumerable<CardData.StatusEffectStacks>) target.attackEffects);

  public bool CheckAttackEffects(CardData targetData) => this.CheckAttackEffects((IEnumerable<CardData.StatusEffectStacks>) targetData.attackEffects);

  public bool CheckAttackEffects(IEnumerable<CardData.StatusEffectStacks> effects) => effects != null && effects.Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (e => e.data.stackable && e.count > this.amount));

  public bool CheckPassiveEffects(Entity target) => this.CheckPassiveEffects((IEnumerable<StatusEffectData>) target.statusEffects);

  public bool CheckPassiveEffects(CardData targetData)
  {
    if (targetData.startWithEffects == null)
      return false;
    CardData.StatusEffectStacks[] array = ((IEnumerable<CardData.StatusEffectStacks>) targetData.startWithEffects).Where<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (e => e.data.canBeBoosted)).ToArray<CardData.StatusEffectStacks>();
    return array.Length != 0 && ((IEnumerable<CardData.StatusEffectStacks>) array).All<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (e => e.count > this.amount));
  }

  public bool CheckPassiveEffects(IEnumerable<StatusEffectData> effects)
  {
    if (effects == null)
      return false;
    StatusEffectData[] array = effects.Where<StatusEffectData>((Func<StatusEffectData, bool>) (e => e.canBeBoosted)).ToArray<StatusEffectData>();
    return array.Length != 0 && ((IEnumerable<StatusEffectData>) array).All<StatusEffectData>((Func<StatusEffectData, bool>) (e => e.count > this.amount));
  }

  public bool CheckTraits(Entity target)
  {
    if (target.traits == null)
      return false;
    foreach (Entity.TraitStacks trait in target.traits)
    {
      if (this.CheckPassiveEffects((IEnumerable<StatusEffectData>) trait.data.effects))
        return true;
    }
    return false;
  }

  public bool CheckTraits(CardData targetData)
  {
    if (targetData.traits == null)
      return false;
    foreach (CardData.TraitStacks trait in targetData.traits)
    {
      if (this.CheckPassiveEffects((IEnumerable<StatusEffectData>) trait.data.effects))
        return true;
    }
    return false;
  }

  [CompilerGenerated]
  public bool \u003CCheckAttackEffects\u003Eb__5_0(CardData.StatusEffectStacks e) => e.data.stackable && e.count > this.amount;

  [CompilerGenerated]
  public bool \u003CCheckPassiveEffects\u003Eb__7_1(CardData.StatusEffectStacks e) => e.count > this.amount;

  [CompilerGenerated]
  public bool \u003CCheckPassiveEffects\u003Eb__8_1(StatusEffectData e) => e.count > this.amount;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintHasAnyEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Has Any Effect", menuName = "Target Constraints/Has Any Effect")]
public class TargetConstraintHasAnyEffect : TargetConstraint
{
  public override bool Check(CardData targetData)
  {
    CardData.StatusEffectStacks[] attackEffects = targetData.attackEffects;
    if (attackEffects != null && attackEffects.Length > 0 || targetData.startWithEffects != null && ((IEnumerable<CardData.StatusEffectStacks>) targetData.startWithEffects).Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (a => !a.data.isStatus)))
      return true;
    List<CardData.TraitStacks> traits = targetData.traits;
    return traits != null && traits.Count > 0;
  }

  public override bool Check(Entity target)
  {
    List<CardData.StatusEffectStacks> attackEffects = target.attackEffects;
    if (attackEffects != null && attackEffects.Count > 0)
      return true;
    return target.statusEffects != null && target.statusEffects.Any<StatusEffectData>((Func<StatusEffectData, bool>) (a => !a.isStatus));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintHasAttackEffect
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(fileName = "Has Attack Effect", menuName = "Target Constraints/Has Attack Effect")]
public class TargetConstraintHasAttackEffect : TargetConstraint
{
  [SerializeField]
  public StatusEffectData effect;

  public override bool Check(Entity target) => !target.attackEffects.Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) this.effect)) ? this.not : !this.not;

  public override bool Check(CardData targetData) => !((IEnumerable<CardData.StatusEffectStacks>) targetData.attackEffects).Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) this.effect)) ? this.not : !this.not;

  [CompilerGenerated]
  public bool \u003CCheck\u003Eb__1_0(CardData.StatusEffectStacks a) => (UnityEngine.Object) a.data == (UnityEngine.Object) this.effect;

  [CompilerGenerated]
  public bool \u003CCheck\u003Eb__2_0(CardData.StatusEffectStacks a) => (UnityEngine.Object) a.data == (UnityEngine.Object) this.effect;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintHasCrown
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[CreateAssetMenu(fileName = "Has Crown", menuName = "Target Constraints/Has Crown")]
public class TargetConstraintHasCrown : TargetConstraint
{
  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData) => !((UnityEngine.Object) targetData.upgrades.Find((Predicate<CardUpgradeData>) (a => a.type == CardUpgradeData.Type.Crown)) != (UnityEngine.Object) null) ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintHasEffectBasedOn
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Has Effect Based On", menuName = "Target Constraints/Has Effect Based On")]
public class TargetConstraintHasEffectBasedOn : TargetConstraint
{
  [SerializeField]
  public string basedOnStatusType;

  public override bool Check(CardData targetData)
  {
    foreach (CardData.StatusEffectStacks attackEffect in targetData.attackEffects)
    {
      if (attackEffect.data is StatusEffectInstantDoubleX data && data.statusToDouble.type == this.basedOnStatusType)
        return !this.not;
      if (attackEffect.data.type == this.basedOnStatusType)
        return !this.not;
    }
    foreach (CardData.StatusEffectStacks startWithEffect in targetData.startWithEffects)
    {
      switch (startWithEffect.data)
      {
        case StatusEffectApplyXWhenYAppliedTo applyXwhenYappliedTo:
          if (applyXwhenYappliedTo.whenAppliedType == this.basedOnStatusType || (bool) (Object) applyXwhenYappliedTo.effectToApply && applyXwhenYappliedTo.effectToApply.type == this.basedOnStatusType)
            return !this.not;
          break;
        case StatusEffectApplyXWhenYAppliedToAlly xwhenYappliedToAlly:
          if (xwhenYappliedToAlly.whenAppliedType == this.basedOnStatusType || (bool) (Object) xwhenYappliedToAlly.effectToApply && xwhenYappliedToAlly.effectToApply.type == this.basedOnStatusType)
            return !this.not;
          break;
        case StatusEffectApplyXWhenYAppliedToSelf xwhenYappliedToSelf:
          if (xwhenYappliedToSelf.whenAppliedType == this.basedOnStatusType || (bool) (Object) xwhenYappliedToSelf.effectToApply && xwhenYappliedToSelf.effectToApply.type == this.basedOnStatusType)
            return !this.not;
          break;
        case StatusEffectApplyX statusEffectApplyX:
          if ((bool) (Object) statusEffectApplyX.effectToApply && statusEffectApplyX.effectToApply.type == this.basedOnStatusType)
            return !this.not;
          break;
        case StatusEffectBonusDamageEqualToX bonusDamageEqualToX:
          if (bonusDamageEqualToX.effectType == this.basedOnStatusType)
            return !this.not;
          break;
      }
    }
    return this.not;
  }

  public override bool Check(Entity target) => this.Check(target.data);
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintHasHealth
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Has Health", menuName = "Target Constraints/Has Health")]
public class TargetConstraintHasHealth : TargetConstraint
{
  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData) => !targetData.hasHealth ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintHasReaction
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Has Reaction", menuName = "Target Constraints/Has Reaction")]
public class TargetConstraintHasReaction : TargetConstraint
{
  public override bool Check(Entity target) => target.statusEffects.Any<StatusEffectData>((Func<StatusEffectData, bool>) (effect => effect.isReaction)) ? !this.not : this.not;

  public override bool Check(CardData targetData) => ((IEnumerable<CardData.StatusEffectStacks>) targetData.startWithEffects).Any<CardData.StatusEffectStacks>((Func<CardData.StatusEffectStacks, bool>) (effectStacks => effectStacks.data.isReaction)) ? !this.not : this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintHasStatus
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "Has Status", menuName = "Target Constraints/Has Status")]
public class TargetConstraintHasStatus : TargetConstraint
{
  [SerializeField]
  public StatusEffectData status;

  public override bool Check(Entity target) => !(bool) (Object) target.FindStatus(this.status.type) ? this.not : !this.not;

  public override bool Check(CardData targetData)
  {
    bool flag = false;
    foreach (CardData.StatusEffectStacks startWithEffect in targetData.startWithEffects)
    {
      if (startWithEffect.data.type == this.status.type)
      {
        flag = true;
        break;
      }
    }
    return !this.not ? flag : !flag;
  }

  public bool CheckWillApply(Hit hit)
  {
    bool flag = false;
    List<CardData.StatusEffectStacks> statusEffects = hit.statusEffects;
    if (statusEffects != null && statusEffects.Count > 0)
    {
      foreach (CardData.StatusEffectStacks statusEffect in hit.statusEffects)
      {
        if (statusEffect.data.type == this.status.type)
        {
          flag = true;
          break;
        }
      }
    }
    return !this.not ? flag : !flag;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintHasStatusType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Has Status Type", menuName = "Target Constraints/Has Status Type")]
public class TargetConstraintHasStatusType : TargetConstraint
{
  [SerializeField]
  public string statusType;

  public override bool Check(Entity target) => !(bool) (Object) target.FindStatus(this.statusType) ? this.not : !this.not;

  public override bool Check(CardData targetData)
  {
    foreach (CardData.StatusEffectStacks startWithEffect in targetData.startWithEffects)
    {
      if (startWithEffect.data.type == this.statusType)
        return !this.not;
    }
    return this.not;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintHasTrait
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Has Trait", menuName = "Target Constraints/Has Trait")]
public class TargetConstraintHasTrait : TargetConstraint
{
  [SerializeField]
  public TraitData trait;
  [SerializeField]
  public bool ignoreSilenced;

  public override bool Check(Entity target)
  {
    if (this.ignoreSilenced && target.silenced)
      return this.not;
    bool flag = false;
    foreach (Entity.TraitStacks trait in target.traits)
    {
      if (trait.data.name == this.trait.name)
      {
        flag = true;
        break;
      }
    }
    return !flag ? this.not : !this.not;
  }

  public override bool Check(CardData targetData)
  {
    bool flag = false;
    foreach (CardData.TraitStacks trait in targetData.traits)
    {
      if (trait.data.name == this.trait.name)
      {
        flag = true;
        break;
      }
    }
    return !flag ? this.not : !this.not;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintHealthMoreThan
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Health More Than", menuName = "Target Constraints/Health More Than")]
public class TargetConstraintHealthMoreThan : TargetConstraint
{
  [SerializeField]
  public int value;

  public override bool Check(Entity target) => target.hp.current <= this.value ? this.not : !this.not;

  public override bool Check(CardData targetData) => targetData.hp <= this.value ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintIsAlive
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Is Alive", menuName = "Target Constraints/Is Alive")]
public class TargetConstraintIsAlive : TargetConstraint
{
  public override bool Check(Entity target) => !target.alive || target.ReadyToDie() ? this.not : !this.not;

  public override bool Check(CardData targetData) => !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintIsCardType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Is Card Type", menuName = "Target Constraints/Is Card Type")]
public class TargetConstraintIsCardType : TargetConstraint
{
  [SerializeField]
  public CardType[] allowedTypes;

  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData) => !this.allowedTypes.Contains<CardType>(targetData.cardType) ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintIsItem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Is Item", menuName = "Target Constraints/Is Item")]
public class TargetConstraintIsItem : TargetConstraint
{
  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData) => !targetData.cardType.item ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintIsOffensive
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Is Offensive", menuName = "Target Constraints/Is Offensive")]
public class TargetConstraintIsOffensive : TargetConstraint
{
  public override bool Check(Entity target) => !target.data.hasAttack && !target.IsOffensive() ? this.not : !this.not;

  public override bool Check(CardData targetData) => !targetData.IsOffensive() ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintIsSpecificCard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "Is Specific Card", menuName = "Target Constraints/Is Specific Card")]
public class TargetConstraintIsSpecificCard : TargetConstraint
{
  [SerializeField]
  public CardData[] allowedCards;

  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData) => !((IEnumerable<CardData>) this.allowedCards).Any<CardData>((Func<CardData, bool>) (a => a.name == targetData.name)) ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintIsUnit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Is Unit", menuName = "Target Constraints/Is Unit")]
public class TargetConstraintIsUnit : TargetConstraint
{
  [SerializeField]
  public bool mustBeMiniboss;

  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData)
  {
    if (!(bool) (Object) targetData)
      return this.not;
    CardType cardType = targetData.cardType;
    return !(bool) (Object) cardType || !cardType.unit || !this.CheckMiniboss(cardType) ? this.not : !this.not;
  }

  public bool CheckMiniboss(CardType cardType) => !this.mustBeMiniboss || cardType.miniboss;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintMaxCounterMoreThan
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Max Counter More Than", menuName = "Target Constraints/Max Counter More Than")]
public class TargetConstraintMaxCounterMoreThan : TargetConstraint
{
  [SerializeField]
  public int moreThan;

  public override bool Check(Entity target) => target.counter.max <= this.moreThan ? this.not : !this.not;

  public override bool Check(CardData targetData) => targetData.counter <= this.moreThan ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintNeedsTarget
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Needs Target", menuName = "Target Constraints/Needs Target")]
public class TargetConstraintNeedsTarget : TargetConstraint
{
  public override bool Check(Entity target) => !target.NeedsTarget ? this.not : !this.not;

  public override bool Check(CardData targetData) => !targetData.needsTarget ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintOnBoard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Is On Board", menuName = "Target Constraints/Is On Board")]
public class TargetConstraintOnBoard : TargetConstraint
{
  public override bool Check(Entity target) => !Battle.IsOnBoard(target) ? this.not : !this.not;

  public override bool Check(CardData targetData) => this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintOr
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Or", menuName = "Target Constraints/Or")]
public class TargetConstraintOr : TargetConstraint
{
  [SerializeField]
  public TargetConstraint[] constraints;

  public override bool Check(Entity target)
  {
    foreach (TargetConstraint constraint in this.constraints)
    {
      if (constraint.Check(target))
        return !this.not;
    }
    return this.not;
  }

  public override bool Check(CardData targetData)
  {
    foreach (TargetConstraint constraint in this.constraints)
    {
      if (constraint.Check(targetData))
        return !this.not;
    }
    return this.not;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintPlayOnSlot
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Plays On", menuName = "Target Constraints/Plays On")]
public class TargetConstraintPlayOnSlot : TargetConstraint
{
  [SerializeField]
  public bool slot;
  [SerializeField]
  public bool board;
  [SerializeField]
  public bool hand;
  [SerializeField]
  public bool enemy;
  [SerializeField]
  public bool friendly;

  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData) => this.slot && !targetData.playOnSlot || this.board && !targetData.canPlayOnBoard || this.hand && !targetData.canPlayOnHand || this.enemy && !targetData.canPlayOnEnemy || this.friendly && !targetData.canPlayOnFriendly ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintPlayType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Play Type", menuName = "Target Constraints/Play Type")]
public class TargetConstraintPlayType : TargetConstraint
{
  [SerializeField]
  public Card.PlayType targetPlayType;

  public override bool Check(Entity target) => this.Check(target.data);

  public override bool Check(CardData targetData) => targetData.playType != this.targetPlayType ? this.not : !this.not;
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetConstraintStatusMoreThan
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "Status More Than", menuName = "Target Constraints/Status More Than")]
public class TargetConstraintStatusMoreThan : TargetConstraint
{
  [SerializeField]
  public StatusEffectData status;
  [SerializeField]
  public int amount;

  public override bool Check(Entity target)
  {
    StatusEffectData status = target.FindStatus(this.status.type);
    return !(bool) (Object) status || status.count <= this.amount ? this.not : !this.not;
  }

  public override bool Check(CardData targetData)
  {
    foreach (CardData.StatusEffectStacks startWithEffect in targetData.startWithEffects)
    {
      if (startWithEffect.data.type == this.status.type && startWithEffect.count > this.amount)
        return !this.not;
    }
    return this.not;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetingArrow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof (Bezier))]
public class TargetingArrow : TargetingDisplay
{
  [SerializeField]
  public Transform head;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float curviness = 0.5f;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float arch;
  [SerializeField]
  public TargetingArrow.ArrowHeadStyle[] headStyles;
  [SerializeField]
  public string defaultStyleName = "Default";
  public Dictionary<string, TargetingArrow.ArrowHeadStyle> _headStyleLookup;
  public TargetingArrow.ArrowHeadStyle currentHeadStyle;
  public Bezier _bezier;

  public Dictionary<string, TargetingArrow.ArrowHeadStyle> headStyleLookup
  {
    get
    {
      if (this._headStyleLookup == null)
      {
        this._headStyleLookup = new Dictionary<string, TargetingArrow.ArrowHeadStyle>();
        foreach (TargetingArrow.ArrowHeadStyle headStyle in this.headStyles)
          this._headStyleLookup[headStyle.name] = headStyle;
      }
      return this._headStyleLookup;
    }
  }

  public Bezier bezier => this._bezier ?? (this._bezier = this.GetComponent<Bezier>());

  public override void UpdatePosition(Transform target) => this.UpdatePosition(this.transform.position, target.position);

  public override void UpdatePosition(Vector3 start, Vector3 end)
  {
    float y = Mathf.Lerp(start.y, end.y, this.curviness);
    Vector3 p1 = new Vector3(start.x, y, start.z - this.arch);
    this.bezier.UpdateCurve(start, p1, end);
    if (!(bool) (UnityEngine.Object) this.head)
      return;
    this.head.position = this.bezier.GetPoint(this.bezier.pointCount - 1);
    TargetingArrow.ArrowHeadStyle currentHeadStyle = this.currentHeadStyle;
    if (currentHeadStyle == null || !currentHeadStyle.directional)
      return;
    Transform transform = currentHeadStyle.transform;
    if (transform == null || this.bezier.pointCount <= 1)
      return;
    Vector3 point = this.bezier.GetPoint(this.bezier.pointCount - 2);
    Vector3 vector3 = transform.position - point;
    float num = Mathf.Atan(vector3.y / vector3.x) * 57.29578f;
    if ((double) vector3.x < 0.0)
      num += 180f;
    if (float.IsNaN(num))
      return;
    transform.localEulerAngles = new Vector3(0.0f, 0.0f, num);
  }

  public override void EntityHover(Entity entity) => this.SetStyle("Target");

  public override void ContainerHover(CardContainer cardContainer, TargetingArrowSystem system)
  {
    if ((UnityEngine.Object) cardContainer == (UnityEngine.Object) system.target.owner.discardContainer && system.target.CanRecall())
    {
      system.snapToContainer = cardContainer;
      this.SetStyle("Discard");
    }
    else
    {
      if (!system.target.targetMode.TargetRow || !system.target.CanPlayOn(cardContainer))
        return;
      system.snapToContainer = cardContainer;
      this.SetStyle("TargetRow");
    }
  }

  public override void SlotHover(CardSlot slot, TargetingArrowSystem system)
  {
    if (!system.target.data.playOnSlot || !system.target.CanPlayOn((CardContainer) slot))
      return;
    system.snapToContainer = (CardContainer) slot;
    this.SetStyle("Target");
  }

  public void SetStyle(string name)
  {
    if ((bool) (UnityEngine.Object) this.currentHeadStyle?.gameObject)
      this.currentHeadStyle.gameObject.SetActive(false);
    this.currentHeadStyle = this.headStyleLookup.ContainsKey(name) ? this.headStyleLookup[name] : this.headStyleLookup[this.defaultStyleName];
    if ((bool) (UnityEngine.Object) this.currentHeadStyle?.gameObject)
      this.currentHeadStyle.gameObject.SetActive(true);
    if ((bool) (UnityEngine.Object) this.currentHeadStyle.renderer)
      this.currentHeadStyle.renderer.color = this.currentHeadStyle.headColor;
    this.bezier.lineRenderer.colorGradient = this.currentHeadStyle.lineColor;
  }

  public override void ResetStyle() => this.SetStyle(this.defaultStyleName);

  [Serializable]
  public class ArrowHeadStyle
  {
    public string name;
    public GameObject gameObject;
    public Transform transform;
    public SpriteRenderer renderer;
    public bool directional;
    public Color headColor;
    public Gradient lineColor;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetingArrowHeadRow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class TargetingArrowHeadRow : MonoBehaviour
{
  [SerializeField]
  public TargetingArrowSystem targetArrowSystem;
  [SerializeField]
  public Transform[] targetTransforms;
  [SerializeField]
  public SpriteRenderer[] targets;
  [SerializeField]
  public Sprite canTarget;
  [SerializeField]
  public Sprite cannotTarget;
  public List<CardSlot> slots;

  public void OnEnable()
  {
    if (!(this.targetArrowSystem.snapToContainer is CardSlotLane snapToContainer))
      return;
    this.slots = snapToContainer.slots;
    if (this.targetArrowSystem.target.data.playOnSlot)
    {
      for (int index = 0; index < this.targets.Length && index < this.slots.Count; ++index)
        this.targets[index].sprite = this.targetArrowSystem.target.CanPlayOn((CardContainer) this.slots[index], true) ? this.canTarget : this.cannotTarget;
    }
    else
    {
      for (int index = 0; index < this.targets.Length && index < this.slots.Count; ++index)
      {
        SpriteRenderer target = this.targets[index];
        CardSlot slot = this.slots[index];
        Sprite sprite = slot.Empty || !this.targetArrowSystem.target.CanPlayOn(slot.GetTop(), true) ? this.cannotTarget : this.canTarget;
        target.sprite = sprite;
      }
    }
  }

  public void LateUpdate()
  {
    for (int index = 0; index < this.targetTransforms.Length && index < this.slots.Count; ++index)
      this.targetTransforms[index].position = this.slots[index].holder.position;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetingArrowSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class TargetingArrowSystem : GameSystem
{
  public TargetingDisplay offensiveArrow;
  public TargetingDisplay supportiveArrow;
  public TargetingDisplay targetMulti;
  public Entity target;
  public Entity hover;
  public CardContainer snapToContainer;
  public bool active;
  public Vector3 toPosition;
  [SerializeField]
  [Range(0.0f, 1f)]
  public float lerp = 0.4f;
  public TargetingDisplay currentArrow;
  public bool offensive;

  public Vector3 toPositionTarget
  {
    get
    {
      if ((bool) (Object) this.hover)
        return this.hover.transform.position;
      return (bool) (Object) this.snapToContainer ? this.snapToContainer.transform.position : MonoBehaviourSingleton<Cursor3d>.instance.transform.position;
    }
  }

  public static bool CorrectType(Card.PlayType playType) => playType == Card.PlayType.Play;

  public void OnEnable()
  {
    global::Events.OnEntityDrag += new UnityAction<Entity>(this.EntityDrag);
    global::Events.OnEntityRelease += new UnityAction<Entity>(this.EntityRelease);
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
    global::Events.OnContainerHover += new UnityAction<CardContainer>(this.ContainerHover);
    global::Events.OnContainerUnHover += new UnityAction<CardContainer>(this.ContainerUnHover);
    global::Events.OnSlotHover += new UnityAction<CardSlot>(this.SlotHover);
    global::Events.OnSlotUnHover += new UnityAction<CardSlot>(this.SlotUnHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityDrag -= new UnityAction<Entity>(this.EntityDrag);
    global::Events.OnEntityRelease -= new UnityAction<Entity>(this.EntityRelease);
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
    global::Events.OnContainerHover -= new UnityAction<CardContainer>(this.ContainerHover);
    global::Events.OnContainerUnHover -= new UnityAction<CardContainer>(this.ContainerUnHover);
    global::Events.OnSlotHover -= new UnityAction<CardSlot>(this.SlotHover);
    global::Events.OnSlotUnHover -= new UnityAction<CardSlot>(this.SlotUnHover);
  }

  public void LateUpdate()
  {
    if (!this.active && (bool) (Object) this.target)
      this.Show();
    if (this.active && !(bool) (Object) this.target)
      this.Hide();
    if (!this.active)
      return;
    this.UpdateArrow();
    this.toPosition = Delta.Lerp(this.toPosition, this.toPositionTarget, this.lerp, Time.deltaTime);
  }

  public void UpdateArrow() => this.currentArrow.UpdatePosition(this.target.transform.position, this.toPosition);

  public void Show()
  {
    this.active = true;
    this.currentArrow = this.target.NeedsTarget ? (this.offensive ? this.offensiveArrow : this.supportiveArrow) : this.targetMulti;
    this.currentArrow.gameObject.SetActive(true);
    this.currentArrow.ResetStyle();
    this.toPosition = !TouchInputModule.active ? this.toPositionTarget : this.target.transform.position;
    this.currentArrow.Show(this);
  }

  public void Hide()
  {
    this.active = false;
    this.currentArrow.gameObject.SetActive(false);
    this.currentArrow.Hide();
  }

  public void EntityDrag(Entity entity)
  {
    if (!entity.inPlay || !(bool) (Object) entity || !(bool) (Object) entity.data || !TargetingArrowSystem.CorrectType(entity.data.playType))
      return;
    this.target = entity;
    this.offensive = this.target.IsOffensive();
  }

  public void EntityRelease(Entity entity)
  {
    if (!((Object) this.target == (Object) entity))
      return;
    this.target = (Entity) null;
  }

  public void EntityHover(Entity entity)
  {
    if (!this.active || !(bool) (Object) this.target || this.target.targetMode.TargetRow || this.target.data.playOnSlot)
      return;
    this.hover = entity;
    this.currentArrow.EntityHover(entity);
  }

  public void EntityUnHover(Entity entity)
  {
    if (!((Object) this.hover == (Object) entity))
      return;
    this.hover = (Entity) null;
    if (!this.active || !(bool) (Object) this.currentArrow)
      return;
    this.currentArrow.ResetStyle();
  }

  public void ContainerHover(CardContainer container)
  {
    if (!this.active || !((Object) this.target != (Object) null))
      return;
    this.currentArrow.ContainerHover(container, this);
  }

  public void ContainerUnHover(CardContainer container)
  {
    if (!((Object) this.snapToContainer == (Object) container))
      return;
    this.snapToContainer = (CardContainer) null;
    if (!this.active || !(bool) (Object) this.currentArrow)
      return;
    this.currentArrow.ResetStyle();
  }

  public void SlotHover(CardSlot slot)
  {
    if (!this.active || !(bool) (Object) this.target)
      return;
    this.currentArrow.SlotHover(slot, this);
  }

  public void SlotUnHover(CardSlot slot)
  {
    if (!((Object) this.snapToContainer == (Object) slot))
      return;
    this.snapToContainer = (CardContainer) null;
    if (!this.active || !(bool) (Object) this.currentArrow)
      return;
    this.currentArrow.ResetStyle();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetingDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public abstract class TargetingDisplay : MonoBehaviour
{
  public virtual void UpdatePosition(Transform target)
  {
  }

  public virtual void UpdatePosition(Vector3 start, Vector3 end)
  {
  }

  public virtual void Show(TargetingArrowSystem system)
  {
  }

  public virtual void Hide()
  {
  }

  public virtual void ResetStyle()
  {
  }

  public virtual void EntityHover(Entity entity)
  {
  }

  public virtual void ContainerHover(CardContainer cardContainer, TargetingArrowSystem system)
  {
  }

  public virtual void SlotHover(CardSlot slot, TargetingArrowSystem system)
  {
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetingMultiple
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class TargetingMultiple : TargetingDisplay
{
  [SerializeField]
  public GameObject targetPrefab;
  public readonly List<GameObject> targets = new List<GameObject>();
  public Entity target;
  public Entity[] entitiesToHit;
  public bool showingTargets;

  public override void Show(TargetingArrowSystem system)
  {
    this.target = system.target;
    this.entitiesToHit = this.target.targetMode.GetTargets(this.target, (Entity) null, (CardContainer) null);
    global::Events.OnContainerHover += new UnityAction<CardContainer>(this.ContainerHover);
    global::Events.OnContainerUnHover += new UnityAction<CardContainer>(this.ContainerUnHover);
  }

  public override void Hide()
  {
    this.HideTargets();
    global::Events.OnContainerHover -= new UnityAction<CardContainer>(this.ContainerHover);
    global::Events.OnContainerUnHover -= new UnityAction<CardContainer>(this.ContainerUnHover);
  }

  public void ContainerHover(CardContainer cardContainer)
  {
    if (!(bool) (Object) cardContainer || this.target.containers.Length == 0 || !((Object) cardContainer == (Object) this.target.containers[0]))
      return;
    this.HideTargets();
  }

  public void ContainerUnHover(CardContainer cardContainer)
  {
    if (this.showingTargets || !(bool) (Object) this.target || this.target.containers.Length == 0 || !((Object) cardContainer == (Object) this.target.containers[0]))
      return;
    this.ShowTargets();
  }

  public void ShowTargets()
  {
    if (this.showingTargets)
      return;
    if (this.entitiesToHit != null)
    {
      foreach (MonoBehaviourCacheTransform behaviourCacheTransform in this.entitiesToHit)
        this.targets.Add(Object.Instantiate<GameObject>(this.targetPrefab, behaviourCacheTransform.transform.position, Quaternion.identity, this.transform));
    }
    this.showingTargets = true;
  }

  public void HideTargets()
  {
    if (!this.showingTargets)
      return;
    foreach (GameObject target in this.targets)
      target.Destroy();
    this.targets.Clear();
    this.showingTargets = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetMode
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public abstract class TargetMode : ScriptableObject
{
  public virtual bool TargetRow => false;

  public virtual bool NeedsTarget => true;

  public virtual bool Random => false;

  public virtual Entity[] GetPotentialTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    throw new NotImplementedException();
  }

  public virtual Entity[] GetTargets(Entity entity, Entity target, CardContainer targetContainer) => this.GetPotentialTargets(entity, target, targetContainer);

  public virtual Entity[] GetSubsequentTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    HashSet<Entity> list = new HashSet<Entity>();
    if ((bool) (UnityEngine.Object) target)
      list.Add(target);
    else if ((bool) (UnityEngine.Object) targetContainer)
      list.AddRange<Entity>((IEnumerable<Entity>) targetContainer);
    return list.ToArray<Entity>();
  }

  public virtual CardSlot[] GetTargetSlots(CardSlotLane row) => row.slots.Where<CardSlot>((Func<CardSlot, bool>) (a => a.Empty)).ToArray<CardSlot>();

  public virtual bool CanTarget(Entity entity) => true;

  public virtual Entity GetEnemyCharacter(Entity entity)
  {
    Entity enemyCharacter = (Entity) null;
    Character character = (UnityEngine.Object) entity.owner == (UnityEngine.Object) Battle.instance.player ? Battle.instance.enemy : Battle.instance.player;
    if ((bool) (UnityEngine.Object) character && (bool) (UnityEngine.Object) character.entity && character.entity.canBeHit)
      enemyCharacter = character.entity;
    return enemyCharacter;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetModeAll
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

[CreateAssetMenu(fileName = "TargetModeAll", menuName = "Target Modes/All")]
public class TargetModeAll : TargetMode
{
  [SerializeField]
  public TargetConstraint[] constraints;

  public override bool NeedsTarget => false;

  public override Entity[] GetPotentialTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    HashSet<Entity> list = new HashSet<Entity>();
    list.AddRange<Entity>(entity.GetAllEnemies().Where<Entity>((Func<Entity, bool>) (e => (bool) (UnityEngine.Object) e && e.enabled && e.alive && e.canBeHit && this.CheckConstraints(e))));
    return list.Count <= 0 ? (Entity[]) null : list.ToArray<Entity>();
  }

  public override Entity[] GetSubsequentTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    HashSet<Entity> list = new HashSet<Entity>();
    list.AddRange<Entity>((IEnumerable<Entity>) Battle.GetCardsOnBoard(target.owner));
    list.Remove(entity);
    return list.Count <= 0 ? (Entity[]) null : list.ToArray<Entity>();
  }

  public bool CheckConstraints(Entity target)
  {
    TargetConstraint[] constraints = this.constraints;
    return constraints == null || constraints.Length <= 0 || ((IEnumerable<TargetConstraint>) this.constraints).All<TargetConstraint>((Func<TargetConstraint, bool>) (c => c.Check(target)));
  }

  [CompilerGenerated]
  public bool \u003CGetPotentialTargets\u003Eb__3_0(Entity e) => (bool) (UnityEngine.Object) e && e.enabled && e.alive && e.canBeHit && this.CheckConstraints(e);
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetModeBack
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "TargetModeBack", menuName = "Target Modes/Back")]
public class TargetModeBack : TargetMode
{
  public override Entity[] GetPotentialTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    HashSet<Entity> entitySet = new HashSet<Entity>();
    if ((bool) (Object) targetContainer)
    {
      if (targetContainer.Count > 0)
        entitySet.Add(this.GetTarget((IList<Entity>) targetContainer));
    }
    else if ((bool) (Object) target)
    {
      if (target.containers.Length != 0)
      {
        CardContainer targets = target.containers.RandomItem<CardContainer>();
        if (targets.Count > 0)
          entitySet.Add(this.GetTarget((IList<Entity>) targets));
      }
    }
    else
    {
      int[] rowIndices = Battle.instance.GetRowIndices(entity);
      foreach (int rowIndex in rowIndices)
        this.AddTargets(entity, entitySet, rowIndex);
      if (entitySet.Count == 0)
      {
        int rowCount = Battle.instance.rowCount;
        for (int rowIndex = 0; rowIndex < rowCount; ++rowIndex)
        {
          if (!rowIndices.Contains<int>(rowIndex))
            this.AddTargets(entity, entitySet, rowIndex);
        }
      }
    }
    return entitySet.Count <= 0 ? (Entity[]) null : entitySet.ToArray<Entity>();
  }

  public override CardSlot[] GetTargetSlots(CardSlotLane row) => new CardSlot[1]
  {
    row.slots[row.max - 1]
  };

  public override bool CanTarget(Entity entity)
  {
    bool flag = false;
    foreach (CardContainer container in entity.containers)
    {
      flag = true;
      for (int index = container.IndexOf(entity) + 1; index < container.max; ++index)
      {
        if ((bool) (Object) container[index] && container[index].canBeHit)
        {
          flag = false;
          break;
        }
      }
      if (flag)
        break;
    }
    return flag;
  }

  public void AddTargets(Entity entity, HashSet<Entity> targets, int rowIndex)
  {
    Entity target = this.GetTarget((IList<Entity>) entity.GetEnemiesInRow(rowIndex));
    if ((bool) (Object) target)
    {
      targets.Add(target);
    }
    else
    {
      Entity enemyCharacter = this.GetEnemyCharacter(entity);
      if (!(bool) (Object) enemyCharacter)
        return;
      targets.Add(enemyCharacter);
    }
  }

  public Entity GetTarget(IList<Entity> targets)
  {
    for (int index = targets.Count - 1; index >= 0; --index)
    {
      Entity target = targets[index];
      if ((bool) (Object) target && target.enabled && target.alive && target.canBeHit)
        return target;
    }
    return (Entity) null;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetModeBasic
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "TargetModeBasic", menuName = "Target Modes/Basic")]
public class TargetModeBasic : TargetMode
{
  public override Entity[] GetPotentialTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    HashSet<Entity> entitySet = new HashSet<Entity>();
    if ((bool) (Object) target)
    {
      entitySet.Add(target);
    }
    else
    {
      int[] rowIndices = Battle.instance.GetRowIndices(entity);
      if (rowIndices.Length != 0)
      {
        foreach (int rowIndex in rowIndices)
          this.AddTargets(entity, entitySet, rowIndex);
        if (entitySet.Count == 0)
        {
          int rowCount = Battle.instance.rowCount;
          for (int rowIndex = 0; rowIndex < rowCount; ++rowIndex)
          {
            if (!rowIndices.Contains<int>(rowIndex))
              this.AddTargets(entity, entitySet, rowIndex);
          }
        }
      }
    }
    return entitySet.Count <= 0 ? (Entity[]) null : entitySet.ToArray<Entity>();
  }

  public void AddTargets(Entity entity, HashSet<Entity> targets, int rowIndex)
  {
    List<Entity> enemiesInRow = entity.GetEnemiesInRow(rowIndex);
    Entity entity1 = (Entity) null;
    foreach (Entity entity2 in enemiesInRow)
    {
      if ((bool) (Object) entity2 && entity2.enabled && entity2.alive && entity2.canBeHit)
      {
        entity1 = entity2;
        break;
      }
    }
    if ((bool) (Object) entity1)
    {
      targets.Add(entity1);
    }
    else
    {
      Entity enemyCharacter = this.GetEnemyCharacter(entity);
      if (!(bool) (Object) enemyCharacter)
        return;
      targets.Add(enemyCharacter);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetModeCrowns
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "TargetModeCrowns", menuName = "Target Modes/Crowns")]
public class TargetModeCrowns : TargetMode
{
  public override Entity[] GetPotentialTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    HashSet<Entity> list = new HashSet<Entity>();
    list.AddRange<Entity>(entity.GetAllEnemies().Where<Entity>((Func<Entity, bool>) (e => (bool) (UnityEngine.Object) e && e.enabled && e.alive && e.canBeHit && e.data.HasCrown)));
    return list.Count <= 0 ? (Entity[]) null : list.ToArray<Entity>();
  }

  public override Entity[] GetSubsequentTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    return this.GetTargets(entity, target, targetContainer);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetModeRandom
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "TargetModeRandom", menuName = "Target Modes/Random")]
public class TargetModeRandom : TargetMode
{
  public override bool TargetRow => true;

  public override bool Random => true;

  public override Entity[] GetPotentialTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    HashSet<Entity> entitySet = new HashSet<Entity>();
    if ((bool) (Object) targetContainer)
    {
      if (targetContainer.Count > 0)
        TargetModeRandom.AddPotentialTargets(entity, entitySet, (IEnumerable<Entity>) targetContainer);
    }
    else if ((bool) (Object) target)
    {
      switch (target.containers.Length)
      {
        case 1:
          CardContainer container = target.containers[0];
          TargetModeRandom.AddPotentialTargets(entity, entitySet, (IEnumerable<Entity>) container);
          break;
        case 2:
          using (IEnumerator<int> enumerator = ((IEnumerable<int>) References.Battle.GetRowIndices(entity)).Intersect<int>((IEnumerable<int>) References.Battle.GetRowIndices(target)).GetEnumerator())
          {
            while (enumerator.MoveNext())
            {
              int current = enumerator.Current;
              TargetModeRandom.AddPotentialTargets(entity, entitySet, current);
            }
            break;
          }
      }
    }
    else
    {
      int[] rowIndices = Battle.instance.GetRowIndices(entity);
      foreach (int rowIndex in rowIndices)
        TargetModeRandom.AddPotentialTargets(entity, entitySet, rowIndex);
      if (entitySet.Count == 0)
      {
        int rowCount = Battle.instance.rowCount;
        for (int rowIndex = 0; rowIndex < rowCount; ++rowIndex)
        {
          if (!rowIndices.Contains<int>(rowIndex))
            TargetModeRandom.AddPotentialTargets(entity, entitySet, rowIndex);
        }
      }
    }
    return entitySet.Count <= 0 ? (Entity[]) null : entitySet.ToArray<Entity>();
  }

  public override Entity[] GetTargets(Entity entity, Entity target, CardContainer targetContainer)
  {
    Entity[] potentialTargets = this.GetPotentialTargets(entity, target, targetContainer);
    if (potentialTargets == null)
      return (Entity[]) null;
    HashSet<Entity> list1 = new HashSet<Entity>();
    if (entity.containers.Length == 1)
      list1.Add(potentialTargets.RandomItem<Entity>());
    else if (entity.containers.Length > 1)
    {
      Dictionary<CardContainer, List<Entity>> dictionary = new Dictionary<CardContainer, List<Entity>>();
      foreach (CardContainer oppositeRow in References.Battle.GetOppositeRows(entity.containers))
        dictionary.Add(oppositeRow, new List<Entity>());
      foreach (Entity entity1 in potentialTargets)
      {
        foreach (CardContainer container in entity1.containers)
        {
          List<Entity> entityList;
          if (dictionary.TryGetValue(container, out entityList))
            entityList.Add(entity1);
        }
      }
      foreach (List<Entity> list2 in dictionary.Values)
      {
        if (list2.Count > 0)
          list1.Add(list2.RandomItem<Entity>());
      }
    }
    return list1.Count <= 0 ? (Entity[]) null : list1.ToArray<Entity>();
  }

  public override Entity[] GetSubsequentTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    return this.GetTargets(entity, target, targetContainer);
  }

  public override CardSlot[] GetTargetSlots(CardSlotLane row) => new CardSlot[1]
  {
    row.slots.RandomItem<CardSlot>()
  };

  public static void AddPotentialTargets(
    Entity entity,
    HashSet<Entity> targets,
    IEnumerable<Entity> collection)
  {
    foreach (Entity target in collection)
    {
      if (entity.CanPlayOn(target, true))
        targets.Add(target);
    }
  }

  public static void AddPotentialTargets(Entity entity, HashSet<Entity> targets, int rowIndex)
  {
    List<Entity> enemiesInRow = entity.GetEnemiesInRow(rowIndex);
    TargetModeRandom.AddPotentialTargets(entity, targets, (IEnumerable<Entity>) enemiesInRow);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TargetModeRow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "TargetModeRow", menuName = "Target Modes/Row")]
public class TargetModeRow : TargetMode
{
  public override bool TargetRow => true;

  public override Entity[] GetPotentialTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    HashSet<Entity> entitySet = new HashSet<Entity>();
    if ((bool) (Object) targetContainer)
      TargetModeRow.AddEligible(entity, (ISet<Entity>) entitySet, (IEnumerable<Entity>) targetContainer);
    else if ((bool) (Object) target)
    {
      switch (target.containers.Length)
      {
        case 1:
          CardContainer container = target.containers[0];
          TargetModeRow.AddEligible(entity, (ISet<Entity>) entitySet, (IEnumerable<Entity>) container);
          break;
        case 2:
          using (IEnumerator<int> enumerator = ((IEnumerable<int>) References.Battle.GetRowIndices(entity)).Intersect<int>((IEnumerable<int>) References.Battle.GetRowIndices(target)).GetEnumerator())
          {
            while (enumerator.MoveNext())
            {
              int current = enumerator.Current;
              List<Entity> enemiesInRow = entity.GetEnemiesInRow(current);
              TargetModeRow.AddEligible(entity, (ISet<Entity>) entitySet, (IEnumerable<Entity>) enemiesInRow);
            }
            break;
          }
      }
    }
    else
    {
      int[] rowIndices = Battle.instance.GetRowIndices(entity);
      foreach (int rowIndex in rowIndices)
      {
        List<Entity> enemiesInRow = entity.GetEnemiesInRow(rowIndex);
        TargetModeRow.AddEligible(entity, (ISet<Entity>) entitySet, (IEnumerable<Entity>) enemiesInRow);
      }
      if (entitySet.Count == 0)
      {
        int rowCount = Battle.instance.rowCount;
        for (int rowIndex = 0; rowIndex < rowCount; ++rowIndex)
        {
          if (!rowIndices.Contains<int>(rowIndex))
          {
            List<Entity> enemiesInRow = entity.GetEnemiesInRow(rowIndex);
            TargetModeRow.AddEligible(entity, (ISet<Entity>) entitySet, (IEnumerable<Entity>) enemiesInRow);
          }
        }
      }
    }
    return entitySet.Count <= 0 ? (Entity[]) null : entitySet.ToArray<Entity>();
  }

  public override Entity[] GetSubsequentTargets(
    Entity entity,
    Entity target,
    CardContainer targetContainer)
  {
    return this.GetTargets(entity, target, targetContainer);
  }

  public static void AddEligible(
    Entity entity,
    ISet<Entity> targets,
    IEnumerable<Entity> fromCollection)
  {
    foreach (Entity from in fromCollection)
    {
      if (entity.CanPlayOn(from, true))
        targets.Add(from);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Targets
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;

public static class Targets
{
  public static bool CheckFlag(Targets.Flag flags, Targets.Flag target) => (flags & target) != 0;

  public static List<Entity> Get(
    Entity self,
    Targets.Flag canTarget,
    StatusEffectData effectToApply,
    TargetConstraint[] applyConstraints,
    Hit hit = null)
  {
    List<Entity> entityList = new List<Entity>();
    if (Targets.CheckFlag(canTarget, Targets.Flag.Self))
      entityList.Add(self);
    Targets.CheckFlag(canTarget, Targets.Flag.Hand);
    Targets.CheckFlag(canTarget, Targets.Flag.EnemyHand);
    if (Targets.CheckFlag(canTarget, Targets.Flag.Allies))
      entityList.AddRange((IEnumerable<Entity>) self.GetAllAllies());
    else if (Targets.CheckFlag(canTarget, Targets.Flag.AlliesInRow))
    {
      entityList.AddRange((IEnumerable<Entity>) self.GetAlliesInRow());
    }
    else
    {
      if (Targets.CheckFlag(canTarget, Targets.Flag.FrontAlly))
      {
        foreach (CardContainer container in self.containers)
        {
          foreach (Entity entity in container)
          {
            if ((bool) (UnityEngine.Object) entity)
            {
              entityList.Add(entity);
              break;
            }
          }
        }
      }
      if (Targets.CheckFlag(canTarget, Targets.Flag.BackAlly))
      {
        foreach (CardContainer container in self.containers)
        {
          for (int index = container.Count - 1; index >= 0; --index)
          {
            Entity entity = container[index];
            if ((bool) (UnityEngine.Object) entity)
            {
              entityList.Add(entity);
              break;
            }
          }
        }
      }
      if (Targets.CheckFlag(canTarget, Targets.Flag.AllyInFrontOf))
      {
        foreach (CardContainer actualContainer in self.actualContainers)
        {
          Entity entity = (Entity) null;
          if (actualContainer is CardSlot cardSlot && actualContainer.Group is CardSlotLane group)
          {
            for (int index = group.slots.IndexOf(cardSlot) - 1; index >= 0; --index)
            {
              entity = group.slots[index].GetTop();
              if ((bool) (UnityEngine.Object) entity)
                break;
            }
          }
          if ((bool) (UnityEngine.Object) entity)
          {
            entityList.Add(entity);
            break;
          }
        }
      }
      if (Targets.CheckFlag(canTarget, Targets.Flag.AllyBehind))
      {
        foreach (CardContainer actualContainer in self.actualContainers)
        {
          Entity entity = (Entity) null;
          if (actualContainer is CardSlot cardSlot && actualContainer.Group is CardSlotLane group)
          {
            for (int index = group.slots.IndexOf(cardSlot) + 1; index < group.slots.Count; ++index)
            {
              entity = group.slots[index].GetTop();
              if ((bool) (UnityEngine.Object) entity)
                break;
            }
          }
          if ((bool) (UnityEngine.Object) entity)
          {
            entityList.Add(entity);
            break;
          }
        }
      }
    }
    if (Targets.CheckFlag(canTarget, Targets.Flag.Enemies))
      entityList.AddRange((IEnumerable<Entity>) self.GetAllEnemies());
    else if (Targets.CheckFlag(canTarget, Targets.Flag.EnemiesInRow))
    {
      foreach (int rowIndex in Battle.instance.GetRowIndices(self))
      {
        List<Entity> enemiesInRow = self.GetEnemiesInRow(rowIndex);
        if (enemiesInRow != null && enemiesInRow.Count > 0)
          entityList.AddRange((IEnumerable<Entity>) enemiesInRow);
      }
    }
    else if (Targets.CheckFlag(canTarget, Targets.Flag.FrontEnemy))
    {
      foreach (int rowIndex in Battle.instance.GetRowIndices(self))
      {
        List<Entity> enemiesInRow = self.GetEnemiesInRow(rowIndex);
        if (enemiesInRow != null && enemiesInRow.Count > 0)
          entityList.Add(enemiesInRow[0]);
      }
    }
    if (Targets.CheckFlag(canTarget, Targets.Flag.Attacker))
    {
      if (hit == null)
        hit = self.lastHit;
      if ((bool) (UnityEngine.Object) hit?.attacker)
      {
        Entity target = hit.attacker;
        if (!effectToApply.CanPlayOn(target))
          target = effectToApply.CanPlayOn(target.owner.entity) ? target.owner.entity : (Entity) null;
        if ((bool) (UnityEngine.Object) target)
          entityList.Add(target);
      }
    }
    if (Targets.CheckFlag(canTarget, Targets.Flag.Target))
    {
      if (hit == null)
        hit = self.lastHit;
      if ((bool) (UnityEngine.Object) hit?.target)
        entityList.Add(hit.target);
    }
    if (Targets.CheckFlag(canTarget, Targets.Flag.RandomUnit))
    {
      List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(self.owner);
      cardsOnBoard.AddRange((IEnumerable<Entity>) Battle.GetCardsOnBoard(Battle.GetOpponent(self.owner)));
      cardsOnBoard.Remove(self);
      Targets.RemoveIneligible((IList<Entity>) cardsOnBoard, effectToApply, applyConstraints);
      if (cardsOnBoard.Count > 0)
        entityList.Add(cardsOnBoard.RandomItem<Entity>());
    }
    if (Targets.CheckFlag(canTarget, Targets.Flag.RandomAlly))
    {
      List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(self.owner);
      cardsOnBoard.Remove(self);
      Targets.RemoveIneligible((IList<Entity>) cardsOnBoard, effectToApply, applyConstraints);
      if (cardsOnBoard.Count > 0)
        entityList.Add(cardsOnBoard.RandomItem<Entity>());
    }
    if (Targets.CheckFlag(canTarget, Targets.Flag.RandomEnemy))
    {
      List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(Battle.GetOpponent(self.owner));
      Targets.RemoveIneligible((IList<Entity>) cardsOnBoard, effectToApply, applyConstraints);
      if (cardsOnBoard.Count > 0)
        entityList.Add(cardsOnBoard.RandomItem<Entity>());
    }
    return entityList;
  }

  public static void RemoveIneligible(
    IList<Entity> list,
    StatusEffectData effectToApply,
    TargetConstraint[] applyConstraints)
  {
    for (int index = list.Count - 1; index >= 0; --index)
    {
      Entity target = list[index];
      if (!effectToApply.CanPlayOn(target))
      {
        list.RemoveAt(index);
      }
      else
      {
        foreach (TargetConstraint applyConstraint in applyConstraints)
        {
          if (!applyConstraint.Check(target))
          {
            list.RemoveAt(index);
            break;
          }
        }
      }
    }
  }

  [Flags]
  public enum Flag
  {
    None = 0,
    Self = 1,
    Hand = 2,
    EnemyHand = 4,
    Allies = 8,
    AlliesInRow = 16, // 0x00000010
    FrontAlly = 32, // 0x00000020
    BackAlly = 64, // 0x00000040
    AllyInFrontOf = 128, // 0x00000080
    AllyBehind = 256, // 0x00000100
    Enemies = 512, // 0x00000200
    EnemiesInRow = 1024, // 0x00000400
    FrontEnemy = 2048, // 0x00000800
    Attacker = 4096, // 0x00001000
    Target = 8192, // 0x00002000
    RandomAlly = 16384, // 0x00004000
    RandomEnemy = 32768, // 0x00008000
    RandomUnit = 65536, // 0x00010000
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Text
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.Localization;

public static class Text
{
  public static global::Text.ColourProfileHex darkProfile = new global::Text.ColourProfileHex("3B262C", "000", "41874AFF", "880033FF", "4B6A9CFF", "4B6A9Caa", "4188baff", "4B6A9Caa", "ffe6");
  public static global::Text.ColourProfileHex lightProfile = new global::Text.ColourProfileHex("FFF", "FFFF99FF", "BBFFCCFF", "FFCCBBFF", "FFFF99FF", "FFFF99aa", "BBFFCCFF", "FFCCBBFF", "ffe6");

  public static string Process(string original) => global::Text.Process(original, 0, 1f, global::Text.lightProfile);

  public static string Process(string original, global::Text.ColourProfileHex profile) => global::Text.Process(original, 0, 1f, profile);

  public static string Process(
    string original,
    int effectBonus,
    float effectFactor,
    global::Text.ColourProfileHex profile)
  {
    string text = original.Trim();
    int length = text.Length;
    for (int index = 0; index < length; ++index)
    {
      if (text[index] == '<')
      {
        string tag = global::Text.FindTag(text, index);
        if (tag.Length > 0)
        {
          text = text.Remove(index, tag.Length + 2);
          string str = global::Text.ProcessTag(text, tag, effectBonus, effectFactor, profile);
          if (str.Length > 0)
          {
            text = text.Insert(index, str);
            index += str.Length;
          }
          length = text.Length;
          --index;
        }
      }
    }
    return text;
  }

  public static string FindTag(string text, int startIndex)
  {
    string tag = "";
    int num = text.IndexOf('>', startIndex) - startIndex;
    if (num > 0)
      tag = text.Substring(startIndex + 1, num - 1);
    return tag;
  }

  public static string ProcessTag(
    string text,
    string tag,
    int effectBonus,
    float effectFactor,
    global::Text.ColourProfileHex profile)
  {
    char c = tag[0];
    bool flag1 = char.IsDigit(c);
    if (tag.Length == 1 && !flag1)
      return "<" + tag + ">";
    string str1 = string.Empty;
    string str2 = (string) null;
    if (c == '+' || c == '-' || c == 'x')
      str2 = c.ToString();
    int result1;
    if ((flag1 || str2 != null) && int.TryParse(Regex.Replace(tag, "[^0-9]+", string.Empty), out result1))
    {
      int num = Mathf.Max(0, Mathf.RoundToInt((float) (result1 + effectBonus) * effectFactor));
      string str3 = "<color=#" + profile.effectColour + ">";
      string str4 = "</color>";
      if (num > result1)
        str3 = "<color=#" + profile.effectBuffedColour + ">";
      else if (num < result1)
        str3 = "<color=#" + profile.effectDebuffedColour + ">";
      str1 = string.Format("<b>{0}{1}{2}{3}</b>", (object) str3, (object) str2, (object) num, (object) str4);
    }
    else
    {
      string[] strArray1 = tag.Split('=', StringSplitOptions.None);
      if (strArray1.Length == 2)
      {
        switch (strArray1[0].Trim())
        {
          case "card":
            string assetName = strArray1[1].Trim();
            CardData cardData = AddressableLoader.Get<CardData>("CardData", assetName);
            if (!(bool) (UnityEngine.Object) cardData)
              Debug.LogError((object) ("Error processing text: " + text + "\nCard [" + assetName + "] does not exist!"));
            str1 = "<#" + profile.keywordColour + ">" + cardData.title + "</color>";
            break;
          case "color":
          case "size":
            str1 = "<" + tag + ">";
            break;
          case "keyword":
            string text1 = strArray1[1].Trim();
            KeywordData keyword = global::Text.ToKeyword(text1);
            bool flag2 = !keyword.iconName.IsNullOrWhitespace();
            if (flag2 && keyword.showIcon && !keyword.showName)
            {
              str1 = "<sprite name=" + keyword.iconName + ">";
              break;
            }
            if (keyword.showName)
            {
              string[] strArray2 = text1.Split(' ', StringSplitOptions.None);
              bool flag3 = strArray2.Length > 2 && strArray2[2] == "silenced";
              string str5 = flag3 ? profile.keywordSilencedColour : profile.keywordColour;
              if (flag2 && keyword.showIcon)
                str1 = str1 + "<sprite name=\"" + keyword.iconName + "\" color=#" + str5 + ">";
              string str6 = str1 + "<color=#" + str5 + ">";
              if (flag3)
                str6 += "<s>";
              string str7;
              if (keyword.canStack && strArray2.Length > 1)
              {
                int result2 = 1;
                int num = 1;
                if (strArray2.Length != 0 && int.TryParse(strArray2[1], out result2))
                  num = Mathf.Max(0, Mathf.RoundToInt((float) (result2 + effectBonus) * effectFactor));
                string str8 = "<color=#" + str5 + ">";
                string str9 = "</color>";
                if (num > result2)
                  str8 = "<color=#" + profile.keywordBuffedColour + ">";
                else if (num < result2)
                  str8 = "<color=#" + profile.keywordDebuffedColour + ">";
                str7 = str6 + string.Format("{0} <b>{1}{2}{3}</b>", (object) keyword.title, (object) str8, (object) num, (object) str9);
              }
              else
                str7 = str6 + keyword.title;
              str1 = str7 + "</color>";
              if (flag3)
              {
                str1 += "</s>";
                break;
              }
              break;
            }
            break;
          case "spr":
          case "sprite":
          case "sprite name":
            str1 = "<sprite name=" + strArray1[1].Trim() + ">";
            break;
        }
      }
    }
    if (str1.IsNullOrWhitespace())
    {
      if (c.Equals('/'))
        str1 = "<" + tag + ">";
      else
        str1 = "<color=#" + profile.effectColour + ">" + tag + "</color>";
    }
    return str1;
  }

  public static KeywordData ToKeyword(string text)
  {
    int startIndex = text.IndexOf(' ');
    if (startIndex > 0)
      text = text.Remove(startIndex, text.Length - startIndex);
    KeywordData keyword = AddressableLoader.Get<KeywordData>("KeywordData", text);
    string message;
    if (!((UnityEngine.Object) keyword != (UnityEngine.Object) null))
      message = "Keyword for \"" + text + "\" = NULL";
    else
      message = "Keyword for \"" + text + "\" = [" + keyword.name + "]";
    Debug.Log((object) message);
    if (!(bool) (UnityEngine.Object) keyword)
      Debug.LogError((object) "Keyword \"text\" not found!");
    return keyword;
  }

  public static HashSet<KeywordData> GetKeywords(string text)
  {
    HashSet<KeywordData> keywords = new HashSet<KeywordData>();
    for (int index = 0; index < text.Length; ++index)
    {
      if (text[index].Equals('<'))
      {
        string tag = global::Text.FindTag(text, index);
        if (tag.Length > 0 && tag.Contains("="))
        {
          string[] strArray = tag.Split('=', StringSplitOptions.None);
          if (strArray.Length == 2 && strArray[0].Trim() == "keyword")
          {
            KeywordData keyword = global::Text.ToKeyword(strArray[1].Trim());
            if (keyword.show)
              keywords.Add(keyword);
          }
        }
      }
    }
    return keywords;
  }

  public static HashSet<CardData> GetMentionedCards(string text)
  {
    HashSet<CardData> mentionedCards = new HashSet<CardData>();
    for (int index = 0; index < text.Length; ++index)
    {
      if (text[index].Equals('<'))
      {
        string tag = global::Text.FindTag(text, index);
        if (tag.Length > 0 && tag.Contains("="))
        {
          string[] strArray = tag.Split('=', StringSplitOptions.None);
          if (strArray.Length == 2 && strArray[0].Trim() == "card")
          {
            CardData cardData = AddressableLoader.Get<CardData>("CardData", strArray[1].Trim());
            mentionedCards.Add(cardData);
          }
        }
      }
    }
    return mentionedCards;
  }

  public static string GetEffectText(
    LocalizedString textKey,
    string textInsert,
    int amount,
    bool silenced = false)
  {
    string str = global::Text.HandleBracketTags(textKey.GetLocalizedString().Replace("{0}", textInsert).Replace("{e}", textInsert).Replace("{a}", amount.ToString()));
    return silenced ? "<s>" + str + "</s>" : str;
  }

  public static string GetEffectText(
    IEnumerable<LocalizedString> textKeys,
    string textInsert,
    int amount,
    bool silenced = false)
  {
    string str1 = "{0}";
    foreach (LocalizedString textKey in textKeys)
      str1 = str1.Replace("{0}", textKey.GetLocalizedString());
    string str2 = global::Text.HandleBracketTags(str1.Replace("{0}", textInsert).Replace("{e}", textInsert).Replace("{a}", amount.ToString()));
    return silenced ? "<s>" + str2 + "</s>" : str2;
  }

  public static string HandleBracketTags(string text)
  {
    while (true)
    {
      int startIndex = text.IndexOf('[');
      if (startIndex >= 0)
      {
        int count = text.IndexOf(']') - startIndex + 1;
        if (count > 0)
        {
          string str = text.Substring(startIndex + 1, count - 2);
          char ch = str.Length <= 1 || startIndex <= 0 ? str[0] : str[1];
          text = text.Remove(startIndex, count);
          text = text.Insert(startIndex, ch.ToString());
        }
        else
          break;
      }
      else
        break;
    }
    return text;
  }

  [Serializable]
  public struct ColourProfileHex
  {
    public string textColour;
    public string effectColour;
    public string effectBuffedColour;
    public string effectDebuffedColour;
    public string keywordColour;
    public string keywordSilencedColour;
    public string keywordBuffedColour;
    public string keywordDebuffedColour;
    public string flavourColour;

    public ColourProfileHex(
      string textColour,
      string effectColour,
      string effectBuffedColour,
      string effectDebuffedColour,
      string keywordColour,
      string keywordSilencedColour,
      string keywordBuffedColour,
      string keywordDebuffedColour,
      string flavourColour)
    {
      this.textColour = textColour;
      this.effectColour = effectColour;
      this.effectBuffedColour = effectBuffedColour;
      this.effectDebuffedColour = effectDebuffedColour;
      this.keywordColour = keywordColour;
      this.keywordSilencedColour = keywordSilencedColour;
      this.keywordBuffedColour = keywordBuffedColour;
      this.keywordDebuffedColour = keywordDebuffedColour;
      this.flavourColour = flavourColour;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TextContainer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class TextContainer : MonoBehaviour
{
  public TextMeshProUGUI textAsset;

  public void SetText(string text) => this.textAsset.text = text;
}
﻿// Decompiled with JetBrains decompiler
// Type: TextFitter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof (TMP_Text))]
public class TextFitter : MonoBehaviourRect
{
  public TMP_Text _textElement;
  [SerializeField]
  public LayoutElement layoutElement;
  [SerializeField]
  public RectTransform[] transforms;
  [SerializeField]
  public bool fitWidth = true;
  [SerializeField]
  [ShowIf("fitWidth")]
  public float minWidth = 3f;
  [SerializeField]
  [ShowIf("fitWidth")]
  public float maxWidth = 5f;
  [SerializeField]
  public bool fitHeight = true;
  [SerializeField]
  [ShowIf("fitHeight")]
  public float minHeight = 1f;
  [SerializeField]
  [ShowIf("fitHeight")]
  public float maxHeight = 1f;

  public TMP_Text textElement => this._textElement ?? (this._textElement = this.GetComponent<TMP_Text>());

  public void SetText(string text)
  {
    this.textElement.text = text;
    this.Fit();
  }

  public void Fit()
  {
    this.StopAllCoroutines();
    if (!this.fitWidth)
      return;
    this.StartCoroutine(this.FitRoutine());
  }

  public IEnumerator FitRoutine()
  {
    TextFitter textFitter = this;
    yield return (object) new WaitForEndOfFrame();
    Vector4 margin = textFitter.textElement.margin;
    Vector3 size = textFitter.textElement.textBounds.size;
    Vector2 sizeDelta = textFitter.rectTransform.sizeDelta;
    float num1 = textFitter.fitWidth ? Mathf.Clamp(size.x + margin.x + margin.z, textFitter.minWidth, textFitter.maxWidth) : sizeDelta.x;
    float num2 = textFitter.fitHeight ? Mathf.Clamp(size.y + margin.y + margin.w, textFitter.minHeight, textFitter.maxHeight) : sizeDelta.y;
    Vector2 vector2 = sizeDelta.With(new float?(num1), new float?(num2));
    textFitter.rectTransform.sizeDelta = vector2;
    if ((bool) (Object) textFitter.layoutElement)
    {
      if (textFitter.fitWidth)
        textFitter.layoutElement.preferredWidth = num1;
      if (textFitter.fitHeight)
        textFitter.layoutElement.preferredHeight = num2;
    }
    foreach (RectTransform transform in textFitter.transforms)
      transform.sizeDelta = vector2;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TextImageData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Text Image Data", fileName = "Text Image Data")]
public class TextImageData : ScriptableObject
{
  [SerializeField]
  public List<char> chars;
  [SerializeField]
  public List<Sprite> sprites;

  public bool TryGetSprite(char value, out Sprite result)
  {
    int index = this.chars.IndexOf(value);
    if (index >= 0)
    {
      result = this.sprites[index];
      return true;
    }
    result = (Sprite) null;
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TextImageDrawer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class TextImageDrawer : TMP_Text
{
  [SerializeField]
  public TextImageData data;
  public Image[] images;
  public Transform _transform;

  public new Transform transform => this._transform ?? (this._transform = this.GetComponent<Transform>());

  public override string text
  {
    get => this.m_text;
    set
    {
      if (!(this.m_text != value))
        return;
      this.m_text = value;
      this.DrawText();
    }
  }

  public override Color color
  {
    get => this.m_fontColor;
    set
    {
      this.m_fontColor = value;
      this.SetColour();
    }
  }

  public override void Awake()
  {
    base.Awake();
    this.DrawText();
  }

  public void DrawText()
  {
    this.Clear();
    this.images = new Image[this.m_text.Length];
    for (int index = 0; index < this.m_text.Length; ++index)
    {
      char ch = this.m_text[index];
      Sprite result;
      if (this.data.TryGetSprite(ch, out result))
      {
        GameObject gameObject = new GameObject(ch.ToString());
        Image image = gameObject.AddComponent<Image>();
        image.sprite = result;
        image.color = this.m_fontColor;
        image.material = this.material;
        image.raycastTarget = this.raycastTarget;
        image.maskable = this.maskable;
        image.preserveAspect = true;
        this.images[index] = image;
        Transform transform = gameObject.transform;
        if (transform != null)
        {
          transform.SetParent(this.transform);
          transform.localScale = Vector3.one;
          transform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
        }
      }
    }
  }

  public void SetColour()
  {
    foreach (Graphic image in this.images)
      image.color = this.m_fontColor;
  }

  public void Clear()
  {
    Image[] images = this.images;
    if (images == null || images.Length <= 0)
      return;
    foreach (Image image in this.images)
    {
      if ((bool) (Object) image && (bool) (Object) image.gameObject)
        Object.Destroy((Object) image.gameObject);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TextMeshFitter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using TMPro;
using UnityEngine;

[RequireComponent(typeof (TMP_Text))]
public class TextMeshFitter : MonoBehaviour
{
  public TMP_Text _textElement;
  public RectTransform _rectTransform;
  [SerializeField]
  public SpriteRenderer parentSprite;
  [SerializeField]
  public bool autoUpdate = true;
  [SerializeField]
  public Vector2 minSize;
  public bool dirty = true;

  public string text
  {
    get => this.textElement.text;
    set
    {
      this.textElement.text = value;
      this.dirty = true;
    }
  }

  public TMP_Text textElement => this._textElement ?? (this._textElement = this.GetComponent<TMP_Text>());

  public RectTransform rectTransform => this._rectTransform ?? (this._rectTransform = this.transform as RectTransform);

  public void Update()
  {
    if (!this.dirty && (!this.autoUpdate || !this.textElement.havePropertiesChanged))
      return;
    this.Run();
    this.dirty = false;
  }

  public void Run()
  {
    TMP_LineInfo[] lineInfo = this.textElement.textInfo.lineInfo;
    float a = 0.0f;
    float num = 0.0f;
    foreach (TMP_LineInfo tmpLineInfo in lineInfo)
    {
      if (tmpLineInfo.characterCount > 0)
      {
        a = Mathf.Max(a, tmpLineInfo.length);
        num += tmpLineInfo.lineHeight;
      }
    }
    Vector4 margin = this.textElement.margin;
    float b1 = a + (margin.x + margin.z);
    float b2 = num + (margin.y + margin.w);
    float x = Mathf.Max(this.minSize.x, b1);
    float y = Mathf.Max(this.minSize.y, b2);
    if ((Object) this.parentSprite != (Object) null)
    {
      Vector3 localScale = this.rectTransform.localScale;
      this.parentSprite.size = new Vector2(x * localScale.x, y * localScale.y);
    }
    this.rectTransform.sizeDelta = new Vector2(x, y);
  }

  [Button("Force Update", EButtonEnableMode.Always)]
  public void ForceUpdate() => this.Run();
}
﻿// Decompiled with JetBrains decompiler
// Type: TextProcessor
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;

public class TextProcessor : MonoBehaviour
{
  [SerializeField]
  public TMP_Text textElement;

  public void SetText(string input) => this.textElement.text = Text.Process(input);
}
﻿// Decompiled with JetBrains decompiler
// Type: TextSwitcher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using TMPro;
using UnityEngine;

[RequireComponent(typeof (TextMeshProUGUI))]
public class TextSwitcher : MonoBehaviour
{
  public bool useExistingTextAsFirst = true;
  public float switchTime = 1f;
  public List<string> texts;
  public int i;
  public float t;
  public TextMeshProUGUI tmp;

  public void Awake()
  {
    this.tmp = this.GetComponent<TextMeshProUGUI>();
    if (this.useExistingTextAsFirst)
      this.texts.Insert(0, this.tmp.text);
    this.t = this.switchTime;
  }

  public void Update()
  {
    for (this.t -= Time.deltaTime; (double) this.t <= 0.0; this.t += this.switchTime)
    {
      this.i = (this.i + 1) % this.texts.Count;
      this.tmp.text = this.texts[this.i];
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TextTypewrite
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;

public class TextTypewrite : MonoBehaviour
{
  [SerializeField]
  public TMP_Text textElement;
  public const float startDelay = 0.25f;
  public const float defaultPause = 0.05f;
  public static readonly Dictionary<char, float> lookup = new Dictionary<char, float>()
  {
    {
      ' ',
      0.005f
    },
    {
      ',',
      0.4f
    },
    {
      '，',
      0.4f
    },
    {
      '.',
      0.15f
    },
    {
      '…',
      0.4f
    }
  };

  public IEnumerator Write()
  {
    this.textElement.maxVisibleCharacters = 0;
    yield return (object) new WaitForSeconds(0.25f);
    int total = this.textElement.textInfo.characterCount;
    for (int i = 0; i < total; ++i)
    {
      this.textElement.maxVisibleCharacters = i + 1;
      char character = this.textElement.textInfo.characterInfo[i].character;
      yield return (object) new WaitForSeconds(TextTypewrite.lookup.ContainsKey(character) ? TextTypewrite.lookup[character] : 0.05f);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TiledImageMover
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class TiledImageMover : MonoBehaviourCacheTransform
{
  [SerializeField]
  public float moveX = 1f;
  [SerializeField]
  public float resetPosX = 0.5f;

  public void Update()
  {
    Vector3 localPosition = this.transform.localPosition;
    float num = localPosition.x + this.moveX * Time.deltaTime;
    if ((double) num >= (double) this.resetPosX)
      num -= this.resetPosX * 2f;
    else if ((double) num <= -(double) this.resetPosX)
      num += this.resetPosX * 2f;
    this.transform.localPosition = localPosition.WithX(num);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TimeScaleSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class TimeScaleSystem : GameSystem
{
  public void OnEnable() => global::Events.OnTimeScaleChange += new UnityAction<float>(this.TimeScaleSet);

  public void OnDisable() => global::Events.OnTimeScaleChange -= new UnityAction<float>(this.TimeScaleSet);

  public void TimeScaleSet(float value) => Time.timeScale = value;
}
﻿// Decompiled with JetBrains decompiler
// Type: TitleSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Components;
using UnityEngine.UI;

public class TitleSetter : MonoBehaviour
{
  [SerializeField]
  public GameObject gameObject;
  [SerializeField]
  public LocalizeStringEvent text;
  [SerializeField]
  public Image underline;
  [SerializeField]
  public bool setActive = true;
  [SerializeField]
  [ShowIf("setActive")]
  public LocalizedString setKey;
  [SerializeField]
  [ShowIf("setActive")]
  public Sprite setUnderlineSprite;

  public void Set()
  {
    this.gameObject.SetActive(this.setActive);
    if (!this.setActive)
      return;
    this.text.StringReference = this.setKey;
    this.underline.sprite = this.setUnderlineSprite;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ToggleBasedOnCardController
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class ToggleBasedOnCardController : MonoBehaviour
{
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public MonoBehaviour[] components;
  [SerializeField]
  public UnityEvent onEnable;
  [SerializeField]
  public UnityEvent onDisable;

  public void AssignCardController(CardController controller)
  {
    this.cardController = controller;
    if (controller.enabled)
      this.Enable();
    else
      this.Disable();
  }

  public void OnEnable()
  {
    global::Events.OnCardControllerEnabled += new UnityAction<CardController>(this.CardControllerEnabled);
    global::Events.OnCardControllerDisabled += new UnityAction<CardController>(this.CardControllerDisabled);
  }

  public void OnDisable()
  {
    global::Events.OnCardControllerEnabled -= new UnityAction<CardController>(this.CardControllerEnabled);
    global::Events.OnCardControllerDisabled -= new UnityAction<CardController>(this.CardControllerDisabled);
  }

  public void CardControllerEnabled(CardController controller)
  {
    if (!((Object) controller == (Object) this.cardController))
      return;
    this.Enable();
  }

  public void CardControllerDisabled(CardController controller)
  {
    if (!((Object) controller == (Object) this.cardController))
      return;
    this.Disable();
  }

  public void Enable()
  {
    foreach (Behaviour component in this.components)
      component.enabled = true;
    this.onEnable?.Invoke();
  }

  public void Disable()
  {
    foreach (Behaviour component in this.components)
      component.enabled = false;
    this.onDisable?.Invoke();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: ToggleSprite
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class ToggleSprite : MonoBehaviour
{
  [SerializeField]
  public Image image;
  [SerializeField]
  public Sprite onSprite;
  [SerializeField]
  public Sprite offSprite;

  public void Set(bool value) => this.image.sprite = value ? this.onSprite : this.offSprite;
}
﻿// Decompiled with JetBrains decompiler
// Type: TokenRewardSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class TokenRewardSequence : UISequence
{
  [SerializeField]
  public CanvasGroup canvasGroup;
  [SerializeField]
  public RectTransform titleTransform;
  [SerializeField]
  public Vector3 titleToPosition;
  [SerializeField]
  public TweenUI revealTween;
  [SerializeField]
  public TweenUI hideTween;
  [SerializeField]
  public CardContainer cardHolder;
  [SerializeField]
  public Button skipButton;
  [SerializeField]
  public int goldGainFromSkip = 10;
  [SerializeField]
  public CardController cardController;
  [SerializeField]
  public CardCharmDragHandler tokenDragHandler;
  [SerializeField]
  public RectTransform tokenSlotGroup;
  [SerializeField]
  public CardCharmHolder tokenSlotPrefab;
  [SerializeField]
  public CardUpgradeData[] tokenData;
  public List<TokenRewardSequence.Target> targets;

  public override IEnumerator Run()
  {
    TokenRewardSequence tokenRewardSequence1 = this;
    Character player = References.Player;
    List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(player);
    if (tokenRewardSequence1.targets == null)
      tokenRewardSequence1.targets = new List<TokenRewardSequence.Target>();
    foreach (Entity entity in cardsOnBoard)
    {
      if (entity.data?.cardType?.name == "Friendly")
        tokenRewardSequence1.targets.Add(new TokenRewardSequence.Target(entity, tokenRewardSequence1.cardController));
    }
    Debug.Log((object) string.Format("{0} Targets: [{1}]", (object) tokenRewardSequence1, (object) string.Join<TokenRewardSequence.Target>(", ", (IEnumerable<TokenRewardSequence.Target>) tokenRewardSequence1.targets)));
    if (tokenRewardSequence1.targets.Count > 0)
    {
      tokenRewardSequence1.cardController.owner = player;
      LeanTween.moveLocal(tokenRewardSequence1.titleTransform.gameObject, tokenRewardSequence1.titleToPosition, 0.75f).setEase(LeanTweenType.easeOutBack);
      yield return (object) Sequences.Wait(0.33f);
      tokenRewardSequence1.gameObject.SetActive(true);
      tokenRewardSequence1.revealTween.Fire();
      tokenRewardSequence1.tokenDragHandler.gameObject.SetActive(true);
      foreach (CardUpgradeData cardUpgradeData in tokenRewardSequence1.tokenData)
      {
        TokenRewardSequence tokenRewardSequence = tokenRewardSequence1;
        CardCharmHolder cardCharmHolder = UnityEngine.Object.Instantiate<CardCharmHolder>(tokenRewardSequence1.tokenSlotPrefab, (Transform) tokenRewardSequence1.tokenSlotGroup);
        cardCharmHolder.gameObject.SetActive(true);
        CardUpgradeData upgradeData = cardUpgradeData.Clone();
        UpgradeDisplay token = cardCharmHolder.Create(upgradeData);
        CardCharmInteraction component = token.GetComponent<CardCharmInteraction>();
        component.canHover = true;
        component.canDrag = true;
        component.onDrag.AddListener((UnityAction<UpgradeDisplay>) (a => tokenRewardSequence.tokenDragHandler.Drag(token)));
      }
      tokenRewardSequence1.cardHolder.gameObject.SetActive(true);
      tokenRewardSequence1.cardHolder.SetSize(tokenRewardSequence1.targets.Count, tokenRewardSequence1.cardHolder.CardScale);
      foreach (TokenRewardSequence.Target target in tokenRewardSequence1.targets)
      {
        target.MoveTo(tokenRewardSequence1.cardHolder);
        target.entity.wobbler?.WobbleRandom();
        tokenRewardSequence1.cardHolder.TweenChildPositions();
        target.entity.DrawOrder = 0;
        yield return (object) Sequences.Wait(0.2f);
      }
      yield return (object) Sequences.Wait(0.15f);
      int i;
      for (i = tokenRewardSequence1.targets.Count - 1; i >= 0; --i)
      {
        TokenRewardSequence.Target target = tokenRewardSequence1.targets[i];
        double num = (double) target.entity.curveAnimator.Ping();
        CoroutineManager.Start(target.entity.Reset());
        yield return (object) Sequences.Wait(0.2f);
      }
      tokenRewardSequence1.skipButton.gameObject.SetActive(true);
      yield return (object) new WaitUntil(new Func<bool>(tokenRewardSequence1.\u003CRun\u003Eb__14_0));
      tokenRewardSequence1.skipButton.gameObject.SetActive(false);
      for (i = tokenRewardSequence1.targets.Count - 1; i >= 0; --i)
      {
        tokenRewardSequence1.targets[i].Return();
        yield return (object) Sequences.Wait(0.167f);
      }
      tokenRewardSequence1.targets = (List<TokenRewardSequence.Target>) null;
      tokenRewardSequence1.cardHolder.gameObject.SetActive(false);
      tokenRewardSequence1.tokenDragHandler.gameObject.SetActive(false);
      tokenRewardSequence1.hideTween.Fire();
      yield return (object) Sequences.Wait(tokenRewardSequence1.hideTween.GetDuration());
      tokenRewardSequence1.gameObject.SetActive(false);
    }
  }

  public void TokenAssigned() => this.StartCoroutine(this.TokenAssignedRoutine());

  public IEnumerator TokenAssignedRoutine()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    TokenRewardSequence tokenRewardSequence = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      tokenRewardSequence.End();
      tokenRewardSequence.skipButton.interactable = false;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) Sequences.Wait(0.1f);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public void Skip()
  {
    References.Player.GainGold(this.goldGainFromSkip);
    this.End();
    this.skipButton.interactable = false;
  }

  [CompilerGenerated]
  public bool \u003CRun\u003Eb__14_0() => this.promptEnd;

  public class Target
  {
    public Entity entity;
    public CardContainer[] previousActualContainers;
    public CardController previousController;

    public Target(Entity entity, CardController controller)
    {
      this.entity = entity;
      this.previousActualContainers = new CardContainer[1]
      {
        entity.owner.drawContainer
      };
      Card component = entity.GetComponent<Card>();
      this.previousController = component.hover.controller;
      component.hover.controller = controller;
    }

    public void MoveTo(params CardContainer[] containers)
    {
      this.entity.RemoveFromContainers();
      foreach (CardContainer container in containers)
        container.Add(this.entity);
    }

    public void Return()
    {
      this.MoveTo(this.previousActualContainers);
      foreach (CardContainer previousActualContainer in this.previousActualContainers)
        previousActualContainer.TweenChildPositions();
      this.entity.GetComponent<Card>().hover.controller = this.previousController;
    }

    public override string ToString() => !((UnityEngine.Object) this.entity == (UnityEngine.Object) null) ? this.entity.name : "NULL";
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Tooltip
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public abstract class Tooltip : MonoBehaviour
{
  public bool animate = true;
  public bool ignoreTimeScale;
  public readonly HashSet<Tooltip> children = new HashSet<Tooltip>();
  [SerializeField]
  public CanvasGroup canvasGroup;
  [Header("Panel")]
  [SerializeField]
  public Image panel;
  [SerializeField]
  public Sprite defaultPanelSprite;
  [SerializeField]
  public Color defaultPanelColor;
  [Header("Animation")]
  [SerializeField]
  public Vector3 scaleFrom = Vector3.zero;
  [SerializeField]
  public AnimationCurve scaleCurve;
  [SerializeField]
  public float scaleDur = 0.5f;
  [SerializeField]
  public float fadeFrom;
  [SerializeField]
  public AnimationCurve fadeCurve;
  [SerializeField]
  public float fadeDur = 0.2f;

  public void Ping()
  {
    if (!this.animate)
      return;
    LeanTween.cancel(this.gameObject);
    this.transform.localScale = this.scaleFrom;
    LeanTween.scale(this.gameObject, Vector3.one, this.scaleDur).setEase(this.scaleCurve).setIgnoreTimeScale(this.ignoreTimeScale);
    this.canvasGroup.alpha = this.fadeFrom;
    this.canvasGroup.LeanAlpha(1f, this.fadeDur).setEase(this.fadeCurve).setIgnoreTimeScale(this.ignoreTimeScale);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TouchHandler
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.EventSystems;

public class TouchHandler : MonoBehaviour
{
  [SerializeField]
  public bool hoverBeforePress = true;

  public bool CanTouchPress(bool alreadyHovered) => !this.hoverBeforePress | alreadyHovered;

  public void HandleTouchPress(PointerEventData pointer, bool alreadyHovered)
  {
    pointer.pressPosition = pointer.position;
    pointer.pointerPressRaycast = pointer.pointerCurrentRaycast;
    ExecuteEvents.ExecuteHierarchy<IPointerDownHandler>(this.gameObject, (BaseEventData) pointer, ExecuteEvents.pointerDownHandler);
    pointer.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(this.gameObject);
    if (!(bool) (Object) pointer.pointerDrag)
      return;
    ExecuteEvents.Execute<IInitializePotentialDragHandler>(pointer.pointerDrag, (BaseEventData) pointer, ExecuteEvents.initializePotentialDrag);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TouchInputModule
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class TouchInputModule : BaseInputModule
{
  [SerializeField]
  public BaseInput input;
  [CompilerGenerated]
  public Vector2 \u003CMousePosition\u003Ek__BackingField;
  [CompilerGenerated]
  public Vector2 \u003CLastMousePosition\u003Ek__BackingField;
  [CompilerGenerated]
  public Vector2 \u003CMouseMove\u003Ek__BackingField;
  [CompilerGenerated]
  public GameObject \u003CHover\u003Ek__BackingField;
  [CompilerGenerated]
  public GameObject \u003CPress\u003Ek__BackingField;
  [CompilerGenerated]
  public static float \u003CScrollX\u003Ek__BackingField;
  [CompilerGenerated]
  public static float \u003CScrollY\u003Ek__BackingField;
  public PointerEventData pointer;
  public static bool touching;
  public static bool active;
  public static int blockScroll;
  public static readonly Vector2 offscreen = new Vector2(-1000f, -1000f);

  public Vector2 MousePosition
  {
    get => this.\u003CMousePosition\u003Ek__BackingField;
    set => this.\u003CMousePosition\u003Ek__BackingField = value;
  }

  public Vector2 LastMousePosition
  {
    get => this.\u003CLastMousePosition\u003Ek__BackingField;
    set => this.\u003CLastMousePosition\u003Ek__BackingField = value;
  }

  public Vector2 MouseMove
  {
    get => this.\u003CMouseMove\u003Ek__BackingField;
    set => this.\u003CMouseMove\u003Ek__BackingField = value;
  }

  public GameObject Hover
  {
    get => this.\u003CHover\u003Ek__BackingField;
    set => this.\u003CHover\u003Ek__BackingField = value;
  }

  public GameObject Press
  {
    get => this.\u003CPress\u003Ek__BackingField;
    set => this.\u003CPress\u003Ek__BackingField = value;
  }

  public static float ScrollX
  {
    get => TouchInputModule.\u003CScrollX\u003Ek__BackingField;
    set => TouchInputModule.\u003CScrollX\u003Ek__BackingField = value;
  }

  public static float ScrollY
  {
    get => TouchInputModule.\u003CScrollY\u003Ek__BackingField;
    set => TouchInputModule.\u003CScrollY\u003Ek__BackingField = value;
  }

  public override void OnEnable()
  {
    base.OnEnable();
    TouchInputModule.active = true;
    this.pointer = new PointerEventData(this.eventSystem);
    global::Events.OnUpdateInputSystem += new UnityAction<bool>(this.ForceUpdate);
    global::Events.OnCardControllerEnabled += new UnityAction<CardController>(this.CardControllerEnabled);
  }

  public override void OnDisable()
  {
    base.OnDisable();
    TouchInputModule.active = false;
    global::Events.OnUpdateInputSystem -= new UnityAction<bool>(this.ForceUpdate);
    global::Events.OnCardControllerEnabled -= new UnityAction<CardController>(this.CardControllerEnabled);
    TouchInputModule.touching = false;
    TouchInputModule.ScrollX = 0.0f;
    TouchInputModule.ScrollY = 0.0f;
  }

  public static void BlockScroll() => ++TouchInputModule.blockScroll;

  public static void UnblockScroll() => --TouchInputModule.blockScroll;

  public override void Process()
  {
    Touch? touch = this.GetTouch();
    if (touch.HasValue)
    {
      this.ProcessTouch(touch.GetValueOrDefault());
      TouchInputModule.touching = true;
      if (TouchInputModule.blockScroll <= 0)
        return;
      TouchInputModule.ScrollX = 0.0f;
      TouchInputModule.ScrollY = 0.0f;
    }
    else
    {
      TouchInputModule.touching = false;
      TouchInputModule.ScrollX = 0.0f;
      TouchInputModule.ScrollY = 0.0f;
    }
  }

  public void ForceUpdate(bool forceTouch)
  {
    if (forceTouch)
    {
      Touch touch = new Touch()
      {
        position = this.MousePosition,
        deltaTime = Time.deltaTime,
        phase = TouchPhase.Stationary
      };
      GameObject hover = this.Hover;
      this.PopulateTouchPointerData(touch, out bool _, out bool _);
      this.Hover = this.pointer.pointerCurrentRaycast.gameObject;
      this.ProcessTouchMove(hover, this.Hover);
    }
    else
      this.Process();
  }

  public override void UpdateModule() => this.Process();

  public void CardControllerEnabled(CardController controller) => this.ProcessTouch(this.GetSimulatedTouch(TouchInputModule.offscreen, false, false));

  public Touch? GetTouch()
  {
    if (this.input.touchCount <= 0)
      return new Touch?();
    Touch touch = this.input.GetTouch(0);
    this.LastMousePosition = this.MousePosition;
    this.MousePosition = touch.position;
    this.MouseMove = touch.deltaPosition;
    return new Touch?(touch);
  }

  public Touch GetSimulatedTouch(Vector2 position, bool pressed, bool released)
  {
    this.LastMousePosition = this.MousePosition;
    this.MousePosition = position;
    this.MouseMove = this.MousePosition - this.LastMousePosition;
    Touch simulatedTouch = new Touch()
    {
      position = this.MousePosition,
      rawPosition = this.MousePosition,
      deltaPosition = this.MouseMove,
      phase = TouchPhase.Stationary,
      pressure = 1f,
      maximumPossiblePressure = 1f,
      type = TouchType.Direct,
      tapCount = 1
    };
    if (pressed)
      simulatedTouch.phase = TouchPhase.Began;
    else if (released)
      simulatedTouch.phase = TouchPhase.Ended;
    else if ((double) simulatedTouch.deltaPosition.sqrMagnitude > 0.0)
      simulatedTouch.phase = TouchPhase.Moved;
    return simulatedTouch;
  }

  public void PopulateTouchPointerData(Touch touch, out bool pressed, out bool released)
  {
    this.pointer.Reset();
    pressed = !TouchInputModule.touching;
    ref bool local = ref released;
    TouchPhase phase = touch.phase;
    int num = (phase == TouchPhase.Canceled ? 0 : (phase != TouchPhase.Ended ? 1 : 0)) == 0 ? 1 : 0;
    local = num != 0;
    this.pointer.position = touch.position;
    this.pointer.delta = pressed ? Vector2.zero : touch.deltaPosition;
    this.pointer.button = PointerEventData.InputButton.Left;
    if (touch.phase == TouchPhase.Canceled)
    {
      this.pointer.pointerCurrentRaycast = new RaycastResult();
    }
    else
    {
      this.eventSystem.RaycastAll(this.pointer, this.m_RaycastResultCache);
      this.pointer.pointerCurrentRaycast = TouchInputModule.FindFirstRaycast(this.m_RaycastResultCache);
      this.m_RaycastResultCache.Clear();
    }
  }

  public void ProcessTouch(Touch touch)
  {
    GameObject hover = this.Hover;
    bool pressed;
    bool released;
    this.PopulateTouchPointerData(touch, out pressed, out released);
    this.Hover = this.pointer.pointerCurrentRaycast.gameObject;
    this.ProcessTouchMove(hover, this.Hover);
    if (!pressed && !released)
    {
      TouchInputModule.ScrollX = touch.deltaPosition.x;
      TouchInputModule.ScrollY = touch.deltaPosition.y;
    }
    else
    {
      TouchInputModule.ScrollX = 0.0f;
      TouchInputModule.ScrollY = 0.0f;
    }
    if (released)
      this.ProcessTouchRelease();
    else if (pressed)
      this.ProcessTouchPress(hover);
    if (released || !(bool) (Object) this.pointer.pointerDrag)
      return;
    this.ProcessTouchDrag();
  }

  public void ProcessTouchPress(GameObject preHover)
  {
    if (!(bool) (Object) this.Hover)
      return;
    TouchHandler component = this.Hover.GetComponent<TouchHandler>();
    bool alreadyHovered = (Object) preHover == (Object) this.Hover;
    if ((bool) (Object) component)
    {
      if (!component.CanTouchPress(alreadyHovered))
        return;
      this.Press = this.Hover;
      component.HandleTouchPress(this.pointer, alreadyHovered);
    }
    else
    {
      this.pointer.pressPosition = this.pointer.position;
      this.pointer.pointerPressRaycast = this.pointer.pointerCurrentRaycast;
      this.Press = this.Hover;
      ExecuteEvents.ExecuteHierarchy<IPointerDownHandler>(this.Press, (BaseEventData) this.pointer, ExecuteEvents.pointerDownHandler);
      this.pointer.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(this.Hover);
      if (!(bool) (Object) this.pointer.pointerDrag)
        return;
      ExecuteEvents.Execute<IInitializePotentialDragHandler>(this.pointer.pointerDrag, (BaseEventData) this.pointer, ExecuteEvents.initializePotentialDrag);
    }
  }

  public void ProcessTouchRelease()
  {
    if (!(bool) (Object) this.Press)
      return;
    ExecuteEvents.ExecuteHierarchy<IPointerUpHandler>(this.Press, (BaseEventData) this.pointer, ExecuteEvents.pointerUpHandler);
    if ((Object) this.Hover == (Object) this.Press)
      ExecuteEvents.ExecuteHierarchy<IPointerClickHandler>(this.Press, (BaseEventData) this.pointer, ExecuteEvents.pointerClickHandler);
    if ((bool) (Object) this.pointer.pointerDrag && this.pointer.dragging)
    {
      ExecuteEvents.ExecuteHierarchy<IDropHandler>(this.Hover, (BaseEventData) this.pointer, ExecuteEvents.dropHandler);
      ExecuteEvents.ExecuteHierarchy<IEndDragHandler>(this.pointer.pointerDrag, (BaseEventData) this.pointer, ExecuteEvents.endDragHandler);
      this.pointer.dragging = false;
    }
    this.Press = (GameObject) null;
  }

  public void ProcessTouchMove(GameObject preHover, GameObject hover)
  {
    if (!((Object) preHover != (Object) hover))
      return;
    int num = (bool) (Object) preHover ? 1 : 0;
    if (num != 0)
      ExecuteEvents.ExecuteHierarchy<IPointerExitHandler>(preHover, (BaseEventData) this.pointer, ExecuteEvents.pointerExitHandler);
    if ((bool) (Object) hover)
      ExecuteEvents.ExecuteHierarchy<IPointerEnterHandler>(hover, (BaseEventData) this.pointer, ExecuteEvents.pointerEnterHandler);
    if (num == 0)
      return;
    preHover.GetComponent<IPointerAfterExitHandler>()?.OnPointerAfterExit(this.pointer);
  }

  public void ProcessTouchDrag()
  {
    if (!this.pointer.IsPointerMoving())
      return;
    if (!this.pointer.dragging && TouchInputModule.ShouldStartDrag(this.pointer.pressPosition, this.pointer.position, (float) this.eventSystem.pixelDragThreshold, this.pointer.useDragThreshold))
    {
      ExecuteEvents.Execute<IBeginDragHandler>(this.pointer.pointerDrag, (BaseEventData) this.pointer, ExecuteEvents.beginDragHandler);
      this.pointer.dragging = true;
    }
    if (!this.pointer.dragging)
      return;
    ExecuteEvents.Execute<IDragHandler>(this.pointer.pointerDrag, (BaseEventData) this.pointer, ExecuteEvents.dragHandler);
  }

  public static bool ShouldStartDrag(
    Vector2 pressPos,
    Vector2 currentPos,
    float threshold,
    bool useDragThreshold)
  {
    return !useDragThreshold || (double) (pressPos - currentPos).sqrMagnitude >= (double) threshold * (double) threshold;
  }

  public new static RaycastResult FindFirstRaycast(List<RaycastResult> candidates)
  {
    foreach (RaycastResult candidate in candidates)
    {
      if ((bool) (Object) candidate.gameObject)
        return candidate;
    }
    return new RaycastResult();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TouchInputSwitcher
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class TouchInputSwitcher : BaseInputSwitcher
{
  public override bool CheckSwitchTo() => this.canSwitchTo && Input.touchCount > 0;

  public override void SwitchTo()
  {
    this.gameObject.SetActive(true);
    MonoBehaviourSingleton<Cursor3d>.instance.usingMouse = true;
    MonoBehaviourSingleton<Cursor3d>.instance.usingTouch = true;
    VirtualPointer.Hide();
    CustomCursor.UpdateState();
    MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem((UINavigationItem) null);
    ControllerButtonSystem.SetTouchStyle();
    InputSystem.mainPlayer.controllers.Mouse.enabled = true;
    InputSystem.AllowDynamicSelectRelease = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TouchScroller
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class TouchScroller : MonoBehaviour
{
  [SerializeField]
  public Scroller scroller;
  [SerializeField]
  public bool horizontal;
  [SerializeField]
  public bool vertical = true;
  [SerializeField]
  public float sensitivity = 0.0215f;
  [SerializeField]
  public float inertia = 0.15f;
  public float vx;
  public float vy;
  public const float threshold = 0.01f;

  public void Update()
  {
    if (!TouchInputModule.active || !this.horizontal && !this.vertical || !this.scroller.interactable || !this.scroller.CheckNavigationLayer() || (double) this.scroller.DeltaTime <= 0.0)
    {
      this.vx = 0.0f;
      this.vy = 0.0f;
    }
    else
    {
      Vector2 anchoredPosition = this.scroller.rectTransform.anchoredPosition;
      bool flag = false;
      if (this.horizontal)
      {
        float f = this.scroller.interactable ? TouchInputModule.ScrollX * this.sensitivity : 0.0f;
        if (TouchInputModule.touching)
        {
          if ((double) Mathf.Abs(f) > 0.0099999997764825821)
          {
            anchoredPosition.x += f;
            this.vx = f;
            flag = true;
          }
        }
        else if ((double) Mathf.Abs(this.vx) > 0.0099999997764825821)
        {
          anchoredPosition.x += this.vx;
          flag = true;
        }
      }
      if (this.vertical)
      {
        float f = this.scroller.interactable ? TouchInputModule.ScrollY * this.sensitivity : 0.0f;
        if (TouchInputModule.touching)
        {
          if ((double) Mathf.Abs(f) > 0.0099999997764825821)
          {
            anchoredPosition.y += f;
            this.vy = f;
            flag = true;
          }
        }
        else if ((double) Mathf.Abs(this.vy) > 0.0099999997764825821)
        {
          anchoredPosition.y += this.vy;
          flag = true;
        }
      }
      if (flag)
      {
        this.scroller.ScrollTo(anchoredPosition);
        this.scroller.CheckBounds();
        this.scroller.rectTransform.anchoredPosition = this.scroller.targetPos;
      }
      if (this.horizontal)
        this.vx = Delta.Lerp(this.vx, 0.0f, this.inertia, this.scroller.DeltaTime);
      if (!this.vertical)
        return;
      this.vy = Delta.Lerp(this.vy, 0.0f, this.inertia, this.scroller.DeltaTime);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Town
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Town : MonoBehaviourSingleton<Town>
{
  [SerializeField]
  public HelpPanelShower tutorialPrompt;
  [SerializeField]
  public EventReference denySfxEvent;

  public override void Awake()
  {
    base.Awake();
    Town.CheckStartConstruction();
  }

  public IEnumerator Start()
  {
    foreach (Building building in Object.FindObjectsOfType<Building>(true))
      building.CheckIfUnlocked();
    if ((bool) (Object) CardFramesSystem.instance && CardFramesSystem.instance.AnyNewFrames())
      yield return (object) CardFramesSystem.instance.DisplayNewFrames();
    if (NewFinalBossChecker.Check())
      yield return (object) NewFinalBossChecker.Run();
    if (MetaprogressionSystem.AnyUnlocksReady())
    {
      yield return (object) SceneManager.Load("TownUnlocks", SceneType.Temporary);
      yield return (object) SceneManager.WaitUntilUnloaded("TownUnlocks");
    }
    this.CheckTutorialPrompt();
  }

  public static void SelectBuilding(Building building)
  {
    if (building.built)
    {
      if (building.Select())
        return;
      Events.InvokeCameraAnimation("Shake");
      SfxSystem.OneShot(MonoBehaviourSingleton<Town>.instance.denySfxEvent);
    }
    else
    {
      Events.InvokeCameraAnimation("Shake");
      SfxSystem.OneShot(MonoBehaviourSingleton<Town>.instance.denySfxEvent);
    }
  }

  public static void CheckStartConstruction()
  {
    List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
    List<string> stringList = MetaprogressionSystem.Get<List<string>>("buildings");
    List<UnlockData> list = new List<UnlockData>();
    foreach (string assetName in stringList)
    {
      if (!unlockedList.Contains(assetName))
      {
        UnlockData unlockData = AddressableLoader.Get<UnlockData>("UnlockData", assetName);
        list.AddIfNotNull<UnlockData>(unlockData);
      }
    }
    UnlockData unlockData1 = (UnlockData) null;
    foreach (UnlockData unlock in list)
    {
      if (unlock.IsActive && MetaprogressionSystem.CheckUnlockRequirements(unlock, (ICollection<string>) unlockedList))
      {
        unlockData1 = unlock;
        break;
      }
    }
    if (!(bool) (Object) unlockData1)
      return;
    unlockedList.Add(unlockData1.name);
    SaveSystem.SaveProgressData<List<string>>("unlocked", unlockedList);
    MetaprogressionSystem.SetUnlocksReady(unlockData1.name);
  }

  public void CheckTutorialPrompt()
  {
    if (SaveSystem.LoadProgressData<bool>("tutorialTownDone", false))
      return;
    this.tutorialPrompt.Show();
    SaveSystem.SaveProgressData<bool>("tutorialTownDone", true);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TownHallFlagSetter
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof (Building))]
public class TownHallFlagSetter : MonoBehaviour
{
  [SerializeField]
  public GameObject[] flags;

  public void SetupFlags()
  {
    GameMode gameMode = AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal");
    List<ClassData> lockedClasses = MetaprogressionSystem.GetLockedClasses();
    for (int index = 0; index < gameMode.classes.Length; ++index)
    {
      ClassData classData = gameMode.classes[index];
      bool flag = !lockedClasses.Contains(classData);
      if (this.flags.Length > index)
        this.flags[index].SetActive(flag);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TownUnlockSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

public class TownUnlockSequence : MonoBehaviour
{
  [SerializeField]
  public GainUnlockSequence unlockSequence;
  [SerializeField]
  public Fader fader;
  [SerializeField]
  public float pauseBeforeUnlock = 0.1f;
  [SerializeField]
  public float pauseAfterUnlock = 0.1f;
  public const float fadeOutDur = 0.1f;

  public IEnumerator Start()
  {
    TownUnlockSequence townUnlockSequence = this;
    yield return (object) AddressableLoader.LoadGroup("UnlockData");
    List<UnlockData> unlocks = AddressableLoader.GetGroup<UnlockData>("UnlockData");
    List<string> unlocksToGain = SaveSystem.LoadProgressData<List<string>>("townNew", new List<string>());
    foreach (string str in unlocksToGain)
    {
      string unlockName = str;
      UnlockData unlockData = unlocks.FirstOrDefault<UnlockData>((Func<UnlockData, bool>) (a => a.name == unlockName));
      if ((UnityEngine.Object) unlockData != (UnityEngine.Object) null)
      {
        yield return (object) new WaitForSeconds(townUnlockSequence.pauseBeforeUnlock);
        Events.InvokeTownUnlock(unlockData);
        townUnlockSequence.unlockSequence.SetUp(unlockData);
        yield return (object) new WaitUntil(new Func<bool>(townUnlockSequence.\u003CStart\u003Eb__5_1));
        yield return (object) new WaitForSeconds(townUnlockSequence.pauseAfterUnlock);
      }
      unlockData = (UnlockData) null;
    }
    unlocksToGain.Clear();
    SaveSystem.SaveProgressData<List<string>>("townNew", unlocksToGain);
    townUnlockSequence.fader.Out(0.1f, LeanTweenType.linear);
    yield return (object) new WaitForSeconds(0.1f);
    Routine routine = new Routine(SceneManager.Unload("TownUnlocks"));
  }

  [CompilerGenerated]
  public bool \u003CStart\u003Eb__5_1() => !this.unlockSequence.gameObject.activeSelf;
}
﻿// Decompiled with JetBrains decompiler
// Type: TraitData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

[CreateAssetMenu(fileName = "New Trait", menuName = "Trait")]
public class TraitData : DataFile
{
  public KeywordData keyword;
  public StatusEffectData[] effects;
  public TraitData[] overrides;
  public bool isReaction;
}
﻿// Decompiled with JetBrains decompiler
// Type: TraitSaveData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Serializable]
public class TraitSaveData : ILoadable<CardData.TraitStacks>
{
  public string name;
  public int count;

  public CardData.TraitStacks Load()
  {
    TraitData traitData = AddressableLoader.Get<TraitData>("TraitData", this.name);
    if (!(bool) (UnityEngine.Object) traitData)
      return (CardData.TraitStacks) null;
    return new CardData.TraitStacks()
    {
      data = traitData,
      count = this.count
    };
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Transition
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class Transition : MonoBehaviourSingleton<Transition>
{
  public static TransitionType current;
  [SerializeField]
  public TransitionType[] transitions;
  public static bool Running;
  public TransitionType prefab;

  public void OnEnable() => global::Events.OnSettingChanged += new UnityAction<string, object>(this.SettingChanged);

  public void OnDisable() => global::Events.OnSettingChanged -= new UnityAction<string, object>(this.SettingChanged);

  public void SettingChanged(string key, object value)
  {
    if (key != "TransitionType" || !(value is int index))
      return;
    this.SetTransitionType(index);
  }

  public void SetTransitionType(int index) => this.prefab = this.transitions[Mathf.Clamp(index, 0, this.transitions.Length - 1)];

  public static TransitionType Begin()
  {
    if ((bool) (UnityEngine.Object) Transition.current)
    {
      if (Transition.Running)
        return Transition.current;
      UnityEngine.Object.Destroy((UnityEngine.Object) Transition.current.gameObject);
    }
    if (!(bool) (UnityEngine.Object) MonoBehaviourSingleton<Transition>.instance.prefab)
      MonoBehaviourSingleton<Transition>.instance.SetTransitionType(Settings.Load<int>("TransitionType", 0));
    Transition.current = UnityEngine.Object.Instantiate<TransitionType>(MonoBehaviourSingleton<Transition>.instance.prefab, MonoBehaviourSingleton<Transition>.instance.transform);
    MonoBehaviourSingleton<Transition>.instance.StopAllCoroutines();
    MonoBehaviourSingleton<Transition>.instance.StartCoroutine(Transition.current.In());
    global::Events.InvokeTransitionStart(Transition.current);
    Transition.Running = true;
    return Transition.current;
  }

  public static void End()
  {
    if (!(bool) (UnityEngine.Object) Transition.current)
      return;
    MonoBehaviourSingleton<Transition>.instance.StopAllCoroutines();
    MonoBehaviourSingleton<Transition>.instance.StartCoroutine(Transition.current.Out());
    global::Events.InvokeTransitionEnd(Transition.current);
    Transition.Running = false;
  }

  public static IEnumerator WaitUntilDone(TransitionType transition)
  {
    if (transition == null)
      transition = Transition.current;
    yield return (object) new WaitUntil((Func<bool>) (() => !(bool) (UnityEngine.Object) transition || !transition.IsRunning));
  }

  public static IEnumerator To(string newSceneKey)
  {
    yield return (object) Transition.WaitUntilDone(Transition.Begin());
    yield return (object) Sequences.SceneChange(newSceneKey);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TransitionClose
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class TransitionClose : TransitionType
{
  [SerializeField]
  public Transform rotator;
  [SerializeField]
  public GameObject borderTop;
  [SerializeField]
  public GameObject borderBottom;
  [SerializeField]
  public CanvasGroup fade;
  [SerializeField]
  public Vector2 angleRange = new Vector2(0.0f, 40f);
  [Header("Tweens")]
  [SerializeField]
  public LeanTweenType easeIn = LeanTweenType.easeOutBounce;
  [SerializeField]
  public float easeInDur = 0.8f;
  [SerializeField]
  public LeanTweenType easeOut = LeanTweenType.easeInQuart;
  [SerializeField]
  public float easeOutDur = 0.5f;
  public Vector3 borderTopStartPos;
  public Vector3 borderBottomStartPos;

  public void Start()
  {
    this.borderTopStartPos = this.borderTop.transform.localPosition;
    this.borderBottomStartPos = this.borderBottom.transform.localPosition;
  }

  public override IEnumerator In()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    TransitionClose transitionClose = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      transitionClose.IsRunning = false;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    transitionClose.IsRunning = true;
    transitionClose.fade.blocksRaycasts = true;
    transitionClose.fade.alpha = 0.01f;
    transitionClose.rotator.SetLocalRotationZ(transitionClose.angleRange.PettyRandom().WithRandomSign());
    LeanTween.moveLocal(transitionClose.borderTop, Vector3.zero, transitionClose.easeInDur).setEase(transitionClose.easeIn);
    LeanTween.moveLocal(transitionClose.borderBottom, Vector3.zero, transitionClose.easeInDur).setEase(transitionClose.easeIn);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) new WaitForSeconds(transitionClose.easeInDur);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override IEnumerator Out()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    TransitionClose transitionClose = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      transitionClose.IsRunning = false;
      transitionClose.gameObject.Destroy();
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    transitionClose.IsRunning = true;
    transitionClose.fade.blocksRaycasts = false;
    transitionClose.fade.alpha = 0.0f;
    LeanTween.moveLocal(transitionClose.borderTop, transitionClose.borderTopStartPos, transitionClose.easeOutDur).setEase(transitionClose.easeOut);
    LeanTween.moveLocal(transitionClose.borderBottom, transitionClose.borderBottomStartPos, transitionClose.easeOutDur).setEase(transitionClose.easeOut);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) new WaitForSeconds(transitionClose.easeOutDur);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TransitionFade
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class TransitionFade : TransitionType
{
  public CanvasGroup fade;
  [Header("Tweens")]
  public LeanTweenType easeIn = LeanTweenType.easeInQuint;
  public float easeInDur = 0.5f;
  public LeanTweenType easeOut = LeanTweenType.easeOutQuint;
  public float easeOutDur = 0.5f;

  public override IEnumerator In()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    TransitionFade transitionFade = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      transitionFade.IsRunning = false;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    transitionFade.IsRunning = true;
    transitionFade.fade.blocksRaycasts = true;
    transitionFade.fade.LeanAlpha(1f, transitionFade.easeInDur).setEase(transitionFade.easeIn);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) new WaitForSeconds(transitionFade.easeInDur);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override IEnumerator Out()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    TransitionFade transitionFade = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      transitionFade.IsRunning = false;
      transitionFade.gameObject.Destroy();
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    transitionFade.IsRunning = true;
    transitionFade.fade.blocksRaycasts = false;
    transitionFade.fade.LeanAlpha(0.0f, transitionFade.easeOutDur).setEase(transitionFade.easeOut);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) new WaitForSeconds(transitionFade.easeOutDur);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TransitionSnow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;

public class TransitionSnow : TransitionType
{
  [SerializeField]
  public ParticleSystem inParticles;
  [SerializeField]
  public ParticleSystem outParticles;
  [Header("Fade Image")]
  [SerializeField]
  public CanvasGroup fade;
  [Header("Tweens")]
  [SerializeField]
  public LeanTweenType easeIn = LeanTweenType.easeInCubic;
  [SerializeField]
  public float easeInDur = 0.6f;
  [SerializeField]
  public LeanTweenType easeOut = LeanTweenType.easeOutCubic;
  [SerializeField]
  public float easeOutDur = 0.1f;

  [Button("In", EButtonEnableMode.Always)]
  public void SnowIn()
  {
    if (this.IsRunning)
      return;
    this.StopAllCoroutines();
    this.StartCoroutine(this.In());
  }

  [Button("Out", EButtonEnableMode.Always)]
  public void SnowOut()
  {
    if (this.IsRunning)
      return;
    this.StopAllCoroutines();
    this.StartCoroutine(this.Out());
  }

  public override IEnumerator In()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    TransitionSnow transitionSnow = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      transitionSnow.IsRunning = false;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    transitionSnow.inParticles.Play();
    transitionSnow.IsRunning = true;
    transitionSnow.fade.blocksRaycasts = true;
    transitionSnow.fade.LeanAlpha(1f, transitionSnow.easeInDur).setEase(transitionSnow.easeIn);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) new WaitForSeconds(transitionSnow.easeInDur);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override IEnumerator Out()
  {
    TransitionSnow transitionSnow = this;
    transitionSnow.outParticles.Play();
    transitionSnow.IsRunning = true;
    transitionSnow.fade.blocksRaycasts = false;
    transitionSnow.fade.LeanAlpha(0.0f, transitionSnow.easeOutDur).setEase(transitionSnow.easeOut);
    yield return (object) new WaitForSeconds(transitionSnow.easeOutDur);
    transitionSnow.IsRunning = false;
    yield return (object) new WaitUntil(new Func<bool>(transitionSnow.\u003COut\u003Eb__10_0));
    transitionSnow.gameObject.Destroy();
  }

  [CompilerGenerated]
  public bool \u003COut\u003Eb__10_0() => !this.outParticles.isPlaying;
}
﻿// Decompiled with JetBrains decompiler
// Type: TransitionType
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine;

public abstract class TransitionType : MonoBehaviour
{
  [CompilerGenerated]
  public bool \u003CIsRunning\u003Ek__BackingField;

  public bool IsRunning
  {
    get => this.\u003CIsRunning\u003Ek__BackingField;
    set => this.\u003CIsRunning\u003Ek__BackingField = value;
  }

  public virtual IEnumerator In() => (IEnumerator) null;

  public virtual IEnumerator Out() => (IEnumerator) null;
}
﻿// Decompiled with JetBrains decompiler
// Type: TribeDisplaySequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class TribeDisplaySequence : MonoBehaviour
{
  [SerializeField]
  public string[] tribeNames;
  [SerializeField]
  public GameObject[] displays;

  public void Run(string className)
  {
    for (int classIndex = 0; classIndex < this.tribeNames.Length; ++classIndex)
    {
      if (this.tribeNames[classIndex] == className)
        this.Run(classIndex);
    }
  }

  public void Run(int classIndex)
  {
    for (int index = 0; index < this.displays.Length; ++index)
      this.displays[index].gameObject.SetActive(index == classIndex);
    this.gameObject.SetActive(true);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TribeFlagDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class TribeFlagDisplay : MonoBehaviour
{
  public Image flagImage;
  [SerializeField]
  public Sprite flagSprite;
  [SerializeField]
  public GameObject locked;
  [SerializeField]
  public ButtonAnimator button;
  [SerializeField]
  public InputAction inputAction;

  public void SetFlagSprite(Sprite sprite)
  {
    this.flagSprite = sprite;
    this.flagImage.sprite = sprite;
  }

  public void AddPressAction(UnityAction action) => this.inputAction.action.AddListener(action);

  public void ClearPressActions() => this.inputAction.action.RemoveAllListeners();

  public void SetInteractable(bool interactable) => this.button.interactable = interactable;

  public void SetUnlocked()
  {
    this.flagImage.sprite = this.flagSprite;
    this.button.interactable = true;
  }

  public void SetAvailable() => this.locked.SetActive(false);
}
﻿// Decompiled with JetBrains decompiler
// Type: TribeHutSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class TribeHutSequence : BuildingSequence
{
  [SerializeField]
  public TribeFlagDisplay[] flags;
  public GameMode _gameMode;

  public GameMode gameMode => this._gameMode ?? (this._gameMode = AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal"));

  public override IEnumerator Sequence()
  {
    this.SetupFlags();
    yield return (object) null;
  }

  public void SetupFlags()
  {
    int? count = this.building.checkedUnlocks?.Count;
    int valueOrDefault = (count.HasValue ? new int?(1 + count.GetValueOrDefault()) : new int?()).GetValueOrDefault();
    int length = this.gameMode.classes.Length;
    for (int index = 0; index < this.flags.Length; ++index)
    {
      if (index < length)
      {
        this.flags[index].SetAvailable();
        if (index < valueOrDefault)
          this.flags[index].SetUnlocked();
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Trigger
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class Trigger
{
  public Entity entity;
  public Entity triggeredBy;
  public Entity[] targets;
  public bool nullified;
  public Hit[] hits;
  public bool countsAsTrigger = true;
  public string type = "basic";
  public bool triggerAgainst;
  public Entity triggerAgainstTarget;
  public CardContainer triggerAgainstContainer;

  public Trigger(Entity entity, Entity triggeredBy, string type, Entity[] targets)
  {
    this.entity = entity;
    this.triggeredBy = triggeredBy;
    this.type = type;
    this.targets = targets;
  }

  public IEnumerator Process()
  {
    string attackerString = this.entity.name;
    string targetsString = this.targets == null || this.targets.Length == 0 ? "null" : "";
    if (this.targets != null)
    {
      for (int index = 0; index < this.targets.Length; ++index)
      {
        if (index > 0)
          targetsString += ", ";
        Entity target = this.targets[index];
        targetsString += (bool) (UnityEngine.Object) target ? target.name : "null";
      }
    }
    Debug.Log((object) ("CardPlayAgainst [" + attackerString + " vs " + targetsString + "]"));
    yield return (object) this.PreProcess();
    if (this.entity.IsAliveAndExists())
    {
      if (this.hits.Length != 0)
        yield return (object) this.Animate();
      yield return (object) this.ProcessHits();
      yield return (object) this.PostProcess();
    }
    Debug.Log((object) ("CardPlayAgainst [" + attackerString + " vs " + targetsString + "] DONE"));
  }

  public virtual IEnumerator PreProcess()
  {
    Trigger trigger1 = this;
    yield return (object) StatusEffectSystem.PreCardPlayedEvent(trigger1.entity, trigger1.targets);
    if (trigger1.entity.IsAliveAndExists())
    {
      if (trigger1.hits == null)
      {
        Trigger trigger2 = trigger1;
        Entity[] targets = trigger1.targets;
        Hit[] hitArray1 = new Hit[targets != null ? targets.Length : 0];
        trigger2.hits = hitArray1;
        if (trigger1.targets != null)
        {
          for (int index = 0; index < trigger1.targets.Length; ++index)
          {
            Hit hit = new Hit(trigger1.entity, trigger1.targets[index]);
            hit.AddAttackerStatuses();
            hit.trigger = trigger1;
            trigger1.hits[index] = hit;
          }
        }
      }
      Hit[] hitArray = trigger1.hits;
      for (int index = 0; index < hitArray.Length; ++index)
        yield return (object) StatusEffectSystem.PreAttackEvent(hitArray[index]);
      hitArray = (Hit[]) null;
    }
  }

  public virtual IEnumerator Animate()
  {
    Trigger data = this;
    if (data.entity.data.hasAttack)
      yield return (object) AssetLoader.Lookup<CardAnimation>("CardAnimations", "Punch").Routine((object) data);
    else
      yield return (object) AssetLoader.Lookup<CardAnimation>("CardAnimations", "Supportive").Routine((object) data);
  }

  public virtual IEnumerator ProcessHits()
  {
    List<Entity> entityList = new List<Entity>();
    Routine.Clump clump = new Routine.Clump();
    foreach (Hit hit in this.hits)
    {
      clump.Add(Trigger.ProcessHit(hit));
      entityList.Add(hit.target);
    }
    yield return (object) clump.WaitForEnd();
  }

  public virtual IEnumerator PostProcess()
  {
    if (this.countsAsTrigger)
      yield return (object) StatusEffectSystem.CardPlayedEvent(this.entity, ((IEnumerable<Hit>) this.hits).Select<Hit, Entity>((Func<Hit, Entity>) (hit => hit.target)).ToArray<Entity>());
  }

  public static IEnumerator ProcessHit(Hit hit)
  {
    yield return (object) hit.Process();
    yield return (object) StatusEffectSystem.PostAttackEvent(hit);
  }

  public static CardContainer GetTargetRow(Entity attacker, Entity target)
  {
    CardContainer targetRow = (CardContainer) null;
    int[] rowIndices1 = Trigger.GetRowIndices(attacker);
    int[] rowIndices2 = Trigger.GetRowIndices(target);
    if (rowIndices1 == null || rowIndices2 == null)
      return (CardContainer) null;
    foreach (int rowIndex in ((IEnumerable<int>) rowIndices1).Intersect<int>((IEnumerable<int>) rowIndices2))
      targetRow = References.Battle.GetRow(target.owner, rowIndex);
    if (!(bool) (UnityEngine.Object) targetRow)
      targetRow = target.containers.Length != 0 ? target.containers[0] : (target.preContainers.Length != 0 ? target.preContainers[0] : (CardContainer) null);
    return targetRow;
  }

  public static int[] GetRowIndices(Entity entity)
  {
    if (entity.alive && Battle.IsOnBoard(entity.containers))
      return References.Battle.GetRowIndices(entity);
    return !Battle.IsOnBoard(entity.preContainers) ? (int[]) null : References.Battle.GetRowIndices((IEnumerable<CardContainer>) entity.preContainers);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TriggerBombard
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TriggerBombard : Trigger
{
  public CardContainer[] slots;

  public TriggerBombard(
    Entity entity,
    Entity triggeredBy,
    string type,
    Entity[] targets,
    CardContainer[] slots)
    : base(entity, triggeredBy, type, targets)
  {
    this.slots = slots;
  }

  public override IEnumerator PreProcess()
  {
    TriggerBombard triggerBombard1 = this;
    List<Entity> entityList = new List<Entity>();
    foreach (CardContainer slot in triggerBombard1.slots)
    {
      Entity top = slot.GetTop();
      entityList.Add(top);
    }
    triggerBombard1.targets = entityList.ToArray();
    yield return (object) StatusEffectSystem.PreCardPlayedEvent(triggerBombard1.entity, triggerBombard1.targets);
    TriggerBombard triggerBombard2 = triggerBombard1;
    Entity[] targets = triggerBombard1.targets;
    Hit[] hitArray1 = new Hit[targets != null ? targets.Length : 0];
    triggerBombard2.hits = hitArray1;
    if (triggerBombard1.targets != null)
    {
      for (int index = 0; index < triggerBombard1.targets.Length; ++index)
      {
        Hit hit = new Hit(triggerBombard1.entity, triggerBombard1.targets[index]);
        hit.AddAttackerStatuses();
        hit.trigger = (Trigger) triggerBombard1;
        triggerBombard1.hits[index] = hit;
      }
    }
    Hit[] hitArray = triggerBombard1.hits;
    for (int index = 0; index < hitArray.Length; ++index)
    {
      Hit hit = hitArray[index];
      if ((bool) (Object) hit.target)
        yield return (object) StatusEffectSystem.PreAttackEvent(hit);
    }
    hitArray = (Hit[]) null;
  }

  public override IEnumerator Animate()
  {
    // ISSUE: reference to a compiler-generated field
    int num = this.\u003C\u003E1__state;
    TriggerBombard triggerBombard = this;
    if (num != 0)
    {
      if (num != 1)
        return false;
      // ISSUE: reference to a compiler-generated field
      this.\u003C\u003E1__state = -1;
      return false;
    }
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = -1;
    Routine routine = new Routine(AssetLoader.Lookup<CardAnimation>("CardAnimations", "BombardRocketShoot").Routine((object) triggerBombard.entity));
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E2__current = (object) Sequences.Wait(0.2f);
    // ISSUE: reference to a compiler-generated field
    this.\u003C\u003E1__state = 1;
    return true;
  }

  public override IEnumerator ProcessHits()
  {
    yield return (object) this.RainRockets();
  }

  public IEnumerator RainRockets()
  {
    TriggerBombard triggerBombard = this;
    CardAnimation rocketAnimation = AssetLoader.Lookup<CardAnimation>("CardAnimations", "BombardRocket");
    Routine.Clump clump = new Routine.Clump();
    for (int i = 0; i < triggerBombard.hits.Length; ++i)
    {
      clump.Add(TriggerBombard.Fire(rocketAnimation, triggerBombard.hits[i], triggerBombard.slots[i]));
      yield return (object) Sequences.Wait(0.3f);
    }
    yield return (object) clump.WaitForEnd();
  }

  public static IEnumerator Fire(CardAnimation rocketAnimation, Hit hit, CardContainer slot)
  {
    yield return (object) rocketAnimation.Routine((object) slot.transform.position);
    if ((bool) (Object) hit.target)
      yield return (object) Trigger.ProcessHit(hit);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TurnOrderButton
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class TurnOrderButton : MonoBehaviour
{
  [SerializeField]
  public ButtonAnimator button;
  [SerializeField]
  public Image image;
  [SerializeField]
  public Sprite openSprite;
  [SerializeField]
  public Sprite closedSprite;
  [SerializeField]
  public ParticleSystem particleSystem;

  public void Awake()
  {
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    this.SetActive(false);
  }

  public void OnDestroy() => global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);

  public void OnEnable()
  {
    global::Events.OnCardControllerEnabled += new UnityAction<CardController>(this.CardControllerEnabled);
    global::Events.OnCardControllerDisabled += new UnityAction<CardController>(this.CardControllerDisabled);
  }

  public void OnDisable()
  {
    global::Events.OnCardControllerEnabled -= new UnityAction<CardController>(this.CardControllerEnabled);
    global::Events.OnCardControllerDisabled -= new UnityAction<CardController>(this.CardControllerDisabled);
  }

  public void CardControllerEnabled(CardController controller)
  {
    if (!(bool) (Object) References.Battle || !((Object) controller == (Object) References.Battle.playerCardController))
      return;
    this.button.interactable = true;
  }

  public void CardControllerDisabled(CardController controller)
  {
    if (!(bool) (Object) References.Battle || !((Object) controller == (Object) References.Battle.playerCardController))
      return;
    this.button.interactable = false;
  }

  public void SceneChanged(Scene scene) => this.SetActive(scene.name == "Battle");

  public void SetActive(bool value)
  {
    this.gameObject.SetActive(value);
    this.button.interactable = value;
    this.CloseEye();
    this.button.interactable = false;
  }

  public void Select()
  {
    if (!ActionQueue.Empty || (bool) (Object) References.Battle && (bool) (Object) References.Battle.playerCardController.dragging)
      return;
    Object.FindObjectOfType<TurnOrderDisplay>()?.Toggle();
  }

  public void OpenEye()
  {
    this.image.sprite = this.openSprite;
    this.particleSystem.Play();
  }

  public void CloseEye()
  {
    this.image.sprite = this.closedSprite;
    this.particleSystem.Stop();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TurnOrderDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class TurnOrderDisplay : MonoBehaviour
{
  [SerializeField]
  public Transform group;
  [SerializeField]
  public TurnOrderNumber prefab;
  [SerializeField]
  public CanvasGroup vignette;
  [SerializeField]
  public float musicPitch = 0.9f;
  public bool active;
  public readonly List<TurnOrderNumber> numbers = new List<TurnOrderNumber>();

  public void Toggle()
  {
    if (this.active)
      this.Clear();
    else
      this.Display();
  }

  public void Display()
  {
    if (this.active)
      return;
    int num = 1;
    foreach (Entity entity in Battle.GetCardsOnBoard(References.Battle.enemy))
    {
      if (entity.data.counter > 0)
        this.CreateNumber(entity, num++);
    }
    foreach (Entity entity in Battle.GetCardsOnBoard(References.Battle.player))
    {
      if (entity.data.counter > 0)
        this.CreateNumber(entity, num++);
    }
    this.active = true;
    global::Events.OnEntitySelect += new UnityAction<Entity>(this.EntitySelect);
    global::Events.OnRedrawBellHit += new UnityAction<RedrawBellSystem>(this.RedrawBellHit);
    global::Events.OnDeckpackOpen += new UnityAction(this.DeckpackOpen);
    global::Events.OnInspect += new UnityAction<Entity>(this.Inspect);
    TurnOrderDisplay.OpenEye();
    this.vignette.gameObject.SetActive(true);
    this.vignette.alpha = 0.0f;
    LeanTween.cancel(this.vignette.gameObject);
    LeanTween.alphaCanvas(this.vignette, 1f, 1f).setEaseOutQuart();
    Object.FindObjectOfType<BattleMusicSystem>()?.FadePitchTo(this.musicPitch);
  }

  public void Clear()
  {
    if (!this.active)
      return;
    foreach (TurnOrderNumber number in this.numbers)
    {
      if ((bool) (Object) number)
        number.gameObject.Destroy();
    }
    this.numbers.Clear();
    this.active = false;
    global::Events.OnEntitySelect -= new UnityAction<Entity>(this.EntitySelect);
    global::Events.OnRedrawBellHit -= new UnityAction<RedrawBellSystem>(this.RedrawBellHit);
    global::Events.OnDeckpackOpen -= new UnityAction(this.DeckpackOpen);
    global::Events.OnInspect -= new UnityAction<Entity>(this.Inspect);
    TurnOrderDisplay.CloseEye();
    if ((bool) (Object) this.vignette)
      this.vignette.gameObject.SetActive(false);
    Object.FindObjectOfType<BattleMusicSystem>()?.FadePitchTo(1f);
  }

  public static void OpenEye() => Object.FindObjectOfType<TurnOrderButton>()?.OpenEye();

  public static void CloseEye() => Object.FindObjectOfType<TurnOrderButton>()?.CloseEye();

  public void CreateNumber(Entity entity, int number)
  {
    TurnOrderNumber turnOrderNumber = Object.Instantiate<TurnOrderNumber>(this.prefab, entity.GetContainerWorldPosition(), Quaternion.identity, this.group);
    turnOrderNumber.Set(entity, number);
    this.numbers.Add(turnOrderNumber);
  }

  public void EntitySelect(Entity entity) => this.Clear();

  public void RedrawBellHit(RedrawBellSystem redrawBell) => this.Clear();

  public void DeckpackOpen() => this.Clear();

  public void Inspect(Entity entity) => this.Clear();
}
﻿// Decompiled with JetBrains decompiler
// Type: TurnOrderNumber
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class TurnOrderNumber : MonoBehaviour
{
  [SerializeField]
  public Image glow;
  [SerializeField]
  public Color imminentGlowColour = Color.red;
  [SerializeField]
  public Image image;
  [SerializeField]
  public Sprite imminentSprite;
  [SerializeField]
  public TMP_Text textElement;

  public void Set(Entity entity, int number)
  {
    this.textElement.text = number.ToString();
    if (entity.counter.current > 1 || entity.IsSnowed)
      return;
    this.glow.color = this.imminentGlowColour;
    this.image.sprite = this.imminentSprite;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TurnOrderOverlay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class TurnOrderOverlay : MonoBehaviour
{
  [SerializeField]
  public GameObject overlay;
  [SerializeField]
  public GameObject button;
  [SerializeField]
  public TMP_Text numberPrefab;
  public List<TMP_Text> numbers;

  public void OnEnable() => global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);

  public void OnDisable() => global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);

  public void BattlePhaseStart(Battle.Phase phase)
  {
    switch (phase)
    {
      case Battle.Phase.Play:
        this.button.SetActive(true);
        break;
      case Battle.Phase.Battle:
      case Battle.Phase.End:
        this.button.SetActive(false);
        break;
    }
  }

  public void Toggle()
  {
    if (this.overlay.activeSelf)
      this.Deactivate();
    else
      this.Activate();
  }

  public void Activate()
  {
    this.overlay.SetActive(true);
    HashSet<Entity> allUnits = Battle.GetAllUnits();
    int num = 1;
    if (this.numbers == null)
      this.numbers = new List<TMP_Text>();
    foreach (Entity entity in allUnits)
    {
      TMP_Text tmpText = Object.Instantiate<TMP_Text>(this.numberPrefab, this.overlay.transform);
      tmpText.transform.localPosition = entity.transform.position;
      tmpText.text = num.ToString();
      tmpText.gameObject.SetActive(true);
      this.numbers.Add(tmpText);
      ++num;
    }
  }

  public void Deactivate()
  {
    foreach (Component number in this.numbers)
      number.gameObject.Destroy();
    this.numbers = (List<TMP_Text>) null;
    this.overlay.SetActive(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialBattleSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public abstract class TutorialBattleSystem : TutorialParentSystem
{
  public override void OnEnable()
  {
    base.OnEnable();
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);
  }

  public override void OnDisable()
  {
    base.OnDisable();
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    this.BattleEnd();
  }

  public void SceneChanged(Scene scene) => Object.Destroy((Object) this);

  public void BattlePhaseStart(Battle.Phase phase)
  {
    if (phase != Battle.Phase.Init)
      return;
    this.BattleStart();
  }

  public virtual void BattleStart()
  {
  }

  public virtual void BattleEnd()
  {
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialBattleSystem1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

public class TutorialBattleSystem1 : TutorialBattleSystem
{
  public static readonly string[] startingHand = new string[6]
  {
    "Sword",
    "SnowStick",
    "Sword",
    "Foxee",
    "Sword",
    "Sword"
  };

  public override void BattleStart()
  {
    UnityEngine.Object.FindObjectOfType<BattleSaveSystem>()?.Disable();
    CardContainer cardContainer = References.Battle.rows[References.Battle.enemy][0];
    cardContainer.canBePlacedOn = false;
    cardContainer.transform.parent.gameObject.SetActive(false);
    UnityEngine.Object.FindObjectOfType<RedrawBellSystem>()?.Disable();
    WaveDeploySystem objectOfType = UnityEngine.Object.FindObjectOfType<WaveDeploySystem>();
    if (objectOfType != null)
    {
      objectOfType.Hide();
      objectOfType.visible = false;
    }
    References.Player.OrderNextCards(TutorialBattleSystem1.startingHand);
    this.phases = new List<TutorialParentSystem.Phase>()
    {
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhasePlaceLeader(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhasePlaceCompanion(TutorialBattleSystem1.FindLastUnit().data),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhaseUseItem(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhaseCounters(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhaseEnemiesAttackFirst(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhaseWaitForNewEnemies(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhaseRedrawBell(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhaseRedrawBellPopUp(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhaseProtectLeader(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhaseWaveDeploy(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhaseWaitForMiniboss(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem1.PhaseMiniboss()
    };
  }

  public static Entity FindLastUnit()
  {
    CardData chosenUnitData = References.PlayerData.inventory.deck.LastOrDefault<CardData>((Func<CardData, bool>) (a => a.cardType.unit));
    return Battle.GetCards(References.Player).LastOrDefault<Entity>((Func<Entity, bool>) (a => (long) a.data.id == (long) chosenUnitData.id));
  }

  public override void BattleEnd() => UnityEngine.Object.FindObjectOfType<RedrawBellSystem>()?.Enable();

  public class PhasePlaceLeader : TutorialParentSystem.Phase
  {
    public override void OnEnable()
    {
      global::Events.OnEntityMove += new UnityAction<Entity>(this.EntityMove);
      Routine routine = new Routine(this.PromptAfter(2f));
    }

    public override void OnDisable()
    {
      global::Events.OnEntityMove -= new UnityAction<Entity>(this.EntityMove);
      PromptSystem.Hide();
    }

    public void EntityMove(Entity entity)
    {
      if (!((UnityEngine.Object) entity.owner == (UnityEngine.Object) References.Player) || !entity.data.cardType.miniboss || !Battle.IsOnBoard(entity))
        return;
      this.enabled = false;
    }

    public IEnumerator PromptAfter(float delay)
    {
      TutorialBattleSystem1.PhasePlaceLeader phasePlaceLeader = this;
      yield return (object) new WaitForSeconds(delay);
      if (phasePlaceLeader.enabled)
      {
        PromptSystem.Create(Prompt.Anchor.Top, 0.0f, -2f, 8.7f);
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_1.GetLocalizedString()));
      }
    }
  }

  public class PhasePlaceCompanion : TutorialParentSystem.Phase
  {
    public readonly CardData target;

    public override float delay => 1f;

    public PhasePlaceCompanion(CardData target) => this.target = target;

    public override void OnEnable()
    {
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart += new UnityAction<int>(this.BattleTurnStart);
      PromptSystem.Create(Prompt.Anchor.TopLeft, 2f, -2f, 8f, Prompt.Emote.Type.Talk);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_2.GetLocalizedString(), (object) this.target.title)));
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart -= new UnityAction<int>(this.BattleTurnStart);
      PromptSystem.Hide();
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!allow || this.CorrectAction(action) || TutorialParentSystem.Phase.FreeMoveAction(action) || TutorialParentSystem.Phase.InspectAction(action))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public void BattleTurnStart(int turn) => this.enabled = false;

    public bool CorrectAction(PlayAction action) => action is ActionMove actionMove && actionMove.entity.data.name == this.target.name && actionMove.toContainers.Length == 1 && Battle.IsOnBoard(actionMove.toContainers[0].Group);

    [CompilerGenerated]
    public string \u003COnEnable\u003Eb__4_0() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_2.GetLocalizedString(), (object) this.target.title);
  }

  public class PhaseUseItem : TutorialParentSystem.Phase
  {
    public override float delay => 1f;

    public override void OnEnable()
    {
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart += new UnityAction<int>(this.BattleTurnStart);
      PromptSystem.Create(Prompt.Anchor.TopLeft, 1f, -2f, 6f, Prompt.Emote.Type.Point);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_3.GetLocalizedString()));
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart -= new UnityAction<int>(this.BattleTurnStart);
      PromptSystem.Hide();
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!allow || this.CorrectAction(action) || TutorialParentSystem.Phase.FreeMoveAction(action) || TutorialParentSystem.Phase.InspectAction(action))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public void BattleTurnStart(int turn) => this.enabled = false;

    public bool CorrectAction(PlayAction action) => action is ActionTriggerAgainst actionTriggerAgainst && actionTriggerAgainst.entity.data.name == "Sword" && actionTriggerAgainst.target.data.name == "Pengoon";
  }

  public class PhaseCounters : TutorialParentSystem.Phase
  {
    public override float delay => 1f;

    public override void OnEnable()
    {
      global::Events.OnBattleTurnStart += new UnityAction<int>(this.BattleTurnStart);
      PromptSystem.Create(Prompt.Anchor.Top, 0.0f, -1.5f, 9f, Prompt.Emote.Type.Explain);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_4.GetLocalizedString()));
    }

    public override void OnDisable()
    {
      global::Events.OnBattleTurnStart -= new UnityAction<int>(this.BattleTurnStart);
      PromptSystem.Hide();
    }

    public void BattleTurnStart(int turn) => this.enabled = false;
  }

  public class PhaseEnemiesAttackFirst : TutorialParentSystem.Phase
  {
    public override float delay => 0.0f;

    public override void OnEnable()
    {
      global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(TutorialBattleSystem1.PhaseEnemiesAttackFirst.BattlePhaseStart);
      global::Events.OnBattleTurnStart += new UnityAction<int>(this.BattleTurnStart);
    }

    public override void OnDisable()
    {
      global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(TutorialBattleSystem1.PhaseEnemiesAttackFirst.BattlePhaseStart);
      global::Events.OnBattleTurnStart -= new UnityAction<int>(this.BattleTurnStart);
      PromptSystem.Hide();
    }

    public static void BattlePhaseStart(Battle.Phase phase)
    {
      if (phase != Battle.Phase.Play)
        return;
      PromptSystem.Create(Prompt.Anchor.TopRight, -3f, -3f, 4f, Prompt.Emote.Type.Scared);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_41.GetLocalizedString()));
    }

    public void BattleTurnStart(int turn) => this.enabled = false;
  }

  public class PhaseWaitForNewEnemies : TutorialParentSystem.Phase
  {
    public override void OnEnable() => global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerform);

    public override void OnDisable() => global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerform);

    public void ActionPerform(PlayAction action)
    {
      if (!(action is ActionMove actionMove) || !((UnityEngine.Object) actionMove.entity.owner == (UnityEngine.Object) References.Battle.enemy))
        return;
      this.enabled = false;
    }
  }

  public class PhaseRedrawBell : TutorialParentSystem.Phase
  {
    public override float delay => 1f;

    public override void OnEnable()
    {
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(TutorialBattleSystem1.PhaseRedrawBell.CheckAction);
      global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerform);
      PromptSystem.Create(Prompt.Anchor.TopRight, -1f, -1.25f, 6f, Prompt.Emote.Type.Talk);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_5.GetLocalizedString()));
      RedrawBellSystem objectOfType = UnityEngine.Object.FindObjectOfType<RedrawBellSystem>();
      if (!(bool) (UnityEngine.Object) objectOfType)
        return;
      objectOfType.Enable();
      objectOfType.BecomeInteractable();
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(TutorialBattleSystem1.PhaseRedrawBell.CheckAction);
      global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerform);
      PromptSystem.Hide();
    }

    public static void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!allow || TutorialBattleSystem1.PhaseRedrawBell.CorrectAction(action) || TutorialBattleSystem1.PhaseRedrawBell.PlayCardAction(action) || TutorialParentSystem.Phase.FreeMoveAction(action) || TutorialParentSystem.Phase.InspectAction(action))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public void ActionPerform(PlayAction action)
    {
      if (!TutorialBattleSystem1.PhaseRedrawBell.CorrectAction(action))
        return;
      this.enabled = false;
    }

    public static bool CorrectAction(PlayAction action) => action is ActionRedraw;

    public static bool PlayCardAction(PlayAction action) => action is ActionTrigger;
  }

  public class PhaseRedrawBellPopUp : TutorialParentSystem.Phase
  {
    public TutorialSystem tutorialSystem;

    public override float delay => 1f;

    public override void OnEnable()
    {
      this.tutorialSystem = UnityEngine.Object.FindObjectOfType<TutorialSystem>();
      global::Events.OnBattleTurnEnd += new UnityAction<int>(this.Show);
    }

    public override void OnDisable() => global::Events.OnBattleTurnEnd -= new UnityAction<int>(this.Show);

    public void Show(int turn)
    {
      HelpPanelSystem.Show(this.tutorialSystem.redrawBellHelpKey);
      HelpPanelSystem.SetEmote(this.tutorialSystem.redrawBellHelpEmote);
      HelpPanelSystem.SetImage(1.5f, 1.5f, this.tutorialSystem.redrawBellHelpSprite);
      HelpPanelSystem.SetBackButtonActive(false);
      HelpPanelSystem.AddButton(HelpPanelSystem.ButtonType.Positive, this.tutorialSystem.redrawBellHelpButtonKey, "Select", new UnityAction(this.End));
    }

    public void End() => this.enabled = false;
  }

  public class PhaseProtectLeader : TutorialParentSystem.Phase
  {
    public override float delay => 1f;

    public override void OnEnable() => this.Show();

    public override void OnDisable() => PromptSystem.Hide();

    public void Show()
    {
      PromptSystem.Create(Prompt.Anchor.Left, 1f, 1f, 4f);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_6.GetLocalizedString()));
      global::Events.OnBattleTurnStart += new UnityAction<int>(this.End);
    }

    public void End(int turn)
    {
      this.enabled = false;
      global::Events.OnBattleTurnStart -= new UnityAction<int>(this.End);
    }
  }

  public class PhaseWaveDeploy : TutorialParentSystem.Phase
  {
    public override float delay => 1f;

    public override void OnEnable()
    {
      global::Events.OnBattleTurnStart += new UnityAction<int>(this.BattleTurnStart);
      UnityEngine.Object.FindObjectOfType<WaveDeploySystem>()?.Show();
      PromptSystem.Create(Prompt.Anchor.TopRight, -3f, -1.75f, 6f, Prompt.Emote.Type.Talk);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_7.GetLocalizedString()));
      PromptSystem.Prompt.SetEmotePosition(Prompt.Emote.Position.Above, 2f, forceFlip: 1f);
    }

    public override void OnDisable()
    {
      global::Events.OnBattleTurnStart -= new UnityAction<int>(this.BattleTurnStart);
      PromptSystem.Hide();
    }

    public void BattleTurnStart(int turn) => this.enabled = false;
  }

  public class PhaseWaitForMiniboss : TutorialParentSystem.Phase
  {
    public override void OnEnable() => global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerform);

    public override void OnDisable() => global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerform);

    public void ActionPerform(PlayAction action)
    {
      if (!(action is ActionMove actionMove) || !((UnityEngine.Object) actionMove.entity.owner == (UnityEngine.Object) References.Battle.enemy) || !actionMove.entity.data.cardType.miniboss)
        return;
      this.enabled = false;
    }
  }

  public class PhaseMiniboss : TutorialParentSystem.Phase
  {
    public override float delay => 1f;

    public override void OnEnable()
    {
      global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);
      Routine routine = new Routine(this.PromptAfterDelay(2f));
    }

    public override void OnDisable()
    {
      global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);
      PromptSystem.Hide();
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
      if (!((UnityEngine.Object) entity.owner == (UnityEngine.Object) References.Battle.enemy) || !entity.data.cardType.miniboss)
        return;
      this.enabled = false;
    }

    public IEnumerator PromptAfterDelay(float delay)
    {
      TutorialBattleSystem1.PhaseMiniboss phaseMiniboss = this;
      yield return (object) new WaitForSeconds(delay);
      if (phaseMiniboss.enabled)
      {
        PromptSystem.Create(Prompt.Anchor.TopLeft, 2f, -1.5f, 5f, Prompt.Emote.Type.Talk);
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_8.GetLocalizedString()));
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialBattleSystem2
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

public class TutorialBattleSystem2 : TutorialBattleSystem
{
  public Entity chosenUnit;

  public override void BattleStart()
  {
    UnityEngine.Object.FindObjectOfType<BattleSaveSystem>()?.Disable();
    this.chosenUnit = TutorialBattleSystem2.FindChosenUnit();
    string[] nextCardNames = new string[6]
    {
      "Sword",
      "PinkberryJuice",
      this.chosenUnit.data.name,
      "Sword",
      "Sword",
      "Sword"
    };
    References.Player.OrderNextCards(nextCardNames);
    this.phases = new List<TutorialParentSystem.Phase>()
    {
      (TutorialParentSystem.Phase) new TutorialBattleSystem2.PhaseWaitForLeader(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem2.PhaseInspectEnemy(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem2.PhasePlaceCompanion(this.chosenUnit),
      (TutorialParentSystem.Phase) new TutorialBattleSystem2.PhaseWaitDisallowRecall(2),
      (TutorialParentSystem.Phase) new TutorialBattleSystem2.PhaseMoveCompanionInFrontOfLeader(this.chosenUnit),
      (TutorialParentSystem.Phase) new TutorialBattleSystem2.PhaseBarrage(this.chosenUnit),
      (TutorialParentSystem.Phase) new TutorialBattleSystem2.PhaseWaitDisallowRecall(1),
      (TutorialParentSystem.Phase) new TutorialBattleSystem2.PhaseRecallToHeal(this.chosenUnit),
      (TutorialParentSystem.Phase) new TutorialBattleSystem2.PhaseRecallFree()
    };
  }

  public void InsertPhase(TutorialParentSystem.Phase phase) => this.phases.Insert(0, phase);

  public static Entity FindChosenUnit()
  {
    CardData chosenUnitData = References.PlayerData.inventory.deck.LastOrDefault<CardData>((Func<CardData, bool>) (a => a.cardType.unit));
    return Battle.GetCards(References.Player).LastOrDefault<Entity>((Func<Entity, bool>) (a => (long) a.data.id == (long) chosenUnitData.id));
  }

  public class PhaseWaitForLeader : TutorialParentSystem.Phase
  {
    public override void OnEnable() => global::Events.OnEntityMove += new UnityAction<Entity>(this.EntityMove);

    public override void OnDisable() => global::Events.OnEntityMove -= new UnityAction<Entity>(this.EntityMove);

    public void EntityMove(Entity entity)
    {
      if (!((UnityEngine.Object) entity.owner == (UnityEngine.Object) References.Player) || !entity.data.cardType.miniboss || !Battle.IsOnBoard(entity))
        return;
      this.enabled = false;
    }
  }

  public class PhaseInspectEnemy : TutorialParentSystem.Phase
  {
    public Entity target;

    public override float delay => 0.2f;

    public override void OnEnable()
    {
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnInspect += new UnityAction<Entity>(this.Inspect);
      global::Events.OnInspectEnd += new UnityAction<Entity>(this.InspectEnd);
      this.target = References.Battle.GetRow(References.Battle.enemy, 0).GetTop();
      PromptSystem.Create(Prompt.Anchor.TopLeft, 1.5f, -2f, 5f, Prompt.Emote.Type.Point);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => string.Format(MonoBehaviourSingleton<Cursor3d>.instance.usingMouse ? ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_1) : ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_1Gamepad), (object) this.target.data.title)));
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnInspect -= new UnityAction<Entity>(this.Inspect);
      global::Events.OnInspectEnd -= new UnityAction<Entity>(this.InspectEnd);
      PromptSystem.Hide();
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!allow || this.CorrectAction(action) || TutorialParentSystem.Phase.FreeMoveAction(action))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public void Inspect(Entity entity) => PromptSystem.Hide();

    public void InspectEnd(Entity entity) => this.enabled = false;

    public bool CorrectAction(PlayAction action) => action is ActionInspect actionInspect && (UnityEngine.Object) actionInspect.entity == (UnityEngine.Object) this.target;

    [CompilerGenerated]
    public string \u003COnEnable\u003Eb__3_0() => string.Format(MonoBehaviourSingleton<Cursor3d>.instance.usingMouse ? ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_1) : ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_1Gamepad), (object) this.target.data.title);
  }

  public class PhasePlaceCompanion : TutorialParentSystem.Phase
  {
    public readonly Entity target;

    public PhasePlaceCompanion(Entity target) => this.target = target;

    public override void OnEnable()
    {
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart += new UnityAction<int>(this.BattleTurnStart);
      Routine routine = new Routine(this.PromptAfter(1f));
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart -= new UnityAction<int>(this.BattleTurnStart);
      PromptSystem.Hide();
    }

    public IEnumerator PromptAfter(float delay)
    {
      TutorialBattleSystem2.PhasePlaceCompanion phasePlaceCompanion = this;
      yield return (object) new WaitForSeconds(delay);
      if (phasePlaceCompanion.enabled)
      {
        PromptSystem.Create(Prompt.Anchor.TopLeft, 1.5f, -2f, 5f);
        PromptSystem.SetTextAction(new Prompt.GetTextCallback(phasePlaceCompanion.\u003CPromptAfter\u003Eb__4_0));
      }
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!allow || this.CorrectAction(action) || TutorialParentSystem.Phase.FreeMoveAction(action) || TutorialParentSystem.Phase.InspectAction(action))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public void BattleTurnStart(int turn) => this.enabled = false;

    public bool CorrectAction(PlayAction action) => action is ActionMove actionMove && actionMove.entity.data.name == this.target.data.name && actionMove.toContainers.Length == 1 && Battle.IsOnBoard(actionMove.toContainers[0].Group) && actionMove.toContainers[0].Group.Count == 0;

    [CompilerGenerated]
    public string \u003CPromptAfter\u003Eb__4_0() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_2.GetLocalizedString(), (object) this.target.data.title);
  }

  public class PhaseWait : TutorialParentSystem.Phase
  {
    public int turns;

    public PhaseWait(int turns) => this.turns = turns;

    public override void OnEnable() => global::Events.OnBattleTurnEnd += new UnityAction<int>(this.End);

    public override void OnDisable() => global::Events.OnBattleTurnEnd -= new UnityAction<int>(this.End);

    public void End(int turn)
    {
      if (--this.turns > 0)
        return;
      this.enabled = false;
    }
  }

  public class PhaseWaitDisallowRecall : TutorialParentSystem.Phase
  {
    public int turns;

    public PhaseWaitDisallowRecall(int turns) => this.turns = turns;

    public override void OnEnable()
    {
      global::Events.OnBattleTurnEnd += new UnityAction<int>(this.End);
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
    }

    public override void OnDisable()
    {
      global::Events.OnBattleTurnEnd -= new UnityAction<int>(this.End);
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!this.IsRecallAction(action) && !this.IsEarlyDeployAction(action))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public bool IsRecallAction(PlayAction action) => action is ActionMove actionMove && actionMove.toContainers.Length == 1 && (UnityEngine.Object) actionMove.toContainers[0] == (UnityEngine.Object) References.Player.discardContainer;

    public bool IsEarlyDeployAction(PlayAction action) => action is ActionEarlyDeploy;

    public void End(int turn)
    {
      if (--this.turns > 0)
        return;
      this.enabled = false;
    }
  }

  public class PhaseMoveCompanionInFrontOfLeader : TutorialParentSystem.Phase
  {
    public Entity leader;
    public Entity target;
    public CardSlot leaderSlot;
    public CardSlot targetSlot;

    public PhaseMoveCompanionInFrontOfLeader(Entity target) => this.target = target;

    public override void OnEnable()
    {
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerform);
      foreach (Entity entity in Battle.GetCardsOnBoard(References.Player))
      {
        if (entity.data.cardType.miniboss)
        {
          this.leader = entity;
          break;
        }
      }
      CardSlotLane container = this.leader.containers[0] as CardSlotLane;
      int index1 = container.IndexOf(this.leader);
      this.leaderSlot = container.slots[index1];
      int index2 = Mathf.Max(0, index1 - 1);
      this.targetSlot = container.slots[index2];
      Debug.Log((object) string.Format("Leader is in [{0}]", (object) this.leaderSlot));
      Debug.Log((object) string.Format("[{0}] SHOULD move to [{1}]", (object) this.target.data.title, (object) this.targetSlot));
      if ((UnityEngine.Object) this.targetSlot.GetTop() == (UnityEngine.Object) this.target)
      {
        this.enabled = false;
        Debug.Log((object) string.Format("[{0}] is already in [{1}]", (object) this.target.data.title, (object) this.targetSlot));
        UnityEngine.Object.FindObjectOfType<TutorialBattleSystem2>()?.InsertPhase((TutorialParentSystem.Phase) new TutorialBattleSystem2.PhaseWait(1));
      }
      else
      {
        PromptSystem.Create(Prompt.Anchor.Right, -2f, 1f, 5f, Prompt.Emote.Type.Talk);
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_3.GetLocalizedString(), (object) this.target.data.title)));
        UnityEngine.Object.FindObjectOfType<TutorialBattleSystem2>()?.InsertPhase((TutorialParentSystem.Phase) new TutorialBattleSystem2.PhaseFreeMove());
      }
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerform);
      PromptSystem.Hide();
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!allow || this.CorrectAction(action) || TutorialParentSystem.Phase.InspectAction(action))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public void ActionPerform(PlayAction action)
    {
      if (!this.CorrectAction(action))
        return;
      this.enabled = false;
    }

    public bool CorrectAction(PlayAction action) => action is ActionMove actionMove && actionMove.entity.data.name == this.target.data.name && actionMove.toContainers.Length == 1 && actionMove.toContainers[0] is CardSlot toContainer && (UnityEngine.Object) toContainer == (UnityEngine.Object) this.targetSlot;

    [CompilerGenerated]
    public string \u003COnEnable\u003Eb__5_0() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_3.GetLocalizedString(), (object) this.target.data.title);
  }

  public class PhaseBarrage : TutorialParentSystem.Phase
  {
    public Entity unitToMove;
    public readonly Entity chosenUnit;
    public Entity barrageEnemy;
    public PlayAction correctAction;

    public PhaseBarrage(Entity chosenUnit) => this.chosenUnit = chosenUnit;

    public override void OnEnable()
    {
      this.barrageEnemy = Battle.GetCardsOnBoard(References.Battle.enemy).FirstOrDefault<Entity>((Func<Entity, bool>) (a => a.data.traits.Any<CardData.TraitStacks>((Func<CardData.TraitStacks, bool>) (t => t.data.name == "Barrage"))));
      if (!(bool) (UnityEngine.Object) this.barrageEnemy)
        this.enabled = false;
      else if (References.Battle.GetRowIndex(this.barrageEnemy.containers[0]) != References.Battle.GetRowIndex(this.chosenUnit.containers[0]))
      {
        PromptSystem.Create(Prompt.Anchor.Left, 0.1f, 1f, 5f, Prompt.Emote.Type.Point);
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_41a.GetLocalizedString(), (object) this.barrageEnemy.data.title, (object) this.chosenUnit.data.title)));
        this.unitToMove = this.chosenUnit;
      }
      else
      {
        PromptSystem.Create(Prompt.Anchor.Left, 0.1f, 1f, 5f, Prompt.Emote.Type.Point);
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_41b.GetLocalizedString(), (object) this.barrageEnemy.data.title, (object) this.chosenUnit.data.title)));
        foreach (Entity entity in Battle.GetCardsOnBoard(References.Player))
        {
          if (entity.data.cardType.miniboss)
          {
            this.unitToMove = entity;
            break;
          }
        }
      }
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerform);
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerform);
      PromptSystem.Hide();
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (this.CorrectAction(action))
      {
        this.correctAction = action;
      }
      else
      {
        allow = false;
        PromptSystem.Shake();
      }
    }

    public void ActionPerform(PlayAction action)
    {
      if (this.correctAction == null || action != this.correctAction)
        return;
      this.enabled = false;
    }

    public bool CorrectAction(PlayAction action)
    {
      if (action is ActionMove actionMove && (UnityEngine.Object) actionMove.entity == (UnityEngine.Object) this.unitToMove && actionMove.toContainers.Length == 1)
      {
        CardContainer toContainer = actionMove.toContainers[0];
        if (toContainer != null && Battle.IsOnBoard(toContainer.Group))
          return (UnityEngine.Object) this.unitToMove.containers[0] != (UnityEngine.Object) toContainer.Group;
      }
      return false;
    }

    [CompilerGenerated]
    public string \u003COnEnable\u003Eb__5_2() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_41a.GetLocalizedString(), (object) this.barrageEnemy.data.title, (object) this.chosenUnit.data.title);

    [CompilerGenerated]
    public string \u003COnEnable\u003Eb__5_3() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_41b.GetLocalizedString(), (object) this.barrageEnemy.data.title, (object) this.chosenUnit.data.title);
  }

  public class PhaseFreeMove : TutorialParentSystem.Phase
  {
    public override void OnEnable()
    {
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart += new UnityAction<int>(this.HidePrompt);
      global::Events.OnBattleTurnEnd += new UnityAction<int>(this.End);
      PromptSystem.Create(Prompt.Anchor.Right, -2f, -1f, 5f, Prompt.Emote.Type.Point);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_4.GetLocalizedString()));
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart -= new UnityAction<int>(this.HidePrompt);
      global::Events.OnBattleTurnEnd -= new UnityAction<int>(this.End);
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!allow || !this.IllegalAction(action))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public void HidePrompt(int value) => PromptSystem.Hide();

    public void End(int value) => this.enabled = false;

    public bool IllegalAction(PlayAction action)
    {
      if (TutorialParentSystem.Phase.FreeMoveAction(action))
        return true;
      switch (action)
      {
        case ActionEarlyDeploy _:
          return true;
        case ActionMove actionMove:
          if (actionMove.toContainers.Length == 1 && (UnityEngine.Object) actionMove.toContainers[0] == (UnityEngine.Object) actionMove.entity.owner.discardContainer)
            return true;
          break;
      }
      return false;
    }
  }

  public class PhaseRecallToHeal : TutorialParentSystem.Phase
  {
    public Entity target;
    public WaveDeploySystemOverflow disabledWaveDeploySystem;

    public PhaseRecallToHeal(Entity target) => this.target = target;

    public override void OnEnable()
    {
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerform);
      PromptSystem.Create(Prompt.Anchor.Right, 0.0f, 1f, 5f);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_5.GetLocalizedString(), (object) this.target.data.title)));
      this.disabledWaveDeploySystem = UnityEngine.Object.FindObjectOfType<WaveDeploySystemOverflow>();
      if (!(bool) (UnityEngine.Object) this.disabledWaveDeploySystem)
        return;
      this.disabledWaveDeploySystem.navigationItem.enabled = false;
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerform);
      PromptSystem.Hide();
      if (!(bool) (UnityEngine.Object) this.disabledWaveDeploySystem)
        return;
      this.disabledWaveDeploySystem.navigationItem.enabled = true;
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!allow || this.CorrectAction(action) || TutorialParentSystem.Phase.FreeMoveAction(action) || TutorialParentSystem.Phase.InspectAction(action) || TutorialBattleSystem2.PhaseRecallToHeal.DiscardHealAction(action))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public void ActionPerform(PlayAction action)
    {
      if (!this.CorrectAction(action))
        return;
      this.enabled = false;
    }

    public bool CorrectAction(PlayAction action) => action is ActionMove actionMove && actionMove.entity.data.name == this.target.data.name && actionMove.toContainers.Length == 1 && (UnityEngine.Object) actionMove.toContainers[0] == (UnityEngine.Object) References.Player.discardContainer;

    public static bool DiscardHealAction(PlayAction action) => action is ActionDiscardEffect;

    [CompilerGenerated]
    public string \u003COnEnable\u003Eb__3_0() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_5.GetLocalizedString(), (object) this.target.data.title);
  }

  public class PhaseRecallFree : TutorialParentSystem.Phase
  {
    public override void OnEnable()
    {
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart += new UnityAction<int>(this.End);
      global::Events.OnBattleTurnEnd += new UnityAction<int>(this.End);
      MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_6.GetLocalizedString();
      PromptSystem.Create(Prompt.Anchor.Right, -2f, -1f, 5f, Prompt.Emote.Type.Happy);
      PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_6.GetLocalizedString()));
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart -= new UnityAction<int>(this.End);
      global::Events.OnBattleTurnEnd -= new UnityAction<int>(this.End);
      PromptSystem.Hide();
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!(action is ActionEarlyDeploy))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public void End(int value) => this.enabled = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialBattleSystem3
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class TutorialBattleSystem3 : TutorialBattleSystem
{
  public Entity chosenUnit;

  public override void BattleStart()
  {
    UnityEngine.Object.FindObjectOfType<BattleSaveSystem>()?.Disable();
    this.chosenUnit = TutorialBattleSystem3.FindChosenUnit();
    string[] nextCardNames = new string[6]
    {
      "SnowStick",
      "Sword",
      this.chosenUnit.data.name,
      "SnowStick",
      "PinkberryJuice",
      "Sword"
    };
    References.Player.OrderNextCards(nextCardNames);
    this.phases = new List<TutorialParentSystem.Phase>()
    {
      (TutorialParentSystem.Phase) new TutorialBattleSystem3.PhaseWaitForLeader(),
      (TutorialParentSystem.Phase) new TutorialBattleSystem3.PhasePlaceCompanion(this.chosenUnit)
    };
  }

  public static Entity FindChosenUnit()
  {
    CardData chosenUnitData = References.PlayerData.inventory.deck.OrderByDescending<CardData, int>((Func<CardData, int>) (a => a.hp)).FirstOrDefault<CardData>((Func<CardData, bool>) (a => !a.cardType.miniboss));
    return Battle.GetCards(References.Player).LastOrDefault<Entity>((Func<Entity, bool>) (a => (long) a.data.id == (long) chosenUnitData.id));
  }

  public class PhaseWaitForLeader : TutorialParentSystem.Phase
  {
    public override void OnEnable() => global::Events.OnEntityMove += new UnityAction<Entity>(this.EntityMove);

    public override void OnDisable() => global::Events.OnEntityMove -= new UnityAction<Entity>(this.EntityMove);

    public void EntityMove(Entity entity)
    {
      if (!((UnityEngine.Object) entity.owner == (UnityEngine.Object) References.Player) || !entity.data.cardType.miniboss || !Battle.IsOnBoard(entity))
        return;
      this.enabled = false;
    }
  }

  public class PhasePlaceCompanion : TutorialParentSystem.Phase
  {
    public readonly Entity target;

    public PhasePlaceCompanion(Entity target) => this.target = target;

    public override void OnEnable()
    {
      global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart += new UnityAction<int>(this.BattleTurnStart);
      Routine routine = new Routine(this.PromptAfter(0.5f));
    }

    public override void OnDisable()
    {
      global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
      global::Events.OnBattleTurnStart -= new UnityAction<int>(this.BattleTurnStart);
      PromptSystem.Hide();
    }

    public IEnumerator PromptAfter(float delay)
    {
      TutorialBattleSystem3.PhasePlaceCompanion phasePlaceCompanion = this;
      yield return (object) new WaitForSeconds(delay);
      if (phasePlaceCompanion.enabled)
      {
        PromptSystem.Create(Prompt.Anchor.Left, 0.1f, 2f, 5f);
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle3_1.GetLocalizedString()));
      }
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
      if (!allow || this.CorrectAction(action) || TutorialParentSystem.Phase.FreeMoveAction(action) || TutorialParentSystem.Phase.InspectAction(action))
        return;
      allow = false;
      PromptSystem.Shake();
    }

    public void BattleTurnStart(int turn) => this.enabled = false;

    public bool CorrectAction(PlayAction action) => action is ActionMove actionMove && actionMove.entity.data.name == this.target.data.name && actionMove.toContainers.Length == 1 && Battle.IsOnBoard(actionMove.toContainers[0].Group);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialCharmSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

public class TutorialCharmSystem : TutorialParentSystem
{
  public static bool promptSystemNeedsReset;

  public override void OnEnable()
  {
    if (SaveSystem.LoadProgressData<bool>("tutorialCharmDone", false))
    {
      UnityEngine.Object.Destroy((UnityEngine.Object) this);
    }
    else
    {
      base.OnEnable();
      global::Events.OnDeckpackOpen += new UnityAction(this.DeckpackOpen);
      global::Events.OnDeckpackClose += new UnityAction(this.DeckpackClose);
    }
  }

  public override void OnDisable()
  {
    base.OnDisable();
    global::Events.OnDeckpackOpen -= new UnityAction(this.DeckpackOpen);
    global::Events.OnDeckpackClose -= new UnityAction(this.DeckpackClose);
    TutorialCharmSystem.CheckPromptSystemReset();
  }

  public void DeckpackOpen()
  {
    if (References.PlayerData.inventory.upgrades.Count<CardUpgradeData>((Func<CardUpgradeData, bool>) (a => a.type == CardUpgradeData.Type.Charm)) <= 0)
      return;
    this.phases = new List<TutorialParentSystem.Phase>()
    {
      (TutorialParentSystem.Phase) new TutorialCharmSystem.PhaseEquipCharm(),
      (TutorialParentSystem.Phase) new TutorialCharmSystem.PhaseCharmEquipped()
    };
  }

  public void DeckpackClose()
  {
    this.phases = (List<TutorialParentSystem.Phase>) null;
    if (this.currentPhase != null)
      this.currentPhase.enabled = false;
    this.currentPhase = (TutorialParentSystem.Phase) null;
    this.delay = 0.0f;
    TutorialCharmSystem.CheckPromptSystemReset();
    if (!SaveSystem.LoadProgressData<bool>("tutorialCharmDone", false))
      return;
    UnityEngine.Object.Destroy((UnityEngine.Object) this);
  }

  public static void CheckPromptSystemReset()
  {
    if (!TutorialCharmSystem.promptSystemNeedsReset)
      return;
    PromptSystem.SetSortingLayer("Prompt", 0);
    TutorialCharmSystem.promptSystemNeedsReset = false;
  }

  public static void Done() => SaveSystem.SaveProgressData<bool>("tutorialCharmDone", true);

  public class PhaseEquipCharm : TutorialParentSystem.Phase
  {
    public override void OnEnable()
    {
      global::Events.OnUpgradeAssign += new UnityAction<Entity, CardUpgradeData>(this.UpgradeAssign);
      Routine.Create(this.PromptAfterDelay(1f));
    }

    public override void OnDisable()
    {
      PromptSystem.Hide();
      global::Events.OnUpgradeAssign -= new UnityAction<Entity, CardUpgradeData>(this.UpgradeAssign);
    }

    public void UpgradeAssign(Entity entity, CardUpgradeData upgradeData)
    {
      if (upgradeData.type != CardUpgradeData.Type.Charm)
        return;
      this.enabled = false;
    }

    public IEnumerator PromptAfterDelay(float delay)
    {
      TutorialCharmSystem.PhaseEquipCharm phaseEquipCharm = this;
      yield return (object) new WaitForSeconds(delay);
      if (phaseEquipCharm.enabled)
      {
        PromptSystem.SetSortingLayer("UI", 5);
        PromptSystem.Create(Prompt.Anchor.Left, 2f, 0.5f, 4f, Prompt.Emote.Type.Explain);
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialCharm1.GetLocalizedString()));
        PromptSystem.Prompt.SetEmotePosition(Prompt.Emote.Position.Above, 1f, forceFlip: -1f);
        TutorialCharmSystem.promptSystemNeedsReset = true;
      }
    }
  }

  public class PhaseCharmEquipped : TutorialParentSystem.Phase
  {
    public override void OnEnable()
    {
      global::Events.OnDeckpackClose += new UnityAction(this.DeckpackClose);
      Routine.Create(this.PromptAfterDelay(2f));
      TutorialCharmSystem.Done();
    }

    public override void OnDisable()
    {
      PromptSystem.Hide();
      global::Events.OnDeckpackClose -= new UnityAction(this.DeckpackClose);
    }

    public void DeckpackClose() => this.enabled = false;

    public IEnumerator PromptAfterDelay(float delay)
    {
      TutorialCharmSystem.PhaseCharmEquipped phaseCharmEquipped = this;
      yield return (object) new WaitForSeconds(delay);
      if (phaseCharmEquipped.enabled)
      {
        PromptSystem.SetSortingLayer("UI", 5);
        PromptSystem.Create(Prompt.Anchor.Left, 1f, 1f, 5f, Prompt.Emote.Type.Scared);
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialCharm2.GetLocalizedString()));
        TutorialCharmSystem.promptSystemNeedsReset = true;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialCompanionSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class TutorialCompanionSystem : GameSystem
{
  public EventRoutineCompanion companionEvent;
  public bool init;
  public bool waitForBreak = true;
  public bool waitForInspect;
  public bool inspectDone;
  public float promptDelay;
  public bool prompt2Show;

  public void OnEnable()
  {
    global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
    global::Events.OnEventStart += new UnityAction<CampaignNode, EventRoutine>(this.EventStart);
    global::Events.OnInspect += new UnityAction<Entity>(this.Inspected);
    global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerformed);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
  }

  public void OnDisable()
  {
    global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
    global::Events.OnEventStart -= new UnityAction<CampaignNode, EventRoutine>(this.EventStart);
    global::Events.OnInspect -= new UnityAction<Entity>(this.Inspected);
    global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerformed);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    PromptSystem.Hide();
  }

  public void Init(EventRoutineCompanion companionEvent)
  {
    this.init = true;
    this.companionEvent = companionEvent;
    this.waitForBreak = true;
    this.waitForInspect = false;
    this.inspectDone = false;
  }

  public void Update()
  {
    if (this.init && this.waitForBreak && (Object) this.companionEvent != (Object) null && this.companionEvent.broken)
    {
      this.waitForBreak = false;
      this.waitForInspect = true;
      this.promptDelay = 1f;
    }
    if ((double) this.promptDelay <= 0.0)
      return;
    this.promptDelay -= Time.deltaTime;
    if ((double) this.promptDelay > 0.0)
      return;
    PromptSystem.Create(Prompt.Anchor.TopLeft, 1f, -3f, 5f, Prompt.Emote.Type.Explain);
    PromptSystem.SetTextAction((Prompt.GetTextCallback) (() =>
    {
      if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        return ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialCompanion1Gamepad);
      return !TouchInputModule.active ? ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialCompanion1) : ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialCompanion1Touch);
    }));
  }

  public void CheckAction(ref PlayAction action, ref bool allow)
  {
    if (!this.inspectDone)
    {
      if (action is ActionInspect)
        return;
      allow = false;
      PromptSystem.Shake();
    }
    else
    {
      if (!(action is ActionSelect actionSelect) || !((Object) actionSelect.entity == (Object) null))
        return;
      allow = false;
      if (this.prompt2Show)
      {
        PromptSystem.Shake();
      }
      else
      {
        PromptSystem.Create(Prompt.Anchor.Left, 1f, 1f, 5f);
        PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialCompanion2.GetLocalizedString()));
        this.prompt2Show = true;
      }
    }
  }

  public void EventStart(CampaignNode node, EventRoutine @event)
  {
    if (!(@event is EventRoutineCompanion companionEvent))
      return;
    this.Init(companionEvent);
  }

  public void Inspected(Entity entity)
  {
    if (!this.waitForInspect || this.inspectDone)
      return;
    this.inspectDone = true;
    PromptSystem.Hide();
  }

  public void ActionPerformed(PlayAction action)
  {
    if (!(action is ActionSelect))
      return;
    PromptSystem.Hide();
    this.prompt2Show = false;
  }

  public void SceneChanged(Scene scene) => Object.Destroy((Object) this);
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialCrownSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class TutorialCrownSystem : TutorialParentSystem
{
  public static bool promptSystemNeedsReset;
  public bool deckpackOpen;
  public bool promptShown;

  public override void OnEnable()
  {
    if (SaveSystem.LoadProgressData<bool>("tutorialCrownDone", false))
    {
      Object.Destroy((Object) this);
    }
    else
    {
      base.OnEnable();
      global::Events.OnDeckpackOpen += new UnityAction(this.DeckpackOpen);
      global::Events.OnDeckpackClose += new UnityAction(this.DeckpackClose);
      global::Events.OnUpgradeAssign += new UnityAction<Entity, CardUpgradeData>(this.UpgradeAssign);
    }
  }

  public override void OnDisable()
  {
    base.OnDisable();
    global::Events.OnDeckpackOpen -= new UnityAction(this.DeckpackOpen);
    global::Events.OnDeckpackClose -= new UnityAction(this.DeckpackClose);
    global::Events.OnUpgradeAssign -= new UnityAction<Entity, CardUpgradeData>(this.UpgradeAssign);
    this.HidePrompt();
  }

  public void DeckpackOpen() => this.deckpackOpen = true;

  public void DeckpackClose()
  {
    this.deckpackOpen = false;
    this.HidePrompt();
  }

  public void UpgradeAssign(Entity entity, CardUpgradeData upgradeData)
  {
    if (!this.deckpackOpen || upgradeData.type != CardUpgradeData.Type.Crown)
      return;
    this.ShowPrompt();
    SaveSystem.SaveProgressData<bool>("tutorialCrownDone", true);
  }

  public void ShowPrompt()
  {
    if (this.promptShown)
      return;
    PromptSystem.Hide();
    PromptSystem.SetSortingLayer("UI", 5);
    PromptSystem.Create(Prompt.Anchor.Left, 2f, 0.5f, 4f, Prompt.Emote.Type.Point);
    PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialCrown.GetLocalizedString()));
    TutorialCrownSystem.promptSystemNeedsReset = true;
    this.promptShown = true;
  }

  public void HidePrompt()
  {
    if (!this.promptShown)
      return;
    PromptSystem.Hide();
    TutorialCrownSystem.CheckPromptSystemReset();
  }

  public static void CheckPromptSystemReset()
  {
    if (!TutorialCrownSystem.promptSystemNeedsReset)
      return;
    PromptSystem.SetSortingLayer("Prompt", 0);
    TutorialCrownSystem.promptSystemNeedsReset = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialInjurySystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class TutorialInjurySystem : TutorialParentSystem
{
  public bool promptShown;

  public override void OnEnable()
  {
    if (SaveSystem.LoadProgressData<bool>("tutorialInjuryDone", false))
    {
      UnityEngine.Object.Destroy((UnityEngine.Object) this);
    }
    else
    {
      base.OnEnable();
      global::Events.OnBattleEnd += new UnityAction(this.BattleEnd);
      global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    }
  }

  public override void OnDisable()
  {
    base.OnDisable();
    global::Events.OnBattleEnd -= new UnityAction(this.BattleEnd);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
  }

  public void SceneChanged(Scene scene)
  {
    if (this.promptShown)
    {
      PromptSystem.Hide();
      this.promptShown = false;
    }
    if (!SaveSystem.LoadProgressData<bool>("tutorialInjuryDone", false))
      return;
    UnityEngine.Object.Destroy((UnityEngine.Object) this);
  }

  public void BattleEnd()
  {
    if (!((UnityEngine.Object) References.Battle.winner == (UnityEngine.Object) References.Battle.player))
      return;
    CardData[] injuriesThisBattle = InjurySystem.GetInjuriesThisBattle();
    if (injuriesThisBattle.Length == 0)
      return;
    this.StartCoroutine(this.Routine(injuriesThisBattle));
  }

  public IEnumerator Routine(CardData[] injuries)
  {
    yield return (object) TutorialInjurySystem.WaitForInjuriesPanel();
    PromptSystem.Create(Prompt.Anchor.Left, 0.5f, 0.0f, 5f, Prompt.Emote.Type.Sad);
    PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => injuries.Length != 1 ? MonoBehaviourSingleton<StringReference>.instance.tutorialInjuryMultiple.GetLocalizedString() : string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialInjury.GetLocalizedString(), (object) injuries[0].title)));
    this.promptShown = true;
    SaveSystem.SaveProgressData<bool>("tutorialInjuryDone", true);
  }

  public static IEnumerator WaitForInjuriesPanel()
  {
    yield return (object) new WaitUntil((Func<bool>) (() => SceneManager.IsLoaded("BattleWin")));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialItemSystem1
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class TutorialItemSystem1 : GameSystem
{
  public string[] items;

  public void OnEnable() => global::Events.OnEventStart += new UnityAction<CampaignNode, EventRoutine>(this.EventStart);

  public void OnDisable() => global::Events.OnEventStart -= new UnityAction<CampaignNode, EventRoutine>(this.EventStart);

  public void SetItems(string[] items) => this.items = items;

  public void EventStart(CampaignNode node, EventRoutine @event)
  {
    if (@event is ItemEventRoutine)
      node.data["cards"] = (object) new SaveCollection<string>(this.items);
    Object.Destroy((Object) this);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialItemSystem2
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class TutorialItemSystem2 : GameSystem
{
  public bool init;
  public ItemEventRoutine itemEvent;
  public bool waitForOpen;
  public float promptDelay;

  public void OnEnable()
  {
    global::Events.OnEventStart += new UnityAction<CampaignNode, EventRoutine>(this.EventStart);
    global::Events.OnActionPerform += new UnityAction<PlayAction>(TutorialItemSystem2.ActionPerformed);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
  }

  public void OnDisable()
  {
    global::Events.OnEventStart -= new UnityAction<CampaignNode, EventRoutine>(this.EventStart);
    global::Events.OnActionPerform -= new UnityAction<PlayAction>(TutorialItemSystem2.ActionPerformed);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    PromptSystem.Hide();
  }

  public void Init(ItemEventRoutine itemEvent)
  {
    this.init = true;
    this.itemEvent = itemEvent;
    this.waitForOpen = true;
  }

  public void Update()
  {
    if (this.init && this.waitForOpen && (bool) (Object) this.itemEvent && this.itemEvent.IsOpen)
    {
      this.waitForOpen = false;
      this.promptDelay = 1.5f;
    }
    if ((double) this.promptDelay <= 0.0)
      return;
    this.promptDelay -= Time.deltaTime;
    if ((double) this.promptDelay > 0.0)
      return;
    PromptSystem.Create(Prompt.Anchor.Left, 0.5f, 0.5f, 4f, Prompt.Emote.Type.Explain);
    PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => MonoBehaviourSingleton<StringReference>.instance.tutorialItem.GetLocalizedString()));
  }

  public void EventStart(CampaignNode node, EventRoutine @event)
  {
    if (!(@event is ItemEventRoutine itemEvent))
      return;
    this.Init(itemEvent);
  }

  public static void ActionPerformed(PlayAction action)
  {
    if (!(action is ActionSelect))
      return;
    PromptSystem.Hide();
  }

  public void SceneChanged(Scene scene) => Object.Destroy((Object) this);
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialParentSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class TutorialParentSystem : GameSystem
{
  public float delay;
  public const float delayBetween = 0.0f;
  public TutorialParentSystem.Phase currentPhase;
  public List<TutorialParentSystem.Phase> phases;

  public virtual void OnEnable()
  {
  }

  public virtual void OnDisable()
  {
    if (this.currentPhase == null)
      return;
    this.currentPhase.enabled = false;
    this.currentPhase = (TutorialParentSystem.Phase) null;
  }

  public virtual void Update()
  {
    if ((double) this.delay > 0.0)
    {
      this.delay -= Time.deltaTime;
    }
    else
    {
      if (this.phases == null || this.phases.Count <= 0)
        return;
      if (this.currentPhase == null)
      {
        this.currentPhase = this.phases[0];
        this.phases.RemoveAt(0);
        this.currentPhase.enabled = true;
      }
      else
      {
        if (this.currentPhase.enabled)
          return;
        this.currentPhase = (TutorialParentSystem.Phase) null;
        this.delay = 0.0f;
        if (this.phases.Count <= 0)
          return;
        this.delay += this.phases[0].delay;
      }
    }
  }

  public abstract class Phase
  {
    public bool _enabled;

    public bool enabled
    {
      get => this._enabled;
      set
      {
        bool enabled = this._enabled;
        this._enabled = value;
        if (this._enabled)
        {
          if (enabled)
            return;
          this.OnEnable();
        }
        else
        {
          if (!enabled)
            return;
          this.OnDisable();
        }
      }
    }

    public virtual float delay => 0.0f;

    public virtual void OnEnable()
    {
    }

    public virtual void OnDisable()
    {
    }

    public static bool FreeMoveAction(PlayAction action) => action is ActionMove actionMove && Battle.IsOnBoard(actionMove.entity) && Battle.IsOnBoard(actionMove.toContainers);

    public static bool InspectAction(PlayAction action) => action is ActionInspect;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TutorialSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;
using UnityEngine.SceneManagement;

public class TutorialSystem : GameSystem
{
  public LocalizedString redrawBellHelpKey;
  public Prompt.Emote.Type redrawBellHelpEmote = Prompt.Emote.Type.Explain;
  public LocalizedString redrawBellHelpButtonKey;
  public Sprite redrawBellHelpSprite;
  public TutorialSystem.Data data;

  public void OnEnable()
  {
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnCampaignSaved += new UnityAction(this.CampaignSaved);
    global::Events.OnCampaignLoaded += new UnityAction(this.CampaignLoaded);
  }

  public void OnDisable()
  {
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnCampaignSaved -= new UnityAction(this.CampaignSaved);
    global::Events.OnCampaignLoaded -= new UnityAction(this.CampaignLoaded);
  }

  public void SceneChanged(Scene scene)
  {
    switch (scene.name)
    {
      case "Battle":
        switch (this.data.battleNumber)
        {
          case 0:
            this.gameObject.AddComponent<TutorialBattleSystem1>();
            SaveSystem.SaveProgressData<int>("tutorialProgress", 1);
            global::Events.InvokeTutorialProgress(1);
            break;
          case 1:
            this.gameObject.AddComponent<TutorialBattleSystem2>();
            break;
          case 2:
            this.gameObject.AddComponent<TutorialBattleSystem3>();
            DynamicTutorialSystem objectOfType = UnityEngine.Object.FindObjectOfType<DynamicTutorialSystem>();
            if (objectOfType != null)
              objectOfType.enabled = true;
            SaveSystem.SaveProgressData<int>("tutorialProgress", 2);
            global::Events.InvokeTutorialProgress(2);
            break;
        }
        ++this.data.battleNumber;
        break;
      case "Event":
        switch (this.data.eventNumber)
        {
          case 0:
            this.gameObject.AddComponent<TutorialCompanionSystem>();
            break;
          case 2:
            this.gameObject.AddComponent<TutorialItemSystem2>();
            break;
        }
        ++this.data.eventNumber;
        break;
    }
  }

  public void CampaignSaved() => SaveSystem.SaveCampaignData<TutorialSystem.Data>(Campaign.Data.GameMode, "tutorialData", this.data);

  public void CampaignLoaded() => this.data = SaveSystem.LoadCampaignData<TutorialSystem.Data>(Campaign.Data.GameMode, "tutorialData", new TutorialSystem.Data());

  [Serializable]
  public struct Data
  {
    public int battleNumber;
    public int eventNumber;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Tween
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

[Serializable]
public struct Tween
{
  public LeanTweenType ease;
  public float dur;
  public bool hasFrom;
  public float scaleFrom;
  public float scaleTo;

  public void Run(GameObject gameObject)
  {
    LeanTween.cancel(gameObject);
    LeanTween.scale(gameObject, Vector3.one * this.scaleTo, this.dur).setEase(this.ease).setFrom(this.hasFrom ? Vector3.one * this.scaleFrom : gameObject.transform.localScale);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: TweenAction
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public enum TweenAction
{
  MOVE_X,
  MOVE_Y,
  MOVE_Z,
  MOVE_LOCAL_X,
  MOVE_LOCAL_Y,
  MOVE_LOCAL_Z,
  MOVE_CURVED,
  MOVE_CURVED_LOCAL,
  MOVE_SPLINE,
  MOVE_SPLINE_LOCAL,
  SCALE_X,
  SCALE_Y,
  SCALE_Z,
  ROTATE_X,
  ROTATE_Y,
  ROTATE_Z,
  ROTATE_AROUND,
  ROTATE_AROUND_LOCAL,
  CANVAS_ROTATEAROUND,
  CANVAS_ROTATEAROUND_LOCAL,
  CANVAS_PLAYSPRITE,
  ALPHA,
  TEXT_ALPHA,
  CANVAS_ALPHA,
  CANVASGROUP_ALPHA,
  ALPHA_VERTEX,
  COLOR,
  CALLBACK_COLOR,
  TEXT_COLOR,
  CANVAS_COLOR,
  CANVAS_MOVE_X,
  CANVAS_MOVE_Y,
  CANVAS_MOVE_Z,
  CALLBACK,
  MOVE,
  MOVE_LOCAL,
  MOVE_TO_TRANSFORM,
  ROTATE,
  ROTATE_LOCAL,
  SCALE,
  VALUE3,
  GUI_MOVE,
  GUI_MOVE_MARGIN,
  GUI_SCALE,
  GUI_ALPHA,
  GUI_ROTATE,
  DELAYED_SOUND,
  CANVAS_MOVE,
  CANVAS_SCALE,
  CANVAS_SIZEDELTA,
  FOLLOW,
}
﻿// Decompiled with JetBrains decompiler
// Type: TweenProfile
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

[Serializable]
public struct TweenProfile
{
  public LeanTweenType ease;
  public float duration;
}
﻿// Decompiled with JetBrains decompiler
// Type: TweenUI
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

public class TweenUI : MonoBehaviour
{
  [SerializeField]
  public GameObject target;
  [SerializeField]
  [HideIf("fireOnStart")]
  public bool fireOnEnable;
  [SerializeField]
  [HideIf("fireOnEnable")]
  public bool fireOnStart;
  [SerializeField]
  [HideIf("FireOnStart")]
  public bool enableOnFire;
  [SerializeField]
  public bool disableAfter;
  [SerializeField]
  public bool multi;
  [SerializeField]
  [HideIf("multi")]
  public TweenUI.Property property;
  [SerializeField]
  [HideIf("multi")]
  public LeanTweenType ease;
  [SerializeField]
  [HideIf("multi")]
  [ShowIf("IsAnimationCurve")]
  public AnimationCurve animationCurve;
  [SerializeField]
  [HideIf("multi")]
  public bool randomSigns;
  [Header("Duration")]
  [SerializeField]
  [HideIf("multi")]
  public bool randomDuration;
  [SerializeField]
  [HideIf("multiOrRandomDuration")]
  public float duration;
  [SerializeField]
  [HideIf("multi")]
  [ShowIf("randomDuration")]
  public Vector2 durationRange;
  [Header("Delay")]
  [SerializeField]
  [HideIf("multi")]
  public bool randomDelay;
  [SerializeField]
  [HideIf("multiOrRandomDelay")]
  public float delay;
  [SerializeField]
  [HideIf("multi")]
  [ShowIf("randomDelay")]
  public Vector2 delayRange;
  [Header("Values")]
  [SerializeField]
  [HideIf("multi")]
  public Vector3 to;
  [SerializeField]
  [HideIf("multi")]
  public bool hasFrom;
  [SerializeField]
  [HideIf("multi")]
  [ShowIf("hasFrom")]
  public Vector3 from;
  [SerializeField]
  [ShowIf("multi")]
  public TweenUI.Tween[] tweens;
  [SerializeField]
  public bool cancelOtherTweens = true;
  [SerializeField]
  public bool ignoreTimeScale;

  public bool multiOrRandomDuration => this.multi || this.randomDuration;

  public bool multiOrRandomDelay => this.multi || this.randomDelay;

  public bool IsAnimationCurve => this.ease == LeanTweenType.animationCurve;

  public bool FireOnStart => this.fireOnEnable || this.fireOnStart;

  public void OnEnable()
  {
    if (!this.fireOnEnable)
      return;
    this.Fire();
  }

  public void Start()
  {
    if (!this.fireOnStart)
      return;
    this.Fire();
  }

  public void Fire()
  {
    if (this.enableOnFire && !this.FireOnStart)
      this.target.gameObject.SetActive(true);
    if (this.cancelOtherTweens)
      LeanTween.cancel(this.target);
    if (this.multi)
    {
      this.delay = 0.0f;
      this.duration = 0.0f;
      foreach (TweenUI.Tween tween in this.tweens)
      {
        tween.Fire(this.target, this.ignoreTimeScale);
        this.delay = Mathf.Max(this.delay, tween.delay);
        this.duration = Mathf.Max(this.duration, tween.duration);
      }
      if (!this.disableAfter)
        return;
      LeanTween.value(this.target, 0.0f, 0.0f, this.delay + this.duration).setIgnoreTimeScale(this.ignoreTimeScale).setOnComplete((System.Action) (() => this.target.gameObject.SetActive(false)));
    }
    else
    {
      if (this.randomDuration)
        this.duration = this.durationRange.PettyRandom();
      if (this.randomDelay)
        this.delay = this.delayRange.PettyRandom();
      LTDescr ltDescr = (LTDescr) null;
      switch (this.property)
      {
        case TweenUI.Property.Move:
          if (this.hasFrom)
            this.target.transform.localPosition = this.GetFrom();
          ltDescr = LeanTween.moveLocal(this.target, this.to, this.duration);
          break;
        case TweenUI.Property.Rotate:
          if (this.hasFrom)
            this.target.transform.localEulerAngles = this.GetFrom();
          ltDescr = LeanTween.rotateLocal(this.target, this.to, this.duration);
          break;
        case TweenUI.Property.Scale:
          if (this.hasFrom)
            this.target.transform.localScale = this.GetFrom();
          ltDescr = LeanTween.scale(this.target, this.to, this.duration);
          break;
      }
      if (ltDescr == null)
        return;
      if (this.ignoreTimeScale)
        ltDescr.setIgnoreTimeScale(true);
      if ((double) this.delay > 0.0)
        ltDescr.setDelay(this.delay);
      if (this.IsAnimationCurve)
        ltDescr.setEase(this.animationCurve);
      else
        ltDescr.setEase(this.ease);
      if (!this.disableAfter)
        return;
      ltDescr.setOnComplete((System.Action) (() => this.target.gameObject.SetActive(false)));
    }
  }

  public float GetDuration() => this.delay + this.duration;

  public Vector3 GetFrom() => !this.randomSigns ? this.from : this.from.With(new float?(this.from.x.WithRandomSign()), new float?(this.from.y.WithRandomSign()), new float?(this.from.z.WithRandomSign()));

  [CompilerGenerated]
  public void \u003CFire\u003Eb__33_0() => this.target.gameObject.SetActive(false);

  [CompilerGenerated]
  public void \u003CFire\u003Eb__33_1() => this.target.gameObject.SetActive(false);

  public enum Property
  {
    Move,
    Rotate,
    Scale,
  }

  [Serializable]
  public struct Tween
  {
    public TweenUI.Property property;
    public LeanTweenType ease;
    public AnimationCurve curve;
    public bool randomSigns;
    [Header("Duration")]
    public float duration;
    [Header("Delay")]
    public float delay;
    [Header("Values")]
    public Vector3 to;
    public bool hasFrom;
    public Vector3 from;

    public void Fire(GameObject target, bool ignoreTimeScale)
    {
      LTDescr ltDescr = (LTDescr) null;
      switch (this.property)
      {
        case TweenUI.Property.Move:
          if (this.hasFrom)
            target.transform.localPosition = this.GetFrom();
          ltDescr = LeanTween.moveLocal(target, this.to, this.duration);
          break;
        case TweenUI.Property.Rotate:
          if (this.hasFrom)
            target.transform.localEulerAngles = this.GetFrom();
          ltDescr = LeanTween.rotateLocal(target, this.to, this.duration);
          break;
        case TweenUI.Property.Scale:
          if (this.hasFrom)
            target.transform.localScale = this.GetFrom();
          ltDescr = LeanTween.scale(target, this.to, this.duration);
          break;
      }
      if (ignoreTimeScale)
        ltDescr.setIgnoreTimeScale(true);
      if ((double) this.delay > 0.0 && ltDescr != null)
        ltDescr.setDelay(this.delay);
      if (this.ease == LeanTweenType.animationCurve)
        ltDescr?.setEase(this.curve);
      else
        ltDescr?.setEase(this.ease);
    }

    public Vector3 GetFrom() => !this.randomSigns ? this.from : this.from.With(new float?(this.from.x.WithRandomSign()), new float?(this.from.y.WithRandomSign()), new float?(this.from.z.WithRandomSign()));
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UIAnchor
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class UIAnchor : MonoBehaviour
{
  public float revealDur = 0.75f;
  public float hideDur = 0.25f;
  [Header("Rotation")]
  public Vector3 angleStart = new Vector3(45f, 90f, 0.0f);
  public bool angleRandomSign = true;
  public LeanTweenType angleTweenEase = LeanTweenType.easeOutBack;
  [Header("Rotation Hide")]
  public Vector3 angleHide = new Vector3(45f, 90f, 0.0f);
  public bool angleHideRandomSign = true;
  public LeanTweenType angleHideTweenEase = LeanTweenType.easeInBack;
  [Header("Scale")]
  public Vector3 scaleStart = Vector3.one;
  public LeanTweenType scaleTweenEase = LeanTweenType.easeInQuart;
  [Header("Scale Hide")]
  public Vector3 scaleHide = Vector3.zero;
  public LeanTweenType scaleHideTweenEase = LeanTweenType.easeInBack;
  [Header("Wobble?")]
  public float wobbleAmount = 2f;
  [Header("Fade In?")]
  public bool doFadeIn = true;
  public float fadeInDur = 0.25f;
  public bool doFadeOut = true;
  public float fadeOutDur = 0.25f;

  public void SetUp()
  {
    if (this.angleRandomSign)
      this.transform.localEulerAngles = new Vector3(this.angleStart.x.WithRandomSign(), this.angleStart.y.WithRandomSign(), this.angleStart.z.WithRandomSign());
    else
      this.transform.localEulerAngles = this.angleStart;
    this.transform.localScale = this.scaleStart;
    if (!this.doFadeIn)
      return;
    CanvasGroup component = this.GetComponent<CanvasGroup>();
    if (!((Object) component != (Object) null))
      return;
    component.alpha = 0.0f;
  }

  public void Reveal()
  {
    LeanTween.cancel(this.gameObject);
    Vector3 zero = Vector3.zero;
    if (this.transform.localEulerAngles != zero)
      LeanTween.rotateLocal(this.gameObject, zero, this.revealDur).setEase(this.angleTweenEase);
    Vector3 one = Vector3.one;
    if (this.transform.localScale != one)
      LeanTween.scale(this.gameObject, one, this.revealDur).setEase(this.scaleTweenEase);
    if (this.doFadeIn && (double) this.fadeInDur > 0.0)
    {
      CanvasGroup component = this.GetComponent<CanvasGroup>();
      if ((Object) component != (Object) null)
        component.LeanAlpha(1f, this.fadeInDur).setEase(LeanTweenType.linear);
    }
    if ((double) this.wobbleAmount <= 0.0)
      return;
    Vector3 vector3 = -(this.transform.localEulerAngles / 90f) * this.wobbleAmount;
    this.transform.GetComponentInChildren<Wobbler>()?.Wobble(new Vector3(vector3.y, vector3.x, 0.0f));
  }

  public void UnReveal(float delay = 0.0f)
  {
    LeanTween.cancel(this.gameObject);
    Vector3 angleHide = this.angleHide;
    if (this.transform.localEulerAngles != angleHide)
      LeanTween.rotateLocal(this.gameObject, angleHide, this.hideDur).setDelay(delay).setEase(this.angleHideTweenEase);
    Vector3 scaleHide = this.scaleHide;
    if (this.transform.localScale != scaleHide)
      LeanTween.scale(this.gameObject, scaleHide, this.hideDur).setDelay(delay).setEase(this.scaleHideTweenEase);
    if (!this.doFadeOut || (double) this.fadeOutDur <= 0.0)
      return;
    CanvasGroup component = this.GetComponent<CanvasGroup>();
    if (!((Object) component != (Object) null))
      return;
    component.LeanAlpha(0.0f, this.fadeOutDur).setDelay(delay).setEase(LeanTweenType.linear);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UIAnchors
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class UIAnchors : MonoBehaviour
{
  public UIAnchors.AnchorPoint[] list;

  public int Count => this.list.Length;

  public void Activate(int anchorIndex) => this.list[anchorIndex].Activate();

  public void Deactivate(int anchorIndex) => this.list[anchorIndex].Deactivate();

  public IEnumerator Reveal(int anchorIndex)
  {
    UIAnchors.AnchorPoint anchorPoint = this.list[anchorIndex];
    UIAnchor target = anchorPoint.target;
    RectTransform anchor = anchorPoint.anchor;
    target.Reveal();
    yield return (object) Sequences.Wait(target.revealDur);
  }

  public IEnumerator UnReveal(int anchorIndex, float delay = 0.0f)
  {
    UIAnchor target = this.list[anchorIndex].target;
    target.UnReveal(delay);
    yield return (object) Sequences.Wait(target.hideDur + delay);
  }

  [Button(null, EButtonEnableMode.Always)]
  public void PromptUpdate() => this.StartCoroutine(this.UpdatePositions());

  [Button(null, EButtonEnableMode.Always)]
  public void SetPositions()
  {
    foreach (UIAnchors.AnchorPoint anchorPoint in this.list)
      anchorPoint.target.transform.position = anchorPoint.anchor.transform.position;
  }

  public IEnumerator UpdatePositions()
  {
    List<Routine> routines = new List<Routine>();
    foreach (UIAnchors.AnchorPoint anchorPoint in this.list)
    {
      if (anchorPoint.target.gameObject.activeSelf)
        routines.Add(new Routine(anchorPoint.Move()));
    }
    bool routinesDone = false;
    while (!routinesDone)
    {
      routinesDone = true;
      foreach (Routine routine in routines)
      {
        if (routine != null && routine.IsRunning)
        {
          routinesDone = false;
          break;
        }
      }
      yield return (object) null;
    }
  }

  [Serializable]
  public class AnchorPoint
  {
    public UIAnchor target;
    public RectTransform anchor;

    public void Activate()
    {
      this.target.gameObject.SetActive(true);
      this.anchor.gameObject.SetActive(true);
    }

    public void Deactivate()
    {
      this.target.gameObject.SetActive(false);
      this.anchor.gameObject.SetActive(false);
    }

    public void SetUp() => this.target.SetUp();

    public IEnumerator Move(float dur = 0.75f, LeanTweenType ease = LeanTweenType.easeOutBack)
    {
      LeanTween.move(this.target.gameObject, this.anchor.position, dur).setEase(ease);
      Vector3 movement = this.anchor.position - this.target.transform.position;
      this.target.GetComponentInChildren<Wobbler>()?.Wobble(movement);
      yield return (object) Sequences.Wait(dur);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UINavigationDefaultSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public static class UINavigationDefaultSystem
{
  public static void SetStartingItem(bool useClosest = true, bool ignoreHistory = false)
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      return;
    Debug.Log((object) "UINavigationDefaultSystem → Finding Default Item");
    if (!MonoBehaviourSingleton<UINavigationSystem>.instance.AvailableNavigationItems.Any<UINavigationItem>())
    {
      Debug.Log((object) "UINavigationDefaultSystem → no available navigation items");
    }
    else
    {
      List<UINavigationItem> list = MonoBehaviourSingleton<UINavigationSystem>.instance.AvailableNavigationItems.Where<UINavigationItem>((Func<UINavigationItem, bool>) (item => (UnityEngine.Object) item != (UnityEngine.Object) null && item.CheckLayer())).ToList<UINavigationItem>();
      if (list.Count <= 0)
      {
        Debug.Log((object) "UINavigationDefaultSystem → no possible items on current navigation layer");
      }
      else
      {
        if (list.Count == 1)
          MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(list[0]);
        else
          MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem((!useClosest ? (!ignoreHistory ? (IEnumerable<UINavigationItem>) list.OrderByDescending<UINavigationItem, int>((Func<UINavigationItem, int>) (a => !UINavigationHistory.items.Contains(a) ? (int) a.selectionPriority : (int) (UINavigationHistory.items.IndexOf(a) + a.selectionPriority))).ThenBy<UINavigationItem, float>((Func<UINavigationItem, float>) (a => Vector3.Distance(MonoBehaviourSingleton<Cursor3d>.instance.transform.position, a.Position))).ToList<UINavigationItem>() : (IEnumerable<UINavigationItem>) list.OrderByDescending<UINavigationItem, int>((Func<UINavigationItem, int>) (a => (int) a.selectionPriority)).ThenBy<UINavigationItem, float>((Func<UINavigationItem, float>) (a => Vector3.Distance(MonoBehaviourSingleton<Cursor3d>.instance.transform.position, a.Position))).ToList<UINavigationItem>()) : (!ignoreHistory ? (IEnumerable<UINavigationItem>) list.OrderBy<UINavigationItem, float>((Func<UINavigationItem, float>) (a => Vector3.Distance(MonoBehaviourSingleton<Cursor3d>.instance.transform.position, a.Position) - (float) a.selectionPriority)).ThenByDescending<UINavigationItem, int>((Func<UINavigationItem, int>) (a => !UINavigationHistory.items.Contains(a) ? (int) a.selectionPriority : (int) (UINavigationHistory.items.IndexOf(a) + a.selectionPriority))).ToList<UINavigationItem>() : (IEnumerable<UINavigationItem>) list.OrderBy<UINavigationItem, float>((Func<UINavigationItem, float>) (a => Vector3.Distance(MonoBehaviourSingleton<Cursor3d>.instance.transform.position, a.Position) - (float) a.selectionPriority)).ThenByDescending<UINavigationItem, int>((Func<UINavigationItem, int>) (a => (int) a.selectionPriority)).ToList<UINavigationItem>())).First<UINavigationItem>());
        Debug.Log((object) string.Format("UINavigationDefaultSystem → Default Item Set: {0}", (object) MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem));
      }
    }
  }

  public static void SetDefaultTarget(Entity entity)
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse || !MonoBehaviourSingleton<UINavigationSystem>.instance.AvailableNavigationItems.Any<UINavigationItem>())
      return;
    CardData.PlayPosition playPosition = UINavigationDefaultSystem.GetPlayPosition(entity);
    List<UINavigationItem> list = UINavigationDefaultSystem.GetDefaultTargets(entity, playPosition).Intersect<UINavigationItem>((IEnumerable<UINavigationItem>) MonoBehaviourSingleton<UINavigationSystem>.instance.AvailableNavigationItems).Where<UINavigationItem>((Func<UINavigationItem, bool>) (item => (UnityEngine.Object) item != (UnityEngine.Object) null && item.CheckLayer())).ToList<UINavigationItem>();
    if (list.Count <= 0)
      UINavigationDefaultSystem.SetStartingItem();
    else if (list.Count == 1)
      MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(list[0]);
    else
      MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(list.OrderBy<UINavigationItem, float>((Func<UINavigationItem, float>) (a => Vector3.Distance(MonoBehaviourSingleton<Cursor3d>.instance.transform.position, a.Position) - (float) a.selectionPriority - (float) UINavigationHistory.GetItemIndex(a))).ToList<UINavigationItem>().First<UINavigationItem>());
  }

  public static CardData.PlayPosition GetPlayPosition(Entity entity)
  {
    if (entity.data.playType == Card.PlayType.Place)
      return CardData.PlayPosition.FriendlySlot;
    if (entity.data.defaultPlayPosition != CardData.PlayPosition.None)
      return entity.data.defaultPlayPosition;
    if (!entity.NeedsTarget)
      return CardData.PlayPosition.None;
    if (entity.data.playOnSlot)
    {
      if (entity.data.canPlayOnFriendly)
        return CardData.PlayPosition.FriendlySlot;
      return !entity.data.canPlayOnEnemy ? CardData.PlayPosition.None : CardData.PlayPosition.EnemySlot;
    }
    return entity.IsOffensive() ? (!entity.targetMode.TargetRow ? CardData.PlayPosition.Enemy : CardData.PlayPosition.EnemyRow) : (!entity.targetMode.TargetRow ? CardData.PlayPosition.Friendly : CardData.PlayPosition.FriendlyRow);
  }

  public static IEnumerable<UINavigationItem> GetDefaultTargets(
    Entity entity,
    CardData.PlayPosition playPosition)
  {
    List<UINavigationItem> defaultTargets;
    switch (playPosition)
    {
      case CardData.PlayPosition.Friendly:
        defaultTargets = Battle.GetCardsOnBoard(entity.owner).Select<Entity, UINavigationItem>((Func<Entity, UINavigationItem>) (a => a.uINavigationItem)).ToList<UINavigationItem>();
        break;
      case CardData.PlayPosition.Enemy:
        defaultTargets = Battle.GetCardsOnBoard(Battle.GetOpponent(entity.owner)).Select<Entity, UINavigationItem>((Func<Entity, UINavigationItem>) (a => a.uINavigationItem)).ToList<UINavigationItem>();
        break;
      case CardData.PlayPosition.FriendlyRow:
        defaultTargets = References.Battle.GetRows(entity.owner).Select<CardContainer, UINavigationItem>((Func<CardContainer, UINavigationItem>) (a => a.nav)).ToList<UINavigationItem>();
        break;
      case CardData.PlayPosition.EnemyRow:
        defaultTargets = References.Battle.GetRows(Battle.GetOpponent(entity.owner)).Select<CardContainer, UINavigationItem>((Func<CardContainer, UINavigationItem>) (a => a.nav)).ToList<UINavigationItem>();
        break;
      case CardData.PlayPosition.FriendlySlot:
        defaultTargets = Battle.IsOnBoard(entity) ? entity.actualContainers.Select<CardContainer, UINavigationItem>((Func<CardContainer, UINavigationItem>) (a => a.nav)).ToList<UINavigationItem>() : References.Battle.GetSlots(entity.owner).Select<CardSlot, UINavigationItem>((Func<CardSlot, UINavigationItem>) (a => a.nav)).ToList<UINavigationItem>();
        break;
      case CardData.PlayPosition.EnemySlot:
        defaultTargets = References.Battle.GetSlots(Battle.GetOpponent(entity.owner)).Select<CardSlot, UINavigationItem>((Func<CardSlot, UINavigationItem>) (a => a.nav)).ToList<UINavigationItem>();
        break;
      default:
        defaultTargets = new List<UINavigationItem>();
        break;
    }
    return (IEnumerable<UINavigationItem>) defaultTargets;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UINavigationHistory
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;

public static class UINavigationHistory
{
  public static readonly List<UINavigationHistory.Layer> layers = new List<UINavigationHistory.Layer>();
  public static readonly List<UINavigationItem> items = new List<UINavigationItem>(10);
  public const int capacity = 10;

  public static void AddItem(UINavigationItem item)
  {
    UINavigationHistory.items.Add(item);
    if (UINavigationHistory.items.Count <= 10)
      return;
    UINavigationHistory.items.RemoveAt(0);
  }

  public static int GetItemIndex(UINavigationItem item) => !UINavigationHistory.items.Contains(item) ? 0 : UINavigationHistory.items.IndexOf(item);

  public static void AddLayer(UINavigationLayer navLayer) => UINavigationHistory.layers.Add(new UINavigationHistory.Layer(navLayer));

  public static void Clear()
  {
    UINavigationHistory.layers.Clear();
    UINavigationHistory.items.Clear();
  }

  public static void GoBackALayer()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      return;
    if (UINavigationHistory.layers.Count > 0)
    {
      UINavigationHistory.Layer layer = UINavigationHistory.layers.FirstOrDefault<UINavigationHistory.Layer>((Func<UINavigationHistory.Layer, bool>) (a => (UnityEngine.Object) a.navigationLayer == (UnityEngine.Object) UINavigationSystem.ActiveNavigationLayer));
      if (layer != null && layer.navigationItemHistory.Count > 0)
      {
        MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(layer.navigationItemHistory.Last<UINavigationItem>());
        return;
      }
    }
    UINavigationDefaultSystem.SetStartingItem(false);
  }

  [Serializable]
  public class Layer
  {
    public UINavigationLayer navigationLayer;
    public readonly List<UINavigationItem> navigationItemHistory = new List<UINavigationItem>();

    public Layer(UINavigationLayer navigationLayer) => this.navigationLayer = navigationLayer;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UINavigationItem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class UINavigationItem : MonoBehaviour
{
  public UINavigationLayer navigationLayer;
  public Vector3 offset;
  public UINavigationItem.SelectionPriority selectionPriority;
  public GameObject clickHandler;
  public bool isHighlighted;
  public bool canLoop;
  public bool ignoreLayers;
  public bool isSelectable = true;
  public bool overrideInputs;
  [ShowIf("overrideInputs")]
  public UINavigationItem inputLeft;
  [ShowIf("overrideInputs")]
  public UINavigationItem inputRight;
  [ShowIf("overrideInputs")]
  public UINavigationItem inputUp;
  [ShowIf("overrideInputs")]
  public UINavigationItem inputDown;
  [HideIf("overrideInputs")]
  public bool overrideHorizontal;
  [ShowIf("overrideHorizontal")]
  [HideIf("overrideInputs")]
  public UnityEvent<float> OnHorizontalOverride;
  [HideIf("overrideInputs")]
  public bool overrideVertical;
  [ShowIf("overrideVertical")]
  [HideIf("overrideInputs")]
  public UnityEvent<float> OnVerticalOverride;
  public bool hasLayerBeenChecked;
  public Camera _cam;

  public Vector3 Position => this.transform.position + this.offset;

  public Camera cam => this._cam ?? (this._cam = Camera.main);

  public void OnEnable()
  {
    this.CheckForReferences(!this.hasLayerBeenChecked);
    MonoBehaviourSingleton<UINavigationSystem>.instance.RegisterSelectable(this);
  }

  public void OnDisable() => this.OnRemoved();

  public void OnDestroy() => this.OnRemoved();

  public void OnRemoved() => MonoBehaviourSingleton<UINavigationSystem>.instance.UnregisterSelectable(this);

  public virtual void Reset()
  {
    if (this.GetComponents<UINavigationItem>().Length > 1)
      Object.Destroy((Object) this);
    this.CheckForReferences(true);
  }

  public void OnTransformParentChanged()
  {
    this.navigationLayer = (UINavigationLayer) null;
    this.CheckForNavigationLayer(!this.hasLayerBeenChecked);
  }

  public void CheckForReferences(bool isFirstTime)
  {
    if ((Object) this.navigationLayer == (Object) null)
      this.CheckForNavigationLayer(isFirstTime);
    if (!((Object) this.clickHandler == (Object) null))
      return;
    this.CheckForSelectable();
  }

  public void CheckForNavigationLayer(bool isFirstTime)
  {
    if (isFirstTime)
      this.navigationLayer = (UINavigationLayer) null;
    this.CheckForNavigationLayer(this.transform, isFirstTime);
    this.hasLayerBeenChecked = true;
  }

  public void CheckForNavigationLayer(Transform checkTransform, bool isFirstTime)
  {
    if ((bool) (Object) checkTransform.GetComponent<UINavigationLayer>() && checkTransform.GetComponent<UINavigationLayer>().isOverrideLayer && (isFirstTime || checkTransform.GetComponent<UINavigationLayer>().allowLayerToBeAppliedAtRuntime))
      this.navigationLayer = checkTransform.GetComponent<UINavigationLayer>();
    if ((bool) (Object) this.navigationLayer || !(bool) (Object) checkTransform.transform.parent)
      return;
    this.CheckForNavigationLayer(checkTransform.transform.parent, isFirstTime);
  }

  public void CheckForSelectable()
  {
    this.CheckForSelectableDown(this.transform);
    if (!((Object) this.clickHandler == (Object) null))
      return;
    this.CheckForSelectableUp(this.transform.parent);
  }

  public void CheckForSelectableDown(Transform checkTransform)
  {
    this.clickHandler = checkTransform.GetComponent<IPointerDownHandler>() != null ? checkTransform.gameObject : (GameObject) null;
    if (!((Object) this.clickHandler == (Object) null))
      return;
    for (int index = 0; index < checkTransform.childCount; ++index)
    {
      this.CheckForSelectableDown(checkTransform.GetChild(index));
      if ((Object) this.clickHandler != (Object) null)
        break;
    }
  }

  public void CheckForSelectableUp(Transform checkTransform)
  {
    if (!((Object) checkTransform != (Object) null))
      return;
    this.clickHandler = checkTransform.GetComponent<IPointerDownHandler>() != null ? checkTransform.gameObject : (GameObject) null;
    if (!((Object) this.clickHandler == (Object) null) || !(bool) (Object) checkTransform.transform.parent)
      return;
    this.CheckForSelectableDown(checkTransform.transform.parent);
  }

  public bool CheckLayer()
  {
    UINavigationLayer activeNavigationLayer = UINavigationSystem.ActiveNavigationLayer;
    if (!this.ignoreLayers && !((Object) this.navigationLayer == (Object) activeNavigationLayer))
      return false;
    return (bool) (Object) activeNavigationLayer && activeNavigationLayer.allowOutsideVisibleSelection || this.cam.IsInCameraView(this.Position);
  }

  public enum SelectionPriority
  {
    Lowest = -2, // 0xFFFFFFFE
    Low = -1, // 0xFFFFFFFF
    Medium = 0,
    High = 1,
    Highest = 2,
    Mega = 10, // 0x0000000A
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UINavigationLayer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class UINavigationLayer : MonoBehaviour
{
  public static uint idMax;
  public uint id;
  public bool isOverrideLayer = true;
  public bool setStartingItem = true;
  public bool allowOutsideVisibleSelection;
  public bool allowLayerToBeAppliedAtRuntime = true;
  public bool forceHover = true;

  public void Awake() => this.id = UINavigationLayer.idMax++;

  public void OnEnable() => MonoBehaviourSingleton<UINavigationSystem>.instance.RegisterNavigationLayer(this);

  public void OnDisable() => MonoBehaviourSingleton<UINavigationSystem>.instance.UnregisterNavigationLayer(this);

  public override bool Equals(object other) => other is UINavigationLayer uiNavigationLayer && (int) uiNavigationLayer.id == (int) this.id;
}
﻿// Decompiled with JetBrains decompiler
// Type: UINavigationSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class UINavigationSystem : MonoBehaviourSingleton<UINavigationSystem>
{
  [Header("Current Status")]
  public UINavigationItem currentNavigationItem;
  public List<UINavigationItem> AvailableNavigationItems = new List<UINavigationItem>();
  public List<UINavigationItem> PossibleNavigationItems = new List<UINavigationItem>();
  public List<UINavigationLayer> NavigationLayers = new List<UINavigationLayer>();
  public static UINavigationLayer ActiveNavigationLayer;
  public UINavigationLayer lastActiveNavigationLayer;
  [Header("Settings Status")]
  public float navigationControllerDeadzone = 0.05f;
  [ReadOnly]
  public MoveDirection lastMove;
  public float navigationGridThreshold = 1.5f;
  public float minorNavigationGridThreshold = 0.25f;
  public float maxAnyItemCheckBeforeLoopMultiplier = 2.5f;
  public float anglePriority = 1f;
  public float disPriority = 1f;
  public float maxNavAngle = 45f;
  public UnityEvent OnNavigate;
  [Header("References")]
  public Cursor3d virtualCursor;
  [SerializeField]
  public CustomEventSystem eventSystem;
  [SerializeField]
  public GameObject eventSystemObj;
  public bool didNavigate;
  public Vector3 lastNavigationItemPos;
  public bool currentNavigationItemChanged = true;

  public void Start() => NavigationState.Reset();

  public void OnEnable()
  {
    global::Events.OnTransitionEnd += new UnityAction<TransitionType>(this.Events_OnTransitionEnd);
    global::Events.OnUINavigationReset += new UnityAction(this.Events_OnUINavigationReset);
    global::Events.OnEntityFlipComplete += new UnityAction<Entity>(this.Events_OnEntityFlipComplete);
  }

  public void OnDisable()
  {
    global::Events.OnTransitionEnd -= new UnityAction<TransitionType>(this.Events_OnTransitionEnd);
    global::Events.OnUINavigationReset -= new UnityAction(this.Events_OnUINavigationReset);
    global::Events.OnEntityFlipComplete -= new UnityAction<Entity>(this.Events_OnEntityFlipComplete);
  }

  public void Events_OnEntityFlipComplete(Entity entity)
  {
    if (!(bool) (UnityEngine.Object) entity || !(bool) (UnityEngine.Object) this.currentNavigationItem || !((UnityEngine.Object) entity.gameObject == (UnityEngine.Object) this.currentNavigationItem.gameObject))
      return;
    UINavigationDefaultSystem.SetStartingItem();
  }

  public void Events_OnUINavigationReset() => this.ResetState();

  public void Events_OnTransitionEnd(TransitionType transition) => UINavigationDefaultSystem.SetStartingItem(false, true);

  public void RemoveActiveLayer() => this.UnregisterNavigationLayer(UINavigationSystem.ActiveNavigationLayer);

  public void RegisterSelectable(UINavigationItem uiNavigationItem)
  {
    if (this.AvailableNavigationItems.Contains(uiNavigationItem) || this.AvailableNavigationItems.Count<UINavigationItem>((Func<UINavigationItem, bool>) (x => (UnityEngine.Object) x.gameObject == (UnityEngine.Object) uiNavigationItem.gameObject)) != 0)
      return;
    this.AvailableNavigationItems.Add(uiNavigationItem);
    if (!(bool) (UnityEngine.Object) MonoBehaviourSingleton<UINavigationSystem>.instance || !(bool) (UnityEngine.Object) MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem || MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem.selectionPriority != UINavigationItem.SelectionPriority.Lowest && (uiNavigationItem.selectionPriority != UINavigationItem.SelectionPriority.Highest || MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem.selectionPriority == UINavigationItem.SelectionPriority.Highest))
      return;
    UINavigationDefaultSystem.SetStartingItem();
  }

  public void UnregisterSelectable(UINavigationItem uiNavigationItem)
  {
    if (!this.AvailableNavigationItems.Contains(uiNavigationItem))
      return;
    this.AvailableNavigationItems.Remove(uiNavigationItem);
  }

  public void RegisterNavigationLayer(UINavigationLayer navigationLayer)
  {
    this.NavigationLayers.Add(navigationLayer);
    if (!navigationLayer.isOverrideLayer)
      return;
    UINavigationSystem.ActiveNavigationLayer = navigationLayer;
  }

  public void UnregisterNavigationLayer(UINavigationLayer navigationLayer)
  {
    if (!this.NavigationLayers.Contains(navigationLayer))
      return;
    foreach (UINavigationItem uiNavigationItem in this.AvailableNavigationItems.Where<UINavigationItem>((Func<UINavigationItem, bool>) (item => (UnityEngine.Object) item.navigationLayer == (UnityEngine.Object) navigationLayer)))
      uiNavigationItem.CheckForNavigationLayer(true);
    this.NavigationLayers.Remove(navigationLayer);
    UINavigationHistory.GoBackALayer();
    if (!navigationLayer.isOverrideLayer)
      return;
    UINavigationSystem.ActiveNavigationLayer = this.NavigationLayers.LastOrDefault<UINavigationLayer>((Func<UINavigationLayer, bool>) (x => x.isOverrideLayer));
  }

  public void Update()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse && (bool) (UnityEngine.Object) this.currentNavigationItem)
    {
      this.SetCurrentNavigationItem((UINavigationItem) null);
    }
    else
    {
      UINavigationLayer activeNavigationLayer = UINavigationSystem.ActiveNavigationLayer;
      if ((bool) (UnityEngine.Object) this.currentNavigationItem && (!this.AvailableNavigationItems.Contains(this.currentNavigationItem) || !this.currentNavigationItem.CheckLayer()))
        this.SetCurrentNavigationItem((UINavigationItem) null);
      if (!(bool) (UnityEngine.Object) this.currentNavigationItem && this.AvailableNavigationItems.Any<UINavigationItem>((Func<UINavigationItem, bool>) (a => (bool) (UnityEngine.Object) a && (UnityEngine.Object) a.navigationLayer == (UnityEngine.Object) activeNavigationLayer)))
        UINavigationDefaultSystem.SetStartingItem();
      else if ((bool) (UnityEngine.Object) this.currentNavigationItem)
      {
        this.CheckForNavigation();
        if ((double) Vector3.Distance(this.currentNavigationItem.Position, this.lastNavigationItemPos) > (double) Mathf.Epsilon)
          this.SetCursor();
      }
      if ((UnityEngine.Object) activeNavigationLayer != (UnityEngine.Object) this.lastActiveNavigationLayer)
        UINavigationHistory.AddLayer(activeNavigationLayer);
      foreach (UINavigationHistory.Layer layer in UINavigationHistory.layers)
      {
        if ((UnityEngine.Object) layer.navigationLayer == (UnityEngine.Object) activeNavigationLayer)
        {
          if (layer.navigationItemHistory.Count > 0)
          {
            if (!((UnityEngine.Object) layer.navigationItemHistory.Last<UINavigationItem>() != (UnityEngine.Object) this.currentNavigationItem))
              break;
          }
          layer.navigationItemHistory.Add(this.currentNavigationItem);
          break;
        }
      }
      this.lastActiveNavigationLayer = activeNavigationLayer;
    }
  }

  public void SetCursor()
  {
    VirtualPointer.Show();
    this.virtualCursor.SetPosition(this.currentNavigationItem.Position);
    this.lastNavigationItemPos = (bool) (UnityEngine.Object) this.currentNavigationItem ? this.currentNavigationItem.Position : this.lastNavigationItemPos;
  }

  public void ResetState() => UINavigationDefaultSystem.SetStartingItem();

  public void CheckForNavigation()
  {
    if (!this.virtualCursor.showVirtualPointerState || Console.active)
      return;
    if (InputSystem.CheckLongHold())
      this.SetCurrentNavigationItem(this.GetSelectable(this.lastMove));
    int num1 = InputSystem.IsButtonPressed("Move Vertical") ? 1 : (InputSystem.IsButtonPressed("Move Vertical", false) ? -1 : 0);
    int num2 = InputSystem.IsButtonPressed("Move Horizontal") ? 1 : (InputSystem.IsButtonPressed("Move Horizontal", false) ? -1 : 0);
    if ((double) Mathf.Abs(num1) > (double) this.navigationControllerDeadzone || (double) Mathf.Abs(num2) > (double) this.navigationControllerDeadzone)
    {
      if (!this.didNavigate)
      {
        if (Mathf.Abs(num1) > Mathf.Abs(num2))
        {
          if ((double) num1 > (double) this.navigationControllerDeadzone)
            this.SetCurrentNavigationItem(this.GetSelectable(MoveDirection.Up));
          if ((double) num1 < -(double) this.navigationControllerDeadzone)
            this.SetCurrentNavigationItem(this.GetSelectable(MoveDirection.Down));
        }
        else
        {
          if ((double) num2 < -(double) this.navigationControllerDeadzone)
            this.SetCurrentNavigationItem(this.GetSelectable(MoveDirection.Left));
          if ((double) num2 > (double) this.navigationControllerDeadzone)
            this.SetCurrentNavigationItem(this.GetSelectable(MoveDirection.Right));
        }
        this.didNavigate = true;
      }
    }
    else
      this.didNavigate = false;
    if (!this.didNavigate)
      return;
    this.currentNavigationItemChanged = true;
    global::Events.InvokeUINavigation();
  }

  public UINavigationItem GetSelectable(MoveDirection moveDirection)
  {
    this.lastMove = moveDirection;
    if (this.currentNavigationItem.overrideInputs)
    {
      switch (moveDirection)
      {
        case MoveDirection.Left:
          if ((bool) (UnityEngine.Object) this.currentNavigationItem.inputLeft)
            return this.currentNavigationItem.inputLeft;
          break;
        case MoveDirection.Up:
          if ((bool) (UnityEngine.Object) this.currentNavigationItem.inputUp)
            return this.currentNavigationItem.inputUp;
          break;
        case MoveDirection.Right:
          if ((bool) (UnityEngine.Object) this.currentNavigationItem.inputRight)
            return this.currentNavigationItem.inputRight;
          break;
        case MoveDirection.Down:
          if ((bool) (UnityEngine.Object) this.currentNavigationItem.inputDown)
            return this.currentNavigationItem.inputDown;
          break;
      }
    }
    if (this.currentNavigationItem.overrideHorizontal)
    {
      switch (moveDirection)
      {
        case MoveDirection.Left:
          this.currentNavigationItem.OnHorizontalOverride?.Invoke(-1f);
          return this.currentNavigationItem;
        case MoveDirection.Right:
          this.currentNavigationItem.OnHorizontalOverride?.Invoke(1f);
          return this.currentNavigationItem;
      }
    }
    if (this.currentNavigationItem.overrideVertical)
    {
      switch (moveDirection)
      {
        case MoveDirection.Up:
          this.currentNavigationItem.OnVerticalOverride?.Invoke(1f);
          return this.currentNavigationItem;
        case MoveDirection.Down:
          this.currentNavigationItem.OnVerticalOverride?.Invoke(-1f);
          return this.currentNavigationItem;
      }
    }
    this.PossibleNavigationItems = this.AvailableNavigationItems.Where<UINavigationItem>((Func<UINavigationItem, bool>) (x => (bool) (UnityEngine.Object) x && (UnityEngine.Object) x != (UnityEngine.Object) this.currentNavigationItem && x.CheckLayer())).ToList<UINavigationItem>();
    Vector3 position = this.currentNavigationItem.Position;
    UINavigationItem selectable = this.GetSelectable(moveDirection, position);
    return !(bool) (UnityEngine.Object) selectable ? this.currentNavigationItem : selectable;
  }

  public UINavigationItem GetSelectable(MoveDirection moveDirection, Vector3 currentPosition)
  {
    UINavigationItem selectable = (UINavigationItem) null;
    switch (moveDirection)
    {
      case MoveDirection.Left:
        selectable = this.GetSelectable(currentPosition, Vector3.left, (Predicate<UINavigationItem>) (a => (double) currentPosition.x - (double) a.Position.x > (double) this.minorNavigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(a.Position.y - currentPosition.y) < (double) this.navigationGridThreshold * (double) this.maxAnyItemCheckBeforeLoopMultiplier && (double) Mathf.Abs(Vector3.Angle(Vector3.left, currentPosition.GetDirTowardsPoint(a.Position))) < (double) this.maxNavAngle));
        if (!(bool) (UnityEngine.Object) selectable && this.currentNavigationItem.canLoop)
        {
          selectable = this.GetSelectableLoop(currentPosition, Vector3.left, (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(currentPosition.x - a.Position.x) > (double) this.minorNavigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(currentPosition.y - a.Position.y) < (double) this.navigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) a.Position.x - (double) currentPosition.x > (double) this.minorNavigationGridThreshold));
          break;
        }
        break;
      case MoveDirection.Up:
        selectable = this.GetSelectable(currentPosition, Vector3.up, (Predicate<UINavigationItem>) (a => (double) a.Position.y - (double) currentPosition.y > (double) this.minorNavigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(a.Position.x - currentPosition.x) < (double) this.navigationGridThreshold * (double) this.maxAnyItemCheckBeforeLoopMultiplier && (double) Mathf.Abs(Vector3.Angle(Vector3.up, currentPosition.GetDirTowardsPoint(a.Position))) < (double) this.maxNavAngle));
        if (!(bool) (UnityEngine.Object) selectable && this.currentNavigationItem.canLoop)
        {
          selectable = this.GetSelectableLoop(currentPosition, Vector3.up, (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(currentPosition.y - a.Position.y) > (double) this.minorNavigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(currentPosition.x - a.Position.x) < (double) this.navigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) currentPosition.y - (double) a.Position.y > (double) this.minorNavigationGridThreshold));
          break;
        }
        break;
      case MoveDirection.Right:
        selectable = this.GetSelectable(currentPosition, Vector3.right, (Predicate<UINavigationItem>) (a => (double) a.Position.x - (double) currentPosition.x > (double) this.minorNavigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(a.Position.y - currentPosition.y) < (double) this.navigationGridThreshold * (double) this.maxAnyItemCheckBeforeLoopMultiplier && (double) Mathf.Abs(Vector3.Angle(Vector3.right, currentPosition.GetDirTowardsPoint(a.Position))) < (double) this.maxNavAngle));
        if (!(bool) (UnityEngine.Object) selectable && this.currentNavigationItem.canLoop)
        {
          selectable = this.GetSelectableLoop(currentPosition, Vector3.right, (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(currentPosition.x - a.Position.x) > (double) this.minorNavigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(currentPosition.y - a.Position.y) < (double) this.navigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) currentPosition.x - (double) a.Position.x > (double) this.minorNavigationGridThreshold));
          break;
        }
        break;
      case MoveDirection.Down:
        selectable = this.GetSelectable(currentPosition, Vector3.down, (Predicate<UINavigationItem>) (a => (double) currentPosition.y - (double) a.Position.y > (double) this.minorNavigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(a.Position.x - currentPosition.x) < (double) this.navigationGridThreshold * (double) this.maxAnyItemCheckBeforeLoopMultiplier && (double) Mathf.Abs(Vector3.Angle(Vector3.down, currentPosition.GetDirTowardsPoint(a.Position))) < (double) this.maxNavAngle));
        if (!(bool) (UnityEngine.Object) selectable && this.currentNavigationItem.canLoop)
        {
          selectable = this.GetSelectableLoop(currentPosition, Vector3.down, (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(currentPosition.y - a.Position.y) > (double) this.minorNavigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) Mathf.Abs(currentPosition.x - a.Position.x) < (double) this.navigationGridThreshold), (Predicate<UINavigationItem>) (a => (double) a.Position.y - (double) currentPosition.y > (double) this.minorNavigationGridThreshold));
          break;
        }
        break;
    }
    return selectable;
  }

  public UINavigationItem GetSelectable(
    Vector3 currentPosition,
    Vector3 direction,
    Predicate<UINavigationItem> directionCheck,
    Predicate<UINavigationItem> alignmentCheck)
  {
    List<UINavigationItem> list = this.PossibleNavigationItems.Where<UINavigationItem>((Func<UINavigationItem, bool>) (a => directionCheck(a) && alignmentCheck(a))).ToList<UINavigationItem>();
    return list.Any<UINavigationItem>() ? list.OrderBy<UINavigationItem, float>((Func<UINavigationItem, float>) (a => Vector3.Distance(a.Position, currentPosition).RemapProportion(0.0f, this.navigationGridThreshold, 0.0f, this.disPriority) + Mathf.Abs(Vector3.Angle(direction, currentPosition.GetDirTowardsPoint(a.Position))).RemapProportion(0.0f, this.maxNavAngle, 0.0f, this.anglePriority))).First<UINavigationItem>() : (UINavigationItem) null;
  }

  public UINavigationItem GetSelectableLoop(
    Vector3 currentPosition,
    Vector3 direction,
    Predicate<UINavigationItem> directionCheck,
    Predicate<UINavigationItem> alignmentCheck,
    Predicate<UINavigationItem> fallbackCheck)
  {
    List<UINavigationItem> list = this.PossibleNavigationItems.Where<UINavigationItem>((Func<UINavigationItem, bool>) (a => directionCheck(a) && alignmentCheck(a))).ToList<UINavigationItem>();
    if (!list.Any<UINavigationItem>())
      list = this.PossibleNavigationItems.Where<UINavigationItem>((Func<UINavigationItem, bool>) (a => fallbackCheck(a))).ToList<UINavigationItem>();
    if (list.Count <= 0)
      return (UINavigationItem) null;
    UINavigationItem selectableLoop = list.OrderBy<UINavigationItem, float>((Func<UINavigationItem, float>) (a => a.Position.DistanceTo(currentPosition))).Last<UINavigationItem>();
    if (list.Count == 1)
      return selectableLoop;
    Vector3 furthestPosition = (selectableLoop.Position - direction * this.navigationGridThreshold).WithZ(currentPosition.z);
    return list.OrderBy<UINavigationItem, float>((Func<UINavigationItem, float>) (a => Vector3.Distance(a.Position, furthestPosition).RemapProportion(0.0f, this.navigationGridThreshold, 0.0f, this.disPriority) + Mathf.Abs(Vector3.Angle(direction, furthestPosition.GetDirTowardsPoint(a.Position))).RemapProportion(0.0f, this.maxNavAngle, 0.0f, this.anglePriority))).First<UINavigationItem>();
  }

  public void SetCurrentNavigationItem(UINavigationItem navItem)
  {
    if ((bool) (UnityEngine.Object) this.currentNavigationItem)
    {
      if (this.currentNavigationItem.Equals((object) navItem))
        return;
      this.eventSystem.Unhover(this.currentNavigationItem.clickHandler);
    }
    if ((bool) (UnityEngine.Object) navItem && this.AvailableNavigationItems.Any<UINavigationItem>((Func<UINavigationItem, bool>) (a => (UnityEngine.Object) a == (UnityEngine.Object) navItem)))
    {
      this.currentNavigationItem = navItem;
      UINavigationLayer activeNavigationLayer = UINavigationSystem.ActiveNavigationLayer;
      if (!(bool) (UnityEngine.Object) activeNavigationLayer || activeNavigationLayer.forceHover)
        this.eventSystem.Hover(navItem.clickHandler);
      UINavigationHistory.AddItem(navItem);
    }
    else
      this.currentNavigationItem = (UINavigationItem) null;
  }

  [CompilerGenerated]
  public bool \u003CGetSelectable\u003Eb__36_0(UINavigationItem x) => (bool) (UnityEngine.Object) x && (UnityEngine.Object) x != (UnityEngine.Object) this.currentNavigationItem && x.CheckLayer();
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.UINavigationTag
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;

namespace Deadpan.Enums
{
  [Serializable]
  public enum UINavigationTag
  {
    DiscardPocket,
    DrawPocket,
    EnemyCard,
    EnemyCardSlot,
    PlayerCardSlot,
    RedrawBell,
    PlayerCard,
    Card,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UISequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using UnityEngine;

public class UISequence : MonoBehaviour
{
  public bool promptEnd;
  public float startDelay = 0.25f;
  public float delayBetween = 0.2f;
  [Header("Tween In")]
  public float tweenInDur = 0.75f;
  public LeanTweenType tweenInEase = LeanTweenType.easeOutBack;
  [Header("Tween Out")]
  public float tweenOutDur = 0.25f;
  public LeanTweenType tweenOutEase = LeanTweenType.easeInBack;
  public Routine routine;

  public bool IsRunning
  {
    get
    {
      Routine routine = this.routine;
      return routine != null && routine.IsRunning;
    }
  }

  public void Begin()
  {
    if (this.IsRunning)
      this.routine.Stop();
    this.routine = new Routine(this.Run());
  }

  public virtual void End() => this.promptEnd = true;

  public void EndIfRunning()
  {
    if (!this.IsRunning)
      return;
    this.End();
  }

  public virtual IEnumerator Run() => (IEnumerator) null;
}
﻿// Decompiled with JetBrains decompiler
// Type: UnitTarget
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class UnitTarget : MonoBehaviour
{
  [SerializeField]
  public GameObject aimlessOverlay;
  [SerializeField]
  public GameObject frenzyUnderlay;

  public void SetAimless(bool aimless) => this.aimlessOverlay.SetActive(aimless);

  public void SetFrenzy(bool frenzy) => this.frenzyUnderlay.SetActive(frenzy);
}
﻿// Decompiled with JetBrains decompiler
// Type: UnitTargetSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class UnitTargetSystem : GameSystem
{
  [SerializeField]
  public UnitTarget targetPrefab;
  public Entity dragging;
  public Entity hover;
  public readonly List<GameObject> targets = new List<GameObject>();

  public void OnEnable()
  {
    global::Events.OnEntityDrag += new UnityAction<Entity>(this.EntityDrag);
    global::Events.OnEntityRelease += new UnityAction<Entity>(this.EntityRelease);
    global::Events.OnEntityHover += new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover += new UnityAction<Entity>(this.EntityUnHover);
  }

  public void OnDisable()
  {
    global::Events.OnEntityDrag -= new UnityAction<Entity>(this.EntityDrag);
    global::Events.OnEntityRelease -= new UnityAction<Entity>(this.EntityRelease);
    global::Events.OnEntityHover -= new UnityAction<Entity>(this.EntityHover);
    global::Events.OnEntityUnHover -= new UnityAction<Entity>(this.EntityUnHover);
  }

  public void Start()
  {
    global::Events.OnSettingChanged += new UnityAction<string, object>(this.SettingChanged);
    if (Settings.Load<int>("UnitTargets", 1) == 1)
      return;
    this.enabled = false;
  }

  public void OnDestroy() => global::Events.OnSettingChanged -= new UnityAction<string, object>(this.SettingChanged);

  public void EntityDrag(Entity entity)
  {
    this.dragging = entity;
    if (!(bool) (Object) this.hover)
      return;
    this.HideTargets();
  }

  public void EntityRelease(Entity entity)
  {
    if (!((Object) this.dragging == (Object) entity))
      return;
    this.dragging = (Entity) null;
  }

  public void EntityHover(Entity entity)
  {
    if ((bool) (Object) this.dragging)
      return;
    if ((bool) (Object) this.hover)
      this.EntityUnHover(this.hover);
    this.hover = entity;
    if (!entity.inPlay || entity.counter.max <= 0 || !entity.data.hasAttack || !Battle.IsOnBoard(this.hover))
      return;
    this.ShowTargets(this.hover);
  }

  public void EntityUnHover(Entity entity)
  {
    if (!((Object) this.hover == (Object) entity))
      return;
    this.hover = (Entity) null;
    this.HideTargets();
  }

  public void SettingChanged(string key, object value)
  {
    if (!(key == "UnitTargets") || !(value is int num))
      return;
    if (num == 0 && this.enabled)
    {
      this.enabled = false;
    }
    else
    {
      if (num != 1 || this.enabled)
        return;
      this.enabled = true;
    }
  }

  public void ShowTargets(Entity entity)
  {
    Entity[] potentialTargets = entity.targetMode.GetPotentialTargets(entity, (Entity) null, (CardContainer) null);
    if (potentialTargets == null)
      return;
    bool random = entity.targetMode.Random;
    StatusEffectData status = entity.FindStatus("frenzy");
    bool frenzy = status != null && status.count > 0;
    foreach (MonoBehaviourCacheTransform behaviourCacheTransform in potentialTargets)
    {
      UnitTarget unitTarget = Object.Instantiate<UnitTarget>(this.targetPrefab, behaviourCacheTransform.transform.position, Quaternion.identity, this.transform);
      unitTarget.SetAimless(random);
      unitTarget.SetFrenzy(frenzy);
      this.targets.Add(unitTarget.gameObject);
    }
  }

  public void HideTargets()
  {
    foreach (GameObject target in this.targets)
      target.Destroy();
    this.targets.Clear();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UnityEventEntity
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine.Events;

[Serializable]
public class UnityEventEntity : UnityEvent<Entity>
{
}
﻿// Decompiled with JetBrains decompiler
// Type: UnityEventGameObject
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;
using UnityEngine.Events;

[Serializable]
public class UnityEventGameObject : UnityEvent<GameObject>
{
}
﻿// Decompiled with JetBrains decompiler
// Type: UnityEventInt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine.Events;

[Serializable]
public class UnityEventInt : UnityEvent<int>
{
}
﻿// Decompiled with JetBrains decompiler
// Type: UnityEventIntInt
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine.Events;

[Serializable]
public class UnityEventIntInt : UnityEvent<int, int>
{
}
﻿// Decompiled with JetBrains decompiler
// Type: UnityEventStatStat
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine.Events;

[Serializable]
public class UnityEventStatStat : UnityEvent<Stat, Stat>
{
}
﻿// Decompiled with JetBrains decompiler
// Type: UnlockData
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Localization;

[CreateAssetMenu(menuName = "Town/Unlock", fileName = "Unlock")]
public class UnlockData : DataFile
{
  [SerializeField]
  public bool active = true;
  [ShowIf("active")]
  public bool activeInDemo = true;
  [ShowIf("active")]
  public bool activeInPressDemo = true;
  public UnlockData.Type type;
  public BuildingType relatedBuilding;
  public float lowPriority;
  public UnlockData[] requires;
  public LocalizedString unlockTitle;
  public LocalizedString unlockDesc;

  public bool IsActive => this.active;

  public enum Type
  {
    None,
    BuildingStarted,
    BuildingFinished,
    Item,
    Pet,
    Tribe,
    Companion,
    Event,
    JournalPage,
    Charm,
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UnlockFrostoscope
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using UnityEngine;

public class UnlockFrostoscope : MonoBehaviour
{
  public void Check(GameObject gameObject)
  {
    Building component = gameObject.GetComponent<Building>();
    if (component == null)
      return;
    this.Check(component);
  }

  public void Check(Building building)
  {
    List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
    UnlockData finished = building.type.finished;
    if (MetaprogressionSystem.IsUnlocked(finished, unlockedList) || SaveSystem.LoadProgressData<CardSaveData[]>("finalBossDeck") == null)
      return;
    unlockedList.Add(finished.name);
    SaveSystem.SaveProgressData<List<string>>("unlocked", unlockedList);
    MetaprogressionSystem.SetUnlocksReady(finished.name);
    building.CheckIfUnlocked();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UnlockModifierSequence
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class UnlockModifierSequence : MonoBehaviour
{
  [SerializeField]
  public ModifierIcon icon;

  public void Run(GameModifierData modifierData)
  {
    this.icon.Set(modifierData, Vector2.zero);
    this.gameObject.SetActive(true);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UnlockReadyIcon
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class UnlockReadyIcon : MonoBehaviour
{
  public void OnEnable() => this.Check();

  public void Check() => this.Set(MetaprogressionSystem.AnyUnlocksReady());

  public void Set(bool unlocksReady) => this.gameObject.SetActive(unlocksReady);
}
﻿// Decompiled with JetBrains decompiler
// Type: UnplayableCrownCardSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;
using UnityEngine.SceneManagement;

public class UnplayableCrownCardSystem : GameSystem
{
  [SerializeField]
  public LocalizedString promptKey;
  public bool active;
  public bool blocked;
  public bool promptShown;
  public int handCount;
  public const float timerMax = 0.5f;
  public float timer;

  public void OnEnable()
  {
    global::Events.OnBattleStart += new UnityAction(this.BattleStart);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerform);
  }

  public void OnDisable()
  {
    global::Events.OnBattleStart -= new UnityAction(this.BattleStart);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerform);
  }

  public void BattleStart()
  {
    if (this.active)
      return;
    this.Activate();
  }

  public void SceneChanged(Scene scene)
  {
    if (!this.active)
      return;
    this.Deactivate();
  }

  public void ActionPerform(PlayAction action)
  {
    if (!this.active || !(action is ActionDrawHand actionDrawHand) || !((Object) actionDrawHand.character == (Object) References.Player))
      return;
    this.Deactivate();
  }

  public void Activate()
  {
    this.active = true;
    this.handCount = References.Player.handContainer.Count;
    this.timer = 0.5f;
  }

  public void Update()
  {
    if (!this.active || (double) this.timer <= 0.0)
      return;
    this.timer -= Time.deltaTime;
    if ((double) this.timer > 0.0)
      return;
    this.timer = 0.5f;
    this.Check();
  }

  public void Check()
  {
    int count = References.Player.handContainer.Count;
    if (count == this.handCount)
      return;
    this.handCount = count;
    if (this.handCount == 0)
    {
      this.Deactivate();
    }
    else
    {
      if (this.handCount <= 0)
        return;
      bool blocked = this.blocked;
      this.blocked = UnplayableCrownCardSystem.CheckBlocked();
      if (this.blocked && !blocked)
      {
        this.ShowPrompt();
        RedrawBellSystem objectOfType = Object.FindObjectOfType<RedrawBellSystem>();
        if (objectOfType == null)
          return;
        objectOfType.Enable();
        objectOfType.BecomeInteractable();
      }
      else
      {
        if (!blocked || this.blocked)
          return;
        this.Deactivate();
      }
    }
  }

  public void Deactivate()
  {
    this.active = false;
    this.blocked = false;
    if (!this.promptShown)
      return;
    PromptSystem.Hide();
    this.promptShown = false;
  }

  public static bool CheckBlocked()
  {
    int num = 0;
    CardContainer[] array = ((IEnumerable<CardContainer>) Object.FindObjectsOfType<CardContainer>()).ToArray<CardContainer>();
    foreach (Entity card in References.Player.handContainer)
    {
      if (UnplayableCrownCardSystem.CardIsBlocked(card, array))
        ++num;
    }
    return num == References.Player.handContainer.Count;
  }

  public static bool CardIsBlocked(Entity card, CardContainer[] containers)
  {
    foreach (StatusEffectData statusEffect in card.statusEffects)
    {
      if (statusEffect is StatusEffectRecycle statusEffectRecycle)
      {
        if (!statusEffectRecycle.IsEnoughJunkInHand())
          return true;
        break;
      }
    }
    if (!card.NeedsTarget)
      return false;
    foreach (CardContainer container in containers)
    {
      if (card.CanPlayOn(container))
        return false;
    }
    foreach (Entity card1 in References.Battle.cards)
    {
      if (card1.enabled && card.CanPlayOn(card1))
        return false;
    }
    return true;
  }

  public void ShowPrompt()
  {
    PromptSystem.Create(Prompt.Anchor.Left, 1.5f, 2f, 5f, Prompt.Emote.Type.Scared);
    PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => this.promptKey.GetLocalizedString()));
    this.promptShown = true;
  }

  [CompilerGenerated]
  public string \u003CShowPrompt\u003Eb__18_0() => this.promptKey.GetLocalizedString();
}
﻿// Decompiled with JetBrains decompiler
// Type: UpgradeDisplay
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UI;

public class UpgradeDisplay : MonoBehaviour
{
  [CompilerGenerated]
  public CardUpgradeData \u003Cdata\u003Ek__BackingField;
  [SerializeField]
  public Image image;
  public UINavigationItem navigationItem;
  public Image _raycast;

  public CardUpgradeData data
  {
    get => this.\u003Cdata\u003Ek__BackingField;
    set => this.\u003Cdata\u003Ek__BackingField = value;
  }

  public Image raycast => this._raycast ?? (this._raycast = this.GetComponent<Image>());

  public bool CanRaycast
  {
    set => this.raycast.raycastTarget = value;
  }

  public virtual void SetData(CardUpgradeData data)
  {
    this.data = data;
    this.image.sprite = data.image;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UpgradeHolder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Events;
using UnityEngine.ResourceManagement.AsyncOperations;

public abstract class UpgradeHolder : MonoBehaviour
{
  [SerializeField]
  public AssetReference prefabRef;
  [SerializeField]
  public CardCharmDragHandler dragHandler;
  [SerializeField]
  public List<UpgradeDisplay> list = new List<UpgradeDisplay>();

  [Button(null, EButtonEnableMode.Always)]
  public virtual void SetPositions()
  {
    foreach (RectTransform rectTransform in this.transform)
      rectTransform.anchoredPosition = Vector2.zero;
  }

  public virtual UpgradeDisplay Create(CardUpgradeData upgradeData)
  {
    AsyncOperationHandle<GameObject> asyncOperationHandle = this.prefabRef.InstantiateAsync(this.transform);
    asyncOperationHandle.WaitForCompletion();
    UpgradeDisplay component1 = asyncOperationHandle.Result.GetComponent<UpgradeDisplay>();
    component1.gameObject.SetActive(true);
    component1.SetData(upgradeData);
    component1.name = upgradeData.name;
    if ((bool) (UnityEngine.Object) this.dragHandler)
    {
      CardCharmInteraction component2 = component1.GetComponent<CardCharmInteraction>();
      if (component2 != null)
      {
        component2.dragHandler = this.dragHandler;
        component2.onDrag.AddListener(new UnityAction<UpgradeDisplay>(this.dragHandler.Drag));
        component2.onDragEnd.AddListener(new UnityAction<UpgradeDisplay>(this.dragHandler.Release));
      }
    }
    this.Add(component1);
    return component1;
  }

  public virtual void Add(UpgradeDisplay upgrade) => this.Insert(0, upgrade);

  public virtual void Insert(int index, UpgradeDisplay upgrade)
  {
    this.list.Insert(index, upgrade);
    upgrade.transform.SetParent(this.transform, false);
    upgrade.transform.localPosition = Vector3.zero;
    upgrade.transform.localEulerAngles = Vector3.zero;
  }

  public virtual void Remove(UpgradeDisplay upgrade)
  {
    this.list.Remove(upgrade);
    upgrade.transform.SetParent((Transform) null, false);
  }

  public virtual void Remove(CardUpgradeData upgradeData)
  {
    UpgradeDisplay upgrade = this.list.Find((Predicate<UpgradeDisplay>) (a => (UnityEngine.Object) a.data == (UnityEngine.Object) upgradeData));
    if (!((UnityEngine.Object) upgrade != (UnityEngine.Object) null))
      return;
    this.Remove(upgrade);
  }

  public virtual int IndexOf(UpgradeDisplay upgrade) => this.list.IndexOf(upgrade);

  public virtual void Clear()
  {
    this.list.Clear();
    this.transform.DestroyAllChildren();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: UtilityScript
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using TMPro;
using UnityEngine;
using UnityEngine.AI;

public static class UtilityScript
{
  public static string GetLogMessage(string source, string message) => "[" + source + "] " + message;

  public static MethodInfo GetMethodInfo<T>(Expression<Action<T>> expression)
  {
    if (expression.Body is MethodCallExpression body)
      return body.Method;
    throw new ArgumentException("Expression is not a method", nameof (expression));
  }

  public static Vector3 GenerateSineWave(
    Vector3 axis,
    Vector3 currentPosition,
    float frequency,
    float magnitude,
    float timeStep)
  {
    return currentPosition + axis * Mathf.Sin(timeStep * frequency) * magnitude;
  }

  public static float PlanarDistance(this Vector3 a, Vector3 b, Axis negatedAxis)
  {
    if (negatedAxis == Axis.All)
      return new Vector3(0.0f, 0.0f, a.z).Distance(new Vector3(0.0f, 0.0f, b.z));
    if (negatedAxis == Axis.All)
      return new Vector3(0.0f, a.y, 0.0f).Distance(new Vector3(0.0f, b.y, 0.0f));
    if (negatedAxis == Axis.All)
      return new Vector3(a.x, 0.0f, 0.0f).Distance(new Vector3(b.x, 0.0f, 0.0f));
    switch (negatedAxis)
    {
      case Axis.All:
        return Vector3.zero.Distance(Vector3.zero);
      case (Axis) 1:
      case (Axis) 3:
        return float.PositiveInfinity;
      case Axis.X:
        return new Vector3(0.0f, a.y, a.z).Distance(new Vector3(0.0f, b.y, b.z));
      case Axis.Y:
        return new Vector3(a.x, 0.0f, a.z).Distance(new Vector3(b.x, 0.0f, b.z));
      default:
        if (negatedAxis == Axis.Z)
          return new Vector3(a.x, a.y, 0.0f).Distance(new Vector3(b.x, b.y, 0.0f));
        goto case (Axis) 1;
    }
  }

  public static Vector2 GetAverage(List<Vector2> positions)
  {
    Vector2 zero = Vector2.zero;
    for (int index = 0; index < positions.Count; ++index)
      zero += positions[index];
    return zero / (float) positions.Count;
  }

  public static Vector3 RandomInRange(this Vector3 inVector) => new Vector3(UnityEngine.Random.Range((float) (-(double) inVector.x / 2.0), inVector.x / 2f), UnityEngine.Random.Range((float) (-(double) inVector.y / 2.0), inVector.y / 2f), UnityEngine.Random.Range((float) (-(double) inVector.z / 2.0), inVector.z / 2f));

  public static Vector3 PlanarDistanceVec3(this Vector3 a, Vector3 b, Axis negatedAxis)
  {
    if (negatedAxis == Axis.All)
      return new Vector3(0.0f, 0.0f, a.z) - new Vector3(0.0f, 0.0f, b.z);
    if (negatedAxis == Axis.All)
      return new Vector3(0.0f, a.y, 0.0f) - new Vector3(0.0f, b.y, 0.0f);
    if (negatedAxis == Axis.All)
      return new Vector3(a.x, 0.0f, 0.0f) - new Vector3(b.x, 0.0f, 0.0f);
    switch (negatedAxis)
    {
      case Axis.All:
        return Vector3.zero - Vector3.zero;
      case (Axis) 1:
      case (Axis) 3:
        return Vector3.positiveInfinity;
      case Axis.X:
        return new Vector3(0.0f, a.y, a.z) - new Vector3(0.0f, b.y, b.z);
      case Axis.Y:
        return new Vector3(a.x, 0.0f, a.z) - new Vector3(b.x, 0.0f, b.z);
      default:
        if (negatedAxis == Axis.Z)
          return new Vector3(a.x, a.y, 0.0f) - new Vector3(b.x, b.y, 0.0f);
        goto case (Axis) 1;
    }
  }

  public static Vector3 GetPlanar(this Vector3 a, Axis negatedAxis)
  {
    switch (negatedAxis)
    {
      case Axis.X:
        return new Vector3(0.0f, a.y, a.z);
      case Axis.Y:
        return new Vector3(a.x, 0.0f, a.z);
      case Axis.Z:
        return new Vector3(a.x, a.y, 0.0f);
      default:
        return new Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity);
    }
  }

  public static float RoundAwayFromZero(this float f) => (double) f < 0.0 ? Mathf.Floor(f) : Mathf.Ceil(f);

  public static float AddToAverage(float average, int size, float value) => ((float) size * average + value) / (float) (size + 1);

  public static float SubtractFromAverage(float average, int size, float value) => ((float) size * average - value) / (float) (size - 1);

  public static float ReplaceInAverage(float average, int size, float oldValue, float newValue) => ((float) size * average - oldValue + newValue) / (float) size;

  public static float AddAveragesTogether(float averageA, int sizeA, float averageB, int sizeB) => (float) ((double) sizeA * (double) averageA + (double) sizeB * (double) averageB) / (float) (sizeA + sizeB);

  public static float GetNormalDistance(
    this Vector3 position,
    Vector3 startPosition,
    Vector3 destination)
  {
    float sqrMagnitude = startPosition.PlanarDistanceVec3(destination, Axis.Y).sqrMagnitude;
    return position.PlanarDistanceVec3(destination, Axis.Y).sqrMagnitude.RemapProportion(0.0f, sqrMagnitude, 0.0f, 1f);
  }

  public static string GetPathBasedOnOS()
  {
    if (Application.isEditor)
      return Application.persistentDataPath + "/";
    if (Application.platform == RuntimePlatform.WebGLPlayer)
      return Path.GetDirectoryName(Application.absoluteURL).Replace("\\", "/") + "/";
    return Application.isMobilePlatform || Application.isConsolePlatform ? Application.persistentDataPath : Application.persistentDataPath + "/";
  }

  public static string GetIdentifier(string userIdentifier, string uniqueObjectIdentifier) => userIdentifier + "-" + uniqueObjectIdentifier;

  public static Vector3 Lerp(this Vector3 a, Vector3 b, float time) => Vector3.Lerp(a, b, time);

  public static bool IsEmpty(this string input) => string.IsNullOrEmpty(input) && string.IsNullOrWhiteSpace(input);

  public static double ToEpoch(this DateTime dt) => dt.Subtract(new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds;

  public static DateTime FromEpoch(this double epoch) => new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddSeconds(epoch);

  public static double ToEpochMs(this DateTime dt) => dt.Subtract(new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc)).TotalMilliseconds;

  public static DateTime FromEpochMs(this double epoch) => new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddMilliseconds(epoch);

  public static float SecondsToMs(this float seconds) => seconds * 1000f;

  public static Texture2D AddWatermark(
    Texture2D textureToSave,
    Texture2D watermark,
    int startPositionX,
    int startPositionY,
    bool hideFadedPixels = false)
  {
    Texture2D texture2D = textureToSave.ToTexture2D();
    for (int x = startPositionX; x < texture2D.width; ++x)
    {
      for (int y = startPositionY; y < texture2D.height; ++y)
      {
        if (x - startPositionX < watermark.width && y - startPositionY < watermark.height)
        {
          Color pixel1 = texture2D.GetPixel(x, y);
          Color pixel2 = watermark.GetPixel(x - startPositionX, y - startPositionY);
          Color b = pixel2;
          double t = (double) pixel2.a / 1.0;
          Color color1 = Color.Lerp(pixel1, b, (float) t);
          Color color2 = new Color(color1.r, color1.g, color1.b, 1f);
          texture2D.SetPixel(x, y, color2);
        }
      }
    }
    texture2D.Apply();
    return texture2D;
  }

  public static float AngleDir(Vector3 fwd, Vector3 targetDir, Vector3 up)
  {
    float num = Vector3.Dot(Vector3.Cross(fwd, targetDir), up);
    if ((double) num > 0.0)
      return 1f;
    return (double) num < 0.0 ? -1f : 0.0f;
  }

  public static IEnumerable<string> ToCsv<T>(
    IEnumerable<T> objectlist,
    string separator = ",",
    bool header = true)
  {
    FieldInfo[] fields = typeof (T).GetFields();
    PropertyInfo[] properties = typeof (T).GetProperties();
    if (header)
      yield return string.Join(separator, ((IEnumerable<FieldInfo>) fields).Select<FieldInfo, string>((Func<FieldInfo, string>) (f => f.Name)).Concat<string>(((IEnumerable<PropertyInfo>) properties).Select<PropertyInfo, string>((Func<PropertyInfo, string>) (p => p.Name))).ToArray<string>());
    foreach (T obj in objectlist)
    {
      T o = obj;
      yield return string.Join(separator, ((IEnumerable<FieldInfo>) fields).Select<FieldInfo, string>((Func<FieldInfo, string>) (f => (f.GetValue((object) o) ?? (object) "").ToString())).Concat<string>(((IEnumerable<PropertyInfo>) properties).Select<PropertyInfo, string>((Func<PropertyInfo, string>) (p => (p.GetValue((object) o, (object[]) null) ?? (object) "").ToString()))).ToArray<string>());
    }
  }

  public static float SubtractValueFromMean(float inVal, float currentMean, float numOfValues) => (float) (((double) currentMean * (double) numOfValues - (double) inVal) / ((double) numOfValues - 1.0));

  public static float AddValueToMean(float inVal, float currentMean, float numOfValues) => currentMean + (inVal - currentMean) / numOfValues;

  public static Color RandomColour() => new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);

  public static int RandomIndex<T>(this IEnumerable<T> list) => UnityEngine.Random.Range(0, list.Count<T>());

  public static T Next<T>(this IEnumerable<T> list, T anchor)
  {
    int num = list.ToList<T>().IndexOf(anchor);
    if (num >= list.Count<T>())
      return list.ElementAtOrDefault<T>(0);
    return num <= -1 ? list.ElementAtOrDefault<T>(list.Count<T>() - 1) : list.ElementAtOrDefault<T>(num + 1);
  }

  public static bool CompareArrays(int[,] arrayA, int[,] arrayB)
  {
    try
    {
      return arrayA.Rank == arrayB.Rank && Enumerable.Range(0, arrayA.Rank).All<int>((Func<int, bool>) (dimension => arrayA.GetLength(dimension) == arrayB.GetLength(dimension))) && ((IEnumerable) arrayA).Cast<int>().SequenceEqual<int>(((IEnumerable) arrayB).Cast<int>());
    }
    catch
    {
      return false;
    }
  }

  public static float RemapProportion(
    this float value,
    float currentMin,
    float currentMax,
    float newMin,
    float newMax)
  {
    return (float) (((double) value - (double) currentMin) / ((double) currentMax - (double) currentMin) * ((double) newMax - (double) newMin)) + newMin;
  }

  public static float Distance(this Vector3 thisVec, Vector3 compareVec) => Vector3.Distance(thisVec, compareVec);

  public static Vector3 Difference(this Vector3 a, Vector3 b) => a - b;

  public static bool InRange(this Vector2 inRange, float inNum, bool isInclusive = true) => isInclusive ? (double) inNum >= (double) inRange.x && (double) inNum <= (double) inRange.y : (double) inNum > (double) inRange.x && (double) inNum < (double) inRange.y;

  public static T RandomEnumValue<T>(Likelihood likelihood)
  {
    Array values = Enum.GetValues(typeof (T));
    float[] source = new float[values.Length];
    source[0] = 100f;
    for (int y = 1; y < values.Length; ++y)
      source[y] = 100f / (float) Math.Pow(2.0, (double) y);
    if ((double) source[values.Length - 1] > 1.0)
      source[values.Length - 1] = 1f;
    float[] array = ((IEnumerable<float>) source).Reverse<float>().ToArray<float>();
    int index1 = 0;
    switch (likelihood)
    {
      case Likelihood.MostToLeast:
        int num1 = UnityEngine.Random.Range(0, 100);
        for (int index2 = 0; index2 < array.Length; ++index2)
        {
          if ((double) num1 < (double) array[index2])
          {
            index1 = array.Length - 1 - index2;
            break;
          }
        }
        break;
      case Likelihood.LeastToMost:
        int num2 = UnityEngine.Random.Range(0, 100);
        for (int index3 = 0; index3 < array.Length; ++index3)
        {
          if ((double) num2 < (double) array[index3])
          {
            index1 = index3;
            break;
          }
        }
        break;
      case Likelihood.Balanced:
        index1 = UnityEngine.Random.Range(0, values.Length);
        break;
    }
    return (T) values.GetValue(index1);
  }

  public static float GetPercentageBetweenValues(float inVal, float minVal, float maxVal) => Mathf.Clamp01((float) (((double) inVal - (double) minVal) / ((double) maxVal - (double) minVal)));

  public static float GetPercentageBetweenValues(this Vector2 inVec, float inVal) => Mathf.Clamp01((float) (((double) inVal - (double) inVec.x) / ((double) inVec.y - (double) inVec.x)));

  public static float GetValueAtPercentage(this Vector2 inVec, float percentage) => inVec.x + (inVec.y - inVec.x) * percentage;

  public static float Clamp(this Vector2 inVec, float inVal) => Mathf.Clamp(inVal, inVec.x, inVec.y);

  public static Vector3 ToVec3(this Vector2 inVec) => new Vector3(inVec.x, inVec.y, 0.0f);

  public static bool IsWithinThreshold(float value, float compareTo, float threshold) => (double) value <= (double) compareTo + (double) threshold && (double) value >= (double) compareTo - (double) threshold;

  public static Texture2D FlipTexture(this Texture2D original)
  {
    Texture2D texture2D = new Texture2D(original.width, original.height);
    int width = original.width;
    int height = original.height;
    for (int x = 0; x < width; ++x)
    {
      for (int y = 0; y < height; ++y)
        texture2D.SetPixel(width - x - 1, y, original.GetPixel(x, y));
    }
    texture2D.Apply();
    return texture2D;
  }

  public static Texture2D ToTexture2D(this Texture texture)
  {
    Texture2D texture2D = new Texture2D(texture.width, texture.height, TextureFormat.RGBA32, false);
    RenderTexture active = RenderTexture.active;
    RenderTexture temporary = RenderTexture.GetTemporary(texture.width, texture.height, 32);
    Graphics.Blit(texture, temporary);
    RenderTexture.active = temporary;
    texture2D.ReadPixels(new Rect(0.0f, 0.0f, (float) temporary.width, (float) temporary.height), 0, 0);
    texture2D.Apply();
    RenderTexture.active = active;
    RenderTexture.ReleaseTemporary(temporary);
    return texture2D;
  }

  public static Vector3 RandomPointInRectTransform(RectTransform rectTransform)
  {
    Rect rect = rectTransform.rect;
    double x1 = (double) rect.x;
    rect = rectTransform.rect;
    double x2 = (double) rect.x;
    rect = rectTransform.rect;
    double width = (double) rect.width;
    double maxInclusive1 = x2 + width;
    double x3 = (double) UnityEngine.Random.Range((float) x1, (float) maxInclusive1);
    rect = rectTransform.rect;
    double y1 = (double) rect.y;
    rect = rectTransform.rect;
    double y2 = (double) rect.y;
    rect = rectTransform.rect;
    double height = (double) rect.height;
    double maxInclusive2 = y2 + height;
    double y3 = (double) UnityEngine.Random.Range((float) y1, (float) maxInclusive2);
    return new Vector3((float) x3, (float) y3, 0.0f);
  }

  public static T RandomEnumValue<T>()
  {
    Array values = Enum.GetValues(typeof (T));
    return (T) values.GetValue(UnityEngine.Random.Range(0, values.Length));
  }

  public static T RandomValueFromList<T>(this List<T> list) => list[UnityEngine.Random.Range(0, list.Count)];

  public static T GetEnumValue<T>(string valueName) => (T) Enum.Parse(typeof (T), valueName);

  public static Vector2 GetCharPosition(this TextMeshPro text, int index)
  {
    text.GetComponent<Transform>();
    Vector3 zero1 = Vector3.zero;
    Vector3 zero2 = Vector3.zero;
    TMP_TextInfo textInfo = text.textInfo;
    if (index < 0 || index >= textInfo.characterInfo.Length)
      return Vector2.zero;
    TMP_CharacterInfo tmpCharacterInfo = textInfo.characterInfo[index];
    return (Vector2) ((tmpCharacterInfo.topLeft + tmpCharacterInfo.topRight + tmpCharacterInfo.bottomLeft + tmpCharacterInfo.bottomRight) / 4f);
  }

  public static bool HasReachedDestination(this NavMeshAgent agent)
  {
    float num = 0.2f;
    return (double) agent.remainingDistance != double.PositiveInfinity && (double) agent.transform.position.PlanarDistance(agent.destination, Axis.Y) < (double) num;
  }

  public static Vector3 GetRandomPointOnNavMesh(this NavMeshAgent agent, float maxWalkDist)
  {
    NavMeshHit hit;
    NavMesh.SamplePosition(UnityEngine.Random.insideUnitSphere * maxWalkDist + agent.transform.position, out hit, maxWalkDist, 1);
    return hit.position;
  }

  public static string SpiltAndCamelCase(this string inString)
  {
    string str = new Regex("\r\n                (?<=[A-Z])(?=[A-Z][a-z]) |\r\n                 (?<=[^A-Z])(?=[A-Z]) |\r\n                 (?<=[A-Za-z])(?=[^A-Za-z])", RegexOptions.IgnorePatternWhitespace).Replace(inString, " ");
    return char.ToUpper(str[0]).ToString() + str.Substring(1);
  }

  public static Vector3 GetSignedVec3(this Vector3 inVector) => new Vector3(UtilityScript.GetSignedAngle(inVector.x), UtilityScript.GetSignedAngle(inVector.y), UtilityScript.GetSignedAngle(inVector.z));

  public static bool IsInCameraView(this Camera cam, Vector3 position, float border = 0.0f)
  {
    Vector3 viewportPoint = cam.WorldToViewportPoint(position);
    return (double) viewportPoint.x >= -(double) border && (double) viewportPoint.x <= 1.0 + (double) border && (double) viewportPoint.y >= -(double) border && (double) viewportPoint.y <= 1.0 + (double) border && (double) viewportPoint.z > 0.0;
  }

  public static float GetSignedAngle(float inAngle)
  {
    float signedAngle = inAngle;
    bool flag;
    do
    {
      flag = true;
      if ((double) signedAngle < -180.0)
        signedAngle += 360f;
      else if ((double) inAngle > 180.0)
        signedAngle -= 360f;
    }
    while (!flag);
    return signedAngle;
  }

  public static T RandomValueFromList<T>(this T[] list) => list[UnityEngine.Random.Range(0, list.Length)];

  public static T RandomValueFromList<T>(List<T> listA, List<T> ignoreFromListA)
  {
    List<T> list = listA.Except<T>((IEnumerable<T>) ignoreFromListA).ToList<T>();
    return list[UnityEngine.Random.Range(0, list.Count)];
  }

  public static float RoundToNearestMultiple(this float value, float factor) => (float) (int) Math.Round((double) value / (double) factor, MidpointRounding.AwayFromZero) * factor;

  public static float Truncate(this float value, int digits)
  {
    double num = Math.Pow(10.0, (double) digits);
    return (float) (Math.Truncate(num * (double) value) / num);
  }

  public static float PingPong(float timeValue, float minValue, float maxValue) => Mathf.PingPong(timeValue, maxValue - minValue) + minValue;

  public static IEnumerator ScaleObject(GameObject gameObj, float aValue, float aTime)
  {
    Vector3 currentScale = gameObj.transform.localScale;
    for (float t = 0.0f; (double) t < 1.0; t += Time.deltaTime / aTime)
    {
      gameObj.transform.localScale = new Vector3(Mathf.Lerp(currentScale.x, aValue, t), Mathf.Lerp(currentScale.x, aValue, t), Mathf.Lerp(currentScale.x, aValue, t));
      yield return (object) null;
    }
  }

  public static GameObject FindObject(this GameObject parent, string name)
  {
    Component[] componentsInChildren = parent.GetComponentsInChildren(typeof (Transform), true);
    Transform[] transformArray = new Transform[componentsInChildren.Length];
    for (int index = 0; index < componentsInChildren.Length; ++index)
      transformArray[index] = componentsInChildren[index].transform;
    foreach (Transform transform in transformArray)
    {
      if (transform.name == name)
        return transform.gameObject;
    }
    return (GameObject) null;
  }

  public static void Update<TSource>(this IEnumerable<TSource> outer, Action<TSource> updator)
  {
    foreach (TSource source in outer)
      updator(source);
  }

  public static bool Approximately(this Quaternion quatA, Quaternion value, float acceptableRange) => 1.0 - (double) Mathf.Abs(Quaternion.Dot(quatA, value)) < (double) acceptableRange;

  public static T Next<T>(this T src) where T : struct
  {
    if (!typeof (T).IsEnum)
      throw new ArgumentException(string.Format("Argument {0} is not an Enum", (object) typeof (T).FullName));
    T[] values = (T[]) Enum.GetValues(src.GetType());
    int index = Array.IndexOf<T>(values, src) + 1;
    return values.Length != index ? values[index] : values[0];
  }

  public static Vector3 Multiply(this Vector3 src, Vector3 vector) => new Vector3(src.x * vector.x, src.y * vector.y, src.z * vector.z);

  public static Vector3 ToVector3(this Color src) => new Vector3(src.r, src.g, src.b);

  public static Color ToColour(this Vector3 src, float alpha = 1f) => new Color(src.x, src.y, src.z, alpha);

  public static Color ColourFromVector3(Vector3 src) => new Color(src.x, src.y, src.z);

  public static void CopyFrom(this Transform toEdit, Transform copyFrom)
  {
    toEdit.transform.parent = copyFrom.parent;
    toEdit.transform.localScale = copyFrom.localScale;
    toEdit.transform.localRotation = copyFrom.localRotation;
    toEdit.transform.localPosition = copyFrom.localPosition;
  }

  public static void CopyFrom(this RectTransform objRectTransform, RectTransform rectTransform)
  {
    objRectTransform.transform.parent = rectTransform.parent;
    objRectTransform.anchorMin = rectTransform.anchorMin;
    objRectTransform.anchorMax = rectTransform.anchorMax;
    objRectTransform.anchoredPosition = rectTransform.anchoredPosition;
    objRectTransform.sizeDelta = rectTransform.sizeDelta;
    objRectTransform.localPosition = rectTransform.localPosition;
  }

  public static Vector3 RotateAround(this Vector3 point, Vector3 pivot, Vector3 angle)
  {
    Vector3 vector3 = point - pivot;
    point = Quaternion.Euler(angle) * vector3 + pivot;
    return point;
  }

  public static Color ScaleToOne(this Color src) => new Color((double) src.r > 1.0 ? src.r / 235f : src.r, (double) src.g > 1.0 ? src.g / 235f : src.g, (double) src.b > 1.0 ? src.b / 235f : src.b, (double) src.a > 1.0 ? src.a / 235f : src.a);

  public static string ConvertToString(this char[] charArray)
  {
    string str = "";
    for (int index = 0; index < charArray.Length; ++index)
      str += charArray[index].ToString();
    return str;
  }

  public static void SetLayerRecursively(this GameObject src, int newLayer)
  {
    src.layer = newLayer;
    foreach (Component component in src.transform)
      component.gameObject.SetLayerRecursively(newLayer);
  }

  public static float SignedAngleBetween(Vector3 vector1, Vector3 vector2, Vector3 normal) => Vector3.Angle(vector1, vector2) * Mathf.Sign(Vector3.Dot(normal, Vector3.Cross(vector1, vector2)));

  public static float UnsignedAngleBetween(Vector3 vector1, Vector3 vector2, Vector3 normal) => (float) (((double) Vector3.Angle(vector1, vector2) * (double) Mathf.Sign(Vector3.Dot(normal, Vector3.Cross(vector1, vector2))) + 180.0) % 360.0);

  public static Vector3 GetDirTowardsPoint(this Vector3 ownPos, Vector3 pointTowards) => (pointTowards - ownPos).normalized;

  public static Vector3 GetDirAwayFromPoint(this Vector3 ownPos, Vector3 pointAway) => (ownPos - pointAway).normalized;

  public static void Reset(this Transform inTransform)
  {
    inTransform.localPosition = Vector3.zero;
    inTransform.localRotation = Quaternion.identity;
    inTransform.localScale = Vector3.one;
  }

  public static void Reset(this RectTransform rectTransform)
  {
    rectTransform.transform.Reset();
    rectTransform.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Bottom, 0.0f, 0.0f);
    rectTransform.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Top, 0.0f, 0.0f);
    rectTransform.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Left, 0.0f, 0.0f);
    rectTransform.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Right, 0.0f, 0.0f);
  }

  public static T[] RangeSubset<T>(this T[] array, int startIndex, int length)
  {
    T[] destinationArray = new T[length];
    Array.Copy((Array) array, startIndex, (Array) destinationArray, 0, length);
    return destinationArray;
  }

  public static T[] Subset<T>(this T[] array, params int[] indices)
  {
    T[] objArray = new T[indices.Length];
    for (int index = 0; index < indices.Length; ++index)
      objArray[index] = array[indices[index]];
    return objArray;
  }

  public static bool IsValidEmail(string email)
  {
    if (string.IsNullOrWhiteSpace(email))
      return false;
    try
    {
      email = Regex.Replace(email, "(@)(.+)$", (MatchEvaluator) (match =>
      {
        string ascii = new IdnMapping().GetAscii(match.Groups[2].Value);
        return match.Groups[1].Value + ascii;
      }), RegexOptions.None, TimeSpan.FromMilliseconds(200.0));
    }
    catch (RegexMatchTimeoutException ex)
    {
      return false;
    }
    catch (ArgumentException ex)
    {
      return false;
    }
    try
    {
      return Regex.IsMatch(email, "^(?(\")(\".+?(?<!\\\\)\"@)|(([0-9a-z]((\\.(?!\\.))|[-!#\\$%&'\\*\\+/=\\?\\^`\\{\\}\\|~\\w])*)(?<=[0-9a-z])@))(?(\\[)(\\[(\\d{1,3}\\.){3}\\d{1,3}\\])|(([0-9a-z][-0-9a-z]*[0-9a-z]*\\.)+[a-z0-9][\\-a-z0-9]{0,22}[a-z0-9]))$", RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(250.0));
    }
    catch (RegexMatchTimeoutException ex)
    {
      return false;
    }
  }

  [CompilerGenerated]
  public static string \u003CIsValidEmail\u003Eg__DomainMapper\u007C84_0(Match match)
  {
    string ascii = new IdnMapping().GetAscii(match.Groups[2].Value);
    return match.Groups[1].Value + ascii;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: VersionCompatibility
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class VersionCompatibility : MonoBehaviour
{
  public static bool versionsGot;
  public static string previousVersion;
  public static string currentVersion;

  public void OnEnable() => global::Events.OnGameStart += new UnityAction(VersionCompatibility.GameStart);

  public void OnDisable() => global::Events.OnGameStart -= new UnityAction(VersionCompatibility.GameStart);

  public static void GetVersions()
  {
    if (VersionCompatibility.versionsGot)
      return;
    VersionCompatibility.currentVersion = Config.data.version;
    VersionCompatibility.previousVersion = SaveSystem.LoadProgressData<string>("version", "0");
  }

  public static void GameStart()
  {
    VersionCompatibility.GetVersions();
    if (VersionCompatibility.currentVersion != VersionCompatibility.previousVersion)
    {
      Debug.Log((object) ("Checking Version Compatibility [" + VersionCompatibility.previousVersion + "] → [" + VersionCompatibility.currentVersion + "]"));
      foreach (VersionCompatibility.Profile profile in new List<VersionCompatibility.Profile>()
      {
        new VersionCompatibility.Profile("Reset Progress", "63+", "0-62", new System.Action(VersionCompatibility.ResetProgress)),
        new VersionCompatibility.Profile("Reset Town Progress", "88+", "0-87", new System.Action(VersionCompatibility.ResetTownProgress)),
        new VersionCompatibility.Profile("Delete Campaign Save", "135+", "0-134", new System.Action(VersionCompatibility.DeleteCampaignSave)),
        new VersionCompatibility.Profile("Reset Progress", "153+", "0-152", new System.Action(VersionCompatibility.DeleteDefaultProfile)),
        new VersionCompatibility.Profile("Create Beta Profile", "175", "0-174", new System.Action(VersionCompatibility.CreateBetaProfile)),
        new VersionCompatibility.Profile("Copy Beta Profile", "177+", "175-176", new System.Action(VersionCompatibility.CopyBetaProfile)),
        new VersionCompatibility.Profile("Copy Beta Profile", "187+", "179-186", new System.Action(VersionCompatibility.CopyBetaProfile))
      })
        profile.Check(VersionCompatibility.currentVersion, VersionCompatibility.previousVersion);
      SaveSystem.SaveProgressData<string>("version", VersionCompatibility.currentVersion);
    }
    ProgressSaveData data = SaveSystem.LoadProgressData<ProgressSaveData>("progress");
    if (data == null)
      return;
    Debug.Log((object) "VersionCompatibility → Converting ProgressSaveData");
    VersionCompatibility.ConvertProgressSaveData(data);
  }

  public static void CreateBetaProfile() => ES3.CopyDirectory(SaveSystem.folderName, SaveSystem.profileFolder + "/Beta", SaveSystem.settings, SaveSystem.settings);

  public static void CopyBetaProfile()
  {
    if (!ES3.DirectoryExists(SaveSystem.profileFolder + "/Beta") || !ES3.FileExists(SaveSystem.profileFolder + "/Beta/Save.sav") || !SaveSystem.gotSaveTimestamp)
      return;
    DateTime timestamp = ES3.GetTimestamp(SaveSystem.profileFolder + "/Beta/Save.sav", SaveSystem.settings);
    if (timestamp > SaveSystem.saveTimestamp)
    {
      Debug.Log((object) string.Format("Beta Save Timestamp: {0}, Default: {1}, Copying Beta Save to Default", (object) timestamp, (object) SaveSystem.saveTimestamp));
      VersionCompatibility.CopyFileFromBetaProfile("Save.sav");
      VersionCompatibility.CopyFileFromBetaProfile("Stats.sav");
      VersionCompatibility.CopyFileFromBetaProfile("Campaign.sav");
      VersionCompatibility.CopyFileFromBetaProfile("CampaignDaily.sav");
      VersionCompatibility.CopyFileFromBetaProfile("CampaignTutorial.sav");
      VersionCompatibility.CopyFileFromBetaProfile("History.sav");
    }
    else
      Debug.Log((object) string.Format("Beta Save Timestamp: {0}, Default: {1}, Default is more recent, deleting Beta profile", (object) timestamp, (object) SaveSystem.saveTimestamp));
    ES3.DeleteDirectory(SaveSystem.profileFolder + "/Beta");
  }

  public static void CopyFileFromBetaProfile(string fileName) => VersionCompatibility.CopyFileData(SaveSystem.profileFolder + "/Beta/" + fileName, SaveSystem.folderName + "/" + fileName, SaveSystem.settings);

  public static void CopyFileData(string fromPath, string toPath, ES3Settings settings)
  {
    if (!ES3.FileExists(fromPath, settings))
      return;
    ES3.SaveRaw(ES3.LoadRawString(fromPath, settings), toPath, settings);
  }

  public static void DeleteDefaultProfile() => SaveSystem.DeleteProfile("Default");

  public static void ResetProgress()
  {
    if (!SaveSystem.ProgressExists())
      return;
    ProgressSaveData progressSaveData = SaveSystem.LoadProgressData<ProgressSaveData>("progress");
    SaveSystem.DeleteProgress();
    if (progressSaveData == null)
      return;
    SaveSystem.SaveProgressData<ProgressSaveData>("progress", progressSaveData);
  }

  public static void ResetTownProgress()
  {
    if (!SaveSystem.ProgressExists())
      return;
    SaveSystem.DeleteProgressData("townProgress");
    SaveSystem.DeleteProgressData("unlocked");
    SaveSystem.DeleteProgressData("townNew");
    SaveSystem.DeleteProgressData("finalBoss");
    SaveSystem.DeleteProgressData("finalBossEnemies");
    SaveSystem.DeleteProgressData("petHutUnlocks");
    SaveSystem.DeleteProgressData("inventorHutUnlocks");
    SaveSystem.DeleteProgressData("hotSpringUnlocks");
    SaveSystem.DeleteProgressData("completedChallenges");
    SaveSystem.DeleteProgressData("challengeProgress");
  }

  public static void ConvertProgressSaveData(ProgressSaveData data)
  {
    SaveSystem.SaveProgressData<int>("nextSeed", data.nextSeed);
    SaveSystem.SaveProgressData<int>("tutorialProgress", data.tutorialProgress);
    SaveSystem.SaveProgressData<bool>("tutorialCharmDone", data.tutorialCharmDone);
    SaveSystem.SaveProgressData<bool>("tutorialInjuryDone", data.tutorialInjuryDone);
    SaveSystem.DeleteProgressData("progress");
  }

  public static void DeleteCampaignSave() => SaveSystem.DeleteCampaign(AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal"));

  public readonly struct Profile
  {
    public readonly string name;
    public readonly int versionFrom;
    public readonly int versionTo;
    public readonly int incompatibleWithFrom;
    public readonly int incompatibleWithTo;
    public readonly System.Action action;

    public Profile(string name, string version, string incompatibleWith, System.Action action)
    {
      this.name = name;
      VersionCompatibility.Profile.ProcessVersionString(version, out this.versionFrom, out this.versionTo);
      VersionCompatibility.Profile.ProcessVersionString(incompatibleWith, out this.incompatibleWithFrom, out this.incompatibleWithTo);
      this.action = action;
    }

    public static void ProcessVersionString(string @in, out int lower, out int higher)
    {
      string[] strArray = @in.Split(new char[1]{ '-' }, StringSplitOptions.RemoveEmptyEntries);
      if (strArray.Length == 2)
      {
        int.TryParse(strArray[0], out lower);
        int.TryParse(strArray[1], out higher);
      }
      else
      {
        int.TryParse(@in.Replace("+", ""), out lower);
        higher = @in.EndsWith("+") ? 99999 : lower;
      }
    }

    public static bool InRange(int x, int a, int b) => a <= x && x <= b;

    public void Check(string currentVersion, string previousVersion)
    {
      int result1;
      int result2;
      if (!int.TryParse(previousVersion, out result1) || !VersionCompatibility.Profile.InRange(result1, this.incompatibleWithFrom, this.incompatibleWithTo) || !int.TryParse(currentVersion, out result2) || !VersionCompatibility.Profile.InRange(result2, this.versionFrom, this.versionTo))
        return;
      Debug.Log((object) ("Version [" + currentVersion + "] incompatible with [" + previousVersion + "] running [" + this.name + "] Script"));
      this.action();
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: VersionNumber
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Deadpan.Enums.Engine.Components.Modding;
using System;
using System.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

[RequireComponent(typeof (TMP_Text))]
public class VersionNumber : MonoBehaviour
{
  [SerializeField]
  public bool showProfile;
  [SerializeField]
  public bool showVersion = true;
  public TMP_Text _t;

  public TMP_Text textElement => this._t ?? (this._t = this.GetComponent<TMP_Text>());

  public void OnEnable()
  {
    global::Events.OnSaveSystemProfileChanged += new UnityAction(this.UpdateText);
    global::Events.OnModLoaded += new UnityAction<WildfrostMod>(this.ModStateChanged);
    global::Events.OnModUnloaded += new UnityAction<WildfrostMod>(this.ModStateChanged);
  }

  public void OnDisable()
  {
    global::Events.OnSaveSystemProfileChanged -= new UnityAction(this.UpdateText);
    global::Events.OnModLoaded -= new UnityAction<WildfrostMod>(this.ModStateChanged);
    global::Events.OnModUnloaded -= new UnityAction<WildfrostMod>(this.ModStateChanged);
  }

  public void Start() => this.UpdateText();

  public void ModStateChanged(WildfrostMod mod) => this.UpdateText();

  public void UpdateText()
  {
    string str = "";
    if (SaveSystem.Enabled && this.showProfile)
    {
      if (!str.IsNullOrWhitespace())
        str += "\n";
      str = str + "Profile: " + SaveSystem.Profile;
    }
    if (this.showVersion)
    {
      if (!str.IsNullOrWhitespace())
        str += "\n";
      str += string.Format(Config.data.versionFormat, (object) Config.data.versionNotation);
    }
    WildfrostMod[] array = Bootstrap.Mods.Where<WildfrostMod>((Func<WildfrostMod, bool>) (a => a.HasLoaded)).ToArray<WildfrostMod>();
    if (array.Length != 0)
    {
      str += "<#ff3><size=0.3>";
      foreach (WildfrostMod wildfrostMod in array)
        str = str + "\n" + wildfrostMod.Title;
    }
    this.textElement.text = str;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: VfxDeathSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class VfxDeathSystem : GameSystem
{
  [SerializeField]
  public GameObject sacrificeFX;

  public void OnEnable() => global::Events.OnEntityKilled += new UnityAction<Entity, DeathType>(this.EntityKilled);

  public void OnDisable() => global::Events.OnEntityKilled -= new UnityAction<Entity, DeathType>(this.EntityKilled);

  public void EntityKilled(Entity entity, DeathType deathType)
  {
    if (!DeathSystem.KilledByOwnTeam(entity) || !(bool) (Object) this.sacrificeFX)
      return;
    Transform transform = entity.transform;
    this.CreateEffect(this.sacrificeFX, transform.position, transform.lossyScale);
  }

  public void CreateEffect(GameObject prefab, Vector3 position, Vector3 scale)
  {
    if (!(bool) (Object) prefab)
      return;
    Object.Instantiate<GameObject>(prefab, position, Quaternion.identity, this.transform).transform.localScale = scale;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: VfxHitSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using System;
using UnityEngine;
using UnityEngine.Events;

public class VfxHitSystem : GameSystem
{
  [SerializeField]
  public AnimationCurve profileCurve;
  [SerializeField]
  public VfxHitSystem.Profile[] profiles;
  [SerializeField]
  public VfxHitSystem.WithStatusProfile[] withStatusProfiles;

  public VfxHitSystem.Profile GetProfile(int power) => this.profiles[Mathf.Clamp(Mathf.RoundToInt(this.profileCurve.Evaluate((float) power)), 0, this.profiles.Length - 1)];

  public static int GetHitPower(Hit hit) => hit.damage + hit.damageBlocked + hit.extraOffensiveness;

  public void OnEnable() => global::Events.OnEntityHit += new UnityAction<Hit>(this.EntityHit);

  public void OnDisable() => global::Events.OnEntityHit -= new UnityAction<Hit>(this.EntityHit);

  public void EntityHit(Hit hit)
  {
    if (!hit.Offensive || !hit.doAnimation || !hit.countsAsHit || !hit.BasicHit || VfxHitSystem.GetHitPower(hit) <= 0 || !(bool) (UnityEngine.Object) hit.target)
      return;
    this.TakeHit(hit);
  }

  public void TakeHit(Hit hit)
  {
    Vector3 position1 = hit.target.transform.position;
    Vector3 position2 = position1;
    if ((bool) (UnityEngine.Object) hit.attacker)
    {
      Vector3 normalized = (position2 - hit.attacker.transform.position).normalized;
      position2 += normalized * -1f;
      position2.z = hit.target.transform.position.z;
    }
    VfxHitSystem.Profile profile = this.GetProfile(VfxHitSystem.GetHitPower(hit));
    if ((bool) (UnityEngine.Object) profile.effectPrefab)
      this.CreateEffect(profile.effectPrefab, position2, hit.target.transform.lossyScale);
    foreach (VfxHitSystem.WithStatusProfile withStatusProfile in this.withStatusProfiles)
    {
      if ((bool) (UnityEngine.Object) hit.target.FindStatus(withStatusProfile.statusType))
      {
        this.CreateEffect(withStatusProfile.effectPrefab, position1, hit.target.transform.lossyScale);
        if (!withStatusProfile.sfxEvent.IsNull)
          SfxSystem.OneShot(withStatusProfile.sfxEvent);
      }
    }
  }

  public void CreateEffect(GameObject prefab, Vector3 position, Vector3 scale)
  {
    if (!(bool) (UnityEngine.Object) prefab)
      return;
    UnityEngine.Object.Instantiate<GameObject>(prefab, position, Quaternion.identity, this.transform).transform.localScale = scale;
  }

  [Serializable]
  public class Profile
  {
    public GameObject effectPrefab;
  }

  [Serializable]
  public class WithStatusProfile
  {
    public string statusType;
    public GameObject effectPrefab;
    public EventReference sfxEvent;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: VfxStatusSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class VfxStatusSystem : GameSystem
{
  [SerializeField]
  public VfxStatusSystem.Profile[] profiles;
  [SerializeField]
  public VfxStatusSystem.DamageProfile[] damageProfiles;
  public Dictionary<string, VfxStatusSystem.Profile> profileLookup;
  public Dictionary<string, VfxStatusSystem.DamageProfile> damageProfileLookup;

  public void OnEnable()
  {
    global::Events.OnStatusEffectApplied += new UnityAction<StatusEffectApply>(this.StatusApplied);
    global::Events.OnEntityHit += new UnityAction<Hit>(this.EntityHit);
    this.profileLookup = new Dictionary<string, VfxStatusSystem.Profile>();
    foreach (VfxStatusSystem.Profile profile in this.profiles)
      this.profileLookup[profile.type] = profile;
    this.damageProfileLookup = new Dictionary<string, VfxStatusSystem.DamageProfile>();
    foreach (VfxStatusSystem.DamageProfile damageProfile in this.damageProfiles)
      this.damageProfileLookup[damageProfile.damageType] = damageProfile;
  }

  public void OnDisable()
  {
    global::Events.OnStatusEffectApplied -= new UnityAction<StatusEffectApply>(this.StatusApplied);
    global::Events.OnEntityHit -= new UnityAction<Hit>(this.EntityHit);
  }

  public void StatusApplied(StatusEffectApply apply)
  {
    if (!(bool) (UnityEngine.Object) apply?.effectData || !apply.target.display.init || !apply.target.startingEffectsApplied || Transition.Running || !this.profileLookup.ContainsKey(apply.effectData.type))
      return;
    VfxStatusSystem.Profile profile = this.profileLookup[apply.effectData.type];
    if (profile == null || !(bool) (UnityEngine.Object) profile.applyEffectPrefab)
      return;
    Transform transform = apply.target.transform;
    this.CreateEffect(profile.applyEffectPrefab, transform.position, transform.lossyScale);
  }

  public void EntityHit(Hit hit)
  {
    if (hit.BasicHit || !this.damageProfileLookup.ContainsKey(hit.damageType))
      return;
    VfxStatusSystem.DamageProfile damageProfile = this.damageProfileLookup[hit.damageType];
    if (damageProfile == null || !((UnityEngine.Object) damageProfile.damageEffectPrefab != (UnityEngine.Object) null))
      return;
    this.CreateEffect(damageProfile.damageEffectPrefab, hit.target.transform.position, hit.target.transform.lossyScale);
  }

  public void CreateEffect(GameObject prefab, Vector3 position, Vector3 scale) => UnityEngine.Object.Instantiate<GameObject>(prefab, position, Quaternion.identity, this.transform).transform.localScale = scale;

  [Serializable]
  public class Profile
  {
    public string type;
    public GameObject applyEffectPrefab;
  }

  [Serializable]
  public class DamageProfile
  {
    public string damageType;
    public GameObject damageEffectPrefab;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: VirtualPointer
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public class VirtualPointer : MonoBehaviourSingleton<VirtualPointer>
{
  public static void Hide()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      return;
    MonoBehaviourSingleton<VirtualPointer>.instance.gameObject.SetActive(false);
  }

  public static void Show()
  {
    if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
      return;
    MonoBehaviourSingleton<VirtualPointer>.instance.gameObject.SetActive(true);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: WarningTutorialSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;

public class WarningTutorialSystem : GameSystem
{
  [SerializeField]
  public LocalizedString promptStringRef;
  public bool promptShown;

  public void OnEnable()
  {
    global::Events.OnCheckAction += new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
    global::Events.OnActionPerform += new UnityAction<PlayAction>(this.ActionPerform);
  }

  public void OnDisable()
  {
    global::Events.OnCheckAction -= new global::Events.UnityActionRef<PlayAction, bool>(this.CheckAction);
    global::Events.OnActionPerform -= new UnityAction<PlayAction>(this.ActionPerform);
  }

  public void CheckAction(ref PlayAction action, ref bool allow)
  {
    if (this.promptShown || !(action is ActionTriggerAgainst actionTriggerAgainst) || !((UnityEngine.Object) actionTriggerAgainst.triggeredBy == (UnityEngine.Object) References.Player.entity))
      return;
    int damage;
    bool instantKill;
    WarningTutorialSystem.GetDamageDetails(actionTriggerAgainst.entity, out damage, out instantKill);
    if (!(damage > 0 | instantKill))
      return;
    Entity entity = (Entity) null;
    if ((bool) (UnityEngine.Object) actionTriggerAgainst.targetContainer)
      entity = actionTriggerAgainst.targetContainer.FirstOrDefault<Entity>((Func<Entity, bool>) (a => a.data.cardType.miniboss && (UnityEngine.Object) a.owner == (UnityEngine.Object) References.Player));
    else if (actionTriggerAgainst.target.data.cardType.miniboss && (UnityEngine.Object) actionTriggerAgainst.target.owner == (UnityEngine.Object) References.Player)
      entity = actionTriggerAgainst.target;
    if (!(bool) (UnityEngine.Object) entity)
      return;
    if (instantKill)
    {
      allow = false;
      this.ShowPrompt(actionTriggerAgainst.entity);
    }
    else
    {
      if ((bool) (UnityEngine.Object) entity.FindStatus("block"))
        return;
      int current = entity.hp.current;
      StatusEffectData status = entity.FindStatus("shell");
      if ((bool) (UnityEngine.Object) status)
        current += status.count;
      if (current > damage)
        return;
      allow = false;
      this.ShowPrompt(actionTriggerAgainst.entity);
    }
  }

  public static void GetDamageDetails(Entity entity, out int damage, out bool instantKill)
  {
    instantKill = false;
    damage = entity.damage.current + entity.tempDamage.Value;
    foreach (CardData.StatusEffectStacks attackEffect in entity.attackEffects)
    {
      if (attackEffect.data is StatusEffectInstantSacrifice)
        instantKill = true;
    }
  }

  public void ActionPerform(PlayAction action)
  {
    if (!this.promptShown)
      return;
    this.HidePrompt();
  }

  public void ShowPrompt(Entity attackingCard)
  {
    PromptSystem.Hide();
    PromptSystem.Create(Prompt.Anchor.Left, 0.0f, 1f, 3f, Prompt.Emote.Type.Scared);
    PromptSystem.SetTextAction((Prompt.GetTextCallback) (() => this.promptStringRef.GetLocalizedString((object) attackingCard.data.title)));
    PromptSystem.Shake();
    this.promptShown = true;
  }

  public void HidePrompt()
  {
    PromptSystem.Hide();
    this.promptShown = false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: WaveDeployerDots
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using UnityEngine;

public class WaveDeployerDots : MonoBehaviour
{
  [SerializeField]
  public float fanRadius = 0.5f;
  [SerializeField]
  public float startAngle = -90f;
  [SerializeField]
  public float arcMax = 90f;
  [SerializeField]
  public float arcGap = 20f;
  public List<WaveDot> dots;
  [SerializeField]
  public Transform dotContainer;
  [SerializeField]
  public WaveDot dotPrefab;
  [SerializeField]
  public WaveDot bigDotPrefab;

  public void Init(BattleWaveManager waveManager, int currentWaveIndex)
  {
    foreach (Component dot in this.dots)
      dot.gameObject.Destroy();
    this.dots = new List<WaveDot>();
    foreach (BattleWaveManager.Wave wave in waveManager.list)
    {
      WaveDot waveDot = UnityEngine.Object.Instantiate<WaveDot>(wave.isBossWave ? this.bigDotPrefab : this.dotPrefab, this.dotContainer);
      waveDot.gameObject.SetActive(true);
      this.dots.Add(waveDot);
    }
    this.SetPositions();
    this.UpdateDots(waveManager, currentWaveIndex);
  }

  public void UpdateDots(BattleWaveManager waveManager, int currentWaveIndex)
  {
    for (int index = 0; index < this.dots.Count; ++index)
    {
      if (waveManager.list[index].spawned && currentWaveIndex != index)
        this.dots[index].TurnOff();
    }
  }

  public void SetPositions()
  {
    for (int index = 0; index < this.dots.Count; ++index)
      this.dots[index].transform.localPosition = this.GetPosition(index);
  }

  public Vector3 GetPosition(int index) => (Vector3) Lengthdir.ToVector2(this.fanRadius, (float) (((double) this.GetAngle(index) + (double) this.startAngle) * (Math.PI / 180.0)));

  public float GetAngle(int index)
  {
    float angleAdd = this.GetAngleAdd();
    return (float) (-(double) angleAdd * (double) (this.dots.Count - 1) * 0.5 + (double) angleAdd * (double) index);
  }

  public float GetAngleAdd()
  {
    int num = this.dots.Count - 1;
    return Mathf.Min((float) num * this.arcGap, this.arcMax) / (float) num;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: WaveDeploySystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class WaveDeploySystem : GameSystem
{
  public bool visible = true;
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public WaveDeployerDots dotManager;
  [SerializeField]
  public TMP_Text counterText;
  [SerializeField]
  public GameObject group;
  [SerializeField]
  public UINavigationItem navigationItem;
  [Header("Settings")]
  [SerializeField]
  public int counterStart = -1;
  [SerializeField]
  public bool recallWhenUnsuccessful;
  [SerializeField]
  public int damageToOpponent;
  [SerializeField]
  public int damageIncreasePerTurn;
  [SerializeField]
  public float pauseAfterDeploy = 0.2f;
  public bool inBattle;
  public int damageToOpponentCurrent;
  public int currentWave;
  public BattleWaveManager waveManager;
  public int counter;
  public int counterMax;
  public bool reset;
  public bool deploySuccessful;
  public List<Entity> deployed;
  public static UINavigationItem nav;

  public void Awake()
  {
    this.group.SetActive(false);
    WaveDeploySystem.nav = this.navigationItem;
  }

  public void OnEnable()
  {
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
  }

  public void OnDisable()
  {
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
  }

  public void BattlePhaseStart(Battle.Phase phase)
  {
    if (this.inBattle)
    {
      if (phase != Battle.Phase.Play || References.Battle.turnCount <= 0)
        return;
      ActionSequence action = new ActionSequence(this.CountDown());
      action.parallel = true;
      ActionQueue.Add((PlayAction) action);
    }
    else
    {
      if (phase != Battle.Phase.Init)
        return;
      this.BattleStart();
    }
  }

  public void SceneChanged(Scene scene)
  {
    if (!this.inBattle)
      return;
    this.Hide();
    this.inBattle = false;
  }

  public void BattleStart()
  {
    this.inBattle = true;
    this.damageToOpponentCurrent = this.damageToOpponent;
    this.currentWave = 0;
    this.waveManager = References.Battle.enemy.GetComponent<BattleWaveManager>();
    this.counter = this.counterStart;
    this.reset = false;
    if (this.visible)
      this.Show();
    this.dotManager.Init(this.waveManager, this.currentWave);
    ActionSequence action = new ActionSequence(this.CountDown());
    action.parallel = true;
    ActionQueue.Add((PlayAction) action);
  }

  public void Close() => this.animator.SetBool(nameof (Close), true);

  public void Open() => this.animator.SetBool("Close", false);

  public void Show()
  {
    this.visible = true;
    this.group.SetActive(true);
    this.animator.SetTrigger("Reveal");
    SfxSystem.OneShot("event:/sfx/inventory/wave_counter_showup");
  }

  public void Hide() => this.group.SetActive(false);

  public IEnumerator CountDown()
  {
    if (this.currentWave < this.waveManager.list.Count)
    {
      bool earlyDeploy = this.CheckEarlyDeploy();
      if (this.visible)
      {
        this.Close();
        if (this.counter <= 1 | earlyDeploy)
          SfxSystem.OneShot("event:/sfx/inventory/wave_counter_decrease_last");
        else
          SfxSystem.OneShot("event:/sfx/inventory/wave_counter_decrease");
        yield return (object) Sequences.Wait(0.1f);
      }
      if (earlyDeploy)
        this.counter = 1;
      if (this.reset)
      {
        this.reset = false;
      }
      else
      {
        this.SetCounter(Mathf.Clamp(this.counter - 1, 0, this.counterMax));
        if (this.counter <= 0)
          yield return (object) this.Activate();
      }
      if (this.visible && this.counter > 0)
      {
        this.Open();
        if (this.counter == this.counterMax)
          SfxSystem.OneShot("event:/sfx/inventory/wave_counter_refresh");
      }
    }
  }

  public void SetCounter(int value)
  {
    this.counter = value;
    this.counterText.text = value.ToString();
  }

  public void SetCounterMax(int value)
  {
    this.counterMax = value;
    this.SetCounter(value);
  }

  public bool CheckEarlyDeploy() => Battle.GetCardsOnBoard(References.Battle.enemy).Count <= 0;

  public IEnumerator Activate()
  {
    WaveDeploySystem waveDeploySystem1 = this;
    int thisWaveIndex = waveDeploySystem1.currentWave;
    int targetRow = Random.Range(0, Battle.instance.rowCount);
    yield return (object) Sequences.Wait(0.2f);
    yield return (object) waveDeploySystem1.TryDeploy(targetRow);
    if (waveDeploySystem1.deploySuccessful)
    {
      yield return (object) waveDeploySystem1.RevealBoard();
      WaveDeploySystem waveDeploySystem2 = waveDeploySystem1;
      int num1 = waveDeploySystem1.currentWave + 1;
      int num2 = num1;
      waveDeploySystem2.currentWave = num2;
      if (num1 < waveDeploySystem1.waveManager.list.Count)
      {
        BattleWaveManager.Wave wave = waveDeploySystem1.waveManager.list[waveDeploySystem1.currentWave];
        waveDeploySystem1.SetCounterMax(wave.counter);
      }
      waveDeploySystem1.damageToOpponentCurrent = waveDeploySystem1.damageToOpponent;
    }
    else
    {
      Routine.Clump clump = new Routine.Clump();
      if (waveDeploySystem1.recallWhenUnsuccessful)
      {
        yield return (object) Sequences.Wait(0.33f);
        foreach (Entity entity in waveDeploySystem1.deployed)
          clump.Add(Sequences.CardMove(entity, new CardContainer[1]
          {
            References.Battle.enemy.reserveContainer
          }));
        yield return (object) clump.WaitForEnd();
      }
      else
        yield return (object) waveDeploySystem1.RevealBoard();
      if (waveDeploySystem1.damageToOpponentCurrent > 0)
      {
        Entity entity = References.Player.entity;
        if ((Object) entity != (Object) null && entity.canBeHit)
        {
          clump.Add(new Hit(References.Battle.enemy.entity, entity, waveDeploySystem1.damageToOpponentCurrent).Process());
          clump.Add(Sequences.Wait(0.2f));
        }
      }
      yield return (object) clump.WaitForEnd();
      waveDeploySystem1.damageToOpponentCurrent += waveDeploySystem1.damageIncreasePerTurn;
      waveDeploySystem1.SetCounter(1);
      clump = (Routine.Clump) null;
    }
    waveDeploySystem1.waveManager.list[thisWaveIndex].spawned = true;
    if ((Object) waveDeploySystem1.dotManager != (Object) null)
      waveDeploySystem1.dotManager.UpdateDots(waveDeploySystem1.waveManager, thisWaveIndex);
  }

  public IEnumerator TryDeploy(int rowIndex)
  {
    if (this.deployed == null)
      this.deployed = new List<Entity>();
    this.deployed.Clear();
    this.deploySuccessful = true;
    Entity[] entityArray = this.waveManager.Peek();
    for (int index = 0; index < entityArray.Length; ++index)
    {
      Entity e = entityArray[index];
      if ((Object) e != (Object) null && e.containers.Contains<CardContainer>(e.owner.reserveContainer))
      {
        for (int index1 = 0; index1 < References.Battle.rowCount; ++index1)
        {
          rowIndex = (rowIndex + 1) % References.Battle.rowCount;
          int targetColumn;
          if (References.Battle.CanDeploy(e, rowIndex, out targetColumn))
          {
            this.Deploy(e, rowIndex, targetColumn);
            this.deployed.Add(e);
            yield return (object) ActionQueue.Wait(false);
            break;
          }
        }
        if (!this.deployed.Contains(e))
          this.deploySuccessful = false;
      }
      e = (Entity) null;
    }
    entityArray = (Entity[]) null;
    if (this.deploySuccessful)
      this.waveManager.Pull();
  }

  public void Deploy(Entity entity, int targetRow, int targetColumn)
  {
    List<CardContainer> rows = Battle.instance.GetRows(entity.owner);
    List<CardContainer> cardContainerList = new List<CardContainer>();
    for (int index = 0; index < entity.height; ++index)
    {
      CardContainer cardContainer = rows[(targetRow + index) % rows.Count];
      cardContainerList.Add(cardContainer);
    }
    entity.flipper.FlipUpInstant();
    ActionMove action = new ActionMove(entity, cardContainerList.ToArray());
    action.insertPos = targetColumn;
    action.pauseAfter = this.pauseAfterDeploy;
    ActionQueue.Add((PlayAction) action);
  }

  public IEnumerator RevealBoard()
  {
    ActionQueue.Add((PlayAction) new ActionRevealAll(References.Battle.GetRows(References.Battle.enemy).ToArray()));
    yield return (object) ActionQueue.Wait(false);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: WaveDeploySystemNoLimit
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class WaveDeploySystemNoLimit : GameSystem
{
  [SerializeField]
  public GameObject blocker;
  [SerializeField]
  public GameObject icon;
  [SerializeField]
  public CanvasGroup group;
  [SerializeField]
  public TMP_Text numberElement;
  [Header("Settings")]
  [SerializeField]
  public int counterStart = -1;
  [SerializeField]
  public int counterMax = 3;
  [SerializeField]
  public int popUpCounterAt = 5;
  [SerializeField]
  public int bigIconAt = 3;
  [SerializeField]
  public Vector3 smallIconPos = new Vector3(0.0f, 3.4f, 0.0f);
  [SerializeField]
  public Vector3 smallIconScale = new Vector3(0.5f, 0.5f, 1f);
  [SerializeField]
  public float pauseAfterDeploy = 0.2f;
  [SerializeField]
  public bool countWhenXEnemies;
  [SerializeField]
  [ShowIf("countWhenXEnemies")]
  public int countWhenEnemiesRemaining = 1;
  [SerializeField]
  public bool needSpace = true;
  public bool inBattle;
  public int currentWave;
  public BattleWaveManager waveManager;
  public int counter;
  public bool reset;
  public bool deploySuccessful;
  public List<Entity> deployed;

  public void OnEnable()
  {
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
  }

  public void OnDisable()
  {
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
  }

  public void BattlePhaseStart(Battle.Phase phase)
  {
    if (this.inBattle)
    {
      if (phase != Battle.Phase.Play || References.Battle.turnCount <= 0)
        return;
      ActionSequence action = new ActionSequence(this.CountDown());
      action.parallel = true;
      ActionQueue.Add((PlayAction) action);
    }
    else
    {
      if (phase != Battle.Phase.Init)
        return;
      this.BattleStart();
    }
  }

  public void SceneChanged(Scene scene)
  {
    if (!this.inBattle)
      return;
    this.inBattle = false;
  }

  public void BattleStart()
  {
    this.inBattle = true;
    this.currentWave = 0;
    this.waveManager = References.Battle.enemy.GetComponent<BattleWaveManager>();
    this.counter = this.counterStart;
    this.reset = false;
    ActionSequence action = new ActionSequence(this.CountDown());
    action.parallel = true;
    ActionQueue.Add((PlayAction) action);
  }

  public IEnumerator CountDown()
  {
    int enemyCount = WaveDeploySystemNoLimit.GetEnemyCount();
    if ((!this.countWhenXEnemies || enemyCount <= this.countWhenEnemiesRemaining) && this.currentWave < this.waveManager.list.Count && References.Battle.GetRows(References.Battle.enemy).Cast<CardSlotLane>().SelectMany<CardSlotLane, CardSlot>((Func<CardSlotLane, IEnumerable<CardSlot>>) (a => (IEnumerable<CardSlot>) a.slots)).Count<CardSlot>((Func<CardSlot, bool>) (a => a.Empty)) >= this.waveManager.list[this.currentWave].units.Count)
    {
      if (enemyCount <= 0)
        this.counter = 0;
      --this.counter;
      if (this.counter <= 0)
        yield return (object) this.Activate();
      else if (this.counter <= this.popUpCounterAt)
      {
        Routine routine = new Routine(this.Pop());
      }
    }
  }

  public IEnumerator Pop()
  {
    WaveDeploySystemNoLimit deploySystemNoLimit = this;
    deploySystemNoLimit.numberElement.text = deploySystemNoLimit.counter.ToString();
    deploySystemNoLimit.group.gameObject.SetActive(true);
    deploySystemNoLimit.blocker.SetActive(true);
    deploySystemNoLimit.group.alpha = 0.0f;
    deploySystemNoLimit.icon.transform.localPosition = deploySystemNoLimit.counter <= deploySystemNoLimit.bigIconAt ? Vector3.zero : deploySystemNoLimit.smallIconPos;
    Vector3 to = deploySystemNoLimit.counter <= deploySystemNoLimit.bigIconAt ? Vector3.one : deploySystemNoLimit.smallIconScale;
    deploySystemNoLimit.icon.transform.localScale = to * 1.5f;
    LeanTween.scale(deploySystemNoLimit.icon, to, 1.5f).setEaseOutElastic();
    LeanTween.value(deploySystemNoLimit.gameObject, 0.0f, 1f, 0.25f).setEaseLinear().setOnUpdate(new Action<float>(deploySystemNoLimit.\u003CPop\u003Eb__27_0));
    deploySystemNoLimit.blocker.SetActive(false);
    yield return (object) new WaitForSeconds(1f);
    LeanTween.value(deploySystemNoLimit.gameObject, 1f, 0.0f, 0.15f).setEaseLinear().setOnUpdate(new Action<float>(deploySystemNoLimit.\u003CPop\u003Eb__27_1)).setOnComplete(new System.Action(deploySystemNoLimit.\u003CPop\u003Eb__27_2));
  }

  public IEnumerator Activate()
  {
    WaveDeploySystemNoLimit deploySystemNoLimit1 = this;
    int thisWaveIndex = deploySystemNoLimit1.currentWave;
    int targetRow = UnityEngine.Random.Range(0, Battle.instance.rowCount);
    yield return (object) Sequences.Wait(0.2f);
    yield return (object) deploySystemNoLimit1.TryDeploy(targetRow);
    if (deploySystemNoLimit1.deploySuccessful)
    {
      yield return (object) WaveDeploySystemNoLimit.RevealBoard();
      WaveDeploySystemNoLimit deploySystemNoLimit2 = deploySystemNoLimit1;
      int num1 = deploySystemNoLimit1.currentWave + 1;
      int num2 = num1;
      deploySystemNoLimit2.currentWave = num2;
      if (num1 < deploySystemNoLimit1.waveManager.list.Count)
        deploySystemNoLimit1.counter = deploySystemNoLimit1.counterMax + 1;
    }
    else
    {
      yield return (object) WaveDeploySystemNoLimit.RevealBoard();
      deploySystemNoLimit1.counter = 1;
    }
    deploySystemNoLimit1.waveManager.list[thisWaveIndex].spawned = true;
  }

  public IEnumerator TryDeploy(int rowIndex)
  {
    if (this.deployed == null)
      this.deployed = new List<Entity>();
    this.deployed.Clear();
    this.deploySuccessful = true;
    Entity[] entityArray = this.waveManager.Peek();
    for (int index = 0; index < entityArray.Length; ++index)
    {
      Entity e = entityArray[index];
      if ((UnityEngine.Object) e != (UnityEngine.Object) null && e.containers.Contains<CardContainer>(e.owner.reserveContainer))
      {
        for (int index1 = 0; index1 < References.Battle.rowCount; ++index1)
        {
          rowIndex = (rowIndex + 1) % References.Battle.rowCount;
          int targetColumn;
          if (References.Battle.CanDeploy(e, rowIndex, out targetColumn))
          {
            this.Deploy(e, rowIndex, targetColumn);
            this.deployed.Add(e);
            yield return (object) ActionQueue.Wait(false);
            break;
          }
        }
        if (!this.deployed.Contains(e))
          this.deploySuccessful = false;
      }
      e = (Entity) null;
    }
    entityArray = (Entity[]) null;
    if (this.deploySuccessful)
      this.waveManager.Pull();
  }

  public void Deploy(Entity entity, int targetRow, int targetColumn)
  {
    List<CardContainer> rows = Battle.instance.GetRows(entity.owner);
    List<CardContainer> cardContainerList = new List<CardContainer>();
    for (int index = 0; index < entity.height; ++index)
    {
      CardContainer cardContainer = rows[(targetRow + index) % rows.Count];
      cardContainerList.Add(cardContainer);
    }
    entity.flipper.FlipUpInstant();
    ActionMove action = new ActionMove(entity, cardContainerList.ToArray());
    action.insertPos = targetColumn;
    action.pauseAfter = this.pauseAfterDeploy;
    ActionQueue.Add((PlayAction) action);
  }

  public static IEnumerator RevealBoard()
  {
    ActionQueue.Add((PlayAction) new ActionRevealAll(References.Battle.GetRows(References.Battle.enemy).ToArray()));
    yield return (object) ActionQueue.Wait(false);
  }

  public static int GetEnemyCount() => Battle.GetCardsOnBoard(References.Battle.enemy).Count<Entity>((Func<Entity, bool>) (a => !a.data.cardType.miniboss));

  [CompilerGenerated]
  public void \u003CPop\u003Eb__27_0(float a) => this.group.alpha = a;

  [CompilerGenerated]
  public void \u003CPop\u003Eb__27_1(float a) => this.group.alpha = a;

  [CompilerGenerated]
  public void \u003CPop\u003Eb__27_2() => this.group.gameObject.SetActive(false);
}
﻿// Decompiled with JetBrains decompiler
// Type: WaveDeploySystemOverflow
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Localization;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class WaveDeploySystemOverflow : GameSystem, ISaveable<BattleWaveData>
{
  public bool visible = true;
  [SerializeField]
  public UnityEngine.Animator animator;
  [SerializeField]
  public TMP_Text counterText;
  [SerializeField]
  public GameObject group;
  public UINavigationItem navigationItem;
  [SerializeField]
  public CanvasGroup canvasGroup;
  [SerializeField]
  public Button button;
  [Header("Glow")]
  [SerializeField]
  public Image glow;
  [SerializeField]
  public Color glowColor = Color.black;
  [SerializeField]
  public Color glowImminentColor = Color.red;
  [Header("Deploy Early")]
  [SerializeField]
  public int deployEarlyReward;
  [SerializeField]
  public int deployEarlyRewardPerTurn = 5;
  [SerializeField]
  public bool autoEarlyDeploy = true;
  [SerializeField]
  public bool canCallEarly;
  [Header("Popup")]
  [SerializeField]
  public LocalizedString popupDesc;
  [SerializeField]
  public LocalizedString popupHitDesc;
  [SerializeField]
  public LocalizedString popupOverflowDesc;
  [SerializeField]
  public LocalizedString popupRewardDesc;
  [Header("Settings")]
  [SerializeField]
  public KeywordData popup;
  [SerializeField]
  public int counterStart = -1;
  [SerializeField]
  public float pauseAfterDeploy = 0.2f;
  public bool inBattle;
  public int currentWave;
  public int counter;
  public bool reset;
  public float fade = 1f;
  public float fadeTo;
  public float fadeAdd = 5f;
  public bool popped;
  public List<BattleWaveManager.Wave> waves;
  public List<Entity> deployedThisTurn;
  public List<ulong> deployed;
  public int overflowWaveIndex = -1;

  public void Awake()
  {
    this.group.SetActive(false);
    WaveDeploySystem.nav = this.navigationItem;
  }

  public void OnEnable()
  {
    global::Events.OnBattlePhaseStart += new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
  }

  public void OnDisable()
  {
    global::Events.OnBattlePhaseStart -= new UnityAction<Battle.Phase>(this.BattlePhaseStart);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
    this.StopAllCoroutines();
  }

  public void Update()
  {
    float f = this.fadeTo - this.fade;
    float max = this.fadeAdd * Time.deltaTime;
    if ((double) Mathf.Abs(f) < (double) max)
      return;
    this.fade += Mathf.Clamp(f, -max, max);
    if ((double) Mathf.Abs(this.fadeTo - this.fade) <= (double) max)
      this.fade = this.fadeTo;
    this.canvasGroup.alpha = this.fade;
  }

  public void BattlePhaseStart(Battle.Phase phase)
  {
    if (this.inBattle)
    {
      if (phase != Battle.Phase.Play)
        return;
      if (References.Battle.turnCount == 0)
      {
        if (!this.visible)
          return;
        this.Show();
      }
      else
      {
        ActionSequence action = new ActionSequence(this.CountDown());
        action.parallel = true;
        ActionQueue.Add((PlayAction) action);
      }
    }
    else if (phase == Battle.Phase.Init)
    {
      this.BattleStart();
    }
    else
    {
      if (phase != Battle.Phase.Play)
        return;
      this.inBattle = true;
    }
  }

  public void SceneChanged(Scene scene)
  {
    if (scene.name == "Battle")
    {
      this.Hide();
    }
    else
    {
      if (!this.inBattle)
        return;
      this.Hide();
      this.BattleEnd();
    }
  }

  public void BattleStart()
  {
    this.inBattle = true;
    this.currentWave = 0;
    this.overflowWaveIndex = -1;
    this.waves = new List<BattleWaveManager.Wave>((IEnumerable<BattleWaveManager.Wave>) References.Battle.enemy.GetComponent<BattleWaveManager>().list);
    this.deployedThisTurn = new List<Entity>();
    this.deployed = new List<ulong>();
    this.counter = this.counterStart;
    this.reset = false;
    ActionSequence action = new ActionSequence(this.CountDown());
    action.parallel = true;
    ActionQueue.Add((PlayAction) action);
  }

  public void BattleEnd()
  {
    this.inBattle = false;
    this.currentWave = 0;
    this.overflowWaveIndex = -1;
    this.waves = (List<BattleWaveManager.Wave>) null;
    this.deployedThisTurn = (List<Entity>) null;
    this.deployed = (List<ulong>) null;
    this.counter = 0;
    this.reset = false;
  }

  public void AssignCardController(CardController controller) => this.GetComponentInChildren<ToggleBasedOnCardController>(true)?.AssignCardController(controller);

  public void Close() => this.animator.SetBool(nameof (Close), true);

  public void Open() => this.animator.SetBool("Close", false);

  public void Show()
  {
    if (this.visible && this.currentWave < this.waves.Count)
    {
      this.group.SetActive(true);
      this.FadeIn();
      SfxSystem.OneShot("event:/sfx/inventory/wave_counter_showup");
      this.button.interactable = this.canCallEarly;
    }
    this.AssignCardController(References.Battle.playerCardController);
  }

  public void Hide()
  {
    this.group.SetActive(false);
    this.FadeOut();
  }

  public void FadeIn()
  {
    this.fade = 0.0f;
    this.fadeTo = 1f;
    this.canvasGroup.blocksRaycasts = true;
  }

  public void FadeOut()
  {
    this.fadeTo = 0.0f;
    this.canvasGroup.blocksRaycasts = false;
  }

  public IEnumerator CountDown()
  {
    WaveDeploySystemOverflow deploySystemOverflow = this;
    if (deploySystemOverflow.currentWave < deploySystemOverflow.waves.Count)
    {
      global::Events.InvokeWaveDeployerPreCountDown(deploySystemOverflow.counter);
      bool earlyDeploy = WaveDeploySystemOverflow.CheckEarlyDeploy();
      if (deploySystemOverflow.visible)
      {
        deploySystemOverflow.Close();
        if (deploySystemOverflow.counter <= 1 | earlyDeploy)
          SfxSystem.OneShot("event:/sfx/inventory/wave_counter_decrease_last");
        else
          SfxSystem.OneShot("event:/sfx/inventory/wave_counter_decrease");
        yield return (object) Sequences.Wait(0.1f);
        if (!(bool) (UnityEngine.Object) deploySystemOverflow)
          yield break;
      }
      if (earlyDeploy && (References.Battle.turnCount == 0 || deploySystemOverflow.autoEarlyDeploy))
        deploySystemOverflow.counter = 1;
      if (deploySystemOverflow.reset)
      {
        deploySystemOverflow.reset = false;
      }
      else
      {
        deploySystemOverflow.SetCounter(Mathf.Max(deploySystemOverflow.counter - 1, 0));
        if (deploySystemOverflow.counter <= 0)
        {
          yield return (object) deploySystemOverflow.Activate();
          if (!(bool) (UnityEngine.Object) deploySystemOverflow)
            yield break;
        }
      }
      if (deploySystemOverflow.visible && deploySystemOverflow.counter > 0)
      {
        deploySystemOverflow.Open();
        if (deploySystemOverflow.counter == deploySystemOverflow.waves[deploySystemOverflow.currentWave].counter)
          SfxSystem.OneShot("event:/sfx/inventory/wave_counter_refresh");
      }
      global::Events.InvokeWaveDeployerPostCountDown(deploySystemOverflow.counter);
    }
  }

  public void SetCounter(int value)
  {
    this.counter = value;
    this.counterText.text = value.ToString();
    if (this.counter <= 1)
      this.glow.color = this.glowImminentColor;
    else
      this.glow.color = this.glowColor;
  }

  public static bool CheckEarlyDeploy() => Battle.GetCardsOnBoard(References.Battle.enemy).Count <= 0;

  public IEnumerator Activate()
  {
    WaveDeploySystemOverflow deploySystemOverflow1 = this;
    int targetRow = UnityEngine.Random.Range(0, Battle.instance.rowCount);
    deploySystemOverflow1.FadeOut();
    yield return (object) Sequences.Wait(0.2f);
    if ((bool) (UnityEngine.Object) deploySystemOverflow1)
    {
      yield return (object) deploySystemOverflow1.TryDeploy(targetRow);
      if ((bool) (UnityEngine.Object) deploySystemOverflow1)
      {
        if (deploySystemOverflow1.deployedThisTurn.Count > 0)
        {
          yield return (object) WaveDeploySystemOverflow.RevealBoard();
          if (!(bool) (UnityEngine.Object) deploySystemOverflow1)
            yield break;
        }
        WaveDeploySystemOverflow deploySystemOverflow2 = deploySystemOverflow1;
        int num1 = deploySystemOverflow1.currentWave + 1;
        int num2 = num1;
        deploySystemOverflow2.currentWave = num2;
        if (num1 < deploySystemOverflow1.waves.Count)
        {
          deploySystemOverflow1.SetCounter(deploySystemOverflow1.waves[deploySystemOverflow1.currentWave].counter);
          deploySystemOverflow1.FadeIn();
        }
        else
          deploySystemOverflow1.Hide();
      }
    }
  }

  public IEnumerator TryDeploy(int rowIndex)
  {
    WaveDeploySystemOverflow deploySystemOverflow = this;
    deploySystemOverflow.deployedThisTurn.Clear();
    List<Entity> failedToDeploy = new List<Entity>();
    foreach (CardData cardData1 in deploySystemOverflow.waves[deploySystemOverflow.currentWave].units.Where<CardData>(new Func<CardData, bool>(deploySystemOverflow.\u003CTryDeploy\u003Eb__52_0)))
    {
      CardData cardData = cardData1;
      Entity entity = References.Battle.cards.FirstOrDefault<Entity>((Func<Entity, bool>) (e => (long) e.data.id == (long) cardData.id));
      if ((bool) (UnityEngine.Object) entity && entity.containers.Contains<CardContainer>(entity.owner.reserveContainer))
      {
        bool thisDeployed = false;
        for (int index = 0; index < References.Battle.rowCount; ++index)
        {
          rowIndex = (rowIndex + 1) % References.Battle.rowCount;
          int targetColumn;
          if (References.Battle.CanDeploy(entity, rowIndex, out targetColumn))
          {
            thisDeployed = true;
            deploySystemOverflow.Deploy(entity, rowIndex, targetColumn);
            deploySystemOverflow.deployedThisTurn.Add(entity);
            deploySystemOverflow.deployed.Add(cardData.id);
            yield return (object) ActionQueue.Wait(false);
            if (!(bool) (UnityEngine.Object) deploySystemOverflow)
              yield break;
            else
              break;
          }
        }
        if (!thisDeployed)
          failedToDeploy.Add(entity);
      }
      entity = (Entity) null;
    }
    if (failedToDeploy.Count > 0)
      deploySystemOverflow.Overflow((IEnumerable<Entity>) failedToDeploy);
  }

  public void Deploy(Entity entity, int targetRow, int targetColumn)
  {
    List<CardContainer> rows = Battle.instance.GetRows(entity.owner);
    List<CardContainer> cardContainerList = new List<CardContainer>();
    for (int index = 0; index < entity.height; ++index)
    {
      CardContainer cardContainer = rows[(targetRow + index) % rows.Count];
      cardContainerList.Add(cardContainer);
    }
    entity.flipper.FlipUpInstant();
    ActionMove action = new ActionMove(entity, cardContainerList.ToArray());
    action.insertPos = targetColumn;
    action.pauseAfter = this.pauseAfterDeploy;
    ActionQueue.Add((PlayAction) action);
  }

  public static IEnumerator RevealBoard()
  {
    ActionQueue.Add((PlayAction) new ActionRevealAll(References.Battle.GetRows(References.Battle.enemy).ToArray()));
    yield return (object) ActionQueue.Wait(false);
  }

  public void Overflow(IEnumerable<Entity> entities)
  {
    Debug.Log((object) ("WaveSpawner → Overflowing [" + string.Join<Entity>(", ", entities) + "]"));
    if (this.overflowWaveIndex <= this.currentWave)
      this.CreateOverflowWave();
    foreach (Entity entity in entities)
    {
      if (!this.TryToAddToOverflow(entity))
      {
        this.CreateOverflowWave();
        this.TryToAddToOverflow(entity);
      }
    }
  }

  public void CreateOverflowWave()
  {
    List<BattleWaveManager.Wave> waves = this.waves;
    BattleWaveManager.Wave wave = waves[waves.Count - 1];
    this.waves.Add(new BattleWaveManager.Wave()
    {
      units = new List<CardData>(),
      counter = wave.counter
    });
    this.overflowWaveIndex = this.waves.Count - 1;
    Debug.Log((object) string.Format("WaveSpawner → New Overflow Wave Created [index: {0}]", (object) this.overflowWaveIndex));
  }

  public bool TryToAddToOverflow(Entity entity)
  {
    BattleWaveManager.Wave wave = this.waves[this.overflowWaveIndex];
    if (wave.units.Count >= 6)
      return false;
    wave.units.Add(entity.data);
    Debug.Log((object) string.Format("WaveSpawner → [{0}] Added to Overflow Wave [index: {1}]", (object) entity.name, (object) this.overflowWaveIndex));
    return true;
  }

  public void TryEarlyDeploy()
  {
    int num = WaveDeploySystemOverflow.CountEmptySpacesOnBoard();
    BattleWaveManager.Wave wave = this.waves[this.currentWave];
    if (!this.canCallEarly)
      return;
    if (wave.units.Count <= num)
    {
      ActionEarlyDeploy actionEarlyDeploy = new ActionEarlyDeploy(this.transform, this.EarlyDeploy());
      actionEarlyDeploy.parallel = true;
      ActionEarlyDeploy action = actionEarlyDeploy;
      if (!global::Events.CheckAction((PlayAction) action))
        return;
      ActionQueue.Add((PlayAction) action);
    }
    else
    {
      SfxSystem.OneShot("event:/sfx/inventory/wave_counter_deny");
      if (!(this.transform is RectTransform transform))
        return;
      transform.anchoredPosition = new Vector2(0.25f.WithRandomSign() - 1f, 2.5f);
      LeanTween.cancel(transform);
      LeanTween.move(transform, new Vector3(-1f, 2.5f, 0.0f), 1f).setEaseOutElastic();
    }
  }

  public IEnumerator EarlyDeploy()
  {
    InputSystem.Disable();
    References.Battle.playerCardController.Disable();
    this.DropGold();
    this.counter = 1;
    yield return (object) this.CountDown();
    References.Battle.playerCardController.Enable();
    InputSystem.Enable();
  }

  public void DropGold()
  {
    int amount = this.deployEarlyReward + this.deployEarlyRewardPerTurn * this.counter;
    if (amount <= 0)
      return;
    global::Events.InvokeDropGold(amount, "Wave Bell", References.Player, this.transform.position);
  }

  public static int CountEmptySpacesOnBoard() => References.Battle.GetRows(References.Battle.enemy).Sum<CardContainer>((Func<CardContainer, int>) (a => !a.canBePlacedOn ? 0 : a.max - a.Count));

  public void Pop()
  {
    if (this.popped || !(bool) (UnityEngine.Object) this.popup || this.currentWave >= this.waves.Count)
      return;
    BattleWaveManager.Wave wave = this.waves[this.currentWave];
    int num1 = this.deployEarlyReward + this.deployEarlyRewardPerTurn * this.counter;
    string forceBody = this.popupDesc.GetLocalizedString().Format((object) wave.units.Count, (object) this.counter);
    int num2 = wave.units.Count - WaveDeploySystemOverflow.CountEmptySpacesOnBoard();
    if (num2 <= 0)
    {
      if (this.canCallEarly)
      {
        forceBody = forceBody + "\n\n" + this.popupHitDesc.GetLocalizedString();
        if (num1 > 0)
          forceBody = forceBody + "\n\n" + this.popupRewardDesc.GetLocalizedString((object) num1);
      }
    }
    else
      forceBody = forceBody + "\n\n" + this.popupOverflowDesc.GetLocalizedString((object) num2);
    CardPopUp.AssignTo((RectTransform) this.transform, -1f, -0.25f);
    CardPopUp.AddPanel(this.popup, forceBody);
    this.popped = true;
  }

  public void UnPop()
  {
    if (!this.popped)
      return;
    CardPopUp.RemovePanel(this.popup.name);
    this.popped = false;
  }

  public BattleWaveData Save() => new BattleWaveData()
  {
    deployed = this.deployed,
    counter = this.counter,
    currentWave = this.currentWave,
    overflowWaveIndex = this.overflowWaveIndex,
    waves = this.waves.Select<BattleWaveManager.Wave, BattleWaveData.Wave>((Func<BattleWaveManager.Wave, BattleWaveData.Wave>) (a => new BattleWaveData.Wave(a))).ToArray<BattleWaveData.Wave>()
  };

  public void Load(BattleWaveData data, IReadOnlyCollection<CardData> cards)
  {
    this.deployed = data.deployed;
    foreach (Entity entity in References.Battle.enemy.reserveContainer)
    {
      int index = this.deployed.IndexOf(entity.data.id);
      if (index >= 0)
        this.deployed.RemoveAt(index);
    }
    this.SetCounter(data.counter);
    this.currentWave = data.currentWave;
    this.overflowWaveIndex = data.overflowWaveIndex;
    this.waves = new List<BattleWaveManager.Wave>();
    foreach (BattleWaveData.Wave wave in data.waves)
      this.waves.Add(new BattleWaveManager.Wave()
      {
        counter = wave.counter,
        isBossWave = wave.isBossWave,
        spawned = wave.spawned,
        units = ((IEnumerable<ulong>) wave.unitIds).Select<ulong, CardData>((Func<ulong, CardData>) (a => cards.FirstOrDefault<CardData>((Func<CardData, bool>) (b => (long) b.id == (long) a)))).ToList<CardData>()
      });
    if (this.currentWave < this.waves.Count)
      this.Show();
    this.deployedThisTurn = new List<Entity>();
  }

  [CompilerGenerated]
  public bool \u003CTryDeploy\u003Eb__52_0(CardData cardData) => (bool) (UnityEngine.Object) cardData && !this.deployed.Contains(cardData.id);
}
﻿// Decompiled with JetBrains decompiler
// Type: WaveDot
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.UI;

public class WaveDot : MonoBehaviour
{
  [SerializeField]
  public Image onImage;
  [SerializeField]
  public Image offImage;

  public void TurnOn()
  {
    this.onImage.enabled = true;
    this.offImage.enabled = false;
  }

  public void TurnOff()
  {
    this.onImage.enabled = false;
    this.offImage.enabled = true;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: WhenDisabled
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class WhenDisabled : MonoBehaviour
{
  [SerializeField]
  public UnityEvent action;

  public void OnDisable() => this.action?.Invoke();
}
﻿// Decompiled with JetBrains decompiler
// Type: WhenEnabled
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Events;

public class WhenEnabled : MonoBehaviour
{
  [SerializeField]
  public UnityEvent action;

  public void OnEnable() => this.action?.Invoke();
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.BattleDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class BattleDataBuilder : DataFileBuilder<BattleData, BattleDataBuilder>
  {
    public BattleDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public BattleDataBuilder()
    {
    }

    public BattleDataBuilder WithTitle(string title)
    {
      this._data.title = title;
      return this;
    }

    public BattleDataBuilder WithPointFactor(float factor = 1f)
    {
      this._data.pointFactor = factor;
      return this;
    }

    public BattleDataBuilder WithWaveCounter(int waveCounter = 4)
    {
      this._data.waveCounter = waveCounter;
      return this;
    }

    public BattleDataBuilder WithPools(params BattleWavePoolData[] pools)
    {
      this._data.pools = pools;
      return this;
    }

    public BattleDataBuilder WithBonusUnitPool(params CardData[] pools)
    {
      this._data.bonusUnitPool = pools;
      return this;
    }

    public BattleDataBuilder WithBonusUnitRange(Vector2Int v)
    {
      this._data.bonusUnitRange = v;
      return this;
    }

    public BattleDataBuilder WithGoldGiverPool(params CardData[] pools)
    {
      this._data.goldGiverPool = pools;
      return this;
    }

    public BattleDataBuilder WithGoldGivers(int amount = 1)
    {
      this._data.goldGivers = amount;
      return this;
    }

    public BattleDataBuilder WithGenerationScript(BattleGenerationScript s)
    {
      this._data.generationScript = s;
      return this;
    }

    public BattleDataBuilder WithSetUpScript(Script s)
    {
      this._data.setUpScript = s;
      return this;
    }

    public BattleDataBuilder WithSprite(Sprite sprite)
    {
      this._data.sprite = sprite;
      return this;
    }

    public BattleDataBuilder WithSprite(string sprite)
    {
      this._data.sprite = this.Mod.GetImageSprite(sprite);
      return this;
    }

    public BattleDataBuilder WithName(string name, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_ref", name);
      this._data.nameRef = collection.GetString(this._data.name + "_ref");
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.BossRewardDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class BossRewardDataBuilder : DataFileBuilder<BossRewardData, BossRewardDataBuilder>
  {
    public BossRewardDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public BossRewardDataBuilder()
    {
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.BuildingPlotTypeBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class BuildingPlotTypeBuilder : DataFileBuilder<BuildingPlotType, BuildingPlotTypeBuilder>
  {
    public BuildingPlotTypeBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public BuildingPlotTypeBuilder()
    {
    }

    public BuildingPlotTypeBuilder WithIllegalBuildings(params BuildingType[] illegalBuildings)
    {
      this._data.illegalBuildings = illegalBuildings;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.BuildingTypeBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class BuildingTypeBuilder : DataFileBuilder<BuildingType, BuildingTypeBuilder>
  {
    public BuildingTypeBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public BuildingTypeBuilder()
    {
    }

    public BuildingTypeBuilder WithTitle(LocalizedString title)
    {
      this._data.titleKey = title;
      return this;
    }

    public BuildingTypeBuilder WithTitle(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_building_title", title);
      this._data.titleKey = collection.GetString(this._data.name + "_building_title");
      return this;
    }

    public BuildingTypeBuilder WithHelp(LocalizedString title)
    {
      this._data.helpKey = title;
      return this;
    }

    public BuildingTypeBuilder WithHelp(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_building_help", title);
      this._data.helpKey = collection.GetString(this._data.name + "_building_help");
      return this;
    }

    public BuildingTypeBuilder WithHelpEmoteType(Prompt.Emote.Type helpEmoteType = Prompt.Emote.Type.Explain)
    {
      this._data.helpEmoteType = helpEmoteType;
      return this;
    }

    public BuildingTypeBuilder WithStarted(UnlockData started)
    {
      this._data.started = started;
      return this;
    }

    public BuildingTypeBuilder WithFinished(UnlockData finished)
    {
      this._data.finished = finished;
      return this;
    }

    public BuildingTypeBuilder WithUnlocks(params UnlockData[] unlocks)
    {
      this._data.unlocks = unlocks;
      return this;
    }

    public BuildingTypeBuilder WithUnlockedCheckedKey(string unlockedCheckedKey)
    {
      this._data.unlockedCheckedKey = unlockedCheckedKey;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.CampaignNodeTypeBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class CampaignNodeTypeBuilder : DataFileBuilder<CampaignNodeType, CampaignNodeTypeBuilder>
  {
    public CampaignNodeTypeBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public CampaignNodeTypeBuilder()
    {
    }

    public CampaignNodeTypeBuilder WithLetter(string letter)
    {
      this._data.letter = letter;
      return this;
    }

    public CampaignNodeTypeBuilder WithZoneName(string zoneName)
    {
      this._data.zoneName = zoneName;
      return this;
    }

    public CampaignNodeTypeBuilder WithMustClear(bool mustClear)
    {
      this._data.mustClear = mustClear;
      return this;
    }

    public CampaignNodeTypeBuilder WithCanSkip(bool canSkip)
    {
      this._data.canSkip = canSkip;
      return this;
    }

    public CampaignNodeTypeBuilder WithCanEnter(bool canEnter)
    {
      this._data.canEnter = canEnter;
      return this;
    }

    public CampaignNodeTypeBuilder WithIsBattle(bool isBattle)
    {
      this._data.isBattle = isBattle;
      return this;
    }

    public CampaignNodeTypeBuilder WithIsBoss(bool isBoss)
    {
      this._data.isBoss = isBoss;
      return this;
    }

    public CampaignNodeTypeBuilder WithModifierReward(bool modifierReward)
    {
      this._data.modifierReward = modifierReward;
      return this;
    }

    public CampaignNodeTypeBuilder WithInteractable(bool interactable)
    {
      this._data.interactable = interactable;
      return this;
    }

    public CampaignNodeTypeBuilder WithStartRevealed(bool startRevealed)
    {
      this._data.startRevealed = startRevealed;
      return this;
    }

    public CampaignNodeTypeBuilder WithFinalNode(bool finalNode)
    {
      this._data.finalNode = finalNode;
      return this;
    }

    public CampaignNodeTypeBuilder WithMapNodePrefab(MapNode mapNodePrefab)
    {
      this._data.mapNodePrefab = mapNodePrefab;
      return this;
    }

    public CampaignNodeTypeBuilder WithMapNodeSprite(Sprite mapNodeSprite)
    {
      this._data.mapNodeSprite = mapNodeSprite;
      return this;
    }

    public CampaignNodeTypeBuilder WithMapNodeSprite(string mapNodeSprite)
    {
      this._data.mapNodeSprite = this.Mod.GetImageSprite(mapNodeSprite);
      return this;
    }

    public CampaignNodeTypeBuilder WithSize(float size = 1f)
    {
      this._data.size = size;
      return this;
    }

    public CampaignNodeTypeBuilder WithCanLink(bool canLink)
    {
      this._data.canLink = canLink;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.CardDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using MonoMod.Cil;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class CardDataBuilder : DataFileBuilder<CardData, CardDataBuilder>
  {
    public ChallengeData UnlockChallenge;
    public static List<string> AutoUnlockedPets = new List<string>();

    public CardDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public CardDataBuilder()
    {
    }

    public CardDataBuilder SetStats(int? health = null, int? damage = null, int counter = 0) => this.SetHealth(health).SetDamage(damage).SetCounter(counter);

    public CardDataBuilder SetCounter(int counter)
    {
      this._data.counter = counter;
      return this;
    }

    public CardDataBuilder SetDamage(int? damage)
    {
      if (damage.HasValue)
        this._data.damage = damage.Value;
      this._data.hasAttack = damage.HasValue;
      return this;
    }

    public CardDataBuilder NeedsTarget(bool value = true)
    {
      this._data.needsTarget = value;
      return this;
    }

    public CardDataBuilder SetHealth(int? health)
    {
      if (health.HasValue)
        this._data.hp = health.Value;
      this._data.hasHealth = health.HasValue;
      return this;
    }

    public CardDataBuilder SetSprites(Sprite mainSprite, Sprite backgroundSprite)
    {
      this._data.mainSprite = mainSprite;
      this._data.backgroundSprite = backgroundSprite;
      return this;
    }

    public CardDataBuilder SetSprites(string mainSprite, string backgroundSprite) => this.SetSprites(this.Mod.ImagePath(mainSprite).ToSprite(), this.Mod.ImagePath(backgroundSprite).ToSprite());

    public CardDataBuilder SetStartWithEffect(params CardData.StatusEffectStacks[] stacks)
    {
      this._data.startWithEffects = stacks;
      return this;
    }

    public CardDataBuilder SetTraits(params CardData.TraitStacks[] stacks)
    {
      this._data.traits = stacks.ToList<CardData.TraitStacks>();
      return this;
    }

    public CardDataBuilder WithDescription(string desc)
    {
      this._data.desc = desc;
      return this;
    }

    public CardDataBuilder WithValue(int price)
    {
      this._data.value = price;
      return this;
    }

    public CardDataBuilder WithTargetMode(TargetMode mode)
    {
      this._data.targetMode = mode;
      return this;
    }

    public CardDataBuilder WithTargetMode(string mode = "TargetModeBasic")
    {
      this._data.targetMode = Extensions.GetTargetMode(mode);
      return this;
    }

    public CardDataBuilder WithPlayType(Card.PlayType type)
    {
      this._data.playType = type;
      return this;
    }

    public CardDataBuilder SetAttackEffect(params CardData.StatusEffectStacks[] stacks)
    {
      this._data.attackEffects = stacks;
      return this;
    }

    public CardDataBuilder WithIdleAnimationProfile(CardAnimationProfile bp)
    {
      this._data.idleAnimationProfile = bp;
      return this;
    }

    public CardDataBuilder WithIdleAnimationProfile(string bp = "SwayAnimationProfile") => this.WithIdleAnimationProfile(Extensions.GetCardAnimationProfile(bp));

    public CardDataBuilder WithBloodProfile(BloodProfile bp)
    {
      this._data.bloodProfile = bp;
      return this;
    }

    public CardDataBuilder WithBloodProfile(string bp = "Blood Profile Normal") => this.WithBloodProfile(this.Mod.GetAsset<BloodProfile>(bp));

    public CardDataBuilder CanPlayOnBoard(bool value = true)
    {
      this._data.canPlayOnBoard = value;
      return this;
    }

    public CardDataBuilder CanPlayOnEnemy(bool value = true)
    {
      this._data.canPlayOnEnemy = value;
      return this;
    }

    public CardDataBuilder CanPlayOnFriendly(bool value = true)
    {
      this._data.canPlayOnFriendly = value;
      return this;
    }

    public CardDataBuilder CanPlayOnHand(bool value = true)
    {
      this._data.canPlayOnHand = value;
      return this;
    }

    public CardDataBuilder CanBeHit(bool value = true)
    {
      this._data.canBeHit = value;
      return this;
    }

    public CardDataBuilder CanShoveToOtherRow(bool value = true)
    {
      this._data.canShoveToOtherRow = value;
      return this;
    }

    public CardDataBuilder AsUnit(string targetMode = "TargetModeBasic", string idleAnim = "SwayAnimationProfile", string bloodProfile = "Blood Profile Normal")
    {
      this._data.canPlayOnEnemy = true;
      this._data.canBeHit = true;
      this._data.playType = Card.PlayType.Place;
      this._data.canPlayOnBoard = true;
      this._data.cardType = this.Mod.Get<CardType>("Friendly");
      return this.SetStats(new int?(0), new int?(0)).WithTargetMode(targetMode).WithBloodProfile(bloodProfile).WithIdleAnimationProfile(idleAnim);
    }

    public CardDataBuilder AsItem(string targetMode = "TargetModeBasic", string idleAnim = "SwayAnimationProfile")
    {
      this._data.canPlayOnEnemy = true;
      this._data.canBeHit = false;
      this._data.playType = Card.PlayType.Play;
      this._data.canPlayOnBoard = true;
      this._data.cardType = this.Mod.Get<CardType>("Item");
      return this.FreeModify((System.Action<CardData>) (a => a.uses = 1)).WithTargetMode(targetMode).WithIdleAnimationProfile(idleAnim).CanPlayOnHand(false);
    }

    public CardDataBuilder IsCompanion(ChallengeData challenge, bool value = true)
    {
      this.UnlockChallenge = challenge;
      if (value)
      {
        this._data.AddToCompanions();
        BuildingSequenceWithUnlocks<BuildingCardUnlockSequence>.OnStart += new RuntimeILReferenceBag.FastDelegateInvokers.Action<BuildingCardUnlockSequence>(this.UnlockSequenceOnOnStart<BuildingCardUnlockSequence>);
      }
      else
      {
        this._data.RemoveFromCompanions();
        BuildingSequenceWithUnlocks<BuildingCardUnlockSequence>.OnStart -= new RuntimeILReferenceBag.FastDelegateInvokers.Action<BuildingCardUnlockSequence>(this.UnlockSequenceOnOnStart<BuildingCardUnlockSequence>);
      }
      return this;
    }

    public CardDataBuilder IsItem(ChallengeData challenge, bool value = true)
    {
      this.UnlockChallenge = challenge;
      if (value)
      {
        this._data.AddToItems();
        BuildingSequenceWithUnlocks<InventorHutSequence>.OnStart += new RuntimeILReferenceBag.FastDelegateInvokers.Action<InventorHutSequence>(this.UnlockSequenceOnOnStart<InventorHutSequence>);
      }
      else
      {
        this._data.RemoveFromItems();
        BuildingSequenceWithUnlocks<InventorHutSequence>.OnStart -= new RuntimeILReferenceBag.FastDelegateInvokers.Action<InventorHutSequence>(this.UnlockSequenceOnOnStart<InventorHutSequence>);
      }
      return this;
    }

    public CardDataBuilder IsPet(string challenge, bool value = true) => this.IsPet(this.Mod.Get<ChallengeData>(challenge), value);

    public CardDataBuilder IsPet(ChallengeData challenge, bool value = true)
    {
      if (value && ((UnityEngine.Object) challenge == (UnityEngine.Object) null || !(bool) (UnityEngine.Object) challenge))
      {
        Debug.Log((object) (this._data.name + "'s pet unlock data is null, instantly unlocking"));
        CardDataBuilder.AutoUnlockedPets.Add(this._data.name);
        BuildingSequenceWithUnlocks<PetHutSequence>.OnStart += (RuntimeILReferenceBag.FastDelegateInvokers.Action<PetHutSequence>) (sequence => sequence.AddSlot((ChallengeData) null));
        return this;
      }
      this.UnlockChallenge = challenge;
      if (value)
      {
        this._data.AddToPets();
        BuildingSequenceWithUnlocks<PetHutSequence>.OnStart += new RuntimeILReferenceBag.FastDelegateInvokers.Action<PetHutSequence>(this.UnlockSequenceOnOnStart<PetHutSequence>);
      }
      else
      {
        this._data.RemoveFromPets();
        BuildingSequenceWithUnlocks<PetHutSequence>.OnStart -= new RuntimeILReferenceBag.FastDelegateInvokers.Action<PetHutSequence>(this.UnlockSequenceOnOnStart<PetHutSequence>);
      }
      return this;
    }

    public void UnlockSequenceOnOnStart<T>(BuildingSequenceWithUnlocks<T> obj) where T : BuildingSequenceWithUnlocks<T> => obj.AddSlot(this.UnlockChallenge);

    public CardDataBuilder CreateItem(
      string name,
      string englishTitle,
      string targetMode = "TargetModeBasic",
      string idleAnim = "SwayAnimationProfile")
    {
      return this.Create(name).WithTitle(englishTitle).AsItem(targetMode, idleAnim);
    }

    [Obsolete("Reverse", true)]
    public CardDataBuilder CreateItem(
      string name,
      string englishTitle,
      string targetMode,
      string wtv,
      string idleAnim)
    {
      return this.Create(name).WithTitle(englishTitle).AsItem(targetMode, idleAnim);
    }

    public CardDataBuilder CreateUnit(
      string name,
      string englishTitle,
      string targetMode = "TargetModeBasic",
      string bloodProfile = "Blood Profile Normal",
      string idleAnim = "SwayAnimationProfile")
    {
      return this.Create(name).WithTitle(englishTitle).AsUnit(targetMode, idleAnim, bloodProfile);
    }

    public CardDataBuilder WithPools(params RewardPool[] pools)
    {
      this.AfterBuildEvent += (DataFileBuilder<CardData, CardDataBuilder>.AfterBuildDelegate) (data => data.WithPools(pools));
      return this;
    }

    public CardDataBuilder WithPools(params string[] pools)
    {
      this.AfterBuildEvent += (DataFileBuilder<CardData, CardDataBuilder>.AfterBuildDelegate) (data => data.WithPools(((IEnumerable<string>) pools).Select<string, RewardPool>(new System.Func<string, RewardPool>(Extensions.GetRewardPool)).ToArray<RewardPool>()));
      return this;
    }

    public CardDataBuilder AddPool(RewardPool pool)
    {
      this.AfterBuildEvent += (DataFileBuilder<CardData, CardDataBuilder>.AfterBuildDelegate) (data => data.AddPool(pool));
      return this;
    }

    public CardDataBuilder AddPool(string pool = "GeneralUnitPool")
    {
      this.AfterBuildEvent += (DataFileBuilder<CardData, CardDataBuilder>.AfterBuildDelegate) (data => data.AddPool(Extensions.GetRewardPool(pool)));
      return this;
    }

    public CardDataBuilder WithCardType(CardType type)
    {
      this._data.cardType = type;
      return this;
    }

    public CardDataBuilder WithCardType(string type = "Friendly")
    {
      this._data.cardType = this.Mod.Get<CardType>(type);
      return this;
    }

    public CardDataBuilder WithTitle(LocalizedString title)
    {
      this._data.titleKey = title;
      return this;
    }

    public CardDataBuilder WithFlavour(LocalizedString flavour)
    {
      this._data.flavourKey = flavour;
      return this;
    }

    public CardDataBuilder WithText(LocalizedString text)
    {
      this._data.textKey = text;
      return this;
    }

    public CardDataBuilder WithTitle(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_title", title);
      this._data.titleKey = collection.GetString(this._data.name + "_title");
      return this;
    }

    public CardDataBuilder WithFlavour(string flavour, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_flavour", flavour);
      this._data.flavourKey = collection.GetString(this._data.name + "_flavour");
      return this;
    }

    public CardDataBuilder WithText(string text, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_text", text);
      this._data.textKey = collection.GetString(this._data.name + "_text");
      return this;
    }

    void object.Finalize()
    {
      try
      {
        UnityEngine.Object.Destroy((UnityEngine.Object) this._data);
      }
      finally
      {
        // ISSUE: explicit finalizer call
        base.Finalize();
      }
    }

    public CardDataBuilder Clone()
    {
      CardDataBuilder cardDataBuilder = new CardDataBuilder(this.Mod);
      cardDataBuilder._data = this._data.InstantiateKeepName<CardData>();
      return cardDataBuilder;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.CardTypeBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Localization;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class CardTypeBuilder : DataFileBuilder<CardType, CardTypeBuilder>
  {
    public CardTypeBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public CardTypeBuilder()
    {
    }

    public CardTypeBuilder WithSortPriority(int sortPriority)
    {
      this._data.sortPriority = sortPriority;
      return this;
    }

    public CardTypeBuilder WithIcon(Sprite icon)
    {
      this._data.icon = icon;
      return this;
    }

    public CardTypeBuilder WithIcon(string icon)
    {
      this._data.icon = this.Mod.GetImageSprite(icon);
      return this;
    }

    public CardTypeBuilder WithPrefabRef(AssetReference prefabRef)
    {
      this._data.prefabRef = prefabRef;
      return this;
    }

    public CardTypeBuilder WithTextBoxSprite(Sprite icon)
    {
      this._data.textBoxSprite = icon;
      return this;
    }

    public CardTypeBuilder WithTextBoxSprite(string icon)
    {
      this._data.textBoxSprite = this.Mod.GetImageSprite(icon);
      return this;
    }

    public CardTypeBuilder WithNameTagSprite(Sprite icon)
    {
      this._data.nameTagSprite = icon;
      return this;
    }

    public CardTypeBuilder WithNameTagSprite(string icon)
    {
      this._data.nameTagSprite = this.Mod.GetImageSprite(icon);
      return this;
    }

    public CardTypeBuilder WithTitle(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_type_title", title);
      this._data.titleKey = collection.GetString(this._data.name + "_type_title");
      return this;
    }

    public CardTypeBuilder WithTitle(LocalizedString str)
    {
      this._data.titleKey = str;
      return this;
    }

    public CardTypeBuilder WithCanDie(bool canDie)
    {
      this._data.canDie = canDie;
      return this;
    }

    public CardTypeBuilder WithCanTakeCrown(bool canTakeCrown)
    {
      this._data.canTakeCrown = canTakeCrown;
      return this;
    }

    public CardTypeBuilder WithCanRecall(bool canRecall)
    {
      this._data.canRecall = canRecall;
      return this;
    }

    public CardTypeBuilder WithCanReserve(bool canReserve)
    {
      this._data.canReserve = canReserve;
      return this;
    }

    public CardTypeBuilder WithItem(bool item)
    {
      this._data.item = item;
      return this;
    }

    public CardTypeBuilder WithUnit(bool unit)
    {
      this._data.unit = unit;
      return this;
    }

    public CardTypeBuilder WithTag(string tag)
    {
      this._data.tag = tag;
      return this;
    }

    public CardTypeBuilder WithMiniboss(bool miniboss)
    {
      this._data.miniboss = miniboss;
      return this;
    }

    public CardTypeBuilder WithDiscoverInJournal(bool discoverInJournal)
    {
      this._data.discoverInJournal = discoverInJournal;
      return this;
    }

    public CardTypeBuilder WithDescriptionColours(Text.ColourProfileHex descriptionColours)
    {
      this._data.descriptionColours = descriptionColours;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.CardUpgradeDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using MonoMod.Cil;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class CardUpgradeDataBuilder : DataFileBuilder<CardUpgradeData, CardUpgradeDataBuilder>
  {
    public ChallengeData UnlockChallenge;

    public CardUpgradeDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public CardUpgradeDataBuilder()
    {
    }

    public CardUpgradeDataBuilder CreateCharm(string name) => this.Create(name).WithType(CardUpgradeData.Type.Charm).AddPool();

    public CardUpgradeDataBuilder WithPools(params RewardPool[] pools)
    {
      this.AfterBuildEvent += (DataFileBuilder<CardUpgradeData, CardUpgradeDataBuilder>.AfterBuildDelegate) (data => data.WithPools(pools));
      return this;
    }

    public CardUpgradeDataBuilder WithPools(params string[] pools)
    {
      this.AfterBuildEvent += (DataFileBuilder<CardUpgradeData, CardUpgradeDataBuilder>.AfterBuildDelegate) (data => data.WithPools(((IEnumerable<string>) pools).Select<string, RewardPool>(new System.Func<string, RewardPool>(Extensions.GetRewardPool)).ToArray<RewardPool>()));
      return this;
    }

    public CardUpgradeDataBuilder AddPool(RewardPool pool)
    {
      this.AfterBuildEvent += (DataFileBuilder<CardUpgradeData, CardUpgradeDataBuilder>.AfterBuildDelegate) (data => data.AddPool(pool));
      return this;
    }

    public CardUpgradeDataBuilder AddPool(string pool = "GeneralCharmPool")
    {
      this.AfterBuildEvent += (DataFileBuilder<CardUpgradeData, CardUpgradeDataBuilder>.AfterBuildDelegate) (data => data.AddPool(Extensions.GetRewardPool(pool)));
      return this;
    }

    public CardUpgradeDataBuilder WithTier(int tier)
    {
      this._data.tier = tier;
      return this;
    }

    public CardUpgradeDataBuilder WithImage(Sprite img)
    {
      this._data.image = img;
      return this;
    }

    public CardUpgradeDataBuilder WithType(CardUpgradeData.Type type)
    {
      this._data.type = type;
      return this;
    }

    public CardUpgradeDataBuilder SetAttackEffects(params CardData.StatusEffectStacks[] efs)
    {
      this._data.attackEffects = efs;
      return this;
    }

    public CardUpgradeDataBuilder SetEffects(params CardData.StatusEffectStacks[] efs)
    {
      this._data.effects = efs;
      return this;
    }

    public CardUpgradeDataBuilder SetTraits(params CardData.TraitStacks[] efs)
    {
      this._data.giveTraits = efs;
      return this;
    }

    public CardUpgradeDataBuilder SetScripts(params CardScript[] efs)
    {
      this._data.scripts = efs;
      return this;
    }

    public CardUpgradeDataBuilder SetConstraints(params TargetConstraint[] efs)
    {
      this._data.targetConstraints = efs;
      return this;
    }

    public CardUpgradeDataBuilder SetBecomesTarget(bool val)
    {
      this._data.becomesTargetedCard = val;
      return this;
    }

    public CardUpgradeDataBuilder SetCanBeRemoved(bool val)
    {
      this._data.canBeRemoved = val;
      return this;
    }

    public CardUpgradeDataBuilder ChangeDamage(int val)
    {
      this._data.damage = val;
      return this;
    }

    public CardUpgradeDataBuilder ChangeHP(int val)
    {
      this._data.hp = val;
      return this;
    }

    public CardUpgradeDataBuilder ChangeCounter(int val)
    {
      this._data.counter = val;
      return this;
    }

    public CardUpgradeDataBuilder ChangeUses(int val)
    {
      this._data.uses = val;
      return this;
    }

    public CardUpgradeDataBuilder ChangeEffectBonus(int val)
    {
      this._data.effectBonus = val;
      return this;
    }

    public CardUpgradeDataBuilder WithSetDamage(bool val)
    {
      this._data.setDamage = val;
      return this;
    }

    public CardUpgradeDataBuilder WithSetHP(bool val)
    {
      this._data.setHp = val;
      return this;
    }

    public CardUpgradeDataBuilder WithSetCounter(bool val)
    {
      this._data.setCounter = val;
      return this;
    }

    public CardUpgradeDataBuilder WithSetUses(bool val)
    {
      this._data.setUses = val;
      return this;
    }

    public CardUpgradeDataBuilder IsCharm(ChallengeData challenge, bool value = true)
    {
      this.UnlockChallenge = challenge;
      if (value)
      {
        this._data.AddToCharms(challenge.reward);
        BuildingSequenceWithUnlocks<ChallengeShrineSequence>.OnStart += new RuntimeILReferenceBag.FastDelegateInvokers.Action<ChallengeShrineSequence>(this.UnlockSequenceOnOnStart<ChallengeShrineSequence>);
      }
      else
      {
        this._data.RemoveFromCharms(challenge.reward);
        BuildingSequenceWithUnlocks<ChallengeShrineSequence>.OnStart -= new RuntimeILReferenceBag.FastDelegateInvokers.Action<ChallengeShrineSequence>(this.UnlockSequenceOnOnStart<ChallengeShrineSequence>);
      }
      return this;
    }

    public void UnlockSequenceOnOnStart<T>(BuildingSequenceWithUnlocks<T> obj) where T : BuildingSequenceWithUnlocks<T> => obj.AddChallengeStone(this.UnlockChallenge);

    public CardUpgradeDataBuilder WithImage(string img)
    {
      this._data.image = this.Mod.ImagePath(img).ToSprite();
      return this;
    }

    public CardUpgradeDataBuilder WithTitle(LocalizedString title)
    {
      this._data.titleKey = title;
      return this;
    }

    public CardUpgradeDataBuilder WithText(LocalizedString text)
    {
      this._data.textKey = text;
      return this;
    }

    public CardUpgradeDataBuilder WithTitle(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Upgrades", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_title", title);
      this._data.titleKey = collection.GetString(this._data.name + "_title");
      return this;
    }

    public CardUpgradeDataBuilder WithText(string text, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Upgrades", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_text", text);
      this._data.textKey = collection.GetString(this._data.name + "_text");
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.ChallengeDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class ChallengeDataBuilder : DataFileBuilder<ChallengeData, ChallengeDataBuilder>
  {
    public ChallengeDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public ChallengeDataBuilder WithTitle(LocalizedString str)
    {
      this._data.titleKey = str;
      return this;
    }

    public ChallengeDataBuilder WithText(LocalizedString str)
    {
      this._data.textKey = str;
      return this;
    }

    public ChallengeDataBuilder WithRewardText(LocalizedString str)
    {
      this._data.rewardKey = str;
      return this;
    }

    public ChallengeDataBuilder WithTitle(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Challenges", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_title", title);
      this._data.titleKey = collection.GetString(this._data.name + "_title");
      return this;
    }

    public ChallengeDataBuilder WithText(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Challenges", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_text", title);
      this._data.textKey = collection.GetString(this._data.name + "_text");
      return this;
    }

    public ChallengeDataBuilder()
    {
    }

    public ChallengeDataBuilder WithRewardText(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Challenges", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_reward", title);
      this._data.rewardKey = collection.GetString(this._data.name + "_reward");
      return this;
    }

    public ChallengeDataBuilder WithGoal(int amountGoal)
    {
      this._data.goal = amountGoal;
      return this;
    }

    public ChallengeDataBuilder WithListener(ChallengeListener listener)
    {
      this._data.listener = listener;
      return this;
    }

    public ChallengeDataBuilder WithListener(string listener)
    {
      this._data.listener = this.Mod.Get<ChallengeListener>(listener);
      return this;
    }

    public ChallengeDataBuilder WithIcon(Sprite icon)
    {
      this._data.icon = icon;
      return this;
    }

    public ChallengeDataBuilder WithRequires(params ChallengeData[] requires)
    {
      this._data.requires = requires;
      return this;
    }

    public ChallengeDataBuilder WithRequires(params string[] requires)
    {
      this._data.requires = ((IEnumerable<string>) requires).Select<string, ChallengeData>(new Func<string, ChallengeData>(this.Mod.Get<ChallengeData>)).ToArray<ChallengeData>();
      return this;
    }

    public ChallengeDataBuilder WithReward(UnlockData reward)
    {
      this._data.reward = reward;
      return this;
    }

    public ChallengeDataBuilder WithReward(string reward)
    {
      this._data.reward = this.Mod.Get<UnlockData>(reward);
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.ChallengeListenerBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class ChallengeListenerBuilder : 
    DataFileBuilder<ChallengeListener, ChallengeListenerBuilder>
  {
    public ChallengeListenerBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public ChallengeListenerBuilder()
    {
    }

    public ChallengeListenerBuilder WithKey(string key)
    {
      this._data.key = key;
      this._data.hasKey = true;
      return this;
    }

    public ChallengeListenerBuilder WithCheckType(ChallengeListener.CheckType type)
    {
      this._data.checkType = type;
      return this;
    }

    public ChallengeListenerBuilder WithStat(string stat)
    {
      this._data.stat = stat;
      return this;
    }

    public ChallengeListenerBuilder WithStat(int toReach)
    {
      this._data.target = toReach;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.ClassDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using UnityEngine;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class ClassDataBuilder : DataFileBuilder<ClassData, ClassDataBuilder>
  {
    public ClassDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public ClassDataBuilder()
    {
    }

    public ClassDataBuilder WithRequiresUnlock(UnlockData requiresUnlock)
    {
      this._data.requiresUnlock = requiresUnlock;
      return this;
    }

    public ClassDataBuilder WithStartingInventory(Inventory startingInventory)
    {
      this._data.startingInventory = startingInventory;
      return this;
    }

    public ClassDataBuilder WithLeaders(params CardData[] leaders)
    {
      this._data.leaders = leaders;
      return this;
    }

    public ClassDataBuilder WithCharacterPrefab(Character characterPrefab)
    {
      this._data.characterPrefab = characterPrefab;
      return this;
    }

    public ClassDataBuilder WithRewardPools(params RewardPool[] rewardPools)
    {
      this._data.rewardPools = rewardPools;
      return this;
    }

    public ClassDataBuilder WithSelectSfxEvent(EventReference selectSfxEvent)
    {
      this._data.selectSfxEvent = selectSfxEvent;
      return this;
    }

    public ClassDataBuilder WithFlag(Sprite flag)
    {
      this._data.flag = flag;
      return this;
    }

    public ClassDataBuilder WithFlag(string flag)
    {
      this._data.flag = this.Mod.GetImageSprite(flag);
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.DataFileBuilder`2
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public abstract class DataFileBuilder<T, Y>
    where T : DataFile
    where Y : DataFileBuilder<T, Y>, new()
  {
    public T _data;
    public WildfrostMod Mod;

    public virtual T BuildInstance() => this._data.InstantiateKeepName<T>();

    public T Build()
    {
      T d = this.BuildInstance();
      this.OnAfterBuildEvent(d);
      return d;
    }

    public DataFileBuilder(WildfrostMod mod) => this.Mod = mod;

    public DataFileBuilder()
    {
    }

    public Y FreeModify(Action<T> action)
    {
      if (action != null)
        action(this._data);
      return (Y) this;
    }

    public Y FreeModify<D>(Action<D> action) where D : T
    {
      if (action != null)
        action((object) this._data as D);
      return (Y) this;
    }

    public event DataFileBuilder<T, Y>.AfterBuildDelegate AfterBuildEvent;

    public event DataFileBuilder<T, Y>.AfterBuildDelegate AfterAllModBuildsEvent;

    public virtual Y Create(string name)
    {
      if (this.Mod != null)
        name = Extensions.PrefixGUID(name, this.Mod);
      if ((object) this._data != null)
        UnityEngine.Object.Destroy((UnityEngine.Object) this._data);
      this._data = ScriptableObject.CreateInstance<T>();
      this._data.name = name;
      return this as Y;
    }

    public virtual Y Create<X>(string name) where X : T
    {
      if (this.Mod != null)
        name = Extensions.PrefixGUID(name, this.Mod);
      if ((object) this._data != null)
        UnityEngine.Object.Destroy((UnityEngine.Object) this._data);
      this._data = (T) ScriptableObject.CreateInstance<X>();
      this._data.name = name;
      return this as Y;
    }

    public static implicit operator T(DataFileBuilder<T, Y> t) => t.Build();

    public virtual Y SubscribeToBuildEvent(DataFileBuilder<T, Y>.AfterBuildDelegate d)
    {
      this.AfterBuildEvent += d;
      return (Y) this;
    }

    public virtual Y UnsubscribeToBuildEvent(DataFileBuilder<T, Y>.AfterBuildDelegate d)
    {
      this.AfterBuildEvent -= d;
      return (Y) this;
    }

    public virtual Y SubscribeToAfterAllBuildEvent(DataFileBuilder<T, Y>.AfterBuildDelegate d)
    {
      this.AfterAllModBuildsEvent += d;
      return (Y) this;
    }

    public virtual Y UnubscribeToAfterAllBuildEvent(DataFileBuilder<T, Y>.AfterBuildDelegate d)
    {
      this.AfterAllModBuildsEvent -= d;
      return (Y) this;
    }

    public virtual void OnAfterBuildEvent(T d)
    {
      DataFileBuilder<T, Y>.AfterBuildDelegate afterBuildEvent = this.AfterBuildEvent;
      if (afterBuildEvent == null)
        return;
      afterBuildEvent(d);
    }

    public virtual void OnAfterAllModBuildsEvent(T d)
    {
      DataFileBuilder<T, Y>.AfterBuildDelegate allModBuildsEvent = this.AfterAllModBuildsEvent;
      if (allModBuildsEvent == null)
        return;
      allModBuildsEvent(d);
    }

    public delegate void AfterBuildDelegate(T d)
      where T : DataFile
      where Y : DataFileBuilder<T, Y>, new();
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.Extensions
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Localization;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public static class Extensions
  {
    public static CardData[] GetCategoryCardData(string category, bool mustBeFinal = true) => AddressableLoader.GetGroup<CardData>("CardData").FindAll((Predicate<CardData>) (a =>
    {
      if ((!(a.cardType.name == category) || a.isEnemyClunker) && (!(a.cardType.name == "Clunker") || !a.isEnemyClunker || !(category == "Enemy")))
        return false;
      if (!mustBeFinal)
        return true;
      LocalizedString titleKey = a.titleKey;
      return titleKey != null && !titleKey.IsEmpty;
    })).ToArray();

    public static StatusEffectDataBuilder SetSummonPrefabRef(
      this StatusEffectDataBuilder inst,
      string name = "SummonCreateCard")
    {
      inst.FreeModify<StatusEffectSummon>((Action<StatusEffectSummon>) (summon => summon.effectPrefabRef = (AssetReference) new AssetReferenceGameObject(name)));
      return inst;
    }

    public static bool IsCharm(this CardUpgradeData inst) => MetaprogressionSystem.Get<List<string>>("charms").Contains(inst.name);

    public static void AddToCharms(this CardUpgradeData inst, UnlockData data) => MetaprogressionSystem.Add<string, string>("charms", data.name, inst.name);

    public static bool RemoveFromCharms(this CardUpgradeData inst, UnlockData data) => MetaprogressionSystem.Remove<string, string>("charms", data.name, inst.name);

    public static bool IsCompanion(this CardData inst) => MetaprogressionSystem.Get<List<string>>("companions").Contains(inst.name);

    public static void AddToCompanions(this CardData inst) => MetaprogressionSystem.Add<string>("companions", inst.name);

    public static bool RemoveFromCompanions(this CardData inst) => MetaprogressionSystem.Remove<string>("companions", inst.name);

    public static bool IsItem(this CardData inst) => MetaprogressionSystem.Get<List<string>>("items").Contains(inst.name);

    public static void AddToItems(this CardData inst) => MetaprogressionSystem.Add<string>("items", inst.name);

    public static bool RemoveFromItems(this CardData inst) => MetaprogressionSystem.Remove<string>("items", inst.name);

    public static bool IsPet(this CardData inst) => MetaprogressionSystem.Get<List<string>>("pets").Contains(inst.name);

    public static void AddToPets(this CardData inst) => MetaprogressionSystem.Add<string>("pets", inst.name);

    public static bool RemoveFromPets(this CardData inst) => MetaprogressionSystem.Remove<string>("pets", inst.name);

    public static T[] RemoveFromArray<T>(this T[] sequence, T item) => ((IEnumerable<T>) sequence).Where<T>((Func<T, bool>) (a => !a.Equals((object) (T) item))).ToArray<T>();

    public static T[] RemoveFromArray<T>(this T[] sequence, Func<T, bool> item) => ((IEnumerable<T>) sequence).Where<T>(item).ToArray<T>();

    public static string PrefixGUID(string name, WildfrostMod mod) => mod == null ? name : mod.GUID + "." + name;

    public static string GetGUID(string name)
    {
      string str = name;
      int num1 = 0;
      int num2 = name.LastIndexOf('.') - num1;
      int startIndex = num1;
      int length = num2;
      return str.Substring(startIndex, length);
    }

    public static WildfrostMod GetModFromGuid(string guid) => Bootstrap.Mods.ToList<WildfrostMod>().Find((Predicate<WildfrostMod>) (a => a.GUID == guid));

    public static CardAnimationProfile GetCardAnimationProfile(string name) => Addressables.LoadAssetAsync<CardAnimationProfile>((object) name).WaitForCompletion();

    public static TargetMode GetTargetMode(string name) => Addressables.LoadAssetAsync<TargetMode>((object) name).WaitForCompletion();

    public static void WithPools(this CardData data, params RewardPool[] pools)
    {
      foreach (RewardPool pool in pools)
        pool.list.Add((DataFile) data);
    }

    public static void AddPool(this CardData data, RewardPool pool) => pool.list.Add((DataFile) data);

    public static void WithPools(this CardUpgradeData data, params RewardPool[] pools)
    {
      foreach (RewardPool pool in pools)
        pool.list.Add((DataFile) data);
    }

    public static void AddPool(this CardUpgradeData data, RewardPool pool) => pool.list.Add((DataFile) data);

    public static LocalizedString GetLocalizedString(string table, string key) => LocalizationHelper.GetCollection(table, new LocaleIdentifier(SystemLanguage.English)).GetString(key);

    public static HashSet<RewardPool> GetAllRewardPools()
    {
      HashSet<RewardPool> list = new HashSet<RewardPool>();
      foreach (ClassData classData in AddressableLoader.GetGroup<ClassData>("ClassData"))
        list.AddRange<RewardPool>((IEnumerable<RewardPool>) classData.rewardPools);
      return list;
    }

    public static Y Edit<T, Y>(this T data)
      where T : DataFile
      where Y : DataFileBuilder<T, Y>, new()
    {
      Y y = new Y();
      y.Mod = data.ModAdded ?? (WildfrostMod) new InternalMod((string) null);
      y._data = data;
      return y;
    }

    public static RewardPool GetRewardPool(string name)
    {
      foreach (ClassData classData in AddressableLoader.GetGroup<ClassData>("ClassData"))
      {
        foreach (RewardPool rewardPool in classData.rewardPools)
        {
          if (rewardPool.name == name)
            return rewardPool;
        }
      }
      return (RewardPool) null;
    }

    public static Texture2D ToTex(this string path)
    {
      Texture2D tex = new Texture2D(0, 0, TextureFormat.RGBA32, false);
      if (!File.Exists(path))
        return tex;
      tex.LoadImage(File.ReadAllBytes(path));
      return tex;
    }

    public static Sprite ToSprite(this string path) => path.ToTex().ToSprite();

    public static Sprite ToSprite(this Texture2D t, Vector2? v = null)
    {
      Vector2 pivot = v ?? new Vector2(0.5f, 0.5f);
      return Sprite.Create(t, new Rect(0.0f, 0.0f, (float) t.width, (float) t.height), pivot);
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.EyeDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class EyeDataBuilder : DataFileBuilder<EyeData, EyeDataBuilder>
  {
    public EyeDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public EyeDataBuilder()
    {
    }

    public EyeDataBuilder WithCardData(string cardData)
    {
      this._data.cardData = cardData;
      return this;
    }

    public EyeDataBuilder WithCardData(CardData cardData)
    {
      this._data.cardData = cardData.name;
      return this;
    }

    public EyeDataBuilder WithEyes(params EyeData.Eye[] eyes)
    {
      this._data.eyes = eyes;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.GameModeBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class GameModeBuilder : DataFileBuilder<GameMode, GameModeBuilder>
  {
    public GameModeBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public GameModeBuilder()
    {
    }

    public GameModeBuilder WithSaveFileName(string saveFileName)
    {
      this._data.saveFileName = saveFileName;
      return this;
    }

    public GameModeBuilder WithSeed(string seed)
    {
      this._data.seed = seed;
      return this;
    }

    public GameModeBuilder WithClasses(params ClassData[] classes)
    {
      this._data.classes = classes;
      return this;
    }

    public GameModeBuilder WithGenerator(CampaignGenerator generator)
    {
      this._data.generator = generator;
      return this;
    }

    public GameModeBuilder WithPopulator(CampaignPopulator populator)
    {
      this._data.populator = populator;
      return this;
    }

    public GameModeBuilder WithStartInNode(bool startInNode)
    {
      this._data.startInNode = startInNode;
      return this;
    }

    public GameModeBuilder WithTakeStartingPet(bool takeStartingPet = true)
    {
      this._data.takeStartingPet = takeStartingPet;
      return this;
    }

    public GameModeBuilder WithCountsAsWin(bool countsAsWin = true)
    {
      this._data.countsAsWin = countsAsWin;
      return this;
    }

    public GameModeBuilder WithShowStats(bool showStats = true)
    {
      this._data.showStats = showStats;
      return this;
    }

    public GameModeBuilder WithGainProgress(bool gainProgress = true)
    {
      this._data.gainProgress = gainProgress;
      return this;
    }

    public GameModeBuilder WithDoSave(bool doSave = true)
    {
      this._data.doSave = doSave;
      return this;
    }

    public GameModeBuilder WithCanRestart(bool canRestart = true)
    {
      this._data.canRestart = canRestart;
      return this;
    }

    public GameModeBuilder WithCanGoBack(bool canGoBack = true)
    {
      this._data.canGoBack = canGoBack;
      return this;
    }

    public GameModeBuilder WithSubmitScore(bool submitScore = false)
    {
      this._data.submitScore = submitScore;
      return this;
    }

    public GameModeBuilder WithMainGameMode(bool mainGameMode = true)
    {
      this._data.mainGameMode = mainGameMode;
      return this;
    }

    public GameModeBuilder WithDailyRun(bool dailyRun = false)
    {
      this._data.dailyRun = dailyRun;
      return this;
    }

    public GameModeBuilder WithTutorialRun(bool tutorialRun = false)
    {
      this._data.tutorialRun = tutorialRun;
      return this;
    }

    public GameModeBuilder WithLeaderboardType(Scores.Type leaderboardType)
    {
      this._data.leaderboardType = leaderboardType;
      return this;
    }

    public GameModeBuilder WithStartScene(string startScene)
    {
      this._data.startScene = startScene;
      return this;
    }

    public GameModeBuilder WithSceneAfterSelection(string sceneAfterSelection = "Campaign")
    {
      this._data.sceneAfterSelection = sceneAfterSelection;
      return this;
    }

    public GameModeBuilder WithCampaignSystemNames(params string[] campaignSystemNames)
    {
      this._data.campaignSystemNames = campaignSystemNames;
      return this;
    }

    public GameModeBuilder WithSystemsToDisable(params string[] systemsToDisable)
    {
      this._data.systemsToDisable = systemsToDisable;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.GameModifierDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMODUnity;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class GameModifierDataBuilder : DataFileBuilder<GameModifierData, GameModifierDataBuilder>
  {
    public GameModifierDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public GameModifierDataBuilder()
    {
    }

    public GameModifierDataBuilder WithValue(int value = 100)
    {
      this._data.value = value;
      return this;
    }

    public GameModifierDataBuilder WithVisible(bool visible = true)
    {
      this._data.visible = visible;
      return this;
    }

    public GameModifierDataBuilder WithBellSprite(Sprite bellSprite)
    {
      this._data.bellSprite = bellSprite;
      return this;
    }

    public GameModifierDataBuilder WithBellSprite(string bellSprite)
    {
      this._data.bellSprite = this.Mod.GetImageSprite(bellSprite);
      return this;
    }

    public GameModifierDataBuilder WithDingerSprite(Sprite dingerSprite)
    {
      this._data.dingerSprite = dingerSprite;
      return this;
    }

    public GameModifierDataBuilder WithDingerSprite(string dingerSprite)
    {
      this._data.dingerSprite = this.Mod.GetImageSprite(dingerSprite);
      return this;
    }

    public GameModifierDataBuilder WithTitle(LocalizedString title)
    {
      this._data.titleKey = title;
      return this;
    }

    public GameModifierDataBuilder WithTitle(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_modifier_title", title);
      this._data.titleKey = collection.GetString(this._data.name + "_modifier_title");
      return this;
    }

    public GameModifierDataBuilder WithDescription(LocalizedString title)
    {
      this._data.descriptionKey = title;
      return this;
    }

    public GameModifierDataBuilder WithDescription(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_modifier_desc", title);
      this._data.descriptionKey = collection.GetString(this._data.name + "_modifier_desc");
      return this;
    }

    public GameModifierDataBuilder WithSystemsToAdd(params string[] systemsToAdd)
    {
      this._data.systemsToAdd = systemsToAdd;
      return this;
    }

    public GameModifierDataBuilder WithSetupScripts(params Script[] setupScripts)
    {
      this._data.setupScripts = setupScripts;
      return this;
    }

    public GameModifierDataBuilder WithStartScripts(params Script[] startScripts)
    {
      this._data.startScripts = startScripts;
      return this;
    }

    public GameModifierDataBuilder WithScriptPriority(int scriptPriority)
    {
      this._data.scriptPriority = scriptPriority;
      return this;
    }

    public GameModifierDataBuilder WithBlockedBy(params GameModifierData[] blockedBy)
    {
      this._data.blockedBy = blockedBy;
      return this;
    }

    public GameModifierDataBuilder WithLinkedStormBell(HardModeModifierData linkedStormBell)
    {
      this._data.linkedStormBell = linkedStormBell;
      return this;
    }

    public GameModifierDataBuilder WithRingSfxEvent(EventReference ringSfxEvent)
    {
      this._data.ringSfxEvent = ringSfxEvent;
      return this;
    }

    public GameModifierDataBuilder WithRingSfxPitch()
    {
      this._data.ringSfxPitch = new Vector2(1f, 1f);
      return this;
    }

    public GameModifierDataBuilder WithRingSfxPitch(Vector2 ringSfxPitch)
    {
      this._data.ringSfxPitch = ringSfxPitch;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.InternalMod
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class InternalMod : WildfrostMod
  {
    public InternalMod(string modDirectory)
      : base(modDirectory)
    {
    }

    public override string GUID => "wildfrost";

    public override string[] Depends => new string[0];

    public override string Title => "wildfrost";

    public override string Description => "wildfrost";
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.KeywordDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class KeywordDataBuilder : DataFileBuilder<KeywordData, KeywordDataBuilder>
  {
    public KeywordDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public KeywordDataBuilder()
    {
    }

    public KeywordDataBuilder WithTitle(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Tooltips", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_title", title);
      this._data.titleKey = collection.GetString(this._data.name + "_title");
      return this;
    }

    public KeywordDataBuilder WithDescription(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Tooltips", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_desc", title);
      this._data.descKey = collection.GetString(this._data.name + "_desc");
      return this;
    }

    public KeywordDataBuilder WithTitleColour(Color? theColour = null)
    {
      if (!theColour.HasValue)
        theColour = new Color?(new Color(1f, 0.7921569f, 0.3411765f, 1f));
      this._data.titleColour = theColour.Value;
      return this;
    }

    public KeywordDataBuilder WithBodyColour(Color? theColour = null)
    {
      if (!theColour.HasValue)
        theColour = new Color?(Color.white);
      this._data.bodyColour = theColour.Value;
      return this;
    }

    public KeywordDataBuilder WithNoteColour(Color? theColour = null)
    {
      if (!theColour.HasValue)
        theColour = new Color?(Color.gray);
      this._data.noteColour = theColour.Value;
      return this;
    }

    public KeywordDataBuilder WithPanelColour(Color theColour)
    {
      this._data.panelColor = theColour;
      return this;
    }

    public KeywordDataBuilder WithPanelSprite(string image)
    {
      this._data.panelSprite = this.Mod.GetImageSprite(image);
      return this;
    }

    public KeywordDataBuilder WithIconName(string iconName)
    {
      this._data.iconName = iconName;
      return this;
    }

    public KeywordDataBuilder WithIconTint(Color hexColor)
    {
      this._data.iconTintHex = hexColor.ToHexRGB();
      return this;
    }

    public KeywordDataBuilder WithShow(bool show = true)
    {
      this._data.show = show;
      return this;
    }

    public KeywordDataBuilder WithShowName(bool show)
    {
      this._data.showName = show;
      return this;
    }

    public KeywordDataBuilder WithShowIcon(bool show = true)
    {
      this._data.showIcon = show;
      return this;
    }

    public KeywordDataBuilder WithCanStack(bool show)
    {
      this._data.canStack = show;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.LocalizationHelper
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using HarmonyLib;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public static class LocalizationHelper
  {
    public static readonly Dictionary<string, StringTable> stringTables = new Dictionary<string, StringTable>();
    public static Harmony _harmony = new Harmony("wildfrost");

    public static Locale TryAddLocale(LocaleIdentifier locali)
    {
      if (!LocalizationSettings.AvailableLocales.Locales.All<Locale>((Func<Locale, bool>) (a => a.Identifier != locali)))
        return LocalizationSettings.AvailableLocales.Locales.Find((Predicate<Locale>) (a => a.Identifier == locali));
      Locale locale = Locale.CreateLocale(locali);
      locale.SortOrder = (ushort) LocalizationSettings.AvailableLocales.Locales.Count;
      LocalizationSettings.AvailableLocales.Locales.Add(locale);
      return locale;
    }

    static LocalizationHelper() => LocalizationHelper._harmony.PatchAll(typeof (LocalizationHelper).Assembly);

    public static StringTable GetCollection(string name, LocaleIdentifier identifier)
    {
      string key = name + "_" + identifier.Code;
      StringTable collection1 = Addressables.LoadAssetAsync<StringTable>((object) key).WaitForCompletion();
      if (!((UnityEngine.Object) collection1 == (UnityEngine.Object) null))
        return collection1;
      StringTable collection2;
      if (LocalizationHelper.stringTables.TryGetValue(key, out collection2))
        return collection2;
      StringTable instance = ScriptableObject.CreateInstance<StringTable>();
      instance.name = key;
      instance.LocaleIdentifier = identifier;
      StringTable stringTable = Addressables.LoadAssetAsync<StringTable>((object) (name + "_" + new LocaleIdentifier(SystemLanguage.English).Code)).WaitForCompletion();
      instance.SharedData = stringTable.SharedData;
      LocalizationHelper.stringTables.Add(key, instance);
      return instance;
    }

    public static LocalizedString GetString(this StringTable table, string key)
    {
      TableReference tableCollectionName = (TableReference) table.TableCollectionName;
      LocalizedString localizedString = new LocalizedString();
      localizedString.SetReference(tableCollectionName, (TableEntryReference) key);
      return localizedString;
    }

    public static void SetString(this StringTable table, string key, string value)
    {
      long id = table.SharedData.GetId(key);
      if (id == 0L)
        id = table.SharedData.AddKey(key).Id;
      if (!table.ContainsKey(id))
        table.AddEntry(key, value);
      else
        table[id].Value = value;
    }

    [HarmonyPatch(typeof (LocalizedString), "GetLocalizedString", new System.Type[] {})]
    public class PatchLocalie1
    {
      [HarmonyPostfix]
      public static void Postfix(ref string __result, LocalizedString __instance)
      {
        if (!string.IsNullOrEmpty(__result))
          return;
        StringTable collection = LocalizationHelper.GetCollection(__instance.TableReference.TableCollectionName, LocalizationSettings.SelectedLocale.Identifier);
        TableEntryReference tableEntryReference = __instance.TableEntryReference;
        long num;
        if (tableEntryReference.ReferenceType != TableEntryReference.Type.Id)
        {
          SharedTableData sharedData = collection.SharedData;
          tableEntryReference = __instance.TableEntryReference;
          string key = tableEntryReference.Key;
          num = sharedData.GetId(key);
        }
        else
        {
          tableEntryReference = __instance.TableEntryReference;
          num = tableEntryReference.KeyId;
        }
        long keyId = num;
        StringTableEntry stringTableEntry;
        if (!collection.TryGetValue(keyId, out stringTableEntry))
          return;
        __result = stringTableEntry.Value;
      }
    }

    [HarmonyPatch(typeof (LocalizedStringDatabase), "GenerateLocalizedString", new System.Type[] {typeof (StringTable), typeof (StringTableEntry), typeof (TableReference), typeof (TableEntryReference), typeof (Locale), typeof (IList<object>)})]
    public class PatchLocalie2
    {
      [HarmonyPostfix]
      public static void Postfix(
        ref string __result,
        LocalizedStringDatabase __instance,
        StringTable table,
        StringTableEntry entry,
        TableReference tableReference,
        TableEntryReference tableEntryReference,
        Locale locale,
        IList<object> arguments)
      {
        if (!string.IsNullOrEmpty(__result))
          return;
        StringTable collection = LocalizationHelper.GetCollection(tableReference.TableCollectionName, locale.Identifier);
        long keyId = tableEntryReference.ReferenceType == TableEntryReference.Type.Id ? tableEntryReference.KeyId : collection.SharedData.GetId(tableEntryReference.Key);
        StringTableEntry stringTableEntry;
        if (!collection.TryGetValue(keyId, out stringTableEntry))
          return;
        __result = stringTableEntry.Value;
      }
    }

    [HarmonyPatch(typeof (LocalizedStringDatabase), "GetLocalizedString", new System.Type[] {typeof (TableReference), typeof (TableEntryReference), typeof (IList<object>), typeof (Locale), typeof (FallbackBehavior)})]
    public class PatchLocalie3
    {
      [HarmonyPostfix]
      public static void Postfix(
        ref string __result,
        LocalizedStringDatabase __instance,
        TableReference tableReference,
        TableEntryReference tableEntryReference,
        IList<object> arguments,
        Locale locale = null,
        FallbackBehavior fallbackBehavior = FallbackBehavior.UseProjectSettings)
      {
        if (!string.IsNullOrEmpty(__result))
          return;
        if ((UnityEngine.Object) locale == (UnityEngine.Object) null)
          locale = LocalizationSettings.SelectedLocale;
        StringTable collection = LocalizationHelper.GetCollection(tableReference.TableCollectionName, locale.Identifier);
        long keyId = tableEntryReference.ReferenceType == TableEntryReference.Type.Id ? tableEntryReference.KeyId : collection.SharedData.GetId(tableEntryReference.Key);
        StringTableEntry stringTableEntry;
        if (!collection.TryGetValue(keyId, out stringTableEntry))
          return;
        __result = stringTableEntry.Value;
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.ModsSceneManager
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class ModsSceneManager : MonoBehaviour
  {
    [SerializeField]
    public GameObject Content;
    [SerializeField]
    public GameObject ModPrefab;
    public List<WildfrostMod> instantiatedMods = new List<WildfrostMod>();

    public IEnumerator Start()
    {
      foreach (WildfrostMod mod in Bootstrap.Mods)
      {
        if (!this.instantiatedMods.Contains(mod))
        {
          GameObject gameObject = this.ModPrefab.InstantiateKeepName<GameObject>();
          gameObject.transform.SetParent(this.Content.transform);
          gameObject.transform.SetLocalZ(0.0f);
          gameObject.transform.SetLocalPositionAndRotation(gameObject.transform.localPosition, Quaternion.identity);
          ModHolder componentInChildren = gameObject.GetComponentInChildren<ModHolder>();
          componentInChildren.Mod = mod;
          componentInChildren.UpdateInfo();
          this.instantiatedMods.Add(mod);
        }
      }
      Time.timeScale = 1f;
      yield break;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.StatusEffectDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class StatusEffectDataBuilder : DataFileBuilder<StatusEffectData, StatusEffectDataBuilder>
  {
    public StatusEffectDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public StatusEffectDataBuilder()
    {
    }

    public StatusEffectDataBuilder WithIsStatus(bool value)
    {
      this._data.isStatus = value;
      return this;
    }

    public StatusEffectDataBuilder WithIsReaction(bool value)
    {
      this._data.isReaction = value;
      return this;
    }

    public StatusEffectDataBuilder WithIsKeyword(bool value)
    {
      this._data.isKeyword = value;
      return this;
    }

    public StatusEffectDataBuilder WithType(string type)
    {
      this._data.type = type;
      return this;
    }

    public StatusEffectDataBuilder WithKeyword(string type)
    {
      this._data.keyword = type;
      return this;
    }

    public StatusEffectDataBuilder WithIconGroupName(string type)
    {
      this._data.iconGroupName = type;
      return this;
    }

    public StatusEffectDataBuilder WithVisible(bool value)
    {
      this._data.visible = value;
      return this;
    }

    public StatusEffectDataBuilder WithStackable(bool value)
    {
      this._data.stackable = value;
      return this;
    }

    public StatusEffectDataBuilder WithOffensive(bool value)
    {
      this._data.offensive = value;
      return this;
    }

    public StatusEffectDataBuilder WithMakesOffensive(bool value)
    {
      this._data.makesOffensive = value;
      return this;
    }

    public StatusEffectDataBuilder WithDoesDamage(bool value)
    {
      this._data.doesDamage = value;
      return this;
    }

    public StatusEffectDataBuilder WithCanBeBoosted(bool value)
    {
      this._data.canBeBoosted = value;
      return this;
    }

    public StatusEffectDataBuilder WithText(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("Card Text", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_text", title);
      this._data.textKey = collection.GetString(this._data.name + "_text");
      return this;
    }

    public StatusEffectDataBuilder WithTextInsert(string value)
    {
      this._data.textInsert = value;
      return this;
    }

    public StatusEffectDataBuilder WithOrder(int order)
    {
      this._data.textOrder = order;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.TraitDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class TraitDataBuilder : DataFileBuilder<TraitData, TraitDataBuilder>
  {
    public TraitDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public TraitDataBuilder()
    {
    }

    public TraitDataBuilder WithKeyword(KeywordData data)
    {
      this._data.keyword = data;
      return this;
    }

    public TraitDataBuilder WithEffects(params StatusEffectData[] effects)
    {
      this._data.effects = effects;
      return this;
    }

    public TraitDataBuilder WithOverrides(params TraitData[] traits)
    {
      this._data.overrides = traits;
      return this;
    }

    public TraitDataBuilder WithIsReaction(bool isReaction)
    {
      this._data.isReaction = isReaction;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.UnlockDataBuilder
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using HarmonyLib;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Localization;
using UnityEngine.Localization.Tables;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public class UnlockDataBuilder : DataFileBuilder<UnlockData, UnlockDataBuilder>
  {
    public UnlockDataBuilder(WildfrostMod mod)
      : base(mod)
    {
    }

    public UnlockDataBuilder()
    {
    }

    public UnlockDataBuilder WithUnlockDescription(LocalizedString str)
    {
      this._data.unlockDesc = str;
      return this;
    }

    public UnlockDataBuilder WithUnlockTitle(LocalizedString str)
    {
      this._data.unlockTitle = str;
      return this;
    }

    public UnlockDataBuilder WithUnlockDescription(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("UI Text", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_unlockDesc", title);
      this._data.unlockDesc = collection.GetString(this._data.name + "_unlockDesc");
      return this;
    }

    public UnlockDataBuilder WithUnlockTitle(string title, SystemLanguage lang = SystemLanguage.English)
    {
      StringTable collection = LocalizationHelper.GetCollection("UI Text", new LocaleIdentifier(lang));
      collection.SetString(this._data.name + "_unlockTitle", title);
      this._data.unlockTitle = collection.GetString(this._data.name + "_unlockTitle");
      return this;
    }

    public UnlockDataBuilder WithRequires(params UnlockData[] requires)
    {
      this._data.requires = requires;
      return this;
    }

    public UnlockDataBuilder WithRequires(params string[] requires)
    {
      this._data.requires = ((IEnumerable<string>) requires).Select<string, UnlockData>(new Func<string, UnlockData>(this.Mod.Get<UnlockData>)).ToArray<UnlockData>();
      return this;
    }

    public UnlockDataBuilder WithLowPriority(float priority)
    {
      this._data.lowPriority = priority;
      return this;
    }

    public UnlockDataBuilder WithBuilding(BuildingType relatedBuilding)
    {
      this._data.relatedBuilding = relatedBuilding;
      this.SubscribeToBuildEvent((DataFileBuilder<UnlockData, UnlockDataBuilder>.AfterBuildDelegate) (data => relatedBuilding.unlocks = relatedBuilding.unlocks.AddToArray<UnlockData>(data)));
      return this;
    }

    public UnlockDataBuilder WithBuilding(string relatedBuilding) => this.WithBuilding(this.Mod.Get<BuildingType>(relatedBuilding));

    public UnlockDataBuilder WithType(UnlockData.Type type)
    {
      this._data.type = type;
      return this;
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Deadpan.Enums.Engine.Components.Modding.WildfrostMod
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using HarmonyLib;
using HarmonyLib.Tools;
using JetBrains.Annotations;
using Steamworks;
using Steamworks.Ugc;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using TMPro;
using UnityEngine;
using UnityEngine.AddressableAssets;

namespace Deadpan.Enums.Engine.Components.Modding
{
  public abstract class WildfrostMod : IComparable<WildfrostMod>
  {
    public string ModDirectory;
    public Sprite _iconSprite;
    public Harmony HarmonyInstance;
    [CompilerGenerated]
    public bool \u003CHasLoaded\u003Ek__BackingField;
    [CompilerGenerated]
    public readonly TMP_SpriteAsset \u003CSpriteAsset\u003Ek__BackingField;
    public static List<System.Type> AllBuiledrs = typeof (WildfrostMod).Assembly.GetTypes().ToList<System.Type>().FindAll((Predicate<System.Type>) (a =>
    {
      System.Type baseType = a.BaseType;
      return (object) baseType != null && baseType.IsGenericType && a.BaseType.GetGenericTypeDefinition() == typeof (DataFileBuilder<,>);
    }));
    public static List<System.Type> AllDataTypes = typeof (WildfrostMod).Assembly.GetTypes().ToList<System.Type>().FindAll((Predicate<System.Type>) (a => a.BaseType == typeof (DataFile)));

    public T GetAsset<T>(string name) => Addressables.LoadAssetAsync<T>((object) name).WaitForCompletion();

    public Sprite GetImageSprite(string relPath) => this.RelToAbsPath(relPath).ToSprite();

    public string RelToAbsPath(params string[] relPath)
    {
      string[] strArray = new string[relPath.Length + 1];
      strArray[0] = this.ModDirectory;
      for (int index = 1; index < strArray.Length; ++index)
        strArray[index] = relPath[index - 1];
      return Path.Combine(strArray);
    }

    public CardData.TraitStacks CreateTraitStack(string name, int amount) => new CardData.TraitStacks(this.Get<TraitData>(name), amount);

    public CardData.StatusEffectStacks CreateEffectStack(string name, int amount) => new CardData.StatusEffectStacks(this.Get<StatusEffectData>(name), amount);

    [Obsolete("Use one without type parameters", true)]
    public CardData.StatusEffectStacks CreateEffectStack<T>(string name, int amount) where T : StatusEffectData => new CardData.StatusEffectStacks(this.Get<StatusEffectData>(name), amount);

    public T Get<T>(string name) where T : DataFile
    {
      T obj = AddressableLoader.Get<T>(typeof (T).Name, Extensions.PrefixGUID(name, this));
      return (bool) (UnityEngine.Object) obj ? obj : AddressableLoader.Get<T>(typeof (T).Name, name);
    }

    public T GetStatusEffect<T>(string name) where T : StatusEffectData
    {
      StatusEffectData statusEffectData = AddressableLoader.Get<StatusEffectData>("StatusEffectData", Extensions.PrefixGUID(name, this));
      return (bool) (UnityEngine.Object) statusEffectData ? (T) statusEffectData : (T) AddressableLoader.Get<StatusEffectData>("StatusEffectData", name);
    }

    public static WildfrostMod[] GetLastMods()
    {
      string[] source = SaveSystem.LoadProgressData<string[]>("lastSavedMods");
      return source != null ? ((IEnumerable<string>) source).Select<string, WildfrostMod>(new Func<string, WildfrostMod>(Extensions.GetModFromGuid)).ToArray<WildfrostMod>() : new WildfrostMod[0];
    }

    public static void SetLastMods(WildfrostMod[] enabled) => SaveSystem.SaveProgressData<string[]>("lastSavedMods", ((IEnumerable<WildfrostMod>) enabled).Select<WildfrostMod, string>((Func<WildfrostMod, string>) (a => a.GUID)).ToArray<string>());

    public WildfrostMod.ConfigStorage FromConfigs()
    {
      (WildfrostMod.ConfigItemAttribute, FieldInfo)[] configs = this.GetConfigs();
      return new WildfrostMod.ConfigStorage()
      {
        Store = configs,
        Mod = this
      };
    }

    public (WildfrostMod.ConfigItemAttribute atr, FieldInfo field)[] GetConfigs()
    {
      List<(WildfrostMod.ConfigItemAttribute, FieldInfo)> valueTupleList = new List<(WildfrostMod.ConfigItemAttribute, FieldInfo)>();
      foreach (FieldInfo field in this.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public))
      {
        WildfrostMod.ConfigItemAttribute customAttribute = field.GetCustomAttribute<WildfrostMod.ConfigItemAttribute>();
        if (customAttribute != null)
          valueTupleList.Add((customAttribute, field));
      }
      return valueTupleList.ToArray();
    }

    public WildfrostMod(string modDirectory)
      : this()
    {
      this.ModDirectory = modDirectory;
    }

    public virtual string IconPath => Path.Combine(this.ModDirectory, "icon.png");

    public virtual Sprite IconSprite => this._iconSprite ?? (this._iconSprite = this.IconPath.ToSprite());

    public abstract string GUID { get; }

    public abstract string[] Depends { get; }

    public abstract string Title { get; }

    public abstract string Description { get; }

    public bool HasLoaded
    {
      get => this.\u003CHasLoaded\u003Ek__BackingField;
      set => this.\u003CHasLoaded\u003Ek__BackingField = value;
    }

    public virtual string ImagesDirectory => Path.Combine(this.ModDirectory, "images");

    public virtual TMP_SpriteAsset SpriteAsset => this.\u003CSpriteAsset\u003Ek__BackingField;

    public string ImagePath(string fileName) => Path.Combine(this.ImagesDirectory, fileName);

    public WildfrostMod[] GetDependancies(bool throwIfNotFound = true)
    {
      ILookup<string, WildfrostMod> look = Bootstrap.Mods.ToLookup<WildfrostMod, string>((Func<WildfrostMod, string>) (a => a.GUID));
      List<(string, WildfrostMod)> list = ((IEnumerable<string>) this.Depends).Select<string, (string, WildfrostMod)>((Func<string, (string, WildfrostMod)>) (a => (a, look[a].FirstOrDefault<WildfrostMod>()))).ToList<(string, WildfrostMod)>();
      if (throwIfNotFound)
      {
        (string, WildfrostMod) tuple = list.Find((Predicate<(string, WildfrostMod)>) (a => a.Item2 == null));
        if (tuple.Item2 == null && !string.IsNullOrEmpty(tuple.Item1))
          throw new Exception("Mod " + tuple.Item1 + " not found! While it is a dependency for " + this.GUID);
      }
      return list.Select<(string, WildfrostMod), WildfrostMod>((Func<(string, WildfrostMod), WildfrostMod>) (a => a.Item2)).ToArray<WildfrostMod>();
    }

    public void LoadDependancies()
    {
      foreach (WildfrostMod dependancy in this.GetDependancies())
        dependancy.ModLoad();
    }

    public void UnloadModsDependantOnThis()
    {
      foreach (WildfrostMod wildfrostMod in Bootstrap.Mods.Where<WildfrostMod>((Func<WildfrostMod, bool>) (a => a.HasLoaded && a.Depends.Contains<string>(this.GUID))))
        wildfrostMod.ModUnload();
    }

    public void ModLoad()
    {
      if (this.HasLoaded)
        return;
      this.LoadDependancies();
      WildfrostMod.ConfigStorage configStorage = this.FromConfigs();
      string str = Path.Combine(this.ModDirectory, "config.cfg");
      if (!File.Exists(str))
        configStorage.WriteToFile(str);
      configStorage.ReadFromFile(str);
      this.Load();
      this.UpdateSave();
      Events.InvokeModLoaded(this);
    }

    public void UpdateSave() => WildfrostMod.SetLastMods(Bootstrap.Mods.ToList<WildfrostMod>().FindAll((Predicate<WildfrostMod>) (a => a.HasLoaded)).ToArray());

    public void ModToggle()
    {
      if (this.HasLoaded)
      {
        this.ModUnload();
      }
      else
      {
        if (this.HasLoaded)
          return;
        this.ModLoad();
      }
    }

    public virtual void Load()
    {
      this.HarmonyInstance.PatchAll(this.GetType().Assembly);
      List<System.Type> allBuiledrs = WildfrostMod.AllBuiledrs;
      List<System.Type> allDataTypes = WildfrostMod.AllDataTypes;
      Dictionary<System.Type, object> dictionary = new Dictionary<System.Type, object>();
      foreach (System.Type type1 in allDataTypes)
      {
        System.Type dataType = type1;
        System.Type type2 = allBuiledrs.Find((Predicate<System.Type>) (a => a.BaseType.GetGenericArguments()[0] == dataType));
        if (!(type2 == (System.Type) null))
        {
          object obj = typeof (WildfrostMod).GetMethod("AddAllTAssetsToGroup", BindingFlags.Instance | BindingFlags.NonPublic).MakeGenericMethod(dataType, type2).Invoke((object) this, new object[0]);
          dictionary.Add(dataType, obj);
        }
      }
      foreach (System.Type type3 in allDataTypes)
      {
        System.Type dataType = type3;
        System.Type type4 = allBuiledrs.Find((Predicate<System.Type>) (a => a.BaseType.GetGenericArguments()[0] == dataType));
        if (!(type4 == (System.Type) null))
        {
          object obj = dictionary[dataType];
          typeof (WildfrostMod.BuilderToBuilt<,>).MakeGenericType(dataType, type4).GetMethod("OnAfterAllModBuildsEvent", BindingFlags.Instance | BindingFlags.Public).Invoke(obj, new object[0]);
        }
      }
      this.HasLoaded = true;
    }

    public WildfrostMod.BuilderToBuilt<T, Y> AddAllTAssetsToGroup<T, Y>()
      where T : DataFile
      where Y : DataFileBuilder<T, Y>, new()
    {
      List<Y> yList = this.AddAssets<Y, T>();
      if (yList == null)
        return new WildfrostMod.BuilderToBuilt<T, Y>()
        {
          builder = new List<Y>(),
          built = new List<T>()
        };
      List<T> list = yList.Select<Y, T>((Func<Y, T>) (a => a.Build())).ToList<T>();
      if (list != null)
      {
        foreach (T obj in list)
        {
          obj.ModAdded = this;
          if (obj is CardData cardData && !(bool) (UnityEngine.Object) cardData.targetMode)
            throw new Exception("Card must have a target mode " + cardData.name);
        }
        AddressableLoader.AddRangeToGroup<T>(typeof (T).Name, (IEnumerable<T>) list);
      }
      return new WildfrostMod.BuilderToBuilt<T, Y>(list, yList);
    }

    [CanBeNull]
    public virtual List<T> AddAssets<T, Y>()
      where T : DataFileBuilder<Y, T>, new()
      where Y : DataFile
    {
      return (List<T>) null;
    }

    public void ModUnload()
    {
      if (!this.HasLoaded)
        return;
      this.Unload();
      this.UnloadModsDependantOnThis();
      this.UpdateSave();
      Events.InvokeModUnloaded(this);
    }

    public virtual void Unload()
    {
      if (!this.HasLoaded)
        return;
      this.HarmonyInstance.UnpatchAll(this.HarmonyInstance.Id);
      this.HasLoaded = false;
      foreach (System.Type type in typeof (WildfrostMod).Assembly.GetTypes().ToList<System.Type>().FindAll((Predicate<System.Type>) (a => a.BaseType == typeof (DataFile))))
        typeof (WildfrostMod).GetMethod("RemoveeAllTAssetsFromGroup", BindingFlags.Instance | BindingFlags.NonPublic).MakeGenericMethod(type).Invoke((object) this, new object[0]);
    }

    public void RemoveeAllTAssetsFromGroup<T>() where T : DataFile
    {
      foreach (T obj in UnityEngine.Object.FindObjectsOfType<T>())
      {
        if (obj.ModAdded == this)
        {
          if (obj is CardData inst)
            inst.RemoveFromPets();
          AddressableLoader.RemoveFromGroup<T>(typeof (T).Name, obj);
          obj.Destroy();
        }
      }
    }

    public WildfrostMod() => this.HarmonyInstance = new Harmony(this.GUID);

    static WildfrostMod()
    {
      Harmony.DEBUG = true;
      HarmonyFileLog.Enabled = true;
      HarmonyLib.Tools.Logger.ChannelFilter = HarmonyLib.Tools.Logger.LogChannel.Info | HarmonyLib.Tools.Logger.LogChannel.Debug;
      HarmonyFileLog.Writer = (TextWriter) new WildfrostMod.DebugLoggerTextWriter();
    }

    public void WriteLine(string text) => Debug.Log((object) ("[" + this.GUID + "] " + text));

    public void WriteWarn(string text) => Debug.LogWarning((object) ("[" + this.GUID + "] " + text));

    public void WriteError(string text) => Debug.LogError((object) ("[" + this.GUID + "] " + text));

    public int CompareTo(WildfrostMod other)
    {
      if (this == other)
        return 0;
      return other == null ? 1 : string.Compare(this.GUID, other.GUID, StringComparison.Ordinal);
    }

    public async void UpdateOrPublishWorkshop()
    {
      WildfrostMod wildfrostMod = this;
      List<Steamworks.Ugc.Item> entries = (await new Query(UgcType.Items, user: SteamClient.SteamId).WithMetadata(true).WithTag("Mod").GetPageAsync(1)).Value.Entries.ToList<Steamworks.Ugc.Item>().FindAll((Predicate<Steamworks.Ugc.Item>) (a => a.Result != Steamworks.Result.FileNotFound));
      Steamworks.Ugc.Item curItem = entries.Find(new Predicate<Steamworks.Ugc.Item>(wildfrostMod.\u003CUpdateOrPublishWorkshop\u003Eb__62_1));
      PublishResult result;
      if (entries.Count == 0 || curItem.Equals((object) new Steamworks.Ugc.Item()))
      {
        Editor editor = Editor.NewCommunityFile;
        editor = editor.WithTitle(wildfrostMod.Title);
        editor = editor.WithDescription(wildfrostMod.Description);
        editor = editor.WithTag("Mod");
        editor = editor.ForAppId(SteamClient.AppId);
        editor = editor.WithPublicVisibility();
        editor = editor.WithPreviewFile(wildfrostMod.IconPath);
        editor = editor.WithContent(wildfrostMod.ModDirectory);
        editor = editor.WithMetaData(wildfrostMod.GUID);
        result = await editor.SubmitAsync();
        Steamworks.Ugc.Item? async = await Steamworks.Ugc.Item.GetAsync(result.FileId);
        foreach (string depend1 in wildfrostMod.Depends)
        {
          string depend = depend1;
          Steamworks.Ugc.Item obj = entries.Find((Predicate<Steamworks.Ugc.Item>) (a => a.Metadata == depend));
          if (!curItem.Equals((object) new Steamworks.Ugc.Item()) && async.HasValue)
            async.GetValueOrDefault().AddDependency(obj.Id);
        }
        Debug.Log((object) ("Upload result " + result.ToString()));
        result = new PublishResult();
        entries = (List<Steamworks.Ugc.Item>) null;
        curItem = new Steamworks.Ugc.Item();
      }
      else
      {
        Editor editor = new Editor(curItem.Id);
        editor = editor.WithTitle(wildfrostMod.Title);
        editor = editor.WithDescription(wildfrostMod.Description);
        editor = editor.WithTag("Mod");
        editor = editor.ForAppId(SteamClient.AppId);
        editor = editor.WithPublicVisibility();
        editor = editor.WithPreviewFile(wildfrostMod.IconPath);
        editor = editor.WithContent(wildfrostMod.ModDirectory);
        editor = editor.WithMetaData(wildfrostMod.GUID);
        result = await editor.SubmitAsync();
        Steamworks.Ugc.Item? async = await Steamworks.Ugc.Item.GetAsync(result.FileId);
        foreach (string depend2 in wildfrostMod.Depends)
        {
          string depend = depend2;
          Steamworks.Ugc.Item obj = entries.Find((Predicate<Steamworks.Ugc.Item>) (a => a.Metadata == depend));
          if (!curItem.Equals((object) new Steamworks.Ugc.Item()) && async.HasValue)
            async.GetValueOrDefault().AddDependency(obj.Id);
        }
        Debug.Log((object) ("Update result " + result.ToString()));
        result = new PublishResult();
        entries = (List<Steamworks.Ugc.Item>) null;
        curItem = new Steamworks.Ugc.Item();
      }
    }

    [CompilerGenerated]
    public bool \u003CUnloadModsDependantOnThis\u003Eb__42_0(WildfrostMod a) => a.HasLoaded && a.Depends.Contains<string>(this.GUID);

    [CompilerGenerated]
    public bool \u003CUpdateOrPublishWorkshop\u003Eb__62_1(Steamworks.Ugc.Item a) => a.Metadata == this.GUID;

    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public sealed class ConfigItemAttribute : Attribute
    {
      public string comment;
      public string forceTitle;
      public string fieldName;
      public string defaultValue;

      public string Title => !string.IsNullOrEmpty(this.forceTitle) ? this.forceTitle : this.fieldName;

      [Obsolete("Use new constructor", true)]
      public ConfigItemAttribute(object defaultValue, string forceTitle = null)
      {
        this.comment = "";
        this.forceTitle = forceTitle;
        this.defaultValue = TypeDescriptor.GetConverter(defaultValue.GetType()).ConvertToString(defaultValue);
      }

      public ConfigItemAttribute(object defaultValue, string comment = "", string forceTitle = null)
      {
        this.comment = comment;
        this.forceTitle = forceTitle;
        this.defaultValue = TypeDescriptor.GetConverter(defaultValue.GetType()).ConvertToString(defaultValue);
      }
    }

    public struct ConfigStorage
    {
      public (WildfrostMod.ConfigItemAttribute atr, FieldInfo field)[] Store;
      public (string title, string value)[] Read;
      public WildfrostMod Mod;

      public void WriteToFile(string name)
      {
        StringBuilder stringBuilder = new StringBuilder();
        foreach ((WildfrostMod.ConfigItemAttribute atr, FieldInfo field) tuple in this.Store)
        {
          tuple.atr.fieldName = tuple.field.Name;
          stringBuilder.AppendLine("//" + tuple.atr.comment);
          stringBuilder.AppendLine(tuple.field.FieldType.FullName + " : " + tuple.atr.Title + " = " + tuple.atr.defaultValue);
        }
        File.WriteAllText(name, stringBuilder.ToString());
      }

      public void ReadFromFile(string name)
      {
        int num1 = 0;
        while (true)
        {
          try
          {
            IEnumerable<string> strings = File.ReadLines(name);
            foreach ((WildfrostMod.ConfigItemAttribute atr, FieldInfo field) tuple in this.Store)
              tuple.atr.fieldName = tuple.field.Name;
            List<(WildfrostMod.ConfigItemAttribute atr, FieldInfo field)> list = this.Store.ToList<(WildfrostMod.ConfigItemAttribute, FieldInfo)>();
            using (IEnumerator<string> enumerator = strings.GetEnumerator())
            {
              while (enumerator.MoveNext())
              {
                string current = enumerator.Current;
                if (!current.StartsWith("//"))
                {
                  int num2 = current.IndexOf(':');
                  int num3 = current.IndexOf('=');
                  string name1 = current.Substring(0, num2 - 1 - 0);
                  string str1 = current;
                  int num4 = num2 + 2;
                  int num5 = num3 - 1 - num4;
                  int startIndex1 = num4;
                  int length1 = num5;
                  string title = str1.Substring(startIndex1, length1);
                  string str2 = current;
                  int length2 = str2.Length;
                  int startIndex2 = num3 + 2;
                  int num6 = startIndex2;
                  int length3 = length2 - num6;
                  string text = str2.Substring(startIndex2, length3);
                  (WildfrostMod.ConfigItemAttribute atr, FieldInfo field) tuple = list.Find((Predicate<(WildfrostMod.ConfigItemAttribute, FieldInfo)>) (a => a.atr.Title == title));
                  (WildfrostMod.ConfigItemAttribute atr, FieldInfo field) = tuple;
                  if (atr == null && field == (FieldInfo) null)
                    throw new WildfrostMod.ConfigStorage.FileIsCorrupted("Config error, no store");
                  if (tuple.field == (FieldInfo) null)
                    throw new Exception("Config value not found " + tuple.atr.Title);
                  System.Type type1 = (System.Type) null;
                  foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
                  {
                    System.Type type2 = assembly.GetType(name1);
                    if (type2 != (System.Type) null)
                    {
                      type1 = type2;
                      break;
                    }
                  }
                  object obj = !(type1 == (System.Type) null) ? TypeDescriptor.GetConverter(type1).ConvertFromInvariantString(text) : throw new Exception("Unknown value type " + name1);
                  tuple.field.SetValue((object) this.Mod, obj);
                }
              }
              break;
            }
          }
          catch (WildfrostMod.ConfigStorage.FileIsCorrupted ex)
          {
            ++num1;
            if (num1 > 1)
            {
              throw;
            }
            else
            {
              File.Delete(name);
              this.WriteToFile(name);
            }
          }
        }
      }

      public class FileIsCorrupted : Exception
      {
        public FileIsCorrupted(string s)
          : base(s)
        {
        }
      }
    }

    public struct BuilderToBuilt<T, Y>
      where T : DataFile
      where Y : DataFileBuilder<T, Y>, new()
    {
      public List<T> built;
      public List<Y> builder;

      public BuilderToBuilt(List<T> dataFiles, List<Y> builders)
      {
        this.built = dataFiles;
        this.builder = builders;
      }

      public void OnAfterAllModBuildsEvent()
      {
        for (int index = 0; index < this.builder.Count; ++index)
          this.builder[index].OnAfterAllModBuildsEvent(this.built[index]);
      }
    }

    public class DebugLoggerTextWriter : TextWriter
    {
      public override Encoding Encoding => Encoding.UTF8;

      public override void Write(string value)
      {
        value = "[HARMONY] " + value;
        Debug.Log((object) value);
      }

      public override void WriteLine(string value)
      {
        value = "[HARMONY] " + value;
        Debug.Log((object) (value + "\n"));
      }
    }
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: WinMusic
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using FMOD;
using FMOD.Studio;
using FMODUnity;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class WinMusic : MonoBehaviour
{
  [SerializeField]
  public bool playOnStart = true;
  [SerializeField]
  public EventReference musicEvent;
  public EventInstance current;

  public void OnEnable()
  {
    global::Events.OnBackToMainMenu += new UnityAction(this.BackToMainMenu);
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
  }

  public void OnDisable()
  {
    global::Events.OnBackToMainMenu -= new UnityAction(this.BackToMainMenu);
    global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);
  }

  public void Start()
  {
    if (!this.playOnStart || (Object) References.Battle.winner != (Object) References.Battle.player)
      return;
    this.StartMusic(this.musicEvent.Guid);
  }

  public void BackToMainMenu() => this.SetEndParam();

  public void SceneChanged(Scene scene) => this.SetEndParam();

  public void Play() => this.StartMusic(this.musicEvent.Guid);

  public void StartMusic(GUID eventGUID)
  {
    try
    {
      this.current = RuntimeManager.CreateInstance(eventGUID);
      int num = (int) this.current.start();
    }
    catch (EventNotFoundException ex)
    {
      UnityEngine.Debug.LogWarning((object) ex);
    }
  }

  public void SetEndParam() => this.SetParam("final_win", 1f);

  public void SetParam(string name, float value)
  {
    if (!this.IsRunning())
      return;
    int num = (int) this.current.setParameterByName(name, value);
  }

  public bool IsRunning()
  {
    if (this.current.isValid())
    {
      PLAYBACK_STATE state;
      int playbackState = (int) this.current.getPlaybackState(out state);
      if (state != PLAYBACK_STATE.STOPPED)
        return true;
    }
    return false;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: WispAnimator
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using System;
using UnityEngine;

public class WispAnimator : MonoBehaviourCacheTransform
{
  public float knockback = 8f;
  public float gravitate = 5f;
  public float maxSpeed = 2f;
  public ParticleSystem smokeFx;
  public SpriteRenderer sprite;
  public SpriteRenderer faceSprite;
  public ParticleSystem pingPS;
  public Vector3 velocity = Vector3.zero;
  public Transform target;

  public void KnockBackFrom(Vector3 from) => this.velocity = (this.transform.position - from).WithZ(0.0f).normalized * this.knockback;

  public void SetTarget(Transform target) => this.target = target;

  public bool TargetExists() => (bool) (UnityEngine.Object) this.target;

  public void JumpToTarget()
  {
    this.pingPS.Play();
    LeanTween.move(this.gameObject, this.target.position, 1f).setEaseInBack();
  }

  public void FadeToColour(Color color, float delay, float duration)
  {
    Color color1 = this.sprite.color;
    Gradient gradient = new Gradient()
    {
      alphaKeys = new GradientAlphaKey[1]
      {
        new GradientAlphaKey(1f, 0.0f)
      },
      colorKeys = new GradientColorKey[2]
      {
        new GradientColorKey(color1, 0.0f),
        new GradientColorKey(color, 1f)
      }
    };
    LeanTween.value(this.gameObject, 0.0f, 1f, duration).setDelay(delay).setOnUpdate((Action<float>) (a =>
    {
      Color color2 = gradient.Evaluate(a);
      this.sprite.color = color2;
      this.smokeFx.main.startColor = (ParticleSystem.MinMaxGradient) color2;
    }));
  }

  public void SetSortingLayer(string layerName, int orderInLayer)
  {
    this.smokeFx.GetComponent<Renderer>().sortingLayerName = layerName;
    this.smokeFx.GetComponent<Renderer>().sortingOrder = orderInLayer;
    this.sprite.sortingLayerName = layerName;
    this.sprite.sortingOrder = orderInLayer + 1;
    this.faceSprite.sortingLayerName = layerName;
    this.faceSprite.sortingOrder = orderInLayer + 2;
  }

  public void Update()
  {
    this.transform.position += this.velocity * Time.deltaTime;
    this.velocity = Vector3.MoveTowards(this.velocity, (double) this.maxSpeed != 0.0 ? ((bool) (UnityEngine.Object) this.target ? (this.target.position - this.transform.position).normalized * this.maxSpeed : Vector3.zero) : Vector3.zero, this.gravitate * Time.deltaTime);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: Wobbler
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using Dead;
using UnityEngine;

public class Wobbler : MonoBehaviourCacheTransform, IPoolable
{
  public Vector3 rotationInfluence = new Vector3(10f, 10f, 2f);
  public Vector3 rotationMax = new Vector3(50f, 50f, 50f);
  public Vector3 rotationDamping = new Vector3(0.91f, 0.93f, 0.94f);
  public Vector3 rotationAcc = new Vector3(1f, 0.8f, 0.7f);
  public Vector3 rotation;
  public Vector3 rotationVelocity;

  public void Update()
  {
    this.rotationVelocity -= Vector3.Scale(this.rotation, this.rotationAcc) * Time.deltaTime;
    this.rotationVelocity = Delta.Multiply(this.rotationVelocity, this.rotationDamping, Time.deltaTime);
    this.rotation += this.rotationVelocity * (200f * Time.deltaTime);
    this.transform.localEulerAngles = this.rotation;
  }

  public void Wobble(Vector3 movement) => this.rotation = (this.rotation + Vector3.Scale(new Vector3(movement.y, -movement.x, -movement.x), this.rotationInfluence)).Clamp(-this.rotationMax, this.rotationMax);

  public void WobbleRandom(float wobbleFactor = 1f) => this.Wobble((Vector3) (PettyRandom.Vector2() * wobbleFactor));

  public void OnGetFromPool()
  {
  }

  public void OnReturnToPool()
  {
    this.rotation = Vector3.zero;
    this.rotationVelocity = Vector3.zero;
    this.transform.localScale = Vector3.one;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: WorldSpaceCanvasFitScreen
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;

public class WorldSpaceCanvasFitScreen : WorldSpaceCanvasUpdater
{
  [ReadOnly]
  public float width;
  [ReadOnly]
  public float height;
  [SerializeField]
  public float scale = 1f;
  [SerializeField]
  public AnimationCurve largeScaleCurve;
  [SerializeField]
  public Vector2 padding;
  public UnityEvent<RectTransform> onUpdate;

  public override void UpdateSize()
  {
    if (!WorldSpaceCanvasFitScreenSystem.exists)
      return;
    if (WorldSpaceCanvasFitScreenSystem.instance.cam.orthographic)
    {
      this.height = WorldSpaceCanvasFitScreenSystem.instance.cam.orthographicSize * 2f;
      this.width = this.height * WorldSpaceCanvasFitScreenSystem.instance.aspectRatio;
    }
    else
    {
      this.height = 11.547f;
      this.width = this.height * WorldSpaceCanvasFitScreenSystem.instance.aspectRatio;
    }
    float num;
    if ((double) this.width < 17.320510864257813)
    {
      num = this.width / 17.32051f * this.scale;
      this.width = 17.32051f;
      this.height = this.width / 1.5f;
    }
    else
    {
      if ((double) this.width > 26.943000793457031)
        this.width = 26.943f;
      AnimationCurve largeScaleCurve = this.largeScaleCurve;
      if (largeScaleCurve != null)
      {
        int length = largeScaleCurve.length;
      }
      num = this.scale;
    }
    this.rectTransform.sizeDelta = new Vector2(this.width - this.padding.x, this.height - this.padding.y);
    this.rectTransform.localScale = new Vector3(num, num, 1f);
    this.onUpdate?.Invoke(this.rectTransform);
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: WorldSpaceCanvasFitScreenSystem
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

public class WorldSpaceCanvasFitScreenSystem : GameSystem
{
  public static WorldSpaceCanvasFitScreenSystem instance;
  public static bool exists;
  [Header("Screen Size")]
  [ReadOnly]
  public int screenWidth;
  [ReadOnly]
  public int screenHeight;
  [ReadOnly]
  public float aspectRatio;
  [Header("UI Size")]
  [ReadOnly]
  public Rect safeArea;
  public const float fixedHeight = 11.547f;
  public const float maxWidth = 26.943f;
  public const float minWidth = 17.32051f;
  public const float minAspect = 1.5f;
  public const float maxAspect = 2.33333325f;
  [CompilerGenerated]
  public Camera \u003Ccam\u003Ek__BackingField;
  public static readonly List<WorldSpaceCanvasUpdater> canvases = new List<WorldSpaceCanvasUpdater>();
  public static readonly Vector3 camPosition = new Vector3(0.0f, 0.0f, -10f);
  public ScreenOrientation lastOrientation;
  public Rect lastSafeArea;

  public Camera cam
  {
    get => this.\u003Ccam\u003Ek__BackingField;
    set => this.\u003Ccam\u003Ek__BackingField = value;
  }

  public static float AspectRatio => !WorldSpaceCanvasFitScreenSystem.exists ? 1.77777779f : Mathf.Min(2.33333325f, WorldSpaceCanvasFitScreenSystem.instance.aspectRatio);

  public void OnEnable()
  {
    WorldSpaceCanvasFitScreenSystem.instance = this;
    WorldSpaceCanvasFitScreenSystem.exists = true;
    global::Events.OnSceneChanged += new UnityAction<Scene>(this.SceneChanged);
    this.UpdateSize();
  }

  public void OnDisable() => global::Events.OnSceneChanged -= new UnityAction<Scene>(this.SceneChanged);

  public void SceneChanged(Scene scene) => this.UpdateSize();

  public void Update()
  {
    if (!(bool) (Object) this.cam)
    {
      this.cam = Camera.main;
      if (!(bool) (Object) this.cam)
        return;
      this.UpdateSize();
    }
    else
    {
      if (this.cam.scaledPixelWidth == this.screenWidth && this.cam.scaledPixelHeight == this.screenHeight)
        return;
      this.UpdateSize();
    }
  }

  [Button(null, EButtonEnableMode.Always)]
  public void UpdateSize()
  {
    this.lastOrientation = Screen.orientation;
    this.lastSafeArea = Screen.safeArea;
    Debug.Log((object) string.Format("[{0}] UPDATING ~World Space~ CANVAS SIZE", (object) this));
    if (!(bool) (Object) this.cam)
      this.cam = Camera.main;
    this.screenWidth = this.cam.scaledPixelWidth;
    this.screenHeight = this.cam.scaledPixelHeight;
    this.aspectRatio = this.cam.aspect;
    Debug.Log((object) string.Format("New Size: ({0}, {1}) Aspect: {2}", (object) this.screenWidth, (object) this.screenHeight, (object) this.aspectRatio));
    int screenWidth = this.screenWidth;
    Rect safeArea1;
    if ((double) this.aspectRatio > 2.3333332538604736)
    {
      screenWidth = Mathf.RoundToInt((float) this.screenHeight * 2.33333325f);
      Debug.Log((object) string.Format("OVER MAX ASPECT RATIO. Actual Size: ({0}, {1}) Aspect: {2}", (object) screenWidth, (object) this.screenHeight, (object) (float) ((double) screenWidth / (double) this.screenHeight)));
      ref Rect local = ref safeArea1;
      double x = (double) Screen.safeArea.x;
      double y = (double) Screen.safeArea.y;
      Rect safeArea2 = Screen.safeArea;
      double width = (double) safeArea2.width;
      safeArea2 = Screen.safeArea;
      double height = (double) safeArea2.height;
      local = new Rect((float) x, (float) y, (float) width, (float) height);
      if ((double) safeArea1.width / (double) safeArea1.height > 2.3333332538604736)
      {
        float num1 = safeArea1.height * 2.33333325f;
        float num2 = safeArea1.width - num1;
        safeArea1.x = Mathf.Max(0.0f, safeArea1.x - num2);
        safeArea1.width = num1;
      }
    }
    else
      safeArea1 = Screen.safeArea;
    this.safeArea = new Rect()
    {
      x = safeArea1.x / (float) screenWidth,
      y = safeArea1.y / (float) this.screenHeight,
      width = safeArea1.width / (float) screenWidth,
      height = safeArea1.height / (float) this.screenHeight
    };
    Debug.Log((object) string.Format("UI Safe Area: {0}", (object) safeArea1));
    foreach (WorldSpaceCanvasUpdater canvase in WorldSpaceCanvasFitScreenSystem.canvases)
      canvase.UpdateSize();
  }

  public static void Register(WorldSpaceCanvasUpdater canvas) => WorldSpaceCanvasFitScreenSystem.canvases.Add(canvas);

  public static void Unregister(WorldSpaceCanvasUpdater canvas) => WorldSpaceCanvasFitScreenSystem.canvases.Remove(canvas);
}
﻿// Decompiled with JetBrains decompiler
// Type: WorldSpaceCanvasSafeArea
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using UnityEngine;

public class WorldSpaceCanvasSafeArea : WorldSpaceCanvasUpdater
{
  [SerializeField]
  public RectTransform parent;
  [SerializeField]
  public bool considerX = true;
  [SerializeField]
  public bool considerY;
  public bool waitForParent;

  public void LateUpdate()
  {
    if (!this.waitForParent || !this.parent.gameObject.activeSelf || !WorldSpaceCanvasFitScreenSystem.exists)
      return;
    Vector2 sizeDelta = this.parent.sizeDelta;
    float num1 = this.considerX ? WorldSpaceCanvasFitScreenSystem.instance.safeArea.x : 0.0f;
    float num2 = this.considerY ? WorldSpaceCanvasFitScreenSystem.instance.safeArea.y : 0.0f;
    float num3 = this.considerX ? WorldSpaceCanvasFitScreenSystem.instance.safeArea.width : 1f;
    float num4 = this.considerY ? WorldSpaceCanvasFitScreenSystem.instance.safeArea.height : 1f;
    float num5 = this.considerX ? 1f - WorldSpaceCanvasFitScreenSystem.instance.safeArea.width - WorldSpaceCanvasFitScreenSystem.instance.safeArea.x : 0.0f;
    float num6 = this.considerY ? 1f - WorldSpaceCanvasFitScreenSystem.instance.safeArea.height - WorldSpaceCanvasFitScreenSystem.instance.safeArea.y : 0.0f;
    double num7 = (double) num3 * (double) sizeDelta.x;
    float num8 = num4 * sizeDelta.y;
    double num9 = (double) num8;
    if (num7 / num9 < 1.5)
    {
      double num10 = (double) num8 * 1.5 / (double) sizeDelta.x;
      float num11 = (float) num10 - num3;
      num1 = Mathf.Max(0.0f, num1 - num11);
      num5 = Mathf.Max(0.0f, num5 - num11);
      num3 = (float) num10;
    }
    if (this.rectTransform.anchorMin == Vector2.zero && this.rectTransform.anchorMax == Vector2.one)
    {
      this.rectTransform.offsetMin = new Vector2(sizeDelta.x * num1, sizeDelta.y * num2);
      this.rectTransform.offsetMax = new Vector2(sizeDelta.x * -num5, sizeDelta.y * -num6);
    }
    else
    {
      this.rectTransform.sizeDelta = new Vector2(sizeDelta.x * num3, sizeDelta.y * num4);
      this.rectTransform.anchoredPosition = new Vector2(sizeDelta.x * num1, sizeDelta.y * num2);
    }
    this.waitForParent = false;
  }

  public override void UpdateSize() => this.waitForParent = true;
}
﻿// Decompiled with JetBrains decompiler
// Type: WorldSpaceCanvasScaler
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

using NaughtyAttributes;
using UnityEngine;

public class WorldSpaceCanvasScaler : WorldSpaceCanvasUpdater
{
  [SerializeField]
  public bool invert;
  [Header("Position")]
  [SerializeField]
  public bool scalePositionX;
  [SerializeField]
  [ShowIf("scalePositionX")]
  public float basePositionX;
  [SerializeField]
  public bool scalePositionY;
  [SerializeField]
  [ShowIf("scalePositionY")]
  public float basePositionY;
  [SerializeField]
  public bool scalePositionZ;
  [SerializeField]
  [ShowIf("scalePositionZ")]
  public float basePositionZ;
  [Header("Scale")]
  [SerializeField]
  public bool scaleX = true;
  [SerializeField]
  [ShowIf("scaleX")]
  public float baseScaleX = 1f;
  [SerializeField]
  public bool scaleY = true;
  [SerializeField]
  [ShowIf("scaleY")]
  public float baseScaleY = 1f;
  [SerializeField]
  public bool scaleZ;
  [SerializeField]
  [ShowIf("scaleZ")]
  public float baseScaleZ = 1f;

  public override void UpdateSize()
  {
    if (!WorldSpaceCanvasFitScreenSystem.exists)
      return;
    float num = 11.547f * WorldSpaceCanvasFitScreenSystem.instance.aspectRatio;
    float scale = (double) num < 17.320510864257813 ? num / 17.32051f : 1f;
    if (this.scalePositionX || this.scalePositionY || this.scalePositionZ)
      this.SetPosition(scale);
    if (!this.scaleX && !this.scaleY && !this.scaleZ)
      return;
    this.SetScale(scale);
  }

  public void SetPosition(float scale)
  {
    Vector3 anchoredPosition3D = this.rectTransform.anchoredPosition3D;
    if (this.scalePositionX)
      anchoredPosition3D.x = this.invert ? this.basePositionX / scale : this.basePositionX * scale;
    if (this.scalePositionY)
      anchoredPosition3D.y = this.invert ? this.basePositionY / scale : this.basePositionY * scale;
    if (this.scalePositionZ)
      anchoredPosition3D.z = this.invert ? this.basePositionZ / scale : this.basePositionZ * scale;
    this.rectTransform.anchoredPosition3D = anchoredPosition3D;
  }

  public void SetScale(float scale)
  {
    Vector3 localScale = this.rectTransform.localScale;
    if (this.scaleX)
      localScale.x = this.invert ? this.baseScaleX / scale : this.baseScaleX * scale;
    if (this.scaleY)
      localScale.y = this.invert ? this.baseScaleY / scale : this.baseScaleY * scale;
    if (this.scaleZ)
      localScale.z = this.invert ? this.baseScaleZ / scale : this.baseScaleZ * scale;
    this.rectTransform.localScale = localScale;
  }
}
﻿// Decompiled with JetBrains decompiler
// Type: WorldSpaceCanvasUpdater
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 47C9391B-2D31-46A1-B2AD-EF073E28C56A
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Wildfrost\Modded\Wildfrost_Data\Managed\Assembly-CSharp-Publicized.dll

public abstract class WorldSpaceCanvasUpdater : MonoBehaviourRect
{
  public void OnEnable()
  {
    WorldSpaceCanvasFitScreenSystem.Register(this);
    this.UpdateSize();
  }

  public void OnDisable() => WorldSpaceCanvasFitScreenSystem.Unregister(this);

  public virtual void UpdateSize()
  {
  }
}
