using System.Collections;
using System.Collections.Generic;
//using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using BetaJester.EnumGenerator;
//using Dead;
using DeadExtensions;
using Deadpan.Enums.Engine.Components.Modding;
//using FMOD;
using FMOD.Studio;
using FMODUnity;
using HarmonyLib;
using HarmonyLib.Tools;
using JetBrains.Annotations;
using MonoMod.Cil;
using NaughtyAttributes;
using Rewired;
using Rewired.Components;
using Rewired.Data.Mapping;
using Rewired.Internal;
using Rewired.Internal.Windows;
using Rewired.Platforms;
using Rewired.UI;
using Rewired.Utils;
using Rewired.Utils.Interfaces;
using Rewired.Utils.Libraries.TinyJson;
using Rewired.Utils.Platforms.Windows;
using Steamworks;
using Steamworks.Data;
using Steamworks.Ugc;
using TMPro;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.AddressableAssets;
using UnityEngine.AddressableAssets.ResourceLocators;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Localization;
using UnityEngine.Localization.Components;
using UnityEngine.Localization.Settings;
using UnityEngine.Localization.Tables;
using UnityEngine.Pool;
using UnityEngine.ResourceManagement.AsyncOperations;
using UnityEngine.SceneManagement;
using UnityEngine.Scripting;
using UnityEngine.Serialization;
using UnityEngine.UI;
using UnityEngine.Video;
using Object = UnityEngine.Object;
using System;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class BackButtonGamePadController : MonoBehaviour
{
    public static bool isGoingBack;

    public Button backButton;

    public EventTrigger eventTrigger;

    public UINavigationLayer uINavigationLayer;

    public UINavigationItem navigationItem;

    public UnityEvent OnBackButtonOverride;

    public const float backClearTime = 0.1f;

    public Coroutine GoingBackClear;

    public bool navItemEnabled;

    public bool press;

    public void Update()
    {
        if (navItemEnabled)
        {
            if (!CheckNavigationItem())
            {
                navItemEnabled = false;
            }
            else if (isGoingBack)
            {
                GoingBackClear ??= StartCoroutine(RunGoBackClear());
                if (press)
                {
                    press = false;
                    Release();
                }
            }
            else if (MonoBehaviourSingleton<UINavigationSystem>.instance.lastActiveNavigationLayer == uINavigationLayer && !MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
            {
                if (press)
                {
                    if (!InputSystem.Enabled || InputSystem.reset)
                    {
                        press = false;
                        Release();
                    }
                    if (!InputSystem.IsButtonHeld("Back"))
                    {
                        Release();
                    }
                }
                else if (InputSystem.IsButtonPressed("Back"))
                {
                    Press();
                }
            }
            else if (press)
            {
                press = false;
                Release();
            }
        }
        else if (CheckNavigationItem())
        {
            navItemEnabled = true;
        }
    }

    public void Press()
    {
        press = true;
        if ((eventTrigger) && ((Behaviour)eventTrigger).enabled)
        {
            eventTrigger.OnPointerDown((PointerEventData)null);
        }
    }

    public void Release()
    {
        if (press)
        {
            Invoke();
        }
        if ((eventTrigger))
        {
            if (press && ((Behaviour)eventTrigger).enabled)
            {
                eventTrigger.OnPointerClick((PointerEventData)null);
            }
            eventTrigger.OnPointerUp((PointerEventData)null);
        }
        press = false;
    }

    public void Invoke()
    {
        isGoingBack = true;
        if (OnBackButtonOverride != null && ((UnityEventBase)OnBackButtonOverride).GetPersistentEventCount() > 0)
        {
            OnBackButtonOverride.Invoke();
        }
        else
        {
            ((UnityEvent)backButton.onClick).Invoke();
        }
    }

    public IEnumerator RunGoBackClear()
    {
        yield return (object)new WaitForSecondsRealtime(0.1f);
        isGoingBack = false;
        GoingBackClear = null;
    }

    public void Start()
    {
        CheckForNavigationLayer(transform);
    }

    public void CheckForNavigationLayer(Transform checkTransform)
    {
        UINavigationLayer component = ((Component)checkTransform).GetComponent<UINavigationLayer>();
        if (component != null && component.isOverrideLayer)
        {
            uINavigationLayer = component;
        }
        if (uINavigationLayer == null && ((Component)checkTransform).transform.parent != null)
        {
            CheckForNavigationLayer(((Component)checkTransform).transform.parent);
        }
    }

    public bool CheckNavigationItem()
    {
        if ((navigationItem))
        {
            return MonoBehaviourSingleton<UINavigationSystem>.instance.AvailableNavigationItems.Contains(navigationItem);
        }
        return true;
    }
}
public class CardUINavigationItem : UINavigationItem
{
    public CardHover cardHover;

    public Entity entity;

    public void Update()
    {
        isSelectable = !entity.flipper.flipped;
    }
}
public class CustomEventSystem : MonoBehaviour
{
    [SerializeField]
    public GameObject current;

    [SerializeField]
    public GameObject press;

    public readonly PointerEventData buttonData = new PointerEventData((EventSystem)null);

    public void Update()
    {
        if (!(press))
        {
            if (InputSystem.IsSelectPressed() && (current))
            {
                Press(current);
            }
        }
        else if (!InputSystem.IsSelectHeld())
        {
            Release(press);
        }
    }

    public void Hover(GameObject obj)
    {
        current = obj;
        ExecuteEvents.ExecuteHierarchy<IPointerEnterHandler>(obj, (BaseEventData)(object)buttonData, ExecuteEvents.pointerEnterHandler);
    }

    public void Unhover(GameObject obj)
    {
        if ((current) && ((object)current).Equals((object?)obj))
        {
            current = null;
        }
        ExecuteEvents.ExecuteHierarchy<IPointerExitHandler>(obj, (BaseEventData)(object)buttonData, ExecuteEvents.pointerExitHandler);
    }

    public void Press(GameObject obj)
    {
        press = obj;
        ExecuteEvents.ExecuteHierarchy<IPointerDownHandler>(obj, (BaseEventData)(object)buttonData, ExecuteEvents.pointerDownHandler);
    }

    public void Release(GameObject obj)
    {
        ExecuteEvents.ExecuteHierarchy<IPointerUpHandler>(obj, (BaseEventData)(object)buttonData, ExecuteEvents.pointerUpHandler);
        if ((obj) && (current) && ((object)obj).Equals((object?)current))
        {
            ExecuteEvents.ExecuteHierarchy<IPointerClickHandler>(obj, (BaseEventData)(object)buttonData, ExecuteEvents.pointerClickHandler);
        }
        press = null;
    }
}
public class CustomInputModule : StandaloneInputModule
{
    public static readonly List<GameObject> unhoverCache = new List<GameObject>();

    public static readonly Vector2 offscreen = new Vector2(-1000f, -1000f);

    public override void OnEnable()
    {
        ((BaseInputModule)this).OnEnable();
        Events.OnCardControllerEnabled += CardControllerEnabled;
    }

    public override void OnDisable()
    {
        ((BaseInputModule)this).OnDisable();
        Events.OnCardControllerEnabled -= CardControllerEnabled;
    }

    public void CardControllerEnabled(CardController controller)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        ForceSetMousePosition(offscreen);
    }

    public void ForceSetMousePosition(Vector2 position)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_008c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0091: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ab: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b0: Unknown result type (might be due to invalid IL or missing references)
        MouseState mousePointerEventDataWithPosition = GetMousePointerEventDataWithPosition(position);
        MouseButtonEventData eventData = mousePointerEventDataWithPosition.GetButtonState((InputButton)0).eventData;
        ((StandaloneInputModule)this).ProcessMousePress(eventData);
        ((PointerInputModule)this).ProcessMove(eventData.buttonData);
        ((PointerInputModule)this).ProcessDrag(eventData.buttonData);
        ((StandaloneInputModule)this).ProcessMousePress(mousePointerEventDataWithPosition.GetButtonState((InputButton)1).eventData);
        ((PointerInputModule)this).ProcessDrag(mousePointerEventDataWithPosition.GetButtonState((InputButton)1).eventData.buttonData);
        ((StandaloneInputModule)this).ProcessMousePress(mousePointerEventDataWithPosition.GetButtonState((InputButton)2).eventData);
        ((PointerInputModule)this).ProcessDrag(mousePointerEventDataWithPosition.GetButtonState((InputButton)2).eventData.buttonData);
        Vector2 scrollDelta = eventData.buttonData.scrollDelta;
        if (!Mathf.Approximately(((scrollDelta)).sqrMagnitude, 0f))
        {
            RaycastResult pointerCurrentRaycast = eventData.buttonData.pointerCurrentRaycast;
            ExecuteEvents.ExecuteHierarchy<IScrollHandler>(ExecuteEvents.GetEventHandler<IScrollHandler>(((pointerCurrentRaycast)).gameObject), (BaseEventData)(object)eventData.buttonData, ExecuteEvents.scrollHandler);
        }
    }

    public MouseState GetMousePointerEventDataWithPosition(Vector2 forcePosition)
    {
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Invalid comparison between Unknown and I4
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_008c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0091: Unknown result type (might be due to invalid IL or missing references)
        //IL_0093: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00eb: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ef: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fa: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fe: Unknown result type (might be due to invalid IL or missing references)
        //IL_0109: Unknown result type (might be due to invalid IL or missing references)
        //IL_010d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0119: Expected O, but got Unknown
        PointerEventData val = default(PointerEventData);
        bool pointerData = ((PointerInputModule)this).GetPointerData(-1, ref val, true);
        ((AbstractEventData)val).Reset();
        if (pointerData)
        {
            val.position = forcePosition;
        }
        if ((int)Cursor.lockState == 1)
        {
            val.position = new Vector2(-1f, -1f);
            val.delta = Vector2.zero;
        }
        else
        {
            val.delta = forcePosition - val.position;
            val.position = forcePosition;
        }
        val.scrollDelta = ((BaseInputModule)this).input.mouseScrollDelta;
        val.button = (InputButton)0;
        ((BaseInputModule)this).eventSystem.RaycastAll(val, ((BaseInputModule)this).m_RaycastResultCache);
        RaycastResult pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(((BaseInputModule)this).m_RaycastResultCache);
        val.pointerCurrentRaycast = pointerCurrentRaycast;
        ((BaseInputModule)this).m_RaycastResultCache.Clear();
        PointerEventData val2 = default(PointerEventData);
        ((PointerInputModule)this).GetPointerData(-2, ref val2, true);
        ((AbstractEventData)val2).Reset();
        ((PointerInputModule)this).CopyFromTo(val, val2);
        val2.button = (InputButton)1;
        PointerEventData val3 = default(PointerEventData);
        ((PointerInputModule)this).GetPointerData(-3, ref val3, true);
        ((AbstractEventData)val3).Reset();
        ((PointerInputModule)this).CopyFromTo(val, val3);
        val3.button = (InputButton)2;
        MouseState val4 = new MouseState();
        val4.SetButtonState((InputButton)0, ((PointerInputModule)this).StateForMouseButton(0), val);
        val4.SetButtonState((InputButton)1, ((PointerInputModule)this).StateForMouseButton(1), val2);
        val4.SetButtonState((InputButton)2, ((PointerInputModule)this).StateForMouseButton(2), val3);
        return val4;
    }

    public override void ProcessMove(PointerEventData pointerEvent)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Invalid comparison between Unknown and I4
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        object obj;
        if ((int)Cursor.lockState != 1)
        {
            RaycastResult pointerCurrentRaycast = pointerEvent.pointerCurrentRaycast;
            obj = ((pointerCurrentRaycast)).gameObject;
        }
        else
        {
            obj = null;
        }
        GameObject newEnterTarget = (GameObject)obj;
        CustomHandlePointerExitAndEnter(pointerEvent, newEnterTarget);
    }

    public static void CustomHandlePointerExitAndEnter(PointerEventData currentPointerData, GameObject newEnterTarget)
    {
        if (newEnterTarget == null || currentPointerData.pointerEnter == null)
        {
            int count = currentPointerData.hovered.Count;
            for (int i = 0; i < count; i++)
            {
                GameObject val = currentPointerData.hovered[i];
                ExecuteEvents.Execute<IPointerExitHandler>(val, (BaseEventData)(object)currentPointerData, ExecuteEvents.pointerExitHandler);
                unhoverCache.Add(val);
            }
            currentPointerData.hovered.Clear();
            if (newEnterTarget == null)
            {
                currentPointerData.pointerEnter = null;
                return;
            }
        }
        if (currentPointerData.pointerEnter == newEnterTarget && (newEnterTarget))
        {
            return;
        }
        GameObject val2 = BaseInputModule.FindCommonRoot(currentPointerData.pointerEnter, newEnterTarget);
        if (currentPointerData.pointerEnter != null)
        {
            Transform val3 = currentPointerData.pointerEnter.transform;
            while (val3 != null && (!(val2 != null) || !(val2.transform == val3)))
            {
                ExecuteEvents.Execute<IPointerExitHandler>(((Component)val3).gameObject, (BaseEventData)(object)currentPointerData, ExecuteEvents.pointerExitHandler);
                currentPointerData.hovered.Remove(((Component)val3).gameObject);
                unhoverCache.Add(((Component)val3).gameObject);
                val3 = val3.parent;
            }
        }
        currentPointerData.pointerEnter = newEnterTarget;
        if (newEnterTarget != null)
        {
            Transform val4 = newEnterTarget.transform;
            while (val4 != null && ((Component)val4).gameObject != val2)
            {
                ExecuteEvents.Execute<IPointerEnterHandler>(((Component)val4).gameObject, (BaseEventData)(object)currentPointerData, ExecuteEvents.pointerEnterHandler);
                currentPointerData.hovered.Add(((Component)val4).gameObject);
                val4 = val4.parent;
            }
        }
        foreach (GameObject item in unhoverCache)
        {
            if ((item))
            {
                item.GetComponent<IPointerAfterExitHandler>()?.OnPointerAfterExit(currentPointerData);
            }
        }
        unhoverCache.Clear();
    }
}
public class EnumContainerExample : MonoBehaviour, IEnumContainer
{
    public List<ObjectInfo> objectInfos = new List<ObjectInfo>();

    public EnumInfo[] GetEnums()
    {
        return new EnumInfo[1]
        {
            new EnumInfo
            {
                _name = "ObjectType",
                _values = objectInfos.Select((ObjectInfo x) => x.objectName).ToArray()
            }
        };
    }
}
[Serializable]
public class ObjectInfo
{
    public string objectName;

    public float objectValue;
}
public class BaseInputSwitcher : MonoBehaviour
{
    public bool canSwitchTo = true;

    public virtual bool CheckSwitchTo()
    {
        return false;
    }

    public virtual void SwitchTo()
    {
    }
}
public class ControllerInputSwitcher : BaseInputSwitcher
{
    public override bool CheckSwitchTo()
    {
        if (!canSwitchTo || Console.active)
        {
            return false;
        }
        if (!(Mathf.Abs(InputSystem.GetAxisDelta("Move Vertical")) > 0f))
        {
            return Mathf.Abs(InputSystem.GetAxisDelta("Move Horizontal")) > 0f;
        }
        return true;
    }

    public override void SwitchTo()
    {
        gameObject.SetActive(true);
        MonoBehaviourSingleton<Cursor3d>.instance.usingMouse = false;
        MonoBehaviourSingleton<Cursor3d>.instance.usingTouch = false;
        VirtualPointer.Show();
        CustomCursor.UpdateState();
        UINavigationDefaultSystem.SetStartingItem();
        ControllerButtonSystem.SetControllerStyle();
        ((Controller)InputSystem.mainPlayer.controllers.Mouse).enabled = false;
        RewiredControllerManager.instance.AssignNextPlayer(InputSystem.mainPlayer.id);
        InputSystem.AllowDynamicSelectRelease = true;
    }
}
public class InputSwitcher : MonoBehaviour
{
    public static int justSwitchedCount = 3;

    public const int maxJustSwitchedCount = 3;

    public static bool justSwitched;

    public int currentIndex = -1;

    [SerializeField]
    public BaseInputSwitcher startingInput;

    [SerializeReference]
    public BaseInputSwitcher[] switchers;

    public void Awake()
    {
        BaseInputSwitcher[] array = switchers;
        for (int i = 0; i < array.Length; i++)
        {
            ((Component)array[i]).gameObject.SetActive(false);
        }
    }

    public void Start()
    {
        int num = switchers.Length;
        for (int i = 0; i < num; i++)
        {
            if (switchers[i] == startingInput)
            {
                SwitchTo(i);
                break;
            }
        }
    }

    public void Update()
    {
        int num = switchers.Length;
        for (int i = 0; i < num; i++)
        {
            if (switchers[i].CheckSwitchTo())
            {
                if (i != currentIndex)
                {
                    SwitchTo(i);
                }
                break;
            }
        }
        if (justSwitched && --justSwitchedCount <= 0)
        {
            justSwitched = false;
        }
    }

    public void SwitchTo(int profileIndex)
    {
        if (currentIndex >= 0)
        {
            ((Component)switchers[currentIndex]).gameObject.SetActive(false);
        }
        switchers[profileIndex].SwitchTo();
        currentIndex = profileIndex;
        justSwitched = true;
        justSwitchedCount = 3;
    }
}
public class MouseInputSwitcher : BaseInputSwitcher
{
    public override bool CheckSwitchTo()
    {
        if (canSwitchTo)
        {
            return Input.GetMouseButtonDown(0);
        }
        return false;
    }

    public override void SwitchTo()
    {
        gameObject.SetActive(true);
        MonoBehaviourSingleton<Cursor3d>.instance.usingMouse = true;
        MonoBehaviourSingleton<Cursor3d>.instance.usingTouch = false;
        VirtualPointer.Hide();
        CustomCursor.UpdateState();
        MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(null);
        ControllerButtonSystem.SetMouseStyle();
        ((Controller)InputSystem.mainPlayer.controllers.Mouse).enabled = true;
        InputSystem.AllowDynamicSelectRelease = true;
    }
}
public class TouchInputSwitcher : BaseInputSwitcher
{
    public override bool CheckSwitchTo()
    {
        if (canSwitchTo)
        {
            return Input.touchCount > 0;
        }
        return false;
    }

    public override void SwitchTo()
    {
        gameObject.SetActive(true);
        MonoBehaviourSingleton<Cursor3d>.instance.usingMouse = true;
        MonoBehaviourSingleton<Cursor3d>.instance.usingTouch = true;
        VirtualPointer.Hide();
        CustomCursor.UpdateState();
        MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(null);
        ControllerButtonSystem.SetTouchStyle();
        ((Controller)InputSystem.mainPlayer.controllers.Mouse).enabled = true;
        InputSystem.AllowDynamicSelectRelease = false;
    }
}
[RequireComponent(typeof(ScrollRect))]
public class JoystickScroller : MonoBehaviour
{
    [SerializeField]
    public string scrollAction = "Scroll Vertical";

    public ScrollRect _scrollRect;

    public readonly Vector2 add = new Vector2(0f, -20f);

    public ScrollRect scrollRect => _scrollRect ?? (_scrollRect = GetComponent<ScrollRect>());

    public void LateUpdate()
    {
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        //IL_008a: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        if (!((Behaviour)scrollRect).enabled)
        {
            return;
        }
        float axis = InputSystem.GetAxis(scrollAction);
        if (Mathf.Abs(axis) > float.Epsilon && (scrollRect.content))
        {
            float verticalNormalizedPosition = scrollRect.verticalNormalizedPosition;
            if ((axis > 0f && verticalNormalizedPosition < 1f) || (axis < 0f && verticalNormalizedPosition > 0f))
            {
                RectTransform content = scrollRect.content;
                content.anchoredPosition += add * (axis * Mathf.Abs(axis) * Time.unscaledDeltaTime);
            }
        }
    }
}
public interface INavigationState
{
    void Begin();

    void End();
}
public static class NavigationState
{
    public static readonly Stack<INavigationState> stateHistory = new Stack<INavigationState>();

    public static INavigationState PeekCurrentState()
    {
        if (stateHistory.Count <= 0)
        {
            return null;
        }
        return stateHistory.Peek();
    }

    public static INavigationState PopCurrentState()
    {
        if (stateHistory.Count <= 0)
        {
            return null;
        }
        return stateHistory.Pop();
    }

    public static void Start(INavigationState state)
    {
        INavigationState navigationState = PeekCurrentState();
        if (navigationState != state)
        {
            navigationState?.End();
            if (state != null)
            {
                state.Begin();
                stateHistory.Push(state);
            }
        }
    }

    public static void BackToPreviousState()
    {
        if (stateHistory.Count > 0)
        {
            PopCurrentState()?.End();
            PeekCurrentState()?.Begin();
        }
    }

    public static void Reset()
    {
        stateHistory.Clear();
        Start(new NavigationStateIdle());
    }
}
public class NavigationStateAssignUpgrade : INavigationState
{
    public readonly List<UINavigationItem> disabled = new List<UINavigationItem>();

    public readonly List<Entity> eligibleCards;

    public NavigationStateAssignUpgrade(List<Entity> eligibleCards)
    {
        this.eligibleCards = eligibleCards;
    }

    public void Begin()
    {
        UpgradeDisplay[] array = Object.FindObjectsOfType<UpgradeDisplay>();
        foreach (UpgradeDisplay upgradeDisplay in array)
        {
            Disable(upgradeDisplay.navigationItem);
        }
        DeckDisplay deckDisplay = Object.FindObjectOfType<DeckDisplay>();
        if (deckDisplay != null)
        {
            Disable(deckDisplay.backButtonNavigationItem);
        }
        Dictionary<UINavigationItem, UINavigationItem.SelectionPriority> dictionary = new Dictionary<UINavigationItem, UINavigationItem.SelectionPriority>();
        foreach (UINavigationItem item in eligibleCards.Select((Entity a) => a.uINavigationItem))
        {
            dictionary[item] = item.selectionPriority;
            item.selectionPriority = UINavigationItem.SelectionPriority.Mega;
        }
        UINavigationDefaultSystem.SetStartingItem(useClosest: false);
        foreach (KeyValuePair<UINavigationItem, UINavigationItem.SelectionPriority> item2 in dictionary)
        {
            item2.Key.selectionPriority = item2.Value;
        }
    }

    public void End()
    {
        foreach (UINavigationItem item in disabled.Where((UINavigationItem a) => a != null))
        {
            ((Behaviour)item).enabled = true;
        }
        disabled.Clear();
    }

    public void Disable(UINavigationItem item)
    {
        if (!(item == null))
        {
            ((Behaviour)item).enabled = false;
            disabled.Add(item);
        }
    }
}
public class NavigationStateBattle : INavigationState
{
    public readonly List<UINavigationItem> disabled = new List<UINavigationItem>();

    public void Begin()
    {
        foreach (CardSlotLane allRow in References.Battle.allRows)
        {
            Disable(allRow.nav);
            foreach (CardSlot slot in allRow.slots)
            {
                Disable(slot.nav);
            }
        }
        if (References.Battle.playerCardController is CardControllerBattle cardControllerBattle)
        {
            Disable(cardControllerBattle.useOnHandAnchor);
        }
    }

    public void End()
    {
        foreach (UINavigationItem item in disabled.Where((UINavigationItem a) => (a)))
        {
            ((Behaviour)item).enabled = true;
        }
        disabled.Clear();
    }

    public void Disable(UINavigationItem item)
    {
        if ((item))
        {
            ((Behaviour)item).enabled = false;
            disabled.Add(item);
        }
    }
}
public class NavigationStateCard : INavigationState
{
    public readonly List<UINavigationItem> disabled = new List<UINavigationItem>();

    public readonly Entity entity;

    public NavigationStateCard(Entity entity)
    {
        this.entity = entity;
    }

    public void Begin()
    {
        List<CardContainer> list = new List<CardContainer>();
        foreach (CardContainer item in from c in Object.FindObjectsOfType<CardContainer>()
                                       where (c.nav) && ((Behaviour)c.nav).enabled
                                       select c)
        {
            if (entity.CanPlayOn(item))
            {
                list.Add(item);
            }
            else
            {
                Disable(item.nav);
            }
        }
        foreach (Entity card in References.Battle.cards)
        {
            if ((card.uINavigationItem) && ((Behaviour)card.uINavigationItem).enabled && (entity.data.playType != Card.PlayType.Play || !entity.CanPlayOn(card)))
            {
                Disable(card.uINavigationItem);
            }
        }
        Disable(RedrawBellSystem.nav);
        Disable(WaveDeploySystem.nav);
        if (References.Battle.playerCardController is CardControllerBattle { useOnHandAnchor: { } useOnHandAnchor } && entity.NeedsTarget)
        {
            Disable(useOnHandAnchor);
        }
        Dictionary<UINavigationItem, UINavigationItem.SelectionPriority> dictionary = new Dictionary<UINavigationItem, UINavigationItem.SelectionPriority>();
        foreach (CardContainer item2 in list)
        {
            if (item2 is CardSlot && item2.Empty)
            {
                UINavigationItem nav = item2.nav;
                if (nav != null && ((Behaviour)nav).enabled)
                {
                    dictionary[nav] = nav.selectionPriority;
                    nav.selectionPriority = UINavigationItem.SelectionPriority.Mega;
                }
            }
        }
        UINavigationDefaultSystem.SetDefaultTarget(entity);
        foreach (KeyValuePair<UINavigationItem, UINavigationItem.SelectionPriority> item3 in dictionary)
        {
            item3.Key.selectionPriority = item3.Value;
        }
    }

    public void End()
    {
        foreach (UINavigationItem item in disabled.Where((UINavigationItem a) => (a)))
        {
            ((Behaviour)item).enabled = true;
        }
        disabled.Clear();
    }

    public void Disable(UINavigationItem item)
    {
        if ((item))
        {
            ((Behaviour)item).enabled = false;
            disabled.Add(item);
        }
    }
}
public class NavigationStateIdle : INavigationState
{
    public void Begin()
    {
    }

    public void End()
    {
    }
}
public class NavigationStateMuncher : INavigationState
{
    public readonly List<UINavigationItem> disabled = new List<UINavigationItem>();

    public readonly EventRoutineMuncher muncher;

    public NavigationStateMuncher(EventRoutineMuncher muncher)
    {
        this.muncher = muncher;
    }

    public void Begin()
    {
        Button backButton = muncher.backButton;
        if (backButton != null)
        {
            Disable(((Component)backButton).GetComponent<UINavigationItem>());
        }
        foreach (Entity item in muncher.cardContainer)
        {
            Disable(item.uINavigationItem);
        }
        UINavigationDefaultSystem.SetStartingItem();
    }

    public void End()
    {
        foreach (UINavigationItem item in disabled.Where((UINavigationItem a) => a != null))
        {
            ((Behaviour)item).enabled = true;
        }
        disabled.Clear();
    }

    public void Disable(UINavigationItem item)
    {
        if (!(item == null))
        {
            ((Behaviour)item).enabled = false;
            disabled.Add(item);
        }
    }
}
public class NavigationStateWait : INavigationState
{
    public readonly bool disableInput;

    public NavigationStateWait(bool disableInput = false)
    {
        this.disableInput = disableInput;
    }

    public void Begin()
    {
        VirtualPointer.Hide();
        if (disableInput)
        {
            InputSystem.Disable();
        }
    }

    public void End()
    {
        VirtualPointer.Show();
        if (disableInput)
        {
            InputSystem.Enable();
        }
    }
}
public class ObjectTrackerUIScript : MonoBehaviour
{
    public RectTransform parentCanvas;

    public GameObject objToTrack;

    public Vector3 localOffset;

    public Vector3 targetPos;

    public virtual void Update()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        targetPos = Vector2Ext.WithZ(RectTransformUtility.WorldToScreenPoint(Camera.main, objToTrack.transform.position), 0f);
        ((Transform)GetComponent<RectTransform>()).position = localOffset + targetPos;
    }
}
public class RewiredControllerManager : MonoBehaviour
{
    public class PlayerMap
    {
        public int rewiredPlayerId;

        public int gamePlayerId;

        public PlayerMap(int rewiredPlayerId, int gamePlayerId)
        {
            this.rewiredPlayerId = rewiredPlayerId;
            this.gamePlayerId = gamePlayerId;
        }
    }

    public static RewiredControllerManager instance;

    public int maxPlayers = 4;

    public static readonly List<PlayerMap> playerMaps = new List<PlayerMap>();

    public static int gamePlayerIdCounter = 0;

    public static Player leadPlayer;

    public const int maxJoysticksPerPlayer = 1;

    public void Awake()
    {
        if ((instance) && instance != this)
        {
            Object.Destroy(this);
            return;
        }
        instance = this;
        AssignNextPlayer(0);
    }

    public void OnEnable()
    {
        ReInput.ControllerConnectedEvent += ControllerConnected;
        ReInput.ControllerDisconnectedEvent += ControllerDisconnected;
    }

    public void OnDisable()
    {
        ReInput.ControllerConnectedEvent -= ControllerConnected;
        ReInput.ControllerDisconnectedEvent -= ControllerDisconnected;
    }

    public static void ControllerConnected(ControllerStatusChangedEventArgs args)
    {
        Player playerController = GetPlayerController(0);
        bool flag = false;
        for (int num = playerController.controllers.joystickCount + 1; num > 1; num--)
        {
            playerController.controllers.RemoveController((Controller)(object)playerController.controllers.Joysticks[0]);
            flag = true;
        }
        if (!playerController.controllers.ContainsController(args.controller))
        {
            playerController.controllers.AddController(args.controller, true);
            flag = true;
        }
        if (flag)
        {
            Debug.LogWarning(("Rewired: [" + playerController.name + "] controllers → " + string.Join(", ", playerController.controllers.Controllers.Select((Controller a) => a.name))));
            Events.InvokeControllerSwitched();
        }
    }

    public static void ControllerDisconnected(ControllerStatusChangedEventArgs args)
    {
        Player playerController = GetPlayerController(0);
        bool flag = false;
        if (playerController.controllers.ContainsController(args.controller))
        {
            playerController.controllers.RemoveController(args.controller);
            flag = true;
        }
        int num = playerController.controllers.joystickCount - 1;
        if (num < 1)
        {
            foreach (Joystick joystick in ReInput.controllers.Joysticks)
            {
                if (!playerController.controllers.ContainsController((Controller)(object)joystick))
                {
                    playerController.controllers.AddController((Controller)(object)joystick, true);
                    flag = true;
                    if (++num >= 1)
                    {
                        break;
                    }
                }
            }
        }
        if (flag)
        {
            Debug.LogWarning(("Rewired: [" + playerController.name + "] controllers → " + string.Join(", ", playerController.controllers.Controllers.Select((Controller a) => a.name))));
            Events.InvokeControllerSwitched();
        }
    }

    public Player AssignNextPlayer(int rewiredPlayerId)
    {
        PlayerMap playerMap = playerMaps.FirstOrDefault((PlayerMap a) => a.rewiredPlayerId == rewiredPlayerId);
        if (playerMap != null)
        {
            return ReInput.players.GetPlayer(playerMap.rewiredPlayerId);
        }
        Debug.Log($"ControllerManager → Assigning Player {rewiredPlayerId}");
        if (playerMaps.Count >= maxPlayers)
        {
            Debug.LogError("Max player limit already reached!");
            return null;
        }
        int nextGamePlayerId = GetNextGamePlayerId();
        playerMaps.Add(new PlayerMap(rewiredPlayerId, nextGamePlayerId));
        Player player = ReInput.players.GetPlayer(rewiredPlayerId);
        Debug.Log($"Assigning Rewired Player id {rewiredPlayerId} to Game Player {nextGamePlayerId}");
        if (leadPlayer == null)
        {
            Debug.Log($"Player {rewiredPlayerId} set as lead player");
            leadPlayer = player;
        }
        if (player.controllers.joystickCount < 1)
        {
            foreach (Joystick joystick in ReInput.controllers.Joysticks)
            {
                if (!player.controllers.Joysticks.Contains(joystick))
                {
                    player.controllers.AddController((Controller)(object)joystick, true);
                    if (player.controllers.joystickCount >= 1)
                    {
                        break;
                    }
                }
            }
        }
        Debug.LogWarning(("Rewired: [" + player.name + "] controllers → " + string.Join(", ", player.controllers.Controllers.Select((Controller a) => a.name))));
        return player;
    }

    public void AssignJoystickMap(Player rewiredPlayer, string newMap)
    {
        rewiredPlayer.controllers.maps.SetAllMapsEnabled(false);
        rewiredPlayer.controllers.maps.SetMapsEnabled(true, newMap);
    }

    public void AssignJoystickMap(int playerNumber, string newMap)
    {
        AssignJoystickMap(GetPlayerController(playerNumber), newMap);
    }

    public int GetNextGamePlayerId()
    {
        return gamePlayerIdCounter++;
    }

    public List<PlayerMap> GetActiveDevices()
    {
        return playerMaps;
    }

    public IList<Player> GetPlayers()
    {
        return ReInput.players.GetPlayers(false);
    }

    public static Player GetPlayerController(int gamePlayerId)
    {
        if (!ReInput.isReady)
        {
            return null;
        }
        if (!(instance))
        {
            Debug.LogError("Not initialized. Do you have a PressStartToJoinPlayerSelector in your scene?");
            return null;
        }
        PlayerMap playerMap = playerMaps.FirstOrDefault((PlayerMap a) => a.gamePlayerId == gamePlayerId);
        if (playerMap == null)
        {
            return instance.AssignNextPlayer(gamePlayerId);
        }
        return ReInput.players.GetPlayer(playerMap.rewiredPlayerId);
    }

    public static int GetPlayerID(int rewiredControllerID)
    {
        if (!ReInput.isReady)
        {
            return -1;
        }
        if (instance == null)
        {
            Debug.LogError("Not initialized. Do you have a PressStartToJoinPlayerSelector in your scehe?");
            return -1;
        }
        foreach (PlayerMap playerMap in playerMaps)
        {
            if (playerMap.rewiredPlayerId == rewiredControllerID)
            {
                return playerMap.gamePlayerId;
            }
        }
        return -1;
    }

    public void ClearAssignedControllers()
    {
        foreach (PlayerMap playerMap in playerMaps)
        {
            playerMap.gamePlayerId = -1;
        }
    }

    public bool IsPlayerControllerConnected(int playerIndex)
    {
        if (playerMaps.Count((PlayerMap x) => x.gamePlayerId == playerIndex) <= 0)
        {
            return false;
        }
        return true;
    }

    public bool IsControllerConnected(int controllerIndex)
    {
        if (ReInput.players.Players.Count((Player x) => x.id == controllerIndex) <= 0)
        {
            return false;
        }
        return true;
    }

    public void AssignControllerToPlayer(int i, int controllerIndex)
    {
        playerMaps.First((PlayerMap x) => x.rewiredPlayerId == controllerIndex).gamePlayerId = i;
    }

    public bool AnyControllerConnected()
    {
        if (playerMaps.Count <= 0)
        {
            return false;
        }
        return true;
    }

    public bool IsButtonPressed(string input = "", bool IsPositive = true)
    {
        if (!enabled)
        {
            return false;
        }
        int callingPlayer = -1;
        return IsButtonPressed(out _, input, IsPositive);
    }

    public bool IsButtonPressed(out int callingPlayer, string input = "", bool IsPositive = true)
    {
        bool state = false;
        callingPlayer = -1;
        if (IsPositive)
        {
            foreach (Player player in ReInput.players.GetPlayers(false))
            {
                if ((input == "") ? player.GetAnyButtonDown() : player.GetButtonDown(input))
                {
                    instance.ReturnTrueWithPlayer(out _, out state, player);
                    break;
                }
            }
        }
        else
        {
            foreach (Player player2 in ReInput.players.GetPlayers(false))
            {
                if ((input == "") ? player2.GetAnyNegativeButtonDown() : player2.GetNegativeButtonDown(input))
                {
                    instance.ReturnTrueWithPlayer(out _, out state, player2);
                    break;
                }
            }
        }
        return state;
    }

    public bool IsButtonHeld(string input = "", bool IsPositive = true)
    {
        if (!enabled)
        {
            return false;
        }
        int callingPlayer = -1;
        return IsButtonHeld(out _, input, IsPositive);
    }

    public bool IsButtonHeld(out int callingPlayer, string input = "", bool IsPositive = true)
    {
        bool state = false;
        callingPlayer = -1;
        if (IsPositive)
        {
            foreach (Player player in ReInput.players.GetPlayers(false))
            {
                bool num;
                if (!(input == ""))
                {
                    num = player.GetButton(input);
                }
                else
                {
                    if (player.GetAnyButton())
                    {
                        goto IL_004b;
                    }
                    num = player.GetAnyNegativeButton();
                }
                if (!num)
                {
                    continue;
                }
                goto IL_004b;
            IL_004b:
                ReturnTrueWithPlayer(out _, out state, player);
                break;
            }
        }
        else
        {
            foreach (Player player2 in ReInput.players.GetPlayers(false))
            {
                bool num2;
                if (!(input == ""))
                {
                    num2 = player2.GetNegativeButton(input);
                }
                else
                {
                    if (player2.GetAnyButton())
                    {
                        goto IL_00ae;
                    }
                    num2 = player2.GetAnyNegativeButton();
                }
                if (!num2)
                {
                    continue;
                }
                goto IL_00ae;
            IL_00ae:
                ReturnTrueWithPlayer(out _, out state, player2);
                break;
            }
        }
        return state;
    }

    public bool IsButtonLongHeld(string input = "", bool IsPositive = true)
    {
        if (!enabled)
        {
            return false;
        }
        int callingPlayer = -1;
        return IsButtonLongHeld(out _, input, IsPositive);
    }

    public bool IsButtonLongHeld(out int callingPlayer, string input = "", bool IsPositive = true)
    {
        bool state = false;
        callingPlayer = -1;
        if (IsPositive)
        {
            foreach (Player player in ReInput.players.GetPlayers(false))
            {
                if ((input == "") ? player.GetAnyButton() : player.GetButtonLongPress(input))
                {
                    ReturnTrueWithPlayer(out _, out state, player);
                    break;
                }
            }
        }
        else
        {
            foreach (Player player2 in ReInput.players.GetPlayers(false))
            {
                if ((input == "") ? player2.GetAnyNegativeButton() : player2.GetNegativeButtonLongPress(input))
                {
                    ReturnTrueWithPlayer(out _, out state, player2);
                    break;
                }
            }
        }
        return state;
    }

    public bool IsButtonReleased(string input = "", bool IsPositive = true)
    {
        if (!enabled)
        {
            return false;
        }
        int callingPlayer = -1;
        return IsButtonReleased(out _, input, IsPositive);
    }

    public bool IsButtonReleased(out int callingPlayer, string input = "", bool IsPositive = true)
    {
        bool state = false;
        callingPlayer = -1;
        if (IsPositive)
        {
            foreach (Player player in ReInput.players.GetPlayers(false))
            {
                if ((input == "") ? player.GetAnyButtonUp() : player.GetButtonUp(input))
                {
                    ReturnTrueWithPlayer(out _, out state, player);
                    break;
                }
            }
        }
        else
        {
            foreach (Player player2 in ReInput.players.GetPlayers(false))
            {
                if ((input == "") ? player2.GetAnyNegativeButtonUp() : player2.GetNegativeButtonUp(input))
                {
                    ReturnTrueWithPlayer(out _, out state, player2);
                    break;
                }
            }
        }
        return state;
    }

    public bool WasButtonReleased(string input = "", bool IsPositive = true)
    {
        int callingPlayer = -1;
        return WasButtonReleased(out _, input, IsPositive);
    }

    public bool WasButtonReleased(out int callingPlayer, string input = "", bool IsPositive = true)
    {
        bool state = false;
        callingPlayer = -1;
        if (IsPositive)
        {
            foreach (Player player in ReInput.players.GetPlayers(false))
            {
                if ((input == "") ? (!player.GetAnyButtonPrev()) : (!player.GetButtonPrev(input)))
                {
                    ReturnTrueWithPlayer(out _, out state, player);
                    break;
                }
            }
        }
        else
        {
            foreach (Player player2 in ReInput.players.GetPlayers(false))
            {
                if ((input == "") ? (!player2.GetAnyNegativeButtonPrev()) : (!player2.GetNegativeButtonPrev(input)))
                {
                    ReturnTrueWithPlayer(out _, out state, player2);
                    break;
                }
            }
        }
        return state;
    }

    public bool WasButtonPressed(string input = "", bool IsPositive = true)
    {
        int callingPlayer = -1;
        return WasButtonPressed(out _, input, IsPositive);
    }

    public bool WasButtonPressed(out int callingPlayer, string input = "", bool IsPositive = true)
    {
        bool state = false;
        callingPlayer = -1;
        if (IsPositive)
        {
            foreach (Player player in ReInput.players.GetPlayers(false))
            {
                if ((input == "") ? player.GetAnyButtonPrev() : player.GetButtonPrev(input))
                {
                    ReturnTrueWithPlayer(out _, out state, player);
                    break;
                }
            }
        }
        else
        {
            foreach (Player player2 in ReInput.players.GetPlayers(false))
            {
                if ((input == "") ? player2.GetAnyNegativeButtonPrev() : player2.GetNegativeButtonPrev(input))
                {
                    ReturnTrueWithPlayer(out _, out state, player2);
                    break;
                }
            }
        }
        return state;
    }

    public float GetAnalogPositive(string input = "")
    {
        if (!enabled)
        {
            return 0f;
        }
        int callingPlayer = -1;
        return GetAnalog(out _, input, lookingForPositive: true);
    }

    public float GetAnalogNegative(string input = "")
    {
        if (!enabled)
        {
            return 0f;
        }
        int callingPlayer = -1;
        return GetAnalog(out _, input, lookingForPositive: false);
    }

    public float GetAnalog(string input = "")
    {
        if (!enabled)
        {
            return 0f;
        }
        float num = 0f;
        foreach (Player player in ReInput.players.GetPlayers(false))
        {
            float axis = player.GetAxis(input);
            if (Mathf.Abs(axis) > Mathf.Abs(num))
            {
                num = axis;
            }
        }
        return num;
    }

    public float GetAnalog(out int callingPlayer, string input, bool lookingForPositive)
    {
        float num = 0f;
        callingPlayer = -1;
        foreach (Player x in ReInput.players.GetPlayers(false))
        {
            if (lookingForPositive)
            {
                if (!(x.GetAxis(input) > num))
                {
                    continue;
                }
                if (playerMaps.Count((PlayerMap y) => y.rewiredPlayerId == x.id) > 0)
                {
                    callingPlayer = playerMaps.First((PlayerMap y) => y.rewiredPlayerId == x.id).gamePlayerId;
                }
                else
                {
                    callingPlayer = -1;
                }
                num = x.GetAxis(input);
            }
            else
            {
                if (!(x.GetAxis(input) < num))
                {
                    continue;
                }
                if (playerMaps.Count((PlayerMap y) => y.rewiredPlayerId == x.id) > 0)
                {
                    callingPlayer = playerMaps.First((PlayerMap y) => y.rewiredPlayerId == x.id).gamePlayerId;
                }
                else
                {
                    callingPlayer = -1;
                }
                num = x.GetAxis(input);
            }
        }
        return num;
    }

    public void ReturnTrueWithPlayer(out int callingPlayer, out bool state, Player x)
    {
        if (playerMaps.Count((PlayerMap y) => y.rewiredPlayerId == x.id) > 0)
        {
            callingPlayer = playerMaps.First((PlayerMap y) => y.rewiredPlayerId == x.id).gamePlayerId;
        }
        else
        {
            callingPlayer = -1;
        }
        state = true;
    }

    public int GetDeviceCount()
    {
        return playerMaps.Count();
    }

    public void SetActiveControllersToMap(string newControllerMap)
    {
        foreach (PlayerMap activeDevice in instance.GetActiveDevices())
        {
            instance.AssignJoystickMap(activeDevice.gamePlayerId, newControllerMap);
        }
    }
}
public class RewiredHotKeyController : MonoBehaviour
{
    [SerializeField]
    public string HotKeyString;

    public UINavigationLayer uINavigationLayer;

    public Button uiButton;

    public EventTrigger eventTrigger;

    public UnityEvent OnHotKeyPressed;

    public bool ignoreLayers;

    public bool ignoreActivateCooldown;

    public HotKeyDisplay display;

    [Header("Keyboard")]
    [SerializeField]
    public bool hasKeyboardInput;

    [SerializeField]
    [ShowIf("hasKeyboardInput")]
    public KeyCode keyboardAction;

    public bool press;

    public static int ActivateCooldown;

    public static RewiredHotKeyController ActivateCooldownInstance;

    public bool IsHotKeyHeld()
    {
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            return InputSystem.IsButtonHeld(HotKeyString);
        }
        if (hasKeyboardInput)
        {
            return Input.GetKey(keyboardAction);
        }
        return false;
    }

    public bool IsHotKeyPressed()
    {
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            return InputSystem.IsButtonPressed(HotKeyString);
        }
        if (hasKeyboardInput)
        {
            return Input.GetKeyDown(keyboardAction);
        }
        return false;
    }

    public void SetActionName(string value)
    {
        HotKeyString = value;
        if ((display))
        {
            display.SetActionName(value);
        }
    }

    public void Update()
    {
        if (ActivateCooldown > 0 && ActivateCooldownInstance == this && --ActivateCooldown <= 0)
        {
            ActivateCooldownInstance = null;
        }
        if ((ignoreLayers || MonoBehaviourSingleton<UINavigationSystem>.instance.lastActiveNavigationLayer == uINavigationLayer) && (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse || hasKeyboardInput))
        {
            if (press)
            {
                if (!InputSystem.Enabled || InputSystem.reset)
                {
                    press = false;
                    Release();
                }
                else
                {
                    if (IsHotKeyHeld())
                    {
                        return;
                    }
                    if (ActivateCooldown > 0 && (ActivateCooldownInstance))
                    {
                        if (!ignoreActivateCooldown)
                        {
                            press = false;
                        }
                    }
                    else
                    {
                        ActivateCooldown = 5;
                        ActivateCooldownInstance = this;
                    }
                    Release();
                }
            }
            else if (IsHotKeyPressed())
            {
                Press();
            }
        }
        else if (press)
        {
            press = false;
            Release();
        }
    }

    public void OnDisable()
    {
        if (ActivateCooldown > 0 && ActivateCooldownInstance == this)
        {
            ActivateCooldown = 0;
            ActivateCooldownInstance = null;
        }
    }

    public void Press()
    {
        press = true;
        if ((eventTrigger) && ((Behaviour)eventTrigger).enabled)
        {
            eventTrigger.OnPointerDown((PointerEventData)null);
        }
    }

    public void Release()
    {
        if (press)
        {
            Invoke();
        }
        if ((eventTrigger))
        {
            if (press && ((Behaviour)eventTrigger).enabled)
            {
                eventTrigger.OnPointerClick((PointerEventData)null);
            }
            eventTrigger.OnPointerUp((PointerEventData)null);
        }
        press = false;
    }

    public void Invoke()
    {
        if (OnHotKeyPressed != null && ((UnityEventBase)OnHotKeyPressed).GetPersistentEventCount() > 0)
        {
            OnHotKeyPressed.Invoke();
        }
        else if ((uiButton) && ((Selectable)uiButton).interactable)
        {
            ButtonClickedEvent onClick = uiButton.onClick;
            if (onClick != null)
            {
                ((UnityEvent)onClick).Invoke();
            }
        }
    }
}
public class SliderUINavigationScript : MonoBehaviour
{
    public float valueMultiplier = 0.1f;

    public Slider slider;

    [SerializeField]
    public SliderSfx sfx;

    public void OnChangeSliderValue(float inValueChange)
    {
        inValueChange *= valueMultiplier;
        Slider obj = slider;
        obj.value += inValueChange;
        if ((sfx))
        {
            sfx.Fire();
        }
    }
}
public class TouchHandler : MonoBehaviour
{
    [SerializeField]
    public bool hoverBeforePress = true;

    public bool CanTouchPress(bool alreadyHovered)
    {
        return !hoverBeforePress || alreadyHovered;
    }

    public void HandleTouchPress(PointerEventData pointer, bool alreadyHovered)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        pointer.pressPosition = pointer.position;
        pointer.pointerPressRaycast = pointer.pointerCurrentRaycast;
        ExecuteEvents.ExecuteHierarchy<IPointerDownHandler>(gameObject, (BaseEventData)(object)pointer, ExecuteEvents.pointerDownHandler);
        pointer.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
        if ((pointer.pointerDrag))
        {
            ExecuteEvents.Execute<IInitializePotentialDragHandler>(pointer.pointerDrag, (BaseEventData)(object)pointer, ExecuteEvents.initializePotentialDrag);
        }
    }
}
public class TouchInputModule : BaseInputModule
{
    [SerializeField]
    public BaseInput input;

    public PointerEventData pointer;

    public static bool touching;

    public static bool active;

    public static int blockScroll;

    public static readonly Vector2 offscreen = new Vector2(-1000f, -1000f);

    public Vector2 MousePosition { get; set; }

    public Vector2 LastMousePosition { get; set; }

    public Vector2 MouseMove { get; set; }

    public GameObject Hover { get; set; }

    public GameObject Press { get; set; }

    public static float ScrollX { get; set; }

    public static float ScrollY { get; set; }

    public override void OnEnable()
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Expected O, but got Unknown
        ((BaseInputModule)this).OnEnable();
        active = true;
        pointer = new PointerEventData(((BaseInputModule)this).eventSystem);
        Events.OnUpdateInputSystem += ForceUpdate;
        Events.OnCardControllerEnabled += CardControllerEnabled;
    }

    public override void OnDisable()
    {
        ((BaseInputModule)this).OnDisable();
        active = false;
        Events.OnUpdateInputSystem -= ForceUpdate;
        Events.OnCardControllerEnabled -= CardControllerEnabled;
        touching = false;
        ScrollX = 0f;
        ScrollY = 0f;
    }

    public static void BlockScroll()
    {
        blockScroll++;
    }

    public static void UnblockScroll()
    {
        blockScroll--;
    }

    public override void Process()
    {
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        Touch? touch = GetTouch();
        if (touch.HasValue)
        {
            Touch valueOrDefault = touch.GetValueOrDefault();
            ProcessTouch(valueOrDefault);
            touching = true;
            if (blockScroll > 0)
            {
                ScrollX = 0f;
                ScrollY = 0f;
            }
        }
        else
        {
            touching = false;
            ScrollX = 0f;
            ScrollY = 0f;
        }
    }

    public void ForceUpdate(bool forceTouch)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        if (forceTouch)
        {
            Touch val = default(Touch);
            ((val)).position = MousePosition;
            ((val)).deltaTime = Time.deltaTime;
            ((val)).phase = (TouchPhase)2;
            Touch touch = val;
            GameObject hover = Hover;
            PopulateTouchPointerData(touch, out var _, out var _);
            RaycastResult pointerCurrentRaycast = pointer.pointerCurrentRaycast;
            Hover = ((pointerCurrentRaycast)).gameObject;
            ProcessTouchMove(hover, Hover);
        }
        else
        {
            ((BaseInputModule)this).Process();
        }
    }

    public override void UpdateModule()
    {
        ((BaseInputModule)this).Process();
    }

    public void CardControllerEnabled(CardController controller)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        Touch simulatedTouch = GetSimulatedTouch(offscreen, pressed: false, released: false);
        ProcessTouch(simulatedTouch);
    }

    public Touch? GetTouch()
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        if (input.touchCount > 0)
        {
            Touch touch = input.GetTouch(0);
            LastMousePosition = MousePosition;
            MousePosition = ((touch)).position;
            MouseMove = ((touch)).deltaPosition;
            return touch;
        }
        return null;
    }

    public Touch GetSimulatedTouch(Vector2 position, bool pressed, bool released)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0089: Unknown result type (might be due to invalid IL or missing references)
        //IL_008a: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ac: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
        LastMousePosition = MousePosition;
        MousePosition = position;
        MouseMove = MousePosition - LastMousePosition;
        Touch val = default(Touch);
        ((val)).position = MousePosition;
        ((val)).rawPosition = MousePosition;
        ((val)).deltaPosition = MouseMove;
        ((val)).phase = (TouchPhase)2;
        ((val)).pressure = 1f;
        ((val)).maximumPossiblePressure = 1f;
        ((val)).type = (TouchType)0;
        ((val)).tapCount = 1;
        Touch result = val;
        if (pressed)
        {
            ((result)).phase = (TouchPhase)0;
        }
        else if (released)
        {
            ((result)).phase = (TouchPhase)3;
        }
        else
        {
            Vector2 deltaPosition = ((result)).deltaPosition;
            if (((deltaPosition)).sqrMagnitude > 0f)
            {
                ((result)).phase = (TouchPhase)1;
            }
        }
        return result;
    }

    public void PopulateTouchPointerData(Touch touch, out bool pressed, out bool released)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Invalid comparison between Unknown and I4
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Invalid comparison between Unknown and I4
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Invalid comparison between Unknown and I4
        //IL_00ad: Unknown result type (might be due to invalid IL or missing references)
        //IL_007d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0083: Unknown result type (might be due to invalid IL or missing references)
        ((AbstractEventData)pointer).Reset();
        pressed = !touching;
        TouchPhase phase = ((touch)).phase;
        released = (int)phase == 4 || (int)phase == 3;
        pointer.position = ((touch)).position;
        pointer.delta = (pressed ? Vector2.zero : ((touch)).deltaPosition);
        pointer.button = (InputButton)0;
        if ((int)((touch)).phase == 4)
        {
            pointer.pointerCurrentRaycast = default(RaycastResult);
            return;
        }
        ((BaseInputModule)this).eventSystem.RaycastAll(pointer, base.m_RaycastResultCache);
        pointer.pointerCurrentRaycast = FindFirstRaycast(base.m_RaycastResultCache);
        base.m_RaycastResultCache.Clear();
    }

    public void ProcessTouch(Touch touch)
    {
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        GameObject hover = Hover;
        PopulateTouchPointerData(touch, out var pressed, out var released);
        RaycastResult pointerCurrentRaycast = pointer.pointerCurrentRaycast;
        Hover = ((pointerCurrentRaycast)).gameObject;
        ProcessTouchMove(hover, Hover);
        if (!pressed && !released)
        {
            ScrollX = ((touch)).deltaPosition.x;
            ScrollY = ((touch)).deltaPosition.y;
        }
        else
        {
            ScrollX = 0f;
            ScrollY = 0f;
        }
        if (released)
        {
            ProcessTouchRelease();
        }
        else if (pressed)
        {
            ProcessTouchPress(hover);
        }
        if (!released && (pointer.pointerDrag))
        {
            ProcessTouchDrag();
        }
    }

    public void ProcessTouchPress(GameObject preHover)
    {
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        if (!(Hover))
        {
            return;
        }
        TouchHandler component = Hover.GetComponent<TouchHandler>();
        bool alreadyHovered = preHover == Hover;
        if ((component))
        {
            if (component.CanTouchPress(alreadyHovered))
            {
                Press = Hover;
                component.HandleTouchPress(pointer, alreadyHovered);
            }
            return;
        }
        pointer.pressPosition = pointer.position;
        pointer.pointerPressRaycast = pointer.pointerCurrentRaycast;
        Press = Hover;
        ExecuteEvents.ExecuteHierarchy<IPointerDownHandler>(Press, (BaseEventData)(object)pointer, ExecuteEvents.pointerDownHandler);
        pointer.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(Hover);
        if ((pointer.pointerDrag))
        {
            ExecuteEvents.Execute<IInitializePotentialDragHandler>(pointer.pointerDrag, (BaseEventData)(object)pointer, ExecuteEvents.initializePotentialDrag);
        }
    }

    public void ProcessTouchRelease()
    {
        if ((Press))
        {
            ExecuteEvents.ExecuteHierarchy<IPointerUpHandler>(Press, (BaseEventData)(object)pointer, ExecuteEvents.pointerUpHandler);
            if (Hover == Press)
            {
                ExecuteEvents.ExecuteHierarchy<IPointerClickHandler>(Press, (BaseEventData)(object)pointer, ExecuteEvents.pointerClickHandler);
            }
            if ((pointer.pointerDrag) && pointer.dragging)
            {
                ExecuteEvents.ExecuteHierarchy<IDropHandler>(Hover, (BaseEventData)(object)pointer, ExecuteEvents.dropHandler);
                ExecuteEvents.ExecuteHierarchy<IEndDragHandler>(pointer.pointerDrag, (BaseEventData)(object)pointer, ExecuteEvents.endDragHandler);
                pointer.dragging = false;
            }
            Press = null;
        }
    }

    public void ProcessTouchMove(GameObject preHover, GameObject hover)
    {
        if (preHover != hover)
        {
            bool num = (preHover);
            if (num)
            {
                ExecuteEvents.ExecuteHierarchy<IPointerExitHandler>(preHover, (BaseEventData)(object)pointer, ExecuteEvents.pointerExitHandler);
            }
            if ((hover))
            {
                ExecuteEvents.ExecuteHierarchy<IPointerEnterHandler>(hover, (BaseEventData)(object)pointer, ExecuteEvents.pointerEnterHandler);
            }
            if (num)
            {
                preHover.GetComponent<IPointerAfterExitHandler>()?.OnPointerAfterExit(pointer);
            }
        }
    }

    public void ProcessTouchDrag()
    {
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        if (pointer.IsPointerMoving())
        {
            if (!pointer.dragging && ShouldStartDrag(pointer.pressPosition, pointer.position, ((BaseInputModule)this).eventSystem.pixelDragThreshold, pointer.useDragThreshold))
            {
                ExecuteEvents.Execute<IBeginDragHandler>(pointer.pointerDrag, (BaseEventData)(object)pointer, ExecuteEvents.beginDragHandler);
                pointer.dragging = true;
            }
            if (pointer.dragging)
            {
                ExecuteEvents.Execute<IDragHandler>(pointer.pointerDrag, (BaseEventData)(object)pointer, ExecuteEvents.dragHandler);
            }
        }
    }

    public static bool ShouldStartDrag(Vector2 pressPos, Vector2 currentPos, float threshold, bool useDragThreshold)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        if (!useDragThreshold)
        {
            return true;
        }
        Vector2 val = pressPos - currentPos;
        return ((val)).sqrMagnitude >= threshold * threshold;
    }

    public static RaycastResult FindFirstRaycast(List<RaycastResult> candidates)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        foreach (RaycastResult candidate in candidates)
        {
            RaycastResult current = candidate;
            if ((((current)).gameObject))
            {
                return current;
            }
        }
        return default(RaycastResult);
    }
}
public static class UINavigationDefaultSystem
{
    public static void SetStartingItem(bool useClosest = true, bool ignoreHistory = false)
    {
        if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            return;
        }
        Debug.Log("UINavigationDefaultSystem → Finding Default Item");
        if (!MonoBehaviourSingleton<UINavigationSystem>.instance.AvailableNavigationItems.Any())
        {
            Debug.Log("UINavigationDefaultSystem → no available navigation items");
            return;
        }
        List<UINavigationItem> list = MonoBehaviourSingleton<UINavigationSystem>.instance.AvailableNavigationItems.Where((UINavigationItem item) => item != null && item.CheckLayer()).ToList();
        if (list.Count <= 0)
        {
            Debug.Log("UINavigationDefaultSystem → no possible items on current navigation layer");
            return;
        }
        if (list.Count == 1)
        {
            MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(list[0]);
        }
        else
        {
            list = (useClosest ? ((!ignoreHistory) ? (from a in list
                                                      orderby Vector3.Distance(((Component)MonoBehaviourSingleton<Cursor3d>.instance).transform.position, a.Position) - (float)a.selectionPriority, (int)((!UINavigationHistory.items.Contains(a)) ? a.selectionPriority : (UINavigationHistory.items.IndexOf(a) + a.selectionPriority)) descending
                                                      select a).ToList() : (from a in list
                                                                            orderby Vector3.Distance(((Component)MonoBehaviourSingleton<Cursor3d>.instance).transform.position, a.Position) - (float)a.selectionPriority, (int)a.selectionPriority descending
                                                                            select a).ToList()) : ((!ignoreHistory) ? (from a in list
                                                                                                                       orderby (int)((!UINavigationHistory.items.Contains(a)) ? a.selectionPriority : (UINavigationHistory.items.IndexOf(a) + a.selectionPriority)) descending, Vector3.Distance(((Component)MonoBehaviourSingleton<Cursor3d>.instance).transform.position, a.Position)
                                                                                                                       select a).ToList() : (from a in list
                                                                                                                                             orderby (int)a.selectionPriority descending, Vector3.Distance(((Component)MonoBehaviourSingleton<Cursor3d>.instance).transform.position, a.Position)
                                                                                                                                             select a).ToList()));
            MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(list.First());
        }
        Debug.Log($"UINavigationDefaultSystem → Default Item Set: {MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem}");
    }

    public static void SetDefaultTarget(Entity entity)
    {
        if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse || !MonoBehaviourSingleton<UINavigationSystem>.instance.AvailableNavigationItems.Any())
        {
            return;
        }
        CardData.PlayPosition playPosition = GetPlayPosition(entity);
        List<UINavigationItem> list = (from item in GetDefaultTargets(entity, playPosition).Intersect(MonoBehaviourSingleton<UINavigationSystem>.instance.AvailableNavigationItems)
                                       where item != null && item.CheckLayer()
                                       select item).ToList();
        if (list.Count <= 0)
        {
            SetStartingItem();
            return;
        }
        if (list.Count == 1)
        {
            MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(list[0]);
            return;
        }
        list = list.OrderBy((UINavigationItem a) => Vector3.Distance(((Component)MonoBehaviourSingleton<Cursor3d>.instance).transform.position, a.Position) - (float)a.selectionPriority - (float)UINavigationHistory.GetItemIndex(a)).ToList();
        MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(list.First());
    }

    public static CardData.PlayPosition GetPlayPosition(Entity entity)
    {
        if (entity.data.playType == Card.PlayType.Place)
        {
            return CardData.PlayPosition.FriendlySlot;
        }
        if (entity.data.defaultPlayPosition != 0)
        {
            return entity.data.defaultPlayPosition;
        }
        if (!entity.NeedsTarget)
        {
            return CardData.PlayPosition.None;
        }
        if (entity.data.playOnSlot)
        {
            if (!entity.data.canPlayOnFriendly)
            {
                if (!entity.data.canPlayOnEnemy)
                {
                    return CardData.PlayPosition.None;
                }
                return CardData.PlayPosition.EnemySlot;
            }
            return CardData.PlayPosition.FriendlySlot;
        }
        if (entity.IsOffensive())
        {
            if (!entity.targetMode.TargetRow)
            {
                return CardData.PlayPosition.Enemy;
            }
            return CardData.PlayPosition.EnemyRow;
        }
        if (!entity.targetMode.TargetRow)
        {
            return CardData.PlayPosition.Friendly;
        }
        return CardData.PlayPosition.FriendlyRow;
    }

    public static IEnumerable<UINavigationItem> GetDefaultTargets(Entity entity, CardData.PlayPosition playPosition)
    {
        return playPosition switch
        {
            CardData.PlayPosition.Friendly => (from a in Battle.GetCardsOnBoard(entity.owner)
                                               select a.uINavigationItem).ToList(),
            CardData.PlayPosition.Enemy => (from a in Battle.GetCardsOnBoard(Battle.GetOpponent(entity.owner))
                                            select a.uINavigationItem).ToList(),
            CardData.PlayPosition.FriendlyRow => (from a in References.Battle.GetRows(entity.owner)
                                                  select a.nav).ToList(),
            CardData.PlayPosition.EnemyRow => (from a in References.Battle.GetRows(Battle.GetOpponent(entity.owner))
                                               select a.nav).ToList(),
            CardData.PlayPosition.FriendlySlot => Battle.IsOnBoard(entity) ? entity.actualContainers.Select((CardContainer a) => a.nav).ToList() : (from a in References.Battle.GetSlots(entity.owner)
                                                                                                                                                    select a.nav).ToList(),
            CardData.PlayPosition.EnemySlot => (from a in References.Battle.GetSlots(Battle.GetOpponent(entity.owner))
                                                select a.nav).ToList(),
            _ => new List<UINavigationItem>(),
        };
    }
}
public static class UINavigationHistory
{
    [Serializable]
    public class Layer
    {
        public UINavigationLayer navigationLayer;

        public readonly List<UINavigationItem> navigationItemHistory = new List<UINavigationItem>();

        public Layer(UINavigationLayer navigationLayer)
        {
            this.navigationLayer = navigationLayer;
        }
    }

    public static readonly List<Layer> layers = new List<Layer>();

    public static readonly List<UINavigationItem> items = new List<UINavigationItem>(10);

    public const int capacity = 10;

    public static void AddItem(UINavigationItem item)
    {
        items.Add(item);
        if (items.Count > 10)
        {
            items.RemoveAt(0);
        }
    }

    public static int GetItemIndex(UINavigationItem item)
    {
        if (!items.Contains(item))
        {
            return 0;
        }
        return items.IndexOf(item);
    }

    public static void AddLayer(UINavigationLayer navLayer)
    {
        layers.Add(new Layer(navLayer));
    }

    public static void Clear()
    {
        layers.Clear();
        items.Clear();
    }

    public static void GoBackALayer()
    {
        if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            return;
        }
        if (layers.Count > 0)
        {
            Layer layer = layers.FirstOrDefault((Layer a) => a.navigationLayer == UINavigationSystem.ActiveNavigationLayer);
            if (layer != null && layer.navigationItemHistory.Count > 0)
            {
                MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(layer.navigationItemHistory.Last());
                return;
            }
        }
        UINavigationDefaultSystem.SetStartingItem(useClosest: false);
    }
}
public class UINavigationItem : MonoBehaviour
{
    public enum SelectionPriority
    {
        Mega = 10,
        Highest = 2,
        High = 1,
        Medium = 0,
        Low = -1,
        Lowest = -2
    }

    public UINavigationLayer navigationLayer;

    public Vector3 offset;

    public SelectionPriority selectionPriority;

    public GameObject clickHandler;

    public bool isHighlighted;

    public bool canLoop;

    public bool ignoreLayers;

    public bool isSelectable = true;

    public bool overrideInputs;

    [ShowIf("overrideInputs")]
    public UINavigationItem inputLeft;

    [ShowIf("overrideInputs")]
    public UINavigationItem inputRight;

    [ShowIf("overrideInputs")]
    public UINavigationItem inputUp;

    [ShowIf("overrideInputs")]
    public UINavigationItem inputDown;

    [HideIf("overrideInputs")]
    public bool overrideHorizontal;

    [ShowIf("overrideHorizontal")]
    [HideIf("overrideInputs")]
    public UnityEvent<float> OnHorizontalOverride;

    [HideIf("overrideInputs")]
    public bool overrideVertical;

    [ShowIf("overrideVertical")]
    [HideIf("overrideInputs")]
    public UnityEvent<float> OnVerticalOverride;

    public bool hasLayerBeenChecked;

    public Camera _cam;

    public Vector3 Position => transform.position + offset;

    public Camera cam => _cam ?? (_cam = Camera.main);

    public void OnEnable()
    {
        CheckForReferences(!hasLayerBeenChecked);
        MonoBehaviourSingleton<UINavigationSystem>.instance.RegisterSelectable(this);
    }

    public void OnDisable()
    {
        OnRemoved();
    }

    public void OnDestroy()
    {
        OnRemoved();
    }

    public void OnRemoved()
    {
        MonoBehaviourSingleton<UINavigationSystem>.instance.UnregisterSelectable(this);
    }

    public virtual void Reset()
    {
        if (GetComponents<UINavigationItem>().Length > 1)
        {
            Object.Destroy(this);
        }
        CheckForReferences(isFirstTime: true);
    }

    public void OnTransformParentChanged()
    {
        navigationLayer = null;
        CheckForNavigationLayer(!hasLayerBeenChecked);
    }

    public void CheckForReferences(bool isFirstTime)
    {
        if (navigationLayer == null)
        {
            CheckForNavigationLayer(isFirstTime);
        }
        if (clickHandler == null)
        {
            CheckForSelectable();
        }
    }

    public void CheckForNavigationLayer(bool isFirstTime)
    {
        if (isFirstTime)
        {
            navigationLayer = null;
        }
        CheckForNavigationLayer(transform, isFirstTime);
        hasLayerBeenChecked = true;
    }

    public void CheckForNavigationLayer(Transform checkTransform, bool isFirstTime)
    {
        if ((((Component)checkTransform).GetComponent<UINavigationLayer>()) && ((Component)checkTransform).GetComponent<UINavigationLayer>().isOverrideLayer && (isFirstTime || ((Component)checkTransform).GetComponent<UINavigationLayer>().allowLayerToBeAppliedAtRuntime))
        {
            navigationLayer = ((Component)checkTransform).GetComponent<UINavigationLayer>();
        }
        if (!(navigationLayer) && (((Component)checkTransform).transform.parent))
        {
            CheckForNavigationLayer(((Component)checkTransform).transform.parent, isFirstTime);
        }
    }

    public void CheckForSelectable()
    {
        CheckForSelectableDown(transform);
        if (clickHandler == null)
        {
            CheckForSelectableUp(transform.parent);
        }
    }

    public void CheckForSelectableDown(Transform checkTransform)
    {
        clickHandler = ((((Component)checkTransform).GetComponent<IPointerDownHandler>() != null) ? ((Component)checkTransform).gameObject : null);
        if (!(clickHandler == null))
        {
            return;
        }
        for (int i = 0; i < checkTransform.childCount; i++)
        {
            CheckForSelectableDown(checkTransform.GetChild(i));
            if (clickHandler != null)
            {
                break;
            }
        }
    }

    public void CheckForSelectableUp(Transform checkTransform)
    {
        if (checkTransform != null)
        {
            clickHandler = ((((Component)checkTransform).GetComponent<IPointerDownHandler>() != null) ? ((Component)checkTransform).gameObject : null);
            if (clickHandler == null && (((Component)checkTransform).transform.parent))
            {
                CheckForSelectableDown(((Component)checkTransform).transform.parent);
            }
        }
    }

    public bool CheckLayer()
    {
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        UINavigationLayer activeNavigationLayer = UINavigationSystem.ActiveNavigationLayer;
        if (ignoreLayers || navigationLayer == activeNavigationLayer)
        {
            if (!(activeNavigationLayer) || !activeNavigationLayer.allowOutsideVisibleSelection)
            {
                return cam.IsInCameraView(Position);
            }
            return true;
        }
        return false;
    }
}
public class UINavigationLayer : MonoBehaviour
{
    public static uint idMax;

    public uint id;

    public bool isOverrideLayer = true;

    public bool setStartingItem = true;

    public bool allowOutsideVisibleSelection;

    public bool allowLayerToBeAppliedAtRuntime = true;

    public bool forceHover = true;

    public void Awake()
    {
        id = idMax++;
    }

    public void OnEnable()
    {
        MonoBehaviourSingleton<UINavigationSystem>.instance.RegisterNavigationLayer(this);
    }

    public void OnDisable()
    {
        MonoBehaviourSingleton<UINavigationSystem>.instance.UnregisterNavigationLayer(this);
    }

    public override bool Equals(object other)
    {
        if (other is UINavigationLayer uINavigationLayer)
        {
            return uINavigationLayer.id == id;
        }
        return false;
    }
}
public class UINavigationSystem : MonoBehaviourSingleton<UINavigationSystem>
{
    [Header("Current Status")]
    public UINavigationItem currentNavigationItem;

    public List<UINavigationItem> AvailableNavigationItems = new List<UINavigationItem>();

    public List<UINavigationItem> PossibleNavigationItems = new List<UINavigationItem>();

    public List<UINavigationLayer> NavigationLayers = new List<UINavigationLayer>();

    public static UINavigationLayer ActiveNavigationLayer;

    public UINavigationLayer lastActiveNavigationLayer;

    [Header("Settings Status")]
    public float navigationControllerDeadzone = 0.05f;

    [ReadOnly]
    public MoveDirection lastMove;

    public float navigationGridThreshold = 1.5f;

    public float minorNavigationGridThreshold = 0.25f;

    public float maxAnyItemCheckBeforeLoopMultiplier = 2.5f;

    public float anglePriority = 1f;

    public float disPriority = 1f;

    public float maxNavAngle = 45f;

    public UnityEvent OnNavigate;

    [Header("References")]
    public Cursor3d virtualCursor;

    [SerializeField]
    public CustomEventSystem eventSystem;

    [SerializeField]
    public GameObject eventSystemObj;

    public bool didNavigate;

    public Vector3 lastNavigationItemPos;

    public bool currentNavigationItemChanged = true;

    public void Start()
    {
        NavigationState.Reset();
    }

    public void OnEnable()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnTransitionEnd += Events_OnTransitionEnd;
        Events.OnUINavigationReset += new UnityAction(Events_OnUINavigationReset);
        Events.OnEntityFlipComplete += Events_OnEntityFlipComplete;
    }

    public void OnDisable()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnTransitionEnd -= Events_OnTransitionEnd;
        Events.OnUINavigationReset -= new UnityAction(Events_OnUINavigationReset);
        Events.OnEntityFlipComplete -= Events_OnEntityFlipComplete;
    }

    public void Events_OnEntityFlipComplete(Entity entity)
    {
        if ((entity) && (currentNavigationItem) && ((Component)entity).gameObject == ((Component)currentNavigationItem).gameObject)
        {
            UINavigationDefaultSystem.SetStartingItem();
        }
    }

    public void Events_OnUINavigationReset()
    {
        ResetState();
    }

    public void Events_OnTransitionEnd(TransitionType transition)
    {
        UINavigationDefaultSystem.SetStartingItem(useClosest: false, ignoreHistory: true);
    }

    public void RemoveActiveLayer()
    {
        UnregisterNavigationLayer(ActiveNavigationLayer);
    }

    public void RegisterSelectable(UINavigationItem uiNavigationItem)
    {
        if (!AvailableNavigationItems.Contains(uiNavigationItem) && AvailableNavigationItems.Count((UINavigationItem x) => ((Component)x).gameObject == ((Component)uiNavigationItem).gameObject) == 0)
        {
            AvailableNavigationItems.Add(uiNavigationItem);
            if ((MonoBehaviourSingleton<UINavigationSystem>.instance) && (MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem) && (MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem.selectionPriority == UINavigationItem.SelectionPriority.Lowest || (uiNavigationItem.selectionPriority == UINavigationItem.SelectionPriority.Highest && MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem.selectionPriority != UINavigationItem.SelectionPriority.Highest)))
            {
                UINavigationDefaultSystem.SetStartingItem();
            }
        }
    }

    public void UnregisterSelectable(UINavigationItem uiNavigationItem)
    {
        if (AvailableNavigationItems.Contains(uiNavigationItem))
        {
            AvailableNavigationItems.Remove(uiNavigationItem);
        }
    }

    public void RegisterNavigationLayer(UINavigationLayer navigationLayer)
    {
        NavigationLayers.Add(navigationLayer);
        if (navigationLayer.isOverrideLayer)
        {
            ActiveNavigationLayer = navigationLayer;
        }
    }

    public void UnregisterNavigationLayer(UINavigationLayer navigationLayer)
    {
        if (!NavigationLayers.Contains(navigationLayer))
        {
            return;
        }
        foreach (UINavigationItem item in AvailableNavigationItems.Where((UINavigationItem item) => item.navigationLayer == navigationLayer))
        {
            item.CheckForNavigationLayer(isFirstTime: true);
        }
        NavigationLayers.Remove(navigationLayer);
        UINavigationHistory.GoBackALayer();
        if (navigationLayer.isOverrideLayer)
        {
            ActiveNavigationLayer = NavigationLayers.LastOrDefault((UINavigationLayer x) => x.isOverrideLayer);
        }
    }

    public void Update()
    {
        //IL_00ae: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
        if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse && (currentNavigationItem))
        {
            SetCurrentNavigationItem(null);
            return;
        }
        UINavigationLayer activeNavigationLayer = ActiveNavigationLayer;
        if ((currentNavigationItem) && (!AvailableNavigationItems.Contains(currentNavigationItem) || !currentNavigationItem.CheckLayer()))
        {
            SetCurrentNavigationItem(null);
        }
        if (!(currentNavigationItem) && AvailableNavigationItems.Any((UINavigationItem a) => (a) && a.navigationLayer == activeNavigationLayer))
        {
            UINavigationDefaultSystem.SetStartingItem();
        }
        else if ((currentNavigationItem))
        {
            CheckForNavigation();
            if (Vector3.Distance(currentNavigationItem.Position, lastNavigationItemPos) > Mathf.Epsilon)
            {
                SetCursor();
            }
        }
        if (activeNavigationLayer != lastActiveNavigationLayer)
        {
            UINavigationHistory.AddLayer(activeNavigationLayer);
        }
        foreach (UINavigationHistory.Layer layer in UINavigationHistory.layers)
        {
            if (layer.navigationLayer == activeNavigationLayer)
            {
                if (layer.navigationItemHistory.Count <= 0 || layer.navigationItemHistory.Last() != currentNavigationItem)
                {
                    layer.navigationItemHistory.Add(currentNavigationItem);
                }
                break;
            }
        }
        lastActiveNavigationLayer = activeNavigationLayer;
    }

    public void SetCursor()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        VirtualPointer.Show();
        virtualCursor.SetPosition(currentNavigationItem.Position);
        lastNavigationItemPos = ((currentNavigationItem) ? currentNavigationItem.Position : lastNavigationItemPos);
    }

    public void ResetState()
    {
        UINavigationDefaultSystem.SetStartingItem();
    }

    public void CheckForNavigation()
    {
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        if (!virtualCursor.showVirtualPointerState || Console.active)
        {
            return;
        }
        if (InputSystem.CheckLongHold())
        {
            SetCurrentNavigationItem(GetSelectable(lastMove));
        }
        int num = (InputSystem.IsButtonPressed("Move Vertical") ? 1 : (InputSystem.IsButtonPressed("Move Vertical", positive: false) ? (-1) : 0));
        int num2 = (InputSystem.IsButtonPressed("Move Horizontal") ? 1 : (InputSystem.IsButtonPressed("Move Horizontal", positive: false) ? (-1) : 0));
        if ((float)Mathf.Abs(num) > navigationControllerDeadzone || (float)Mathf.Abs(num2) > navigationControllerDeadzone)
        {
            if (!didNavigate)
            {
                if (Mathf.Abs(num) > Mathf.Abs(num2))
                {
                    if ((float)num > navigationControllerDeadzone)
                    {
                        SetCurrentNavigationItem(GetSelectable((MoveDirection)1));
                    }
                    if ((float)num < 0f - navigationControllerDeadzone)
                    {
                        SetCurrentNavigationItem(GetSelectable((MoveDirection)3));
                    }
                }
                else
                {
                    if ((float)num2 < 0f - navigationControllerDeadzone)
                    {
                        SetCurrentNavigationItem(GetSelectable((MoveDirection)0));
                    }
                    if ((float)num2 > navigationControllerDeadzone)
                    {
                        SetCurrentNavigationItem(GetSelectable((MoveDirection)2));
                    }
                }
                didNavigate = true;
            }
        }
        else
        {
            didNavigate = false;
        }
        if (didNavigate)
        {
            currentNavigationItemChanged = true;
            Events.InvokeUINavigation();
        }
    }

    public UINavigationItem GetSelectable(MoveDirection moveDirection)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Expected I4, but got Unknown
        //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
        //IL_0184: Unknown result type (might be due to invalid IL or missing references)
        //IL_0189: Unknown result type (might be due to invalid IL or missing references)
        //IL_018b: Unknown result type (might be due to invalid IL or missing references)
        //IL_018c: Unknown result type (might be due to invalid IL or missing references)
        //IL_010e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0110: Invalid comparison between Unknown and I4
        //IL_00b7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b9: Invalid comparison between Unknown and I4
        //IL_0112: Unknown result type (might be due to invalid IL or missing references)
        //IL_0114: Invalid comparison between Unknown and I4
        lastMove = moveDirection;
        if (currentNavigationItem.overrideInputs)
        {
            switch ((int)moveDirection)
            {
                case 0:
                    if ((currentNavigationItem.inputLeft))
                    {
                        return currentNavigationItem.inputLeft;
                    }
                    break;
                case 2:
                    if ((currentNavigationItem.inputRight))
                    {
                        return currentNavigationItem.inputRight;
                    }
                    break;
                case 1:
                    if ((currentNavigationItem.inputUp))
                    {
                        return currentNavigationItem.inputUp;
                    }
                    break;
                case 3:
                    if ((currentNavigationItem.inputDown))
                    {
                        return currentNavigationItem.inputDown;
                    }
                    break;
            }
        }
        if (currentNavigationItem.overrideHorizontal)
        {
            if ((int)moveDirection == 0)
            {
                currentNavigationItem.OnHorizontalOverride?.Invoke(-1f);
                return currentNavigationItem;
            }
            if ((int)moveDirection == 2)
            {
                currentNavigationItem.OnHorizontalOverride?.Invoke(1f);
                return currentNavigationItem;
            }
        }
        if (currentNavigationItem.overrideVertical)
        {
            if ((int)moveDirection == 1)
            {
                currentNavigationItem.OnVerticalOverride?.Invoke(1f);
                return currentNavigationItem;
            }
            if ((int)moveDirection == 3)
            {
                currentNavigationItem.OnVerticalOverride?.Invoke(-1f);
                return currentNavigationItem;
            }
        }
        PossibleNavigationItems = AvailableNavigationItems.Where((UINavigationItem x) => (x) && x != currentNavigationItem && x.CheckLayer()).ToList();
        Vector3 position = currentNavigationItem.Position;
        UINavigationItem selectable = GetSelectable(moveDirection, position);
        if (!(selectable))
        {
            return currentNavigationItem;
        }
        return selectable;
    }

    public UINavigationItem GetSelectable(MoveDirection moveDirection, Vector3 currentPosition)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Expected I4, but got Unknown
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_01b0: Unknown result type (might be due to invalid IL or missing references)
        //IL_01b5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b8: Unknown result type (might be due to invalid IL or missing references)
        //IL_0133: Unknown result type (might be due to invalid IL or missing references)
        //IL_0138: Unknown result type (might be due to invalid IL or missing references)
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        //IL_007d: Unknown result type (might be due to invalid IL or missing references)
        //IL_01ef: Unknown result type (might be due to invalid IL or missing references)
        //IL_01f4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fd: Unknown result type (might be due to invalid IL or missing references)
        //IL_0178: Unknown result type (might be due to invalid IL or missing references)
        //IL_017d: Unknown result type (might be due to invalid IL or missing references)
        UINavigationItem uINavigationItem = null;
        switch ((int)moveDirection)
        {
            case 0:
                uINavigationItem = GetSelectable(currentPosition, Vector3.left, (UINavigationItem a) => currentPosition.x - a.Position.x > minorNavigationGridThreshold, (UINavigationItem a) => Mathf.Abs(a.Position.y - currentPosition.y) < navigationGridThreshold * maxAnyItemCheckBeforeLoopMultiplier && Mathf.Abs(Vector3.Angle(Vector3.left, currentPosition.GetDirTowardsPoint(a.Position))) < maxNavAngle);
                if (!(uINavigationItem) && currentNavigationItem.canLoop)
                {
                    uINavigationItem = GetSelectableLoop(currentPosition, Vector3.left, (UINavigationItem a) => Mathf.Abs(currentPosition.x - a.Position.x) > minorNavigationGridThreshold, (UINavigationItem a) => Mathf.Abs(currentPosition.y - a.Position.y) < navigationGridThreshold, (UINavigationItem a) => a.Position.x - currentPosition.x > minorNavigationGridThreshold);
                }
                break;
            case 2:
                uINavigationItem = GetSelectable(currentPosition, Vector3.right, (UINavigationItem a) => a.Position.x - currentPosition.x > minorNavigationGridThreshold, (UINavigationItem a) => Mathf.Abs(a.Position.y - currentPosition.y) < navigationGridThreshold * maxAnyItemCheckBeforeLoopMultiplier && Mathf.Abs(Vector3.Angle(Vector3.right, currentPosition.GetDirTowardsPoint(a.Position))) < maxNavAngle);
                if (!(uINavigationItem) && currentNavigationItem.canLoop)
                {
                    uINavigationItem = GetSelectableLoop(currentPosition, Vector3.right, (UINavigationItem a) => Mathf.Abs(currentPosition.x - a.Position.x) > minorNavigationGridThreshold, (UINavigationItem a) => Mathf.Abs(currentPosition.y - a.Position.y) < navigationGridThreshold, (UINavigationItem a) => currentPosition.x - a.Position.x > minorNavigationGridThreshold);
                }
                break;
            case 3:
                uINavigationItem = GetSelectable(currentPosition, Vector3.down, (UINavigationItem a) => currentPosition.y - a.Position.y > minorNavigationGridThreshold, (UINavigationItem a) => Mathf.Abs(a.Position.x - currentPosition.x) < navigationGridThreshold * maxAnyItemCheckBeforeLoopMultiplier && Mathf.Abs(Vector3.Angle(Vector3.down, currentPosition.GetDirTowardsPoint(a.Position))) < maxNavAngle);
                if (!(uINavigationItem) && currentNavigationItem.canLoop)
                {
                    uINavigationItem = GetSelectableLoop(currentPosition, Vector3.down, (UINavigationItem a) => Mathf.Abs(currentPosition.y - a.Position.y) > minorNavigationGridThreshold, (UINavigationItem a) => Mathf.Abs(currentPosition.x - a.Position.x) < navigationGridThreshold, (UINavigationItem a) => a.Position.y - currentPosition.y > minorNavigationGridThreshold);
                }
                break;
            case 1:
                uINavigationItem = GetSelectable(currentPosition, Vector3.up, (UINavigationItem a) => a.Position.y - currentPosition.y > minorNavigationGridThreshold, (UINavigationItem a) => Mathf.Abs(a.Position.x - currentPosition.x) < navigationGridThreshold * maxAnyItemCheckBeforeLoopMultiplier && Mathf.Abs(Vector3.Angle(Vector3.up, currentPosition.GetDirTowardsPoint(a.Position))) < maxNavAngle);
                if (!(uINavigationItem) && currentNavigationItem.canLoop)
                {
                    uINavigationItem = GetSelectableLoop(currentPosition, Vector3.up, (UINavigationItem a) => Mathf.Abs(currentPosition.y - a.Position.y) > minorNavigationGridThreshold, (UINavigationItem a) => Mathf.Abs(currentPosition.x - a.Position.x) < navigationGridThreshold, (UINavigationItem a) => currentPosition.y - a.Position.y > minorNavigationGridThreshold);
                }
                break;
        }
        return uINavigationItem;
    }

    public UINavigationItem GetSelectable(Vector3 currentPosition, Vector3 direction, Predicate<UINavigationItem> directionCheck, Predicate<UINavigationItem> alignmentCheck)
    {
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        List<UINavigationItem> source = PossibleNavigationItems.Where((UINavigationItem a) => directionCheck(a) && alignmentCheck(a)).ToList();
        if (source.Any())
        {
            return source.OrderBy((UINavigationItem a) => Vector3.Distance(a.Position, currentPosition).RemapProportion(0f, navigationGridThreshold, 0f, disPriority) + Mathf.Abs(Vector3.Angle(direction, currentPosition.GetDirTowardsPoint(a.Position))).RemapProportion(0f, maxNavAngle, 0f, anglePriority)).First();
        }
        return null;
    }

    public UINavigationItem GetSelectableLoop(Vector3 currentPosition, Vector3 direction, Predicate<UINavigationItem> directionCheck, Predicate<UINavigationItem> alignmentCheck, Predicate<UINavigationItem> fallbackCheck)
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ec: Unknown result type (might be due to invalid IL or missing references)
        List<UINavigationItem> list = PossibleNavigationItems.Where((UINavigationItem a) => directionCheck(a) && alignmentCheck(a)).ToList();
        if (!list.Any())
        {
            list = PossibleNavigationItems.Where((UINavigationItem a) => fallbackCheck(a)).ToList();
        }
        if (list.Count > 0)
        {
            UINavigationItem uINavigationItem = list.OrderBy((UINavigationItem a) => Vector3Ext.DistanceTo(a.Position, currentPosition)).Last();
            if (list.Count == 1)
            {
                return uINavigationItem;
            }
            Vector3 furthestPosition = Vector3Ext.WithZ(uINavigationItem.Position - direction * navigationGridThreshold, currentPosition.z);
            return list.OrderBy((UINavigationItem a) => Vector3.Distance(a.Position, furthestPosition).RemapProportion(0f, navigationGridThreshold, 0f, disPriority) + Mathf.Abs(Vector3.Angle(direction, furthestPosition.GetDirTowardsPoint(a.Position))).RemapProportion(0f, maxNavAngle, 0f, anglePriority)).First();
        }
        return null;
    }

    public void SetCurrentNavigationItem(UINavigationItem navItem)
    {
        if ((currentNavigationItem))
        {
            if (((object)currentNavigationItem).Equals((object?)navItem))
            {
                return;
            }
            eventSystem.Unhover(currentNavigationItem.clickHandler);
        }
        if ((navItem) && AvailableNavigationItems.Any((UINavigationItem a) => a == navItem))
        {
            currentNavigationItem = navItem;
            UINavigationLayer activeNavigationLayer = ActiveNavigationLayer;
            if (!(activeNavigationLayer) || activeNavigationLayer.forceHover)
            {
                eventSystem.Hover(navItem.clickHandler);
            }
            UINavigationHistory.AddItem(navItem);
        }
        else
        {
            currentNavigationItem = null;
        }
    }
}
public enum Likelihood
{
    MostToLeast,
    LeastToMost,
    Balanced
}
[Serializable]
[Flags]
public enum Axis
{
    All = 0,
    X = 2,
    Y = 4,
    Z = 8
}
public static class UtilityScript
{
    public static string GetLogMessage(string source, string message)
    {
        return "[" + source + "] " + message;
    }

    public static MethodInfo GetMethodInfo<T>(Expression<System.Action<T>> expression)
    {
        if (expression.Body is MethodCallExpression methodCallExpression)
        {
            return methodCallExpression.Method;
        }
        throw new ArgumentException("Expression is not a method", "expression");
    }

    public static Vector3 GenerateSineWave(Vector3 axis, Vector3 currentPosition, float frequency, float magnitude, float timeStep)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        return currentPosition + axis * Mathf.Sin(timeStep * frequency) * magnitude;
    }

    public static float PlanarDistance(this Vector3 a, Vector3 b, Axis negatedAxis)
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_007e: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0152: Unknown result type (might be due to invalid IL or missing references)
        //IL_0157: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00dd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ee: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ff: Unknown result type (might be due to invalid IL or missing references)
        //IL_0104: Unknown result type (might be due to invalid IL or missing references)
        //IL_010f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0115: Unknown result type (might be due to invalid IL or missing references)
        //IL_0120: Unknown result type (might be due to invalid IL or missing references)
        //IL_0126: Unknown result type (might be due to invalid IL or missing references)
        //IL_0131: Unknown result type (might be due to invalid IL or missing references)
        //IL_0136: Unknown result type (might be due to invalid IL or missing references)
        //IL_013c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0147: Unknown result type (might be due to invalid IL or missing references)
        if (negatedAxis == Axis.All)
        {
            return Distance(new Vector3(0f, 0f, a.z), new Vector3(0f, 0f, b.z));
        }
        if (negatedAxis == Axis.All)
        {
            return Distance(new Vector3(0f, a.y, 0f), new Vector3(0f, b.y, 0f));
        }
        if (negatedAxis == Axis.All)
        {
            return Distance(new Vector3(a.x, 0f, 0f), new Vector3(b.x, 0f, 0f));
        }
        return negatedAxis switch
        {
            Axis.X => Distance(new Vector3(0f, a.y, a.z), new Vector3(0f, b.y, b.z)),
            Axis.Y => Distance(new Vector3(a.x, 0f, a.z), new Vector3(b.x, 0f, b.z)),
            Axis.Z => Distance(new Vector3(a.x, a.y, 0f), new Vector3(b.x, b.y, 0f)),
            Axis.All => Vector3.zero.Distance(Vector3.zero),
            _ => float.PositiveInfinity,
        };
    }

    public static Vector2 GetAverage(List<Vector2> positions)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        Vector2 val = Vector2.zero;
        for (int i = 0; i < positions.Count; i++)
        {
            val += positions[i];
        }
        return val / (float)positions.Count;
    }

    public static Vector3 RandomInRange(this Vector3 inVector)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(Random.Range((0f - inVector.x) / 2f, inVector.x / 2f), Random.Range((0f - inVector.y) / 2f, inVector.y / 2f), Random.Range((0f - inVector.z) / 2f, inVector.z / 2f));
    }

    public static Vector3 PlanarDistanceVec3(this Vector3 a, Vector3 b, Axis negatedAxis)
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_007e: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0093: Unknown result type (might be due to invalid IL or missing references)
        //IL_0152: Unknown result type (might be due to invalid IL or missing references)
        //IL_0157: Unknown result type (might be due to invalid IL or missing references)
        //IL_015c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0162: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00dd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ee: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ff: Unknown result type (might be due to invalid IL or missing references)
        //IL_0104: Unknown result type (might be due to invalid IL or missing references)
        //IL_010f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0115: Unknown result type (might be due to invalid IL or missing references)
        //IL_011a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0120: Unknown result type (might be due to invalid IL or missing references)
        //IL_0126: Unknown result type (might be due to invalid IL or missing references)
        //IL_0131: Unknown result type (might be due to invalid IL or missing references)
        //IL_0136: Unknown result type (might be due to invalid IL or missing references)
        //IL_013c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0147: Unknown result type (might be due to invalid IL or missing references)
        //IL_014c: Unknown result type (might be due to invalid IL or missing references)
        if (negatedAxis == Axis.All)
        {
            return new Vector3(0f, 0f, a.z) - new Vector3(0f, 0f, b.z);
        }
        if (negatedAxis == Axis.All)
        {
            return new Vector3(0f, a.y, 0f) - new Vector3(0f, b.y, 0f);
        }
        if (negatedAxis == Axis.All)
        {
            return new Vector3(a.x, 0f, 0f) - new Vector3(b.x, 0f, 0f);
        }
        return (Vector3)(negatedAxis switch
        {
            Axis.X => new Vector3(0f, a.y, a.z) - new Vector3(0f, b.y, b.z),
            Axis.Y => new Vector3(a.x, 0f, a.z) - new Vector3(b.x, 0f, b.z),
            Axis.Z => new Vector3(a.x, a.y, 0f) - new Vector3(b.x, b.y, 0f),
            Axis.All => Vector3.zero - Vector3.zero,
            _ => Vector3.positiveInfinity,
        });
    }

    public static Vector3 GetPlanar(this Vector3 a, Axis negatedAxis)
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        return (Vector3)(negatedAxis switch
        {
            Axis.X => new Vector3(0f, a.y, a.z),
            Axis.Y => new Vector3(a.x, 0f, a.z),
            Axis.Z => new Vector3(a.x, a.y, 0f),
            _ => new Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity),
        });
    }

    public static float RoundAwayFromZero(this float f)
    {
        if (!(f >= 0f))
        {
            return Mathf.Floor(f);
        }
        return Mathf.Ceil(f);
    }

    public static float AddToAverage(float average, int size, float value)
    {
        return ((float)size * average + value) / (float)(size + 1);
    }

    public static float SubtractFromAverage(float average, int size, float value)
    {
        return ((float)size * average - value) / (float)(size - 1);
    }

    public static float ReplaceInAverage(float average, int size, float oldValue, float newValue)
    {
        return ((float)size * average - oldValue + newValue) / (float)size;
    }

    public static float AddAveragesTogether(float averageA, int sizeA, float averageB, int sizeB)
    {
        return ((float)sizeA * averageA + (float)sizeB * averageB) / (float)(sizeA + sizeB);
    }

    public static float GetNormalDistance(this Vector3 position, Vector3 startPosition, Vector3 destination)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = startPosition.PlanarDistanceVec3(destination, Axis.Y);
        float sqrMagnitude = ((val)).sqrMagnitude;
        val = position.PlanarDistanceVec3(destination, Axis.Y);
        return ((val)).sqrMagnitude.RemapProportion(0f, sqrMagnitude, 0f, 1f);
    }

    public static string GetPathBasedOnOS()
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Invalid comparison between Unknown and I4
        if (Application.isEditor)
        {
            return Application.persistentDataPath + "/";
        }
        if ((int)Application.platform == 17)
        {
            return Path.GetDirectoryName(Application.absoluteURL).Replace("\\", "/") + "/";
        }
        if (Application.isMobilePlatform || Application.isConsolePlatform)
        {
            return Application.persistentDataPath;
        }
        return Application.persistentDataPath + "/";
    }

    public static string GetIdentifier(string userIdentifier, string uniqueObjectIdentifier)
    {
        return userIdentifier + "-" + uniqueObjectIdentifier;
    }

    public static Vector3 Lerp(this Vector3 a, Vector3 b, float time)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        return Vector3.Lerp(a, b, time);
    }

    public static bool IsEmpty(this string input)
    {
        if (string.IsNullOrEmpty(input))
        {
            return string.IsNullOrWhiteSpace(input);
        }
        return false;
    }

    public static double ToEpoch(this DateTime dt)
    {
        return dt.Subtract(new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds;
    }

    public static DateTime FromEpoch(this double epoch)
    {
        return new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddSeconds(epoch);
    }

    public static double ToEpochMs(this DateTime dt)
    {
        return dt.Subtract(new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc)).TotalMilliseconds;
    }

    public static DateTime FromEpochMs(this double epoch)
    {
        return new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddMilliseconds(epoch);
    }

    public static float SecondsToMs(this float seconds)
    {
        return seconds * 1000f;
    }

    public static Texture2D AddWatermark(Texture2D textureToSave, Texture2D watermark, int startPositionX, int startPositionY, bool hideFadedPixels = false)
    {
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        Texture2D val = ((Texture)(object)textureToSave).ToTexture2D();
        Color val3 = default(Color);
        for (int i = startPositionX; i < ((Texture)val).width; i++)
        {
            for (int j = startPositionY; j < ((Texture)val).height; j++)
            {
                if (i - startPositionX < ((Texture)watermark).width && j - startPositionY < ((Texture)watermark).height)
                {
                    Color pixel = val.GetPixel(i, j);
                    Color pixel2 = watermark.GetPixel(i - startPositionX, j - startPositionY);
                    Color val2 = Color.Lerp(pixel, pixel2, pixel2.a / 1f);
                    Color val3 = new(val2.r, val2.g, val2.b, 1f);
                    val.SetPixel(i, j, val3);
                }
            }
        }
        val.Apply();
        return val;
    }

    public static float AngleDir(Vector3 fwd, Vector3 targetDir, Vector3 up)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        float num = Vector3.Dot(Vector3.Cross(fwd, targetDir), up);
        if (num > 0f)
        {
            return 1f;
        }
        if (num < 0f)
        {
            return -1f;
        }
        return 0f;
    }

    public static IEnumerable<string> ToCsv<T>(IEnumerable<T> objectlist, string separator = ",", bool header = true)
    {
        FieldInfo[] fields = typeof(T).GetFields();
        PropertyInfo[] properties = typeof(T).GetProperties();
        if (header)
        {
            yield return string.Join(separator, fields.Select((FieldInfo f) => f.Name).Concat(properties.Select((PropertyInfo p) => p.Name)).ToArray());
        }
        foreach (T o in objectlist)
        {
            yield return string.Join(separator, fields.Select((FieldInfo f) => (f.GetValue(o) ?? "").ToString()).Concat(properties.Select((PropertyInfo p) => (p.GetValue(o, null) ?? "").ToString())).ToArray());
        }
    }

    public static float SubtractValueFromMean(float inVal, float currentMean, float numOfValues)
    {
        return (currentMean * numOfValues - inVal) / (numOfValues - 1f);
    }

    public static float AddValueToMean(float inVal, float currentMean, float numOfValues)
    {
        return currentMean + (inVal - currentMean) / numOfValues;
    }

    public static Color RandomColour()
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        return new Color(Random.value, Random.value, Random.value);
    }

    public static int RandomIndex<T>(this IEnumerable<T> list)
    {
        return Random.Range(0, list.Count());
    }

    public static T Next<T>(this IEnumerable<T> list, T anchor)
    {
        int num = list.ToList().IndexOf(anchor);
        if (num >= list.Count())
        {
            return list.ElementAtOrDefault(0);
        }
        if (num <= -1)
        {
            return list.ElementAtOrDefault(list.Count() - 1);
        }
        return list.ElementAtOrDefault(num + 1);
    }

    public static bool CompareArrays(int[,] arrayA, int[,] arrayB)
    {
        try
        {
            return arrayA.Rank == arrayB.Rank && Enumerable.Range(0, arrayA.Rank).All((int dimension) => arrayA.GetLength(dimension) == arrayB.GetLength(dimension)) && arrayA.Cast<int>().SequenceEqual(arrayB.Cast<int>());
        }
        catch
        {
            return false;
        }
    }

    public static float RemapProportion(this float value, float currentMin, float currentMax, float newMin, float newMax)
    {
        return (value - currentMin) / (currentMax - currentMin) * (newMax - newMin) + newMin;
    }

    public static float Distance(this Vector3 thisVec, Vector3 compareVec)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return Vector3.Distance(thisVec, compareVec);
    }

    public static Vector3 Difference(this Vector3 a, Vector3 b)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        return a - b;
    }

    public static bool InRange(this Vector2 inRange, float inNum, bool isInclusive = true)
    {
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0004: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        if (isInclusive)
        {
            if (inNum >= inRange.x)
            {
                return inNum <= inRange.y;
            }
            return false;
        }
        if (inNum > inRange.x)
        {
            return inNum < inRange.y;
        }
        return false;
    }

    public static T RandomEnumValue<T>(Likelihood likelihood)
    {
        Array values = Enum.GetValues(typeof(T));
        float[] array = new float[values.Length];
        array[0] = 100f;
        for (int i = 1; i < values.Length; i++)
        {
            array[i] = 100f / (float)Math.Pow(2.0, i);
        }
        if (array[values.Length - 1] > 1f)
        {
            array[values.Length - 1] = 1f;
        }
        array = array.Reverse().ToArray();
        int index = 0;
        switch (likelihood)
        {
            case Likelihood.Balanced:
                index = Random.Range(0, values.Length);
                break;
            case Likelihood.MostToLeast:
                {
                    int num2 = Random.Range(0, 100);
                    for (int k = 0; k < array.Length; k++)
                    {
                        if ((float)num2 < array[k])
                        {
                            index = array.Length - 1 - k;
                            break;
                        }
                    }
                    break;
                }
            case Likelihood.LeastToMost:
                {
                    int num = Random.Range(0, 100);
                    for (int j = 0; j < array.Length; j++)
                    {
                        if ((float)num < array[j])
                        {
                            index = j;
                            break;
                        }
                    }
                    break;
                }
        }
        return (T)values.GetValue(index);
    }

    public static float GetPercentageBetweenValues(float inVal, float minVal, float maxVal)
    {
        return Mathf.Clamp01((inVal - minVal) / (maxVal - minVal));
    }

    public static float GetPercentageBetweenValues(this Vector2 inVec, float inVal)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        return Mathf.Clamp01((inVal - inVec.x) / (inVec.y - inVec.x));
    }

    public static float GetValueAtPercentage(this Vector2 inVec, float percentage)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return inVec.x + (inVec.y - inVec.x) * percentage;
    }

    public static float Clamp(this Vector2 inVec, float inVal)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        return Mathf.Clamp(inVal, inVec.x, inVec.y);
    }

    public static Vector3 ToVec3(this Vector2 inVec)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(inVec.x, inVec.y, 0f);
    }

    public static bool IsWithinThreshold(float value, float compareTo, float threshold)
    {
        if (value <= compareTo + threshold && value >= compareTo - threshold)
        {
            return true;
        }
        return false;
    }

    public static Texture2D FlipTexture(this Texture2D original)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Expected O, but got Unknown
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        Texture2D val = new Texture2D(((Texture)original).width, ((Texture)original).height);
        int width = ((Texture)original).width;
        int height = ((Texture)original).height;
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < height; j++)
            {
                val.SetPixel(width - i - 1, j, original.GetPixel(i, j));
            }
        }
        val.Apply();
        return val;
    }

    public static Texture2D ToTexture2D(this Texture texture)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Expected O, but got Unknown
        Texture2D val = new Texture2D(texture.width, texture.height, (TextureFormat)4, false);
        RenderTexture active = RenderTexture.active;
        RenderTexture temporary = RenderTexture.GetTemporary(texture.width, texture.height, 32);
        Graphics.Blit(texture, temporary);
        RenderTexture.active = temporary;
        val.ReadPixels(new Rect(0f, 0f, (float)((Texture)temporary).width, (float)((Texture)temporary).height), 0, 0);
        val.Apply();
        RenderTexture.active = active;
        RenderTexture.ReleaseTemporary(temporary);
        return val;
    }

    public static Vector3 RandomPointInRectTransform(RectTransform rectTransform)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0052: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        Rect rect = rectTransform.rect;
        float x = ((rect)).x;
        rect = rectTransform.rect;
        float x2 = ((rect)).x;
        rect = rectTransform.rect;
        float num = Random.Range(x, x2 + ((rect)).width);
        rect = rectTransform.rect;
        float y = ((rect)).y;
        rect = rectTransform.rect;
        float y2 = ((rect)).y;
        rect = rectTransform.rect;
        return new Vector3(num, Random.Range(y, y2 + ((rect)).height), 0f);
    }

    public static T RandomEnumValue<T>()
    {
        Array values = Enum.GetValues(typeof(T));
        return (T)values.GetValue(Random.Range(0, values.Length));
    }

    public static T RandomValueFromList<T>(this List<T> list)
    {
        return list[Random.Range(0, list.Count)];
    }

    public static T GetEnumValue<T>(string valueName)
    {
        return (T)Enum.Parse(typeof(T), valueName);
    }

    public static Vector2 GetCharPosition(this TextMeshPro text, int index)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        ((Component)text).GetComponent<Transform>();
        _ = Vector3.zero;
        _ = Vector3.zero;
        TMP_TextInfo textInfo = ((TMP_Text)text).textInfo;
        if (index < 0 || index >= textInfo.characterInfo.Length)
        {
            return Vector2.zero;
        }
        TMP_CharacterInfo val = textInfo.characterInfo[index];
        return ((val.topLeft + val.topRight + val.bottomLeft + val.bottomRight) / 4f);
    }

    public static bool HasReachedDestination(this NavMeshAgent agent)
    {
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        float num = 0.2f;
        if (agent.remainingDistance != float.PositiveInfinity && ((Component)agent).transform.position.PlanarDistance(agent.destination, Axis.Y) < num)
        {
            return true;
        }
        return false;
    }

    public static Vector3 GetRandomPointOnNavMesh(this NavMeshAgent agent, float maxWalkDist)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        NavMeshHit val = default(NavMeshHit);
        NavMesh.SamplePosition(Random.insideUnitSphere * maxWalkDist + ((Component)agent).transform.position, ref val, maxWalkDist, 1);
        return ((val)).position;
    }

    public static string SpiltAndCamelCase(this string inString)
    {
        string text = new Regex("\r\n                (?<=[A-Z])(?=[A-Z][a-z]) |\r\n                 (?<=[^A-Z])(?=[A-Z]) |\r\n                 (?<=[A-Za-z])(?=[^A-Za-z])", RegexOptions.IgnorePatternWhitespace).Replace(inString, " ");
        return char.ToUpper(text[0]) + text.Substring(1);
    }

    public static Vector3 GetSignedVec3(this Vector3 inVector)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(GetSignedAngle(inVector.x), GetSignedAngle(inVector.y), GetSignedAngle(inVector.z));
    }

    public static bool IsInCameraView(this Camera cam, Vector3 position, float border = 0f)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = cam.WorldToViewportPoint(position);
        if (val.x >= 0f - border && val.x <= 1f + border && val.y >= 0f - border && val.y <= 1f + border)
        {
            return val.z > 0f;
        }
        return false;
    }

    public static float GetSignedAngle(float inAngle)
    {
        float num = inAngle;
        bool flag = false;
        do
        {
            flag = true;
            if (num < -180f)
            {
                num += 360f;
            }
            else if (inAngle > 180f)
            {
                num -= 360f;
            }
        }
        while (!flag);
        return num;
    }

    public static T RandomValueFromList<T>(this T[] list)
    {
        return list[Random.Range(0, list.Length)];
    }

    public static T RandomValueFromList<T>(List<T> listA, List<T> ignoreFromListA)
    {
        List<T> list = listA.Except(ignoreFromListA).ToList();
        return list[Random.Range(0, list.Count)];
    }

    public static float RoundToNearestMultiple(this float value, float factor)
    {
        return (float)(int)Math.Round((double)value / (double)factor, MidpointRounding.AwayFromZero) * factor;
    }

    public static float Truncate(this float value, int digits)
    {
        double num = Math.Pow(10.0, digits);
        return (float)(Math.Truncate(num * (double)value) / num);
    }

    public static float PingPong(float timeValue, float minValue, float maxValue)
    {
        return Mathf.PingPong(timeValue, maxValue - minValue) + minValue;
    }

    public static IEnumerator ScaleObject(GameObject gameObj, float aValue, float aTime)
    {
        Vector3 currentScale = gameObj.transform.localScale;
        Vector3 localScale = default(Vector3);
        for (float t = 0f; t < 1f; t += Time.deltaTime / aTime)
        {
            ((localScale))..ctor(Mathf.Lerp(currentScale.x, aValue, t), Mathf.Lerp(currentScale.x, aValue, t), Mathf.Lerp(currentScale.x, aValue, t));
            gameObj.transform.localScale = localScale;
            yield return null;
        }
    }

    public static GameObject FindObject(this GameObject parent, string name)
    {
        Component[] componentsInChildren = parent.GetComponentsInChildren(typeof(Transform), true);
        Transform[] array = (Transform[])(object)new Transform[componentsInChildren.Length];
        for (int i = 0; i < componentsInChildren.Length; i++)
        {
            array[i] = componentsInChildren[i].transform;
        }
        Transform[] array2 = array;
        foreach (Transform val in array2)
        {
            if ((val).name == name)
            {
                return ((Component)val).gameObject;
            }
        }
        return null;
    }

    public static void Update<TSource>(this IEnumerable<TSource> outer, System.Action<TSource> updator)
    {
        foreach (TSource item in outer)
        {
            updator(item);
        }
    }

    public static bool Approximately(this Quaternion quatA, Quaternion value, float acceptableRange)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return 1f - Mathf.Abs(Quaternion.Dot(quatA, value)) < acceptableRange;
    }

    public static T Next<T>(this T src) where T : struct
    {
        if (!typeof(T).IsEnum)
        {
            throw new ArgumentException($"Argument {typeof(T).FullName} is not an Enum");
        }
        T[] array = (T[])Enum.GetValues(src.GetType());
        int num = Array.IndexOf(array, src) + 1;
        if (array.Length != num)
        {
            return array[num];
        }
        return array[0];
    }

    public static Vector3 Multiply(this Vector3 src, Vector3 vector)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(src.x * vector.x, src.y * vector.y, src.z * vector.z);
    }

    public static Vector3 ToVector3(this Color src)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(src.r, src.g, src.b);
    }

    public static Color ToColour(this Vector3 src, float alpha = 1f)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        return new Color(src.x, src.y, src.z, alpha);
    }

    public static Color ColourFromVector3(Vector3 src)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        return new Color(src.x, src.y, src.z);
    }

    public static void CopyFrom(this Transform toEdit, Transform copyFrom)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        ((Component)toEdit).transform.parent = copyFrom.parent;
        ((Component)toEdit).transform.localScale = copyFrom.localScale;
        ((Component)toEdit).transform.localRotation = copyFrom.localRotation;
        ((Component)toEdit).transform.localPosition = copyFrom.localPosition;
    }

    public static void CopyFrom(this RectTransform objRectTransform, RectTransform rectTransform)
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        ((Component)objRectTransform).transform.parent = ((Transform)rectTransform).parent;
        objRectTransform.anchorMin = rectTransform.anchorMin;
        objRectTransform.anchorMax = rectTransform.anchorMax;
        objRectTransform.anchoredPosition = rectTransform.anchoredPosition;
        objRectTransform.sizeDelta = rectTransform.sizeDelta;
        ((Transform)objRectTransform).localPosition = ((Transform)rectTransform).localPosition;
    }

    public static Vector3 RotateAround(this Vector3 point, Vector3 pivot, Vector3 angle)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = point - pivot;
        val = Quaternion.Euler(angle) * val;
        point = val + pivot;
        return point;
    }

    public static Color ScaleToOne(this Color src)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        return new Color((src.r > 1f) ? (src.r / 235f) : src.r, (src.g > 1f) ? (src.g / 235f) : src.g, (src.b > 1f) ? (src.b / 235f) : src.b, (src.a > 1f) ? (src.a / 235f) : src.a);
    }

    public static string ConvertToString(this char[] charArray)
    {
        string text = "";
        for (int i = 0; i < charArray.Length; i++)
        {
            text += charArray[i];
        }
        return text;
    }

    public static void SetLayerRecursively(this GameObject src, int newLayer)
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        src.layer = newLayer;
        foreach (Transform item in src.transform)
        {
            ((Component)item).gameObject.SetLayerRecursively(newLayer);
        }
    }

    public static float SignedAngleBetween(Vector3 vector1, Vector3 vector2, Vector3 normal)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        float num = Vector3.Angle(vector1, vector2);
        float num2 = Mathf.Sign(Vector3.Dot(normal, Vector3.Cross(vector1, vector2)));
        return num * num2;
    }

    public static float UnsignedAngleBetween(Vector3 vector1, Vector3 vector2, Vector3 normal)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        float num = Vector3.Angle(vector1, vector2);
        float num2 = Mathf.Sign(Vector3.Dot(normal, Vector3.Cross(vector1, vector2)));
        return (num * num2 + 180f) % 360f;
    }

    public static Vector3 GetDirTowardsPoint(this Vector3 ownPos, Vector3 pointTowards)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = pointTowards - ownPos;
        return ((val)).normalized;
    }

    public static Vector3 GetDirAwayFromPoint(this Vector3 ownPos, Vector3 pointAway)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = ownPos - pointAway;
        return ((val)).normalized;
    }

    public static void Reset(this Transform inTransform)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        inTransform.localPosition = Vector3.zero;
        inTransform.localRotation = Quaternion.identity;
        inTransform.localScale = Vector3.one;
    }

    public static void Reset(this RectTransform rectTransform)
    {
        ((Component)rectTransform).transform.Reset();
        rectTransform.SetInsetAndSizeFromParentEdge((Edge)3, 0f, 0f);
        rectTransform.SetInsetAndSizeFromParentEdge((Edge)2, 0f, 0f);
        rectTransform.SetInsetAndSizeFromParentEdge((Edge)0, 0f, 0f);
        rectTransform.SetInsetAndSizeFromParentEdge((Edge)1, 0f, 0f);
    }

    public static T[] RangeSubset<T>(this T[] array, int startIndex, int length)
    {
        T[] array2 = new T[length];
        Array.Copy(array, startIndex, array2, 0, length);
        return array2;
    }

    public static T[] Subset<T>(this T[] array, params int[] indices)
    {
        T[] array2 = new T[indices.Length];
        for (int i = 0; i < indices.Length; i++)
        {
            array2[i] = array[indices[i]];
        }
        return array2;
    }

    public static bool IsValidEmail(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
        {
            return false;
        }
        try
        {
            email = Regex.Replace(email, "(@)(.+)$", DomainMapper, RegexOptions.None, TimeSpan.FromMilliseconds(200.0));
        }
        catch (RegexMatchTimeoutException)
        {
            return false;
        }
        catch (ArgumentException)
        {
            return false;
        }
        try
        {
            return Regex.IsMatch(email, "^(?(\")(\".+?(?<!\\\\)\"@)|(([0-9a-z]((\\.(?!\\.))|[-!#\\$%&'\\*\\+/=\\?\\^`\\{\\}\\|~\\w])*)(?<=[0-9a-z])@))(?(\\[)(\\[(\\d{1,3}\\.){3}\\d{1,3}\\])|(([0-9a-z][-0-9a-z]*[0-9a-z]*\\.)+[a-z0-9][\\-a-z0-9]{0,22}[a-z0-9]))$", RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(250.0));
        }
        catch (RegexMatchTimeoutException)
        {
            return false;
        }
        static string DomainMapper(Match match)
        {
            string ascii = new IdnMapping().GetAscii(match.Groups[2].Value);
            return match.Groups[1].Value + ascii;
        }
    }
}
public static class PasswordCheck
{
    public enum PasswordStrength
    {
        Blank,
        VeryWeak,
        Weak,
        Medium,
        Strong,
        VeryStrong
    }

    public struct PasswordOptions
    {
        public int RequiredLength;

        public int RequiredUniqueChars;

        public bool RequireNonAlphanumeric;

        public bool RequireLowercase;

        public bool RequireUppercase;

        public bool RequireDigit;
    }

    public static PasswordStrength GetPasswordStrength(string password)
    {
        int num = 0;
        if (string.IsNullOrEmpty(password) || string.IsNullOrEmpty(password.Trim()))
        {
            return PasswordStrength.Blank;
        }
        if (HasMinimumLength(password, 5))
        {
            num++;
        }
        if (HasMinimumLength(password, 8))
        {
            num++;
        }
        if (HasUpperCaseLetter(password) && HasLowerCaseLetter(password))
        {
            num++;
        }
        if (HasDigit(password))
        {
            num++;
        }
        if (HasSpecialChar(password))
        {
            num++;
        }
        return (PasswordStrength)num;
    }

    public static bool IsStrongPassword(string password)
    {
        if (HasMinimumLength(password, 8) && HasUpperCaseLetter(password) && HasLowerCaseLetter(password))
        {
            if (!HasDigit(password))
            {
                return HasSpecialChar(password);
            }
            return true;
        }
        return false;
    }

    public static bool IsValidPassword(string password, PasswordOptions opts)
    {
        return IsValidPassword(password, opts.RequiredLength, opts.RequiredUniqueChars, opts.RequireNonAlphanumeric, opts.RequireLowercase, opts.RequireUppercase, opts.RequireDigit);
    }

    public static bool IsValidPassword(string password, int requiredLength, int requiredUniqueChars, bool requireNonAlphanumeric, bool requireLowercase, bool requireUppercase, bool requireDigit)
    {
        if (!HasMinimumLength(password, requiredLength))
        {
            return false;
        }
        if (!HasMinimumUniqueChars(password, requiredUniqueChars))
        {
            return false;
        }
        if (requireNonAlphanumeric && !HasSpecialChar(password))
        {
            return false;
        }
        if (requireLowercase && !HasLowerCaseLetter(password))
        {
            return false;
        }
        if (requireUppercase && !HasUpperCaseLetter(password))
        {
            return false;
        }
        if (requireDigit && !HasDigit(password))
        {
            return false;
        }
        return true;
    }

    public static bool HasMinimumLength(string password, int minLength)
    {
        return password.Length >= minLength;
    }

    public static bool HasMinimumUniqueChars(string password, int minUniqueChars)
    {
        return password.Distinct().Count() >= minUniqueChars;
    }

    public static bool HasDigit(string password)
    {
        return password.Any((char c) => char.IsDigit(c));
    }

    public static bool HasSpecialChar(string password)
    {
        return password.IndexOfAny("!@#$%^&*?_~-£().,".ToCharArray()) != -1;
    }

    public static bool HasUpperCaseLetter(string password)
    {
        return password.Any((char c) => char.IsUpper(c));
    }

    public static bool HasLowerCaseLetter(string password)
    {
        return password.Any((char c) => char.IsLower(c));
    }
}
public class GenericCompare<T> : IComparer<T>
{
    public Func<T, T, int> ComparerFunction { get; set; }

    public GenericCompare(Func<T, T, int> comparerFunction)
    {
        ComparerFunction = comparerFunction;
    }

    public int Compare(T x, T y)
    {
        if (x == null || y == null)
        {
            if (y == null && x == null)
            {
                return 0;
            }
            if (y == null)
            {
                return 1;
            }
            if (x == null)
            {
                return -1;
            }
        }
        try
        {
            return ComparerFunction(x, y);
        }
        catch (Exception)
        {
        }
        return 0;
    }
}
public static class AspectRatio
{
    public static Vector2 GetAspectRatio(int x, int y)
    {
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        float num = (float)x / (float)y;
        int num2 = 0;
        do
        {
            num2++;
        }
        while (Math.Round(num * (float)num2, 2) != (double)Mathf.RoundToInt(num * (float)num2));
        return new Vector2((float)Math.Round(num * (float)num2, 2), (float)num2);
    }

    public static Vector2 GetAspectRatio(Vector2 xy)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        float num = xy.x / xy.y;
        int num2 = 0;
        do
        {
            num2++;
        }
        while (Math.Round(num * (float)num2, 2) != (double)Mathf.RoundToInt(num * (float)num2));
        return new Vector2((float)Math.Round(num * (float)num2, 2), (float)num2);
    }

    public static Vector2 GetAspectRatio(int x, int y, bool debug)
    {
        //IL_009a: Unknown result type (might be due to invalid IL or missing references)
        float num = (float)x / (float)y;
        int num2 = 0;
        do
        {
            num2++;
        }
        while (Math.Round(num * (float)num2, 2) != (double)Mathf.RoundToInt(num * (float)num2));
        if (debug)
        {
            Debug.Log(("Aspect ratio is " + num * (float)num2 + ":" + num2 + " (Resolution: " + x + "x" + y + ")"));
        }
        return new Vector2((float)Math.Round(num * (float)num2, 2), (float)num2);
    }

    public static Vector2 GetAspectRatio(Vector2 xy, bool debug)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ac: Unknown result type (might be due to invalid IL or missing references)
        float num = xy.x / xy.y;
        int num2 = 0;
        do
        {
            num2++;
        }
        while (Math.Round(num * (float)num2, 2) != (double)Mathf.RoundToInt(num * (float)num2));
        if (debug)
        {
            Debug.Log(("Aspect ratio is " + num * (float)num2 + ":" + num2 + " (Resolution: " + xy.x + "x" + xy.y + ")"));
        }
        return new Vector2((float)Math.Round(num * (float)num2, 2), (float)num2);
    }
}
public class VirtualPointer : MonoBehaviourSingleton<VirtualPointer>
{
    public static void Hide()
    {
        if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            ((Component)MonoBehaviourSingleton<VirtualPointer>.instance).gameObject.SetActive(false);
        }
    }

    public static void Show()
    {
        if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            ((Component)MonoBehaviourSingleton<VirtualPointer>.instance).gameObject.SetActive(true);
        }
    }
}
[CreateAssetMenu(fileName = "Add Attack Effect", menuName = "Card Scripts/Add Attack Effect")]
public class CardScriptAddAttackEffect : CardScript
{
    [SerializeField]
    public StatusEffectData effect;

    [SerializeField]
    public Vector2Int countRange;

    public override void Run(CardData target)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        target.attackEffects = IArrayExt.With<CardData.StatusEffectStacks>(target.attackEffects, new CardData.StatusEffectStacks(effect, Vector2IntExt.Random(countRange)));
    }
}
[CreateAssetMenu(fileName = "Add Damage Equal To Health", menuName = "Card Scripts/Add Damage Equal To Health")]
public class CardScriptAddDamageEqualToHealth : CardScript
{
    public override void Run(CardData target)
    {
        target.damage += target.hp;
    }
}
[CreateAssetMenu(fileName = "Add Passive Effect", menuName = "Card Scripts/Add Passive Effect")]
public class CardScriptAddPassiveEffect : CardScript
{
    [SerializeField]
    public StatusEffectData effect;

    [SerializeField]
    public Vector2Int countRange;

    public override void Run(CardData target)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        target.startWithEffects = IArrayExt.With<CardData.StatusEffectStacks>(target.startWithEffects, new CardData.StatusEffectStacks(effect, Vector2IntExt.Random(countRange)));
    }
}
[CreateAssetMenu(fileName = "Add Random Boost", menuName = "Card Scripts/Add Boost")]
public class CardScriptAddRandomBoost : CardScript
{
    [SerializeField]
    public Vector2Int boostRange;

    public override void Run(CardData target)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        int num = Vector2IntExt.Random(boostRange);
        if (num == 0)
        {
            return;
        }
        CardData.StatusEffectStacks[] attackEffects = target.attackEffects;
        foreach (CardData.StatusEffectStacks statusEffectStacks in attackEffects)
        {
            statusEffectStacks.count = Mathf.Max(1, statusEffectStacks.count + num);
        }
        attackEffects = target.startWithEffects;
        foreach (CardData.StatusEffectStacks statusEffectStacks2 in attackEffects)
        {
            if (!statusEffectStacks2.data.visible)
            {
                statusEffectStacks2.count = Mathf.Max(1, statusEffectStacks2.count + num);
            }
        }
        foreach (CardData.TraitStacks trait in target.traits)
        {
            if (trait.data.keyword.canStack)
            {
                trait.count = Mathf.Max(1, trait.count + num);
            }
        }
    }
}
[CreateAssetMenu(fileName = "Add Random Counter", menuName = "Card Scripts/Add Counter")]
public class CardScriptAddRandomCounter : CardScript
{
    [SerializeField]
    public Vector2Int counterRange;

    public override void Run(CardData target)
    {
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        if (target.counter >= 1)
        {
            target.counter += Vector2IntExt.Random(counterRange);
            target.counter = Mathf.Max(1, target.counter);
        }
    }
}
[CreateAssetMenu(fileName = "Add Random Damage", menuName = "Card Scripts/Add Damage")]
public class CardScriptAddRandomDamage : CardScript
{
    [SerializeField]
    public Vector2Int damageRange;

    public override void Run(CardData target)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        if (target.hasAttack)
        {
            target.damage += Vector2IntExt.Random(damageRange);
            target.damage = Mathf.Max(0, target.damage);
        }
    }
}
[CreateAssetMenu(fileName = "Add Random Health", menuName = "Card Scripts/Add Health")]
public class CardScriptAddRandomHealth : CardScript
{
    [SerializeField]
    public Vector2Int healthRange;

    public override void Run(CardData target)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        if (target.hasHealth)
        {
            target.hp += Vector2IntExt.Random(healthRange);
            target.hp = Mathf.Max(1, target.hp);
        }
    }
}
[CreateAssetMenu(fileName = "Add Trait", menuName = "Card Scripts/Add Trait")]
public class CardScriptAddTrait : CardScript
{
    [SerializeField]
    public TraitData trait;

    [SerializeField]
    public Vector2Int countRange;

    [SerializeField]
    public bool @override = true;

    public override void Run(CardData target)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_010d: Unknown result type (might be due to invalid IL or missing references)
        if (Vector2IntExt.Random(countRange) <= 0)
        {
            return;
        }
        for (int num = target.traits.Count - 1; num >= 0; num--)
        {
            CardData.TraitStacks traitStacks = target.traits[num];
            if (IArrayExt.Contains<TraitData>(trait.overrides, traitStacks.data))
            {
                if (!@override)
                {
                    Debug.Log(("Cannot add [" + (trait).name + "] because of [" + (traitStacks.data).name + "]"));
                    return;
                }
                target.traits.RemoveAt(num);
                Debug.Log(("[" + (trait).name + "] overrides [" + (traitStacks.data).name + "]"));
            }
        }
        target.traits.Add(new CardData.TraitStacks
        {
            data = trait,
            count = Vector2IntExt.Random(countRange)
        });
    }
}
[CreateAssetMenu(fileName = "Become Basic Item Card", menuName = "Card Scripts/Become Basic Item Card")]
public class CardScriptBecomeBasicItemCard : CardScript
{
    public override void Run(CardData target)
    {
        target.playType = Card.PlayType.Play;
        target.needsTarget = true;
        target.canPlayOnBoard = true;
        target.canPlayOnHand = false;
        target.canPlayOnFriendly = true;
        target.canPlayOnEnemy = true;
        target.playOnSlot = false;
        target.defaultPlayPosition = CardData.PlayPosition.None;
    }
}
[CreateAssetMenu(fileName = "Boost Attack Effects Or Damage", menuName = "Card Scripts/Boost Attack Effects Or Damage")]
public class CardScriptBoostAttackEffectsOrAttack : CardScript
{
    [SerializeField]
    public Vector2Int range = new Vector2Int(2, 2);

    [SerializeField]
    public float reducePerCharm = 0.5f;

    public override void Run(CardData target)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        int num = Vector2IntExt.Random(range);
        List<CardUpgradeData> upgrades = target.upgrades;
        if (upgrades != null && upgrades.Count > 0)
        {
            float num2 = num;
            foreach (CardUpgradeData upgrade in target.upgrades)
            {
                if (upgrade.type == CardUpgradeData.Type.Charm)
                {
                    num2 -= reducePerCharm;
                    if (num2 <= 0f)
                    {
                        break;
                    }
                }
            }
            num = Mathf.CeilToInt(num2);
        }
        if (num <= 0)
        {
            return;
        }
        int num3 = (int)Mathf.Sign((float)num);
        if (target.attackEffects.Length != 0)
        {
            while (num > 0)
            {
                CardData.StatusEffectStacks[] attackEffects = target.attackEffects;
                foreach (CardData.StatusEffectStacks statusEffectStacks in attackEffects)
                {
                    statusEffectStacks.count = Mathf.Max(1, statusEffectStacks.count + num3);
                    if (--num <= 0)
                    {
                        break;
                    }
                }
            }
        }
        else if (target.hasAttack)
        {
            target.damage += num;
            target.damage = Mathf.Max(0, target.damage);
        }
    }
}
[CreateAssetMenu(fileName = "Copy Effects From Other Card In Deck", menuName = "Card Scripts/Copy Effects From Other Card In Deck")]
public class CardScriptCopyEffectsFromOtherCardInDeck : CardScript
{
    [SerializeField]
    public bool includeReserve = true;

    [SerializeField]
    public string[] eligibleTypes = new string[2] { "Leader", "Friendly" };

    public override void Run(CardData target)
    {
        List<CardData> list = new List<CardData>();
        list.AddRange(References.PlayerData.inventory.deck.Where((CardData a) => IArrayExt.Contains<string>(eligibleTypes, a.cardType.tag) && a != target));
        if (includeReserve)
        {
            list.AddRange(References.PlayerData.inventory.reserve.Where((CardData a) => IArrayExt.Contains<string>(eligibleTypes, a.cardType.tag) && a != target));
        }
        if (list.Count > 0)
        {
            GainEffects(target, IListExt.TakeRandom<CardData>((IList<CardData>)list));
        }
    }

    public static void GainEffects(CardData target, CardData toCopy)
    {
        target.attackEffects = CardData.StatusEffectStacks.Stack(target.attackEffects, toCopy.attackEffects);
        target.startWithEffects = CardData.StatusEffectStacks.Stack(target.startWithEffects, toCopy.startWithEffects.Where((CardData.StatusEffectStacks a) => !a.data.isStatus && a.data.HasDescOrIsKeyword));
        CardData.TraitStacks.Stack(ref target.traits, toCopy.traits);
    }
}
[CreateAssetMenu(fileName = "Copy Previous Charm", menuName = "Card Scripts/Copy Previous Charm")]
public class CardScriptCopyPreviousCharm : CardScript
{
    [SerializeField]
    public string[] illegal;

    public override void Run(CardData target)
    {
        CardUpgradeData cardUpgradeData = target.upgrades.FindLast((CardUpgradeData a) => a.type == CardUpgradeData.Type.Charm && !IArrayExt.Contains<string>(illegal, (a).name));
        if ((cardUpgradeData))
        {
            cardUpgradeData.AdjustStats(target);
            cardUpgradeData.RunScripts(target);
            cardUpgradeData.AdjustEffectBonus(target);
            cardUpgradeData.GainEffects(target);
        }
    }
}
[CreateAssetMenu(fileName = "Destroy Card", menuName = "Card Scripts/Destroy Card")]
public class CardScriptDestroyCard : CardScript
{
    public override void Run(CardData target)
    {
        RemoveFromDeck(target);
        DestroyEntities(target);
    }

    public static void RemoveFromDeck(CardData target)
    {
        if (IListExt.RemoveWhere<CardData>((IList<CardData>)References.PlayerData.inventory.deck, (Predicate<CardData>)((CardData a) => target.id == a.id)))
        {
            Debug.Log(("[" + (target).name + "] Removed From Player's deck"));
        }
        else if (IListExt.RemoveWhere<CardData>((IList<CardData>)References.PlayerData.inventory.reserve, (Predicate<CardData>)((CardData a) => target.id == a.id)))
        {
            Debug.Log(("[" + (target).name + "] Removed From Player's reserve"));
        }
    }

    public static void DestroyEntities(CardData target)
    {
        Entity[] array = Object.FindObjectsOfType<Entity>();
        foreach (Entity entity in array)
        {
            if (entity.data == target)
            {
                ((Component)entity).gameObject.AddComponent<CardDestroyedConsume>().sortingLayer = "ParticlesFront";
                entity.RemoveFromContainers();
                entity.display.GetCanvas().sortingLayerName = "Inspect";
            }
        }
        Object.FindObjectOfType<DeckDisplaySequence>()?.UpdatePositions();
    }
}
[CreateAssetMenu(fileName = "Gain Attack Icon", menuName = "Card Scripts/Gain Attack Icon")]
public class CardScriptGainAttackIcon : CardScript
{
    public override void Run(CardData target)
    {
        target.hasAttack = true;
    }
}
[CreateAssetMenu(fileName = "Give Upgrade", menuName = "Card Scripts/Give Upgrade")]
public class CardScriptGiveUpgrade : CardScript
{
    [SerializeField]
    public CardUpgradeData upgradeData;

    public override void Run(CardData target)
    {
        if (upgradeData != null)
        {
            upgradeData.Clone().Assign(target);
        }
    }
}
[CreateAssetMenu(fileName = "Leader", menuName = "Card Scripts/Leader")]
public class CardScriptLeader : CardScript
{
    [SerializeField]
    public CharacterType[] characterTypeOptions;

    [SerializeField]
    public LeaderProfileData[] leaderProfileOptions;

    public override void Run(CardData target)
    {
        CharacterType characterType = IArrayExt.RandomItem<CharacterType>(characterTypeOptions);
        CharacterData characterData = new CharacterData
        {
            race = characterType.race,
            gender = characterType.gender
        };
        LeaderProfileData leaderProfileData = IArrayExt.RandomItem<LeaderProfileData>(leaderProfileOptions);
        leaderProfileData.Apply(characterType);
        target.backgroundSprite = leaderProfileData.GetRandomBackground();
        characterData.Randomize(characterType);
        leaderProfileData.UnApply(characterType);
        target.forceTitle = characterData.title;
        target.SetCustomData("CharacterData", characterData);
    }
}
[CreateAssetMenu(fileName = "Modify Upgrade Slots", menuName = "Card Scripts/Modify Upgrade Slots")]
public class CardScriptModifyCharmSlots : CardScript
{
    [SerializeField]
    public int addCharmSlots;

    public override void Run(CardData target)
    {
        if (addCharmSlots != 0)
        {
            if (target.customData != null && target.customData.TryGetValue("extraCharmSlots", out var value) && value is int num)
            {
                target.customData["extraCharmSlots"] = num + addCharmSlots;
            }
            else
            {
                target.SetCustomData("extraCharmSlots", addCharmSlots);
            }
        }
    }
}
[CreateAssetMenu(fileName = "Multiply Counter", menuName = "Card Scripts/Multiply Counter")]
public class CardScriptMultiplyCounter : CardScript
{
    [SerializeField]
    public float multiply;

    [SerializeField]
    public bool roundUp;

    public override void Run(CardData target)
    {
        target.counter = (roundUp ? Mathf.CeilToInt((float)target.counter * multiply) : Mathf.RoundToInt((float)target.counter * multiply));
        target.counter = Mathf.Max(1, target.counter);
    }
}
[CreateAssetMenu(fileName = "Multiply Health", menuName = "Card Scripts/Multiply Health")]
public class CardScriptMultiplyHealth : CardScript
{
    [SerializeField]
    public float multiply;

    [SerializeField]
    public bool roundUp;

    public override void Run(CardData target)
    {
        target.hp = (roundUp ? Mathf.CeilToInt((float)target.hp * multiply) : Mathf.RoundToInt((float)target.hp * multiply));
        target.hp = Mathf.Max(1, target.hp);
    }
}
[CreateAssetMenu(fileName = "Multiply Passive Effect", menuName = "Card Scripts/Multiply Passive Effect")]
public class CardScriptMultiplyPassiveEffect : CardScript
{
    [SerializeField]
    public StatusEffectData effect;

    [SerializeField]
    public float multiply = 1f;

    public override void Run(CardData target)
    {
        CardData.StatusEffectStacks[] startWithEffects = target.startWithEffects;
        foreach (CardData.StatusEffectStacks statusEffectStacks in startWithEffects)
        {
            if ((statusEffectStacks.data).name == (effect).name)
            {
                statusEffectStacks.count = Mathf.RoundToInt((float)statusEffectStacks.count * multiply);
            }
        }
    }
}
[CreateAssetMenu(fileName = "Remove Attack Effect", menuName = "Card Scripts/Remove Attack Effect")]
public class CardScriptRemoveAttackEffect : CardScript
{
    [SerializeField]
    public bool removeAll;

    [SerializeField]
    [HideIf("removeAll")]
    public StatusEffectData[] toRemove;

    public override void Run(CardData target)
    {
        if (removeAll)
        {
            target.attackEffects = Array.Empty<CardData.StatusEffectStacks>();
            return;
        }
        List<CardData.StatusEffectStacks> list = IArrayExt.ToList<CardData.StatusEffectStacks>(target.attackEffects);
        list.RemoveAll((CardData.StatusEffectStacks a) => IArrayExt.Contains<StatusEffectData>(toRemove, a.data));
        target.attackEffects = list.ToArray();
    }
}
[CreateAssetMenu(fileName = "Remove Passive Effect", menuName = "Card Scripts/Remove Passive Effect")]
public class CardScriptRemovePassiveEffect : CardScript
{
    [SerializeField]
    public bool removeAll;

    [SerializeField]
    [HideIf("removeAll")]
    public StatusEffectData[] toRemove;

    [SerializeField]
    [ShowIf("removeAll")]
    public bool excludingStatusEffects;

    [SerializeField]
    [ShowIf("removeAll")]
    public StatusEffectData[] excluding;

    [SerializeField]
    [ShowIf("removeAll")]
    public string[] excludingTypes;

    [InfoBox(/*Could not decode attribute arguments.*/)]
    [SerializeField]
    public int reduceStacks;

    public override void Run(CardData target)
    {
        List<CardData.StatusEffectStacks> list = IArrayExt.ToList<CardData.StatusEffectStacks>(target.startWithEffects);
        if (removeAll)
        {
            for (int num = list.Count - 1; num >= 0; num--)
            {
                CardData.StatusEffectStacks statusEffectStacks = list[num];
                if (!Exclude(statusEffectStacks.data) && (!excludingStatusEffects || !statusEffectStacks.data.isStatus))
                {
                    statusEffectStacks.count -= reduceStacks;
                    if (reduceStacks <= 0 || statusEffectStacks.count <= 0)
                    {
                        list.RemoveAt(num);
                    }
                }
            }
        }
        else if (reduceStacks <= 0)
        {
            list.RemoveAll((CardData.StatusEffectStacks a) => IArrayExt.Contains<StatusEffectData>(toRemove, a.data));
        }
        else
        {
            for (int num2 = list.Count - 1; num2 >= 0; num2--)
            {
                CardData.StatusEffectStacks statusEffectStacks2 = list[num2];
                if (IArrayExt.Contains<StatusEffectData>(toRemove, statusEffectStacks2.data))
                {
                    statusEffectStacks2.count -= reduceStacks;
                    if (statusEffectStacks2.count <= 0)
                    {
                        list.RemoveAt(num2);
                    }
                }
            }
        }
        target.startWithEffects = list.ToArray();
    }

    public bool Exclude(StatusEffectData effectData)
    {
        if (!IArrayExt.Contains<StatusEffectData>(excluding, effectData))
        {
            if (!StringExt.IsNullOrEmpty(effectData.type))
            {
                return IArrayExt.Contains<string>(excludingTypes, effectData.type);
            }
            return false;
        }
        return true;
    }
}
[CreateAssetMenu(fileName = "Remove Trait", menuName = "Card Scripts/Remove Trait")]
public class CardScriptRemoveTrait : CardScript
{
    [SerializeField]
    public bool removeAll;

    [SerializeField]
    [HideIf("removeAll")]
    public TraitData[] toRemove;

    [SerializeField]
    [ShowIf("removeAll")]
    public TraitData[] excluding;

    public override void Run(CardData target)
    {
        if (removeAll)
        {
            target.traits = target.traits.Where((CardData.TraitStacks a) => IArrayExt.Contains<TraitData>(excluding, a.data)).ToList();
            return;
        }
        List<CardData.TraitStacks> list = target.traits.ToList();
        list.RemoveAll((CardData.TraitStacks a) => IArrayExt.Contains<TraitData>(toRemove, a.data));
        target.traits = list.ToList();
    }
}
[CreateAssetMenu(fileName = "Replace Attack With Apply", menuName = "Card Scripts/Replace Attack With Apply")]
public class CardScriptReplaceAttackWithApply : CardScript
{
    [SerializeField]
    public StatusEffectData effect;

    public override void Run(CardData target)
    {
        if (target.hasAttack && target.damage > 0)
        {
            CardData.StatusEffectStacks[] newEffects = new CardData.StatusEffectStacks[1]
            {
                new CardData.StatusEffectStacks(effect, target.damage)
            };
            target.attackEffects = CardData.StatusEffectStacks.Stack(target.attackEffects, newEffects);
            target.damage = 0;
        }
    }
}
[CreateAssetMenu(fileName = "Round Health", menuName = "Card Scripts/Round Health")]
public class CardScriptRoundHealth : CardScript
{
    [SerializeField]
    [HideIf("floor")]
    public bool ceil = true;

    [SerializeField]
    [HideIf("ceil")]
    public bool floor;

    [SerializeField]
    public int round = 10;

    public override void Run(CardData target)
    {
        float num = (float)target.hp / (float)round;
        if (ceil)
        {
            target.hp = Mathf.CeilToInt(num) * round;
        }
        else if (floor)
        {
            target.hp = Mathf.FloorToInt(num) * round;
        }
        else
        {
            target.hp = Mathf.RoundToInt(num) * round;
        }
        target.hp = Mathf.Max(1, target.hp);
    }
}
[CreateAssetMenu(fileName = "Set Counter", menuName = "Card Scripts/Set Counter")]
public class CardScriptSetCounter : CardScript
{
    [SerializeField]
    public Vector2Int counterRange;

    public override void Run(CardData target)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        if (target.counter >= 1)
        {
            target.counter = Vector2IntExt.Random(counterRange);
            target.counter = Mathf.Max(1, target.counter);
        }
    }
}
[CreateAssetMenu(fileName = "Set Damage", menuName = "Card Scripts/Set Damage")]
public class CardScriptSetDamage : CardScript
{
    [SerializeField]
    public Vector2Int damageRange;

    public override void Run(CardData target)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        if (target.hasAttack)
        {
            target.damage = Vector2IntExt.Random(damageRange);
            target.damage = Mathf.Max(0, target.damage);
        }
    }
}
[CreateAssetMenu(fileName = "Set Health", menuName = "Card Scripts/Set Health")]
public class CardScriptSetHealth : CardScript
{
    [SerializeField]
    public Vector2Int healthRange;

    public override void Run(CardData target)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        if (target.hasHealth)
        {
            target.hp = Vector2IntExt.Random(healthRange);
            target.hp = Mathf.Max(1, target.hp);
        }
    }
}
[CreateAssetMenu(fileName = "Swap Effects Based On", menuName = "Card Scripts/Swap Effects Based On")]
public class CardScriptSwapEffectsBasedOn : CardScript
{
    [SerializeField]
    public StatusEffectData statusA;

    [SerializeField]
    public StatusEffectData statusB;

    public override void Run(CardData target)
    {
        CardData.StatusEffectStacks[] attackEffects = target.attackEffects;
        foreach (CardData.StatusEffectStacks statusEffectStacks in attackEffects)
        {
            if (statusEffectStacks.data.type == statusA.type)
            {
                statusEffectStacks.data = statusB;
            }
            else if (statusEffectStacks.data.type == statusB.type)
            {
                statusEffectStacks.data = statusA;
            }
            else if (statusEffectStacks.data is StatusEffectInstantDoubleX effect)
            {
                TrySwap(effect, statusEffectStacks, statusA, statusB);
            }

            attackEffects = target.startWithEffects;
            foreach (CardData.StatusEffectStacks startWithEffect in target.startWithEffects)
            {
                switch (startWithEffect.data)
                {
                    case StatusEffectApplyXWhenYAppliedTo effect1:
                        CardScriptSwapEffectsBasedOn.TrySwap(effect1, startWithEffect, this.statusA, this.statusB);
                        break;
                    case StatusEffectApplyXWhenYAppliedToAlly effect2:
                        CardScriptSwapEffectsBasedOn.TrySwap(effect2, startWithEffect, this.statusA, this.statusB);
                        break;
                    case StatusEffectApplyXWhenYAppliedToSelf effect3:
                        CardScriptSwapEffectsBasedOn.TrySwap(effect3, startWithEffect, this.statusA, this.statusB);
                        break;
                    case StatusEffectApplyX effect4:
                        CardScriptSwapEffectsBasedOn.TrySwap(effect4, startWithEffect, this.statusA, this.statusB);
                        break;
                    case StatusEffectBonusDamageEqualToX effect5:
                        CardScriptSwapEffectsBasedOn.TrySwap(effect5, startWithEffect, this.statusA, this.statusB);
                        break;
                }
            }
        }
    }

    public static bool Swap(CardData.StatusEffectStacks stacks, StatusEffectData a, StatusEffectData b)
    {
        string text = (stacks.data).name.Replace((a).name, (b).name);
        StatusEffectData statusEffectData = AddressableLoader.Get<StatusEffectData>("StatusEffectData", text);
        if ((statusEffectData))
        {
            stacks.data = statusEffectData;
            return true;
        }
        Debug.LogError(("[" + text + "] effect does not exist! Cannot swap effect [" + (stacks.data).name + "] :("));
        return false;
    }

    public static void TrySwap(StatusEffectInstantDoubleX effect, CardData.StatusEffectStacks stacks, StatusEffectData a, StatusEffectData b)
    {
        if ((effect.statusToDouble))
        {
            if (effect.statusToDouble.type == a.type)
            {
                Swap(stacks, a, b);
            }
            else if (effect.statusToDouble.type == b.type)
            {
                Swap(stacks, b, a);
            }
        }
    }

    public static void TrySwap(StatusEffectApplyX effect, CardData.StatusEffectStacks stacks, StatusEffectData a, StatusEffectData b)
    {
        if ((effect.effectToApply))
        {
            if (effect.effectToApply.type == a.type)
            {
                Swap(stacks, a, b);
            }
            else if (effect.effectToApply.type == b.type)
            {
                Swap(stacks, b, a);
            }
        }
    }

    public static void TrySwap(StatusEffectApplyXWhenYAppliedTo effect, CardData.StatusEffectStacks stacks, StatusEffectData a, StatusEffectData b)
    {
        if (IArrayExt.Contains<string>(effect.whenAppliedTypes, a.type) || ((effect.effectToApply) && effect.effectToApply.type == a.type))
        {
            Swap(stacks, a, b);
        }
        else if (IArrayExt.Contains<string>(effect.whenAppliedTypes, b.type) || ((effect.effectToApply) && effect.effectToApply.type == b.type))
        {
            Swap(stacks, b, a);
        }
    }

    public static void TrySwap(StatusEffectApplyXWhenYAppliedToAlly effect, CardData.StatusEffectStacks stacks, StatusEffectData a, StatusEffectData b)
    {
        if (effect.whenAppliedType == a.type || ((effect.effectToApply) && effect.effectToApply.type == a.type))
        {
            Swap(stacks, a, b);
        }
        else if (effect.whenAppliedType == b.type || ((effect.effectToApply) && effect.effectToApply.type == b.type))
        {
            Swap(stacks, b, a);
        }
    }

    public static void TrySwap(StatusEffectApplyXWhenYAppliedToSelf effect, CardData.StatusEffectStacks stacks, StatusEffectData a, StatusEffectData b)
    {
        if (effect.whenAppliedType == a.type || ((effect.effectToApply) && effect.effectToApply.type == a.type))
        {
            Swap(stacks, a, b);
        }
        else if (effect.whenAppliedType == b.type || ((effect.effectToApply) && effect.effectToApply.type == b.type))
        {
            Swap(stacks, b, a);
        }
    }

    public static void TrySwap(StatusEffectBonusDamageEqualToX effect, CardData.StatusEffectStacks stacks, StatusEffectData a, StatusEffectData b)
    {
        if (effect.effectType == a.type)
        {
            Swap(stacks, a, b);
        }
        else if (effect.effectType == b.type)
        {
            Swap(stacks, b, a);
        }
    }
}
[CreateAssetMenu(fileName = "Swap Traits", menuName = "Card Scripts/Swap Traits")]
public class CardScriptSwapTraits : CardScript
{
    [SerializeField]
    public TraitData traitA;

    [SerializeField]
    public TraitData traitB;

    public override void Run(CardData target)
    {
        foreach (CardData.TraitStacks trait in target.traits)
        {
            if (trait.data == traitA)
            {
                trait.data = traitB;
            }
            else if (trait.data == traitB)
            {
                trait.data = traitA;
            }
        }
    }
}
public class TriggerBombard : Trigger
{
    public CardContainer[] slots;

    public TriggerBombard(Entity entity, Entity triggeredBy, string type, Entity[] targets, CardContainer[] slots)
        : base(entity, triggeredBy, type, targets)
    {
        this.slots = slots;
    }

    public override IEnumerator PreProcess()
    {
        List<Entity> list = new List<Entity>();
        CardContainer[] array = slots;
        for (int i = 0; i < array.Length; i++)
        {
            Entity top = array[i].GetTop();
            list.Add(top);
        }
        targets = list.ToArray();
        yield return StatusEffectSystem.PreCardPlayedEvent(entity, targets);
        TriggerBombard triggerBombard = this;
        Entity[] array2 = targets;
        triggerBombard.hits = new Hit[(array2 != null) ? array2.Length : 0];
        if (targets != null)
        {
            for (int j = 0; j < targets.Length; j++)
            {
                Hit hit = new Hit(entity, targets[j]);
                hit.AddAttackerStatuses();
                hit.trigger = this;
                hits[j] = hit;
            }
        }
        Hit[] array3 = hits;
        foreach (Hit hit2 in array3)
        {
            if ((hit2.target))
            {
                yield return StatusEffectSystem.PreAttackEvent(hit2);
            }
        }
    }

    public override IEnumerator Animate()
    {
        new Routine(AssetLoader.Lookup<CardAnimation>("CardAnimations", "BombardRocketShoot").Routine(entity));
        yield return Sequences.Wait(0.2f);
    }

    public override IEnumerator ProcessHits()
    {
        yield return RainRockets();
    }

    public IEnumerator RainRockets()
    {
        CardAnimation rocketAnimation = AssetLoader.Lookup<CardAnimation>("CardAnimations", "BombardRocket");
        Routine.Clump clump = new Routine.Clump();
        for (int i = 0; i < hits.Length; i++)
        {
            Hit hit = hits[i];
            CardContainer slot = slots[i];
            clump.Add(Fire(rocketAnimation, hit, slot));
            yield return Sequences.Wait(0.3f);
        }
        yield return clump.WaitForEnd();
    }

    public static IEnumerator Fire(CardAnimation rocketAnimation, Hit hit, CardContainer slot)
    {
        yield return rocketAnimation.Routine(((Component)slot).transform.position);
        if ((hit.target))
        {
            yield return Trigger.ProcessHit(hit);
        }
    }
}
public class Names : MonoBehaviourSingleton<Names>
{
    [Serializable]
    public struct Asset
    {
        public string name;

        public LocaleTextAsset[] files;
    }

    [Serializable]
    public class LocaleTextAsset
    {
        public Locale locale;

        public TextAsset textAsset;
    }

    [SerializeField]
    public Asset[] assets;

    public static Dictionary<string, TextAsset> files;

    public static readonly Dictionary<string, Queue<string>> lookup = new Dictionary<string, Queue<string>>();

    public static void Reset()
    {
        lookup.Clear();
    }

    public void OnEnable()
    {
        LocalizationSettings.Instance.OnSelectedLocaleChanged += LocaleChanged;
    }

    public void OnDisable()
    {
        LocalizationSettings.Instance.OnSelectedLocaleChanged -= LocaleChanged;
    }

    public static void LocaleChanged(Locale locale)
    {
        files = null;
        Reset();
    }

    public static string Pull(string key)
    {
        if (!lookup.ContainsKey(key))
        {
            Load(key);
        }
        Queue<string> queue = lookup[key];
        if (queue == null || queue.Count == 0)
        {
            Load(key);
            queue = lookup[key];
        }
        return queue.Dequeue();
    }

    public static string Pull(string characterRace, string characterGender)
    {
        return Pull(characterRace + characterGender);
    }

    public static void Load(string key)
    {
        List<string> list = new List<string>();
        string[] array = Regex.Split(GetFiles(key).text, "\r\n|\n|\r");
        foreach (string text in array)
        {
            list.Add(text.Trim());
        }
        IListExt.Shuffle<string>((IList<string>)list);
        lookup[key] = new Queue<string>(list);
    }

    public static TextAsset GetFiles(string key)
    {
        if (files == null)
        {
            files = new Dictionary<string, TextAsset>();
            Asset[] array = MonoBehaviourSingleton<Names>.instance.assets;
            for (int i = 0; i < array.Length; i++)
            {
                Asset asset = array[i];
                LocaleTextAsset localeTextAsset = asset.files.FirstOrDefault((LocaleTextAsset a) => (a.locale).name == (LocalizationSettings.SelectedLocale).name) ?? asset.files.First();
                files[asset.name] = localeTextAsset.textAsset;
            }
        }
        return files[key];
    }
}
public class Bolgo : ScriptableCardImage
{
    [SerializeField]
    public Image image;

    [Header("Scale Based On Damage")]
    [SerializeField]
    public AnimationCurve scaleCurve;

    [SerializeField]
    public AnimationCurve tweenCurve;

    [SerializeField]
    public float tweenDur;

    [Header("Set Sprite Based On Shell")]
    [SerializeField]
    public Sprite[] sprites;

    [SerializeField]
    public AnimationCurve spriteIndexCurve;

    public int currentShell;

    public bool currentDamageSet;

    public int currentDamage;

    public float scaleFrom = 1f;

    public float scaleTo = 1f;

    public float tweenT;

    public bool tween;

    public override void UpdateEvent()
    {
        if (!currentDamageSet || currentDamage != entity.damage.current)
        {
            currentDamageSet = true;
            currentDamage = entity.damage.current;
            SetScale();
        }
        int num = entity.FindStatus("shell")?.count ?? 0;
        if (num != currentShell)
        {
            currentShell = num;
            int num2 = Mathf.RoundToInt(Mathf.Clamp(spriteIndexCurve.Evaluate((float)currentShell), 0f, 1f) * ((float)sprites.Length - 1f));
            image.sprite = sprites[num2];
        }
    }

    public void SetScale()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        scaleFrom = Mathf.Lerp(1f, ((Component)image).transform.localScale.x, 0.5f);
        scaleTo = scaleCurve.Evaluate((float)currentDamage);
        StartScaleTween();
    }

    public void StartScaleTween()
    {
        tween = true;
        tweenT = 0f;
    }

    public void Update()
    {
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        if (tween)
        {
            tweenT += Time.deltaTime / tweenDur;
            float num = scaleFrom + tweenCurve.Evaluate(tweenT) * (scaleTo - scaleFrom);
            ((Component)image).transform.localScale = new Vector3(num, num, 1f);
            if (tweenT > 1f)
            {
                tween = false;
            }
        }
    }
}
public class Leader : ScriptableCardImage
{
    [SerializeField]
    public CharacterAvatar avatar;

    public override void AssignEvent()
    {
        avatar.UpdateDisplay(DictionaryExt.Get<CharacterData>(entity.data.customData, "CharacterData"));
    }
}
public class LilBerry : ScriptableCardImage
{
    [SerializeField]
    public Transform image;

    [SerializeField]
    public AnimationCurve scaleCurve;

    [Header("Scale Tween")]
    [SerializeField]
    public AnimationCurve tweenCurve;

    [SerializeField]
    public float tweenDur;

    public float scaleFrom = 1f;

    public float scaleTo = 1f;

    public float tweenT;

    public bool tween;

    public bool currentSet;

    public int current;

    public override void UpdateEvent()
    {
        if (!currentSet || current != entity.damage.current)
        {
            currentSet = true;
            current = entity.damage.current;
            SetScale();
        }
    }

    public void SetScale()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        scaleFrom = Mathf.Lerp(1f, image.localScale.x, 0.5f);
        scaleTo = scaleCurve.Evaluate((float)current);
        StartScaleTween();
    }

    public void StartScaleTween()
    {
        tween = true;
        tweenT = 0f;
    }

    public void Update()
    {
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        if (tween)
        {
            tweenT += Time.deltaTime / tweenDur;
            float num = scaleFrom + tweenCurve.Evaluate(tweenT) * (scaleTo - scaleFrom);
            ((Component)image).transform.localScale = new Vector3(num, num, 1f);
            if (tweenT > 1f)
            {
                tween = false;
            }
        }
    }
}
public class SnowBear : ScriptableCardImage
{
    [SerializeField]
    public Transform main;

    [SerializeField]
    public Transform ball;

    [SerializeField]
    public AnimationCurve curve;

    [SerializeField]
    public AnimationCurve ballScaleCurve;

    [SerializeField]
    public AnimationCurve ballYCurve;

    [SerializeField]
    public AnimationCurve yCurve;

    [Header("Tween")]
    [SerializeField]
    public AnimationCurve tweenCurve;

    [SerializeField]
    public float tweenDur;

    public float tweenFrom;

    public float tweenTo;

    public float tweenT;

    public bool tween;

    public bool currentSet;

    public int current;

    public override void UpdateEvent()
    {
        if (!currentSet || current != entity.damage.current)
        {
            currentSet = true;
            current = entity.damage.current;
            Set();
        }
    }

    public void Set()
    {
        tweenFrom = tweenTo;
        tweenTo = curve.Evaluate((float)current);
        StartTween();
    }

    public void StartTween()
    {
        tween = true;
        tweenT = 0f;
    }

    public void Update()
    {
        if (tween)
        {
            tweenT += Time.deltaTime / tweenDur;
            float progress = tweenFrom + tweenCurve.Evaluate(tweenT) * (tweenTo - tweenFrom);
            UpdateValues(progress);
            if (tweenT > 1f)
            {
                tween = false;
            }
        }
    }

    public void UpdateValues(float progress)
    {
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        float num = ballScaleCurve.Evaluate(progress);
        float num2 = ballYCurve.Evaluate(progress);
        float num3 = yCurve.Evaluate(progress);
        ball.localScale = new Vector3(num, num, 1f);
        ball.localPosition = Vector3Ext.WithY(ball.localPosition, num2);
        main.localPosition = Vector3Ext.WithY(main.localPosition, num3);
    }
}
public class StormGlobe : ScriptableCardImage
{
    [SerializeField]
    public Image image;

    [SerializeField]
    public Sprite[] sprites;

    [SerializeField]
    public AnimationCurve spriteIndexCurve;

    public int effectBonus;

    public override void UpdateEvent()
    {
        if (entity.effectBonus != effectBonus)
        {
            effectBonus = entity.effectBonus;
            int num = Mathf.Clamp(Mathf.RoundToInt(spriteIndexCurve.Evaluate((float)effectBonus)), 0, sprites.Length - 1);
            image.sprite = sprites[num];
        }
    }
}
[CreateAssetMenu(fileName = "Add Campaign Nodes", menuName = "Scripts/Add Campaign Nodes")]
public class ScriptAddCampaignNodes : Script
{
    [Serializable]
    public class Event
    {
        public CampaignNodeType type;

        public Vector2Int tierRange;
    }

    [SerializeField]
    public Event[] events;

    public override IEnumerator Run()
    {
        Routine.Clump clump = new Routine.Clump();
        Event[] array = events;
        foreach (Event @event in array)
        {
            int num = Vector2IntExt.Random(@event.tierRange);
            List<CampaignNode> list = new List<CampaignNode>();
            foreach (CampaignNode node2 in References.Campaign.nodes)
            {
                if (node2.tier == num && node2.type.interactable && node2.connections.Count > 1)
                {
                    list.Add(node2);
                }
            }
            CampaignNode campaignNode = IListExt.RandomItem<CampaignNode>((IList<CampaignNode>)list);
            int num2 = References.Campaign.nodes.IndexOf(campaignNode);
            CampaignNode campaignNode2 = new CampaignNode(@event.type, campaignNode.position.x, campaignNode.position.y, num, campaignNode.positionIndex, campaignNode.areaIndex, campaignNode.radius);
            References.Campaign.nodes.Insert(num2 + 1, campaignNode2);
            campaignNode2.id = num2;
            campaignNode2.connections = IListExt.Clone<CampaignNode.Connection>((IEnumerable<CampaignNode.Connection>)campaignNode.connections);
            int count = References.Campaign.nodes.Count;
            for (int j = num2 + 1; j < count; j++)
            {
                CampaignNode campaignNode3 = References.Campaign.nodes[j];
                campaignNode3.id++;
                foreach (CampaignNode.Connection connection in campaignNode3.connections)
                {
                    connection.otherId++;
                }
            }
            List<int> list2 = new List<int> { campaignNode2.id };
            while (list2.Count > 0)
            {
                CampaignNode node = Campaign.GetNode(list2[0]);
                node.position.x += 1f;
                list2.RemoveAt(0);
                foreach (int item in node.connections.Select((CampaignNode.Connection a) => a.otherId))
                {
                    if (!list2.Contains(item))
                    {
                        list2.Add(item);
                    }
                }
            }
            campaignNode.connections.Clear();
            campaignNode.ConnectTo(campaignNode2);
            clump.Add(campaignNode2.type.SetUp(campaignNode2));
        }
        yield return clump.WaitForEnd();
        CampaignGenerator.ShuffleNodes(References.Campaign.nodes);
    }
}
[CreateAssetMenu(fileName = "Add Enemies", menuName = "Scripts/Add Enemies")]
public class ScriptAddEnemies : Script
{
    [Serializable]
    public class Profile
    {
        public BattleData battleData;

        public int add = 2;

        public int toWave = 1;

        public bool randomPosition;

        public CardData[] pool;
    }

    [SerializeField]
    public Profile[] profiles;

    public override IEnumerator Run()
    {
        foreach (CampaignNode node in References.Campaign.nodes)
        {
            if (node.type.isBattle)
            {
                string targetBattleName = (string)node.data["battle"];
                Profile profile = profiles.FirstOrDefault((Profile a) => (a.battleData).name == targetBattleName);
                if (profile != null)
                {
                    BattleWaveManager.WaveData obj = node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves")[profile.toWave];
                    int count = obj.Count;
                    int insertPos = (profile.randomPosition ? Random.Range(0, count) : count);
                    InsertTo(obj, insertPos, profile.add, profile.pool);
                }
            }
        }
        yield break;
    }

    public static void InsertTo(BattleWaveManager.WaveData waveData, int insertPos, int count, CardData[] fromPool)
    {
        List<CardData> list = new List<CardData>();
        for (int i = 0; i < count; i++)
        {
            if (list.Count <= 0)
            {
                list.AddRange(fromPool);
            }
            CardData cardData = IListExt.TakeRandom<CardData>((IList<CardData>)list);
            if (waveData is BattleWaveManager.WaveDataFull)
            {
                waveData.InsertCard(insertPos, cardData.Clone());
            }
            else
            {
                waveData.InsertCard(insertPos, cardData);
            }
        }
    }
}
[CreateAssetMenu(fileName = "Add Random Cards", menuName = "Scripts/Add Random Cards")]
public class ScriptAddRandomCards : Script
{
    [SerializeField]
    public int replaceIndex = -1;

    [SerializeField]
    public bool anyCard;

    [SerializeField]
    [ShowIf("anyCard")]
    public CardType[] ofType;

    [SerializeField]
    [HideIf("anyCard")]
    public CardData[] pool;

    [SerializeField]
    public Vector2Int countRange;

    public override IEnumerator Run()
    {
        CardDataList deck = References.PlayerData.inventory.deck;
        if (replaceIndex >= 0)
        {
            deck.RemoveAt(replaceIndex);
        }
        List<CardData> list = new List<CardData>();
        int num = Vector2IntExt.Random(countRange);
        for (int i = 0; i < num; i++)
        {
            if (list.Count <= 0)
            {
                PopulateCardList(list);
            }
            CardData cardData = IListExt.TakeRandom<CardData>((IList<CardData>)list).Clone();
            Debug.Log((name + " → Adding [" + (cardData).name + "] to player's deck"));
            if (replaceIndex >= 0)
            {
                deck.Insert(replaceIndex, cardData);
            }
            else
            {
                deck.Add(cardData);
            }
        }
        yield break;
    }

    public void PopulateCardList(List<CardData> list)
    {
        if (anyCard)
        {
            RewardPool[] rewardPools = References.PlayerData.classData.rewardPools;
            for (int i = 0; i < rewardPools.Length; i++)
            {
                foreach (DataFile item in rewardPools[i].list)
                {
                    if (item is CardData cardData && IArrayExt.Contains<CardType>(ofType, cardData.cardType))
                    {
                        list.Add(cardData);
                    }
                }
            }
        }
        else
        {
            list.AddRange(pool);
        }
    }
}
[CreateAssetMenu(fileName = "Add Upgrades", menuName = "Scripts/Add Upgrades")]
public class ScriptAddUpgrades : Script
{
    [SerializeField]
    public int count = 1;

    [SerializeField]
    public CardUpgradeData[] upgradePool;

    [SerializeField]
    [HideIf("addToRandom")]
    public bool addToFirstEligible = true;

    [SerializeField]
    [HideIf("addToFirstEligible")]
    public bool addToRandom;

    [SerializeField]
    public bool ofCardType;

    [SerializeField]
    [ShowIf("ofCardType")]
    public CardType[] eligibleCardTypes;

    public override IEnumerator Run()
    {
        for (int i = 0; i < count; i++)
        {
            AddUpgrade();
        }
        yield break;
    }

    public void AddUpgrade()
    {
        foreach (CardUpgradeData item in IEnumerableExt.InRandomOrder<CardUpgradeData>((IEnumerable<CardUpgradeData>)upgradePool))
        {
            if (TryAddUpgrade(item))
            {
                break;
            }
        }
    }

    public bool TryAddUpgrade(CardUpgradeData upgradeData)
    {
        bool result = false;
        if (addToFirstEligible)
        {
            foreach (CardData item in References.PlayerData.inventory.deck)
            {
                if (Eligible(item) && upgradeData.CanAssign(item))
                {
                    upgradeData.Clone().Assign(item);
                    result = true;
                    break;
                }
            }
        }
        else if (addToRandom)
        {
            foreach (CardData item2 in IEnumerableExt.InRandomOrder<CardData>((IEnumerable<CardData>)References.PlayerData.inventory.deck))
            {
                if (Eligible(item2) && upgradeData.CanAssign(item2))
                {
                    upgradeData.Clone().Assign(item2);
                    result = true;
                    break;
                }
            }
        }
        else
        {
            References.PlayerData.inventory.upgrades.Add(upgradeData.Clone());
            result = true;
        }
        return result;
    }

    public bool Eligible(CardData cardData)
    {
        if (!ofCardType)
        {
            return true;
        }
        return IArrayExt.Contains<CardType>(eligibleCardTypes, cardData.cardType);
    }
}
[CreateAssetMenu(fileName = "Adjust Shop Prices", menuName = "Scripts/Adjust Shop Prices")]
public class ScriptAdjustShopPrices : Script
{
    [SerializeField]
    public Vector2Int cardPrices = new Vector2Int(5, 5);

    [SerializeField]
    public Vector2Int charmPrices = new Vector2Int(5, 5);

    [SerializeField]
    public Vector2Int charmMachinePrice = new Vector2Int(5, 5);

    [SerializeField]
    public Vector2Int charmMachineAddPrice = new Vector2Int(5, 5);

    [SerializeField]
    public Vector2Int crownPrice = new Vector2Int(5, 5);

    [SerializeField]
    public Vector2Int crownAddPrice = new Vector2Int(5, 5);

    public override IEnumerator Run()
    {
        foreach (CampaignNode node in References.Campaign.nodes)
        {
            CampaignNodeType type = node.type;
            if (!(type is CampaignNodeTypeShop))
            {
                if (!(type is CampaignNodeTypeCharmShop))
                {
                    continue;
                }
                EventRoutineCharmShop.Data data = DictionaryExt.Get<EventRoutineCharmShop.Data>(node.data, "data");
                foreach (EventRoutineCharmShop.UpgradedCard card in data.cards)
                {
                    card.price += Vector2IntExt.Random(cardPrices);
                }
                foreach (EventRoutineCharmShop.CharmShopItemData item in data.items)
                {
                    item.price += Vector2IntExt.Random(charmPrices);
                }
                continue;
            }
            ShopRoutine.Data data2 = DictionaryExt.Get<ShopRoutine.Data>(node.data, "shopData");
            data2.charmPrice += Vector2IntExt.Random(charmMachinePrice);
            data2.charmPriceAdd += Vector2IntExt.Random(charmMachineAddPrice);
            data2.crownPrice += Vector2IntExt.Random(crownPrice);
            data2.crownPriceAdd += Vector2IntExt.Random(crownAddPrice);
            foreach (ShopRoutine.Item item2 in data2.items)
            {
                item2.price += Vector2IntExt.Random(cardPrices);
            }
        }
        yield break;
    }
}
[CreateAssetMenu(fileName = "BattleSetUp", menuName = "Scripts/Battle Set Up")]
public class ScriptBattleSetUp : Script
{
    public override IEnumerator Run()
    {
        Character player = References.Player;
        Character enemy = References.Battle.enemy;
        CampaignNode node = Campaign.FindCharacterNode(player);
        Events.InvokePreBattleSetUp(node);
        SetUpEnemyWaves(enemy, node);
        Random.InitState(node.seed);
        yield return CreateCards(player, enemy);
        Events.InvokePostBattleSetUp(node);
    }

    public static void SetUpEnemyWaves(Character enemy, CampaignNode node)
    {
        BattleWaveManager component = ((Component)enemy).GetComponent<BattleWaveManager>();
        component.list = new List<BattleWaveManager.Wave>();
        BattleWaveManager.WaveData[] saveCollection = node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves");
        for (int i = 0; i < saveCollection.Length; i++)
        {
            BattleWaveManager.Wave item = new BattleWaveManager.Wave(saveCollection[i]);
            component.list.Add(item);
        }
    }

    public static IEnumerator CreateCards(Character player, Character enemy)
    {
        CardController cardController = Object.FindObjectOfType<CardController>();
        Routine.Clump clump = new Routine.Clump();
        List<Entity> enemyCards = new List<Entity>();
        List<Entity> playerCards = new List<Entity>();
        clump.Add(CreateEnemyCards(enemy, cardController, enemyCards));
        clump.Add(CreatePlayerCards(player, cardController, playerCards));
        yield return clump.WaitForEnd();
        Vector3 localScale = Vector3.one * enemy.reserveContainer.CardScale;
        foreach (Entity item in enemyCards)
        {
            enemy.reserveContainer.Add(item);
            item.transform.localScale = localScale;
        }
        enemy.reserveContainer.SetChildPositions();
        Vector3 localScale2 = Vector3.one * player.drawContainer.CardScale;
        foreach (Entity item2 in IEnumerableExt.InRandomOrder<Entity>((IEnumerable<Entity>)playerCards))
        {
            player.drawContainer.Add(item2);
            item2.transform.localScale = localScale2;
        }
        player.drawContainer.SetChildPositions();
    }

    public static IEnumerator CreateEnemyCards(Character enemy, CardController cardController, IList<Entity> entities)
    {
        Routine.Clump clump = new Routine.Clump();
        BattleWaveManager waveManager = ((Component)enemy).GetComponent<BattleWaveManager>();
        int num = waveManager.list.Sum((BattleWaveManager.Wave a) => a.units.Count);
        while (entities.Count < num)
        {
            entities.Add(null);
        }
        int entityIndex = 0;
        for (int waveIndex = 0; waveIndex < waveManager.list.Count; waveIndex++)
        {
            BattleWaveManager.Wave wave = waveManager.list[waveIndex];
            List<Entity> entitiesThisWave = new List<Entity>();
            while (entitiesThisWave.Count < wave.units.Count)
            {
                entitiesThisWave.Add(null);
            }
            for (int i = 0; i < wave.units.Count; i++)
            {
                Card card = CardManager.Get(wave.units[i], cardController, enemy, inPlay: true, isPlayerCard: false);
                entitiesThisWave[i] = card.entity;
                card.entity.flipper.FlipDownInstant();
                entities[entityIndex++] = card.entity;
                clump.Add(card.UpdateData());
            }
            yield return clump.WaitForEnd();
            waveManager.AddEntities(entitiesThisWave.ToArray());
            Debug.Log($"{wave} Created");
        }
    }

    public static IEnumerator CreatePlayerCards(Character player, CardController cardController, IList<Entity> entities)
    {
        Routine.Clump clump = new Routine.Clump();
        int count = player.data.inventory.deck.Count;
        while (entities.Count < count)
        {
            entities.Add(null);
        }
        for (int i = 0; i < count; i++)
        {
            Card card = CardManager.Get(player.data.inventory.deck[i], cardController, player, inPlay: true, isPlayerCard: true);
            entities[i] = card.entity;
            card.entity.flipper.FlipDownInstant();
            clump.Add(card.UpdateData());
        }
        yield return clump.WaitForEnd();
    }
}
[CreateAssetMenu(fileName = "Change Card Stats", menuName = "Scripts/Change Card Stats")]
public class ScriptChangeCardStats : Script
{
    [SerializeField]
    public int cardIndex;

    [SerializeField]
    public CardScript[] scriptPool;

    [SerializeField]
    public Vector2Int countRange;

    public override IEnumerator Run()
    {
        int num = Vector2IntExt.Random(countRange);
        CardData target = References.PlayerData.inventory.deck[cardIndex];
        foreach (CardScript item in IEnumerableExt.InRandomOrder<CardScript>((IEnumerable<CardScript>)scriptPool))
        {
            if (num <= 0)
            {
                break;
            }
            item.Run(target);
            num--;
        }
        yield break;
    }
}
[CreateAssetMenu(fileName = "Change Combo Factor", menuName = "Scripts/Change Combo Factor")]
public class ScriptChangeComboFactor : Script
{
    [SerializeField]
    public float value = 1f;

    public override IEnumerator Run()
    {
        References.PlayerData.comboGoldFactor = value;
        yield break;
    }
}
[CreateAssetMenu(fileName = "Change Companion Limit", menuName = "Scripts/Change Companion Limit")]
public class ScriptChangeCompanionLimit : Script
{
    [SerializeField]
    public bool set;

    [SerializeField]
    [HideIf("set")]
    public bool add = true;

    [SerializeField]
    public int value = 1;

    public override IEnumerator Run()
    {
        if (set)
        {
            References.PlayerData.companionLimit = value;
        }
        else if (add)
        {
            References.PlayerData.companionLimit += value;
        }
        yield break;
    }
}
[CreateAssetMenu(fileName = "Change Enemy Gold Factor", menuName = "Scripts/Change Enemy Gold Factor")]
public class ScriptChangeEnemyGoldFactor : Script
{
    [SerializeField]
    public float value = 1f;

    public override IEnumerator Run()
    {
        References.PlayerData.enemyGoldFactor = value;
        yield break;
    }
}
[CreateAssetMenu(fileName = "Change Hand Size", menuName = "Scripts/Change Hand Size")]
public class ScriptChangeHandSize : Script
{
    [SerializeField]
    public bool set;

    [SerializeField]
    [HideIf("set")]
    public bool add = true;

    [SerializeField]
    public int value = 1;

    public override IEnumerator Run()
    {
        if (set)
        {
            References.PlayerData.handSize = value;
        }
        else if (add)
        {
            References.PlayerData.handSize += value;
        }
        yield break;
    }
}
[CreateAssetMenu(fileName = "Change Redraw Bell Counter", menuName = "Scripts/Change Redraw Bell Counter")]
public class ScriptChangeRedrawBellCounter : Script
{
    [SerializeField]
    public bool set;

    [SerializeField]
    [HideIf("set")]
    public bool add = true;

    [SerializeField]
    public int value = 1;

    public override IEnumerator Run()
    {
        if (set)
        {
            References.PlayerData.redrawBell = value;
        }
        else if (add)
        {
            References.PlayerData.redrawBell += value;
        }
        yield break;
    }
}
[CreateAssetMenu(fileName = "Change Shop Prices", menuName = "Scripts/Change Shop Prices")]
public class ScriptChangeShopPrices : Script
{
    [SerializeField]
    public Vector2Int itemsToAffect = new Vector2Int(2, 3);

    [SerializeField]
    public Vector2 affectPriceRange = new Vector2(1f, 1.5f);

    [SerializeField]
    public Vector2 charmPriceRange = new Vector2(1f, 1.5f);

    [SerializeField]
    public Vector2 crownPriceRange = new Vector2(1f, 1.5f);

    [SerializeField]
    public float removeDiscountChance = 0.5f;

    public override IEnumerator Run()
    {
        foreach (CampaignNode item in Campaign.instance.nodes.Where((CampaignNode node) => node.type is CampaignNodeTypeShop))
        {
            if (!item.data.TryGetValue("shopData", out var value) || !(value is ShopRoutine.Data data))
            {
                continue;
            }
            int num = Vector2IntExt.Random(itemsToAffect);
            foreach (ShopRoutine.Item item2 in data.items.OrderBy((ShopRoutine.Item a) => Random.Range(0f, 1f)))
            {
                float num2 = Vector2Ext.Random(affectPriceRange);
                item2.price = Mathf.RoundToInt((float)item2.price * num2);
                if (!(num2 < 1f) || Random.Range(0f, 1f) < removeDiscountChance)
                {
                }
                num--;
                if (num <= 0)
                {
                    break;
                }
            }
            data.charmPrice = Mathf.RoundToInt((float)data.charmPrice * Vector2Ext.Random(charmPriceRange));
            data.crownPrice = Mathf.RoundToInt((float)data.crownPrice * Vector2Ext.Random(crownPriceRange));
        }
        yield break;
    }
}
[CreateAssetMenu(fileName = "Change Wave Bell Counter", menuName = "Scripts/Change Wave Bell Counter")]
public class ScriptChangeWaveBellCounter : Script
{
    [SerializeField]
    public bool set;

    [SerializeField]
    [HideIf("set")]
    public bool add = true;

    [SerializeField]
    public int value = 1;

    public override IEnumerator Run()
    {
        if (set)
        {
            Set();
        }
        else if (add)
        {
            Add();
        }
        yield break;
    }

    public void Add()
    {
        foreach (CampaignNode node in Campaign.instance.nodes)
        {
            if (!node.cleared && node.type.isBattle && node.data.TryGetValue("waves", out var obj) && obj is SaveCollection<BattleWaveManager.WaveData> waves)
            {
                Add(waves);
            }
        }
    }

    public void Set()
    {
        foreach (CampaignNode node in Campaign.instance.nodes)
        {
            if (!node.cleared && node.type.isBattle && node.data.TryGetValue("waves", out var obj) && obj is SaveCollection<BattleWaveManager.WaveData> waves)
            {
                Set(waves);
            }
        }
    }

    public void Add(SaveCollection<BattleWaveManager.WaveData> waves)
    {
        for (int i = 0; i < waves.Count; i++)
        {
            waves[i].counter += value;
        }
    }

    public void Set(SaveCollection<BattleWaveManager.WaveData> waves)
    {
        for (int i = 0; i < waves.Count; i++)
        {
            waves[i].counter = value;
        }
    }
}
[CreateAssetMenu(fileName = "Curse Crowns", menuName = "Scripts/Curse Crowns")]
public class ScriptCurseCrowns : Script
{
    [SerializeField]
    public int curseBossCrowns = 1;

    [SerializeField]
    public int curseShopCrowns = 1;

    [SerializeField]
    public int[] legalBossTiers = new int[1] { 2 };

    [SerializeField]
    public int[] legalShopTiers = new int[4] { 2, 3, 4, 5 };

    [SerializeField]
    public CardUpgradeData[] cursedCrowns;

    public override IEnumerator Run()
    {
        List<CardUpgradeData> pool = PopulatePool();
        int num = curseBossCrowns;
        int num2 = curseShopCrowns;
        foreach (CampaignNode item in IEnumerableExt.InRandomOrder<CampaignNode>(References.Campaign.nodes.Where((CampaignNode a) => a.type.interactable && a.dataLinkedTo == -1 && a.tier >= 0 && a.data != null)))
        {
            if (item.type is CampaignNodeTypeBoss && TryCurseBossCrown(item, pool))
            {
                if (--num <= 0 && num2 <= 0)
                {
                    break;
                }
            }
            else if (item.type is CampaignNodeTypeShop && TryCurseShopCrown(item, pool) && --num2 <= 0 && num <= 0)
            {
                break;
            }
        }
        yield break;
    }

    public bool TryCurseBossCrown(CampaignNode node, List<CardUpgradeData> pool)
    {
        if (!IArrayExt.Contains<int>(legalBossTiers, node.tier))
        {
            return false;
        }
        CampaignNodeTypeBoss.RewardData rewardData = DictionaryExt.Get<CampaignNodeTypeBoss.RewardData>(node.data, "rewards");
        if (rewardData != null)
        {
            foreach (BossRewardData.Data reward in rewardData.rewards)
            {
                if (reward.type == BossRewardData.Type.Crown && reward is BossRewardDataCrown.Data data && TryPullFromPool(pool, out var upgradeData))
                {
                    data.upgradeDataName = (upgradeData).name;
                    return true;
                }
            }
        }
        return false;
    }

    public bool TryCurseShopCrown(CampaignNode node, List<CardUpgradeData> pool)
    {
        if (!IArrayExt.Contains<int>(legalShopTiers, node.tier))
        {
            return false;
        }
        ShopRoutine.Data data = DictionaryExt.Get<ShopRoutine.Data>(node.data, "shopData");
        if (data != null && TryPullFromPool(pool, out var upgradeData))
        {
            data.crownType = (upgradeData).name;
            return true;
        }
        return false;
    }

    public static bool TryPullFromPool(List<CardUpgradeData> pool, out CardUpgradeData upgradeData)
    {
        if (pool.Count > 0)
        {
            upgradeData = IListExt.TakeRandom<CardUpgradeData>((IList<CardUpgradeData>)pool);
            return true;
        }
        upgradeData = null;
        return false;
    }

    public List<CardUpgradeData> PopulatePool()
    {
        List<CardUpgradeData> list = new List<CardUpgradeData>();
        list.AddRange(cursedCrowns);
        return list;
    }
}
[CreateAssetMenu(fileName = "Downgrade Card Rewards", menuName = "Scripts/Downgrade Card Rewards")]
public class ScriptDowngradeCardRewards : Script
{
    [Serializable]
    public struct FixedCharmSet
    {
        public string[] cards;

        public CardUpgradeData[] charmOptions;
    }

    [SerializeField]
    public CardUpgradeData[] charms;

    [SerializeField]
    public int downgradesPerTier = 2;

    [SerializeField]
    public FixedCharmSet[] charmSets;

    public override IEnumerator Run()
    {
        List<CardUpgradeData> pool = PopulatePool();
        Dictionary<int, int> dictionary = new Dictionary<int, int>();
        for (int i = 0; i <= 8; i++)
        {
            dictionary[i] = downgradesPerTier;
        }
        foreach (CampaignNode item in IEnumerableExt.InRandomOrder<CampaignNode>(References.Campaign.nodes.Where((CampaignNode a) => a.type.interactable && a.dataLinkedTo == -1 && a.tier >= 0 && a.data != null)))
        {
            if (dictionary[item.tier] > 0 && TryAddDowngrade(item, pool))
            {
                dictionary[item.tier]--;
            }
        }
        yield break;
    }

    public bool TryAddDowngrade(CampaignNode node, List<CardUpgradeData> pool)
    {
        bool result = false;
        CampaignNodeType type = node.type;
        if (type is CampaignNodeTypeItem || type is CampaignNodeTypeCompanion || type is CampaignNodeTypeCurseItems)
        {
            if (TryAddDowngrade(node.data.GetSaveCollection<string>("cards"), pool, out var appliedToIndex, out var downgradeApplied))
            {
                result = true;
                AddUpgradeToCardInNodeData(node, appliedToIndex, (downgradeApplied).name);
            }
        }
        else if (node.type is CampaignNodeTypeShop)
        {
            ShopRoutine.Data data = DictionaryExt.Get<ShopRoutine.Data>(node.data, "shopData");
            if (TryAddDowngrade(data.items.Select((ShopRoutine.Item a) => a.cardDataName).ToArray(), pool, out var appliedToIndex2, out var downgradeApplied2))
            {
                result = true;
                for (int i = 0; i <= appliedToIndex2; i++)
                {
                    if (data.upgrades.Count <= i)
                    {
                        string[] item = ((i != appliedToIndex2) ? null : new string[1] { (downgradeApplied2).name });
                        data.upgrades.Add(item);
                    }
                    else if (i == appliedToIndex2)
                    {
                        string[] array = data.upgrades[i];
                        if (array == null)
                        {
                            array = new string[1] { (downgradeApplied2).name };
                        }
                        else
                        {
                            List<string> list = IArrayExt.ToList<string>(array);
                            list.Add((downgradeApplied2).name);
                            array = list.ToArray();
                        }
                        data.upgrades[i] = array;
                    }
                }
            }
        }
        else if (node.type is CampaignNodeTypeCharmShop)
        {
            EventRoutineCharmShop.Data data2 = DictionaryExt.Get<EventRoutineCharmShop.Data>(node.data, "data");
            if (TryAddDowngrade(data2.cards.Select((EventRoutineCharmShop.UpgradedCard a) => a.cardDataName).ToArray(), pool, out var appliedToIndex3, out var downgradeApplied3))
            {
                result = true;
                EventRoutineCharmShop.UpgradedCard upgradedCard = data2.cards[appliedToIndex3];
                List<string> list2 = ((upgradedCard.upgradeNames == null) ? new List<string>() : IArrayExt.ToList<string>(upgradedCard.upgradeNames));
                list2.Add((downgradeApplied3).name);
                upgradedCard.upgradeNames = list2.ToArray();
            }
        }
        return result;
    }

    public static void AddUpgradeToCardInNodeData(CampaignNode node, int cardIndex, string upgradeName)
    {
        string text = $"upgrades{cardIndex}";
        if (node.data.ContainsKey(text))
        {
            DictionaryExt.Get<SaveCollection<string>>(node.data, text).Add(upgradeName);
        }
        else
        {
            node.data[text] = new SaveCollection<string>(upgradeName);
        }
        if (node.linkedToThis == null)
        {
            return;
        }
        foreach (int linkedToThi in node.linkedToThis)
        {
            AddUpgradeToCardInNodeData(Campaign.GetNode(linkedToThi), cardIndex, upgradeName);
        }
    }

    public bool TryAddDowngrade(string[] cardNames, List<CardUpgradeData> pool, out int appliedToIndex, out CardUpgradeData downgradeApplied)
    {
        appliedToIndex = -1;
        downgradeApplied = null;
        bool result = false;
        foreach (int item in IEnumerableExt.InRandomOrder<int>((IEnumerable<int>)IListExt.GetIndices<string>((IList<string>)cardNames)))
        {
            string assetName = cardNames[item];
            CardData cardData = AddressableLoader.Get<CardData>("CardData", assetName);
            downgradeApplied = FindDowngrade(cardData, pool);
            if ((downgradeApplied))
            {
                pool.Remove(downgradeApplied);
                result = true;
                appliedToIndex = item;
                break;
            }
        }
        return result;
    }

    public CardUpgradeData FindDowngrade(CardData cardData, List<CardUpgradeData> pool)
    {
        FixedCharmSet[] array = charmSets;
        for (int i = 0; i < array.Length; i++)
        {
            FixedCharmSet fixedCharmSet = array[i];
            if (IArrayExt.Contains<string>(fixedCharmSet.cards, (cardData).name))
            {
                return IArrayExt.RandomItem<CardUpgradeData>(fixedCharmSet.charmOptions);
            }
        }
        for (int j = 0; j < pool.Count; j++)
        {
            if (pool[j].CanAssign(cardData))
            {
                return pool[j];
            }
        }
        return null;
    }

    public List<CardUpgradeData> PopulatePool()
    {
        List<CardUpgradeData> list = new List<CardUpgradeData>();
        list.AddRange(IEnumerableExt.InRandomOrder<CardUpgradeData>((IEnumerable<CardUpgradeData>)charms));
        list.AddRange(IEnumerableExt.InRandomOrder<CardUpgradeData>((IEnumerable<CardUpgradeData>)charms));
        return list;
    }
}
[CreateAssetMenu(fileName = "Early Minibosses", menuName = "Scripts/Early Minibosses")]
public class ScriptEarlyMinibosses : Script
{
    public override IEnumerator Run()
    {
        foreach (CampaignNode node in References.Campaign.nodes)
        {
            if (node.type.isBattle && !node.type.isBoss)
            {
                List<BattleWaveManager.WaveData> list = IArrayExt.ToList<BattleWaveManager.WaveData>(node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves"));
                BattleWaveManager.WaveData waveData = list.FirstOrDefault((BattleWaveManager.WaveData a) => a.isBossWave);
                if (waveData != null)
                {
                    int num = list.IndexOf(waveData);
                    list.RemoveAt(num);
                    list.Insert(num - 1, waveData);
                    node.data["waves"] = new SaveCollection<BattleWaveManager.WaveData>(list);
                }
            }
        }
        yield break;
    }
}
[CreateAssetMenu(fileName = "Modify Wave Counters", menuName = "Scripts/Modify Wave Counters")]
public class ScriptModifyWaveCounters : Script
{
    [SerializeField]
    public int change = -1;

    [SerializeField]
    public bool normalBattles = true;

    [SerializeField]
    public bool bossBattles = true;

    [SerializeField]
    public bool finalBossBattles = true;

    public override IEnumerator Run()
    {
        foreach (CampaignNode node in References.Campaign.nodes)
        {
            if (!node.type.isBattle || (!normalBattles && (node.type).name == "CampaignNodeBattle") || (!bossBattles && (node.type).name == "CampaignNodeBoss"))
            {
                continue;
            }
            if (!finalBossBattles)
            {
                string name = (node.type).name;
                if (name == "CampaignNodeFinalBoss" || name == "CampaignNodeFinalFinalBoss")
                {
                    continue;
                }
            }
            BattleWaveManager.WaveData[] saveCollection = node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves");
            BattleWaveManager.WaveData[] array = saveCollection;
            for (int i = 0; i < array.Length; i++)
            {
                array[i].counter += change;
            }
            node.data["waves"] = new SaveCollection<BattleWaveManager.WaveData>(saveCollection);
        }
        yield break;
    }
}
[CreateAssetMenu(fileName = "Randomize Deck", menuName = "Scripts/Randomize Deck")]
public class ScriptRandomizeDeck : Script
{
    [SerializeField]
    public Vector2Int cardsToRemove = new Vector2Int(0, 2);

    [SerializeField]
    public Vector2Int cardsToAdd = new Vector2Int(1, 4);

    [SerializeField]
    public Vector2Int charmsToAdd = new Vector2Int(1, 3);

    [SerializeField]
    [Range(0f, 1f)]
    public float addCharmChance = 0.25f;

    [SerializeField]
    [Range(0f, 1f)]
    public float replaceChance = 0.5f;

    public override IEnumerator Run()
    {
        GetPools(out var cards, out var charms);
        RemoveCards();
        AddCards(cards);
        if (Random.Range(0f, 1f) < addCharmChance)
        {
            AddCharms(charms);
        }
        References.PlayerData.inventory.deck.Sort((CardData a, CardData b) => a.cardType.sortPriority.CompareTo(b.cardType.sortPriority));
        yield break;
    }

    public static void GetPools(out List<CardData> cards, out List<CardUpgradeData> charms)
    {
        cards = new List<CardData>();
        charms = new List<CardUpgradeData>();
        RewardPool[] rewardPools = References.PlayerData.classData.rewardPools;
        for (int i = 0; i < rewardPools.Length; i++)
        {
            foreach (DataFile item3 in rewardPools[i].list)
            {
                if (!(item3 is CardData item))
                {
                    if (item3 is CardUpgradeData item2)
                    {
                        charms.Add(item2);
                    }
                }
                else
                {
                    cards.Add(item);
                }
            }
        }
    }

    public void RemoveCards()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        int num = Vector2IntExt.Random(cardsToRemove);
        for (int i = 0; i < num; i++)
        {
            int index = Random.Range(1, References.PlayerData.inventory.deck.Count);
            References.PlayerData.inventory.deck.RemoveAt(index);
        }
    }

    public void AddCards(List<CardData> cards)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        int num = Vector2IntExt.Random(cardsToAdd);
        List<CardData> added = new List<CardData>();
        for (int i = 0; i < num; i++)
        {
            AddCard(References.PlayerData.inventory.deck, IListExt.TakeRandom<CardData>((IList<CardData>)cards).Clone(), added);
        }
    }

    public void AddCard(CardDataList deck, CardData cardDataClone, List<CardData> added)
    {
        bool num = Random.Range(0f, 1f) < replaceChance;
        int index = Random.Range(1, deck.Count);
        if (num && !added.Contains(deck[index]))
        {
            deck.RemoveAt(index);
        }
        deck.Insert(index, cardDataClone);
    }

    public void AddCharms(List<CardUpgradeData> charms)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        int num = Vector2IntExt.Random(charmsToAdd);
        for (int i = 0; i < num; i++)
        {
            bool flag = false;
            while (!flag && charms.Count > 0)
            {
                flag = TryAddCharm(References.PlayerData.inventory.deck, IListExt.TakeRandom<CardUpgradeData>((IList<CardUpgradeData>)charms));
            }
            if (charms.Count <= 0)
            {
                break;
            }
        }
    }

    public static bool TryAddCharm(CardDataList deck, CardUpgradeData upgradeData)
    {
        bool result = false;
        foreach (CardData item in IEnumerableExt.InRandomOrder<CardData>((IEnumerable<CardData>)deck))
        {
            if (upgradeData.CanAssign(item))
            {
                upgradeData.Clone().Assign(item);
                result = true;
                break;
            }
        }
        return result;
    }
}
[CreateAssetMenu(fileName = "Remove Random Cards", menuName = "Scripts/Remove Random Cards")]
public class ScriptRemoveRandomCards : Script
{
    [SerializeField]
    public Vector2Int countRange;

    [SerializeField]
    public CardType[] cardTypes;

    public override IEnumerator Run()
    {
        CardData[] array = IEnumerableExt.InRandomOrder<CardData>(References.PlayerData.inventory.deck.Where(Eligible)).ToArray();
        int num = Vector2IntExt.Random(countRange);
        for (int i = 0; i < num; i++)
        {
            CardData cardData = array[i];
            References.PlayerData.inventory.deck.Remove(cardData);
            Debug.Log((name + " → Removing " + (cardData).name + " from player's deck"));
        }
        yield break;
    }

    public bool Eligible(CardData cardData)
    {
        if (cardTypes.Length == 0)
        {
            return true;
        }
        return IArrayExt.Contains<CardType>(cardTypes, cardData.cardType);
    }
}
[CreateAssetMenu(fileName = "Run Scripts On Deck", menuName = "Scripts/Run Scripts On Deck")]
public class ScriptRunScriptsOnDeck : Script
{
    [SerializeField]
    public AssetReferenceT<CardScript>[] scriptRefs;

    [SerializeField]
    public TargetConstraint[] constraints;

    [SerializeField]
    public Vector2Int countRange;

    [SerializeField]
    public bool includeReserve;

    public override IEnumerator Run()
    {
        List<CardData> list = new List<CardData>();
        AddRangeIfConstraints(list, References.PlayerData.inventory.deck, constraints);
        if (includeReserve)
        {
            AddRangeIfConstraints(list, References.PlayerData.inventory.reserve, constraints);
        }
        if (list.Count > 0)
        {
            Affect(list);
        }
        yield break;
    }

    public static void AddRangeIfConstraints(ICollection<CardData> collection, CardDataList toAdd, TargetConstraint[] constraints)
    {
        foreach (CardData item in toAdd)
        {
            AddIfConstraints(collection, item, constraints);
        }
    }

    public static void AddIfConstraints(ICollection<CardData> collection, CardData item, TargetConstraint[] constraints)
    {
        if (!constraints.Any((TargetConstraint c) => !c.Check(item)))
        {
            collection.Add(item);
        }
    }

    public void Affect(IReadOnlyCollection<CardData> cards)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        int num = Vector2IntExt.Random(countRange);
        Debug.Log(("[" + name + "] Affecting [" + string.Join(", ", cards) + "]"));
        using AddressableGroup<CardScript> addressableGroup = new AddressableGroup<CardScript>(scriptRefs);
        foreach (CardData item in IEnumerableExt.InRandomOrder<CardData>((IEnumerable<CardData>)cards))
        {
            foreach (CardScript item2 in addressableGroup)
            {
                item2.Run(item);
            }
            num--;
            if (num <= 0)
            {
                break;
            }
        }
    }
}
[CreateAssetMenu(fileName = "Upgrade Enemies", menuName = "Scripts/Upgrade Enemies")]
public class ScriptUpgradeEnemies : Script
{
    [Serializable]
    public struct Tier
    {
        public Vector2Int upgradesRange;

        public bool canAffectMiniboss;
    }

    [SerializeField]
    public string[] illegalCards = new string[1] { "Gobling" };

    [SerializeField]
    public CardUpgradeData[] upgradePool;

    [SerializeField]
    public Tier[] tiers;

    public override IEnumerator Run()
    {
        List<CardUpgradeData> currentPool = new List<CardUpgradeData>();
        foreach (CampaignNode node in References.Campaign.nodes)
        {
            if (node.type.isBattle)
            {
                BattleWaveManager.WaveData[] saveCollection = node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves");
                int num = ((tiers.Length > node.tier) ? Vector2IntExt.Random(tiers[node.tier].upgradesRange) : 0);
                if (num > 0)
                {
                    AddUpgrades(currentPool, saveCollection, num, tiers[node.tier].canAffectMiniboss);
                }
            }
        }
        yield break;
    }

    public void AddUpgrades(List<CardUpgradeData> currentPool, BattleWaveManager.WaveData[] waves, int upgradeCount, bool canUpgradeMiniboss)
    {
        foreach (BattleWaveManager.WaveData wave in waves)
        {
            if (TryAddUpgrade(currentPool, wave, canUpgradeMiniboss) && --upgradeCount <= 0)
            {
                break;
            }
        }
    }

    public bool TryAddUpgrade(List<CardUpgradeData> currentPool, BattleWaveManager.WaveData wave, bool canUpgradeMiniboss)
    {
        bool result = false;
        List<int> list = GenericPool<List<int>>.Get();
        list.Clear();
        for (int i = 0; i < wave.Count; i++)
        {
            list.Add(i);
        }
        foreach (int item in IEnumerableExt.InRandomOrder<int>((IEnumerable<int>)list))
        {
            if (TryAddUpgrade(currentPool, wave, item, canUpgradeMiniboss))
            {
                result = true;
                break;
            }
        }
        GenericPool<List<int>>.Release(list);
        return result;
    }

    public bool TryAddUpgrade(List<CardUpgradeData> currentPool, BattleWaveManager.WaveData wave, int cardIndex, bool canUpgradeMiniboss)
    {
        if (IllegalCard(wave.GetCardName(cardIndex)))
        {
            return false;
        }
        CardData cardData = wave.PeekCardData(cardIndex);
        if (!(cardData))
        {
            return false;
        }
        if (cardData.cardType.miniboss && !canUpgradeMiniboss)
        {
            return false;
        }
        CardUpgradeData cardUpgradeData = ((currentPool.Count > 0) ? currentPool.FirstOrDefault((CardUpgradeData a) => wave.AddUpgradeToCard(cardIndex, a)) : null);
        if (!(cardUpgradeData))
        {
            currentPool.AddRange(IEnumerableExt.InRandomOrder<CardUpgradeData>((IEnumerable<CardUpgradeData>)upgradePool));
            cardUpgradeData = currentPool.FirstOrDefault((CardUpgradeData a) => wave.AddUpgradeToCard(cardIndex, a));
        }
        if ((cardUpgradeData))
        {
            currentPool.Remove(cardUpgradeData);
            return true;
        }
        return false;
    }

    public bool IllegalCard(string cardDataName)
    {
        return IArrayExt.Contains<string>(illegalCards, cardDataName);
    }
}
[CreateAssetMenu(fileName = "Upgrade Final Boss", menuName = "Scripts/Upgrade Final Boss")]
public class ScriptUpgradeFinalBoss : Script
{
    [SerializeField]
    public CardUpgradeData attackUpgrade;

    [SerializeField]
    public CardUpgradeData effectsUpgrade;

    [SerializeField]
    public TargetConstraint canBeBoostedConstraint;

    public override IEnumerator Run()
    {
        foreach (CampaignNode node in References.Campaign.nodes)
        {
            AddUpgrade(node);
        }
        yield break;
    }

    public void AddUpgrade(CampaignNode node)
    {
        if (!node.type.isBattle || !node.type.isBoss || !((node.type).name == "CampaignNodeFinalBoss"))
        {
            return;
        }
        BattleWaveManager.WaveData[] saveCollection = node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves");
        foreach (BattleWaveManager.WaveData waveData in saveCollection)
        {
            if (!waveData.isBossWave)
            {
                continue;
            }
            for (int j = 0; j < waveData.Count; j++)
            {
                CardData cardData = waveData.GetCardData(j);
                if (cardData.cardType.miniboss)
                {
                    CardUpgradeData upgradeData = GetUpgrade(cardData).Clone();
                    waveData.AddUpgradeToCard(j, upgradeData);
                }
            }
        }
    }

    public CardUpgradeData GetUpgrade(CardData cardData)
    {
        if (!canBeBoostedConstraint.Check(cardData))
        {
            return attackUpgrade;
        }
        return effectsUpgrade;
    }
}
[CreateAssetMenu(fileName = "Upgrade Minibosses", menuName = "Scripts/Upgrade Minibosses")]
public class ScriptUpgradeMinibosses : Script
{
    [Serializable]
    public struct Profile
    {
        public string[] cardDataNames;

        public CardUpgradeData[] possibleUpgrades;
    }

    [SerializeField]
    public Profile[] profiles;

    [SerializeField]
    public CardUpgradeData[] defaultUpgrades;

    public override IEnumerator Run()
    {
        foreach (CampaignNode node in References.Campaign.nodes)
        {
            if (node.type.isBattle && !((node.type).name == "CampaignNodeFinalBoss"))
            {
                BattleWaveManager.WaveData[] saveCollection = node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves");
                AddUpgrade(saveCollection);
            }
        }
        yield break;
    }

    public void AddUpgrade(BattleWaveManager.WaveData[] waves)
    {
        foreach (BattleWaveManager.WaveData waveData in waves)
        {
            if (!waveData.isBossWave)
            {
                continue;
            }
            for (int j = 0; j < waveData.Count; j++)
            {
                CardData cardData = waveData.PeekCardData(j);
                if ((cardData) && cardData.cardType.miniboss)
                {
                    CardUpgradeData upgrade = GetUpgrade(cardData);
                    if (upgrade != null)
                    {
                        waveData.AddUpgradeToCard(j, upgrade.Clone());
                    }
                }
            }
        }
    }

    public CardUpgradeData GetUpgrade(CardData cardData)
    {
        Profile[] array = profiles;
        for (int i = 0; i < array.Length; i++)
        {
            Profile profile = array[i];
            if (IArrayExt.Contains<string>(profile.cardDataNames, (cardData).name))
            {
                return IArrayExt.RandomItem<CardUpgradeData>(profile.possibleUpgrades);
            }
        }
        return GetDefaultUpgrade(cardData);
    }

    public CardUpgradeData GetDefaultUpgrade(CardData cardData)
    {
        foreach (CardUpgradeData item in IEnumerableExt.InRandomOrder<CardUpgradeData>((IEnumerable<CardUpgradeData>)defaultUpgrades))
        {
            if (item.CanAssign(cardData))
            {
                return item;
            }
        }
        return null;
    }
}
[CreateAssetMenu(fileName = "Upgrade Specific Enemies", menuName = "Scripts/Upgrade Specific Enemies")]
public class ScriptUpgradeSpecificEnemies : Script
{
    [Serializable]
    public class Profile
    {
        public CardData cardData;

        public CardUpgradeData[] upgrades;
    }

    [SerializeField]
    public Profile[] profiles;

    public override IEnumerator Run()
    {
        foreach (CampaignNode node in References.Campaign.nodes)
        {
            if (!node.type.isBattle)
            {
                continue;
            }
            BattleWaveManager.WaveData[] saveCollection = node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves");
            foreach (BattleWaveManager.WaveData waveData in saveCollection)
            {
                for (int j = 0; j < waveData.Count; j++)
                {
                    string cardName = waveData.GetCardName(j);
                    Profile profile = profiles.FirstOrDefault((Profile a) => (a.cardData).name == cardName);
                    if (profile != null)
                    {
                        CardUpgradeData[] upgrades = profile.upgrades;
                        foreach (CardUpgradeData upgradeData in upgrades)
                        {
                            waveData.AddUpgradeToCard(j, upgradeData);
                        }
                    }
                }
            }
        }
        yield break;
    }
}
[CreateAssetMenu(fileName = "Entity With Highest Attack", menuName = "Select Scripts/Entity With Highest Attack")]
public class SelectScriptEntityHighestAttack : SelectScript<Entity>
{
    [SerializeField]
    public int selectAmount = 1;

    public override List<Entity> Run(List<Entity> group)
    {
        Entity entity = group.Where((Entity a) => a.IsAliveAndExists() && a.HasAttackIcon()).OrderByDescending(GetAttack).FirstOrDefault();
        int highestAttack = ((entity) ? GetAttack(entity) : 0);
        return IEnumerableExt.InRandomOrder<Entity>(group.Where((Entity a) => a.IsAliveAndExists() && a.HasAttackIcon() && GetAttack(a) == highestAttack)).Take(selectAmount).ToList();
    }

    public static int GetAttack(Entity entity)
    {
        return entity.damage.current + ((entity.tempDamage)).Value;
    }
}
[CreateAssetMenu(fileName = "Entity With Highest Health", menuName = "Select Scripts/Entity With Highest Health")]
public class SelectScriptEntityHighestHealth : SelectScript<Entity>
{
    [SerializeField]
    public int selectAmount = 1;

    public override List<Entity> Run(List<Entity> group)
    {
        Entity entity = group.Where((Entity a) => a.IsAliveAndExists() && a.data.hasHealth).OrderByDescending(GetHealth).FirstOrDefault();
        int highestHealth = ((entity) ? GetHealth(entity) : 0);
        return IEnumerableExt.InRandomOrder<Entity>(group.Where((Entity a) => a.IsAliveAndExists() && a.data.hasHealth && a.hp.current == highestHealth)).Take(selectAmount).ToList();
    }

    public static int GetHealth(Entity entity)
    {
        return entity.hp.current;
    }
}
[CreateAssetMenu(fileName = "Entity With Lowest Attack", menuName = "Select Scripts/Entity With Lowest Attack")]
public class SelectScriptEntityLowestAttack : SelectScript<Entity>
{
    [SerializeField]
    public int selectAmount = 1;

    public override List<Entity> Run(List<Entity> group)
    {
        Entity entity = group.Where((Entity a) => a.IsAliveAndExists() && a.HasAttackIcon()).OrderBy(GetAttack).FirstOrDefault();
        int lowestAttack = ((entity) ? GetAttack(entity) : 0);
        return IEnumerableExt.InRandomOrder<Entity>(group.Where((Entity a) => a.IsAliveAndExists() && a.HasAttackIcon() && GetAttack(a) == lowestAttack)).Take(selectAmount).ToList();
    }

    public static int GetAttack(Entity entity)
    {
        return entity.damage.current + ((entity.tempDamage)).Value;
    }
}
[CreateAssetMenu(fileName = "Entity With Lowest Health", menuName = "Select Scripts/Entity With Lowest Health")]
public class SelectScriptEntityLowestHealth : SelectScript<Entity>
{
    [SerializeField]
    public int selectAmount = 1;

    public override List<Entity> Run(List<Entity> group)
    {
        Entity entity = group.Where((Entity a) => a.IsAliveAndExists() && a.data.hasHealth).OrderBy(GetHealth).FirstOrDefault();
        int lowestHealth = ((entity) ? GetHealth(entity) : 0);
        return IEnumerableExt.InRandomOrder<Entity>(group.Where((Entity a) => a.IsAliveAndExists() && a.data.hasHealth && a.hp.current == lowestHealth)).Take(selectAmount).ToList();
    }

    public static int GetHealth(Entity entity)
    {
        return entity.hp.current;
    }
}
[CreateAssetMenu(fileName = "Random", menuName = "Select Scripts/Random")]
public class SelectScriptRandom : SelectScript<Entity>
{
    [SerializeField]
    public int selectAmount = 1;

    public override List<Entity> Run(List<Entity> group)
    {
        return IEnumerableExt.InRandomOrder<Entity>((IEnumerable<Entity>)group).Take(selectAmount).ToList();
    }
}
public class BlurManager : MonoBehaviour
{
    [SerializeField]
    public Camera blurCamera;

    [SerializeField]
    public Material blurMaterial;

    public void Start()
    {
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Expected O, but got Unknown
        if (blurCamera.targetTexture != null)
        {
            blurCamera.targetTexture.Release();
        }
        blurCamera.targetTexture = new RenderTexture(Screen.width, Screen.height, 24, (RenderTextureFormat)0, 1);
        blurMaterial.SetTexture("_MainTex", (Texture)(object)blurCamera.targetTexture);
    }
}
[CreateAssetMenu(fileName = "And", menuName = "Target Constraints/And")]
public class TargetConstraintAnd : TargetConstraint
{
    [SerializeField]
    public TargetConstraint[] constraints;

    public override bool Check(Entity target)
    {
        TargetConstraint[] array = constraints;
        for (int i = 0; i < array.Length; i++)
        {
            if (!array[i].Check(target))
            {
                return not;
            }
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        TargetConstraint[] array = constraints;
        for (int i = 0; i < array.Length; i++)
        {
            if (!array[i].Check(targetData))
            {
                return not;
            }
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Attack More Than", menuName = "Target Constraints/Attack More Than")]
public class TargetConstraintAttackMoreThan : TargetConstraint
{
    [SerializeField]
    public int value;

    public override bool Check(Entity target)
    {
        if (target.damage.current + ((target.tempDamage)).Value <= value)
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        if (targetData.damage <= value)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Can Be Boosted", menuName = "Target Constraints/Can Be Boosted")]
public class TargetConstraintCanBeBoosted : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if (CheckAttackEffects(target))
        {
            return !not;
        }
        if (CheckPassiveEffects(target))
        {
            return !not;
        }
        return not;
    }

    public override bool Check(CardData targetData)
    {
        if (CheckAttackEffects(targetData))
        {
            return !not;
        }
        if (CheckPassiveEffects(targetData))
        {
            return !not;
        }
        if (CheckTraits(targetData))
        {
            return !not;
        }
        return not;
    }

    public static bool CheckAttackEffects(Entity target)
    {
        return CheckAttackEffects(target.attackEffects.Select((CardData.StatusEffectStacks a) => a.data));
    }

    public static bool CheckAttackEffects(CardData targetData)
    {
        return CheckAttackEffects(targetData.attackEffects.Select((CardData.StatusEffectStacks a) => a.data));
    }

    public static bool CheckAttackEffects(IEnumerable<StatusEffectData> effects)
    {
        return effects?.Any((StatusEffectData e) => e.stackable) ?? false;
    }

    public static bool CheckPassiveEffects(Entity target)
    {
        return CheckPassiveEffects(target.statusEffects);
    }

    public static bool CheckPassiveEffects(CardData targetData)
    {
        return CheckPassiveEffects(targetData.startWithEffects.Select((CardData.StatusEffectStacks a) => a.data));
    }

    public static bool CheckPassiveEffects(IEnumerable<StatusEffectData> effects)
    {
        return effects?.Any((StatusEffectData e) => e.canBeBoosted) ?? false;
    }

    public static bool CheckTraits(Entity target)
    {
        if (target.traits == null)
        {
            return false;
        }
        foreach (Entity.TraitStacks trait in target.traits)
        {
            if (CheckPassiveEffects(trait.data.effects))
            {
                return true;
            }
        }
        return false;
    }

    public static bool CheckTraits(CardData targetData)
    {
        if (targetData.traits == null)
        {
            return false;
        }
        foreach (CardData.TraitStacks trait in targetData.traits)
        {
            if (CheckPassiveEffects(trait.data.effects))
            {
                return true;
            }
        }
        return false;
    }
}
[CreateAssetMenu(fileName = "Can Be Hit", menuName = "Target Constraints/Can Be Hit")]
public class TargetConstraintCanBeHit : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if (!target.canBeHit)
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        if (!targetData.canBeHit)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Can Take Crown", menuName = "Target Constraints/Can Take Crown")]
public class TargetConstraintCanTakeCrown : TargetConstraint
{
    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public override bool Check(CardData targetData)
    {
        if (!targetData.cardType.canTakeCrown)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Is Damaged", menuName = "Target Constraints/Is Damaged")]
public class TargetConstraintDamaged : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if (target.hp.current >= target.hp.max)
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        return not;
    }
}
[CreateAssetMenu(fileName = "Does Attack", menuName = "Target Constraints/Does Attack")]
public class TargetConstraintDoesAttack : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if (!(target.data) || (!target.HasAttackIcon() && target.attackEffects.Count <= 0))
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        if (!(targetData) || (!targetData.hasAttack && targetData.attackEffects.Length == 0))
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Does Damage", menuName = "Target Constraints/Does Damage")]
public class TargetConstraintDoesDamage : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if (!(target.data) || !target.HasAttackIcon())
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        if (!(targetData) || !targetData.hasAttack)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Does Kill", menuName = "Target Constraints/Does Kill")]
public class TargetConstraintDoesKill : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if ((!(target.data) || !target.HasAttackIcon()) && !target.statusEffects.Any((StatusEffectData a) => a.doesDamage) && !target.attackEffects.Any((CardData.StatusEffectStacks a) => a.data.doesDamage))
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        if ((!(targetData) || !targetData.hasAttack) && !targetData.startWithEffects.Any((CardData.StatusEffectStacks a) => a.data.doesDamage) && !targetData.attackEffects.Any((CardData.StatusEffectStacks a) => a.data.doesDamage))
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Does Summon", menuName = "Target Constraints/Does Summon")]
public class TargetConstraintDoesSummon : TargetConstraint
{
    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public override bool Check(CardData targetData)
    {
        bool flag = false;
        CardData.StatusEffectStacks[] startWithEffects = targetData.startWithEffects;
        foreach (CardData.StatusEffectStacks statusEffectStacks in startWithEffects)
        {
            if ((statusEffectStacks.data is StatusEffectSummon statusEffectSummon && statusEffectSummon.summonCard.cardType.unit) || (statusEffectStacks.data is StatusEffectApplyX { effectToApply: StatusEffectInstantSummon effectToApply } && effectToApply.targetSummon.summonCard.cardType.unit))
            {
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            startWithEffects = targetData.attackEffects;
            for (int i = 0; i < startWithEffects.Length; i++)
            {
                if (startWithEffects[i].data is StatusEffectInstantSummon statusEffectInstantSummon && statusEffectInstantSummon.targetSummon.summonCard.cardType.unit)
                {
                    flag = true;
                    break;
                }
            }
        }
        if (!flag)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Effects More Than", menuName = "Target Constraints/Effects More Than")]
public class TargetConstraintEffectsMoreThan : TargetConstraint
{
    [SerializeField]
    public int amount;

    public override bool Check(Entity target)
    {
        if (CheckAttackEffects(target))
        {
            return !not;
        }
        if (CheckPassiveEffects(target))
        {
            return !not;
        }
        return not;
    }

    public override bool Check(CardData targetData)
    {
        if (CheckAttackEffects(targetData))
        {
            return !not;
        }
        if (CheckPassiveEffects(targetData))
        {
            return !not;
        }
        if (CheckTraits(targetData))
        {
            return !not;
        }
        return not;
    }

    public bool CheckAttackEffects(Entity target)
    {
        return CheckAttackEffects(target.attackEffects);
    }

    public bool CheckAttackEffects(CardData targetData)
    {
        return CheckAttackEffects(targetData.attackEffects);
    }

    public bool CheckAttackEffects(IEnumerable<CardData.StatusEffectStacks> effects)
    {
        return effects?.Any((CardData.StatusEffectStacks e) => e.data.stackable && e.count > amount) ?? false;
    }

    public bool CheckPassiveEffects(Entity target)
    {
        return CheckPassiveEffects(target.statusEffects);
    }

    public bool CheckPassiveEffects(CardData targetData)
    {
        if (targetData.startWithEffects == null)
        {
            return false;
        }
        CardData.StatusEffectStacks[] array = targetData.startWithEffects.Where((CardData.StatusEffectStacks e) => e.data.canBeBoosted).ToArray();
        if (array.Length != 0)
        {
            return array.All((CardData.StatusEffectStacks e) => e.count > amount);
        }
        return false;
    }

    public bool CheckPassiveEffects(IEnumerable<StatusEffectData> effects)
    {
        if (effects == null)
        {
            return false;
        }
        StatusEffectData[] array = effects.Where((StatusEffectData e) => e.canBeBoosted).ToArray();
        if (array.Length != 0)
        {
            return array.All((StatusEffectData e) => e.count > amount);
        }
        return false;
    }

    public bool CheckTraits(Entity target)
    {
        if (target.traits == null)
        {
            return false;
        }
        foreach (Entity.TraitStacks trait in target.traits)
        {
            if (CheckPassiveEffects(trait.data.effects))
            {
                return true;
            }
        }
        return false;
    }

    public bool CheckTraits(CardData targetData)
    {
        if (targetData.traits == null)
        {
            return false;
        }
        foreach (CardData.TraitStacks trait in targetData.traits)
        {
            if (CheckPassiveEffects(trait.data.effects))
            {
                return true;
            }
        }
        return false;
    }
}
[CreateAssetMenu(fileName = "Has Any Effect", menuName = "Target Constraints/Has Any Effect")]
public class TargetConstraintHasAnyEffect : TargetConstraint
{
    public override bool Check(CardData targetData)
    {
        CardData.StatusEffectStacks[] attackEffects = targetData.attackEffects;
        if ((attackEffects == null || attackEffects.Length <= 0) && (targetData.startWithEffects == null || !targetData.startWithEffects.Any((CardData.StatusEffectStacks a) => !a.data.isStatus)))
        {
            List<CardData.TraitStacks> traits = targetData.traits;
            if (traits != null)
            {
                return traits.Count > 0;
            }
            return false;
        }
        return true;
    }

    public override bool Check(Entity target)
    {
        List<CardData.StatusEffectStacks> attackEffects = target.attackEffects;
        if (attackEffects == null || attackEffects.Count <= 0)
        {
            if (target.statusEffects != null)
            {
                return target.statusEffects.Any((StatusEffectData a) => !a.isStatus);
            }
            return false;
        }
        return true;
    }
}
[CreateAssetMenu(fileName = "Has Attack Effect", menuName = "Target Constraints/Has Attack Effect")]
public class TargetConstraintHasAttackEffect : TargetConstraint
{
    [SerializeField]
    public StatusEffectData effect;

    public override bool Check(Entity target)
    {
        if (!target.attackEffects.Any((CardData.StatusEffectStacks a) => a.data == effect))
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        if (!targetData.attackEffects.Any((CardData.StatusEffectStacks a) => a.data == effect))
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Has Crown", menuName = "Target Constraints/Has Crown")]
public class TargetConstraintHasCrown : TargetConstraint
{
    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public override bool Check(CardData targetData)
    {
        if (!(targetData.upgrades.Find((CardUpgradeData a) => a.type == CardUpgradeData.Type.Crown) != null))
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Has Effect Based On", menuName = "Target Constraints/Has Effect Based On")]
public class TargetConstraintHasEffectBasedOn : TargetConstraint
{
    [SerializeField]
    public string basedOnStatusType;

    public override bool Check(CardData targetData)
  {
    foreach (CardData.StatusEffectStacks attackEffect in targetData.attackEffects)
    {
      if (attackEffect.data is StatusEffectInstantDoubleX data && data.statusToDouble.type == this.basedOnStatusType)
        return !this.not;
      if (attackEffect.data.type == this.basedOnStatusType)
        return !this.not;
    }
    foreach (CardData.StatusEffectStacks startWithEffect in targetData.startWithEffects)
    {
      switch (startWithEffect.data)
      {
        case StatusEffectApplyXWhenYAppliedTo applyXwhenYappliedTo:
          if (applyXwhenYappliedTo.whenAppliedTypes.Contains<string>(this.basedOnStatusType) || (bool) (Object) applyXwhenYappliedTo.effectToApply && applyXwhenYappliedTo.effectToApply.type == this.basedOnStatusType)
            return !this.not;
          break;
        case StatusEffectApplyXWhenYAppliedToAlly xwhenYappliedToAlly:
          if (xwhenYappliedToAlly.whenAppliedType == this.basedOnStatusType || (bool) (Object) xwhenYappliedToAlly.effectToApply && xwhenYappliedToAlly.effectToApply.type == this.basedOnStatusType)
            return !this.not;
          break;
        case StatusEffectApplyXWhenYAppliedToSelf xwhenYappliedToSelf:
          if (xwhenYappliedToSelf.whenAppliedType == this.basedOnStatusType || (bool) (Object) xwhenYappliedToSelf.effectToApply && xwhenYappliedToSelf.effectToApply.type == this.basedOnStatusType)
            return !this.not;
          break;
        case StatusEffectApplyX statusEffectApplyX:
          if ((bool) (Object) statusEffectApplyX.effectToApply && statusEffectApplyX.effectToApply.type == this.basedOnStatusType)
            return !this.not;
          break;
        case StatusEffectBonusDamageEqualToX bonusDamageEqualToX:
          if (bonusDamageEqualToX.effectType == this.basedOnStatusType)
            return !this.not;
          break;
      }
    }
    return this.not;
  }

    public override bool Check(Entity target)
    {
        return Check(target.data);
    }
}
[CreateAssetMenu(fileName = "Has Health", menuName = "Target Constraints/Has Health")]
public class TargetConstraintHasHealth : TargetConstraint
{
    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public override bool Check(CardData targetData)
    {
        if (!targetData.hasHealth)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Has Reaction", menuName = "Target Constraints/Has Reaction")]
public class TargetConstraintHasReaction : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if (target.statusEffects.Any((StatusEffectData effect) => effect.isReaction))
        {
            return !not;
        }
        return not;
    }

    public override bool Check(CardData targetData)
    {
        if (targetData.startWithEffects.Any((CardData.StatusEffectStacks effectStacks) => effectStacks.data.isReaction))
        {
            return !not;
        }
        return not;
    }
}
[CreateAssetMenu(fileName = "Has Status", menuName = "Target Constraints/Has Status")]
public class TargetConstraintHasStatus : TargetConstraint
{
    [SerializeField]
    public StatusEffectData status;

    public override bool Check(Entity target)
    {
        if (!target.statusEffects.Any((StatusEffectData a) => (a).name == (status).name))
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        bool flag = false;
        CardData.StatusEffectStacks[] startWithEffects = targetData.startWithEffects;
        for (int i = 0; i < startWithEffects.Length; i++)
        {
            if ((startWithEffects[i].data).name == (status).name)
            {
                flag = true;
                break;
            }
        }
        if (!not)
        {
            return flag;
        }
        return !flag;
    }

    public bool CheckWillApply(Hit hit)
    {
        bool flag = false;
        List<CardData.StatusEffectStacks> statusEffects = hit.statusEffects;
        if (statusEffects != null && statusEffects.Count > 0)
        {
            foreach (CardData.StatusEffectStacks statusEffect in hit.statusEffects)
            {
                if ((statusEffect.data).name == (status).name)
                {
                    flag = true;
                    break;
                }
            }
        }
        if (!not)
        {
            return flag;
        }
        return !flag;
    }
}
[CreateAssetMenu(fileName = "Has Status Type", menuName = "Target Constraints/Has Status Type")]
public class TargetConstraintHasStatusType : TargetConstraint
{
    [SerializeField]
    public string statusType;

    public override bool Check(Entity target)
    {
        if (!(target.FindStatus(statusType)))
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        CardData.StatusEffectStacks[] startWithEffects = targetData.startWithEffects;
        for (int i = 0; i < startWithEffects.Length; i++)
        {
            if (startWithEffects[i].data.type == statusType)
            {
                return !not;
            }
        }
        return not;
    }
}
[CreateAssetMenu(fileName = "Has Trait", menuName = "Target Constraints/Has Trait")]
public class TargetConstraintHasTrait : TargetConstraint
{
    [SerializeField]
    public TraitData trait;

    [SerializeField]
    public bool ignoreSilenced;

    public override bool Check(Entity target)
    {
        if (ignoreSilenced && target.silenced)
        {
            return not;
        }
        bool flag = false;
        foreach (Entity.TraitStacks trait in target.traits)
        {
            if ((trait.data).name == (this.trait).name)
            {
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        bool flag = false;
        foreach (CardData.TraitStacks trait in targetData.traits)
        {
            if ((trait.data).name == (this.trait).name)
            {
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Has Upgrade Of Type", menuName = "Target Constraints/Has Upgrade Of Type")]
public class TargetConstraintHasUpgradeOfType : TargetConstraint
{
    [SerializeField]
    public CardUpgradeData.Type type = CardUpgradeData.Type.Charm;

    [SerializeField]
    public int countRequired = 1;

    [SerializeField]
    public CardUpgradeData[] ignore;

    public override bool Check(CardData targetData)
    {
        int num = 0;
        foreach (CardUpgradeData upgrade in targetData.upgrades)
        {
            if (upgrade.type == type && !IArrayExt.Contains<CardUpgradeData>(ignore, upgrade) && ++num >= countRequired)
            {
                break;
            }
        }
        if (num < countRequired)
        {
            return not;
        }
        return !not;
    }

    public override bool Check(Entity target)
    {
        return Check(target.data);
    }
}
[CreateAssetMenu(fileName = "Health More Than", menuName = "Target Constraints/Health More Than")]
public class TargetConstraintHealthMoreThan : TargetConstraint
{
    [SerializeField]
    public int value;

    public override bool Check(Entity target)
    {
        if (target.hp.current <= value)
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        if (targetData.hp <= value)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Is Alive", menuName = "Target Constraints/Is Alive")]
public class TargetConstraintIsAlive : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if (!target.alive || target.ReadyToDie())
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        return !not;
    }
}
[CreateAssetMenu(fileName = "Is Card Type", menuName = "Target Constraints/Is Card Type")]
public class TargetConstraintIsCardType : TargetConstraint
{
    [SerializeField]
    public CardType[] allowedTypes;

    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public override bool Check(CardData targetData)
    {
        if (!IArrayExt.Contains<CardType>(allowedTypes, targetData.cardType))
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Is In Deck", menuName = "Target Constraints/Is In Deck")]
public class TargetConstraintIsInDeck : TargetConstraint
{
    [SerializeField]
    public bool includeReserve = true;

    public override bool Check(CardData targetData)
    {
        if (References.PlayerData == null)
        {
            return false;
        }
        if (!IsInDeck(targetData))
        {
            if (includeReserve)
            {
                return IsInReserve(targetData);
            }
            return false;
        }
        return true;
    }

    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public static bool IsInDeck(CardData cardData)
    {
        return References.PlayerData.inventory.deck.Contains(cardData);
    }

    public static bool IsInReserve(CardData cardData)
    {
        return References.PlayerData.inventory.reserve.Contains(cardData);
    }
}
[CreateAssetMenu(fileName = "Is Item", menuName = "Target Constraints/Is Item")]
public class TargetConstraintIsItem : TargetConstraint
{
    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public override bool Check(CardData targetData)
    {
        if (!targetData.cardType.item)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Is Offensive", menuName = "Target Constraints/Is Offensive")]
public class TargetConstraintIsOffensive : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if (!target.HasAttackIcon() && !target.IsOffensive())
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        if (!targetData.IsOffensive())
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Is Specific Card", menuName = "Target Constraints/Is Specific Card")]
public class TargetConstraintIsSpecificCard : TargetConstraint
{
    [SerializeField]
    public CardData[] allowedCards;

    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public override bool Check(CardData targetData)
    {
        if (!allowedCards.Any((CardData a) => (a).name == (targetData).name))
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Is Unit", menuName = "Target Constraints/Is Unit")]
public class TargetConstraintIsUnit : TargetConstraint
{
    [SerializeField]
    public bool mustBeMiniboss;

    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public override bool Check(CardData targetData)
    {
        if (!(targetData))
        {
            return not;
        }
        CardType cardType = targetData.cardType;
        if (!(cardType) || !cardType.unit || !CheckMiniboss(cardType))
        {
            return not;
        }
        return !not;
    }

    public bool CheckMiniboss(CardType cardType)
    {
        if (mustBeMiniboss)
        {
            return cardType.miniboss;
        }
        return true;
    }
}
[CreateAssetMenu(fileName = "Max Counter More Than", menuName = "Target Constraints/Max Counter More Than")]
public class TargetConstraintMaxCounterMoreThan : TargetConstraint
{
    [SerializeField]
    public int moreThan;

    public override bool Check(Entity target)
    {
        if (target.counter.max <= moreThan)
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        if (targetData.counter <= moreThan)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Needs Target", menuName = "Target Constraints/Needs Target")]
public class TargetConstraintNeedsTarget : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if (!target.NeedsTarget)
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        if (!targetData.needsTarget)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Is On Board", menuName = "Target Constraints/Is On Board")]
public class TargetConstraintOnBoard : TargetConstraint
{
    public override bool Check(Entity target)
    {
        if (!Battle.IsOnBoard(target))
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        return not;
    }
}
[CreateAssetMenu(fileName = "Or", menuName = "Target Constraints/Or")]
public class TargetConstraintOr : TargetConstraint
{
    [SerializeField]
    public TargetConstraint[] constraints;

    public override bool Check(Entity target)
    {
        TargetConstraint[] array = constraints;
        for (int i = 0; i < array.Length; i++)
        {
            if (array[i].Check(target))
            {
                return !not;
            }
        }
        return not;
    }

    public override bool Check(CardData targetData)
    {
        TargetConstraint[] array = constraints;
        for (int i = 0; i < array.Length; i++)
        {
            if (array[i].Check(targetData))
            {
                return !not;
            }
        }
        return not;
    }
}
[CreateAssetMenu(fileName = "Plays On", menuName = "Target Constraints/Plays On")]
public class TargetConstraintPlayOnSlot : TargetConstraint
{
    [SerializeField]
    public bool slot;

    [SerializeField]
    public bool board;

    [SerializeField]
    public bool hand;

    [SerializeField]
    public bool enemy;

    [SerializeField]
    public bool friendly;

    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public override bool Check(CardData targetData)
    {
        if ((slot && !targetData.playOnSlot) || (board && !targetData.canPlayOnBoard) || (hand && !targetData.canPlayOnHand) || (enemy && !targetData.canPlayOnEnemy) || (friendly && !targetData.canPlayOnFriendly))
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Play Type", menuName = "Target Constraints/Play Type")]
public class TargetConstraintPlayType : TargetConstraint
{
    [SerializeField]
    public Card.PlayType targetPlayType;

    public override bool Check(Entity target)
    {
        return Check(target.data);
    }

    public override bool Check(CardData targetData)
    {
        if (targetData.playType != targetPlayType)
        {
            return not;
        }
        return !not;
    }
}
[CreateAssetMenu(fileName = "Status More Than", menuName = "Target Constraints/Status More Than")]
public class TargetConstraintStatusMoreThan : TargetConstraint
{
    [SerializeField]
    public StatusEffectData status;

    [SerializeField]
    public int amount;

    public override bool Check(Entity target)
    {
        StatusEffectData statusEffectData = target.FindStatus(status.type);
        if (!(statusEffectData) || statusEffectData.count <= amount)
        {
            return not;
        }
        return !not;
    }

    public override bool Check(CardData targetData)
    {
        CardData.StatusEffectStacks[] startWithEffects = targetData.startWithEffects;
        foreach (CardData.StatusEffectStacks statusEffectStacks in startWithEffects)
        {
            if (statusEffectStacks.data.type == status.type && statusEffectStacks.count > amount)
            {
                return !not;
            }
        }
        return not;
    }
}
[CreateAssetMenu(fileName = "TargetModeAll", menuName = "Target Modes/All")]
public class TargetModeAll : TargetMode
{
    [SerializeField]
    public TargetConstraint[] constraints;

    public override bool NeedsTarget => false;

    public override Entity[] GetPotentialTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        HashSetExt.AddRange<Entity>(hashSet, from e in entity.GetAllEnemies()
                                             where (e) && ((Behaviour)e).enabled && e.alive && e.canBeHit && CheckConstraints(e)
                                             select e);
        if (hashSet.Count <= 0)
        {
            return null;
        }
        return HashSetExt.ToArray<Entity>(hashSet);
    }

    public override Entity[] GetSubsequentTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        HashSetExt.AddRange<Entity>(hashSet, (IEnumerable<Entity>)Battle.GetCardsOnBoard(target.owner));
        hashSet.Remove(entity);
        if (hashSet.Count <= 0)
        {
            return null;
        }
        return HashSetExt.ToArray<Entity>(hashSet);
    }

    public bool CheckConstraints(Entity target)
    {
        TargetConstraint[] array = constraints;
        if (array != null && array.Length > 0)
        {
            return constraints.All((TargetConstraint c) => c.Check(target));
        }
        return true;
    }
}
[CreateAssetMenu(fileName = "TargetModeBack", menuName = "Target Modes/Back")]
public class TargetModeBack : TargetMode
{
    public override Entity[] GetPotentialTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        if ((targetContainer))
        {
            if (targetContainer.Count > 0)
            {
                hashSet.Add(GetTarget(targetContainer));
            }
        }
        else if ((target))
        {
            if (target.containers.Length != 0)
            {
                CardContainer cardContainer = IArrayExt.RandomItem<CardContainer>(target.containers);
                if (cardContainer.Count > 0)
                {
                    hashSet.Add(GetTarget(cardContainer));
                }
            }
        }
        else
        {
            int[] rowIndices = Battle.instance.GetRowIndices(entity);
            int[] array = rowIndices;
            foreach (int rowIndex in array)
            {
                AddTargets(entity, hashSet, rowIndex);
            }
            if (hashSet.Count == 0)
            {
                int rowCount = Battle.instance.rowCount;
                for (int j = 0; j < rowCount; j++)
                {
                    if (!IArrayExt.Contains<int>(rowIndices, j))
                    {
                        AddTargets(entity, hashSet, j);
                    }
                }
            }
        }
        if (hashSet.Count <= 0)
        {
            return null;
        }
        return HashSetExt.ToArray<Entity>(hashSet);
    }

    public override CardSlot[] GetTargetSlots(CardSlotLane row)
    {
        return new CardSlot[1] { row.slots[row.max - 1] };
    }

    public override bool CanTarget(Entity entity)
    {
        bool flag = false;
        CardContainer[] containers = entity.containers;
        foreach (CardContainer cardContainer in containers)
        {
            flag = true;
            for (int j = cardContainer.IndexOf(entity) + 1; j < cardContainer.max; j++)
            {
                if ((cardContainer[j]) && cardContainer[j].canBeHit)
                {
                    flag = false;
                    break;
                }
            }
            if (flag)
            {
                break;
            }
        }
        return flag;
    }

    public void AddTargets(Entity entity, HashSet<Entity> targets, int rowIndex)
    {
        List<Entity> enemiesInRow = entity.GetEnemiesInRow(rowIndex);
        Entity target = GetTarget(enemiesInRow);
        if ((target))
        {
            targets.Add(target);
            return;
        }
        target = GetEnemyCharacter(entity);
        if ((target))
        {
            targets.Add(target);
        }
    }

    public Entity GetTarget(IList<Entity> targets)
    {
        for (int num = targets.Count - 1; num >= 0; num--)
        {
            Entity entity = targets[num];
            if ((entity) && ((Behaviour)entity).enabled && entity.alive && entity.canBeHit)
            {
                return entity;
            }
        }
        return null;
    }
}
[CreateAssetMenu(fileName = "TargetModeBasic", menuName = "Target Modes/Basic")]
public class TargetModeBasic : TargetMode
{
    public override Entity[] GetPotentialTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        if ((target))
        {
            hashSet.Add(target);
        }
        else
        {
            int[] rowIndices = Battle.instance.GetRowIndices(entity);
            if (rowIndices.Length != 0)
            {
                int[] array = rowIndices;
                foreach (int rowIndex in array)
                {
                    AddTargets(entity, hashSet, rowIndex);
                }
                if (hashSet.Count == 0)
                {
                    int rowCount = Battle.instance.rowCount;
                    for (int j = 0; j < rowCount; j++)
                    {
                        if (!IArrayExt.Contains<int>(rowIndices, j))
                        {
                            AddTargets(entity, hashSet, j);
                        }
                    }
                }
            }
        }
        if (hashSet.Count <= 0)
        {
            return null;
        }
        return HashSetExt.ToArray<Entity>(hashSet);
    }

    public void AddTargets(Entity entity, HashSet<Entity> targets, int rowIndex)
    {
        List<Entity> enemiesInRow = entity.GetEnemiesInRow(rowIndex);
        Entity entity2 = null;
        foreach (Entity item in enemiesInRow)
        {
            if ((item) && ((Behaviour)item).enabled && item.alive && item.canBeHit)
            {
                entity2 = item;
                break;
            }
        }
        if ((entity2))
        {
            targets.Add(entity2);
            return;
        }
        entity2 = GetEnemyCharacter(entity);
        if ((entity2))
        {
            targets.Add(entity2);
        }
    }
}
[CreateAssetMenu(fileName = "TargetModeCrowns", menuName = "Target Modes/Crowns")]
public class TargetModeCrowns : TargetMode
{
    public override Entity[] GetPotentialTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        HashSetExt.AddRange<Entity>(hashSet, from e in entity.GetAllEnemies()
                                             where (e) && ((Behaviour)e).enabled && e.alive && e.canBeHit && e.data.HasCrown
                                             select e);
        if (hashSet.Count <= 0)
        {
            return null;
        }
        return HashSetExt.ToArray<Entity>(hashSet);
    }

    public override Entity[] GetSubsequentTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        return GetTargets(entity, target, targetContainer);
    }
}
[CreateAssetMenu(fileName = "TargetModeRandom", menuName = "Target Modes/Random")]
public class TargetModeRandom : TargetMode
{
    public override bool TargetRow => true;

    public override bool Random => true;

    public override Entity[] GetPotentialTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        if ((targetContainer))
        {
            if (targetContainer.Count > 0)
            {
                AddPotentialTargets(entity, hashSet, targetContainer);
            }
        }
        else if ((target))
        {
            switch (target.containers.Length)
            {
                case 1:
                    {
                        CardContainer collection = target.containers[0];
                        AddPotentialTargets(entity, hashSet, collection);
                        break;
                    }
                case 2:
                    {
                        int[] rowIndices = References.Battle.GetRowIndices(entity);
                        int[] rowIndices2 = References.Battle.GetRowIndices(target);
                        foreach (int item in rowIndices.Intersect(rowIndices2))
                        {
                            AddPotentialTargets(entity, hashSet, item);
                        }
                        break;
                    }
            }
        }
        else
        {
            int[] rowIndices3 = Battle.instance.GetRowIndices(entity);
            int[] array = rowIndices3;
            foreach (int rowIndex in array)
            {
                AddPotentialTargets(entity, hashSet, rowIndex);
            }
            if (hashSet.Count == 0)
            {
                int rowCount = Battle.instance.rowCount;
                for (int j = 0; j < rowCount; j++)
                {
                    if (!IArrayExt.Contains<int>(rowIndices3, j))
                    {
                        AddPotentialTargets(entity, hashSet, j);
                    }
                }
            }
        }
        if (hashSet.Count <= 0)
        {
            return null;
        }
        return HashSetExt.ToArray<Entity>(hashSet);
    }

    public override Entity[] GetTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        Entity[] potentialTargets = GetPotentialTargets(entity, target, targetContainer);
        if (potentialTargets == null)
        {
            return null;
        }
        HashSet<Entity> hashSet = new HashSet<Entity>();
        if (entity.containers.Length == 1)
        {
            hashSet.Add(IArrayExt.RandomItem<Entity>(potentialTargets));
        }
        else if (entity.containers.Length > 1)
        {
            Dictionary<CardContainer, List<Entity>> dictionary = new Dictionary<CardContainer, List<Entity>>();
            CardContainer[] oppositeRows = References.Battle.GetOppositeRows(entity.containers);
            foreach (CardContainer key in oppositeRows)
            {
                dictionary.Add(key, new List<Entity>());
            }
            Entity[] array = potentialTargets;
            foreach (Entity entity2 in array)
            {
                oppositeRows = entity2.containers;
                foreach (CardContainer key2 in oppositeRows)
                {
                    if (dictionary.TryGetValue(key2, out var value))
                    {
                        value.Add(entity2);
                    }
                }
            }
            foreach (List<Entity> value2 in dictionary.Values)
            {
                if (value2.Count > 0)
                {
                    hashSet.Add(IListExt.RandomItem<Entity>((IList<Entity>)value2));
                }
            }
        }
        if (hashSet.Count <= 0)
        {
            return null;
        }
        return HashSetExt.ToArray<Entity>(hashSet);
    }

    public override Entity[] GetSubsequentTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        return GetTargets(entity, target, targetContainer);
    }

    public override CardSlot[] GetTargetSlots(CardSlotLane row)
    {
        return new CardSlot[1] { IListExt.RandomItem<CardSlot>((IList<CardSlot>)row.slots) };
    }

    public static void AddPotentialTargets(Entity entity, HashSet<Entity> targets, IEnumerable<Entity> collection)
    {
        foreach (Entity item in collection)
        {
            if (entity.CanPlayOn(item, ignoreRowCheck: true))
            {
                targets.Add(item);
            }
        }
    }

    public static void AddPotentialTargets(Entity entity, HashSet<Entity> targets, int rowIndex)
    {
        List<Entity> enemiesInRow = entity.GetEnemiesInRow(rowIndex);
        AddPotentialTargets(entity, targets, enemiesInRow);
    }
}
[CreateAssetMenu(fileName = "TargetModeRow", menuName = "Target Modes/Row")]
public class TargetModeRow : TargetMode
{
    public override bool TargetRow => true;

    public override Entity[] GetPotentialTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        if ((targetContainer))
        {
            AddEligible(entity, hashSet, targetContainer);
        }
        else if ((target))
        {
            switch (target.containers.Length)
            {
                case 1:
                    {
                        CardContainer fromCollection = target.containers[0];
                        AddEligible(entity, hashSet, fromCollection);
                        break;
                    }
                case 2:
                    {
                        int[] rowIndices = References.Battle.GetRowIndices(entity);
                        int[] rowIndices2 = References.Battle.GetRowIndices(target);
                        foreach (int item in rowIndices.Intersect(rowIndices2))
                        {
                            List<Entity> enemiesInRow = entity.GetEnemiesInRow(item);
                            AddEligible(entity, hashSet, enemiesInRow);
                        }
                        break;
                    }
            }
        }
        else
        {
            int[] rowIndices3 = Battle.instance.GetRowIndices(entity);
            int[] array = rowIndices3;
            foreach (int rowIndex in array)
            {
                List<Entity> enemiesInRow2 = entity.GetEnemiesInRow(rowIndex);
                AddEligible(entity, hashSet, enemiesInRow2);
            }
            if (hashSet.Count == 0)
            {
                int rowCount = Battle.instance.rowCount;
                for (int j = 0; j < rowCount; j++)
                {
                    if (!IArrayExt.Contains<int>(rowIndices3, j))
                    {
                        List<Entity> enemiesInRow3 = entity.GetEnemiesInRow(j);
                        AddEligible(entity, hashSet, enemiesInRow3);
                    }
                }
            }
        }
        if (hashSet.Count <= 0)
        {
            return null;
        }
        return HashSetExt.ToArray<Entity>(hashSet);
    }

    public override Entity[] GetSubsequentTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        return GetTargets(entity, target, targetContainer);
    }

    public static void AddEligible(Entity entity, ISet<Entity> targets, IEnumerable<Entity> fromCollection)
    {
        foreach (Entity item in fromCollection)
        {
            if (entity.CanPlayOn(item, ignoreRowCheck: true))
            {
                targets.Add(item);
            }
        }
    }
}
public class ActionApplyStatus : PlayAction
{
    public Entity target;

    public Entity applier;

    public StatusEffectData status;

    public int stacks;

    public bool temporary;

    public ActionApplyStatus(Entity target, Entity applier, StatusEffectData status, int stacks, bool temporary = false)
    {
        this.target = target;
        this.applier = applier;
        this.status = status;
        this.stacks = stacks;
        this.temporary = temporary;
    }

    public override IEnumerator Run()
    {
        yield return StatusEffectSystem.Apply(target, applier, status, stacks, temporary);
        yield return Sequences.Wait(0.6f);
    }
}
public class ActionChangePhase : PlayAction
{
    public readonly Entity entity;

    public readonly CardData newPhase;

    public readonly CardData[] newPhases;

    public readonly CardAnimation animation;

    public List<Entity> newCards;

    public bool loadingNewCards;

    public ActionChangePhase(Entity entity, CardData newPhase, CardAnimation animation)
    {
        this.entity = entity;
        this.newPhase = newPhase;
        this.animation = animation;
    }

    public ActionChangePhase(Entity entity, CardData[] newPhases, CardAnimation animation)
    {
        this.entity = entity;
        this.newPhases = newPhases;
        this.animation = animation;
    }

    public override IEnumerator Run()
    {
        if (!entity.IsAliveAndExists())
        {
            yield break;
        }
        Events.InvokeEntityChangePhase(entity);
        CardData[] array = newPhases;
        bool multipleNewPhases = array != null && array.Length > 0;
        if (multipleNewPhases)
        {
            new Routine(CreateNewCards());
        }
        PauseMenu.Block();
        DeckpackBlocker.Block();
        if (Deckpack.IsOpen && References.Player.entity.display is CharacterDisplay characterDisplay)
        {
            characterDisplay.CloseInventory();
        }
        ChangePhaseAnimationSystem animationSystem = Object.FindObjectOfType<ChangePhaseAnimationSystem>();
        if ((animationSystem))
        {
            yield return animationSystem.Focus(entity);
        }
        if ((animation))
        {
            yield return animation.Routine(entity);
        }
        PlayAction[] actions = ActionQueue.GetActions();
        foreach (PlayAction PlayAction in actions)
        {
            if (!(Playaction is ActionTrigger actionTrigger))
            {
                if (Playaction is ActionEffectApply actionEffectApply)
                {
                    actionEffectApply.TryRemoveEntity(entity);
                }
            }
            else if (actionTrigger.entity == entity)
            {
                ActionQueue.Remove(playAction);
            }
        }
        if (multipleNewPhases)
        {
            ActionQueue.Stack(new ActionSequence(Split(entity, newPhases))
            {
                note = "Split boss",
                priority = 10
            }, fixedPosition: true);
        }
        else
        {
            ActionQueue.Stack(new ActionSequence(Change(entity, newPhase))
            {
                note = "Change boss phase",
                priority = 10
            }, fixedPosition: true);
        }
        if ((animationSystem))
        {
            ActionQueue.Stack(new ActionSequence(animationSystem.UnFocus())
            {
                note = "Unfocus boss",
                priority = 10
            }, fixedPosition: true);
        }
    }

    public static IEnumerator Change(Entity entity, CardData newData)
    {
        entity.alive = false;
        yield return entity.ClearStatuses();
        entity.data = newData;
        yield return entity.display.UpdateData(doPing: true);
        entity.alive = true;
        yield return StatusEffectSystem.EntityEnableEvent(entity);
    }

    public IEnumerator Split(Entity entity, IEnumerable<CardData> split)
    {
        entity.alive = false;
        while (loadingNewCards)
        {
            yield return null;
        }
        int num = 0;
        int count = entity.actualContainers.Count;
        Dictionary<CardContainer, List<Entity>> dictionary = new Dictionary<CardContainer, List<Entity>>();
        foreach (Entity newCard in newCards)
        {
            int num2 = num % count;
            CardContainer key = entity.actualContainers[num2];
            if (dictionary.ContainsKey(key))
            {
                CardContainer key2 = entity.containers[num2];
                if (dictionary.ContainsKey(key2))
                {
                    dictionary[key2].Add(newCard);
                }
                else
                {
                    dictionary[key2] = new List<Entity> { newCard };
                }
            }
            else
            {
                dictionary[key] = new List<Entity> { newCard };
            }
            num++;
        }
        Vector3 position = entity.transform.position;
        entity.RemoveFromContainers();
        CardManager.ReturnToPool(entity);
        foreach (var (cardContainer2, list2) in dictionary)
        {
            if (list2 == null)
            {
                continue;
            }
            foreach (Entity item in list2)
            {
                cardContainer2.Add(item);
                Transform transform = item.transform;
                transform.localScale = item.GetContainerScale();
                Vector3 containerWorldPosition = item.GetContainerWorldPosition();
                transform.position = Vector3.Lerp(position, containerWorldPosition, 0.1f);
                LeanTween.move(((Component)item).gameObject, containerWorldPosition, PettyRandom.Range(0.8f, 1.2f)).setEaseOutElastic();
                item.wobbler.WobbleRandom();
            }
        }
        ChangePhaseAnimationSystem changePhaseAnimationSystem = Object.FindObjectOfType<ChangePhaseAnimationSystem>();
        MinibossIntroSystem minibossIntroSystem = Object.FindObjectOfType<MinibossIntroSystem>();
        foreach (Entity newCard2 in newCards)
        {
            if ((changePhaseAnimationSystem))
            {
                changePhaseAnimationSystem.RemoveTarget(entity);
                changePhaseAnimationSystem.Assign(newCard2);
            }
            if ((minibossIntroSystem))
            {
                minibossIntroSystem.Ignore(newCard2);
            }
        }
        ActionQueue.Stack(new ActionSequence(FinalSplit(dictionary))
        {
            note = "Final boss split",
            priority = 10
        }, fixedPosition: true);
    }

    public static IEnumerator FinalSplit(Dictionary<CardContainer, List<Entity>> toMove)
    {
        foreach (KeyValuePair<CardContainer, List<Entity>> item in toMove)
        {
            foreach (Entity item2 in item.Value)
            {
                ((Behaviour)item2).enabled = true;
                item2.RemoveFromContainers();
                item2.owner.reserveContainer.Add(item2);
                ActionQueue.Stack(new ActionMove(item2, item.Key)
                {
                    priority = 10
                }, fixedPosition: true);
                ActionQueue.Stack(new ActionRunEnableEvent(item2)
                {
                    priority = 10
                }, fixedPosition: true);
            }
        }
        yield return null;
    }

    public static IEnumerator EnableBehaviour(Behaviour system)
    {
        system.enabled = true;
        yield return null;
    }

    public IEnumerator CreateNewCards()
    {
        loadingNewCards = true;
        newCards = new List<Entity>();
        CardController controller = entity.display.hover.controller;
        Character owner = entity.owner;
        Routine.Clump clump = new Routine.Clump();
        CardData[] array = newPhases;
        for (int i = 0; i < array.Length; i++)
        {
            Card card = CardManager.Get(array[i], controller, owner, inPlay: true, owner.team == References.Player.team);
            newCards.Add(card.entity);
            clump.Add(card.UpdateData());
        }
        yield return clump.WaitForEnd();
        loadingNewCards = false;
    }
}
public class ActionCombine : PlayAction
{
    public readonly Entity[] entities;

    public readonly Entity finalEntity;

    public ActionCombine(Entity[] entities)
    {
        this.entities = entities;
        finalEntity = entities.Last();
    }

    public override IEnumerator Run()
    {
        if ((CombineSystem.instance))
        {
            yield return CombineSystem.instance.Combine(entities, finalEntity);
        }
    }
}
public class ActionConsume : PlayAction
{
    public readonly Entity target;

    public bool blocked { get; set; }

    public ActionConsume(Entity target)
    {
        this.target = target;
    }

    public override IEnumerator Run()
    {
        if (!blocked)
        {
            yield return Sequences.WaitForAnimationEnd(target);
            target.alive = true;
            yield return target.Kill(DeathType.Consume);
        }
    }

    public void Block()
    {
        target.alive = true;
        blocked = true;
    }
}
public class ActionDiscardEffect : PlayAction
{
    public readonly Entity target;

    public readonly int healAmount;

    public ActionDiscardEffect(Entity target, int healAmount)
    {
        this.target = target;
        this.healAmount = healAmount;
    }

    public override IEnumerator Run()
    {
        Routine.Clump clump = new Routine.Clump();
        if (target.data.hasHealth)
        {
            target.hp.current = Mathf.Min(target.hp.current + healAmount, target.hp.max);
            target.PromptUpdate();
            target.curveAnimator?.Ping();
            clump.Add(Sequences.Wait(0.6f));
            SfxSystem.OneShot("event:/sfx/status/heal");
        }
        clump.Add(RemoveStatuses());
        yield return clump.WaitForEnd();
    }

    public IEnumerator RemoveStatuses()
    {
        for (int i = target.statusEffects.Count - 1; i >= 0; i--)
        {
            StatusEffectData statusEffectData = target.statusEffects[i];
            if ((statusEffectData) && statusEffectData.removeOnDiscard)
            {
                yield return statusEffectData.Remove();
            }
        }
    }
}
public class ActionDraw : PlayAction
{
    public readonly Character character;

    public int count;

    public float pauseBetween;

    public ActionDraw(Character character, int count = 1, float pauseBetween = 0.1f)
    {
        this.character = character;
        this.count = count;
        this.pauseBetween = pauseBetween;
    }

    public override IEnumerator Run()
    {
        if (count <= 0 || !(character.drawContainer) || !(character.handContainer) || !(character.discardContainer))
        {
            yield break;
        }
        Events.InvokeCardDraw(count);
        while (count > 0)
        {
            yield return Sequences.Wait(pauseBetween);
            Entity top = character.drawContainer.GetTop();
            if (!(top))
            {
                Events.InvokeCardDrawEnd();
                yield return Sequences.ShuffleTo(character.discardContainer, character.drawContainer);
                top = character.drawContainer.GetTop();
                Events.InvokeCardDraw(count);
            }
            if ((top))
            {
                yield return Sequences.CardMove(top, new CardContainer[1] { character.handContainer });
                character.handContainer.TweenChildPositions();
            }
            count--;
        }
        Events.InvokeCardDrawEnd();
        ActionQueue.Stack(new ActionRevealAll(character.handContainer));
    }
}
public class ActionDrawHand : PlayAction
{
    public readonly Character character;

    public readonly float pauseBetween;

    public override bool IsRoutine => false;

    public ActionDrawHand(Character character, float pauseBetween = 0.1f)
    {
        this.character = character;
        this.pauseBetween = pauseBetween;
    }

    public override void Process()
    {
        int count = character.handContainer.max - character.handContainer.Count;
        ActionQueue.Stack(new ActionDraw(character, count, pauseBetween));
    }
}
public class ActionEarlyDeploy : PlayAction
{
    public readonly Transform transform;

    public readonly IEnumerator earlyDeployRoutine;

    public ActionEarlyDeploy(Transform transform, IEnumerator earlyDeployRoutine)
    {
        this.transform = transform;
        this.earlyDeployRoutine = earlyDeployRoutine;
    }

    public override IEnumerator Run()
    {
        SfxSystem.OneShot("event:/sfx/inventory/wave_counter_ring");
        transform.localEulerAngles = new Vector3(0f, 0f, 20f);
        LeanTween.cancel(((Component)transform).gameObject);
        LeanTween.rotateLocal(((Component)transform).gameObject, Vector3.zero, 1.5f).setEaseOutElastic();
        yield return earlyDeployRoutine;
    }
}
public class ActionEffectApply : PlayAction
{
    public class Sequence
    {
        public readonly List<Entity> targets;

        public int amount;

        public Sequence(List<Entity> targets, int amount)
        {
            this.targets = targets;
            this.amount = amount;
        }

        public override string ToString()
        {
            return string.Format("Sequence: [{0}] → {1}", string.Join(", ", targets), amount);
        }
    }

    public readonly StatusEffectApplyX effect;

    public readonly List<Entity> targets = new List<Entity>();

    public readonly List<int> amounts = new List<int>();

    public readonly List<Sequence> sequences = new List<Sequence>();

    public bool running;

    public ActionEffectApply(StatusEffectApplyX effect, List<Entity> targets, int amount)
    {
        this.effect = effect;
        sequences.Add(new Sequence(targets, amount));
    }

    public void Stack(List<Entity> newTargets, int amount)
    {
        bool flag = false;
        foreach (Sequence sequence in sequences)
        {
            if (sequence.targets.Count == newTargets.Count && IListExt.ContainsAll<Entity>((IList<Entity>)sequence.targets, (IEnumerable<Entity>)newTargets))
            {
                sequence.amount += amount;
                Debug.Log($"Stacking [{(effect).name}] {sequence.amount - amount} → {sequence.amount}");
                flag = true;
                break;
            }
            if (amount == sequence.amount && !IListExt.ContainsAny<Entity>((IList<Entity>)sequence.targets, (IEnumerable<Entity>)newTargets))
            {
                sequence.targets.AddRange(newTargets);
                Debug.Log(("Stacking [" + (effect).name + "] adding " + string.Join(", ", newTargets)));
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            sequences.Add(new Sequence(newTargets, amount));
            Debug.Log(("Stacking [" + (effect).name + "] ↓\n" + string.Join("\n", sequences)));
        }
    }

    public override IEnumerator Run()
    {
        running = true;
        foreach (Sequence sequence in sequences)
        {
            if (!(effect))
            {
                break;
            }
            yield return effect.Sequence(sequence.targets, sequence.amount);
        }
    }

    public void TryRemoveEntity(Entity entity)
    {
        foreach (Sequence sequence in sequences)
        {
            if (sequence.targets.Contains(entity))
            {
                sequence.targets.Remove(entity);
            }
        }
    }
}
public class ActionEndTurn : PlayAction
{
    public readonly Character character;

    public override bool IsRoutine => false;

    public ActionEndTurn(Character character)
    {
        this.character = character;
    }

    public override void Process()
    {
        character.endTurn = true;
    }
}
public class ActionFlee : PlayAction
{
    public readonly Entity entity;

    public ActionFlee(Entity entity)
    {
        this.entity = entity;
    }

    public override IEnumerator Run()
    {
        if (entity.IsAliveAndExists())
        {
            Debug.Log(("[" + (entity).name + "] Fleeing!"));
            CardContainer[] toContainers = new CardContainer[1] { entity.owner.reserveContainer };
            yield return Sequences.CardMove(entity, toContainers, -1, tweenAll: false);
            CardContainer cardContainer = entity.actualContainers[0];
            Vector3 localPosition = entity.transform.localPosition;
            Vector3 childPosition = cardContainer.GetChildPosition(entity);
            float time = 0.8f;
            LeanTween.moveLocalX(((Component)entity).gameObject, childPosition.x, time).setEase(LeanTweenType.linear);
            LeanTween.moveLocalY(((Component)entity).gameObject, localPosition.y + 0.5f, 0.2f).setEase(Curves.Get("Jump")).setLoopPingPong(4);
            Events.InvokeEntityFlee(entity);
            yield return (object)new WaitForSeconds(PettyRandom.Range(0.15f, 0.25f));
        }
    }
}
public class ActionInspect : PlayAction
{
    public Entity entity;

    public InspectSystem inspectSystem;

    public override bool IsRoutine => false;

    public ActionInspect(Entity entity, InspectSystem inspectSystem)
    {
        this.entity = entity;
        this.inspectSystem = inspectSystem;
    }

    public override void Process()
    {
        inspectSystem.Inspect(entity);
    }
}
public class ActionKill : PlayAction
{
    public Entity entity;

    public ActionKill(Entity entity)
    {
        this.entity = entity;
    }

    public override IEnumerator Run()
    {
        if (entity.IsAliveAndExists())
        {
            yield return Sequences.WaitForAnimationEnd(entity);
            yield return entity.Kill();
        }
    }
}
public class ActionMove : PlayAction
{
    public readonly Entity entity;

    public CardContainer[] toContainers;

    public int insertPos = -1;

    public bool tweenAll = true;

    public ActionMove(Entity entity, params CardContainer[] toContainers)
    {
        this.entity = entity;
        this.toContainers = toContainers;
    }

    public ActionMove(Entity entity, CardContainer[] toContainers, int insertPos)
    {
        this.entity = entity;
        this.toContainers = toContainers;
        this.insertPos = insertPos;
    }

    public override IEnumerator Run()
    {
        if (entity.IsAliveAndExists() && toContainers != null)
        {
            yield return Sequences.CardMove(entity, toContainers, insertPos, tweenAll);
        }
    }
}
public class ActionProcessTrigger : PlayAction
{
    public Trigger trigger;

    public readonly Func<Trigger> GetTriggerMethod;

    public ActionProcessTrigger(Trigger trigger)
    {
        this.trigger = trigger;
    }

    public ActionProcessTrigger(Func<Trigger> GetTriggerMethod)
    {
        this.GetTriggerMethod = GetTriggerMethod;
    }

    public override IEnumerator Run()
    {
        if (trigger == null && GetTriggerMethod != null)
        {
            trigger = GetTriggerMethod();
        }
        Events.InvokeEntityPreTrigger(ref trigger);
        yield return StatusEffectSystem.PreTriggerEvent(trigger);
        bool num = trigger.entity.HasAttackIcon();
        if (!num && trigger.entity.attackEffects.Count <= 0)
        {
            trigger.targets = null;
        }
        if (num)
        {
            Entity[] targets = trigger.targets;
            if ((targets == null || targets.Length <= 0) && NoTargetTextSystem.Exists())
            {
                yield return NoTargetTextSystem.Run(trigger.entity, NoTargetType.NoTargetToAttack);
            }
        }
        if (trigger.targets != null)
        {
            trigger.targets = trigger.targets.Where((Entity t) => t.IsAliveAndExists()).ToArray();
        }
        trigger.entity.triggeredBy = trigger.triggeredBy;
        Events.InvokeEntityTrigger(ref trigger);
        if (!trigger.nullified && !trigger.entity.IsSnowed)
        {
            Entity[] targets = trigger.targets;
            if (targets != null && targets.Length > 0)
            {
                yield return trigger.Process();
                yield return Sequences.Wait(0.167f);
            }
            else
            {
                yield return trigger.Process();
            }
        }
        Events.InvokeEntityTriggered(ref trigger);
        trigger.entity.triggeredBy = null;
    }
}
public class ActionRedraw : PlayAction
{
    public readonly Character character;

    public readonly int drawCount;

    public override bool IsRoutine => false;

    public ActionRedraw(Character character, int drawCount = -1)
    {
        this.character = character;
        this.drawCount = drawCount;
    }

    public override void Process()
    {
        if ((character))
        {
            DiscardAll();
            if (drawCount < 0)
            {
                ActionQueue.Add(new ActionDrawHand(character));
            }
            else if (drawCount > 0)
            {
                ActionQueue.Add(new ActionDraw(character, drawCount));
            }
        }
    }

    public void DiscardAll()
    {
        foreach (Entity item in character.handContainer)
        {
            item.display.hover.SetHoverable(value: false);
            ActionQueue.Stack(new ActionMove(item, character.discardContainer));
        }
    }
}
public class ActionReduceUses : PlayAction
{
    public readonly Entity entity;

    public ActionReduceUses(Entity entity)
    {
        this.entity = entity;
    }

    public override IEnumerator Run()
    {
        if ((entity))
        {
            yield return CardReduceUses(entity);
        }
    }

    public static IEnumerator CardReduceUses(Entity entity)
    {
        if (entity.uses.max <= 0 || entity.uses.current <= 0)
        {
            yield break;
        }
        if (--entity.uses.current <= 0)
        {
            if (entity.alive)
            {
                yield return Sequences.CardDiscard(entity);
            }
        }
        else if (entity.alive)
        {
            entity.TweenToContainer();
        }
    }
}
public class ActionRefreshWhileActiveEffect : PlayAction
{
    public readonly StatusEffectWhileActiveX effect;

    public static ulong idCurrent;

    public readonly ulong id;

    public ActionRefreshWhileActiveEffect(StatusEffectWhileActiveX effect)
    {
        this.effect = effect;
        id = idCurrent++;
    }

    public override IEnumerator Run()
    {
        yield return effect.Deactivate();
        if (effect.CanActivate())
        {
            yield return effect.Activate();
        }
        PlayAction[] actions = ActionQueue.GetActions();
        for (int num = actions.Length - 1; num >= 0; num--)
        {
            PlayAction PlayAction = actions[num];
            if (Playaction is ActionRefreshWhileActiveEffect actionRefreshWhileActiveEffect && actionRefreshWhileActiveEffect.id != id && actionRefreshWhileActiveEffect.effect.id == effect.id)
            {
                ActionQueue.Remove(playAction);
            }
        }
    }
}
public class ActionResetOffset : PlayAction
{
    public readonly Entity entity;

    public const float dur = 0.33f;

    public const LeanTweenType ease = LeanTweenType.easeOutQuint;

    public override bool IsRoutine => false;

    public ActionResetOffset(Entity entity)
    {
        this.entity = entity;
    }

    public override void Process()
    {
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        if (entity.IsAliveAndExists())
        {
            GameObject gameObject = ((Component)entity.offset).gameObject;
            LeanTween.cancel(gameObject);
            LeanTween.scale(gameObject, Vector3.one, 0.33f).setEase(LeanTweenType.easeOutQuint);
            LeanTween.moveLocal(gameObject, Vector3.zero, 0.33f).setEase(LeanTweenType.easeOutQuint);
            LeanTween.rotateLocal(gameObject, Vector3.zero, 0.33f).setEase(LeanTweenType.easeOutQuint);
            entity.ResetDrawOrder();
        }
    }
}
public class ActionReveal : PlayAction
{
    public readonly Entity entity;

    public override bool IsRoutine => false;

    public ActionReveal(Entity entity, float pauseAfter = 0f)
    {
        this.entity = entity;
        base.pauseAfter = pauseAfter;
    }

    public override void Process()
    {
        if (entity.flipper.flipped)
        {
            entity.flipper.FlipUp();
        }
        ((Behaviour)entity).enabled = true;
    }
}
public class ActionRevealAll : PlayAction
{
    public readonly CardContainer[] containers;

    public override bool IsRoutine => false;

    public ActionRevealAll(params CardContainer[] containers)
    {
        this.containers = containers;
    }

    public override void Process()
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        float num = 0.167f;
        int num2 = 1;
        CardContainer[] array = containers;
        foreach (CardContainer cardContainer in array)
        {
            if (cardContainer == null)
            {
                continue;
            }
            foreach (Entity item in cardContainer)
            {
                if (!(item == null))
                {
                    if (item.flipper.flipped)
                    {
                        ActionQueue.Insert(num2++, new ActionReveal(item, num));
                    }
                    if (!((Behaviour)item).enabled)
                    {
                        hashSet.Add(item);
                    }
                }
            }
        }
        foreach (Entity item2 in hashSet)
        {
            ActionQueue.Insert(num2++, new ActionRunEnableEvent(item2));
        }
    }
}
public class ActionRunEnableEvent : PlayAction
{
    public readonly Entity entity;

    public ActionRunEnableEvent(Entity entity)
    {
        this.entity = entity;
    }

    public override IEnumerator Run()
    {
        if (entity.StillExists())
        {
            ((Behaviour)entity).enabled = true;
            Events.InvokeEntityEnabled(entity);
            yield return StatusEffectSystem.EntityEnableEvent(entity);
        }
    }
}
public class ActionSelect : PlayAction
{
    public Entity entity;

    public System.Action<Entity> action;

    public override bool IsRoutine => false;

    public ActionSelect(Entity entity, System.Action<Entity> action)
    {
        this.entity = entity;
        this.action = action;
    }

    public override void Process()
    {
        action(entity);
    }
}
public class ActionSequence : PlayAction
{
    public readonly Routine routine;

    public ActionSequence(IEnumerator enumerator)
    {
        routine = new Routine(enumerator, autoStart: false);
    }

    public override IEnumerator Run()
    {
        routine.Start();
        while (routine.IsRunning)
        {
            yield return null;
        }
    }
}
public class ActionShove : PlayAction
{
    public readonly Dictionary<Entity, List<CardSlot>> shoveData;

    public readonly bool updatePositions;

    public ActionShove(Dictionary<Entity, List<CardSlot>> shoveData, bool updatePositions = false)
    {
        this.shoveData = shoveData;
        this.updatePositions = updatePositions;
    }

    public override IEnumerator Run()
    {
        return ShoveSystem.DoShove(shoveData, updatePositions);
    }
}
public class ActionTrigger : PlayAction
{
    public readonly Entity entity;

    public readonly Entity triggeredBy;

    public string triggerType = "basic";

    public override bool IsRoutine => false;

    public ActionTrigger(Entity entity, Entity triggeredBy)
    {
        this.entity = entity;
        this.triggeredBy = triggeredBy;
    }

    public override void Process()
    {
        if (entity.IsAliveAndExists())
        {
            Events.InvokePreProcessTrigger(entity);
            ActionQueue.Stack(new ActionProcessTrigger(GetTrigger));
        }
    }

    public virtual Trigger GetTrigger()
    {
        Entity[] targets = ((entity.targetMode) ? entity.targetMode.GetTargets(entity, null, null) : null);
        return new Trigger(entity, triggeredBy, triggerType, targets);
    }
}
public class ActionTriggerAgainst : ActionTrigger
{
    public Entity target;

    public readonly CardContainer targetContainer;

    public Trigger trigger;

    public bool countsAsTrigger = true;

    public override bool IsRoutine => false;

    public ActionTriggerAgainst(Entity entity, Entity triggeredBy, Entity target, CardContainer targetContainer)
        : base(entity, triggeredBy)
    {
        this.target = target;
        this.targetContainer = targetContainer;
    }

    public override void Process()
    {
        if (entity.IsAliveAndExists())
        {
            Events.InvokePreProcessTrigger(entity);
            ActionQueue.Stack(new ActionProcessTrigger(GetTrigger));
        }
    }

    public override Trigger GetTrigger()
    {
        Entity[] targets = GetTargets();
        if (trigger == null)
        {
            trigger = new Trigger(entity, triggeredBy, triggerType, targets);
        }
        trigger.triggerAgainst = true;
        trigger.triggerAgainstTarget = target;
        trigger.triggerAgainstContainer = targetContainer;
        trigger.countsAsTrigger = countsAsTrigger;
        return trigger;
    }

    public virtual Entity[] GetTargets()
    {
        if (!countsAsTrigger)
        {
            return new Entity[1] { target };
        }
        if (!(entity.targetMode))
        {
            return null;
        }
        return entity.targetMode.GetTargets(entity, target, targetContainer);
    }
}
public class ActionTriggerByCounter : ActionTrigger
{
    public override bool IsRoutine => false;

    public ActionTriggerByCounter(Entity entity, Entity triggeredBy)
        : base(entity, triggeredBy)
    {
    }

    public override void Process()
    {
        if (entity.IsAliveAndExists())
        {
            Events.InvokePreProcessTrigger(entity);
            ActionQueue.Stack(new ActionProcessTrigger(GetTrigger));
        }
    }
}
public class ActionTriggerSubsequent : ActionTriggerAgainst
{
    public ActionTriggerSubsequent(Entity entity, Entity triggeredBy, Entity target, CardContainer targetContainer)
        : base(entity, triggeredBy, target, targetContainer)
    {
    }

    public override Entity[] GetTargets()
    {
        if (!(entity.targetMode))
        {
            return null;
        }
        return entity.targetMode.GetSubsequentTargets(entity, target, targetContainer);
    }
}
public abstract class PlayAction
{
    public float pauseBefore;

    public float pauseAfter;

    public int priority;

    public bool fixedPosition;

    public bool parallel;

    public string note;

    public virtual bool IsRoutine => true;

    public virtual string Name => GetType().Name + (StringExt.IsNullOrWhitespace(note) ? "" : (" [" + note + "]"));

    public virtual void Process()
    {
    }

    public virtual IEnumerator Run()
    {
        return null;
    }

    public PlayAction()
    {
    }
}
public class ActionQueue : MonoBehaviourSingleton<ActionQueue>
{
    public readonly List<PlayAction> queue = new List<PlayAction>();

    [SerializeField]
    public int count;

    [SerializeField]
    public float delayBefore;

    [SerializeField]
    public float delayAfter;

    public static PlayAction current;

    public static readonly Routine.Clump parallelClump = new Routine.Clump();

    public static bool Empty => ActionQueue.instance.count <= 0;

    public static PlayAction Insert(int index, PlayAction action, bool fixedPosition = false)
    {
        if (fixedPosition)
        {
            action.fixedPosition = true;
        }
        int num = 0;
        for (num = index; num < ActionQueue.instance.count && ActionQueue.instance.queue[num].fixedPosition; num++)
        {
        }
        ActionQueue.instance.queue.Insert(num, action);
        ActionQueue.instance.count++;
        Events.InvokeActionQueued(action);
        return action;
    }

    public static PlayAction Add(PlayAction action, bool fixedPosition = false)
    {
        return Insert(ActionQueue.instance.count, action, fixedPosition);
    }

    public static PlayAction Stack(PlayAction action, bool fixedPosition = false)
    {
        return Insert(0, action, fixedPosition);
    }

    public static PlayAction[] GetActions()
    {
        return ActionQueue.instance.queue.ToArray();
    }

    public static int IndexOf(PlayAction action)
    {
        return ActionQueue.instance.queue.IndexOf(action);
    }

    public static bool Remove(PlayAction action)
    {
        if (IndexOf(action) >= 0 && System.Action != current)
        {
            ActionQueue.instance.queue.Remove(action);
            ActionQueue.instance.count--;
            return true;
        }
        return false;
    }

    public static IEnumerator Wait(bool includeParallel = true)
    {
        while (ActionQueue.instance.count > 0)
        {
            yield return null;
        }
        if (includeParallel)
        {
            yield return parallelClump.WaitForEnd();
        }
    }

    public void Start()
    {
        StartCoroutine(Routine());
    }

    public static void Restart()
    {
        Debug.Log("~ System.Action QUEUE RESET ~");
        ((MonoBehaviour)ActionQueue.instance).StopAllCoroutines();
        ActionQueue.instance.queue.Clear();
        ActionQueue.instance.count = 0;
        current = null;
        parallelClump.Clear();
        ((MonoBehaviour)ActionQueue.instance).StartCoroutine(ActionQueue.instance.Routine());
    }

    public IEnumerator Routine()
    {
        while (true)
        {
            if (count > 0 && !GameManager.paused && !Deckpack.IsOpen && current == null)
            {
                yield return RunActionRoutine();
            }
            else
            {
                yield return null;
            }
        }
    }

    public IEnumerator RunActionRoutine()
    {
        int index = GetIndexOfHighestPriorityAction(queue);
        current = queue[index];
        current.fixedPosition = true;
        if (current.parallel)
        {
            RunParallel(current);
            queue.RemoveAt(index);
            count--;
        }
        else
        {
            yield return PerformAction(current);
            queue.RemoveAt(index);
            count--;
            yield return PostAction(current);
        }
        current = null;
    }

    public static int GetIndexOfHighestPriorityAction(IReadOnlyList<PlayAction> actions)
    {
        int num = int.MinValue;
        int result = -1;
        int num2 = actions.Count;
        for (int i = 0; i < num2; i++)
        {
            PlayAction PlayAction = actions[i];
            if (playAction.priority > num)
            {
                num = playAction.priority;
                result = i;
            }
        }
        return result;
    }

    public IEnumerator Run(PlayAction action)
    {
        yield return PerformAction(action);
        yield return PostAction(action);
    }

    public IEnumerator PerformAction(PlayAction action)
    {
        Events.InvokeActionPerform(action);
        if (action.pauseBefore + delayBefore > 0f)
        {
            yield return Sequences.Wait(action.pauseBefore + delayBefore);
        }
        if (action.IsRoutine)
        {
            yield return action.Run();
        }
        else
        {
            action.Process();
        }
    }

    public IEnumerator PostAction(PlayAction action)
    {
        Events.InvokeActionFinished(action);
        yield return StatusEffectSystem.ActionPerformedEvent(action);
        if (action.pauseAfter + delayAfter > 0f)
        {
            yield return Sequences.Wait(action.pauseAfter + delayAfter);
        }
    }

    public static void RunParallel(PlayAction action)
    {
        parallelClump.Add(ActionQueue.instance.Run(action));
    }
}
public class AngleWobbler : MonoBehaviour
{
    public Transform holder;

    public Transform target;

    public bool globalSpace = true;

    [SerializeField]
    public Vector3 movementInfluence = new Vector3(-1f, 0.5f, 0f);

    [SerializeField]
    public float rotationMax = 45f;

    [SerializeField]
    public Vector2 wobbleFactorRange = new Vector2(4.5f, 5.5f);

    [SerializeField]
    public Vector2 wobbleDampingRange = new Vector2(0.9f, 0.95f);

    [SerializeField]
    public Vector2 wobbleAccRange = new Vector2(0.65f, 0.75f);

    [SerializeField]
    [ReadOnly]
    public float wobbleFactor;

    [SerializeField]
    [ReadOnly]
    public float wobbleDamping;

    [SerializeField]
    [ReadOnly]
    public float wobbleAcc;

    public Vector3 prePosition;

    public float rotation;

    public float rotationVelocity;

    public float startAngle;

    public Vector3 HolderPosition => holder.position;

    public void Awake()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        SetAngle(target.localEulerAngles.z);
        wobbleFactor = Vector2Ext.PettyRandom(wobbleFactorRange);
        wobbleDamping = Vector2Ext.PettyRandom(wobbleDampingRange);
        wobbleAcc = Vector2Ext.PettyRandom(wobbleAccRange);
    }

    public void OnEnable()
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        if (holder != null)
        {
            prePosition = HolderPosition;
        }
    }

    public void Update()
    {
        //IL_00a0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ac: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c5: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0075: Unknown result type (might be due to invalid IL or missing references)
        //IL_007b: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00dd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00eb: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ec: Unknown result type (might be due to invalid IL or missing references)
        rotationVelocity -= rotation * wobbleAcc * Time.deltaTime;
        rotationVelocity = Delta.Multiply(rotationVelocity, wobbleDamping, Time.deltaTime);
        rotation += rotationVelocity * 200f * Time.deltaTime;
        if (globalSpace)
        {
            Vector3 eulerAngles = target.eulerAngles;
            target.eulerAngles = new Vector3(eulerAngles.x, eulerAngles.y, startAngle + rotation);
        }
        else
        {
            Vector3 localEulerAngles = target.localEulerAngles;
            target.localEulerAngles = new Vector3(localEulerAngles.x, localEulerAngles.y, startAngle + rotation);
        }
        Vector3 holderPosition = HolderPosition;
        Vector3 movement = holderPosition - prePosition;
        Wobble(movement);
        prePosition = holderPosition;
    }

    public void Wobble(Vector3 movement)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3.Scale(movement, movementInfluence);
        float num = ((val)).magnitude * wobbleFactor;
        rotation = Mathf.Clamp(rotation + num, 0f - rotationMax, rotationMax);
    }

    public void WobbleRandom()
    {
        float num = FloatExt.WithRandomSign(rotationMax * PettyRandom.Range(0.5f, 1f), 0.5f);
        rotation = Mathf.Clamp(rotation + num, 0f - rotationMax, rotationMax);
    }

    public void SetAngle(float angle)
    {
        startAngle = angle;
    }
}
public class CreateCardAnimation : MonoBehaviour
{
    public virtual IEnumerator Run(Entity entity, params CardData.StatusEffectStacks[] withEffects)
    {
        yield return GainEffects(entity, withEffects);
        GameObjectExt.Destroy(gameObject);
    }

    public IEnumerator DestroyOnEnd(ParticleSystem ps)
    {
        yield return (object)new WaitUntil((Func<bool>)(() => !(this) || !(ps) || !ps.isPlaying));
        if ((this) && (gameObject))
        {
            GameObjectExt.Destroy(gameObject);
        }
    }

    public static IEnumerator GainEffects(Entity entity, IEnumerable<CardData.StatusEffectStacks> withEffects)
    {
        Routine.Clump clump = new Routine.Clump();
        foreach (CardData.StatusEffectStacks withEffect in withEffects)
        {
            clump.Add(StatusEffectSystem.Apply(entity, null, withEffect.data, withEffect.count));
        }
        yield return clump.WaitForEnd();
    }
}
public class FlipCreateCardAnimation : CreateCardAnimation
{
    public static readonly Vector3 startPos = new Vector3(0f, -10f, 0f);

    public override IEnumerator Run(Entity entity, params CardData.StatusEffectStacks[] withEffects)
    {
        entity.transform.localScale = Vector3.zero;
        entity.transform.position = startPos;
        if (entity.display is Card card)
        {
            card.canvasGroup.alpha = 1f;
        }
        entity.flipper.FlipDownInstant();
        entity.curveAnimator.Ping();
        yield return CreateCardAnimation.GainEffects(entity, withEffects);
        entity.flipper.FlipUp();
        entity.wobbler.WobbleRandom();
        GameObjectExt.Destroy(gameObject);
    }
}
public class SummonCreateCardAnimation : CreateCardAnimation
{
    [SerializeField]
    public ParticleSystem inParticleSystem;

    [SerializeField]
    public ParticleSystem outParticleSystem;

    [SerializeField]
    public float chargeDelay = 0.54f;

    public override IEnumerator Run(Entity entity, params CardData.StatusEffectStacks[] withEffects)
    {
        Routine.Clump clump = new Routine.Clump();
        SfxSystem.OneShot("event:/sfx/card/summon");
        clump.Add(In());
        clump.Add(CreateCardAnimation.GainEffects(entity, withEffects));
        yield return clump.WaitForEnd();
        Out();
        yield return (object)new WaitForSeconds(chargeDelay);
        if (entity.display is Card card)
        {
            LeanTween.alphaCanvas(card.canvasGroup, 1f, 0.1f);
        }
        entity.curveAnimator.Ping();
        entity.wobbler.WobbleRandom();
        clump.Add(DestroyOnEnd(outParticleSystem));
    }

    public IEnumerator In()
    {
        inParticleSystem.Play();
        MainModule main = inParticleSystem.main;
        yield return (object)new WaitForSeconds(((main)).duration);
    }

    public void Out()
    {
        GameObjectExt.Destroy(((Component)inParticleSystem).gameObject);
        outParticleSystem.Play();
    }
}
public class Animator : MonoBehaviour
{
    [Serializable]
    public struct Animation
    {
        public enum Property
        {
            Move,
            Rotate,
            Scale
        }

        public string name;

        public Property property;

        public AnimationCurve curve;

        public Vector2 duration;

        public Vector2 delay;

        public Vector3 to;

        public Vector3 from;

        public bool hasFrom;

        public bool loop;

        public void Play(GameObject target)
        {
            //IL_0041: Unknown result type (might be due to invalid IL or missing references)
            //IL_0047: Unknown result type (might be due to invalid IL or missing references)
            //IL_0035: Unknown result type (might be due to invalid IL or missing references)
            //IL_0074: Unknown result type (might be due to invalid IL or missing references)
            //IL_007a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0068: Unknown result type (might be due to invalid IL or missing references)
            //IL_00a7: Unknown result type (might be due to invalid IL or missing references)
            //IL_00ad: Unknown result type (might be due to invalid IL or missing references)
            //IL_009b: Unknown result type (might be due to invalid IL or missing references)
            //IL_00be: Unknown result type (might be due to invalid IL or missing references)
            LeanTween.cancel(target);
            LTDescr lTDescr = null;
            switch (property)
            {
                case Property.Move:
                    if (hasFrom)
                    {
                        target.transform.localPosition = from;
                    }
                    lTDescr = LeanTween.moveLocal(target, to, Vector2Ext.PettyRandom(duration));
                    break;
                case Property.Rotate:
                    if (hasFrom)
                    {
                        target.transform.localEulerAngles = from;
                    }
                    lTDescr = LeanTween.rotateLocal(target, to, Vector2Ext.PettyRandom(duration));
                    break;
                case Property.Scale:
                    if (hasFrom)
                    {
                        target.transform.localScale = from;
                    }
                    lTDescr = LeanTween.scale(target, to, Vector2Ext.PettyRandom(duration));
                    break;
            }
            float num = Vector2Ext.PettyRandom(delay);
            if (num > 0f)
            {
                lTDescr?.setDelay(num);
            }
            lTDescr?.setEase(curve);
            if (loop)
            {
                lTDescr?.setLoopClamp();
            }
        }
    }

    [SerializeField]
    public Animation[] animations;

    public Dictionary<string, Animation> lookup;

    public void Awake()
    {
        lookup = new Dictionary<string, Animation>();
        Animation[] array = animations;
        for (int i = 0; i < array.Length; i++)
        {
            Animation value = array[i];
            lookup[value.name] = value;
        }
    }

    public void Play(string animationName)
    {
        if (lookup.ContainsKey(animationName))
        {
            lookup[animationName].Play(gameObject);
        }
    }

    public void Stop()
    {
        LeanTween.cancel(gameObject);
    }
}
public class AddressableLoader : MonoBehaviour
{
    public class Group
    {
        public readonly Dictionary<string, DataFile> lookup = new Dictionary<string, DataFile>();

        public readonly List<DataFile> list = new List<DataFile>();

        public T Get<T>(string name) where T : DataFile
        {
            if (!lookup.ContainsKey(name))
            {
                return null;
            }
            return lookup[name] as T;
        }

        public List<T> GetList<T>() where T : DataFile
        {
            return list.Cast<T>().ToList();
        }

        public void Add<T>(T obj) where T : DataFile
        {
            list.Add(obj);
            lookup[GetName(obj)] = obj;
        }

        public void Remove<T>(T obj) where T : DataFile
        {
            list.Remove(obj);
            lookup.Remove(GetName(obj));
        }

        public void AddRange<T>(IEnumerable<T> obj) where T : DataFile
        {
            foreach (T item in obj)
            {
                Add(item);
            }
        }

        public Group(IEnumerable<DataFile> items)
        {
            foreach (DataFile item in items)
            {
                list.Add(item);
                lookup[GetName(item)] = item;
            }
        }

        public static string GetName(DataFile asset)
        {
            if (asset is KeywordData keywordData)
            {
                return (keywordData).name.ToLower();
            }
            return (asset).name;
        }
    }

    [SerializeField]
    public bool initOnStart;

    public static readonly Dictionary<string, Group> groups = new Dictionary<string, Group>();

    public IEnumerator Start()
    {
        if (initOnStart)
        {
            Debug.Log("Addressables Init");
            AsyncOperationHandle<IResourceLocator> val = Addressables.InitializeAsync();
            yield return val;
            Debug.Log("Addressables Init Done");
        }
    }

    public static bool IsGroupLoaded(string name)
    {
        return groups.ContainsKey(name);
    }

    public static void ForceLoadGroup(string name)
    {
        if (StartLoadGroup(name, out var handle))
        {
            handle.WaitForCompletion();
            StoreGroup(name, handle.Result);
        }
    }

    public static async Task PreLoadGroup(string name)
    {
        if (!IsGroupLoaded(name))
        {
            StartLoadGroup(name, out var handle);
            await handle.Task;
        }
    }

    public static IEnumerator LoadGroup(string name)
    {
        if (StartLoadGroup(name, out var handle))
        {
            yield return handle;
            StoreGroup(name, handle.Result);
        }
    }

    public static bool StartLoadGroup(string name, out AsyncOperationHandle<IList<DataFile>> handle)
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        if (IsGroupLoaded(name))
        {
            Debug.Log(("Group [" + name + "] is already loaded!"));
            handle = default(AsyncOperationHandle<IList<DataFile>>);
            return false;
        }
        handle = Addressables.LoadAssetsAsync<DataFile>((object)name, (System.Action<DataFile>)null);
        return true;
    }

    public static void StoreGroup<T>(string name, ICollection<T> data) where T : DataFile
    {
        if (data == null)
        {
            data = new List<T>();
        }
        Group value = new Group(data);
        groups[name] = value;
        Debug.Log($"Group [{name}] loaded! ({data.Count} items)");
    }

    public static List<T> GetGroup<T>(string name) where T : DataFile
    {
        if (!IsGroupLoaded(name))
        {
            ForceLoadGroup(name);
        }
        return groups[name].GetList<T>();
    }

    public static void AddToGroup<T>(string name, T value) where T : DataFile
    {
        if (!IsGroupLoaded(name))
        {
            ForceLoadGroup(name);
        }
        groups[name].Add(value);
    }

    public static void RemoveFromGroup<T>(string name, T value) where T : DataFile
    {
        if (!IsGroupLoaded(name))
        {
            ForceLoadGroup(name);
        }
        groups[name].Remove(value);
    }

    public static void AddRangeToGroup<T>(string name, IEnumerable<T> value) where T : DataFile
    {
        if (!IsGroupLoaded(name))
        {
            ForceLoadGroup(name);
        }
        groups[name].AddRange(value);
    }

    public static T Get<T>(string groupName, string assetName) where T : DataFile
    {
        if (!IsGroupLoaded(groupName))
        {
            ForceLoadGroup(groupName);
        }
        try
        {
            return groups[groupName].Get<T>(assetName);
        }
        catch (Exception ex)
        {
            throw new Exception("[" + assetName + "] does not exist!\n\n" + ex.Message, ex.InnerException);
        }
    }

    public static CardData GetCardDataClone(string cardDataName)
    {
        CardData cardData = Get<CardData>("CardData", cardDataName);
        if (!(cardData))
        {
            return MissingCardSystem.GetClone(cardDataName);
        }
        return cardData.Clone();
    }

    public static T Get<T>(string assetName) where T : DataFile
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        AsyncOperationHandle<T> val = Addressables.LoadAssetAsync<T>((object)assetName);
        val.WaitForCompletion();
        return val.Result;
    }

    public static GameObject Get(string assetName)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        AsyncOperationHandle<GameObject> val = Addressables.LoadAssetAsync<GameObject>((object)assetName);
        val.WaitForCompletion();
        return val.Result;
    }

    public static bool TryGet<T>(string groupName, string assetName, out T result) where T : DataFile
    {
        if (!IsGroupLoaded(groupName))
        {
            ForceLoadGroup(groupName);
        }
        result = groups[groupName].Get<T>(assetName);
        return result != null;
    }

    public static AsyncOperationHandle<GameObject> InstantiateAsync(string key, Vector3 position, Quaternion rotation, Transform parent = null)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        return Addressables.InstantiateAsync((object)key, position, rotation, parent, true);
    }

    public static AsyncOperationHandle<GameObject> InstantiateAsync(AssetReference assetRef, Vector3 position, Quaternion rotation, Transform parent = null)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0004: Unknown result type (might be due to invalid IL or missing references)
        return assetRef.InstantiateAsync(position, rotation, parent);
    }
}
public class AddressableReleaser : MonoBehaviour
{
    [SerializeField]
    public bool releaseOnDisable = true;

    [SerializeField]
    [HideIf("releaseOnDisable")]
    public bool releaseOnDestroy;

    public readonly List<AsyncOperationHandle> handles = new List<AsyncOperationHandle>();

    [field: SerializeField]
    public int assetsToRelease { get; set; }

    public void Add(AsyncOperationHandle handle)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        handles.Add(handle);
        assetsToRelease++;
    }

    public void OnDisable()
    {
        if (releaseOnDisable)
        {
            ReleaseAll();
        }
    }

    public void OnDestroy()
    {
        if (releaseOnDestroy)
        {
            ReleaseAll();
        }
    }

    public void ReleaseAll()
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        foreach (AsyncOperationHandle handle in handles)
        {
            AsyncOperationHandle current = handle;
            Debug.Log($"→ Asset Releaser Releasing Asset: {((current)).Result}");
            Addressables.Release(current);
        }
        handles.Clear();
        assetsToRelease = 0;
    }
}
public abstract class AddressableAssetLoader<T> : MonoBehaviour
{
    [SerializeField]
    public bool instant = true;

    [SerializeField]
    public bool onEnable = true;

    [SerializeField]
    public bool releaseOnDisable = true;

    public AsyncOperationHandle<T> operation;

    public bool loaded;

    public void OnEnable()
    {
        if (onEnable)
        {
            Load();
        }
    }

    public void OnDisable()
    {
        if (releaseOnDisable)
        {
            Release();
        }
    }

    public void OnDestroy()
    {
        if (!releaseOnDisable)
        {
            Release();
        }
    }

    public void Release()
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        if (operation.IsValid())
        {
            Addressables.Release<T>(operation);
        }
        loaded = false;
    }

    public virtual void Load()
    {
    }

    public AddressableAssetLoader()
    {
    }
}
public class AddressablePrefabLoader : AddressableAssetLoader<GameObject>
{
    [SerializeField]
    public AssetReferenceGameObject prefabRef;

    [SerializeField]
    public bool setChildIndex;

    [SerializeField]
    [ShowIf("setChildIndex")]
    public int childIndex;

    [SerializeField]
    public UnityEvent<GameObject> onLoad;

    public override void Load()
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        if (loaded)
        {
            return;
        }
        operation = ((AssetReference)prefabRef).InstantiateAsync(transform, false);
        if (instant)
        {
            operation.WaitForCompletion();
            Loaded();
        }
        else
        {
            operation.Completed += delegate
            {
                Loaded();
            };
        }
        loaded = true;
    }

    public void Loaded()
    {
        if (setChildIndex)
        {
            operation.Result.transform.SetSiblingIndex(childIndex);
        }
        onLoad?.Invoke(operation.Result);
    }
}
public class AddressableSpriteLoader : AddressableAssetLoader<Sprite>
{
    public enum Type
    {
        SpriteRenderer,
        Image,
        ImageSprite
    }

    [SerializeField]
    public bool atlas = true;

    [ShowIf("atlas")]
    public AssetReferenceAtlasedSprite atlasedSpriteRef;

    [HideIf("atlas")]
    public AssetReferenceSprite spriteRef;

    [SerializeField]
    public Type type;

    [SerializeField]
    [ShowIf("IsSpriteRenderer")]
    public SpriteRenderer spriteRenderer;

    [SerializeField]
    [ShowIf("IsImage")]
    public Image image;

    [SerializeField]
    [ShowIf("IsImageSprite")]
    public ImageSprite imageSprite;

    public bool IsSpriteRenderer => type == Type.SpriteRenderer;

    public bool IsImage => type == Type.Image;

    public bool IsImageSprite => type == Type.ImageSprite;

    public override void Load()
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        if (loaded)
        {
            return;
        }
        operation = (atlas ? ((AssetReferenceT<Sprite>)(object)atlasedSpriteRef).LoadAssetAsync() : ((AssetReferenceT<Sprite>)(object)spriteRef).LoadAssetAsync());
        if (instant)
        {
            operation.WaitForCompletion();
            SetSprite();
        }
        else
        {
            operation.Completed += delegate
            {
                SetSprite();
            };
        }
        loaded = true;
    }

    public void SetSprite()
    {
        switch (type)
        {
            case Type.SpriteRenderer:
                spriteRenderer.sprite = operation.Result;
                break;
            case Type.Image:
                image.sprite = operation.Result;
                break;
            case Type.ImageSprite:
                imageSprite.SetSprite(operation.Result);
                break;
        }
    }
}
public class AddressableTieredSpriteLoader : AddressableAssetLoader<Sprite>
{
    public enum Type
    {
        SpriteRenderer,
        Image,
        ImageSprite
    }

    [Serializable]
    public struct Tier
    {
        public bool atlas;

        public AssetReferenceAtlasedSprite atlasedSpriteRef;

        public AssetReferenceSprite spriteRef;
    }

    [SerializeField]
    public Tier[] tiers;

    [SerializeField]
    public Type type;

    [SerializeField]
    [ShowIf("IsSpriteRenderer")]
    public SpriteRenderer spriteRenderer;

    [SerializeField]
    [ShowIf("IsImage")]
    public Image image;

    [SerializeField]
    [ShowIf("IsImageSprite")]
    public ImageSprite imageSprite;

    public bool IsSpriteRenderer => type == Type.SpriteRenderer;

    public bool IsImage => type == Type.Image;

    public bool IsImageSprite => type == Type.ImageSprite;

    public override void Load()
    {
        Load(0);
    }

    public void Load(int tier)
    {
        tier = Mathf.Clamp(tier, 0, tiers.Length - 1);
        Load(tiers[tier]);
    }

    public void Load(Tier tier)
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        if (loaded)
        {
            return;
        }
        operation = (tier.atlas ? ((AssetReferenceT<Sprite>)(object)tier.atlasedSpriteRef).LoadAssetAsync() : ((AssetReferenceT<Sprite>)(object)tier.spriteRef).LoadAssetAsync());
        if (instant)
        {
            operation.WaitForCompletion();
            SetSprite();
        }
        else
        {
            operation.Completed += delegate
            {
                SetSprite();
            };
        }
        loaded = true;
    }

    public void SetSprite()
    {
        switch (type)
        {
            case Type.SpriteRenderer:
                spriteRenderer.sprite = operation.Result;
                break;
            case Type.Image:
                image.sprite = operation.Result;
                break;
            case Type.ImageSprite:
                imageSprite.SetSprite(operation.Result);
                break;
        }
    }
}
public class AddressableVideoClipLoader : AddressableAssetLoader<VideoClip>
{
    public AssetReferenceT<VideoClip> videoClipRef;

    [SerializeField]
    public VideoPlayer videoPlayer;

    public override void Load()
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        if (loaded)
        {
            return;
        }
        operation = videoClipRef.LoadAssetAsync();
        if (instant)
        {
            operation.WaitForCompletion();
            SetVideoClip();
        }
        else
        {
            operation.Completed += delegate
            {
                SetVideoClip();
            };
        }
        loaded = true;
    }

    public void SetVideoClip()
    {
        videoPlayer.clip = operation.Result;
        videoPlayer.Play();
    }
}
public class AssetLoader : MonoBehaviour
{
    [Serializable]
    public class Group
    {
        public string name;

        public Object[] assets;

        public Dictionary<string, Object> lookup;
    }

    public Group[] groups;

    public static Dictionary<string, Group> groupLookup;

    public void Awake()
    {
        Debug.Log("> AssetLoader Loading Resources...");
        StopWatch.Start();
        int num = 0;
        int num2 = 0;
        groupLookup = new Dictionary<string, Group>();
        Group[] array = groups;
        foreach (Group group in array)
        {
            groupLookup[group.name.ToLower()] = group;
            group.lookup = new Dictionary<string, Object>();
            num++;
            Object[] assets = group.assets;
            foreach (Object val in assets)
            {
                group.lookup[val.name.ToLower()] = val;
                num2++;
            }
        }
        Debug.Log($"> {num} Groups");
        Debug.Log($"> {num2} Assets");
        Debug.Log($"> DONE ({StopWatch.Stop()}ms)");
    }

    public static T Lookup<T>(string groupName, string assetName) where T : Object
    {
        Object obj = GetGroup(groupName)?.lookup[assetName.ToLower()];
        return (T)(object)((obj is T) ? obj : null);
    }

    public static Group GetGroup(string groupName)
    {
        return groupLookup[groupName.ToLower()];
    }

    public static IEnumerable<T> GetEnumerable<T>(string groupName)
    {
        return GetGroup(groupName)?.assets.Cast<T>();
    }

    public static List<T> GetList<T>(string groupName)
    {
        return GetEnumerable<T>(groupName)?.ToList();
    }

    public static T[] GetArray<T>(string groupName)
    {
        return GetEnumerable<T>(groupName)?.ToArray();
    }
}
public class PreloadAddressableGroup : MonoBehaviour
{
    [SerializeField]
    public string[] groups;

    public static bool done;

    public async void Start()
    {
        if (done)
        {
            Object.Destroy(gameObject);
            return;
        }
        done = true;
        Object.DontDestroyOnLoad(gameObject);
        Debug.Log($"~ ASSET PRELOADER: {groups.Length} group(s) to load");
        string[] array = groups;
        foreach (string group in array)
        {
            Debug.Log(("~ ASSET PRELOADER: Loading Group [" + group + "]"));
            StopWatch.Start();
            await AddressableLoader.PreLoadGroup(group);
            Debug.Log($"~ ASSET PRELOADER: Group [{group}] Loaded! ({StopWatch.Stop()}ms)");
        }
        Debug.Log("~ ASSET PRELOADER: Finished");
        Object.Destroy(gameObject);
    }
}
public class RenderTextureCreator : MonoBehaviour
{
    [SerializeField]
    public int width;

    [SerializeField]
    public int height;

    [SerializeField]
    public GraphicsFormat colorFormat;

    [SerializeField]
    public GraphicsFormat depthStencilFormat;

    [SerializeField]
    public int mipCount;

    [SerializeField]
    public bool destroyOnDisable = true;

    [SerializeField]
    public UnityEvent<RenderTexture> onCreate;

    public RenderTexture rt;

    public void OnEnable()
    {
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Expected O, but got Unknown
        if (rt != null)
        {
            ObjectExt.Destroy(rt);
        }
        rt = new RenderTexture(width, height, colorFormat, depthStencilFormat, mipCount);
        onCreate.Invoke(rt);
    }

    public void OnDisable()
    {
        if (destroyOnDisable && rt != null)
        {
            ObjectExt.Destroy(rt);
        }
    }
}
public class AvatarEyePositions : MonoBehaviour
{
    [Serializable]
    public class Eye
    {
        public Vector3 pos;

        public Vector3 scale = new Vector3(2.1276596f, 2.1276596f, 1f);
    }

    public Eye[] eyes;
}
public class AvatarPart : MonoBehaviour
{
    [Serializable]
    public struct Anchor
    {
        public string name;

        public Transform transform;
    }

    [Serializable]
    public struct Part
    {
        public string name;

        public Image image;

        public void Disable()
        {
            if (image != null)
            {
                ((Behaviour)image).enabled = false;
            }
        }

        public void Set(Sprite sprite, Vector2 scale)
        {
            //IL_0032: Unknown result type (might be due to invalid IL or missing references)
            //IL_0037: Unknown result type (might be due to invalid IL or missing references)
            //IL_003c: Unknown result type (might be due to invalid IL or missing references)
            //IL_003d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0042: Unknown result type (might be due to invalid IL or missing references)
            if (image != null)
            {
                ((Behaviour)image).enabled = true;
                image.sprite = sprite;
                Transform transform = ((Component)image).transform;
                transform.localScale = ((transform.localScale) * scale);
            }
        }
    }

    [SerializeField]
    public Anchor[] anchors;

    [SerializeField]
    public Part[] parts;

    public Transform GetAnchor(string name)
    {
        return anchors.FirstOrDefault((Anchor a) => a.name == name).transform;
    }

    public Part Get(string name)
    {
        return parts.FirstOrDefault((Part a) => a.name == name);
    }
}
public class AvatarPoser : MonoBehaviour
{
    [Serializable]
    public struct Pose
    {
        public string name;

        public bool setFace;

        public Sprite[] face;

        public bool setBody;

        public Sprite[] body;
    }

    [SerializeField]
    public Image faceImage;

    [SerializeField]
    public Image bodyImage;

    [SerializeField]
    [Range(0f, 2f)]
    public float pingStrength = 1f;

    [SerializeField]
    public Vector2 poseTime = new Vector2(1.5f, 2f);

    [SerializeField]
    public Pose[] poses;

    public readonly Dictionary<string, Pose> poseLookup = new Dictionary<string, Pose>();

    public Sprite baseFaceSprite;

    public Sprite baseBodySprite;

    public Vector3 scale;

    public float reset;

    public void Awake()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        scale = transform.localScale;
        poseLookup.Clear();
        Pose[] array = poses;
        for (int i = 0; i < array.Length; i++)
        {
            Pose value = array[i];
            poseLookup[value.name] = value;
        }
        if ((faceImage))
        {
            baseFaceSprite = faceImage.sprite;
        }
        if ((bodyImage))
        {
            baseBodySprite = bodyImage.sprite;
        }
    }

    public void Update()
    {
        if (!(reset > 0f))
        {
            return;
        }
        reset -= Time.deltaTime;
        if (reset <= 0f)
        {
            if ((faceImage))
            {
                faceImage.sprite = baseFaceSprite;
            }
            if ((bodyImage))
            {
                bodyImage.sprite = baseBodySprite;
            }
            Ping();
        }
    }

    public void Set(string poseName)
    {
        //IL_0083: Unknown result type (might be due to invalid IL or missing references)
        if (poseLookup.TryGetValue(poseName, out var value))
        {
            if ((faceImage) && value.setFace)
            {
                faceImage.sprite = value.face[PettyRandom.Range(0, value.face.Length - 1)];
            }
            if ((bodyImage) && value.setBody)
            {
                bodyImage.sprite = value.body[PettyRandom.Range(0, value.body.Length - 1)];
            }
            reset = Vector2Ext.PettyRandom(poseTime);
            Ping();
        }
    }

    public void Ping()
    {
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        if (!(pingStrength <= 0f))
        {
            LeanTween.cancel(gameObject);
            float num = 1f + 0.05f * pingStrength;
            transform.localScale = new Vector3(num * scale.x, 1f / num * scale.y, scale.z);
            LeanTween.scale(gameObject, scale, 1f).setEase(LeanTweenType.easeOutElastic);
        }
    }
}
public class AvatarPoseSetter : MonoBehaviour
{
    [SerializeField]
    public bool onAwake;

    [SerializeField]
    [HideIf("onAwake")]
    public bool onEnable = true;

    [SerializeField]
    public AvatarPoser poser;

    [SerializeField]
    public string[] poseOptions = new string[2] { "", "Greet" };

    [SerializeField]
    public Vector2 delay = new Vector2(0.5f, 1.5f);

    public void Awake()
    {
        if (onAwake)
        {
            StartCoroutine(Run());
        }
    }

    public void OnEnable()
    {
        if (!onAwake && onEnable)
        {
            StartCoroutine(Run());
        }
    }

    public void OnDisable()
    {
        StopAllCoroutines();
    }

    public IEnumerator Run()
    {
        yield return (object)new WaitForSeconds(Vector2Ext.PettyRandom(delay));
        if ((poser) && poseOptions != null && poseOptions.Length != 0)
        {
            poser.Set(IArrayExt.RandomItem<string>(poseOptions));
        }
    }
}
public class CharacterAvatar : MonoBehaviour
{
    public AvatarPart root;

    public Texture2D paletteTexture;

    public Material recolourMaterial;

    public Material recolourMaterialCopy;

    public void OnDestroy()
    {
        if ((paletteTexture))
        {
            Object.Destroy(paletteTexture);
        }
        if ((recolourMaterialCopy))
        {
            Object.Destroy(recolourMaterialCopy);
        }
    }

    public void UpdateDisplay(CharacterData data)
    {
        //IL_007b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        //IL_008b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        //IL_031e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0323: Unknown result type (might be due to invalid IL or missing references)
        //IL_032f: Expected O, but got Unknown
        //IL_0335: Unknown result type (might be due to invalid IL or missing references)
        //IL_033a: Unknown result type (might be due to invalid IL or missing references)
        //IL_03a2: Unknown result type (might be due to invalid IL or missing references)
        //IL_03b3: Unknown result type (might be due to invalid IL or missing references)
        //IL_03c4: Unknown result type (might be due to invalid IL or missing references)
        //IL_03d6: Unknown result type (might be due to invalid IL or missing references)
        //IL_03e8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fb: Unknown result type (might be due to invalid IL or missing references)
        //IL_0101: Unknown result type (might be due to invalid IL or missing references)
        //IL_0106: Unknown result type (might be due to invalid IL or missing references)
        //IL_0111: Unknown result type (might be due to invalid IL or missing references)
        //IL_0116: Unknown result type (might be due to invalid IL or missing references)
        //IL_011b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0120: Unknown result type (might be due to invalid IL or missing references)
        //IL_01dd: Unknown result type (might be due to invalid IL or missing references)
        //IL_01f2: Unknown result type (might be due to invalid IL or missing references)
        //IL_0207: Unknown result type (might be due to invalid IL or missing references)
        //IL_021c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0231: Unknown result type (might be due to invalid IL or missing references)
        //IL_0246: Unknown result type (might be due to invalid IL or missing references)
        //IL_025a: Unknown result type (might be due to invalid IL or missing references)
        //IL_026e: Unknown result type (might be due to invalid IL or missing references)
        CharacterType characterType = AssetLoader.Lookup<CharacterType>("CharacterTypes", data.race + data.gender);
        if (!(characterType))
        {
            return;
        }
        Transform anchor = root.GetAnchor("body");
        if (anchor == null)
        {
            return;
        }
        TransformExt.DestroyAllChildren(anchor);
        Object.Destroy(paletteTexture);
        GameObject prefab = GetPrefab(characterType, "Body", data.bodyIndex);
        if (!(prefab))
        {
            return;
        }
        GameObject val = Object.Instantiate<GameObject>(prefab, anchor);
        Transform transform = val.transform;
        transform.localScale = ((transform.localScale) * data.bodyScale);
        AvatarPart component = val.GetComponent<AvatarPart>();
        if (component != null)
        {
            GameObject prefab2 = GetPrefab(characterType, "Head", data.headIndex);
            if ((prefab2))
            {
                Transform anchor2 = component.GetAnchor("head");
                if (anchor2 != null)
                {
                    GameObject val2 = Object.Instantiate<GameObject>(prefab2, anchor2);
                    val2.transform.localScale = ((val2.transform.localScale) * data.headScale / (val.transform.localScale));
                    AvatarPart component2 = val2.GetComponent<AvatarPart>();
                    if (component2 != null)
                    {
                        Sprite sprite = GetSprite(characterType, "Mouth", data.mouthIndex);
                        Sprite sprite2 = GetSprite(characterType, "Nose", data.noseIndex);
                        Sprite sprite3 = GetSprite(characterType, "Eyebrows", data.eyebrowIndex);
                        Sprite sprite4 = GetSprite(characterType, "Ears", data.earIndex);
                        Sprite sprite5 = GetSprite(characterType, "HairTop", data.hairTopIndex);
                        Sprite sprite6 = GetSprite(characterType, "HairBack", data.hairBackIndex);
                        Sprite sprite7 = GetSprite(characterType, "Beard", data.beardIndex);
                        Sprite sprite8 = GetSprite(characterType, "Markings", data.markingsIndex);
                        SetSprite(characterType, component2, "mouth", sprite, data.mouthScale);
                        SetSprite(characterType, component2, "nose", sprite2, data.noseScale);
                        SetSprite(characterType, component2, "eyebrows", sprite3, data.eyebrowScale);
                        SetSprite(characterType, component2, "ears", sprite4, data.earScale);
                        SetSprite(characterType, component2, "hairtop", sprite5, data.hairScale);
                        SetSprite(characterType, component2, "hairback", sprite6, data.hairScale);
                        SetSprite(characterType, component2, "beard", sprite7, Vector2.one);
                        SetSprite(characterType, component2, "markings", sprite8, Vector2.one);
                        GameObject prefab3 = GetPrefab(characterType, "Eyes", data.eyesIndex);
                        if ((prefab3))
                        {
                            Transform anchor3 = component2.GetAnchor("eyes");
                            if (anchor3 != null)
                            {
                                Object.Instantiate<GameObject>(prefab3, anchor3);
                            }
                        }
                    }
                }
            }
            GameObject prefab4 = GetPrefab(characterType, "Weapon1", data.weapon1Index);
            if (prefab4 != null)
            {
                Transform anchor4 = component.GetAnchor("weapon1");
                if (anchor4 != null)
                {
                    Object.Instantiate<GameObject>(prefab4, anchor4);
                    goto IL_0318;
                }
            }
            GameObject prefab5 = GetPrefab(characterType, "Weapon2", data.weapon2Index);
            if (prefab5 != null)
            {
                Transform anchor5 = component.GetAnchor("weapon2");
                if (anchor5 != null)
                {
                    Object.Instantiate<GameObject>(prefab5, anchor5);
                }
            }
        }
        goto IL_0318;
    IL_0318:
        paletteTexture = new Texture2D(25, 1, (TextureFormat)4, false)
        {
            filterMode = (FilterMode)0
        };
        NativeArray<Color32> rawTextureData = paletteTexture.GetRawTextureData<Color32>();
        ColorSet colorSet = GetColorSet(characterType, "ClothingColour", data.clothingColorIndex);
        ColorSet colorSet2 = GetColorSet(characterType, "HairColour", data.hairColorIndex);
        ColorSet colorSet3 = GetColorSet(characterType, "EyeColour", data.eyeColorIndex);
        ColorSet colorSet4 = GetColorSet(characterType, "SkinColour", data.skinColorIndex);
        ColorSet colorSet5 = GetColorSet(characterType, "MarkingColour", data.markingsColorIndex);
        SetTexturePixels(characterType, paletteTexture, rawTextureData, 0, colorSet);
        SetTexturePixels(characterType, paletteTexture, rawTextureData, 4, colorSet2);
        SetTexturePixels(characterType, paletteTexture, rawTextureData, 13, colorSet3);
        SetTexturePixels(characterType, paletteTexture, rawTextureData, 14, colorSet4);
        SetTexturePixels(characterType, paletteTexture, rawTextureData, 17, colorSet5);
        paletteTexture.Apply();
        if ((recolourMaterialCopy))
        {
            Object.Destroy(recolourMaterialCopy);
        }
        recolourMaterialCopy = Object.Instantiate<Material>(recolourMaterial);
        recolourMaterialCopy.SetTexture("_PaletteTex", (Texture)(object)paletteTexture);
        Image[] componentsInChildren = GetComponentsInChildren<Image>();
        Mask val4 = default(Mask);
        foreach (Image val3 in componentsInChildren)
        {
            if (!((Component)val3).TryGetComponent<Mask>(ref val4))
            {
                ((Graphic)val3).material = recolourMaterialCopy;
            }
        }
    }

    public static GameObject GetPrefab(CharacterType type, string name, int index)
    {
        if (index >= 0)
        {
            CharacterType.PrefabGroup prefabGroup = type.prefabs.FirstOrDefault((CharacterType.PrefabGroup a) => a.name == name);
            if (prefabGroup != null)
            {
                return prefabGroup.collection[index];
            }
        }
        return null;
    }

    public static Sprite GetSprite(CharacterType type, string name, int index)
    {
        if (index >= 0)
        {
            CharacterType.SpriteGroup spriteGroup = type.sprites.FirstOrDefault((CharacterType.SpriteGroup a) => a.name == name);
            if (spriteGroup != null)
            {
                return spriteGroup.collection[index];
            }
        }
        return null;
    }

    public static ColorSet GetColorSet(CharacterType type, string name, int index)
    {
        if (index >= 0)
        {
            CharacterType.ColorSetGroup colorSetGroup = type.colorSets.FirstOrDefault((CharacterType.ColorSetGroup a) => a.name == name);
            if (colorSetGroup != null)
            {
                return colorSetGroup.collection[index];
            }
        }
        return null;
    }

    public static void SetSprite(CharacterType type, AvatarPart part, string partName, Sprite sprite, Vector2 scale)
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        AvatarPart.Part part2 = part.Get(partName);
        if (!(sprite))
        {
            part2.Disable();
        }
        else
        {
            part2.Set(sprite, scale);
        }
    }

    public static void SetSprite(CharacterType type, AvatarPart part, Sprite sprite, Vector2 scale, params string[] partNames)
    {
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        foreach (string name in partNames)
        {
            AvatarPart.Part part2 = part.Get(name);
            if (!(sprite))
            {
                part2.Disable();
            }
            else
            {
                part2.Set(sprite, scale);
            }
        }
    }

    public static void SetTexturePixels(CharacterType type, Texture2D texture, NativeArray<Color32> data, int startX, ColorSet colorSet)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        Color[] set = colorSet.set;
        for (int i = 0; i < set.Length; i++)
        {
            Color32 val = (set[i]);
            data[startX++] = val;
        }
    }
}
public class CharacterAvatarMoveToCard : MonoBehaviour
{
    [SerializeField]
    public Vector3 inCardPosition;

    [SerializeField]
    public Vector3 inCardRotation;

    [SerializeField]
    public Vector3 inCardScale;

    public void MoveToCard(Card card)
    {
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        transform.SetParent(((Component)card.mainImage).transform);
        transform.localPosition = inCardPosition;
        transform.localEulerAngles = inCardRotation;
        transform.localScale = inCardScale;
    }
}
public class Battle : SceneRoutine
{
    public enum Phase
    {
        None,
        Init,
        Play,
        Battle,
        End,
        LastStand
    }

    public static Battle instance;

    public Character player;

    public Character enemy;

    public Character winner;

    public readonly List<Entity> minibosses = new List<Entity>();

    public Phase _phase;

    public Transform outOfUseCardsGroup;

    public CardController playerCardController;

    public readonly Dictionary<Character, List<CardContainer>> rows = new Dictionary<Character, List<CardContainer>>();

    public readonly Dictionary<CardContainer, int> rowIndices = new Dictionary<CardContainer, int>();

    public List<Entity> cards = new List<Entity>();

    public float startDelay = 1f;

    public bool canEnd = true;

    public int rowCount;

    public int turnCount;

    public bool cancelTurn;

    public bool auto;

    public bool loadMidBattle;

    public int playerMinibossCount => minibosses.Count((Entity a) => (a) && a.owner == player);

    public int enemyMinibossCount => minibosses.Count((Entity a) => (a) && a.owner == enemy);

    public Phase phase
    {
        get
        {
            return _phase;
        }
        set
        {
            if (_phase != value && !ended)
            {
                Debug.Log($"Battle Phase: {value}");
                Events.InvokeBattlePhaseStart(value);
                _phase = value;
            }
        }
    }

    public IEnumerable<CardSlotLane> allRows => rows.Values.SelectMany((List<CardContainer> a) => a).Cast<CardSlotLane>();

    public IEnumerable<CardSlot> allSlots => allRows.SelectMany((CardSlotLane a) => a.slots);

    public bool ended => phase == Phase.End;

    public void Awake()
    {
        instance = this;
        References.Battle = this;
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void PlayerWin()
    {
        winner = player;
        phase = Phase.End;
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void EnemyWin()
    {
        winner = enemy;
        phase = Phase.End;
    }

    public void Start()
    {
        Events.OnEntityCreated += EntityCreated;
        Events.OnEntityKilled += EntityKilled;
        Events.OnEntityDestroyed += EntityDestroyed;
    }

    public void OnDestroy()
    {
        Events.OnEntityCreated -= EntityCreated;
        Events.OnEntityKilled -= EntityKilled;
        Events.OnEntityDestroyed -= EntityDestroyed;
    }

    public void EntityCreated(Entity entity)
    {
        if (entity.data.cardType.miniboss)
        {
            minibosses.Add(entity);
        }
        cards.Add(entity);
    }

    public void CancelTurn()
    {
        cancelTurn = true;
    }

    public void EntityDestroyed(Entity entity)
    {
        EntityKilled(entity, DeathType.Normal);
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        if (minibosses.Remove(entity) && phase != Phase.LastStand)
        {
            CheckEnd();
        }
        cards.Remove(entity);
    }

    public bool CheckEnd()
    {
        if (!canEnd)
        {
            return false;
        }
        if (playerMinibossCount <= 0)
        {
            winner = enemy;
            phase = Phase.End;
            return true;
        }
        if (enemyMinibossCount <= 0)
        {
            winner = player;
            phase = Phase.End;
            return true;
        }
        return false;
    }

    public static Character GetOpponent(Character character)
    {
        if (!(character == instance.enemy))
        {
            if (!(character == instance.player))
            {
                return null;
            }
            return instance.enemy;
        }
        return instance.player;
    }

    public int GetRowIndex(CardContainer rowContainer)
    {
        if (!(rowContainer) || !(rowContainer.owner))
        {
            return -1;
        }
        return rows[rowContainer.owner].IndexOf(rowContainer);
    }

    public int[] GetRowIndices(Entity entity)
    {
        List<int> list = GenericPool<List<int>>.Get();
        list.Clear();
        if ((entity.owner))
        {
            List<CardContainer> list2 = rows[entity.owner];
            for (int i = 0; i < rowCount; i++)
            {
                if (list2[i].Contains(entity))
                {
                    list.Add(i);
                }
            }
        }
        int[] result = list.ToArray();
        GenericPool<List<int>>.Release(list);
        return result;
    }

    public int[] GetRowIndices(IEnumerable<CardContainer> containers)
    {
        HashSet<int> hashSet = GenericPool<HashSet<int>>.Get();
        hashSet.Clear();
        foreach (CardContainer container in containers)
        {
            if (rowIndices.TryGetValue(container, out var value))
            {
                hashSet.Add(value);
            }
        }
        int[] result = HashSetExt.ToArray<int>(hashSet);
        GenericPool<HashSet<int>>.Release(hashSet);
        return result;
    }

    public CardContainer GetRow(Character owner, int rowIndex)
    {
        return rows[owner][rowIndex];
    }

    public List<CardContainer> GetRows(Character owner)
    {
        List<CardContainer> list = rows[owner];
        List<CardContainer> list2 = new List<CardContainer>();
        foreach (CardContainer item in list)
        {
            list2.Add(item);
        }
        return list2;
    }

    public CardSlotLane GetOppositeRow(CardSlotLane row)
    {
        int rowIndex = GetRowIndex(row);
        if (rowIndex >= 0)
        {
            Character opponent = GetOpponent(row.owner);
            if ((opponent) && GetRow(opponent, rowIndex) is CardSlotLane result)
            {
                return result;
            }
        }
        return null;
    }

    public CardContainer[] GetOppositeRows(CardContainer[] rows)
    {
        CardContainer[] array = new CardContainer[rows.Length];
        int num = 0;
        Character character = null;
        foreach (CardContainer cardContainer in rows)
        {
            int rowIndex = GetRowIndex(cardContainer);
            if (rowIndex < 0)
            {
                continue;
            }
            if (character == null)
            {
                character = GetOpponent(cardContainer.owner);
            }
            if ((character))
            {
                CardContainer row = GetRow(character, rowIndex);
                if (row != null)
                {
                    array[num++] = row;
                }
            }
        }
        return array;
    }

    public List<CardSlot> GetSlots()
    {
        List<CardSlot> list = new List<CardSlot>();
        foreach (CardContainer item in rows.Values.SelectMany((List<CardContainer> a) => a))
        {
            if (item is CardSlotLane cardSlotLane)
            {
                list.AddRange(cardSlotLane.slots);
            }
        }
        return list;
    }

    public List<CardSlot> GetSlots(Character owner)
    {
        List<CardContainer> list = rows[owner];
        List<CardSlot> list2 = new List<CardSlot>();
        foreach (CardContainer item in list)
        {
            if (item is CardSlotLane cardSlotLane)
            {
                list2.AddRange(cardSlotLane.slots);
            }
        }
        return list2;
    }

    public static List<Entity> GetCards(Character character)
    {
        List<Entity> cardsOnBoard = GetCardsOnBoard(character);
        List<CardContainer> list = new List<CardContainer>();
        IListExt.AddIfNotNull<CardContainer>((IList<CardContainer>)list, character.reserveContainer);
        IListExt.AddIfNotNull<CardContainer>((IList<CardContainer>)list, character.handContainer);
        IListExt.AddIfNotNull<CardContainer>((IList<CardContainer>)list, character.drawContainer);
        IListExt.AddIfNotNull<CardContainer>((IList<CardContainer>)list, character.discardContainer);
        foreach (CardContainer item in list)
        {
            foreach (Entity item2 in item)
            {
                cardsOnBoard.Add(item2);
            }
        }
        return cardsOnBoard;
    }

    public static List<Entity> GetAllCards()
    {
        List<Entity> list = new List<Entity>();
        list.AddRange(GetCards(instance.player));
        list.AddRange(GetCards(instance.enemy));
        return list;
    }

    public static List<Entity> GetCardsOnBoard()
    {
        List<Entity> list = new List<Entity>();
        list.AddRange(GetCardsOnBoard(instance.player));
        list.AddRange(GetCardsOnBoard(instance.enemy));
        return list;
    }

    public static List<Entity> GetCardsOnBoard(Character character)
    {
        List<Entity> list = new List<Entity>();
        int num = 2;
        int num2 = 3;
        for (int i = 0; i < num2; i++)
        {
            for (int j = 0; j < num; j++)
            {
                if (instance.GetRow(character, j) is CardSlotLane cardSlotLane)
                {
                    Entity top = cardSlotLane.slots[i].GetTop();
                    if (top != null && !list.Contains(top))
                    {
                        list.Add(top);
                    }
                }
            }
        }
        return list;
    }

    public static bool IsOnBoard(Entity entity)
    {
        if (entity.containers.Length != 0)
        {
            return IsOnBoard(entity.containers);
        }
        if (!entity.alive && entity.preContainers != null)
        {
            return IsOnBoard(entity.preContainers);
        }
        return false;
    }

    public static bool IsOnBoard(CardContainer[] containers)
    {
        foreach (CardContainer cardContainer in containers)
        {
            if (instance.GetRowIndex(cardContainer.Group) >= 0)
            {
                return true;
            }
        }
        return false;
    }

    public static bool IsOnBoard(CardContainer container)
    {
        return instance.GetRowIndex(container) >= 0;
    }

    public override IEnumerator Run()
    {
        CampaignNode node = Campaign.FindCharacterNode(player);
        NavigationState.Start(new NavigationStateBattle());
        NavigationState.Start(new NavigationStateWait());
        if (!loadMidBattle)
        {
            phase = Phase.Init;
            yield return Sequences.Wait(startDelay);
            yield return ActionQueue.Wait();
            Debug.Log("BATTLE START!");
            Events.InvokeBattleStart();
            yield return DrawChampions(player, player.drawContainer, player.handContainer);
            SetSeed(node.seed - 9999, 0);
            NavigationState.BackToPreviousState();
            yield return WaitForChampionsToDeploy(player, playerCardController, player.handContainer);
            NavigationState.Start(new NavigationStateWait());
            Events.InvokeBattleTurnEnd(turnCount);
            ActionQueue.Add(new ActionDraw(player, player.handContainer.max));
            yield return ActionQueue.Wait();
        }
        yield return BattleLoop(node);
        Debug.Log("BATTLE END!");
        Events.InvokeBattleEnd();
        NavigationState.Reset();
        if ((playerCardController))
        {
            playerCardController.Disable();
        }
        List<Entity> cardsOnBoard = GetCardsOnBoard(GetOpponent(winner));
        if (cardsOnBoard.Count > 0)
        {
            Debug.Log($"[{cardsOnBoard.Count}] Cards To Flee!");
            foreach (Entity item in cardsOnBoard)
            {
                ActionQueue.Stack(new ActionFlee(item));
            }
            yield return ActionQueue.Wait();
        }
        yield return Events.InvokePreBattleEnd();
        if (Campaign.CheckVictory() || winner != player)
        {
            if (winner != player)
            {
                if (Settings.Load("showJournalNameOnEnd", defaultValue: false))
                {
                    yield return JournalVoidNameSequence.LoadAndRun(unloadAfter: true);
                }
                else
                {
                    JournalNameHistory.MostRecentNameKilled();
                }
            }
            yield return SceneManager.Load("CampaignEnd", SceneType.Temporary);
            yield return SceneManager.WaitUntilUnloaded("CampaignEnd");
        }
        else if (winner == player)
        {
            Events.InvokeBattleWinPreRewards();
            yield return ActionQueue.Wait();
            if (node.data.ContainsKey("rewards"))
            {
                yield return SceneManager.Load("BossReward", SceneType.Temporary);
                yield return SceneManager.WaitUntilUnloaded("BossReward");
            }
            Events.InvokeBattleWin();
            yield return ActionQueue.Wait();
            yield return SceneManager.Load("BattleWin", SceneType.Temporary);
            BattleVictorySequence battleVictorySequence = Object.FindObjectOfType<BattleVictorySequence>();
            yield return battleVictorySequence.Run();
        }
    }

    public IEnumerator BattleLoop(CampaignNode node)
    {
        while (!ended)
        {
            if (Deckpack.IsOpen)
            {
                yield return WaitForDeckpack();
            }
            yield return UpdateBoard(enemy);
            if (Deckpack.IsOpen)
            {
                yield return WaitForDeckpack();
            }
            yield return UpdateBoard(player);
            if (Deckpack.IsOpen)
            {
                yield return WaitForDeckpack();
            }
            yield return UpdateContainer(player.handContainer);
            if (!ended)
            {
                SetSeed(node.seed, turnCount);
                if (!auto)
                {
                    cancelTurn = false;
                    phase = Phase.Play;
                }
                yield return ActionQueue.Wait();
                Events.InvokeBattlePreTurnStart(turnCount);
                turnCount++;
                NavigationState.BackToPreviousState();
                if (!auto)
                {
                    playerCardController.Enable();
                    yield return WaitForTurnEnd(player, playerCardController);
                }
                NavigationState.Start(new NavigationStateWait());
                Events.InvokeBattleTurnStart(turnCount);
                if (Deckpack.IsOpen)
                {
                    yield return WaitForDeckpack();
                }
                phase = Phase.Battle;
                if (!auto)
                {
                    yield return Sequences.Wait(0.5f);
                }
                yield return CheckUnitsTakeTurns();
                yield return ActionQueue.Wait();
                yield return ProcessHandStart(player);
                if (!ended)
                {
                    yield return CheckUnitsTakeTurns();
                    yield return ProcessUnits(enemy);
                    yield return ProcessUnits(player);
                    yield return CheckUnitsTakeTurns();
                    yield return ProcessUnitTurnEnd();
                    yield return CheckUnitsTakeTurns();
                    yield return ProcessHandEnd(player);
                    yield return CheckUnitsTakeTurns();
                }
                yield return CheckUnitsTakeTurns();
                Events.InvokeBattleTurnEnd(turnCount);
            }
        }
    }

    public static void SetSeed(int baseSeed, int offset)
    {
        Debug.Log($"Battle Setting Seed: {baseSeed} Offset: {offset}");
        Random.InitState(baseSeed);
        for (int i = 0; i < offset; i++)
        {
            Random.Range(0f, 1f);
        }
    }

    public static IEnumerator WaitForDeckpack()
    {
        yield return (object)new WaitUntil((Func<bool>)(() => !Deckpack.IsOpen));
        yield return (object)new WaitForSeconds(0.5f);
    }

    public IEnumerator WaitForTurnEnd(Character character, CardController cardController)
    {
        while (!ended && !auto)
        {
            yield return ActionQueue.Wait();
            if (character.endTurn)
            {
                if (!character.freeAction)
                {
                    phase = Phase.Battle;
                }
                yield return CheckUnitsTakeTurns(enemy);
                yield return CheckUnitsTakeTurns(player);
                yield return UpdateBoard(enemy);
                yield return UpdateBoard(player);
                Events.InvokeCharacterActionPerformed(character);
                if (!character.freeAction)
                {
                    character.endTurn = false;
                    break;
                }
                character.freeAction = false;
                character.endTurn = false;
                cardController.Enable();
                character.handContainer.TweenChildPositions();
                phase = Phase.Play;
            }
            yield return ActionQueue.Wait();
        }
        cardController.Disable();
    }

    public IEnumerator DrawChampions(Character character, CardContainer fromContainer, CardContainer toContainer)
    {
        float pauseBetween = 0.1f;
        int count = fromContainer.Count;
        for (int i = count - 1; i >= 0; i--)
        {
            Entity entity = fromContainer[i];
            if (entity.data.HasCrown)
            {
                if ((entity))
                {
                    StartCoroutine(Sequences.CardMove(entity, new CardContainer[1] { toContainer }));
                    toContainer.TweenChildPositions();
                }
                yield return Sequences.Wait(pauseBetween);
            }
        }
        ActionQueue.Stack(new ActionRevealAll(toContainer));
        yield return ActionQueue.Wait();
    }

    public IEnumerator WaitForChampionsToDeploy(Character character, CardController cardController, CardContainer handContainer)
    {
        if (CrownCardsInContainer(handContainer) <= 0)
        {
            yield break;
        }
        cardController.Enable();
        while (!ended)
        {
            if (character.endTurn)
            {
                yield return null;
                character.endTurn = false;
                Routine.Clump clump = new Routine.Clump();
                clump.Add(UpdateBoard(enemy));
                clump.Add(UpdateBoard(player));
                clump.Add(UpdateContainer(player.handContainer));
                yield return clump.WaitForEnd();
                if (CrownCardsInContainer(handContainer) <= 0)
                {
                    break;
                }
                cardController.Enable();
            }
            yield return null;
        }
        character.freeAction = false;
    }

    public static int CrownCardsInContainer(CardContainer container)
    {
        return container.Count((Entity a) => a.data.HasCrown);
    }

    public IEnumerator UpdateBoard(Character character)
    {
        float seconds = 0f;
        foreach (CardContainer row in GetRows(character))
        {
            row.MoveChildrenForward();
            row.TweenChildPositions();
        }
        yield return Sequences.Wait(seconds);
    }

    public bool CanDeploy(Entity entity, int targetRow, out int targetColumn)
    {
        targetColumn = 0;
        bool result = false;
        List<CardContainer> list = GetRows(entity.owner);
        int num = int.MaxValue;
        foreach (CardContainer item in list)
        {
            num = Mathf.Min(num, item.max);
        }
        if (entity.positionPriority >= 0)
        {
            for (int i = 0; i < num; i++)
            {
                bool flag = false;
                for (int j = 0; j < entity.height; j++)
                {
                    CardContainer cardContainer = list[(targetRow + j) % list.Count];
                    if (!(cardContainer is CardSlotLane cardSlotLane) || !cardContainer.canBePlacedOn)
                    {
                        continue;
                    }
                    CardSlot cardSlot = cardSlotLane.slots[i];
                    if (!cardSlot.canBePlacedOn)
                    {
                        continue;
                    }
                    Entity top = cardSlot.GetTop();
                    if (top == null)
                    {
                        flag = true;
                    }
                    else
                    {
                        if ((top.positionPriority >= entity.positionPriority && (entity.positionPriority <= 1 || top.positionPriority > entity.positionPriority)) || !CanPushBack(top))
                        {
                            continue;
                        }
                        bool flag2 = true;
                        for (int k = i + 1; k < cardSlotLane.max; k++)
                        {
                            Entity top2 = cardSlotLane.slots[k].GetTop();
                            if ((top2) && top2.positionPriority >= entity.positionPriority)
                            {
                                flag2 = false;
                                break;
                            }
                        }
                        if (flag2)
                        {
                            flag = true;
                        }
                    }
                }
                if (flag)
                {
                    result = true;
                    targetColumn = i;
                    break;
                }
            }
        }
        else
        {
            for (int num2 = num - 1; num2 >= 0; num2--)
            {
                bool flag3 = true;
                for (int l = 0; l < entity.height; l++)
                {
                    if (list[(targetRow + l) % list.Count] is CardSlotLane cardSlotLane2)
                    {
                        Entity top3 = cardSlotLane2.slots[num2].GetTop();
                        if ((top3) && (top3.positionPriority > entity.positionPriority || !CanPushForwards(top3)))
                        {
                            flag3 = false;
                        }
                    }
                }
                if (flag3)
                {
                    result = true;
                    targetColumn = num2;
                    break;
                }
            }
        }
        return result;
    }

    public static bool CanPushBack(Entity entity)
    {
        bool result = true;
        CardContainer[] containers = entity.containers;
        for (int i = 0; i < containers.Length; i++)
        {
            if (containers[i] is CardSlotLane cardSlotLane)
            {
                int num = cardSlotLane.IndexOf(entity) + 1;
                CardSlot cardSlot = ((num < cardSlotLane.max) ? cardSlotLane.slots[num] : null);
                if (cardSlot == null)
                {
                    result = false;
                    break;
                }
                Entity top = cardSlot.GetTop();
                if ((top) && !CanPushBack(top))
                {
                    result = false;
                    break;
                }
            }
        }
        return result;
    }

    public static bool CanPushForwards(Entity entity)
    {
        bool result = true;
        CardContainer[] containers = entity.containers;
        for (int i = 0; i < containers.Length; i++)
        {
            if (containers[i] is CardSlotLane cardSlotLane)
            {
                int num = cardSlotLane.IndexOf(entity) - 1;
                CardSlot cardSlot = ((num >= 0) ? cardSlotLane.slots[num] : null);
                if (cardSlot == null || !cardSlot.Empty)
                {
                    result = false;
                    break;
                }
            }
        }
        return result;
    }

    public IEnumerator UpdateContainer(CardContainer container)
    {
        float seconds = 0f;
        container.TweenChildPositions();
        yield return Sequences.Wait(seconds);
    }

    public IEnumerator CheckUnitsTakeTurns()
    {
        if (!cancelTurn)
        {
            yield return CheckUnitsTakeTurns(enemy);
            if (!cancelTurn)
            {
                yield return CheckUnitsTakeTurns(player);
            }
        }
    }

    public IEnumerator CheckUnitsTakeTurns(Character character)
    {
        float pauseAfter = 0.167f;
        List<CardContainer> list = GetRows(character);
        List<Entity> list2 = new List<Entity>();
        foreach (CardContainer item in list)
        {
            for (int i = 0; i < item.Count; i++)
            {
                list2.Add(item[i]);
            }
        }
        foreach (Entity unit in list2)
        {
            if (cancelTurn)
            {
                break;
            }
            if (unit.counter.current <= 0 && unit.counter.max > 0 && !unit.IsSnowed && unit.alive && unit.owner.autoTriggerUnits)
            {
                ActionTriggerByCounter triggerAction = new ActionTriggerByCounter(unit, unit);
                if (Deckpack.IsOpen)
                {
                    yield return WaitForDeckpack();
                }
                if (Events.CheckAction(triggerAction))
                {
                    ActionQueue.Add(triggerAction);
                    yield return ActionQueue.Wait();
                    yield return Sequences.Wait(pauseAfter);
                }
                unit.counter.current = unit.counter.max;
                unit.PromptUpdate();
            }
        }
    }

    public IEnumerator ProcessUnits(Character character)
    {
        List<Entity> processed = new List<Entity>();
        Events.InvokePreProcessUnits(character);
        bool dirty;
        do
        {
            dirty = false;
            List<Entity> list = HashSetExt.ToList<Entity>(GetAllUnits(character));
            IListExt.RemoveMany<Entity>((IList<Entity>)list, (ICollection<Entity>)processed);
            Dictionary<Entity, CardContainer[]> positions = list.ToDictionary((Entity e) => e, (Entity e) => e.actualContainers.ToArray());
            foreach (Entity entity in list)
            {
                if (!entity.IsAliveAndExists())
                {
                    dirty = true;
                    Debug.Log("BATTLE PROCESS LIST DIRTIED! An entity in the list no longer exists");
                    break;
                }
                CardContainer[] array = entity.actualContainers.ToArray();
                if (!positions.ContainsKey(entity) || !IListExt.ContainsAll<CardContainer>((IList<CardContainer>)positions[entity], (IEnumerable<CardContainer>)array))
                {
                    dirty = true;
                    Debug.Log($"BATTLE PROCESS LIST DIRTIED! [{(entity).name}] was expected at [{positions[entity]}], but was actually at [{array}]");
                    break;
                }
                if (minibosses.Count((Entity a) => a.owner.team == entity.owner.team) <= 0)
                {
                    Debug.Log(((entity).name + "'s Leader No Longer Exists! Skipping Processing..."));
                    continue;
                }
                yield return ProcessUnit(entity);
                processed.Add(entity);
                if (cancelTurn)
                {
                    break;
                }
            }
        }
        while (dirty && !cancelTurn);
        Events.InvokePostProcessUnits(character);
    }

    public static HashSet<Entity> GetAllUnits(Character character)
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        HashSetExt.AddRange<Entity>(hashSet, (IEnumerable<Entity>)GetCardsOnBoard(character));
        if ((character.entity) && character.entity.alive && character.entity.canBeHit)
        {
            hashSet.Add(character.entity);
        }
        return hashSet;
    }

    public static HashSet<Entity> GetAllUnits()
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        Character[] array = new Character[2] { instance.enemy, instance.player };
        foreach (Character character in array)
        {
            HashSetExt.AddRange<Entity>(hashSet, (IEnumerable<Entity>)GetAllUnits(character));
        }
        return hashSet;
    }

    public IEnumerator ProcessUnit(Entity unit)
    {
        float pauseAfter = 0.133f;
        if (Deckpack.IsOpen)
        {
            yield return WaitForDeckpack();
        }
        bool snowed = unit.IsSnowed;
        yield return StatusEffectSystem.TurnStartEvent(unit);
        if ((unit.counter.max > 0 || snowed) && unit.alive)
        {
            yield return CardCountDown(unit);
            if (unit.counter.current <= 0 && unit.counter.max > 0 && !snowed && unit.owner.autoTriggerUnits)
            {
                ActionTriggerByCounter action = new ActionTriggerByCounter(unit, unit);
                if (Events.CheckAction(action))
                {
                    ActionQueue.Add(action);
                    yield return ActionQueue.Wait();
                    if (cancelTurn)
                    {
                        yield break;
                    }
                }
                unit.counter.current = unit.counter.max;
                unit.PromptUpdate();
            }
            Routine.Clump clump = new Routine.Clump();
            clump.Add(StatusEffectSystem.TurnEvent(unit));
            clump.Add(Sequences.Wait(pauseAfter));
            yield return clump.WaitForEnd();
        }
        else
        {
            yield return StatusEffectSystem.TurnEvent(unit);
        }
        if (StatusEffectSystem.EventsRunning)
        {
            yield return Sequences.WaitForStatusEffectEvents();
        }
    }

    public IEnumerator ProcessHandStart(Character character)
    {
        if (cancelTurn)
        {
            yield break;
        }
        foreach (Entity entity2 in character.handContainer)
        {
            if (Deckpack.IsOpen)
            {
                yield return WaitForDeckpack();
            }
            yield return StatusEffectSystem.TurnStartEvent(entity2);
            if (cancelTurn)
            {
                break;
            }
        }
        foreach (Entity entity2 in character.handContainer)
        {
            if (Deckpack.IsOpen)
            {
                yield return WaitForDeckpack();
            }
            yield return StatusEffectSystem.TurnEvent(entity2);
            if (cancelTurn)
            {
                break;
            }
        }
    }

    public IEnumerator ProcessHandEnd(Character character)
    {
        if (cancelTurn)
        {
            yield break;
        }
        foreach (Entity entity in character.handContainer)
        {
            if (Deckpack.IsOpen)
            {
                yield return WaitForDeckpack();
            }
            yield return StatusEffectSystem.TurnEndEvent(entity);
            if (cancelTurn)
            {
                break;
            }
        }
    }

    public IEnumerator ProcessUnitTurnEnd()
    {
        if (cancelTurn)
        {
            yield break;
        }
        HashSet<Entity> hashSet = new HashSet<Entity>();
        Character[] array = new Character[2] { enemy, player };
        foreach (Character character in array)
        {
            HashSetExt.AddRange<Entity>(hashSet, (IEnumerable<Entity>)GetCardsOnBoard(character));
            if ((character.entity) && character.entity.alive)
            {
                hashSet.Add(character.entity);
            }
        }
        foreach (Entity unit in hashSet)
        {
            if (Deckpack.IsOpen)
            {
                yield return WaitForDeckpack();
            }
            ActionQueue.Stack(new ActionSequence(StatusEffectSystem.TurnEndEvent(unit)), fixedPosition: true);
            yield return ActionQueue.Wait();
            if (cancelTurn)
            {
                break;
            }
        }
    }

    public static IEnumerator CardCountDown(Entity entity)
    {
        if (Deckpack.IsOpen)
        {
            yield return WaitForDeckpack();
        }
        int amount = 1;
        Events.InvokeEntityCountDown(entity, ref amount);
        Hit hit = new Hit(null, entity)
        {
            counterReduction = amount,
            screenShake = 0f
        };
        yield return hit.Process();
    }
}
public class BattleRewards : MonoBehaviour
{
    public List<RewardData> rewards;
}
public class BattleSetUp : SceneRoutine
{
    [Serializable]
    public struct Background
    {
        public string key;

        public GameObject prefab;
    }

    [SerializeField]
    [Required(null)]
    public Battle battle;

    [SerializeField]
    public Character enemy;

    [SerializeField]
    public CharacterDisplay enemyCharacterDisplay;

    [SerializeField]
    [Required(null)]
    public BoardDisplay board;

    [SerializeField]
    [Required(null)]
    public CardController cardController;

    [SerializeField]
    public TweenUI startTween;

    [Header("Background")]
    [SerializeField]
    public PrefabLoaderAsync backgroundLoader;

    public CharacterDisplay playerDisplay;

    public override IEnumerator Run()
    {
        Routine updateBackgroundRoutine = new Routine(UpdateBackground());
        Character player = References.Player;
        CampaignNode node = Campaign.FindCharacterNode(player);
        playerDisplay = (CharacterDisplay)player.entity.display;
        if ((playerDisplay))
        {
            Debug.Log("BATTLE SET UP");
            battle.player = player;
            battle.enemy = enemy;
            board.player = player;
            board.enemy = enemy;
            cardController.owner = player;
            battle.rows[player] = new List<CardContainer>();
            battle.rows[enemy] = new List<CardContainer>();
            yield return null;
            yield return board.SetUp(node, cardController);
            player.handContainer.AssignController(cardController);
            player.handContainer.SetSize(player.data.handSize, player.handContainer.CardScale);
            player.discardContainer.AssignController(cardController);
            player.drawContainer.AssignController(cardController);
            enemyCharacterDisplay.Assign(enemy);
        }
        else
        {
            Debug.LogError($"PLAYER [{player}] IS NOT ASSIGNED TO → CharacterDisplay");
        }
        yield return (object)new WaitUntil((Func<bool>)(() => !updateBackgroundRoutine.IsRunning));
    }

    public IEnumerator StartAnimation()
    {
        if ((startTween))
        {
            startTween.Fire();
        }
        new Routine.Clump().Add(playerDisplay.handOverlay.Show());
        yield return Sequences.Wait(0.1f);
    }

    public IEnumerator UpdateBackground()
    {
        if (Campaign.FindCharacterNode(References.Player).type is CampaignNodeTypeBattle { overrideBackground: not false } campaignNodeTypeBattle)
        {
            yield return backgroundLoader.Load(campaignNodeTypeBattle.background);
            yield break;
        }
        AreaData currentArea = References.GetCurrentArea();
        if ((currentArea))
        {
            yield return backgroundLoader.Load(currentArea.battleBackgroundPrefabRef);
        }
    }
}
public class BattleWaveManager : MonoBehaviour
{
    [Serializable]
    public class Wave
    {
        public int counter;

        public List<CardData> units;

        public bool isBossWave;

        public bool spawned;

        public Wave()
        {
        }

        public Wave(WaveData data)
        {
            counter = data.counter;
            units = new List<CardData>();
            int count = data.Count;
            for (int i = 0; i < count; i++)
            {
                units.Add(data.GetCardData(i));
            }
            isBossWave = data.isBossWave;
        }

        public override string ToString()
        {
            return string.Format("Wave ({0}) counter: {1}", string.Join(", ", units), counter);
        }
    }

    [Serializable]
    public abstract class WaveData
    {
        public int counter;

        public bool isBossWave;

        public virtual int Count => 0;

        public abstract void AddCard(CardData card);

        public abstract void InsertCard(int index, CardData card);

        public abstract CardData GetCardData(int index);

        public abstract string GetCardName(int index);

        public abstract CardData PeekCardData(int index);

        public abstract bool AddUpgradeToCard(int index, CardUpgradeData upgradeData);

        public WaveData()
        {
        }
    }

    [Serializable]
    public class WaveDataBasic : WaveData
    {
        public Card[] cards;

        public override int Count => cards.Length;

        public override void AddCard(CardData card)
        {
            List<Card> list = IArrayExt.ToList<Card>(cards);
            list.Add(new Card((card).name));
            cards = list.ToArray();
        }

        public override void InsertCard(int index, CardData card)
        {
            List<Card> list = IArrayExt.ToList<Card>(cards);
            list.Insert(index, new Card((card).name));
            cards = list.ToArray();
        }

        public override CardData GetCardData(int index)
        {
            Card card = cards[index];
            CardData cardDataClone = AddressableLoader.GetCardDataClone(card.cardName);
            if (card.upgradeNames != null)
            {
                foreach (string upgradeName in card.upgradeNames)
                {
                    CardUpgradeData cardUpgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", upgradeName);
                    if ((cardUpgradeData))
                    {
                        cardUpgradeData.Clone().Assign(cardDataClone);
                    }
                }
            }
            return cardDataClone;
        }

        public override CardData PeekCardData(int index)
        {
            return AddressableLoader.Get<CardData>("CardData", cards[index].cardName);
        }

        public override string GetCardName(int index)
        {
            return cards[index].cardName;
        }

        public override bool AddUpgradeToCard(int index, CardUpgradeData upgradeData)
        {
            Card card = cards[index];
            CardData cardData = AddressableLoader.Get<CardData>("CardData", card.cardName);
            if ((cardData) && upgradeData.CanAssign(cardData))
            {
                card.AddUpgrade((upgradeData).name);
                return true;
            }
            return false;
        }

        public Card Get(int index)
        {
            return cards[index];
        }

        public WaveDataFull ConvertToFull()
        {
            WaveDataFull waveDataFull = new WaveDataFull();
            List<CardSaveData> list = new List<CardSaveData>();
            for (int i = 0; i < cards.Length; i++)
            {
                IListExt.AddIfNotNull<CardSaveData>((IList<CardSaveData>)list, new CardSaveData(PeekCardData(i)));
            }
            waveDataFull.cardDatas = list.ToArray();
            for (int j = 0; j < cards.Length; j++)
            {
                Card obj = cards[j];
                CardSaveData cardSaveData = waveDataFull.cardDatas[j];
                List<CardUpgradeSaveData> list2 = new List<CardUpgradeSaveData>();
                foreach (string upgradeName in obj.upgradeNames)
                {
                    list2.Add(new CardUpgradeSaveData(upgradeName));
                }
                cardSaveData.upgrades = list2.ToArray();
            }
            return waveDataFull;
        }
    }

    [Serializable]
    public class WaveDataFull : WaveData
    {
        public CardSaveData[] cardDatas;

        public override int Count => cardDatas.Length;

        public override void AddCard(CardData card)
        {
            List<CardSaveData> list = IArrayExt.ToList<CardSaveData>(cardDatas);
            list.Add(new CardSaveData(card));
            cardDatas = list.ToArray();
        }

        public override void InsertCard(int index, CardData card)
        {
            List<CardSaveData> list = IArrayExt.ToList<CardSaveData>(cardDatas);
            list.Insert(index, new CardSaveData(card));
            cardDatas = list.ToArray();
        }

        public override CardData GetCardData(int index)
        {
            return cardDatas[index].Load(keepId: false);
        }

        public override CardData PeekCardData(int index)
        {
            return AddressableLoader.Get<CardData>("CardData", cardDatas[index].name);
        }

        public override string GetCardName(int index)
        {
            return cardDatas[index].name;
        }

        public override bool AddUpgradeToCard(int index, CardUpgradeData upgradeData)
        {
            bool result = false;
            CardData cardData = cardDatas[index].Load(keepId: false);
            if (upgradeData.CanAssign(cardData))
            {
                upgradeData.Assign(cardData);
                cardDatas[index] = new CardSaveData(cardData);
                result = true;
            }
            return result;
        }
    }

    [Serializable]
    public class Card
    {
        public string cardName;

        public List<string> upgradeNames;

        public Card()
        {
        }

        public Card(string cardName)
        {
            this.cardName = cardName;
        }

        public void AddUpgrade(string upgradeName)
        {
            if (upgradeNames == null)
            {
                upgradeNames = new List<string>();
            }
            upgradeNames.Add(upgradeName);
        }
    }

    public List<Wave> list;

    public Queue<Entity[]> remainingWaves;

    public void AddWave(Wave wave)
    {
        if (list == null)
        {
            list = new List<Wave>();
        }
        list.Add(wave);
        Debug.Log($"\"{wave}\" Added");
    }

    public void AddEntities(Entity[] entities)
    {
        if (remainingWaves == null)
        {
            remainingWaves = new Queue<Entity[]>();
        }
        remainingWaves.Enqueue(entities);
    }

    public Entity[] Pull()
    {
        return remainingWaves.Dequeue();
    }

    public Entity[] Peek()
    {
        return remainingWaves.Peek();
    }
}
[RequireComponent(typeof(SpriteRenderer))]
public class BlingParticle : MonoBehaviour
{
    public BlingParticleSystem system;

    public Character owner;

    public int value = 1;

    [SerializeField]
    public Vector2 sizeRange = new Vector2(0.7f, 0.9f);

    [SerializeField]
    public Vector2 angleRange = new Vector2(-20f, 20f);

    [SerializeField]
    public Vector3 groundRotation = new Vector3(20f, 0f, 0f);

    [SerializeField]
    public Vector2 bounceRange = new Vector2(0.35f, 0.45f);

    [SerializeField]
    public Vector2 bounceSlowdownRange = new Vector2(0.75f, 0.85f);

    [SerializeField]
    public Vector2 flyToBagRange = new Vector2(2f, 2.5f);

    [SerializeField]
    public Vector2 startSpeedRange = new Vector2(1f, 2f);

    [SerializeField]
    public Vector2 startUpSpeedRange = new Vector2(0f, 1f);

    [SerializeField]
    public Vector2 frictMultRange = new Vector2(0.94f, 0.96f);

    [SerializeField]
    public float grav = 10f;

    [SerializeField]
    public Vector2 groundOffsetRange = new Vector2(0.5f, 1f);

    [SerializeField]
    public bool startTimerWhenOnGround = true;

    [SerializeField]
    [Range(0f, 1f)]
    public float zInfluence = 0.5f;

    [SerializeField]
    public float flyToBagSpeed = 1f;

    [SerializeField]
    public float flyMaxSpeed = 10f;

    public float worldGroundY;

    public float bounce;

    public float bounceSlowdown;

    public float flyToBag;

    public Vector3 velocity;

    public float frictMult;

    public bool onGround;

    public GoldDisplay targetBag;

    public SpriteRenderer _spr;

    public SpriteRenderer spr => _spr ?? (_spr = GetComponent<SpriteRenderer>());

    public Sprite sprite
    {
        set
        {
            spr.sprite = value;
        }
    }

    public string sortingLayer
    {
        set
        {
            ((Renderer)spr).sortingLayerName = value;
        }
    }

    public void OnEnable()
    {
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0076: Unknown result type (might be due to invalid IL or missing references)
        //IL_0081: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        //IL_0091: Unknown result type (might be due to invalid IL or missing references)
        //IL_0096: Unknown result type (might be due to invalid IL or missing references)
        //IL_009d: Unknown result type (might be due to invalid IL or missing references)
        //IL_00aa: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b5: Unknown result type (might be due to invalid IL or missing references)
        //IL_0102: Unknown result type (might be due to invalid IL or missing references)
        //IL_0107: Unknown result type (might be due to invalid IL or missing references)
        //IL_010a: Unknown result type (might be due to invalid IL or missing references)
        //IL_010f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0111: Unknown result type (might be due to invalid IL or missing references)
        //IL_0113: Unknown result type (might be due to invalid IL or missing references)
        //IL_011d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0122: Unknown result type (might be due to invalid IL or missing references)
        //IL_0135: Unknown result type (might be due to invalid IL or missing references)
        sortingLayer = "ParticlesBehind";
        onGround = false;
        targetBag = null;
        float num = Vector2Ext.PettyRandom(sizeRange);
        bounce = Vector2Ext.PettyRandom(bounceRange);
        bounceSlowdown = Vector2Ext.PettyRandom(bounceSlowdownRange);
        flyToBag = Vector2Ext.PettyRandom(flyToBagRange);
        frictMult = Vector2Ext.PettyRandom(frictMultRange);
        transform.localScale = new Vector3(num, num, 1f);
        Vector3 localEulerAngles = Vector3Ext.WithZ(groundRotation, Vector2Ext.PettyRandom(angleRange));
        transform.localEulerAngles = localEulerAngles;
        worldGroundY = transform.position.y - Vector2Ext.PettyRandom(groundOffsetRange);
        spr.flipX = PettyRandom.Choose<bool>(new bool[2] { true, false });
        Vector3 val = new Vector3(PettyRandom.Range(-1f, 1f), PettyRandom.Range(-1f, 1f), 0f);
        Vector3 normalized = ((val)).normalized;
        velocity = normalized * Vector2Ext.PettyRandom(startSpeedRange);
        velocity.y += Vector2Ext.PettyRandom(startUpSpeedRange);
    }

    public void Update()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e0: Unknown result type (might be due to invalid IL or missing references)
        //IL_021f: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b9: Unknown result type (might be due to invalid IL or missing references)
        //IL_01cf: Unknown result type (might be due to invalid IL or missing references)
        Vector3 localPosition = transform.localPosition;
        localPosition += velocity * Time.deltaTime;
        if ((targetBag))
        {
            Vector3 val = ((Component)targetBag).transform.position - transform.position;
            velocity += val * (flyToBagSpeed * Time.deltaTime);
            if (((val)).sqrMagnitude < 0.1f)
            {
                Collect();
            }
            else if (((velocity)).magnitude > flyMaxSpeed)
            {
                velocity = ((val)).normalized * flyMaxSpeed;
            }
        }
        else
        {
            if (!onGround && velocity.y <= 0f && localPosition.y <= worldGroundY)
            {
                velocity.y *= 0f - bounce;
                velocity.x *= bounceSlowdown;
                if (Mathf.Abs(velocity.y) < 0.05f)
                {
                    velocity.y = 0f;
                    onGround = true;
                }
                localPosition.y = worldGroundY;
            }
            if (zInfluence > 0f)
            {
                localPosition.z -= velocity.y * zInfluence * Time.deltaTime;
            }
            velocity.x = Delta.Multiply(velocity.x, frictMult, Time.deltaTime);
            if (!onGround)
            {
                velocity.y -= grav * Time.deltaTime;
            }
            else if (localPosition.y != worldGroundY)
            {
                onGround = false;
            }
            if (!startTimerWhenOnGround || onGround)
            {
                flyToBag -= Time.deltaTime;
                if (flyToBag <= 0f)
                {
                    FlyToBag();
                }
            }
        }
        transform.localPosition = localPosition;
    }

    public void FlyToBag()
    {
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        if (owner.entity.display is CharacterDisplay characterDisplay && characterDisplay.goldDisplay != null)
        {
            targetBag = characterDisplay.goldDisplay;
            sortingLayer = "ParticlesFront";
            Events.InvokeGoldFlyToBag(value, owner, transform.position);
        }
        else
        {
            Collect();
        }
    }

    public void Collect()
    {
        owner.GainGold(value);
        ReturnToPool();
        Events.InvokeCollectGold(value);
    }

    public void ReturnToPool()
    {
        system.Pool(this);
    }
}
public class Blink : MonoBehaviour
{
    public Vector2 onRange = new Vector2(5f, 6f);

    public Vector2 offRange = new Vector2(0.1f, 0.1f);

    public AnimationCurve blinkCurve;

    public AnimationCurve unblinkCurve;

    public float blinkCurveDuration = 0.1f;

    [SerializeField]
    public bool startOn = true;

    public bool on;

    public float timer;

    public float preScaleY;

    public void Awake()
    {
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        on = startOn;
        if (on)
        {
            timer = Vector2Ext.PettyRandom(onRange) * PettyRandom.value;
            return;
        }
        Transform transform = this.transform;
        Vector3 localScale = transform.localScale;
        preScaleY = localScale.y;
        localScale.y = 0f;
        transform.localScale = localScale;
        timer = Vector2Ext.PettyRandom(offRange) * PettyRandom.value;
    }

    public void Update()
    {
        timer -= Time.deltaTime;
        if (timer <= 0f)
        {
            Toggle();
        }
    }

    public void Toggle()
    {
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_009b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0089: Unknown result type (might be due to invalid IL or missing references)
        on = !on;
        LeanTween.cancel(gameObject);
        if (on)
        {
            LeanTween.scaleY(gameObject, preScaleY, blinkCurveDuration).setEase(unblinkCurve);
        }
        else
        {
            preScaleY = transform.localScale.y;
            LeanTween.scaleY(gameObject, 0f, blinkCurveDuration).setEase(blinkCurve);
        }
        if (on)
        {
            timer = Vector2Ext.PettyRandom(onRange);
        }
        else
        {
            timer = Vector2Ext.PettyRandom(offRange);
        }
    }
}
public class BoardDisplay : MonoBehaviour
{
    public Character player;

    public Character enemy;

    public int playerRowLength = 3;

    public int enemyRowLength = 3;

    [Range(0f, 1f)]
    public float cardScale = 1f / 3f;

    [SerializeField]
    public LayoutGroup layout;

    [Header("Card Container References")]
    public CardContainer playerReserve;

    public CardContainer[] playerRows;

    public CardContainer enemyReserve;

    public CardContainer[] enemyRows;

    public IEnumerator SetUp(CampaignNode node, CardController cardController)
    {
        ((Behaviour)layout).enabled = false;
        if (playerReserve != null)
        {
            playerReserve.owner = player;
            player.reserveContainer = playerReserve;
            playerReserve.SetSize(999, cardScale);
            playerReserve.AssignController(cardController);
        }
        if (enemyReserve != null)
        {
            enemyReserve.owner = enemy;
            enemy.reserveContainer = enemyReserve;
            enemyReserve.SetSize(999, cardScale);
            enemyReserve.AssignController(cardController);
        }
        for (int i = 0; i < playerRows.Length; i++)
        {
            CardContainer cardContainer = playerRows[i];
            cardContainer.owner = player;
            cardContainer.SetSize(playerRowLength, cardScale);
            cardContainer.AssignController(cardController);
            if (cardContainer is CardSlotLane cardSlotLane)
            {
                cardSlotLane.SetDirection(1);
            }
            References.Battle.rows[player].Add(cardContainer);
            References.Battle.rowIndices[cardContainer] = i;
        }
        for (int j = 0; j < enemyRows.Length; j++)
        {
            CardContainer cardContainer2 = enemyRows[j];
            cardContainer2.owner = enemy;
            cardContainer2.SetSize(enemyRowLength, cardScale);
            cardContainer2.AssignController(cardController);
            if (cardContainer2 is CardSlotLane cardSlotLane2)
            {
                cardSlotLane2.SetDirection(-1);
            }
            References.Battle.rows[enemy].Add(cardContainer2);
            References.Battle.rowIndices[cardContainer2] = j;
        }
        yield return null;
        ((Behaviour)layout).enabled = true;
    }
}
public class BombardRocket : MonoBehaviour
{
    [SerializeField]
    public ParticleSystem rocketTrail;

    [SerializeField]
    public GameObject rocket;

    [SerializeField]
    public ParticleSystem explosion;

    [SerializeField]
    public float explosionShakeAmount = 2f;

    public void Explode()
    {
        StartCoroutine(ExplodeRoutine());
    }

    public IEnumerator ExplodeRoutine()
    {
        rocketTrail.Stop(true, (ParticleSystemStopBehavior)1);
        GameObjectExt.Destroy(rocket);
        explosion.Play();
        Events.InvokeScreenShake(explosionShakeAmount, 180f);
        yield return (object)new WaitForSeconds(4f);
        GameObjectExt.Destroy(gameObject);
    }
}
public class Bootstrap : MonoBehaviour
{
    [SerializeField]
    public string[] loadFirst = new string[2] { "Camera", "Global" };

    [SerializeField]
    public string[] thenLoad = new string[4] { "Input", "Systems", "Saving", "PauseScreen" };

    [SerializeField]
    public string startSceneKey = "MainMenu";

    [SerializeField]
    public string culture = "en-GB";

    [SerializeField]
    public Animator progressAnimator;

    [SerializeField]
    public Image progressFill;

    [SerializeField]
    public float pauseBefore = 0.5f;

    [SerializeField]
    public float pauseAfter = 0.5f;

    [SerializeField]
    public bool unloadSceneAfter = true;

    [SerializeField]
    public float fillLerp = 0.1f;

    [SerializeField]
    public SplashScreenSequence splashScreen;

    [SerializeField]
    public float minTime;

    public float targetFill;

    public float fillAdd;

    public static bool done;

    public static int Count;

    public static readonly SortedSet<WildfrostMod> Mods = new SortedSet<WildfrostMod>();

    public void OnEnable()
    {
        Count++;
    }

    public void OnDisable()
    {
        Count--;
    }

    public IEnumerator Start()
    {
        if (done)
        {
            Object.Destroy(gameObject);
            yield break;
        }
        done = true;
        Scene thisScene = SceneManager.GetActiveScene();
        Routine.Clump clump = new Routine.Clump();
        clump.Add(Load());
        if (minTime > 0f)
        {
            clump.Add(Sequences.Wait(minTime));
        }
        yield return clump.WaitForEnd();
        while (AudioSettingsSystem.Loading)
        {
            yield return null;
        }
        if ((splashScreen))
        {
            yield return splashScreen.Run();
        }
        ModsSetup();
        SceneManager.JobStart();
        yield return Transition.To(startSceneKey);
        if (unloadSceneAfter)
        {
            SceneManager.UnloadSceneAsync(thisScene).completed += delegate
            {
                SceneManager.JobEnd();
            };
        }
        else
        {
            Object.Destroy(gameObject);
            SceneManager.JobEnd();
        }
    }

    public IEnumerator Load()
    {
        Thread.CurrentThread.CurrentCulture = CultureInfo.CreateSpecificCulture(culture);
        fillAdd = 1f / (float)(loadFirst.Length + thenLoad.Length);
        yield return (object)new WaitForSeconds(pauseBefore);
        if ((progressAnimator))
        {
            progressAnimator.SetBool("Increasing", true);
        }
        yield return Load(loadFirst);
        yield return Load(thenLoad);
        if ((progressAnimator))
        {
            progressAnimator.SetBool("Increasing", false);
            progressAnimator.SetTrigger("Ping");
        }
        yield return (object)new WaitForSeconds(pauseAfter);
    }

    public void Update()
    {
        if ((progressFill))
        {
            progressFill.fillAmount = Delta.Lerp(progressFill.fillAmount, targetFill, fillLerp, Time.deltaTime);
        }
    }

    public IEnumerator Load(IEnumerable<string> sceneKeys)
    {
        Routine.Clump clump = new Routine.Clump();
        foreach (string sceneKey in sceneKeys)
        {
            clump.Add(SceneManager.Load(sceneKey, SceneType.Persistent, delegate
            {
                targetFill += fillAdd;
            }));
        }
        yield return clump.WaitForEnd();
    }

    public static bool IsModDirectory(string dir, out string[] dlls)
    {
        dlls = Directory.GetFiles(dir, "*.dll");
        return dlls.Length != 0;
    }

    public static void LoadModAtPath(string path)
    {
        if (!IsModDirectory(path, out var dlls))
        {
            return;
        }
        Assembly assembly = null;
        string[] array = dlls;
        for (int i = 0; i < array.Length; i++)
        {
            Assembly assembly2 = Assembly.LoadFrom(array[i]);
            try
            {
                Type[] types = assembly2.GetTypes();
                for (int j = 0; j < types.Length; j++)
                {
                    if (types[j].BaseType == typeof(WildfrostMod))
                    {
                        Debug.Log("Found valid mod type");
                        assembly = assembly2;
                        break;
                    }
                }
            }
            catch (TypeLoadException)
            {
            }
        }
        if (assembly == null)
        {
            Debug.LogWarning(("Empty mod? " + path));
        }
        else
        {
            Type[] types = assembly.GetTypes();
            foreach (Type type in types)
            {
                if (type.BaseType == typeof(WildfrostMod) && type != typeof(InternalMod))
                {
                    WildfrostMod item = Activator.CreateInstance(type, path) as WildfrostMod;
                    Mods.Add(item);
                    break;
                }
            }
            Debug.LogWarning(("Properly loaded mod and added instance " + assembly));
        }
        Debug.LogWarning(("Found mod directory " + path));
    }

    public void ModsSetup()
    {
        foreach (Type allDataType in WildfrostMod.AllDataTypes)
        {
            typeof(AddressableLoader).GetMethod("GetGroup", BindingFlags.Static | BindingFlags.Public).MakeGenericMethod(allDataType).Invoke(this, new object[1] { allDataType.ToString() });
        }
        TMP_Text.OnSpriteAssetRequest += delegate (int hash, string s)
        {
            foreach (WildfrostMod mod in Mods)
            {
                if (s == mod.GUID)
                {
                    return mod.HasLoaded ? mod.SpriteAsset : null;
                }
            }
            return (TMP_SpriteAsset)null;
        };
        string path = Path.Combine(Application.streamingAssetsPath, "Mods");
        if (!Directory.Exists(path))
        {
            Directory.CreateDirectory(path);
        }
        string[] directories = Directory.GetDirectories(path);
        for (int i = 0; i < directories.Length; i++)
        {
            LoadModAtPath(directories[i]);
        }
        WildfrostMod[] lastMods = WildfrostMod.GetLastMods();
        for (int i = 0; i < lastMods.Length; i++)
        {
            lastMods[i]?.ModLoad();
        }
    }
}
public class CameraMover : GameSystem
{
    [Serializable]
    public class Translation
    {
        public string name;

        public Vector3 position;

        public Vector3 rotation;

        public LeanTweenType ease;

        public float dur;
    }

    [SerializeField]
    public Translation[] battlePhasePositions;

    public void OnEnable()
    {
        Events.OnBattlePhaseStart += BattlePhaseStart;
        Events.OnSceneChanged += SceneChange;
    }

    public void OnDisable()
    {
        Events.OnBattlePhaseStart -= BattlePhaseStart;
        Events.OnSceneChanged -= SceneChange;
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        Translation translation = battlePhasePositions.FirstOrDefault((Translation a) => a.name == phase.ToString().ToLower());
        if (translation != null)
        {
            LeanTween.cancel(gameObject);
            LeanTween.moveLocal(gameObject, translation.position, translation.dur).setEase(translation.ease);
            LeanTween.rotateLocal(gameObject, translation.rotation, translation.dur).setEase(translation.ease);
        }
    }

    public void SceneChange(Scene scene)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(gameObject);
        transform.localPosition = Vector3.zero;
        transform.localEulerAngles = Vector3.zero;
    }
}
public class BossSetUp : MonoBehaviour
{
    public CharacterAvatar avatarPrefab;

    public CardData cardData;

    [SerializeField]
    [Required(null)]
    public Entity entity;

    [SerializeField]
    [Required(null)]
    public Character character;

    public void Awake()
    {
        SetUp();
    }

    public void SetUp()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        entity.random3 = PettyRandom.Vector3();
        entity.data = cardData.Clone();
        entity.hp.max = entity.data.hp;
        entity.hp.current = entity.hp.max;
        entity.data.hasAttack = false;
    }
}
public class Campaign : MonoBehaviour, ISaveable<CampaignSaveData>
{
    public enum Result
    {
        None,
        Win,
        Lose,
        Restart
    }

    public static Campaign instance;

    public Transform characterContainer;

    public List<Character> characters = new List<Character>();

    public List<CampaignNode> nodes = new List<CampaignNode>();

    public GameObject systems;

    [ReadOnly]
    public TextAsset preset;

    [ReadOnly]
    public string battleTiers;

    public static CampaignData Data;

    public Result result { get; set; }

    public void Awake()
    {
        instance = this;
        References.Campaign = this;
    }

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleEnd += new UnityAction(BattleEnd);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleEnd -= new UnityAction(BattleEnd);
    }

    public void BattleEnd()
    {
        if (References.Battle.winner == References.Battle.player)
        {
            if (CheckVictory())
            {
                End(Result.Win);
                JournalNameHistory.MostRecentNameMissing();
            }
        }
        else
        {
            End(Result.Lose);
        }
    }

    public static void Begin()
    {
        if (Data.GameMode.doSave)
        {
            SaveSystem.DeleteCampaign(Data.GameMode);
            SaveSystem.SaveCampaignData(Data.GameMode, "seed", Data.Seed);
        }
        if (Data.GameMode.mainGameMode)
        {
            SaveSystem.SaveProgressData("nextSeed", Random.Seed());
        }
    }

    public void End(Result result)
    {
        this.result = result;
        Debug.Log(">>>> CAMPAIGN END <<<<");
        Events.InvokeCampaignEnd(result, StatsSystem.Get(), References.PlayerData);
        PromptSave();
    }

    public void Final()
    {
        StopAllCoroutines();
        ActionQueue.Restart();
        References.Campaign = null;
        Events.InvokeCampaignFinal();
    }

    public IEnumerator Start()
    {
        yield return (object)new WaitUntil((Func<bool>)(() => !GameManager.Busy));
        yield return SceneManager.Load("UI", SceneType.Persistent);
        Events.InvokeCampaignStart();
        Random.InitState(Data.Seed);
        CampaignNode continueBattleNode = null;
        if (CheckContinue(Data.GameMode))
        {
            CampaignSaveData campaignSaveData = SaveSystem.LoadCampaignData<CampaignSaveData>(Data.GameMode, "data");
            StatsSystem.Set(SaveSystem.LoadCampaignData<CampaignStats>(Data.GameMode, "stats"));
            nodes = campaignSaveData.LoadNodes();
            Data.GameMode.populator.LoadCharacters(this, campaignSaveData.characters);
            References.Player = characters[campaignSaveData.playerId];
            References.PlayerData = References.Player.data;
            CharacterDisplay.FindAndAssign(References.Player);
            BattleSaveData battleSaveData = SaveSystem.LoadCampaignData<BattleSaveData>(Data.GameMode, "battleState", null);
            if (battleSaveData != null)
            {
                CampaignNode campaignNode = FindCharacterNode(References.Player);
                if (campaignNode != null && campaignNode.id == battleSaveData.campaignNodeId)
                {
                    if (battleSaveData.HasMissingCardData())
                    {
                        SaveSystem.SaveCampaignData<BattleSaveData>(Data.GameMode, "battleState", null);
                    }
                    else
                    {
                        continueBattleNode = campaignNode;
                    }
                }
            }
            if (campaignSaveData.modifiers != null)
            {
                string[] modifiers = campaignSaveData.modifiers;
                foreach (string assetName in modifiers)
                {
                    GameModifierData gameModifierData = AddressableLoader.Get<GameModifierData>("GameModifierData", assetName);
                    if (gameModifierData != null)
                    {
                        ModifierSystem.AddModifier(Data, gameModifierData);
                    }
                }
            }
            Events.InvokeCampaignLoaded();
        }
        else
        {
            yield return Data.GameMode.generator.Generate(this);
            Events.InvokePreCampaignPopulate();
            yield return Data.GameMode.populator.Populate(this);
            StatsSystem.Set(new CampaignStats());
            yield return Events.InvokeCampaignGenerated();
            FirstSave();
        }
        if (Data.GameMode.campaignSystemNames != null)
        {
            string[] modifiers = Data.GameMode.campaignSystemNames;
            foreach (string text in modifiers)
            {
                GameObjectExt.AddComponentByName(gameObject, text);
            }
        }
        if (Data.GameMode.systemsToDisable != null)
        {
            string[] modifiers = Data.GameMode.systemsToDisable;
            foreach (string text2 in modifiers)
            {
                Type type = Type.GetType(text2);
                if ((object)type != null && Object.FindObjectOfType(type, true) is GameSystem gameSystem)
                {
                    Debug.Log(("Disabling [" + text2 + "]"));
                    gameSystem.Disable();
                }
            }
        }
        yield return SceneManager.Load("MapNew", SceneType.Active);
        if (continueBattleNode == null || !TryEnterNode(continueBattleNode, delay: false))
        {
            Transition.End();
        }
    }

    public static CampaignNode GetNode(int id)
    {
        return instance.nodes[id];
    }

    public static Character GetCharacter(int id)
    {
        return instance.characters[id];
    }

    public static int GetCharacterId(Character character)
    {
        return instance.characters.IndexOf(character);
    }

    public static void MoveCharacter(Character character, CampaignNode toNode)
    {
        FindCharacterNode(character)?.characters?.Remove(GetCharacterId(character));
        toNode.characters.Add(GetCharacterId(character));
        PromptSave();
    }

    public static CampaignNode FindCharacterNode(Character character)
    {
        foreach (CampaignNode node in instance.nodes)
        {
            if (node.characters.Contains(GetCharacterId(character)))
            {
                return node;
            }
        }
        return null;
    }

    public static bool TryEnterNode(CampaignNode node, bool delay = true)
    {
        if (!node.cleared && node.characters.Contains(GetCharacterId(References.Player)))
        {
            ((MonoBehaviour)instance).StartCoroutine(EnterNode(node, delay));
            return true;
        }
        return false;
    }

    public static IEnumerator EnterNode(CampaignNode node, bool delay = true)
    {
        if ((node?.type))
        {
            InputSystem.Disable();
            if (delay)
            {
                yield return Sequences.Wait(0.5f);
            }
            InputSystem.Enable();
            Random.InitState(node.seed);
            yield return node.type.Run(node);
        }
    }

    public static void FirstSave()
    {
        if (Data.GameMode.doSave)
        {
            SaveSystem.SaveCampaignData(Data.GameMode, "gameVersion", Data.GameVersion);
            SaveSystem.SaveCampaignData(Data.GameMode, "gameMode", (Data.GameMode).name);
            string value = (Data.GameMode.dailyRun ? DailyFetcher.GetDateTime().ToString("dd/MM/yyyy") : DateTime.Now.ToString("dd/MM/yyyy"));
            SaveSystem.SaveCampaignData(Data.GameMode, "startDate", value);
            PromptSave();
        }
    }

    public static void PromptSave()
    {
        if (Data.GameMode.doSave)
        {
            SaveSystem.SaveCampaignData(Data.GameMode, "data", instance.Save());
            if (instance.result != 0)
            {
                SaveSystem.SaveCampaignData(Data.GameMode, "result", instance.result);
            }
        }
        Events.InvokeCampaignSaved();
    }

    public static bool CheckVictory()
    {
        CampaignNode campaignNode = FindCharacterNode(References.Player);
        if (!campaignNode.finalNode)
        {
            return campaignNode.connections.Count <= 0;
        }
        return true;
    }

    public static bool CheckContinue(GameMode gameMode)
    {
        if (!gameMode.doSave || !SaveSystem.CampaignExists(gameMode))
        {
            return false;
        }
        if (SaveSystem.LoadCampaignData(gameMode, "result", Result.None) != 0)
        {
            return false;
        }
        return SaveSystem.CampaignDataExists(gameMode, "data");
    }

    public CampaignSaveData Save()
    {
        return new CampaignSaveData(this);
    }
}
public class CampaignBattlePool : MonoBehaviour
{
    [Serializable]
    public struct Tier
    {
        public Vector2Int pointRange;

        public int pointsAdd;

        public BattleData[] battles;

        public BattleData[] bosses;
    }

    [SerializeField]
    public int basePoints;

    [SerializeField]
    public Tier[] tiers;

    public BattleData GetRandomBattle(int tier)
    {
        return IArrayExt.RandomItem<BattleData>(tiers[tier].battles);
    }

    public BattleData GetRandomBossBattle(int tier)
    {
        return IArrayExt.RandomItem<BattleData>(tiers[tier].bosses);
    }

    public int GetPoints(int tier, int battleLevel)
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        Tier tier2 = tiers[tier];
        return basePoints + Vector2IntExt.Random(tier2.pointRange) + battleLevel * tier2.pointsAdd;
    }
}
public class CampaignBattleRewardPool : MonoBehaviour
{
    [Serializable]
    public struct Pool
    {
        public string name;

        public List<CampaignNodeType> nodeTypes;

        public RewardData[] rewards;

        public List<RewardData> pool;

        public RewardData Pull()
        {
            if (pool == null)
            {
                pool = new List<RewardData>();
            }
            if (pool.Count <= 0)
            {
                pool.AddRange(rewards);
                IListExt.Shuffle<RewardData>((IList<RewardData>)pool);
            }
            if (pool.Count > 0)
            {
                RewardData result = pool[0];
                pool.RemoveAt(0);
                return result;
            }
            throw new Exception("CampaignBattleRewardPool IS EMPTY! God Dammit!");
        }
    }

    public Pool[] pools;
}
public class CardContainer : MonoBehaviourRect, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IList<Entity>, ICollection<Entity>, IEnumerable<Entity>, IEnumerable
{
    [Required(null)]
    public RectTransform holder;

    public UINavigationItem nav;

    public List<CardContainer> shoveTo = new List<CardContainer>();

    public CardContainer _group;

    public readonly List<Entity> entities = new List<Entity>();

    public Character owner;

    public bool canBePlacedOn;

    public bool canPlayOn;

    public bool canHover = true;

    public int max;

    public Vector3 gap;

    public Vector3 childHoverOffset;

    [Header("Movement Tween")]
    public Vector2 movementDurRand = new Vector2(0.3f, 0.4f);

    public LeanTweenType movementEase = LeanTweenType.easeOutQuart;

    [Header("Scale Tween")]
    public Vector2 scaleDurRand = new Vector2(0.2f, 0.2f);

    public LeanTweenType scaleEase = LeanTweenType.easeOutQuart;

    [Header("Events")]
    public UnityEventEntity onAdd;

    public UnityEventEntity onRemove;

    public CardController _cc;

    [SerializeField]
    public bool poolCardsOnDestroy = true;

    public virtual CardContainer Group
    {
        get
        {
            if (!(_group))
            {
                return this;
            }
            return _group;
        }
        set
        {
            _group = value;
        }
    }

    public virtual int Count { get; set; }

    public virtual float CardScale => holder.sizeDelta.y / 4.5f * 1f;

    public bool Empty => Count <= 0;

    public CardController cc
    {
        get
        {
            if (!(_cc))
            {
                _cc = CardController.Find(gameObject);
            }
            return _cc;
        }
    }

    public bool IsReadOnly => false;

    public virtual int ChildCount => ((Transform)holder).childCount;

    public virtual Entity this[int index]
    {
        get
        {
            if (entities.Count <= index)
            {
                return null;
            }
            return entities[index];
        }
        set
        {
            throw new NotImplementedException();
        }
    }

    public static CardContainer[] FindAll()
    {
        CardContainer[] array = Object.FindObjectsOfType<CardContainer>();
        HashSet<CardContainer> hashSet = GenericPool<HashSet<CardContainer>>.Get();
        hashSet.Clear();
        CardContainer[] array2 = array;
        foreach (CardContainer cardContainer in array2)
        {
            if (cardContainer.Group != cardContainer)
            {
                HashSetExt.AddIfNotNull<CardContainer>(hashSet, cardContainer);
            }
        }
        CardContainer[] result = HashSetExt.ToArray<CardContainer>(hashSet);
        GenericPool<HashSet<CardContainer>>.Release(hashSet);
        return result;
    }

    public CardContainer[] GetSecondaryContainers(Entity entity)
    {
        List<CardContainer> list = GenericPool<List<CardContainer>>.Get();
        list.Clear();
        CardContainer[] array = FindAll();
        foreach (CardContainer cardContainer in array)
        {
            if (cardContainer != this && cardContainer.Contains(entity))
            {
                list.Add(cardContainer);
            }
        }
        CardContainer[] result = list.ToArray();
        GenericPool<List<CardContainer>>.Release(list);
        return result;
    }

    public virtual void AssignController(CardController controller)
    {
        _cc = controller;
    }

    public void Start()
    {
        nav = null;
        CheckForNavigationItem(transform);
    }

    public void CheckForNavigationItem(Transform inTransform)
    {
        if ((((Component)inTransform).GetComponent<UINavigationItem>()))
        {
            nav = ((Component)inTransform).GetComponent<UINavigationItem>();
            return;
        }
        for (int i = 0; i < inTransform.childCount; i++)
        {
            CheckForNavigationItem(inTransform.GetChild(i));
        }
    }

    public void OnDestroy()
    {
        if (!GameManager.End && poolCardsOnDestroy)
        {
            for (int num = entities.Count - 1; num >= 0; num--)
            {
                CardManager.ReturnToPool(entities[num]);
            }
        }
    }

    public virtual void SetSize(int size, float cardScale)
    {
        max = size;
    }

    public virtual void Add(Entity entity)
    {
        entity.transform.SetParent((Transform)(object)holder);
        entity.AddTo(this);
        entities.Add(entity);
        Count++;
        CardAdded(entity);
        ((UnityEvent<Entity>)onAdd).Invoke(entity);
    }

    public virtual void Insert(int index, Entity entity)
    {
        entity.transform.SetParent((Transform)(object)holder);
        entity.AddTo(this);
        entities.Insert(index, entity);
        Count++;
        entity.transform.SetSiblingIndex(index);
        CardAdded(entity);
        ((UnityEvent<Entity>)onAdd).Invoke(entity);
    }

    public virtual bool PushForwards(int fromIndex)
    {
        throw new NotImplementedException();
    }

    public virtual bool PushBackwards(int fromIndex)
    {
        throw new NotImplementedException();
    }

    public virtual void MoveChildrenForward()
    {
        throw new NotImplementedException();
    }

    public virtual void Remove(Entity entity)
    {
        if (!entity.inCardPool)
        {
            entity.transform.SetParent((Transform)null);
        }
        entity.RemoveFrom(this);
        entities.Remove(entity);
        Count--;
        CardRemoved(entity);
        ((UnityEvent<Entity>)onRemove).Invoke(entity);
        Debug.Log(("[" + (entity).name + "] Removed From [" + name + "]"));
    }

    public virtual void RemoveAt(int index)
    {
        Remove(this[index]);
    }

    public virtual Entity GetTop()
    {
        if (entities.Count <= 0)
        {
            return null;
        }
        return entities[entities.Count - 1];
    }

    public virtual Vector3 GetChildPosition(Entity child)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        return Vector3.zero;
    }

    public virtual Vector3 GetChildScale(Entity child)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        return Vector3.one * CardScale;
    }

    public virtual Vector3 GetChildRotation(Entity child)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        return Vector3.zero;
    }

    public virtual int GetChildDrawOrder(Entity child)
    {
        return 0;
    }

    public virtual void CardAdded(Entity entity)
    {
    }

    public virtual void CardRemoved(Entity entity)
    {
    }

    public bool IsPrimaryContainer(Entity entity)
    {
        if ((entity) && entity.actualContainers.Count > 0)
        {
            return entity.actualContainers[0] == this;
        }
        return false;
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public virtual void TweenChildPositions()
    {
        foreach (Entity item in this.Where((Entity a) => a.alive))
        {
            item.TweenToContainer();
        }
    }

    public virtual void SetChildPositions()
    {
        using IEnumerator<Entity> enumerator = GetEnumerator();
        while (enumerator.MoveNext())
        {
            Entity current = enumerator.Current;
            SetChildPosition(current);
        }
    }

    public virtual void TweenChildPosition(Entity child)
    {
        child.TweenToContainer();
    }

    public virtual void SetChildPosition(Entity child)
    {
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        child.transform.localPosition = GetChildPosition(child);
        child.transform.localScale = GetChildScale(child);
        child.transform.localEulerAngles = GetChildRotation(child);
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        if (canHover)
        {
            Hover();
        }
    }

    public virtual void Hover()
    {
        if ((cc))
        {
            cc.HoverContainer(this);
        }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        if (canHover)
        {
            UnHover();
        }
    }

    public virtual void UnHover()
    {
        if ((cc) && cc.hoverContainer == this)
        {
            cc.UnHoverContainer();
        }
    }

    public virtual int IndexOf(Entity item)
    {
        return entities.IndexOf(item);
    }

    public virtual void Clear()
    {
        for (int num = Count - 1; num >= 0; num--)
        {
            RemoveAt(num);
        }
    }

    public void DestroyAll()
    {
        using IEnumerator<Entity> enumerator = GetEnumerator();
        while (enumerator.MoveNext())
        {
            CardManager.ReturnToPool(enumerator.Current);
        }
    }

    public void ClearAndDestroyAllImmediately()
    {
        Entity[] array = ToArray();
        Clear();
        Entity[] array2 = array;
        for (int i = 0; i < array2.Length; i++)
        {
            GameObjectExt.DestroyImmediate(((Component)array2[i]).gameObject);
        }
    }

    public virtual bool Contains(Entity item)
    {
        return entities.Contains(item);
    }

    public virtual Entity[] ToArray()
    {
        return entities.ToArray();
    }

    public void CopyTo(Entity[] array, int arrayIndex)
    {
        entities.CopyTo(array, arrayIndex);
    }

    bool ICollection<Entity>.Remove(Entity item)
    {
        throw new NotImplementedException();
    }

    public virtual IEnumerator<Entity> GetEnumerator()
    {
        return entities.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
public class CardContainerGrid : CardContainer
{
    [SerializeField]
    public bool fixedWidth;

    [SerializeField]
    public float minHeight;

    [SerializeField]
    public Vector2 cellSize = new Vector2(2.25f, 3.375f);

    [SerializeField]
    public Vector2 spacing = new Vector2(0.5f, 0.5f);

    [SerializeField]
    public int columnCount = 5;

    [SerializeField]
    public TextAlignment align = (TextAlignment)1;

    [Header("Sort Cards by Type")]
    [SerializeField]
    public bool sort;

    [Header("A lil randomness to card position/rotation")]
    [SerializeField]
    public Vector3 randomOffset;

    [SerializeField]
    public Vector3 randomRotation;

    public override float CardScale => cellSize.x / 3f;

    public new void DestroyAll()
    {
        foreach (Entity entity in entities)
        {
            CardManager.ReturnToPool(entity);
        }
        entities.Clear();
        Count = 0;
    }

    public override void CardAdded(Entity entity)
    {
        base.CardAdded(entity);
        SetSize();
        Sort();
    }

    public override void CardRemoved(Entity entity)
    {
        base.CardRemoved(entity);
        SetSize();
        Sort();
    }

    public override Vector3 GetChildPosition(Entity child)
    {
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_007b: Unknown result type (might be due to invalid IL or missing references)
        //IL_007e: Invalid comparison between Unknown and I4
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_0083: Invalid comparison between Unknown and I4
        //IL_00fe: Unknown result type (might be due to invalid IL or missing references)
        //IL_0100: Unknown result type (might be due to invalid IL or missing references)
        //IL_0156: Unknown result type (might be due to invalid IL or missing references)
        //IL_0158: Unknown result type (might be due to invalid IL or missing references)
        //IL_015e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0164: Unknown result type (might be due to invalid IL or missing references)
        //IL_0169: Unknown result type (might be due to invalid IL or missing references)
        //IL_016e: Unknown result type (might be due to invalid IL or missing references)
        //IL_009a: Unknown result type (might be due to invalid IL or missing references)
        int num = IndexOf(child);
        int num2 = num % columnCount;
        int num3 = Mathf.FloorToInt((float)(num / columnCount));
        int num4 = RowCount(num3);
        float num5 = (float)num4 * cellSize.x + (float)(num4 - 1) * spacing.x;
        Vector2 sizeDelta = base.rectTransform.sizeDelta;
        Vector2 val = new Vector2(0f - sizeDelta.x, sizeDelta.y) * 0.5f;
        TextAlignment val2 = align;
        if ((int)val2 != 1)
        {
            if ((int)val2 == 2)
            {
                val.x = sizeDelta.x * 0.5f - num5;
            }
        }
        else
        {
            val.x = (0f - num5) * 0.5f;
        }
        val.x += cellSize.x * 0.5f + spacing.x;
        val.y -= cellSize.y * 0.5f + spacing.y;
        Vector2 val3 = val;
        val3.x += (float)num2 * cellSize.x + (float)(num2 - 1) * spacing.x;
        val3.y -= (float)num3 * cellSize.y + (float)(num3 - 1) * spacing.y;
        return (val3) + Vector3.Scale(child.random3, randomOffset);
    }

    public int RowCount(int rowIndex)
    {
        return Mathf.Clamp(Count - rowIndex * columnCount, 0, columnCount);
    }

    public override Vector3 GetChildRotation(Entity child)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return Vector3.Scale(child.random3, randomRotation);
    }

    public void SetSize()
    {
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0098: Unknown result type (might be due to invalid IL or missing references)
        int num = GetColumnCount();
        int rowCount = GetRowCount();
        float num2 = (fixedWidth ? base.rectTransform.sizeDelta.x : ((float)num * cellSize.x + (float)(num - 1) * spacing.x));
        float num3 = Mathf.Max(minHeight, (float)rowCount * cellSize.y + (float)(rowCount - 1) * spacing.y);
        LayoutElement component = GetComponent<LayoutElement>();
        if (component != null)
        {
            component.preferredWidth = num2;
            component.preferredHeight = num3;
        }
        else
        {
            base.rectTransform.sizeDelta = new Vector2(num2, num3);
        }
    }

    public void Sort()
    {
        if (sort)
        {
            entities.Sort((Entity a, Entity b) => a.data.cardType.sortPriority.CompareTo(b.data.cardType.sortPriority));
        }
    }

    public int GetColumnCount()
    {
        return Mathf.Min(columnCount, Count);
    }

    public int GetRowCount()
    {
        return Mathf.CeilToInt((float)Count / (float)columnCount);
    }
}
public class CardHand : CardContainer
{
    [SerializeField]
    public float fanCircleRadius = 20f;

    [SerializeField]
    public Vector3 fanCircleStartPos = new Vector3(0f, -20f, 0f);

    public bool staticAngleAdd;

    [ShowIf("staticAngleAdd")]
    public float fanCircleAngleAdd = 5f;

    [SerializeField]
    [DisableIf("staticAngleAdd")]
    public AnimationCurve fanCircleAngleAddCurve;

    [SerializeField]
    public bool dynamicGap;

    [SerializeField]
    [EnableIf("dynamicGap")]
    public AnimationCurve dynamicGapCurve;

    public override void TweenChildPosition(Entity child)
    {
        child.DrawOrder = GetChildDrawOrder(child);
        base.TweenChildPosition(child);
    }

    public override void SetSize(int size, float cardScale)
    {
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        base.SetSize(size, cardScale);
        float num = 3f * cardScale;
        holder.sizeDelta = new Vector2(num * (float)size + GetGap(size).x * (float)(size - 1), 4.5f * cardScale);
    }

    public override Vector3 GetChildPosition(Entity child)
    {
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        int num = IndexOf(child);
        float radians = (GetAngle(num) + 90f) * ((float)Math.PI / 180f);
        Vector3 val = GetGap(Count);
        return fanCircleStartPos + val * ((float)(Count - 1) * 0.5f) - val * (float)num + (Lengthdir.ToVector2(fanCircleRadius, radians));
    }

    public override Vector3 GetChildRotation(Entity child)
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(0f, 0f, GetAngle(IndexOf(child)));
    }

    public Vector3 GetGap(int cardCount)
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        if (!dynamicGap || dynamicGapCurve.length <= 0)
        {
            return gap;
        }
        Keyframe val = dynamicGapCurve[dynamicGapCurve.length - 1];
        float time = ((val)).time;
        float num = (((float)cardCount > time) ? ((val)).value : dynamicGapCurve.Evaluate((float)cardCount));
        return Vector3Ext.WithX(gap, num);
    }

    public float GetAngleAdd()
    {
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        if (fanCircleAngleAddCurve.length <= 0 || staticAngleAdd)
        {
            return fanCircleAngleAdd;
        }
        Keyframe val = fanCircleAngleAddCurve[fanCircleAngleAddCurve.length - 1];
        float time = ((val)).time;
        if (!((float)Count > time))
        {
            return fanCircleAngleAddCurve.Evaluate((float)Count);
        }
        return ((val)).value;
    }

    public float GetAngle(int childIndex)
    {
        float angleAdd = GetAngleAdd();
        return (0f - angleAdd) * (float)(Count - 1) * 0.5f + (float)childIndex * angleAdd;
    }
}
public class CardIconStack : CardContainer
{
    public Dictionary<Entity, RectTransform> activeIcons = new Dictionary<Entity, RectTransform>();

    public Queue<RectTransform> iconPool = new Queue<RectTransform>();

    public int iconCount;

    [SerializeField]
    public Vector3 randomAngleAmount = new Vector3(0f, 0f, 2f);

    public bool insertAtBottom;

    [SerializeField]
    public RectTransform iconPrefab;

    public override void SetSize(int size, float cardScale)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        base.SetSize(size, cardScale);
        holder.sizeDelta = GameManager.CARD_SIZE * cardScale;
    }

    public override Vector3 GetChildPosition(Entity child)
    {
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        IndexOf(child);
        float num = 0f;
        float num2 = 0f;
        float num3 = num;
        float num4 = num2;
        return new Vector3(0f, num3, num4);
    }

    public override void Add(Entity entity)
    {
        if (insertAtBottom)
        {
            entity.transform.SetParent((Transform)(object)holder);
            entity.AddTo(this);
            entities.Insert(0, entity);
            entity.transform.SetSiblingIndex(0);
            Count++;
            CardAdded(entity);
            for (int i = 1; i < Count; i++)
            {
                TweenChildPosition(entities[i]);
            }
        }
        else
        {
            base.Add(entity);
        }
    }

    public override Vector3 GetChildRotation(Entity child)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        return Vector3.zero;
    }

    public override void CardAdded(Entity entity)
    {
        base.CardAdded(entity);
        ((Behaviour)entity).enabled = false;
        if (entity.flipper != null && !entity.flipper.flipped)
        {
            entity.flipper.FlipDown();
        }
        AddIcon(entity);
    }

    public override void CardRemoved(Entity entity)
    {
        RemoveIcon(entity);
    }

    public void AddIcon(Entity entity)
    {
        activeIcons[entity] = GetIcon();
        UpdateIconPositions();
    }

    public void RemoveIcon(Entity entity)
    {
        RectTransform val = activeIcons[entity];
        if (val != null)
        {
            PoolIcon(val);
            activeIcons.Remove(entity);
        }
    }

    public void UpdateIconPositions()
    {
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        int count = Count;
        for (int i = 0; i < count; i++)
        {
            Entity entity = this[i];
            RectTransform obj = activeIcons[entity];
            ((Transform)obj).SetSiblingIndex(i);
            ((Transform)obj).localPosition = gap * (float)i;
            ((Transform)obj).localEulerAngles = Vector3.Scale(entity.random3, randomAngleAmount);
        }
    }

    public void PoolIcon(RectTransform icon)
    {
        ((Component)icon).gameObject.SetActive(false);
        iconPool.Enqueue(icon);
    }

    public RectTransform GetIcon()
    {
        RectTransform val = null;
        if (iconPool.Count > 0)
        {
            val = iconPool.Dequeue();
        }
        else
        {
            val = Object.Instantiate<RectTransform>(iconPrefab, transform);
            (val).name = $"Icon {iconCount++}";
        }
        ((Component)val).gameObject.SetActive(true);
        return val;
    }
}
public class CardLane : CardContainer
{
    [Range(-1f, 1f)]
    public int dir = -1;

    public override void SetSize(int size, float cardScale)
    {
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        base.SetSize(size, cardScale);
        float num = 3f * cardScale;
        holder.sizeDelta = new Vector2(num * (float)size + gap.x * (float)(size - 1), 4.5f * cardScale);
    }

    public override Vector3 GetChildPosition(Entity child)
    {
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0133: Unknown result type (might be due to invalid IL or missing references)
        int num = IndexOf(child);
        float num2 = 3f * CardScale;
        _ = CardScale;
        float num3 = holder.sizeDelta.x * 0.5f;
        float num4 = (float)max * num2 * 0.5f + (float)(max - 1) * gap.x * 0.5f;
        float num5 = (float)(-max) * gap.y * 0.5f;
        float num6 = (float)(-max) * gap.z * 0.5f;
        bool num7 = num4 > num3;
        if (num7)
        {
            num4 = num3;
        }
        float num8 = num4 * 2f;
        num4 *= (float)dir;
        num4 += num2 * 0.5f * (float)(-dir);
        float num9 = gap.x;
        if (num7)
        {
            num9 = (num8 - num2 * (float)Count) / (float)Mathf.Max(1, Count - 1);
        }
        float num10 = (num2 + num9) * (float)(-dir);
        float num11 = num4 + num10 * (float)num;
        float num12 = num5 + gap.y * (float)num;
        float num13 = num6 + gap.z * (float)num;
        return new Vector3(num11, num12, num13);
    }

    public void SetDirection(int dir)
    {
        this.dir = dir;
    }
}
public class CardPlane : CardContainer
{
    public readonly Dictionary<Entity, Vector3> positions = new Dictionary<Entity, Vector3>();

    public override float CardScale => 1f;

    public override void Add(Entity entity)
    {
        base.Add(entity);
        StorePosition(entity);
    }

    public override void Insert(int index, Entity entity)
    {
        base.Insert(index, entity);
        StorePosition(entity);
    }

    public override void Remove(Entity entity)
    {
        base.Remove(entity);
        FreePosition(entity);
    }

    public override Vector3 GetChildPosition(Entity child)
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        if (!positions.ContainsKey(child))
        {
            return Vector3.zero;
        }
        return positions[child];
    }

    public void StorePosition(Entity entity)
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        positions[entity] = entity.transform.localPosition;
    }

    public void FreePosition(Entity entity)
    {
        positions.Remove(entity);
    }
}
public class CardPocket : CardContainer
{
    public class PositionHandler
    {
        public readonly CardPocket pocket;

        public readonly Entity entity;

        public readonly Vector3 startPosition;

        public readonly Vector3 positionChange;

        public readonly AnimationCurve curve;

        public readonly float duration;

        public float delay;

        public float t;

        public bool IsFinished => t >= duration;

        public PositionHandler(CardPocket pocket, Entity entity, Vector3 fromPosition, Vector3 toPosition, AnimationCurve slideCurve, float slideDuration, float slideDelay)
        {
            //IL_0015: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001e: Unknown result type (might be due to invalid IL or missing references)
            //IL_001f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0024: Unknown result type (might be due to invalid IL or missing references)
            this.pocket = pocket;
            this.entity = entity;
            startPosition = fromPosition;
            positionChange = toPosition - fromPosition;
            curve = slideCurve;
            duration = slideDuration;
            delay = slideDelay;
            t = 0f;
        }

        public Vector3 GetPosition()
        {
            //IL_001a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0020: Unknown result type (might be due to invalid IL or missing references)
            //IL_0026: Unknown result type (might be due to invalid IL or missing references)
            //IL_002b: Unknown result type (might be due to invalid IL or missing references)
            float num = curve.Evaluate(t / duration);
            return startPosition + positionChange * num;
        }

        public void Skip()
        {
            t = duration;
            Update(0f);
        }

        public void Update(float delta)
        {
            //IL_0054: Unknown result type (might be due to invalid IL or missing references)
            if (delay > 0f)
            {
                delay -= delta;
                if (delay <= 0f)
                {
                    Events.InvokeEntityEnterPocket(entity, pocket);
                }
            }
            else
            {
                t += delta;
                entity.transform.localPosition = GetPosition();
            }
        }
    }

    [SerializeField]
    public Transform slideInPosition;

    [SerializeField]
    public AnimationCurve slideCurve;

    [SerializeField]
    public float slideDuration = 0.5f;

    [SerializeField]
    public float slideDelay = 0.5f;

    [SerializeField]
    public Vector3 randomAngleAmount = new Vector3(0f, 0f, 1f);

    [SerializeField]
    public CardPocketInteraction interaction;

    [SerializeField]
    public CardContainer[] skipAnimationFromContainers;

    public readonly Dictionary<Entity, PositionHandler> positions = new Dictionary<Entity, PositionHandler>();

    public override void AssignController(CardController controller)
    {
        base.AssignController(controller);
        GetComponentInChildren<ToggleBasedOnCardController>(true)?.AssignCardController(controller);
    }

    public void Update()
    {
        foreach (KeyValuePair<Entity, PositionHandler> position in positions)
        {
            if (!position.Value.IsFinished)
            {
                position.Value.Update(Time.deltaTime);
            }
        }
    }

    public override void SetSize(int size, float cardScale)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        base.SetSize(size, cardScale);
        holder.sizeDelta = GameManager.CARD_SIZE * cardScale;
    }

    public override Vector3 GetChildPosition(Entity child)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return positions[child].GetPosition();
    }

    public override Vector3 GetChildRotation(Entity child)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return Vector3.Scale(child.random3, randomAngleAmount);
    }

    public Vector3 GetFinalChildPosition(Entity child)
    {
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        int num = IndexOf(child);
        float num2 = 0f;
        float num3 = 0f;
        float num4 = 0f + gap.x * (float)num;
        float num5 = num2 + gap.y * (float)num;
        float num6 = num3 + gap.z * (float)num;
        return new Vector3(num4, num5, num6);
    }

    public override void Hover()
    {
        base.Hover();
        if ((interaction))
        {
            interaction.Hover();
        }
    }

    public override void UnHover()
    {
        base.UnHover();
        if ((interaction))
        {
            interaction.UnHover();
        }
    }

    public override void CardAdded(Entity entity)
    {
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        base.CardAdded(entity);
        ((Behaviour)entity).enabled = false;
        if ((entity.uINavigationItem))
        {
            entity.uINavigationItem.isSelectable = false;
            ((Behaviour)entity.uINavigationItem).enabled = false;
        }
        if ((entity.flipper))
        {
            entity.flipper.FlipDown();
        }
        PositionHandler positionHandler = new PositionHandler(this, entity, slideInPosition.localPosition, GetFinalChildPosition(entity), slideCurve, slideDuration, slideDelay);
        positions.Add(entity, positionHandler);
        if (entity.preContainers == null || entity.preContainers.Length == 0)
        {
            positionHandler.Skip();
            return;
        }
        CardContainer[] preContainers = entity.preContainers;
        foreach (CardContainer cardContainer in preContainers)
        {
            if (IArrayExt.Contains<CardContainer>(skipAnimationFromContainers, cardContainer))
            {
                positionHandler.Skip();
                break;
            }
        }
    }

    public override void CardRemoved(Entity entity)
    {
        base.CardRemoved(entity);
        if ((entity.uINavigationItem))
        {
            entity.uINavigationItem.isSelectable = true;
            ((Behaviour)entity.uINavigationItem).enabled = true;
        }
        positions.Remove(entity);
    }
}
public class CardSlot : CardContainer
{
    [SerializeField]
    public SpriteRenderer icon;

    public Color originalIconColor;

    public void Awake()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        originalIconColor = icon.color;
    }

    public override void SetSize(int size, float cardScale)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        base.SetSize(size, cardScale);
        holder.sizeDelta = GameManager.CARD_SIZE * cardScale;
    }

    public override void CardAdded(Entity entity)
    {
        FadeOutIcon();
    }

    public override void CardRemoved(Entity entity)
    {
        if (base.Empty)
        {
            FadeInIcon();
        }
    }

    public void ForceHover()
    {
        base.cc?.HoverSlot(this);
    }

    public void ForceUnHover()
    {
        if (base.cc != null && base.cc.hoverSlot == this)
        {
            base.cc.UnHoverSlot();
        }
    }

    public override void Hover()
    {
        if (canHover && base.cc != null)
        {
            base.cc.HoverSlot(this);
        }
    }

    public override void UnHover()
    {
        if (canHover && base.cc != null && base.cc.hoverSlot == this)
        {
            base.cc.UnHoverSlot();
        }
    }

    public void FadeOutIcon()
    {
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(((Component)icon).gameObject);
        LeanTween.color(((Component)icon).gameObject, ColorExt.With(originalIconColor, -1f, -1f, -1f, 0f), 0.33f);
    }

    public void FadeInIcon()
    {
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(((Component)icon).gameObject);
        LeanTween.color(((Component)icon).gameObject, originalIconColor, 0.33f);
    }
}
public class CardSlotLane : CardContainer
{
    public class PushData
    {
        public readonly Dictionary<Entity, List<CardContainer>> dict = new Dictionary<Entity, List<CardContainer>>();

        public void Add(PushData other)
        {
            foreach (KeyValuePair<Entity, List<CardContainer>> item in other.dict)
            {
                Add(item.Key, item.Value);
            }
        }

        public void Add(Entity entity, CardContainer container)
        {
            if (dict.ContainsKey(entity))
            {
                dict[entity].Add(container);
                return;
            }
            dict[entity] = new List<CardContainer> { container };
        }

        public void Add(Entity entity, List<CardContainer> containers)
        {
            if (dict.ContainsKey(entity))
            {
                dict[entity].AddRange(containers);
            }
            else
            {
                dict[entity] = containers;
            }
        }

        public void Execute()
        {
            foreach (KeyValuePair<Entity, List<CardContainer>> item in dict)
            {
                item.Key.RemoveFromContainers();
            }
            foreach (KeyValuePair<Entity, List<CardContainer>> item2 in dict)
            {
                foreach (CardContainer item3 in item2.Value)
                {
                    item3.Add(item2.Key);
                }
            }
        }
    }

    public List<CardSlot> slots;

    [Required(null)]
    public CardSlot slotPrefab;

    [Required(null)]
    public HorizontalLayoutGroup layout;

    public bool autoMoveForwards = true;

    public override int Count
    {
        get
        {
            int num = 0;
            foreach (CardSlot slot in slots)
            {
                num += slot.Count;
            }
            return num;
        }
        set
        {
            base.Count = value;
        }
    }

    public override Entity this[int index]
    {
        get
        {
            int skips = GetSkips(index);
            for (int i = index + skips; i < max; i++)
            {
                CardSlot cardSlot = slots[i];
                if (cardSlot != null && !cardSlot.Empty)
                {
                    return cardSlot[0];
                }
            }
            return null;
        }
        set
        {
            throw new NotImplementedException();
        }
    }

    public override void SetSize(int size, float cardScale)
    {
        base.SetSize(size, cardScale);
        new Routine(SetSizeRoutine(size, cardScale));
    }

    public IEnumerator SetSizeRoutine(int size, float cardScale)
    {
        CreateSlots(size);
        yield return null;
        holder.sizeDelta = ((RectTransform)((Component)layout).transform).sizeDelta;
    }

    public override void MoveChildrenForward()
    {
        for (int i = 1; i < max; i++)
        {
            CardSlot cardSlot = slots[i];
            Entity top = cardSlot.GetTop();
            if (!(top) || top.positionPriority <= 0)
            {
                continue;
            }
            int num = 0;
            List<CardSlot> list = new List<CardSlot> { cardSlot };
            if (top.height > 1)
            {
                CardContainer[] secondaryContainers = cardSlot.GetSecondaryContainers(top);
                foreach (CardContainer cardContainer in secondaryContainers)
                {
                    if (cardContainer is CardSlot item && cardContainer.Group is CardSlotLane)
                    {
                        list.Add(item);
                    }
                }
            }
            for (int num2 = i - 1; num2 >= 0; num2--)
            {
                bool flag = true;
                foreach (CardSlot item3 in list)
                {
                    if (!(item3.Group as CardSlotLane).slots[num2].Empty)
                    {
                        flag = false;
                        break;
                    }
                }
                if (!flag)
                {
                    break;
                }
                num++;
            }
            if (num <= 0)
            {
                continue;
            }
            if (list.Count > 1)
            {
                foreach (CardSlot item4 in list)
                {
                    if (item4.IsPrimaryContainer(top))
                    {
                        list.Remove(item4);
                        list.Insert(0, item4);
                        break;
                    }
                }
            }
            for (int num3 = list.Count - 1; num3 >= 0; num3--)
            {
                CardSlot cardSlot2 = list[num3];
                CardSlotLane obj = cardSlot2.Group as CardSlotLane;
                int num4 = obj.slots.IndexOf(cardSlot2);
                CardSlot cardSlot3 = obj.slots[num4 - num];
                cardSlot2.Remove(top);
                cardSlot3.Add(top);
            }
        }
        for (int num5 = max - 2; num5 >= 0; num5--)
        {
            CardSlot cardSlot4 = slots[num5];
            Entity top2 = cardSlot4.GetTop();
            if ((top2) && top2.positionPriority < 0)
            {
                int num6 = 0;
                List<CardSlot> list2 = new List<CardSlot> { cardSlot4 };
                if (top2.height > 1)
                {
                    CardContainer[] secondaryContainers = cardSlot4.GetSecondaryContainers(top2);
                    foreach (CardContainer cardContainer2 in secondaryContainers)
                    {
                        if (cardContainer2 is CardSlot item2 && cardContainer2.Group is CardSlotLane)
                        {
                            list2.Add(item2);
                        }
                    }
                }
                for (int k = num5 + 1; k < max; k++)
                {
                    bool flag2 = true;
                    foreach (CardSlot item5 in list2)
                    {
                        if (!(item5.Group as CardSlotLane).slots[k].Empty)
                        {
                            flag2 = false;
                            break;
                        }
                    }
                    if (!flag2)
                    {
                        break;
                    }
                    num6++;
                }
                if (num6 > 0)
                {
                    if (list2.Count > 1)
                    {
                        foreach (CardSlot item6 in list2)
                        {
                            if (item6.IsPrimaryContainer(top2))
                            {
                                list2.Remove(item6);
                                list2.Insert(0, item6);
                                break;
                            }
                        }
                    }
                    for (int num7 = list2.Count - 1; num7 >= 0; num7--)
                    {
                        CardSlot cardSlot5 = list2[num7];
                        CardSlotLane obj2 = cardSlot5.Group as CardSlotLane;
                        int num8 = obj2.slots.IndexOf(cardSlot5);
                        CardSlot cardSlot6 = obj2.slots[num8 + num6];
                        cardSlot5.Remove(top2);
                        cardSlot6.Add(top2);
                    }
                }
            }
        }
    }

    public void SetDirection(int direction)
    {
        ((HorizontalOrVerticalLayoutGroup)layout).reverseArrangement = direction == 1;
    }

    public void CreateSlots(int count)
    {
        TransformExt.DestroyAllChildren(((Component)layout).transform);
        slots.Clear();
        CardSlot cardSlot = null;
        for (int i = 0; i < count; i++)
        {
            CardSlot cardSlot2 = Object.Instantiate<CardSlot>(slotPrefab, ((Component)layout).transform);
            (cardSlot2).name = $"{name} [Slot {i + 1}]";
            cardSlot2.owner = owner;
            cardSlot2.Group = this;
            slots.Add(cardSlot2);
            if ((cardSlot))
            {
                cardSlot.shoveTo.Add(cardSlot2);
                cardSlot2.shoveTo.Add(cardSlot);
            }
            cardSlot = cardSlot2;
        }
    }

    public override void Add(Entity entity)
    {
        if (Count >= max)
        {
            return;
        }
        if (entity.positionPriority >= 0)
        {
            for (int i = 0; i < max; i++)
            {
                CardSlot cardSlot = slots[i];
                Entity top = cardSlot.GetTop();
                if (!(top))
                {
                    cardSlot.Add(entity);
                    break;
                }
                if (top.positionPriority >= entity.positionPriority)
                {
                    continue;
                }
                bool flag = true;
                for (int j = i + 1; j < max; j++)
                {
                    Entity top2 = slots[j].GetTop();
                    if ((top2) && top2.positionPriority >= entity.positionPriority)
                    {
                        flag = false;
                        break;
                    }
                }
                if (flag)
                {
                    Insert(i, entity);
                    break;
                }
            }
            return;
        }
        for (int num = max - 1; num >= 0; num--)
        {
            CardSlot cardSlot2 = slots[num];
            Entity top3 = cardSlot2.GetTop();
            if (!(top3))
            {
                cardSlot2.Add(entity);
                break;
            }
            if (top3.positionPriority <= entity.positionPriority)
            {
                Insert(num, entity);
                break;
            }
        }
    }

    public override void Insert(int index, Entity entity)
    {
        if (Count >= max)
        {
            return;
        }
        CardSlot cardSlot = slots[index];
        if ((cardSlot) && cardSlot.Empty)
        {
            cardSlot.Add(entity);
            return;
        }
        bool flag = PushForwards(index);
        if (!flag)
        {
            flag = PushBackwards(index);
        }
        if (flag)
        {
            cardSlot.Add(entity);
        }
    }

    public override bool PushForwards(int fromIndex)
    {
        bool num = CanPush(fromIndex);
        if (num)
        {
            GetPushData(fromIndex).Execute();
        }
        return num;
    }

    public override bool PushBackwards(int fromIndex)
    {
        bool num = CanPush(fromIndex, 1);
        if (num)
        {
            GetPushData(fromIndex, 1).Execute();
        }
        return num;
    }

    public bool CanPush(int fromIndex, int direction = -1)
    {
        bool result = true;
        Entity top = slots[fromIndex].GetTop();
        if ((top))
        {
            CardContainer[] containers = top.containers;
            for (int i = 0; i < containers.Length; i++)
            {
                if (containers[i] is CardSlotLane cardSlotLane)
                {
                    int num = cardSlotLane.IndexOf(top) + direction;
                    if (num >= 0 && num < cardSlotLane.max)
                    {
                        if (!cardSlotLane.CanPush(num, direction))
                        {
                            result = false;
                            break;
                        }
                        continue;
                    }
                    result = false;
                    break;
                }
                result = false;
                break;
            }
        }
        return result;
    }

    public PushData GetPushData(int fromIndex, int direction = -1)
    {
        PushData pushData = new PushData();
        Entity top = slots[fromIndex].GetTop();
        if ((top))
        {
            CardContainer[] containers = top.containers;
            for (int i = 0; i < containers.Length; i++)
            {
                if (containers[i] is CardSlotLane cardSlotLane)
                {
                    int num = cardSlotLane.IndexOf(top) + direction;
                    if (num >= 0 && num < cardSlotLane.max)
                    {
                        CardSlot container = cardSlotLane.slots[num];
                        pushData.Add(top, container);
                        pushData.Add(cardSlotLane.GetPushData(num, direction));
                    }
                }
            }
        }
        return pushData;
    }

    public override void Remove(Entity entity)
    {
        foreach (CardSlot slot in slots)
        {
            if (slot.Count > 0 && slot[0] == entity)
            {
                slot.Remove(entity);
            }
        }
    }

    public override void RemoveAt(int index)
    {
        CardSlot cardSlot = slots[index];
        if ((cardSlot) && !cardSlot.Empty)
        {
            cardSlot.RemoveAt(0);
        }
    }

    public int GetSkips(int upToIndex)
    {
        int num = 0;
        for (int i = 0; i <= upToIndex; i++)
        {
            CardSlot cardSlot = slots[i];
            if (cardSlot == null || cardSlot.Empty)
            {
                num++;
            }
        }
        return num;
    }

    public override Entity GetTop()
    {
        if (max <= 0)
        {
            return null;
        }
        if (slots[0].Empty)
        {
            return null;
        }
        return slots[0][0];
    }

    public override int IndexOf(Entity item)
    {
        for (int i = 0; i < max; i++)
        {
            if (slots[i].Contains(item))
            {
                return i;
            }
        }
        return -1;
    }

    public override bool Contains(Entity item)
    {
        return slots.Any((CardSlot slot) => slot.Contains(item));
    }

    public override Entity[] ToArray()
    {
        List<Entity> list = new List<Entity>();
        foreach (CardSlot slot in slots)
        {
            if (slot.Count > 0)
            {
                list.Add(slot[0]);
            }
        }
        return list.ToArray();
    }

    public override IEnumerator<Entity> GetEnumerator()
    {
        foreach (CardSlot slot in slots)
        {
            foreach (Entity item in slot)
            {
                yield return item;
            }
        }
    }
}
public class CardStack : CardContainer
{
    [SerializeField]
    public Vector3 randomAngleAmount = new Vector3(0f, 0f, 2f);

    public bool insertAtBottom;

    public bool flipOnAdd = true;

    public override void SetSize(int size, float cardScale)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        base.SetSize(size, cardScale);
        holder.sizeDelta = GameManager.CARD_SIZE * cardScale;
    }

    public override Vector3 GetChildPosition(Entity child)
    {
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        int num = IndexOf(child);
        float num2 = 0f;
        float num3 = 0f;
        float num4 = 0f + gap.x * (float)num;
        float num5 = num2 + gap.y * (float)num;
        float num6 = num3 + gap.z * (float)num;
        return new Vector3(num4, num5, num6);
    }

    public override void Add(Entity entity)
    {
        if (insertAtBottom)
        {
            entity.transform.SetParent((Transform)(object)holder);
            entity.AddTo(this);
            entities.Insert(0, entity);
            entity.transform.SetSiblingIndex(0);
            Count++;
            CardAdded(entity);
            for (int i = 1; i < Count; i++)
            {
                TweenChildPosition(entities[i]);
            }
        }
        else
        {
            base.Add(entity);
        }
    }

    public override Vector3 GetChildRotation(Entity child)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return Vector3.Scale(child.random3, randomAngleAmount);
    }

    public override void CardAdded(Entity entity)
    {
        base.CardAdded(entity);
        ((Behaviour)entity).enabled = false;
        if (flipOnAdd && (entity.flipper))
        {
            entity.flipper.FlipDown();
        }
    }
}
public class CardController : MonoBehaviour
{
    public Character owner;

    [ReadOnly]
    public GameObject hover;

    [ReadOnly]
    public Entity hoverEntity;

    [ReadOnly]
    public Entity dragging;

    [ReadOnly]
    public CardContainer hoverContainer;

    [ReadOnly]
    public CardSlot hoverSlot;

    public bool canHoverWhileDragging = true;

    [Range(0f, 1f)]
    public float dragLerp = 0.25f;

    public float hoverZ = -0.2f;

    public float dragZ = -1f;

    [Header("Hover Tween")]
    public float cardHoverScale = 1.33f;

    public LeanTweenType cardHoverEase = LeanTweenType.easeOutBack;

    public float cardHoverEaseDur = 0.33f;

    public LeanTweenType cardUnHoverEase = LeanTweenType.easeOutBack;

    public float cardUnHoverEaseDur = 0.33f;

    [Header("Draw Order")]
    public int hoverDrawOrder = 100;

    public int dragDrawOrder = 200;

    [Header("Interactables")]
    public bool interactWithInPlay = true;

    public bool interactWithNotInPlay = true;

    public bool canPress = true;

    public bool canPressAndHoverInSameFrame;

    public Vector3 draggingPositionPre;

    public int draggingLayerPre;

    public Entity pressEntity;

    public bool press;

    public virtual bool AllowDynamicSelectRelease => InputSystem.AllowDynamicSelectRelease;

    public Vector3 CardHoverScale => new Vector3(cardHoverScale * 1f, cardHoverScale * 1f, 1f);

    public static CardController Find(GameObject gameObject)
    {
        return gameObject.GetComponentInParent<CardController>();
    }

    public virtual void Update()
    {
        if (!press)
        {
            if (canPress && InputSystem.IsSelectPressed())
            {
                press = true;
                if (canPressAndHoverInSameFrame || !(hoverEntity) || hoverEntity.display.hover.WasHovering)
                {
                    pressEntity = hoverEntity;
                    Press();
                    if ((pressEntity))
                    {
                        Events.InvokeEntitySelect(pressEntity);
                    }
                }
            }
        }
        else if (InputSystem.IsDynamicSelectReleased(AllowDynamicSelectRelease && (dragging)))
        {
            Release();
            pressEntity = null;
            press = false;
        }
        if ((dragging))
        {
            DragUpdate();
        }
    }

    public void Enable()
    {
        enabled = true;
    }

    public void OnEnable()
    {
        Events.InvokeCardControllerEnabled(this);
    }

    public void Disable()
    {
        enabled = false;
        Release();
        UnHover();
    }

    public void OnDisable()
    {
        Events.InvokeCardControllerDisabled(this);
    }

    public virtual void Press()
    {
    }

    public virtual void Release()
    {
    }

    public bool TryDrag(Entity entity)
    {
        if (Events.CheckEntityDrag(entity))
        {
            Drag(entity);
            return true;
        }
        return false;
    }

    public void Drag(Entity entity)
    {
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        dragging = entity;
        draggingLayerPre = ((Component)dragging).gameObject.layer;
        ((Component)dragging).gameObject.layer = LayerMask.NameToLayer("Default");
        entity.dragging = true;
        draggingPositionPre = dragging.transform.position;
        if (dragDrawOrder != 0)
        {
            entity.DrawOrder = dragDrawOrder;
        }
        Events.InvokeEntityDrag(entity);
    }

    public virtual void DragEnd()
    {
        Events.InvokeEntityRelease(dragging);
        ((Component)dragging).gameObject.layer = draggingLayerPre;
        dragging.dragging = false;
        dragging = null;
        press = false;
    }

    public virtual void DragUpdate()
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        DragUpdatePosition();
        Wobbler wobbler = dragging.wobbler;
        if ((wobbler))
        {
            Vector3 position = dragging.transform.position;
            Vector3 movement = position - draggingPositionPre;
            wobbler.Wobble(movement);
            draggingPositionPre = position;
        }
    }

    public virtual void DragCancel()
    {
        DragEnd();
        UnHover(dragging);
    }

    public virtual bool CanUseOn(Entity entity, Entity target)
    {
        if ((entity) && (target) && entity.data.playType == Card.PlayType.Play && !entity.targetMode.TargetRow && ((entity.data.canPlayOnBoard && Battle.IsOnBoard(target)) || (entity.data.canPlayOnHand && IArrayExt.Contains<CardContainer>(target.containers, entity.owner?.handContainer))) && ((entity.data.canPlayOnFriendly && entity.owner == target.owner) || (entity.data.canPlayOnEnemy && entity.owner != target.owner)))
        {
            return entity.CanPlayOn(target);
        }
        return false;
    }

    public Vector3 GetDragPosition()
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        return Vector3Ext.WithZ(Cursor3d.Position - (dragging.offset.position - dragging.transform.position), dragZ);
    }

    public virtual void DragUpdatePosition()
    {
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        dragging.transform.position = Delta.Lerp(dragging.transform.position, GetDragPosition(), dragLerp, Time.deltaTime);
    }

    public void Hover(Entity entity)
    {
        if ((!(dragging) || (canHoverWhileDragging && CanUseOn(dragging, entity))) && (!entity.StillExists() || (entity.inPlay && interactWithInPlay) || (!entity.inPlay && interactWithNotInPlay)))
        {
            if ((hoverEntity) && dragging != hoverEntity)
            {
                UnHover(hoverEntity);
            }
            if ((entity) && entity != dragging)
            {
                hoverEntity = entity;
                TweenHover(entity);
                Events.InvokeEntityHover(entity);
            }
        }
    }

    public void UnHover(Entity entity)
    {
        if (!(dragging) || canHoverWhileDragging)
        {
            if (hoverEntity == entity)
            {
                hoverEntity = null;
                Events.InvokeEntityUnHover(entity);
            }
            if (dragging != entity)
            {
                TweenUnHover(entity);
            }
        }
    }

    public void UnHover()
    {
        if ((hoverEntity))
        {
            UnHover(hoverEntity);
        }
    }

    public void HoverContainer(CardContainer container)
    {
        UnHoverContainer();
        hoverContainer = container;
        Events.InvokeContainerHover(container);
    }

    public void UnHoverContainer()
    {
        if ((hoverContainer))
        {
            Events.InvokeContainerUnHover(hoverContainer);
            hoverContainer = null;
        }
    }

    public void HoverSlot(CardSlot slot)
    {
        if (!(dragging) || dragging.CanPlayOn(slot))
        {
            UnHoverSlot();
            hoverSlot = slot;
            Events.InvokeSlotHover(slot);
        }
    }

    public void UnHoverSlot()
    {
        if ((hoverSlot))
        {
            Events.InvokeSlotUnHover(hoverSlot);
            hoverSlot = null;
        }
    }

    public void TweenHover(Entity entity, bool doScale = true, bool doMove = true, bool doRotate = true, bool doDrawOrder = true)
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bc: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        //IL_0095: Unknown result type (might be due to invalid IL or missing references)
        //IL_009a: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ba: Unknown result type (might be due to invalid IL or missing references)
        GameObject gameObject = ((Component)entity.offset).gameObject;
        LeanTween.cancel(gameObject);
        if (doScale)
        {
            LeanTween.scale(gameObject, CardHoverScale, cardHoverEaseDur).setEase(cardHoverEase);
        }
        if (doMove)
        {
            float num = 0f;
            Vector3 val = default(Vector3);
            ((val))..ctor(0f, num, 0f);
            if (entity.containers.Length != 0)
            {
                CardContainer[] containers = entity.containers;
                foreach (CardContainer cardContainer in containers)
                {
                    num -= cardContainer.GetChildPosition(entity).y / entity.transform.localScale.y;
                    val += cardContainer.childHoverOffset;
                }
                val /= (float)entity.actualContainers.Count;
            }
            LeanTween.moveLocal(gameObject, Vector3Ext.WithZ(val, hoverZ), cardHoverEaseDur * 1.5f).setEase(LeanTweenType.easeOutQuart);
        }
        if (doRotate)
        {
            LeanTween.rotateZ(gameObject, 0f, cardHoverEaseDur * 1.5f).setEase(LeanTweenType.easeOutQuart);
        }
        if (doDrawOrder && hoverDrawOrder != 0)
        {
            entity.DrawOrder = hoverDrawOrder;
        }
        if ((entity.display) && (entity.display.hover))
        {
            entity.display.hover.hovering = true;
        }
    }

    public void TweenUnHover(Entity entity, bool retainScale = false, bool retainPosition = false, bool retainRotation = false, bool retainDrawOrder = false)
    {
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        GameObject gameObject = ((Component)entity.offset).gameObject;
        LeanTween.cancel(gameObject);
        if (!retainScale)
        {
            LeanTween.scale(gameObject, Vector3.one, cardUnHoverEaseDur).setEase(cardUnHoverEase);
        }
        if (!retainPosition)
        {
            LeanTween.moveLocal(gameObject, Vector3.zero, cardUnHoverEaseDur).setEase(cardUnHoverEase);
        }
        if (!retainRotation)
        {
            LeanTween.rotateLocal(gameObject, Vector3.zero, cardUnHoverEaseDur).setEase(cardUnHoverEase);
        }
        if (!retainDrawOrder)
        {
            entity.ResetDrawOrder();
        }
        if ((entity.display) && (entity.display.hover))
        {
            entity.display.hover.hovering = false;
        }
    }
}
public class CardControllerBattle : CardController
{
    public UINavigationItem useOnHandAnchor;

    public override void Press()
    {
        if ((pressEntity) && pressEntity.owner == owner)
        {
            Debug.Log(("Pressing [" + (pressEntity).name + "]"));
            if (TryDrag(pressEntity))
            {
                UnHover(pressEntity);
                NavigationState.Start(new NavigationStateCard(pressEntity));
            }
        }
    }

    public override void DragUpdatePosition()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_02c3: Unknown result type (might be due to invalid IL or missing references)
        //IL_02c8: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        //IL_007c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0081: Unknown result type (might be due to invalid IL or missing references)
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        //IL_009d: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ae: Unknown result type (might be due to invalid IL or missing references)
        //IL_041e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0423: Unknown result type (might be due to invalid IL or missing references)
        //IL_042f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0198: Unknown result type (might be due to invalid IL or missing references)
        //IL_019d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0166: Unknown result type (might be due to invalid IL or missing references)
        //IL_016b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0177: Unknown result type (might be due to invalid IL or missing references)
        //IL_012f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0134: Unknown result type (might be due to invalid IL or missing references)
        //IL_0136: Unknown result type (might be due to invalid IL or missing references)
        //IL_0138: Unknown result type (might be due to invalid IL or missing references)
        //IL_0139: Unknown result type (might be due to invalid IL or missing references)
        //IL_013b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0145: Unknown result type (might be due to invalid IL or missing references)
        //IL_014a: Unknown result type (might be due to invalid IL or missing references)
        //IL_014f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0272: Unknown result type (might be due to invalid IL or missing references)
        //IL_0273: Unknown result type (might be due to invalid IL or missing references)
        //IL_0274: Unknown result type (might be due to invalid IL or missing references)
        //IL_0275: Unknown result type (might be due to invalid IL or missing references)
        //IL_027f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0284: Unknown result type (might be due to invalid IL or missing references)
        //IL_0289: Unknown result type (might be due to invalid IL or missing references)
        //IL_02a0: Unknown result type (might be due to invalid IL or missing references)
        //IL_02a5: Unknown result type (might be due to invalid IL or missing references)
        //IL_02b1: Unknown result type (might be due to invalid IL or missing references)
        //IL_0202: Unknown result type (might be due to invalid IL or missing references)
        //IL_0207: Unknown result type (might be due to invalid IL or missing references)
        //IL_020d: Unknown result type (might be due to invalid IL or missing references)
        //IL_021a: Unknown result type (might be due to invalid IL or missing references)
        //IL_021f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0374: Unknown result type (might be due to invalid IL or missing references)
        //IL_0384: Unknown result type (might be due to invalid IL or missing references)
        //IL_0394: Unknown result type (might be due to invalid IL or missing references)
        //IL_0399: Unknown result type (might be due to invalid IL or missing references)
        //IL_039e: Unknown result type (might be due to invalid IL or missing references)
        //IL_03a3: Unknown result type (might be due to invalid IL or missing references)
        //IL_03cb: Unknown result type (might be due to invalid IL or missing references)
        //IL_03db: Unknown result type (might be due to invalid IL or missing references)
        //IL_03eb: Unknown result type (might be due to invalid IL or missing references)
        //IL_03f0: Unknown result type (might be due to invalid IL or missing references)
        //IL_03f5: Unknown result type (might be due to invalid IL or missing references)
        //IL_03fa: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = GetDragPosition();
        if ((hoverContainer) && hoverContainer.canBePlacedOn && hoverContainer == owner.discardContainer && dragging.CanRecall())
        {
            val = ((Component)hoverContainer).transform.position - Vector3.Scale(dragging.offset.localPosition, dragging.transform.localScale);
            dragging.transform.position = Delta.Lerp(dragging.transform.position, val, dragLerp, Time.deltaTime);
        }
        else
        {
            if (!(dragging.data))
            {
                return;
            }
            if (dragging.data.playType == Card.PlayType.Play)
            {
                if (!dragging.NeedsTarget)
                {
                    if ((hoverContainer) && dragging.containers.Length != 0 && hoverContainer == dragging.containers[0])
                    {
                        Vector3 positionFromContainers = dragging.GetPositionFromContainers();
                        val = positionFromContainers + Vector3.ClampMagnitude(val - positionFromContainers, 0.2f);
                    }
                    dragging.transform.position = Delta.Lerp(dragging.transform.position, val, dragLerp, Time.deltaTime);
                    return;
                }
                if (dragging.NeedsTarget)
                {
                    Vector3 val2 = dragging.GetPositionFromContainers();
                    if ((!dragging.targetMode.TargetRow || !(hoverContainer) || !hoverContainer.canPlayOn) && (hoverEntity) && hoverEntity != dragging && hoverEntity.InHand())
                    {
                        Vector3 position = ((Component)useOnHandAnchor).transform.position;
                        val2 = Vector3Ext.WithX(position, (position.x + val.x) / 2f);
                    }
                    if (dragging.data.playOnSlot && dragging.CanPlayOn(hoverSlot))
                    {
                        Entity top = hoverSlot.GetTop();
                        if (top != null && ShoveSystem.CanShove(top, dragging, out var shoveData))
                        {
                            ShoveSystem.ShowShove(hoverSlot, shoveData);
                        }
                    }
                    Vector3 target = val2 + Vector3.ClampMagnitude(val - val2, 0.2f);
                    dragging.transform.position = Delta.Lerp(dragging.transform.position, target, dragLerp, Time.deltaTime);
                    return;
                }
            }
            if (ShoveSystem.Active)
            {
                val = ShoveSystem.Position;
            }
            else if (dragging.data.playType == Card.PlayType.Place && (hoverSlot) && ShoveSystem.Slot != hoverSlot && hoverSlot.canBePlacedOn && hoverSlot.owner == dragging.owner)
            {
                if (hoverSlot.Count < hoverSlot.max || dragging.actualContainers.Contains(hoverSlot))
                {
                    val = ((Component)hoverSlot).transform.position - Vector3.Scale(dragging.offset.localPosition, dragging.transform.localScale);
                }
                else if (ShoveSystem.CanShove(hoverSlot.GetTop(), dragging, out Dictionary<Entity, List<CardSlot>> shoveData2))
                {
                    val = ((Component)hoverSlot).transform.position - Vector3.Scale(dragging.offset.localPosition, dragging.transform.localScale);
                    ShoveSystem.ShowShove(hoverSlot, shoveData2);
                }
            }
            dragging.transform.position = Delta.Lerp(dragging.transform.position, val, dragLerp, Time.deltaTime);
        }
    }

    public override void DragCancel()
    {
        dragging.TweenToContainer();
        TweenUnHover(dragging);
        base.DragCancel();
    }

    public override void DragEnd()
    {
        base.DragEnd();
        NavigationState.BackToPreviousState();
    }

    public override void Release()
    {
        if (!(dragging))
        {
            return;
        }
        bool retainPosition = false;
        bool retainRotation = false;
        bool retainScale = false;
        bool retainDrawOrder = false;
        if (enabled)
        {
            if (InputSwitcher.justSwitched)
            {
                dragging.TweenToContainer();
            }
            else if ((hoverContainer) && hoverContainer.canBePlacedOn && hoverContainer == owner.discardContainer && dragging.owner == owner)
            {
                if (dragging.CanRecall())
                {
                    ActionMove action = new ActionMove(dragging, hoverContainer);
                    if (Events.CheckAction(action))
                    {
                        Events.InvokeDiscard(dragging);
                        if (Battle.IsOnBoard(dragging))
                        {
                            owner.freeAction = true;
                        }
                        ActionQueue.Add(action);
                        ActionQueue.Add(new ActionEndTurn(owner));
                        enabled = false;
                        retainDrawOrder = true;
                    }
                }
                hoverContainer.UnHover();
            }
            else
            {
                switch (dragging.data.playType)
                {
                    case Card.PlayType.Place:
                        if (!(hoverSlot) || dragging.actualContainers.Contains(hoverSlot) || !hoverSlot.canBePlacedOn || !(hoverSlot.owner == dragging.owner))
                        {
                            break;
                        }
                        if (hoverSlot.Count < hoverSlot.max)
                        {
                            ActionMove action6 = new ActionMove(dragging, hoverSlot);
                            if (Events.CheckAction(action6))
                            {
                                bool flag = Battle.IsOnBoard(dragging) && Battle.IsOnBoard(hoverSlot.Group);
                                Events.InvokeEntityPlace(dragging, new CardContainer[1] { hoverSlot }, flag);
                                ActionQueue.Add(action6);
                                ActionQueue.Add(new ActionEndTurn(owner));
                                if (flag)
                                {
                                    owner.freeAction = true;
                                }
                                enabled = false;
                            }
                        }
                        else
                        {
                            if (!ShoveSystem.CanShove(hoverSlot.GetTop(), dragging, out var shoveData))
                            {
                                break;
                            }
                            ActionMove action7 = new ActionMove(dragging, hoverSlot);
                            if (Events.CheckAction(action7))
                            {
                                bool flag2 = Battle.IsOnBoard(dragging) && Battle.IsOnBoard(hoverSlot.Group);
                                ShoveSystem.Fix = true;
                                Events.InvokeEntityPlace(dragging, new CardContainer[1] { hoverSlot }, flag2);
                                ActionQueue.Add(new ActionShove(shoveData));
                                ActionQueue.Add(action7);
                                ActionQueue.Add(new ActionEndTurn(owner));
                                if (flag2)
                                {
                                    owner.freeAction = true;
                                }
                                enabled = false;
                            }
                        }
                        break;
                    case Card.PlayType.Play:
                        if (!dragging.NeedsTarget)
                        {
                            if (!(hoverContainer) || !dragging.InContainer(hoverContainer))
                            {
                                ActionTrigger action2 = new ActionTrigger(dragging, owner.entity);
                                if (Events.CheckAction(action2))
                                {
                                    ActionQueue.Add(action2);
                                    ActionQueue.Add(new ActionReduceUses(dragging));
                                    ActionQueue.Add(new ActionResetOffset(dragging));
                                    ActionQueue.Add(new ActionEndTurn(owner));
                                    enabled = false;
                                    retainRotation = true;
                                    retainDrawOrder = true;
                                    dragging.RemoveFromContainers();
                                }
                            }
                        }
                        else if (dragging.data.playOnSlot)
                        {
                            CardContainer cardContainer = (dragging.targetMode.TargetRow ? hoverContainer : hoverSlot);
                            if (!dragging.CanPlayOn(cardContainer))
                            {
                                break;
                            }
                            ActionTriggerAgainst action3 = new ActionTriggerAgainst(dragging, owner.entity, null, cardContainer);
                            if (Events.CheckAction(action3))
                            {
                                if (ShoveSystem.Active)
                                {
                                    ShoveSystem.Fix = true;
                                }
                                ActionQueue.Add(action3);
                                ActionQueue.Add(new ActionReduceUses(dragging));
                                ActionQueue.Add(new ActionResetOffset(dragging));
                                ActionQueue.Add(new ActionEndTurn(owner));
                                enabled = false;
                                retainPosition = true;
                                retainRotation = true;
                                retainDrawOrder = true;
                            }
                        }
                        else if (dragging.targetMode.TargetRow)
                        {
                            if (dragging.CanPlayOn(hoverContainer))
                            {
                                ActionTriggerAgainst action4 = new ActionTriggerAgainst(dragging, owner.entity, null, hoverContainer);
                                if (Events.CheckAction(action4))
                                {
                                    ActionQueue.Add(action4);
                                    ActionQueue.Add(new ActionReduceUses(dragging));
                                    ActionQueue.Add(new ActionResetOffset(dragging));
                                    ActionQueue.Add(new ActionEndTurn(owner));
                                    enabled = false;
                                    retainPosition = true;
                                    retainRotation = true;
                                    retainDrawOrder = true;
                                }
                            }
                        }
                        else if ((hoverEntity) && hoverEntity != dragging)
                        {
                            ActionTriggerAgainst action5 = new ActionTriggerAgainst(dragging, owner.entity, hoverEntity, null);
                            if (Events.CheckAction(action5))
                            {
                                ActionQueue.Add(action5);
                                ActionQueue.Add(new ActionReduceUses(dragging));
                                ActionQueue.Add(new ActionResetOffset(dragging));
                                ActionQueue.Add(new ActionEndTurn(owner));
                                enabled = false;
                                retainPosition = true;
                                retainRotation = true;
                                retainDrawOrder = true;
                            }
                        }
                        break;
                }
            }
            if (ActionQueue.Empty)
            {
                dragging.TweenToContainer();
            }
        }
        TweenUnHover(dragging, retainScale, retainPosition, retainRotation, retainDrawOrder);
        DragEnd();
        UnHover();
    }
}
public class CardControllerCardOrganizer : CardController
{
    [Header("Plane to store positions in")]
    [SerializeField]
    public CardPlane cardPlane;

    [Header("Snap To Grid")]
    [SerializeField]
    public Vector2 snapOffset;

    [SerializeField]
    public Vector2 snapSize = new Vector2(3.8f, 5.5f);

    public override void Press()
    {
        if ((pressEntity) && TryDrag(pressEntity))
        {
            pressEntity.transform.SetAsLastSibling();
        }
    }

    public override void Release()
    {
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        if (dragging != null)
        {
            Vector3 val = Vector3Ext.WithZ(GetDragPosition() - dragging.transform.parent.position, 0f);
            if (Input.GetButton("Snap"))
            {
                val = Snap(val);
            }
            dragging.transform.localPosition = val;
            cardPlane?.StorePosition(dragging);
            ((Component)dragging).gameObject.layer = draggingLayerPre;
            dragging.dragging = false;
            TweenUnHover(dragging);
            DragEnd();
        }
    }

    public override void DragUpdatePosition()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3Ext.WithZ(GetDragPosition() - dragging.transform.parent.position, dragZ);
        if (Input.GetButton("Snap"))
        {
            val = Snap(val);
        }
        dragging.transform.localPosition = Delta.Lerp(dragging.transform.localPosition, val, dragLerp, Time.deltaTime);
    }

    public Vector3 Snap(Vector3 position)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        position.x = Mathf.Round((position.x + snapOffset.x) / snapSize.x) * snapSize.x - snapOffset.x;
        position.y = Mathf.Round((position.y + snapOffset.y) / snapSize.y) * snapSize.y - snapOffset.y;
        return position;
    }
}
public class CardControllerDeck : CardController
{
    [SerializeField]
    public DeckDisplaySequence deckDisplaySequence;

    public CardContainer deckContainer;

    public CardContainer reserveContainer;

    [SerializeField]
    public DeckSelectSequence selectSequence;

    [SerializeField]
    public ScrollRect scrollRect;

    [SerializeField]
    public ContentSizeFitter contentSizeFitter;

    public override bool AllowDynamicSelectRelease => false;

    public override void Press()
    {
        if ((pressEntity))
        {
            StartCoroutine(OpenMenu(pressEntity));
        }
    }

    public IEnumerator OpenMenu(Entity entity)
    {
        Disable();
        selectSequence.SetEntity(entity);
        if (!(References.Battle))
        {
            if (owner.data.inventory.deck.Contains(entity.data))
            {
                if (entity.data.cardType.canReserve)
                {
                    selectSequence.AddMoveDown((UnityAction)delegate
                    {
                        MoveToReserve(entity);
                    });
                }
            }
            else if (owner.data.inventory.reserve.Contains(entity.data) && owner.GetCompanionCount() < owner.data.companionLimit)
            {
                selectSequence.AddMoveUp((UnityAction)delegate
                {
                    MoveToDeck(entity);
                });
            }
        }
        yield return selectSequence.Run();
        Enable();
    }

    public void MoveToDeck(Entity entity)
    {
        if (!entity.InContainerGroup(deckContainer))
        {
            entity.RemoveFromContainers();
            deckContainer.Add(entity);
        }
        if (!owner.data.inventory.deck.Contains(entity.data))
        {
            owner.data.inventory.reserve.Remove(entity.data);
            owner.data.inventory.deck.Add(entity.data);
        }
        reserveContainer.TweenChildPositions();
        deckContainer.TweenChildPositions();
        StartCoroutine(FixLayoutsRoutine());
    }

    public void MoveToReserve(Entity entity)
    {
        if (!entity.InContainerGroup(reserveContainer))
        {
            entity.RemoveFromContainers();
            reserveContainer.Add(entity);
        }
        if (!owner.data.inventory.reserve.Contains(entity.data))
        {
            owner.data.inventory.deck.Remove(entity.data);
            owner.data.inventory.reserve.Add(entity.data);
        }
        reserveContainer.TweenChildPositions();
        deckContainer.TweenChildPositions();
        StartCoroutine(FixLayoutsRoutine());
    }

    public IEnumerator FixLayoutsRoutine()
    {
        Vector2 scrollPosition = scrollRect.normalizedPosition;
        ((Behaviour)contentSizeFitter).enabled = false;
        yield return null;
        ((Behaviour)contentSizeFitter).enabled = true;
        scrollRect.normalizedPosition = scrollPosition;
    }
}
public class CardControllerDragger : CardController
{
    [Header("Dragging")]
    public bool canDrag = true;

    public UnityEventEntity onDrag;

    public UnityEventEntity onRelease;

    public UnityEventEntity onCancel;

    public override void Press()
    {
        if (canDrag && (pressEntity) && pressEntity.owner == owner && TryDrag(pressEntity))
        {
            ((UnityEvent<Entity>)onDrag)?.Invoke(pressEntity);
        }
    }

    public override void DragCancel()
    {
        if ((dragging))
        {
            ((UnityEvent<Entity>)onCancel)?.Invoke(dragging);
            DragEnd();
        }
    }

    public override void Release()
    {
        if ((dragging))
        {
            ((UnityEvent<Entity>)onRelease)?.Invoke(dragging);
            DragEnd();
        }
    }

    public override void DragEnd()
    {
        dragging.TweenToContainer();
        TweenUnHover(dragging);
        base.DragEnd();
    }
}
public class CardControllerSelectCard : CardController
{
    [Header("Press Tween")]
    public float cardPressScaleFrom = 0.8f;

    public float cardPressScaleTo = 1f;

    public LeanTweenType cardPressEase = LeanTweenType.easeOutElastic;

    public float cardPressEaseDur = 1f;

    public float cardPressWobble = 1f;

    public UnityEventEntity pressEvent;

    public UnityEventEntity hoverEvent;

    public UnityEventEntity unHoverEvent;

    public override bool AllowDynamicSelectRelease => false;

    public new void OnEnable()
    {
        Events.OnEntityHover += CardHover;
        Events.OnEntityUnHover += CardUnHover;
    }

    public new void OnDisable()
    {
        Events.OnEntityHover -= CardHover;
        Events.OnEntityUnHover -= CardUnHover;
    }

    public override void Press()
    {
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        //IL_0082: Unknown result type (might be due to invalid IL or missing references)
        //IL_0092: Unknown result type (might be due to invalid IL or missing references)
        //IL_009d: Unknown result type (might be due to invalid IL or missing references)
        if (canPress && (pressEntity) && !pressEntity.inPlay)
        {
            Debug.Log(("Pressing [" + (pressEntity).name + "]"));
            TweenHover(pressEntity);
            if (cardPressEaseDur > 0f)
            {
                LeanTween.scale(((Component)pressEntity.offset).gameObject, Vector3.one * cardPressScaleTo, cardPressEaseDur).setFrom(Vector3.one * cardPressScaleFrom).setEase(cardPressEase);
            }
            if (cardPressWobble != 0f)
            {
                pressEntity.wobbler?.WobbleRandom(cardPressWobble);
            }
        }
    }

    public override void Release()
    {
        if ((pressEntity) && hoverEntity == pressEntity && !pressEntity.inPlay)
        {
            Debug.Log($"[{this}] PRESSING [{pressEntity}]! :D");
            Entity entity = pressEntity;
            pressEntity = null;
            ((UnityEvent<Entity>)pressEvent).Invoke(entity);
        }
    }

    public void CardHover(Entity entity)
    {
        ((UnityEvent<Entity>)hoverEvent).Invoke(entity);
    }

    public void CardUnHover(Entity entity)
    {
        ((UnityEvent<Entity>)unHoverEvent).Invoke(entity);
    }
}
public class CardOrganizer : MonoBehaviour
{
    [Serializable]
    public class Data
    {
        [Serializable]
        public class Card
        {
            public string cardDataName;

            public float posX;

            public float posY;

            public Card(Entity entity)
            {
                //IL_001e: Unknown result type (might be due to invalid IL or missing references)
                //IL_0034: Unknown result type (might be due to invalid IL or missing references)
                cardDataName = (entity.data).name;
                posX = entity.transform.localPosition.x;
                posY = entity.transform.localPosition.y;
            }
        }

        public Card[] cards;

        public Data(params Entity[] entities)
        {
            List<Card> list = new List<Card>();
            foreach (Entity entity in entities)
            {
                list.Add(new Card(entity));
            }
            cards = list.ToArray();
        }
    }

    [SerializeField]
    public Canvas canvas;

    [SerializeField]
    public CardContainer cardHolder;

    [SerializeField]
    public CardController cardController;

    [Header("Card Grid")]
    [SerializeField]
    public int gridColumns = 8;

    [SerializeField]
    public Vector2 gridSpacing;

    public Vector2 startPos;

    public bool inspecting;

    public static string filePath => Application.streamingAssetsPath + "/Cards.json";

    public Vector2 GetCellSize()
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        return GameManager.CARD_SIZE + gridSpacing;
    }

    public void OnEnable()
    {
        Events.OnInspect += InspectStart;
        Events.OnInspectEnd += InspectEnd;
    }

    public void OnDisable()
    {
        Events.OnInspect -= InspectStart;
        Events.OnInspectEnd -= InspectEnd;
    }

    public void InspectStart(Entity entity)
    {
        inspecting = true;
    }

    public void InspectEnd(Entity entity)
    {
        inspecting = false;
    }

    public IEnumerator Start()
    {
        if (!GameManager.Ready)
        {
            yield break;
        }
        yield return AddressableLoader.LoadGroup("CardData");
        List<CardData> cardDataList = AddressableLoader.GetGroup<CardData>("CardData");
        int num = Mathf.RoundToInt((float)(cardDataList.Count / gridColumns));
        int num2 = Mathf.Min(gridColumns, cardDataList.Count);
        float num3 = (float)num2 * 3f + (float)(num2 - 1) * gridSpacing.x;
        float num4 = (float)num * 4.5f + (float)(num - 1) * gridSpacing.y;
        startPos.x = (0f - num3) / 2f + 1.5f;
        startPos.y = num4 / 2f - 2.25f;
        yield return Load();
        List<Entity> list = IArrayExt.ToList<Entity>(((Component)cardHolder).GetComponentsInChildren<Entity>());
        Routine.Clump clump = new Routine.Clump();
        for (int i = 0; i < cardDataList.Count; i++)
        {
            CardData cardData = cardDataList[i];
            if (!list.Exists((Entity a) => (a.data).name == (cardData).name))
            {
                Vector2 cardPos = GetCardPos(i);
                clump.Add(CreateCard(cardData, cardPos));
            }
        }
        yield return clump.WaitForEnd();
        Transition.End();
    }

    public Vector2 GetCardPos(int cardIndex)
    {
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        int num = Mathf.FloorToInt((float)(cardIndex / gridColumns));
        int num2 = cardIndex % gridColumns;
        float num3 = startPos.x + (float)num2 * (3f + gridSpacing.x);
        float num4 = startPos.y - (float)num * (4.5f + gridSpacing.y);
        return new Vector2(num3, num4);
    }

    public IEnumerator CreateCard(CardData cardData, Vector2 pos)
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        Card card = CardManager.Get(cardData.Clone(), cardController, null, inPlay: false, isPlayerCard: true);
        card.entity.returnToPool = false;
        yield return card.UpdateData();
        card.entity.transform.localPosition = Vector2Ext.WithZ(pos, 0f);
        cardHolder.Add(card.entity);
    }

    public void OnDestroy()
    {
        if (GameManager.Ready)
        {
            Save();
        }
    }

    public void Update()
    {
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        if (inspecting)
        {
            return;
        }
        if (Input.GetKeyDown((KeyCode)100) && Input.GetKey((KeyCode)306))
        {
            Entity hover = GetHover();
            if ((hover))
            {
                cardController.UnHover();
                new Routine(CreateCard(hover.data, (hover.transform.localPosition + new Vector3(0.25f, -0.25f))));
                Debug.Log(("Duplicating [" + (hover).name + "]"));
            }
            else
            {
                Debug.Log("Nothing to duplicate!");
            }
        }
        if (!Input.GetKeyDown((KeyCode)127))
        {
            return;
        }
        Entity target = GetHover();
        if ((target))
        {
            if (((Component)cardHolder).GetComponentsInChildren<Entity>(true).Count((Entity a) => (a.data).name == (target.data).name) > 1)
            {
                Debug.Log(("Deleting [" + (target).name + "]"));
                cardController.UnHover();
                Object.Destroy(((Component)target).gameObject);
            }
            else
            {
                Debug.Log(("Cannot delete [" + (target).name + "]"));
                target.wobbler?.WobbleRandom();
            }
        }
        else
        {
            Debug.Log("Nothing to delete!");
        }
    }

    public Entity GetHover()
    {
        return cardController.dragging ?? cardController.hoverEntity;
    }

    public void Save()
    {
        Debug.Log($"[{this}] SAVING DATA");
        string contents = JsonUtility.ToJson((object)new Data(((Component)cardHolder).GetComponentsInChildren<Entity>(true)));
        File.WriteAllText(filePath, contents);
        Debug.Log("Done!");
    }

    public IEnumerator Load()
    {
        Debug.Log($"[{this}] LOADING DATA");
        if (File.Exists(filePath))
        {
            Data data = JsonUtility.FromJson<Data>(File.ReadAllText(filePath));
            Routine.Clump clump = new Routine.Clump();
            Data.Card[] cards = data.cards;
            foreach (Data.Card card in cards)
            {
                if (AddressableLoader.TryGet<CardData>("CardData", card.cardDataName, out var result))
                {
                    clump.Add(CreateCard(result, new Vector2(card.posX, card.posY)));
                }
            }
            yield return clump.WaitForEnd();
        }
        else
        {
            Debug.Log(("[" + filePath + "] does not exist..."));
        }
    }
}
public class CardViewer : MonoBehaviour
{
    [SerializeField]
    public Transform cardHolder;

    [SerializeField]
    public CardData startingData;

    [SerializeField]
    public InspectSystem inspectSystem;

    public int current;

    public List<CardData> cards;

    public void Start()
    {
        cards = (from a in AddressableLoader.GetGroup<CardData>("CardData")
                 where (a.cardType).name != "Leader" && (a.cardType).name != "Boss" && (a.mainSprite).name != "Nothing"
                 select a).ToList();
        Set(startingData);
    }

    public void Update()
    {
        if (Input.GetKeyDown((KeyCode)276))
        {
            Set(-1);
        }
        else if (Input.GetKeyDown((KeyCode)275))
        {
            Set(1);
        }
    }

    public void Set(CardData data)
    {
        current = cards.IndexOf(data);
        StopAllCoroutines();
        StartCoroutine(SetRoutine(data));
    }

    public IEnumerator SetRoutine(CardData data)
    {
        TransformExt.DestroyAllChildren(cardHolder);
        Card card = CardManager.Get(data, null, null, inPlay: false, isPlayerCard: false);
        card.entity.returnToPool = false;
        yield return card.UpdateData();
        card.transform.SetParent(cardHolder);
        card.imageIdleAnimator.FadeIn();
        card.imageIdleAnimator.SetSpeed(1f, 2f / (float)Math.PI, 0f);
        card.backgroundIdleAnimator.FadeIn();
        card.backgroundIdleAnimator.SetSpeed(1f, 2f / (float)Math.PI, 0f);
        Transform transform = card.transform;
        transform.localPosition = Vector3.zero;
        transform.localEulerAngles = Vector3.zero;
        transform.localScale = Vector3.one;
        if ((inspectSystem))
        {
            Events.InvokeEntityHover(card.entity);
            inspectSystem.ClearPopups();
            inspectSystem.inspect = card.entity;
            inspectSystem.CreatePopups();
        }
    }

    public void Set(int change)
    {
        int num = (current + change) % cards.Count;
        if (num < 0)
        {
            num += cards.Count;
        }
        Set(cards[num]);
    }
}
public class CardCharmDragHandler : MonoBehaviour
{
    [SerializeField]
    public bool canDragMidBattle = true;

    [SerializeField]
    public EventReference denySfxEvent;

    [SerializeField]
    public CardContainer[] assignmentContainers;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public UpgradeHolder dragHolder;

    [SerializeField]
    public UnityEvent onAssign;

    [SerializeField]
    public AssignCharmSequence assignSequence;

    [SerializeField]
    public bool instantAssign = true;

    public UpgradeDisplay dragging;

    public UpgradeHolder preHolder;

    public int preIndex;

    public Entity hoverEntity;

    public List<Entity> eligibleCards;

    public List<Entity> ineligibleCards;

    public readonly Routine.Clump flipClump = new Routine.Clump();

    public bool IsDragging { get; set; }

    public void OnEnable()
    {
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
        StopAllCoroutines();
    }

    public void LateUpdate()
    {
        if (IsDragging)
        {
            UpdatePosition();
            if (InputSystem.IsButtonPressed("Back"))
            {
                CancelDrag();
            }
        }
    }

    public void UpdatePosition()
    {
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            transform.position = Cursor3d.Position;
            return;
        }
        UINavigationItem currentNavigationItem = MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem;
        if (currentNavigationItem != null)
        {
            transform.position = Vector3Ext.WithZ(currentNavigationItem.Position, Cursor3d.Position.z);
        }
    }

    public void Drag(UpgradeDisplay upgrade)
    {
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        if (!canDragMidBattle && (References.Battle) && !References.Battle.ended)
        {
            SfxSystem.OneShot(denySfxEvent);
            return;
        }
        TouchInputModule.BlockScroll();
        preHolder = ((Component)upgrade).GetComponentInParent<UpgradeHolder>();
        if ((preHolder))
        {
            preIndex = preHolder.IndexOf(upgrade);
            preHolder.Remove(upgrade);
            preHolder.SetPositions();
        }
        dragHolder.Add(upgrade);
        dragHolder.SetPositions();
        UpdatePosition();
        Events.InvokeUpgradePickup(upgrade);
        dragging = upgrade;
        IsDragging = true;
        if (eligibleCards == null)
        {
            eligibleCards = new List<Entity>();
        }
        if (ineligibleCards == null)
        {
            ineligibleCards = new List<Entity>();
        }
        CardContainer[] array = assignmentContainers;
        for (int i = 0; i < array.Length; i++)
        {
            foreach (Entity item in array[i])
            {
                if (dragging.data.CanAssign(item))
                {
                    eligibleCards.Add(item);
                    item.flipper.FlipUp();
                }
                else
                {
                    ineligibleCards.Add(item);
                    item.flipper.flipped = true;
                }
            }
        }
        StopAllCoroutines();
        StartCoroutine(FlipCardsDown(ineligibleCards));
        NavigationState.Start(new NavigationStateAssignUpgrade(eligibleCards));
        cardController.canPress = false;
    }

    public void Release(UpgradeDisplay upgrade)
    {
        if (dragging != upgrade)
        {
            return;
        }
        if ((hoverEntity) && eligibleCards != null && eligibleCards.Contains(hoverEntity))
        {
            dragHolder.Remove(dragging);
            new Routine(Assign(dragging, hoverEntity));
            return;
        }
        if ((preHolder))
        {
            ReturnToHolder();
        }
        DragEnd();
    }

    public void DragEnd()
    {
        TouchInputModule.UnblockScroll();
        dragging = null;
        IsDragging = false;
        StopAllCoroutines();
        StartCoroutine(FlipCardsUp(ineligibleCards.ToArray()));
        eligibleCards = null;
        ineligibleCards = null;
        NavigationState.BackToPreviousState();
        cardController.canPress = true;
    }

    public void ReturnToHolder()
    {
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        dragHolder.Remove(dragging);
        preHolder.Insert((preIndex >= 0) ? preIndex : 0, dragging);
        ((Component)dragging).transform.localPosition = Vector3.zero;
        preHolder.SetPositions();
        Events.InvokeUpgradeDrop(dragging);
    }

    public void CancelDrag()
    {
        if (IsDragging)
        {
            CardCharmInteraction component = ((Component)dragging).GetComponent<CardCharmInteraction>();
            if (component != null)
            {
                component.CancelDrag();
                ReturnToHolder();
                DragEnd();
            }
        }
    }

    public IEnumerator FlipCardsDown(IEnumerable<Entity> cards)
    {
        flipClump.Clear();
        foreach (Entity card in cards)
        {
            flipClump.Add(FlipDown(card, PettyRandom.Range(0f, 0.2f)));
        }
        yield return flipClump.WaitForEnd();
    }

    public static IEnumerator FlipDown(Entity card, float delay)
    {
        yield return (object)new WaitForSeconds(delay);
        card.flipper.FlipDown(force: true);
    }

    public IEnumerator FlipCardsUp(IEnumerable<Entity> cards)
    {
        flipClump.Clear();
        foreach (Entity card in cards)
        {
            flipClump.Add(FlipUp(card, PettyRandom.Range(0f, 0.2f)));
        }
        yield return flipClump.WaitForEnd();
    }

    public static IEnumerator FlipUp(Entity card, float delay)
    {
        yield return (object)new WaitForSeconds(delay);
        card.flipper.FlipUp();
    }

    public IEnumerator Assign(UpgradeDisplay upgrade, Entity entity)
    {
        cardController.Disable();
        NavigationState.Start(new NavigationStateWait(disableInput: true));
        CardUpgradeData upgradeData = upgrade.data;
        GameObjectExt.Destroy(((Component)upgrade).gameObject);
        if (instantAssign || upgradeData.type != CardUpgradeData.Type.Charm)
        {
            yield return upgradeData.Assign(entity);
        }
        else
        {
            assignSequence.Assign(entity, upgradeData);
            yield return assignSequence.Run();
        }
        cardController.Enable();
        NavigationState.BackToPreviousState();
        DragEnd();
        if ((cardController.owner))
        {
            cardController.owner.data.inventory.upgrades.Remove(upgradeData);
        }
        UnityEvent obj = onAssign;
        if (obj != null)
        {
            obj.Invoke();
        }
    }

    public void EntityHover(Entity entity)
    {
        if (eligibleCards != null && eligibleCards.Contains(entity))
        {
            hoverEntity = entity;
        }
    }

    public void EntityUnHover(Entity entity)
    {
        if (hoverEntity == entity)
        {
            hoverEntity = null;
        }
    }
}
[RequireComponent(typeof(UpgradeDisplay))]
public class CardCharmInteraction : MonoBehaviourRect, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
    [SerializeField]
    public GameObject image;

    public CardCharmDragHandler dragHandler;

    public bool canHover;

    public bool canDrag;

    public bool hover;

    public bool preHover;

    public bool press;

    public bool drag;

    public Vector2 popUpOffset = new Vector2(0f, -1f);

    public UnityEvent<UpgradeDisplay> onHover;

    public UnityEvent<UpgradeDisplay> onUnHover;

    public UnityEvent<UpgradeDisplay> onDrag;

    public UnityEvent<UpgradeDisplay> onDragEnd;

    public UpgradeDisplay _upgradeDisplay;

    public UpgradeDisplay upgradeDisplay => _upgradeDisplay ?? (_upgradeDisplay = GetComponent<UpgradeDisplay>());

    public bool DragHandlerDragging
    {
        get
        {
            if ((dragHandler))
            {
                return dragHandler.IsDragging;
            }
            return false;
        }
    }

    public void LateUpdate()
    {
        if (!press)
        {
            if (hover && InputSystem.IsSelectPressed())
            {
                press = true;
                if (preHover)
                {
                    Press();
                }
            }
        }
        else if (MonoBehaviourSingleton<Cursor3d>.instance.usingTouch ? InputSystem.IsSelectReleased() : InputSystem.IsDynamicSelectReleased(drag))
        {
            Release();
            press = false;
            if (MonoBehaviourSingleton<Cursor3d>.instance.usingTouch)
            {
                StartCoroutine(UpdateInputSystem());
            }
        }
        preHover = hover;
    }

    public IEnumerator UpdateInputSystem()
    {
        yield return null;
        if (upgradeDisplay is CardCharm cardCharm)
        {
            cardCharm.StopWobble();
        }
        yield return null;
        Events.InvokeUpdateInputSystem(forceTouch: true);
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        Hover();
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        if (hover && press && !drag && MonoBehaviourSingleton<Cursor3d>.instance.usingTouch && (dragHandler))
        {
            StartDrag();
        }
        else
        {
            UnHover();
        }
    }

    public void Press()
    {
        if (canDrag && hover)
        {
            StartDrag();
        }
    }

    public void Release()
    {
        if (drag)
        {
            StopDrag();
        }
    }

    public void Hover()
    {
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        if (canHover && !drag && !DragHandlerDragging)
        {
            if (!hover)
            {
                LeanTween.cancel(image);
                LeanTween.scale(image, Vector3.one * 1.1f, 0.33f).setEase(LeanTweenType.easeOutBack);
            }
            hover = true;
            onHover?.Invoke(upgradeDisplay);
            Events.InvokeUpgradeHover(upgradeDisplay);
            PopUpDescription();
        }
    }

    public void UnHover()
    {
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        if (canHover && hover)
        {
            LeanTween.cancel(image);
            LeanTween.scale(image, Vector3.one, 0.2f).setEase(LeanTweenType.easeOutQuart);
            hover = false;
            onUnHover?.Invoke(upgradeDisplay);
            HideDescription();
        }
    }

    public void StartDrag()
    {
        Debug.Log(("Dragging Card Charm [" + name + "]"));
        drag = true;
        onDrag?.Invoke(upgradeDisplay);
        UnHover();
        upgradeDisplay.CanRaycast = false;
    }

    public void StopDrag()
    {
        Debug.Log(("Dropping Card Charm [" + name + "]"));
        onDragEnd?.Invoke(upgradeDisplay);
        drag = false;
        upgradeDisplay.CanRaycast = true;
    }

    public void CancelDrag()
    {
        Debug.Log(("Cancelling Card Charm Drag [" + name + "]"));
        drag = false;
        upgradeDisplay.CanRaycast = true;
    }

    public void PopUpDescription()
    {
        CardPopUp.AssignTo(base.rectTransform, popUpOffset.x, popUpOffset.y);
        CardPopUp.AddPanel((upgradeDisplay.data).name, upgradeDisplay.data.title, upgradeDisplay.data.text);
    }

    public void HideDescription()
    {
        CardPopUp.RemovePanel((upgradeDisplay.data).name);
    }
}
public class CardDeactivator : MonoBehaviour
{
    public readonly List<GameObject> entities = new List<GameObject>();

    public readonly List<GameObject> toDisable = new List<GameObject>();

    public Camera _cam;

    public Camera cam => _cam ?? (_cam = Camera.main);

    public void OnEnable()
    {
        Events.OnEntityCreated += EntityCreated;
        Events.OnEntityDestroyed += EntityDestroyed;
    }

    public void OnDisable()
    {
        Events.OnEntityCreated -= EntityCreated;
        Events.OnEntityDestroyed -= EntityDestroyed;
    }

    public void EntityCreated(Entity entity)
    {
        entities.Add(((Component)entity).gameObject);
    }

    public void EntityDestroyed(Entity entity)
    {
        entities.Remove(((Component)entity).gameObject);
    }

    public void LateUpdate()
    {
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        if (Transition.Running)
        {
            return;
        }
        foreach (GameObject entity in entities)
        {
            bool inView = cam.IsInCameraView(entity.transform.position, 0.1f);
            SetActiveness(entity.gameObject, inView);
        }
        for (int num = Mathf.CeilToInt((float)toDisable.Count * 0.1f) - 1; num >= 0; num--)
        {
            GameObject obj = toDisable[num];
            toDisable.RemoveAt(num);
            obj.gameObject.SetActive(false);
        }
    }

    public void SetActiveness(GameObject obj, bool inView)
    {
        if (inView)
        {
            if (!obj.activeSelf || toDisable.Contains(obj))
            {
                obj.SetActive(true);
                toDisable.Remove(obj);
            }
        }
        else if (obj.activeSelf && !toDisable.Contains(obj))
        {
            toDisable.Add(obj);
        }
    }
}
public class CardDestroyed : FlyOffScreen, ICardDestroyed, IRemoveWhenPooled
{
    public AngleWobbler[] wobblers;

    public override void Begin()
    {
        wobblers = GetComponentsInChildren<AngleWobbler>();
        AngleWobbler[] array = wobblers;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].globalSpace = false;
        }
    }

    public override void End()
    {
        Final();
    }

    public void Final()
    {
        Object.Destroy(this);
        CardManager.ReturnToPool(gameObject.GetComponent<Card>());
    }

    public void OnDisable()
    {
        AngleWobbler[] array = wobblers;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].globalSpace = true;
        }
        wobblers = null;
    }
}
public class CardDestroyedConsume : MonoBehaviour, ICardDestroyed, IRemoveWhenPooled
{
    public string sortingLayer = "Default";

    public int sortingOrder = 10;

    public IEnumerator Start()
    {
        Entity entity = GetComponent<Entity>();
        AsyncOperationHandle<GameObject> handle = AddressableLoader.InstantiateAsync("CardBreakFX", entity.offset.position, Quaternion.identity, transform);
        SfxSystem.OneShot("event:/sfx/card/consume");
        yield return handle;
        LeanTween.scale(gameObject, Vector3.one * 0.6f, 0.25f).setEase(LeanTweenType.easeInBack);
        yield return (object)new WaitForSeconds(0.25f);
        LeanTween.scale(gameObject, Vector3.one * 1.2f, 0.25f).setEase(LeanTweenType.easeInBack);
        yield return (object)new WaitForSeconds(0.15f);
        ParticleSystem ps = handle.Result.GetComponent<ParticleSystem>();
        if (ps != null)
        {
            ps.Play();
            if (entity.display is Card { canvasGroup: { } canvasGroup })
            {
                LeanTween.alphaCanvas(canvasGroup, 0f, 0.1f);
            }
            ParticleSystemRenderer[] componentsInChildren = ((Component)ps).GetComponentsInChildren<ParticleSystemRenderer>();
            foreach (ParticleSystemRenderer obj in componentsInChildren)
            {
                ((Renderer)obj).sortingLayerName = sortingLayer;
                ((Renderer)obj).sortingOrder = sortingOrder;
            }
            yield return (object)new WaitUntil((Func<bool>)(() => !(ps) || !ps.isPlaying));
        }
        Final();
    }

    public void Final()
    {
        Object.Destroy(this);
        CardManager.ReturnToPool(gameObject.GetComponent<Card>());
    }
}
public class CardDestroyedSacrifice : MonoBehaviour, ICardDestroyed, IRemoveWhenPooled
{
    public float dur = 0.5f;

    public const LeanTweenType ease = LeanTweenType.easeInBack;

    public Entity entity;

    public void Start()
    {
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        entity = GetComponent<Entity>();
        entity.wobbler.WobbleRandom();
        Events.InvokeCameraAnimation("Droop");
        Events.InvokeScreenRumble(0f, 0.25f, 0f, 0.25f * dur, 0.5f * dur, 0.25f * dur);
        LeanTween.scale(gameObject, new Vector3(0.25f, 0.25f, 1f), dur).setEase(LeanTweenType.easeInBack).setOnComplete(Final);
        LeanTween.rotateY(gameObject, IntExt.WithRandomSign(90, 0.5f), dur).setEase(LeanTweenType.easeInBack);
        if (entity.display is Card { canvasGroup: { } canvasGroup })
        {
            LeanTween.alphaCanvas(canvasGroup, 0f, dur).setEase(LeanTweenType.easeInBack);
        }
    }

    public void Final()
    {
        Object.Destroy(this);
        CardManager.ReturnToPool(entity);
    }
}
public class CardDisplay : MonoBehaviour
{
    [SerializeField]
    public CardData data;

    public Card _card;

    public Card card => _card ?? (_card = GetComponent<Card>());

    public void Awake()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        transform.localScale = Vector3.zero;
    }

    public IEnumerator Start()
    {
        card.entity.data = data;
        yield return card.UpdateData();
        LeanTween.scale(gameObject, Vector3.one, 0.3f).setEaseOutBack();
    }
}
public class CardFrameSetter : MonoBehaviour
{
    [SerializeField]
    public AddressableTieredSpriteLoader[] spriteSetters;

    public bool loaded;

    public void Load(int frameLevel)
    {
        if (!loaded)
        {
            AddressableTieredSpriteLoader[] array = spriteSetters;
            for (int i = 0; i < array.Length; i++)
            {
                array[i].Load(frameLevel);
            }
            loaded = true;
        }
    }
}
public class CardHover : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerAfterExitHandler
{
    [SerializeField]
    public bool IsMaster = true;

    [HideIf("IsMaster")]
    public CardHover master;

    [SerializeField]
    [ShowIf("IsMaster")]
    public GraphicRaycaster graphicRaycaster;

    [SerializeField]
    [ShowIf("IsMaster")]
    public Entity entity;

    [SerializeField]
    [ShowIf("IsMaster")]
    public bool disableWhileDragging = true;

    [SerializeField]
    [ShowIf("IsMaster")]
    public Flipper flipper;

    public UnityEvent onHover;

    public UnityEvent onUnHover;

    [Header("Pop up \"Keyword\" description(s) while mouse over")]
    [SerializeField]
    public CardPopUpTarget pop;

    [Header("Mouse Over This Element?")]
    [SerializeField]
    [ReadOnly]
    public bool mouseOver;

    [SerializeField]
    [ReadOnly]
    public int childMouseOverCount;

    public bool preMouseOver;

    [Header("Entity assigned as \"Hovering\"? (set by CardControllers)")]
    [ReadOnly]
    public bool hovering;

    [ShowIf("IsMaster")]
    public CardController controller;

    public bool hoverable = true;

    public bool dragging;

    public bool hasPop;

    public bool IsHovering
    {
        get
        {
            if (!IsMaster)
            {
                return master.hovering;
            }
            return hovering;
        }
    }

    public bool IsHoverable
    {
        get
        {
            if (!IsMaster)
            {
                return master.hoverable;
            }
            return hoverable;
        }
    }

    public bool IsMouseOver
    {
        get
        {
            if (!mouseOver)
            {
                return childMouseOverCount > 0;
            }
            return true;
        }
    }

    public bool CanHover
    {
        get
        {
            if (enabled && (controller) && ((Behaviour)controller).enabled && !flipper.flipped)
            {
                return IsHoverable;
            }
            return false;
        }
    }

    public bool WasHovering { get; set; }

    public void Awake()
    {
        hasPop = (pop);
    }

    public void OnEnable()
    {
        hoverable = true;
        hovering = false;
        mouseOver = false;
        if (IsMaster)
        {
            ((Behaviour)graphicRaycaster).enabled = true;
        }
        Events.OnUpdateInputSystem += UpdateInputSystem;
        Events.OnCardControllerEnabled += CardControllerEnabled;
    }

    public void OnDisable()
    {
        if (mouseOver && !IsMaster)
        {
            mouseOver = false;
            master.childMouseOverCount = Mathf.Max(0, master.childMouseOverCount - 1);
        }
        if (hasPop && (pop) && pop.popped)
        {
            pop.UnPop();
        }
        Events.OnUpdateInputSystem -= UpdateInputSystem;
        Events.OnCardControllerEnabled -= CardControllerEnabled;
    }

    public void Update()
    {
        if (!hasPop || (mouseOver && IsHovering))
        {
            return;
        }
        if ((pop))
        {
            if (pop.popped)
            {
                pop.UnPop();
            }
        }
        else
        {
            hasPop = false;
        }
    }

    public void LateUpdate()
    {
        WasHovering = IsHovering;
        if (IsMaster)
        {
            bool isMouseOver = IsMouseOver;
            if (isMouseOver && !preMouseOver)
            {
                Hover();
            }
            else if (!isMouseOver && preMouseOver)
            {
                UnHover();
            }
            preMouseOver = isMouseOver;
        }
        if (mouseOver && IsHovering && hasPop)
        {
            if ((pop))
            {
                if (!pop.popped)
                {
                    pop.Pop();
                }
            }
            else
            {
                hasPop = false;
            }
        }
        if (IsMaster && disableWhileDragging && entity.dragging != dragging)
        {
            dragging = entity.dragging;
            if (dragging)
            {
                Disable();
            }
            else
            {
                Enable();
            }
        }
    }

    public void UpdateInputSystem(bool forceTouch)
    {
        if (IsMaster && IsMouseOver)
        {
            preMouseOver = false;
        }
    }

    public void CardControllerEnabled(CardController controller)
    {
        if (mouseOver && controller == this.controller)
        {
            controller.Hover(IsMaster ? entity : master.entity);
        }
    }

    public void CheckHover()
    {
        if (IsMouseOver && !preMouseOver)
        {
            Hover();
            preMouseOver = true;
        }
    }

    public void CheckUnHover()
    {
        if (!IsMouseOver && preMouseOver)
        {
            UnHover();
            preMouseOver = false;
        }
    }

    public void Enable()
    {
        ((Behaviour)graphicRaycaster).enabled = true;
        Events.InvokeUpdateInputSystem(forceTouch: false);
    }

    public void Disable()
    {
        ((Behaviour)graphicRaycaster).enabled = false;
        ForceUnHover();
        Events.InvokeUpdateInputSystem(forceTouch: false);
    }

    public void SetHoverable(bool value)
    {
        hoverable = value;
        if (!hoverable)
        {
            ForceUnHover();
        }
    }

    public void Hover()
    {
        if (CanHover)
        {
            controller.Hover(entity);
            UnityEvent obj = onHover;
            if (obj != null)
            {
                obj.Invoke();
            }
        }
    }

    public void UnHover()
    {
        if (enabled && (controller) && ((Behaviour)controller).enabled && controller.hoverEntity == entity)
        {
            controller.UnHover(entity);
            UnityEvent obj = onUnHover;
            if (obj != null)
            {
                obj.Invoke();
            }
        }
    }

    public void ForceUnHover()
    {
        mouseOver = false;
        preMouseOver = false;
        UnHover();
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        if (!mouseOver && hoverable && (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse || !(UINavigationSystem.ActiveNavigationLayer) || UINavigationSystem.ActiveNavigationLayer.forceHover))
        {
            mouseOver = true;
            if (IsMaster)
            {
                CheckHover();
                return;
            }
            master.childMouseOverCount++;
            master.CheckHover();
        }
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        if (mouseOver)
        {
            mouseOver = false;
            if (!IsMaster)
            {
                master.childMouseOverCount = Mathf.Max(0, master.childMouseOverCount - 1);
            }
        }
    }

    public void OnPointerAfterExit(PointerEventData eventData)
    {
        if (IsMaster)
        {
            CheckUnHover();
        }
        else
        {
            master.CheckUnHover();
        }
    }
}
public class CardIdleAnimation : MonoBehaviourCacheTransform, IPoolable
{
    public enum Action
    {
        None,
        FadeIn,
        FadeOut
    }

    public CardAnimationProfile profile;

    public Entity _entity;

    public bool alwaysOn;

    public float strength = 1f;

    public float speedFactor = 1f;

    public float fadeInTime = 0.4f;

    public float fadeInStrength = 1f;

    public float speed;

    public float offset;

    public Vector3 basePosition;

    public Vector3 baseRotation;

    public Vector3 baseScale;

    [SerializeField]
    public CardAnimationProfile setProfile;

    [SerializeField]
    public CardIdleAnimation.Action currentAction;

    public Entity entity
    {
        get
        {
            return _entity;
        }
        set
        {
            _entity = value;
            SetProfile(_entity.data.idleAnimationProfile);
        }
    }

    public void Awake()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        basePosition = base.transform.localPosition;
        baseRotation = base.transform.localEulerAngles;
        baseScale = base.transform.localScale;
        speed = 1f / PettyRandom.Range(2f, 3f);
    }

    public void OnEnable()
    {
        if (alwaysOn)
        {
            StartAction(Action.FadeIn);
        }
    }

    public void OnDisable()
    {
        if (!alwaysOn)
        {
            fadeInStrength = 0f;
            enabled = false;
            currentAction = Action.None;
        }
    }

    public void Update()
    {
        //IL_0167: Unknown result type (might be due to invalid IL or missing references)
        //IL_029d: Unknown result type (might be due to invalid IL or missing references)
        //IL_03d3: Unknown result type (might be due to invalid IL or missing references)
        if ((profile) && strength != 0f)
        {
            float num = (Time.timeSinceLevelLoad * speed * speedFactor + offset) % 1f;
            if (profile.doMoveX || profile.doMoveY || profile.doMoveZ)
            {
                float num2 = (profile.doMoveX ? (profile.moveX.Evaluate(num) * profile.moveAmount.x * strength * fadeInStrength) : 0f);
                float num3 = (profile.doMoveY ? (profile.moveY.Evaluate(num) * profile.moveAmount.y * strength * fadeInStrength) : 0f);
                float num4 = (profile.doMoveZ ? (profile.moveZ.Evaluate(num) * profile.moveAmount.z * strength * fadeInStrength) : 0f);
                base.transform.localPosition = new Vector3(basePosition.x + num2, basePosition.y + num3, basePosition.z + num4);
            }
            if (profile.doRotateX || profile.doRotateY || profile.doRotateZ)
            {
                float num5 = (profile.doRotateX ? (profile.rotateX.Evaluate(num) * profile.rotateAmount.x * strength * fadeInStrength) : 0f);
                float num6 = (profile.doRotateY ? (profile.rotateY.Evaluate(num) * profile.rotateAmount.y * strength * fadeInStrength) : 0f);
                float num7 = (profile.doRotateZ ? (profile.rotateZ.Evaluate(num) * profile.rotateAmount.z * strength * fadeInStrength) : 0f);
                base.transform.localEulerAngles = new Vector3(baseRotation.x + num5, baseRotation.y + num6, baseRotation.z + num7);
            }
            if (profile.doScaleX || profile.doScaleY || profile.doScaleZ)
            {
                float num8 = (profile.doScaleX ? (profile.ScaleX.Evaluate(num) * profile.scaleAmount.x * strength * fadeInStrength) : 0f);
                float num9 = (profile.doScaleY ? (profile.ScaleY.Evaluate(num) * profile.scaleAmount.y * strength * fadeInStrength) : 0f);
                float num10 = (profile.doScaleZ ? (profile.ScaleZ.Evaluate(num) * profile.scaleAmount.z * strength * fadeInStrength) : 0f);
                base.transform.localScale = new Vector3(baseScale.x + num8, baseScale.y + num9, baseScale.z + num10);
            }
        }
        if ((setProfile))
        {
            SetProfile(setProfile);
            setProfile = null;
        }
        if (currentAction != 0)
        {
            RunAction();
        }
    }

    public void SetSpeed(float speed, float speedFactor, float offset)
    {
        this.speed = speed;
        this.speedFactor = speedFactor;
        this.offset = offset;
    }

    public void SetProfile(CardAnimationProfile profile)
    {
        this.profile = profile;
        float num = ((_entity) ? (1f / (2f + Mathf.Abs(_entity.random3.x))) : 0.5f);
        speed = num * profile.speedFactor;
        offset = ((_entity) ? Mathf.Abs(_entity.random3.y) : 0f);
    }

    public void StartAction(CardIdleAnimation.Action action)
    {
        currentAction = action;
        switch (action)
        {
            case Action.FadeIn:
                enabled = true;
                fadeInStrength = 0f;
                break;
            case Action.FadeOut:
                if (!gameObject.activeInHierarchy)
                {
                    enabled = false;
                    fadeInStrength = 0f;
                    StartAction(Action.None);
                }
                break;
        }
    }

    public void RunAction()
    {
        switch (currentAction)
        {
            case Action.FadeIn:
                if (fadeInStrength < 1f)
                {
                    fadeInStrength += 1f / fadeInTime * Time.deltaTime;
                    break;
                }
                fadeInStrength = 1f;
                StartAction(Action.None);
                break;
            case Action.FadeOut:
                if (fadeInStrength > 0f)
                {
                    fadeInStrength -= 1f / fadeInTime * Time.deltaTime;
                    break;
                }
            enabled = false;
                fadeInStrength = 0f;
                StartAction(Action.None);
                break;
        }
    }

    public void FadeIn()
    {
        StartAction(Action.FadeIn);
    }

    public void FadeOut()
    {
        StartAction(Action.FadeOut);
    }

    public void Clear()
    {
        fadeInStrength = 0f;
        currentAction = Action.None;
    }

    public void OnGetFromPool()
    {
    }

    public void OnReturnToPool()
    {
        Clear();
    }
}
public class CardInspector : MonoBehaviour
{
    [SerializeField]
    public bool animatePopUps = true;

    [SerializeField]
    public bool ignoreTimeScale;

    [SerializeField]
    public bool showHiddenKeywords = true;

    [SerializeField]
    [ShowIf("showHiddenKeywords")]
    public KeywordData injuredKeyword;

    [Header("Pop up panels")]
    [SerializeField]
    public RectTransform leftPopGroup;

    [SerializeField]
    public RectTransform leftOverflowPopGroup;

    [SerializeField]
    public RectTransform rightPopGroup;

    [SerializeField]
    public RectTransform rightOverflowPopGroup;

    [SerializeField]
    public RectTransform bottomPopGroup;

    [SerializeField]
    public RectTransform[] overflowOrder;

    [SerializeField]
    public CardPopUpPanel popUpPrefab;

    [SerializeField]
    public CardTooltip cardTooltipPrefab;

    [SerializeField]
    public LayoutGroup[] layoutsToFix;

    public readonly List<Tooltip> popups = new List<Tooltip>();

    public readonly List<KeywordData> currentPoppedKeywords = new List<KeywordData>();

    public void CreatePopups(Entity inspect)
    {
        Events.InvokeEntityHover(inspect);
        CreateIconPopups(inspect.display.healthLayoutGroup, (Transform)(object)leftPopGroup);
        CreateIconPopups(inspect.display.damageLayoutGroup, (Transform)(object)rightPopGroup);
        CreateIconPopups(inspect.display.counterLayoutGroup, (Transform)(object)bottomPopGroup);
        if (inspect.display is Card card)
        {
            foreach (CardData mentionedCard in card.mentionedCards)
            {
                Popup(mentionedCard, (Transform)(object)rightPopGroup);
            }
            foreach (KeywordData keyword in card.keywords)
            {
                Popup(keyword, (Transform)(object)rightPopGroup);
            }
        }
        if (showHiddenKeywords)
        {
            foreach (KeywordData hiddenKeyword in inspect.GetHiddenKeywords())
            {
                Popup(hiddenKeyword, (Transform)(object)rightPopGroup);
            }
            List<CardData.StatusEffectStacks> injuries = inspect.data.injuries;
            if (injuries != null && injuries.Count > 0)
            {
                Popup(injuredKeyword, (Transform)(object)rightPopGroup);
            }
        }
        CoroutineManager.Start(FixLayoutsAfterFrame());
    }

    public void CreateIconPopups(RectTransform iconLayoutGroup, Transform popGroup)
    {
        CardPopUpTarget[] componentsInChildren = ((Component)iconLayoutGroup).GetComponentsInChildren<CardPopUpTarget>();
        for (int i = 0; i < componentsInChildren.Length; i++)
        {
            KeywordData[] keywords = componentsInChildren[i].keywords;
            foreach (KeywordData keyword in keywords)
            {
                Popup(keyword, popGroup);
            }
        }
    }

    public void ClearPopups()
    {
        foreach (Tooltip popup in popups)
        {
            GameObjectExt.Destroy(((Component)popup).gameObject);
        }
        popups.Clear();
        currentPoppedKeywords.Clear();
    }

    public IEnumerator FixLayoutsAfterFrame()
    {
        yield return null;
        yield return FixLayouts();
    }

    public IEnumerator FixLayouts()
    {
        yield return null;
        LayoutGroup[] array = layoutsToFix;
        foreach (LayoutGroup val in array)
        {
            VerticalLayoutGroup val2 = (VerticalLayoutGroup)(object)((val is VerticalLayoutGroup) ? val : null);
            if (val2 == null)
            {
                HorizontalLayoutGroup val3 = (HorizontalLayoutGroup)(object)((val is HorizontalLayoutGroup) ? val : null);
                if (val3 != null)
                {
                    HorizontalLayoutGroupExt.FitToChildren(val3);
                }
            }
            else
            {
                VerticalLayoutGroupExt.FitToChildren(val2);
            }
        }
        if (CheckOverflow(bottomPopGroup))
        {
            yield return FixLayouts();
        }
    }

    public bool CheckOverflow(params RectTransform[] checkCollide)
    {
        for (int i = 0; i < overflowOrder.Length - 1; i++)
        {
            RectTransform val = overflowOrder[i];
            if (((Transform)val).childCount > 0 && CheckCollide(val, checkCollide))
            {
                Transform child = ((Transform)val).GetChild(((Transform)val).childCount - 1);
                RectTransform parent = overflowOrder[i + 1];
                child.SetParent((Transform)(object)parent);
                child.SetSiblingIndex(0);
                return true;
            }
        }
        return false;
    }

    public static bool CheckCollide(RectTransform target, IEnumerable<RectTransform> checks)
    {
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        foreach (RectTransform check in checks)
        {
            if (RectOverlap(target, check))
            {
                Debug.Log($"[{target.rect}] Overlaps [{check.rect}]");
                return true;
            }
        }
        return false;
    }

    public static bool RectOverlap(RectTransform a, RectTransform b)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_006b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Unknown result type (might be due to invalid IL or missing references)
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        //IL_007a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        //IL_0097: Unknown result type (might be due to invalid IL or missing references)
        //IL_009e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00af: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c4: Unknown result type (might be due to invalid IL or missing references)
        Vector3 position = ((Transform)a).position;
        Rect rect = a.rect;
        Vector2 size = ((rect)).size;
        Vector2 pivot = a.pivot;
        float num = position.x - pivot.x * size.x;
        float num2 = position.y - pivot.y * size.y;
        Rect val = default(Rect);
        ((val))..ctor(num, num2, size.x, size.y);
        Vector3 position2 = ((Transform)b).position;
        rect = b.rect;
        Vector2 size2 = ((rect)).size;
        Vector2 pivot2 = b.pivot;
        float num3 = position2.x - pivot2.x * size2.x;
        float num4 = position2.y - pivot2.y * size2.y;
        Rect val2 = default(Rect);
        ((val2))..ctor(num3, num4, size2.x, size2.y);
        return ((val)).Overlaps(val2);
    }

    public CardPopUpPanel Popup(KeywordData keyword, Transform group)
    {
        if (!currentPoppedKeywords.Contains(keyword))
        {
            CardPopUpPanel cardPopUpPanel = Object.Instantiate<CardPopUpPanel>(popUpPrefab, group);
            (((Component)cardPopUpPanel).gameObject).name = (keyword).name;
            cardPopUpPanel.animate = animatePopUps;
            cardPopUpPanel.ignoreTimeScale = ignoreTimeScale;
            cardPopUpPanel.Set(keyword);
            Events.InvokePopupPanelCreated(keyword, cardPopUpPanel);
            currentPoppedKeywords.Add(keyword);
            popups.Add(cardPopUpPanel);
            {
                foreach (KeywordData keyword2 in Text.GetKeywords(keyword.body))
                {
                    CardPopUpPanel cardPopUpPanel2 = Popup(keyword2, group);
                    HashSetExt.AddIfNotNull<Tooltip>(cardPopUpPanel.children, (Tooltip)cardPopUpPanel2);
                }
                return cardPopUpPanel;
            }
        }
        return null;
    }

    public CardTooltip Popup(CardData cardData, Transform group)
    {
        CardTooltip cardTooltip = Object.Instantiate<CardTooltip>(cardTooltipPrefab, group);
        (((Component)cardTooltip).gameObject).name = (cardData).name;
        cardTooltip.animate = animatePopUps;
        cardTooltip.ignoreTimeScale = ignoreTimeScale;
        cardTooltip.Set(cardData);
        popups.Add(cardTooltip);
        foreach (KeywordData keyword in cardTooltip.keywords)
        {
            CardPopUpPanel cardPopUpPanel = Popup(keyword, group);
            HashSetExt.AddIfNotNull<Tooltip>(cardTooltip.children, (Tooltip)cardPopUpPanel);
        }
        return cardTooltip;
    }
}
public class CardManager : MonoBehaviourSingleton<CardManager>
{
    public static readonly Dictionary<string, GameObject> cardIcons = new Dictionary<string, GameObject>();

    public static readonly Vector3 startPos = new Vector3(-99f, -99f, 0f);

    public static readonly Dictionary<string, ObjectPool<Card>> cardPools = new Dictionary<string, ObjectPool<Card>>();

    public static bool init = false;

    public AsyncOperationHandle<IList<GameObject>> cardIconLoadHandle;

    public const float SCALE = 1f;

    public const float HOVER_SCALE = 1f;

    public IEnumerator Start()
    {
        Transform t = transform;
        List<CardType> group = AddressableLoader.GetGroup<CardType>("CardType");
        foreach (CardType cardType in group)
        {
            AsyncOperationHandle<GameObject> handle = Addressables.LoadAssetAsync<GameObject>((object)cardType.prefabRef);
            yield return handle;
            GameObject prefab = handle.Result;
            for (int i = 0; i < 3; i++)
            {
                cardPools.Add($"{(cardType).name}{i}", new ObjectPool<Card>((Func<Card>)(() => Object.Instantiate<GameObject>(prefab, startPos, quaternion.op_Implicit(quaternion.identity), t).GetComponent<Card>()), (System.Action<Card>)delegate (Card card)
                {
                    //IL_0017: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0027: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0037: Unknown result type (might be due to invalid IL or missing references)
                    card.OnGetFromPool();
                    card.entity.OnGetFromPool();
                    card.transform.position = startPos;
                    card.transform.localRotation = Quaternion.identity;
                    card.transform.localScale = Vector3.one;
                    ((Component)card).gameObject.SetActive(true);
                }, (System.Action<Card>)delegate (Card card)
                {
                    card.transform.SetParent(t);
                    card.OnReturnToPool();
                    card.entity.OnReturnToPool();
                    Events.InvokeCardPooled(card);
                    ((Component)card).gameObject.SetActive(false);
                }, (System.Action<Card>)delegate (Card card)
                {
                    Object.Destroy(((Component)card).gameObject);
                }, false, 10, 20));
            }
        }
        LoadCardIcons();
        init = true;
    }

    public void LoadCardIcons()
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        if (cardIconLoadHandle.IsValid())
        {
            Addressables.Release<IList<GameObject>>(cardIconLoadHandle);
        }
        Debug.Log("CardManager Loading Card Icon Prefabs");
        cardIconLoadHandle = Addressables.LoadAssetsAsync<GameObject>((object)"CardIcons", (System.Action<GameObject>)null);
        foreach (GameObject item in cardIconLoadHandle.WaitForCompletion())
        {
            if (item != null)
            {
                StatusIcon component = item.GetComponent<StatusIcon>();
                if (component != null)
                {
                    cardIcons[component.type] = item;
                }
            }
        }
        Debug.Log($"{cardIcons.Count} icons loaded");
    }

    public static Card Get(CardData data, CardController controller, Character owner, bool inPlay, bool isPlayerCard)
    {
        int num = (isPlayerCard ? CardFramesSystem.GetFrameLevel((data).name) : 0);
        Card card = cardPools[$"{(data.cardType).name}{num}"].Get();
        card.frameLevel = num;
        card.entity.data = data;
        card.entity.inPlay = inPlay;
        card.hover.controller = controller;
        card.entity.owner = owner;
        card.frameSetter.Load(num);
        Events.InvokeEntityCreated(card.entity);
        return card;
    }

    public static bool ReturnToPool(Entity entity)
    {
        if (entity.display is Card card)
        {
            return ReturnToPool(entity, card);
        }
        Object.Destroy(((Component)entity).gameObject);
        return false;
    }

    public static bool ReturnToPool(Card card)
    {
        return ReturnToPool(card.entity, card);
    }

    public static bool ReturnToPool(Entity entity, Card card)
    {
        if (GameManager.End || entity.inCardPool)
        {
            return false;
        }
        if (!entity.returnToPool)
        {
            Object.Destroy(((Component)entity).gameObject);
        }
        cardPools[$"{(entity.data.cardType).name}{card.frameLevel}"].Release(card);
        return true;
    }

    public static StatusIcon NewStatusIcon(string type, Transform iconParent)
    {
        StatusIcon result = null;
        if (cardIcons.ContainsKey(type))
        {
            result = Object.Instantiate<GameObject>(cardIcons[type], iconParent).GetComponent<StatusIcon>();
        }
        return result;
    }

    public static void ReturnToPoolNextFrame(Card card)
    {
        ((MonoBehaviour)MonoBehaviourSingleton<CardManager>.instance).StartCoroutine(ReturnToPoolNextFrameRoutine(card));
    }

    public static IEnumerator ReturnToPoolNextFrameRoutine(Card card)
    {
        yield return null;
        ReturnToPool(card);
    }
}
public class CardPoolReturner : MonoBehaviour
{
    [SerializeField]
    public string[] scenesToIgnore;

    public void OnEnable()
    {
        Events.OnSceneUnload += SceneUnload;
    }

    public void OnDisable()
    {
        Events.OnSceneUnload -= SceneUnload;
    }

    public void SceneUnload(Scene scene)
    {
        if (IArrayExt.Contains<string>(scenesToIgnore, ((scene)).name))
        {
            return;
        }
        StopWatch.Start();
        int num = 0;
        GameObject[] rootGameObjects = ((scene)).GetRootGameObjects();
        for (int i = 0; i < rootGameObjects.Length; i++)
        {
            Card[] componentsInChildren = rootGameObjects[i].GetComponentsInChildren<Card>();
            foreach (Card card in componentsInChildren)
            {
                if (card.entity.returnToPool && CardManager.ReturnToPool(card))
                {
                    num++;
                }
            }
        }
        Debug.Log($"[{num}] Cards returned to pool from [{((scene)).name}] ({StopWatch.Stop()}ms)");
    }
}
public class CardPopUp : MonoBehaviourRectSingleton<CardPopUp>
{
    [SerializeField]
    public Canvas canvas;

    [SerializeField]
    public RectTransform bounds;

    [SerializeField]
    public RectTransform boundingBox;

    [SerializeField]
    public RectTransform layout;

    [SerializeField]
    public ContentSizeFitter sizeFitter;

    [SerializeField]
    public float gap = 0.05f;

    [SerializeField]
    [Range(-1f, 1f)]
    public float posX = 1f;

    [SerializeField]
    [Range(-1f, 1f)]
    public float posY;

    [Header("Tooltip Prefabs")]
    [SerializeField]
    public AssetReferenceGameObject keywordTooltipPrefab;

    [SerializeField]
    public int keywordTooltipInitialPool = 1;

    [SerializeField]
    public AssetReferenceGameObject cardTooltipPrefab;

    [SerializeField]
    public int cardTooltipInitialPool = 1;

    public readonly Dictionary<string, Tooltip> activePanels = new Dictionary<string, Tooltip>();

    public RectTransform follow;

    public readonly List<Tooltip> pool = new List<Tooltip>();

    public bool ignoreTimeScale;

    public void Awake()
    {
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        for (int i = 0; i < keywordTooltipInitialPool; i++)
        {
            PoolPanel(((AssetReference)keywordTooltipPrefab).InstantiateAsync((Transform)(object)layout, false).WaitForCompletion().GetComponent<CardPopUpPanel>());
        }
        for (int j = 0; j < cardTooltipInitialPool; j++)
        {
            PoolPanel(((AssetReference)cardTooltipPrefab).InstantiateAsync((Transform)(object)layout, false).WaitForCompletion().GetComponent<CardTooltip>());
        }
    }

    public void Update()
    {
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_006b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        //IL_0092: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ae: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ba: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bf: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cc: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cd: Unknown result type (might be due to invalid IL or missing references)
        if ((follow))
        {
            Vector2 val = follow.sizeDelta * (((Transform)follow).lossyScale) * follow.pivot;
            Vector2 val2 = layout.sizeDelta * (((Transform)layout).lossyScale) * layout.pivot;
            float num = (val.x + val2.x + gap) * posX;
            float num2 = (val.y + val2.y + gap) * posY;
            Vector3 pos = ((Transform)follow).position + new Vector3(num, num2, 0f);
            ((Transform)base.rectTransform).position = ApplyLimits(pos);
        }
        else
        {
            Clear();
        }
    }

    public static void SetCanvasLayer(string layerName, int orderInLayer)
    {
        MonoBehaviourRectSingleton<CardPopUp>.instance.canvas.sortingLayerName = layerName;
        MonoBehaviourRectSingleton<CardPopUp>.instance.canvas.sortingOrder = orderInLayer;
    }

    public static void SetIgnoreTimeScale(bool ignore)
    {
        MonoBehaviourRectSingleton<CardPopUp>.instance.ignoreTimeScale = ignore;
    }

    public static void Reset()
    {
        SetCanvasLayer("PopUp", 0);
        SetIgnoreTimeScale(ignore: false);
    }

    public static void AssignToCard(Card card)
    {
        ref RectTransform reference = ref MonoBehaviourRectSingleton<CardPopUp>.instance.follow;
        Transform transform = ((Component)card.canvas).transform;
        reference = (RectTransform)(object)((transform is RectTransform) ? transform : null);
        MonoBehaviourRectSingleton<CardPopUp>.instance.posX = 1f;
        MonoBehaviourRectSingleton<CardPopUp>.instance.posY = 0f;
    }

    public static void AssignTo(RectTransform rect, float posX, float posY)
    {
        MonoBehaviourRectSingleton<CardPopUp>.instance.follow = rect;
        MonoBehaviourRectSingleton<CardPopUp>.instance.posX = posX;
        MonoBehaviourRectSingleton<CardPopUp>.instance.posY = posY;
    }

    public static CardPopUpPanel AddPanel(string name, string title, string body)
    {
        if (MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.ContainsKey(name))
        {
            return null;
        }
        CardPopUpPanel panel = MonoBehaviourRectSingleton<CardPopUp>.instance.GetPanel<CardPopUpPanel>();
        (((Component)panel).gameObject).name = name;
        panel.ignoreTimeScale = MonoBehaviourRectSingleton<CardPopUp>.instance.ignoreTimeScale;
        panel.Set(title, body);
        MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.Add(name, panel);
        foreach (KeywordData keyword in Text.GetKeywords(body))
        {
            CardPopUpPanel cardPopUpPanel = AddPanel(keyword);
            HashSetExt.AddIfNotNull<Tooltip>(panel.children, (Tooltip)cardPopUpPanel);
        }
        return panel;
    }

    public static CardPopUpPanel AddPanel(KeywordData keyword, string forceBody = null)
    {
        if (MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.ContainsKey((keyword).name))
        {
            return null;
        }
        CardPopUpPanel panel = MonoBehaviourRectSingleton<CardPopUp>.instance.GetPanel<CardPopUpPanel>();
        (((Component)panel).gameObject).name = (keyword).name;
        panel.ignoreTimeScale = MonoBehaviourRectSingleton<CardPopUp>.instance.ignoreTimeScale;
        panel.Set(keyword, forceBody);
        Events.InvokePopupPanelCreated(keyword, panel);
        MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.Add((keyword).name, panel);
        foreach (KeywordData keyword2 in Text.GetKeywords(keyword.body))
        {
            CardPopUpPanel cardPopUpPanel = AddPanel(keyword2);
            HashSetExt.AddIfNotNull<Tooltip>(panel.children, (Tooltip)cardPopUpPanel);
        }
        return panel;
    }

    public static CardTooltip AddPanel(CardData cardData)
    {
        CardTooltip panel = MonoBehaviourRectSingleton<CardPopUp>.instance.GetPanel<CardTooltip>();
        (((Component)panel).gameObject).name = (cardData).name;
        panel.Set(cardData);
        MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.Add((cardData).name, panel);
        foreach (KeywordData keyword in panel.keywords)
        {
            CardPopUpPanel cardPopUpPanel = AddPanel(keyword);
            HashSetExt.AddIfNotNull<Tooltip>(panel.children, (Tooltip)cardPopUpPanel);
        }
        return panel;
    }

    public static void RemovePanel(string name)
    {
        if (MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.TryGetValue(name, out var value))
        {
            foreach (Tooltip child in value.children)
            {
                RemovePanel((child).name);
            }
            MonoBehaviourRectSingleton<CardPopUp>.instance.PoolPanel(value);
            MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.Remove(name);
        }
        else
        {
            Debug.Log(("Panel [" + name + "] does not exist (CardPopUp)"));
        }
        MonoBehaviourRectSingleton<CardPopUp>.instance.StartFixLayouts();
    }

    public T GetPanel<T>() where T : Tooltip
    {
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0052: Unknown result type (might be due to invalid IL or missing references)
        //IL_0081: Unknown result type (might be due to invalid IL or missing references)
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        Tooltip tooltip = pool.FirstOrDefault((Tooltip a) => a is T);
        if (!(tooltip))
        {
            Type typeFromHandle = typeof(T);
            tooltip = ((typeFromHandle == typeof(CardTooltip)) ? ((Tooltip)((AssetReference)cardTooltipPrefab).InstantiateAsync((Transform)(object)layout, false).WaitForCompletion().GetComponent<CardTooltip>()) : ((Tooltip)((AssetReference)keywordTooltipPrefab).InstantiateAsync((Transform)(object)layout, false).WaitForCompletion().GetComponent<CardPopUpPanel>()));
        }
        else
        {
            pool.RemoveAt(pool.IndexOf(tooltip));
        }
        ((Component)tooltip).gameObject.SetActive(true);
        ((Component)tooltip).transform.SetAsLastSibling();
        return tooltip as T;
    }

    public void PoolPanel(Tooltip panel)
    {
        panel.children.Clear();
        ((Component)panel).gameObject.SetActive(false);
        pool.Add(panel);
    }

    public static void Clear()
    {
        foreach (KeyValuePair<string, Tooltip> activePanel in MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels)
        {
            GameObjectExt.Destroy(((Component)activePanel.Value).gameObject);
        }
        MonoBehaviourRectSingleton<CardPopUp>.instance.activePanels.Clear();
        MonoBehaviourRectSingleton<CardPopUp>.instance.follow = null;
    }

    public void StartFixLayouts()
    {
        if ((sizeFitter))
        {
            StopAllCoroutines();
            StartCoroutine(FixLayouts());
        }
    }

    public IEnumerator FixLayouts()
    {
        yield return null;
        ((Behaviour)sizeFitter).enabled = false;
        yield return null;
        ((Behaviour)sizeFitter).enabled = true;
    }

    public Vector3 ApplyLimits(Vector3 pos)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0052: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        Vector2 val = Vector2.Scale(Vector2.Scale(bounds.sizeDelta, bounds.pivot) - Vector2.Scale(boundingBox.sizeDelta, boundingBox.pivot), (((Transform)base.rectTransform).lossyScale));
        return Vector2Ext.WithZ(Vector2Ext.Clamp((pos), -val, val), pos.z);
    }
}
public class CardPopUpTarget : MonoBehaviourRect
{
    [SerializeField]
    [ReadOnly]
    public bool popped;

    [SerializeField]
    public Card card;

    [HideIf("IsCard")]
    public KeywordData[] keywords;

    [SerializeField]
    [HideIf("IsCard")]
    [Range(-1f, 1f)]
    public float posX = 1f;

    [SerializeField]
    [HideIf("IsCard")]
    [Range(-1f, 1f)]
    public float posY;

    public readonly HashSet<string> current = new HashSet<string>();

    public bool IsCard => card != null;

    public void Pop()
    {
        if (IsCard)
        {
            CardPopUp.AssignToCard(card);
            if (card.mentionedCards != null)
            {
                foreach (CardData mentionedCard in card.mentionedCards)
                {
                    if (current.Add((mentionedCard).name))
                    {
                        CardPopUp.AddPanel(mentionedCard);
                    }
                }
            }
            if (card.keywords != null)
            {
                foreach (KeywordData keyword in card.keywords)
                {
                    if (current.Add((keyword).name))
                    {
                        CardPopUp.AddPanel(keyword);
                    }
                }
            }
        }
        else if (keywords.Length != 0)
        {
            CardPopUp.AssignTo(base.rectTransform, posX, posY);
            KeywordData[] array = keywords;
            foreach (KeywordData keywordData2 in array)
            {
                if (current.Add((keywordData2).name))
                {
                    CardPopUp.AddPanel(keywordData2);
                }
            }
        }
        popped = true;
    }

    public void UnPop()
    {
        if (current.Count > 0)
        {
            foreach (string item in current)
            {
                CardPopUp.RemovePanel(item);
            }
            current.Clear();
        }
        popped = false;
    }

    public void OnDisable()
    {
        current.Clear();
    }
}
[RequireComponent(typeof(Card))]
public class CardRotator : MonoBehaviour
{
    [SerializeField]
    [Required(null)]
    [OnValueChanged("DataChanged")]
    public CardData data;

    [SerializeField]
    public float rotateSpeed;

    [SerializeField]
    public Vector3 rotateAmount;

    [SerializeField]
    public bool startFlippedDown = true;

    public Entity entity;

    public Card card;

    public float internalRotateSpeed = 1f;

    public float t;

    public IEnumerator Start()
    {
        entity = GetComponent<Entity>();
        entity.data = data;
        card = GetComponent<Card>();
        yield return card.UpdateData();
        if (startFlippedDown)
        {
            entity.flipper.FlipDownInstant();
            internalRotateSpeed = 0f;
            transform.localEulerAngles = Vector3.zero;
        }
    }

    public void Update()
    {
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        t += Time.deltaTime * rotateSpeed * internalRotateSpeed;
        transform.localEulerAngles = rotateAmount * Mathf.Sin(t);
    }

    public void DataChanged()
    {
        if (!Application.isEditor)
        {
            StartCoroutine(UpdateData(data));
        }
    }

    public IEnumerator UpdateData(CardData data)
    {
        entity.data = data;
        yield return entity.ClearStatuses();
        card.ClearStatusIcons();
        yield return card.UpdateData();
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Flip()
    {
        if (entity.flipper.flipped)
        {
            StartCoroutine(FlipUpRoutine());
        }
        else
        {
            StartCoroutine(FlipDownRoutine());
        }
    }

    public IEnumerator FlipUpRoutine()
    {
        entity.flipper.FlipUp();
        float dur = entity.flipper.flipUpDurationRand.y;
        yield return Sequences.Wait(dur / 2f);
        entity.wobbler.WobbleRandom();
        yield return Sequences.Wait(dur / 2f);
        LeanTween.value(0f, 1f, 1f).setOnUpdate(delegate (float a)
        {
            internalRotateSpeed = a;
        });
    }

    public IEnumerator FlipDownRoutine()
    {
        entity.flipper.FlipDown();
        float dur = entity.flipper.flipUpDurationRand.y;
        yield return Sequences.Wait(dur / 2f);
        entity.wobbler.WobbleRandom();
        yield return Sequences.Wait(dur / 2f);
        LeanTween.value(1f, 0f, 1f).setOnUpdate(delegate (float a)
        {
            internalRotateSpeed = a;
        });
    }
}
public class CardSelector : MonoBehaviour
{
    public Character character;

    public UnityEventEntity selectEvent;

    public void TakeCard(Entity entity)
    {
        if ((character) && (entity.data))
        {
            Debug.Log(("CardSelector → adding [" + (entity.data).name + "] to " + (character).name + "'s deck"));
            character.data.inventory.deck.Add(entity.data);
            MoveCardToDeck(entity);
            ((UnityEvent<Entity>)selectEvent).Invoke(entity);
        }
    }

    public void TakeFirstCard(CardContainer cardContainer)
    {
        if (cardContainer.Count > 0)
        {
            TakeCard(cardContainer.GetTop());
        }
    }

    public void MoveCardToDeck(Entity entity)
    {
        Events.InvokeEntityEnterBackpack(entity);
        entity.transform.parent = character.entity.display.transform;
        entity.display?.hover?.Disable();
        new Routine(AssetLoader.Lookup<CardAnimation>("CardAnimations", "FlyToBackpack").Routine(entity));
    }
}
public class ChallengeDisplayCreator : MonoBehaviour
{
    public ChallengeData challenge;

    [SerializeField]
    public ChallengeProgressDisplay displayPrefab;

    [SerializeField]
    public Transform displayParent;

    [SerializeField]
    public bool checkOnEnable = true;

    public void OnEnable()
    {
        if (checkOnEnable)
        {
            Check();
        }
    }

    public void Check()
    {
        if (!(challenge) || !challenge.reward.IsActive || !(displayPrefab))
        {
            return;
        }
        List<string> list = SaveSystem.LoadProgressData<List<string>>("completedChallenges", null) ?? new List<string>();
        if (list.Contains((challenge).name))
        {
            return;
        }
        ChallengeData[] requires = challenge.requires;
        foreach (ChallengeData challengeData in requires)
        {
            if (!list.Contains((challengeData).name))
            {
                return;
            }
        }
        int num = (SaveSystem.LoadProgressData<List<ChallengeProgress>>("challengeProgress", null)?.FirstOrDefault((ChallengeProgress a) => a.challengeName == (challenge).name))?.currentValue ?? 0;
        ChallengeProgressDisplay challengeProgressDisplay = Object.Instantiate<ChallengeProgressDisplay>(displayPrefab, (displayParent) ? displayParent : transform);
        challengeProgressDisplay.Assign(challenge);
        challengeProgressDisplay.SetFill(num, challenge.goal);
    }
}
public class ChallengeStone : MonoBehaviour
{
    public ChallengeData challenge;

    [SerializeField]
    public GameObject door;

    [SerializeField]
    public CardCharmHolder charmHolder;

    [SerializeField]
    public UINavigationItem navItem;

    [SerializeField]
    public LocalizeStringEvent title;

    [SerializeField]
    public LocalizeStringEvent text;

    public static readonly Vector2 popUpOffset = new Vector2(1f, 0f);

    public static readonly Vector4 raycastPadding = new Vector4(0f, 0f, 0f, 0f);

    public void OnEnable()
    {
        if ((challenge))
        {
            title.StringReference = challenge.titleKey;
            if (!challenge.hidden)
            {
                text.StringReference = challenge.textKey;
            }
        }
    }

    public void Open(CardUpgradeData upgradeData)
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        ((Behaviour)navItem).enabled = false;
        door.SetActive(false);
        UpgradeDisplay upgradeDisplay = charmHolder.Create(upgradeData);
        Image component = ((Component)upgradeDisplay).GetComponent<Image>();
        if (component != null)
        {
            ((Graphic)component).raycastPadding = raycastPadding;
        }
        CardCharmInteraction component2 = ((Component)upgradeDisplay).GetComponent<CardCharmInteraction>();
        if (component2 != null)
        {
            component2.popUpOffset = popUpOffset;
            component2.canDrag = false;
        }
        if (challenge.hidden)
        {
            text.StringReference = challenge.textKey;
        }
    }
}
public class Character : MonoBehaviour, ISaveable<CharacterSaveData>
{
    public PlayerData data;

    public string title;

    public int team = 1;

    public Entity entity;

    [HorizontalLine(/*Could not decode attribute arguments.*/)]
    public CardContainer drawContainer;

    public CardContainer handContainer;

    public CardContainer discardContainer;

    public CardContainer reserveContainer;

    public bool freeAction;

    public bool endTurn;

    public bool autoTriggerUnits = true;

    public void Assign(PlayerData data)
    {
        this.data = data;
    }

    public int GetCompanionCount()
    {
        return data.inventory.deck.FindAll((CardData a) => (a.cardType).name == "Friendly").Count;
    }

    public void GainGold(int amount)
    {
        if ((data?.inventory))
        {
            data.inventory.AddGold(amount);
            entity.PromptUpdate();
        }
    }

    public void SpendGold(int amount)
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        if ((data?.inventory))
        {
            Inventory inventory = data.inventory;
            inventory.gold -= amount;
            entity.PromptUpdate();
            Events.InvokeSpendGold(amount);
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Gain10Gold()
    {
        GainGold(10);
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Gain100Gold()
    {
        GainGold(100);
    }

    public CharacterSaveData Save()
    {
        return new CharacterSaveData(this);
    }

    public override bool Equals(object other)
    {
        if (other is Character character)
        {
            return team == character.team;
        }
        return false;
    }
}
public class CharacterRewards : MonoBehaviour
{
    public class Pool
    {
        public readonly List<DataFile> current = new List<DataFile>();

        public List<DataFile> list { get; set; }

        public void Add(DataFile item)
        {
            if (this.list == null)
            {
                List<DataFile> list2 = (this.list = new List<DataFile>());
            }
            this.list.Add(item);
        }

        public void Add(IEnumerable<DataFile> content)
        {
            if (this.list == null)
            {
                List<DataFile> list2 = (this.list = new List<DataFile>());
            }
            this.list.AddRange(content);
        }

        public void Remove(IEnumerable<string> itemNames)
        {
            foreach (string itemName in itemNames)
            {
                Remove(itemName);
            }
        }

        public void Remove(string itemName)
        {
            int num = list.RemoveAll((DataFile a) => (a).name == itemName);
            Debug.Log($"Removed [{num}] instances of [{itemName}]");
        }

        public void PullOut(IEnumerable<DataFile> items)
        {
            CheckPopulate();
            foreach (DataFile item in items)
            {
                current.Remove(item);
            }
        }

        public void PullOut(DataFile item)
        {
            CheckPopulate();
            current.Remove(item);
        }

        public DataFile Pull()
        {
            CheckPopulate();
            DataFile result = current[0];
            current.RemoveAt(0);
            return result;
        }

        public DataFile[] Pull(int itemCount, bool allowDuplicates = false)
        {
            List<DataFile> list = new List<DataFile>();
            while (list.Count < itemCount)
            {
                CheckPopulate();
                for (int i = 0; i < current.Count; i++)
                {
                    DataFile item = current[i];
                    if (allowDuplicates || !list.Contains(item))
                    {
                        list.Add(item);
                        current.RemoveAt(i);
                        break;
                    }
                }
            }
            return list.ToArray();
        }

        public DataFile[] Pull(int itemCount, bool allowDuplicates, Predicate<DataFile> match)
        {
            List<DataFile> list = new List<DataFile>();
            while (list.Count < itemCount)
            {
                CheckPopulate();
                List<DataFile> list2 = current.FindAll(match);
                if (list2.Count <= 0)
                {
                    Populate();
                    list2 = current.FindAll(match);
                    if (list2.Count <= 0)
                    {
                        break;
                    }
                }
                foreach (DataFile item in list2)
                {
                    if (allowDuplicates || !list.Contains(item))
                    {
                        list.Add(item);
                        current.RemoveAt(current.IndexOf(item));
                        if (list.Count >= itemCount)
                        {
                            break;
                        }
                    }
                }
            }
            return list.ToArray();
        }

        public DataFile[] GetFromOriginalList(int itemCount, bool allowDuplicates)
        {
            List<DataFile> list = new List<DataFile>();
            while (list.Count < itemCount)
            {
                foreach (DataFile item in IEnumerableExt.InRandomOrder<DataFile>((IEnumerable<DataFile>)this.list))
                {
                    if (allowDuplicates || !list.Contains(item))
                    {
                        list.Add(item);
                        if (list.Count >= itemCount)
                        {
                            break;
                        }
                    }
                }
            }
            return list.ToArray();
        }

        public DataFile[] GetFromOriginalList(int itemCount, bool allowDuplicates, Predicate<DataFile> match)
        {
            List<DataFile> list = new List<DataFile>();
            while (list.Count < itemCount)
            {
                List<DataFile> list2 = current.FindAll(match);
                if (list2.Count <= 0)
                {
                    break;
                }
                foreach (DataFile item in IEnumerableExt.InRandomOrder<DataFile>((IEnumerable<DataFile>)list2))
                {
                    if (allowDuplicates || !list.Contains(item))
                    {
                        list.Add(item);
                        if (list.Count >= itemCount)
                        {
                            break;
                        }
                    }
                }
            }
            return list.ToArray();
        }

        public void CheckPopulate()
        {
            if (current.Count <= 0)
            {
                Populate();
            }
        }

        public void Populate()
        {
            current.AddRange(IEnumerableExt.InRandomOrder<DataFile>((IEnumerable<DataFile>)list));
        }
    }

    public readonly Dictionary<string, Pool> poolLookup = new Dictionary<string, Pool>();

    public void Populate(ClassData classData)
    {
        poolLookup.Clear();
        RewardPool[] rewardPools = classData.rewardPools;
        foreach (RewardPool rewardPool in rewardPools)
        {
            Add(rewardPool);
        }
    }

    public void Add(RewardPool rewardPool)
    {
        if (!poolLookup.ContainsKey(rewardPool.type))
        {
            poolLookup[rewardPool.type] = new Pool();
        }
        for (int i = 0; i < rewardPool.copies; i++)
        {
            poolLookup[rewardPool.type].Add(rewardPool.list);
            Debug.Log($"Character Reward Pool [{rewardPool.type}] Populated with [{rewardPool.list.Count}] items from [{(rewardPool).name}]");
        }
    }

    public List<DataFile> GetItemsInPool(string name)
    {
        if (poolLookup.TryGetValue(name, out var value))
        {
            return value.list;
        }
        return null;
    }

    public void Add(string poolName, IEnumerable<DataFile> items)
    {
        if (!poolLookup.ContainsKey(poolName))
        {
            poolLookup[poolName] = new Pool();
        }
        poolLookup[poolName].Add(items);
    }

    public void RemoveLockedCards()
    {
        List<UnlockData> remainingUnlocks = MetaprogressionSystem.GetRemainingUnlocks();
        if (poolLookup.TryGetValue("Items", out var value))
        {
            List<string> lockedItems = MetaprogressionSystem.GetLockedItems(remainingUnlocks);
            Debug.Log(("Locked Items: [" + string.Join(", ", lockedItems) + "]"));
            value.Remove(lockedItems);
        }
        if (poolLookup.TryGetValue("Units", out var value2))
        {
            List<string> lockedCompanions = MetaprogressionSystem.GetLockedCompanions(remainingUnlocks);
            Debug.Log(("Locked Companions: [" + string.Join(", ", lockedCompanions) + "]"));
            value2.Remove(lockedCompanions);
        }
        if (poolLookup.TryGetValue("Charms", out var value3))
        {
            List<string> lockedCharms = MetaprogressionSystem.GetLockedCharms(remainingUnlocks);
            Debug.Log(("Locked Charms: [" + string.Join(", ", lockedCharms) + "]"));
            value3.Remove(lockedCharms);
        }
    }

    public void RemoveCardsFromStartingDeck()
    {
        HashSet<string> hashSet = new HashSet<string>();
        HashSet<string> hashSet2 = new HashSet<string>();
        foreach (CardData item in References.PlayerData.inventory.deck)
        {
            switch ((item.cardType).name)
            {
                case "Friendly":
                    hashSet2.Add((item).name);
                    break;
                case "Item":
                case "Clunker":
                    hashSet.Add((item).name);
                    break;
            }
        }
        if (hashSet.Count > 0)
        {
            Debug.Log(("Removing Items: [" + string.Join(", ", hashSet) + "]"));
            (poolLookup.ContainsKey("Items") ? poolLookup["Items"] : null)?.Remove(hashSet);
        }
        if (hashSet2.Count > 0)
        {
            Debug.Log(("Removing Units: [" + string.Join(", ", hashSet2) + "]"));
            (poolLookup.ContainsKey("Units") ? poolLookup["Units"] : null)?.Remove(hashSet2);
        }
    }

    public void RemoveCompanionsInFinalBossBattle()
    {
        Pool pool = null;
        CardSaveData[] array = SaveSystem.LoadProgressData<CardSaveData[]>("finalBossDeck", null);
        if (array == null)
        {
            return;
        }
        CardSaveData[] array2 = array;
        for (int i = 0; i < array2.Length; i++)
        {
            CardData cardData = array2[i].Peek();
            if ((cardData) && (cardData.cardType).name == "Friendly")
            {
                Debug.Log(("Removing [" + (cardData).name + "]"));
                if (pool == null)
                {
                    pool = (poolLookup.ContainsKey("Units") ? poolLookup["Units"] : null);
                }
                pool?.Remove((cardData).name);
            }
        }
    }

    public T Pull<T>(object pulledBy, string poolName) where T : DataFile
    {
        return Pull<T>(pulledBy, poolName, 1)[0];
    }

    public T[] Pull<T>(object pulledBy, string poolName, int itemCount, bool allowDuplicates = false) where T : DataFile
    {
        List<DataFile> list = Events.PullRewards(pulledBy, poolName, ref itemCount);
        if (poolLookup.ContainsKey(poolName))
        {
            Pool pool = poolLookup[poolName];
            if (list.Count > 0)
            {
                foreach (DataFile item in list)
                {
                    pool.PullOut(item);
                }
            }
            if (itemCount > 0)
            {
                list.AddRange(pool.Pull(itemCount, allowDuplicates));
            }
        }
        return list.Cast<T>().ToArray();
    }

    public T[] Pull<T>(object pulledBy, string poolName, int itemCount, bool allowDuplicates, Predicate<DataFile> match) where T : DataFile
    {
        List<DataFile> list = Events.PullRewards(pulledBy, poolName, ref itemCount);
        if (poolLookup.ContainsKey(poolName))
        {
            Pool pool = poolLookup[poolName];
            if (list.Count > 0)
            {
                foreach (DataFile item in list)
                {
                    pool.PullOut(item);
                }
            }
            if (itemCount > 0)
            {
                list.AddRange(pool.Pull(itemCount, allowDuplicates, match));
            }
        }
        return list.Cast<T>().ToArray();
    }

    public T[] GetFromOriginalList<T>(object pulledBy, string poolName, int itemCount, bool allowDuplicates) where T : DataFile
    {
        List<DataFile> list = Events.PullRewards(pulledBy, poolName, ref itemCount);
        if (poolLookup.ContainsKey(poolName))
        {
            Pool pool = poolLookup[poolName];
            if (itemCount > 0)
            {
                list.AddRange(pool.GetFromOriginalList(itemCount, allowDuplicates));
            }
        }
        return list.Cast<T>().ToArray();
    }

    public T[] GetFromOriginalList<T>(object pulledBy, string poolName, int itemCount, bool allowDuplicates, Predicate<DataFile> match) where T : DataFile
    {
        List<DataFile> list = Events.PullRewards(pulledBy, poolName, ref itemCount);
        if (poolLookup.ContainsKey(poolName))
        {
            Pool pool = poolLookup[poolName];
            if (itemCount > 0)
            {
                list.AddRange(pool.GetFromOriginalList(itemCount, allowDuplicates, match));
            }
        }
        return list.Cast<T>().ToArray();
    }

    public void PullOut(string poolName, IEnumerable<DataFile> items)
    {
        if (poolLookup.TryGetValue(poolName, out var value))
        {
            value.PullOut(items);
        }
    }

    public void PullOut(string poolName, DataFile item)
    {
        if (poolLookup.TryGetValue(poolName, out var value))
        {
            value.PullOut(item);
        }
    }
}
public class CharmMachine : MonoBehaviour
{
    [SerializeField]
    public Animator animator;

    [SerializeField]
    public CardPopUpTarget pop;

    public bool running;

    public bool hover;

    public bool CanRun()
    {
        if (!running)
        {
            return enabled;
        }
        return false;
    }

    public IEnumerator Run()
    {
        running = true;
        UnHover();
        animator.SetBool("EyesOpen", true);
        Events.InvokeScreenShake(0.2f, 0f);
        animator.SetTrigger("Rumble");
        SfxSystem.OneShot("event:/sfx/location/shop/charm_rumble");
        yield return Sequences.Wait(0.1f);
        animator.SetBool("OpenMouth", true);
        yield return Sequences.Wait(0.35f);
        animator.SetTrigger("DropCharm");
        SfxSystem.OneShot("event:/sfx/location/shop/charm_drop");
        yield return Sequences.Wait(1f);
        animator.SetBool("OpenMouth", false);
        animator.SetBool("EyesOpen", false);
        running = false;
    }

    public void Hover()
    {
        if (!hover && enabled && !running)
        {
            hover = true;
            animator.SetBool("Hover", hover);
            animator.SetBool("EyesOpen", hover);
            pop.Pop();
        }
    }

    public void UnHover()
    {
        if (hover)
        {
            hover = false;
            animator.SetBool("Hover", hover);
            animator.SetBool("EyesOpen", hover);
            pop.UnPop();
        }
    }
}
public class CheckAchievements : MonoBehaviour
{
    public static readonly Dictionary<string, string> AchievementChallenge = new Dictionary<string, string>
    {
        { "ACHIEVEMENT_0", "Challenge Charm 1" },
        { "ACHIEVEMENT_1", "Challenge Charm 2" },
        { "ACHIEVEMENT_2", "Challenge Charm 3" },
        { "ACHIEVEMENT_3", "Challenge Charm 4" },
        { "ACHIEVEMENT_4", "Challenge Charm 5" },
        { "ACHIEVEMENT_5", "Challenge Charm 6" },
        { "ACHIEVEMENT_6", "Challenge Charm 7" },
        { "ACHIEVEMENT_7", "Challenge Charm 8" },
        { "ACHIEVEMENT_8", "Challenge Charm 9" },
        { "ACHIEVEMENT_9", "Challenge Charm 10" },
        { "ACHIEVEMENT_10", "Challenge Charm 11" },
        { "ACHIEVEMENT_11", "Challenge Charm 12" },
        { "ACHIEVEMENT_12", "Challenge Charm 13" },
        { "ACHIEVEMENT_13", "Challenge Charm 14" },
        { "ACHIEVEMENT_14", "Challenge Charm 15" },
        { "ACHIEVEMENT_15", "Challenge Charm 16" },
        { "ACHIEVEMENT_16", "Challenge Charm 17" },
        { "ACHIEVEMENT_17", "Challenge Charm 18" },
        { "ACHIEVEMENT_18", "Challenge Charm 19" },
        { "ACHIEVEMENT_19", "Challenge Charm 20" },
        { "ACHIEVEMENT_20", "Challenge Charm 21" },
        { "ACHIEVEMENT_21", "Challenge Charm 22" },
        { "ACHIEVEMENT_22", "Challenge Charm 23" },
        { "ACHIEVEMENT_23", "Challenge Charm 24" },
        { "ACHIEVEMENT_24", "Challenge Charm 25" },
        { "ACHIEVEMENT_25", "Challenge Charm 26" },
        { "ACHIEVEMENT_26", "Challenge Charm 27" }
    };

    public void Start()
    {
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        if (!SteamManager.init)
        {
            return;
        }
        List<string> list = SaveSystem.LoadProgressData<List<string>>("completedChallenges");
        Debug.Log("Steam Achievements:");
        foreach (Achievement achievement in SteamUserStats.Achievements)
        {
            Achievement current = achievement;
            Debug.Log($"→ {((current)).Name} ({((current)).State})");
            if (!((current)).State)
            {
                string text = AchievementChallenge[((current)).Identifier];
                Debug.Log(("-→ Requires [" + text + "]"));
                if (list != null && list.Contains(text))
                {
                    AchievementsSystem.Achieve(((current)).Identifier);
                }
            }
        }
    }
}
public class ChooseNewCompanion : UISequence
{
    [SerializeField]
    public UISequence sequence;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardContainer cardContainer;

    [SerializeField]
    public int rewardOptions = 3;

    [Header("Banners")]
    [SerializeField]
    public RectTransform topBanner;

    [SerializeField]
    public RectTransform bottomBanner;

    [SerializeField]
    public RectTransform background;

    [SerializeField]
    public Vector2 bannerTweenDur = new Vector2(0.9f, 1.1f);

    [SerializeField]
    public LeanTweenType bannerTweenEase = LeanTweenType.easeOutBounce;

    [SerializeField]
    public Vector2 bannerTweenOutDur = new Vector2(0.3f, 0.4f);

    [SerializeField]
    public LeanTweenType bannerTweenOutEase = LeanTweenType.easeInBack;

    public CardData[] storedRewards;

    public override IEnumerator Run()
    {
        Populate();
        gameObject.SetActive(true);
        if (background != null)
        {
            ((Component)background).gameObject.SetActive(true);
            ((Transform)background).localScale = Vector3.zero;
            yield return null;
            background.LeanScale(Vector3.one, 1f).setEase(LeanTweenType.easeOutElastic);
            yield return Sequences.Wait(0.25f);
        }
        if (topBanner != null)
        {
            ((Component)topBanner).gameObject.SetActive(true);
            Vector3 localPosition = ((Transform)topBanner).localPosition;
            ((Transform)topBanner).localPosition = Vector3Ext.WithY(localPosition, localPosition.y + 5f);
            LeanTween.cancel(((Component)topBanner).gameObject);
            LeanTween.moveLocal(((Component)topBanner).gameObject, localPosition, Vector2Ext.PettyRandom(bannerTweenDur)).setEase(bannerTweenEase);
        }
        if (bottomBanner != null)
        {
            ((Component)bottomBanner).gameObject.SetActive(true);
            Vector3 localPosition2 = ((Transform)bottomBanner).localPosition;
            ((Transform)bottomBanner).localPosition = Vector3Ext.WithY(localPosition2, localPosition2.y - 5f);
            LeanTween.cancel(((Component)bottomBanner).gameObject);
            LeanTween.moveLocal(((Component)bottomBanner).gameObject, localPosition2, Vector2Ext.PettyRandom(bannerTweenDur)).setEase(bannerTweenEase);
        }
        ((Component)sequence).gameObject.SetActive(true);
        yield return sequence.Run();
        if (background != null)
        {
            background.LeanScale(Vector3.zero, tweenOutDur).setEase(LeanTweenType.easeInBack);
            yield return Sequences.Wait(tweenOutDur);
        }
        if (topBanner != null)
        {
            LeanTween.cancel(((Component)topBanner).gameObject);
            LeanTween.moveLocal(((Component)topBanner).gameObject, Vector3Ext.WithY(((Transform)topBanner).localPosition, ((Transform)topBanner).localPosition.y + 5f), Vector2Ext.PettyRandom(bannerTweenOutDur)).setEase(bannerTweenOutEase);
        }
        if (bottomBanner != null)
        {
            LeanTween.cancel(((Component)bottomBanner).gameObject);
            LeanTween.moveLocal(((Component)bottomBanner).gameObject, Vector3Ext.WithY(((Transform)bottomBanner).localPosition, ((Transform)bottomBanner).localPosition.y - 5f), Vector2Ext.PettyRandom(bannerTweenOutDur)).setEase(bannerTweenOutEase);
        }
    }

    public void Populate()
    {
        //IL_0122: Unknown result type (might be due to invalid IL or missing references)
        //IL_0135: Unknown result type (might be due to invalid IL or missing references)
        //IL_0147: Unknown result type (might be due to invalid IL or missing references)
        Character player = References.Player;
        cardSelector.character = player;
        cardController.owner = player;
        if (storedRewards == null || storedRewards.Length == 0)
        {
            storedRewards = ((Component)player).GetComponent<CharacterRewards>().Pull<CardData>(this, "Units", rewardOptions);
            Debug.Log(("Unit Reward Options: [" + string.Join(", ", (IEnumerable<CardData>)storedRewards) + "]"));
        }
        cardContainer.SetSize(storedRewards.Length, 0.8f);
        cardContainer.owner = player;
        Routine.Clump clump = new Routine.Clump();
        CardData[] array = storedRewards;
        for (int i = 0; i < array.Length; i++)
        {
            Card card = CardManager.Get(array[i].Clone(), cardController, player, inPlay: false, isPlayerCard: true);
            card.entity.flipper.FlipDownInstant();
            cardContainer.Add(card.entity);
            clump.Add(card.UpdateData());
        }
        foreach (Entity item in cardContainer)
        {
            Transform transform = item.transform;
            transform.localPosition = cardContainer.GetChildPosition(item);
            transform.localScale = cardContainer.GetChildScale(item);
            transform.localEulerAngles = cardContainer.GetChildRotation(item);
        }
    }
}
public class CinemaBarShower : MonoBehaviour
{
    [SerializeField]
    public bool showOnEnable;

    [Header("Sorting Order")]
    [SerializeField]
    public bool setSortingOrder;

    [SerializeField]
    [ShowIf("setSortingOrder")]
    public string sortingLayer = "CinemaBars";

    [SerializeField]
    [ShowIf("setSortingOrder")]
    public int orderInLayer;

    [Header("Top Bar")]
    [SerializeField]
    public bool topText;

    [SerializeField]
    [ShowIf("topText")]
    public LocalizedString topScript;

    [SerializeField]
    [ShowIf("topText")]
    public LocalizedString topPrompt;

    [SerializeField]
    [ShowIf("topText")]
    public string topAction;

    [Header("Bottom Bar")]
    [SerializeField]
    public bool bottomText;

    [SerializeField]
    [ShowIf("bottomText")]
    public LocalizedString bottomScript;

    [SerializeField]
    [ShowIf("bottomText")]
    public LocalizedString bottomPrompt;

    [SerializeField]
    [ShowIf("bottomText")]
    public string bottomAction;

    public void OnEnable()
    {
        if (showOnEnable)
        {
            Show();
        }
    }

    public void Show()
    {
        CinemaBarSystem.In();
        CinemaBarSystem.SetSortingLayer(sortingLayer, orderInLayer);
        if (topText)
        {
            if (!((LocalizedReference)topScript).IsEmpty)
            {
                CinemaBarSystem.Top.SetScript(topScript.GetLocalizedString());
            }
            else if (!((LocalizedReference)topPrompt).IsEmpty)
            {
                CinemaBarSystem.Top.SetPrompt(topPrompt.GetLocalizedString(), topAction);
            }
        }
        if (bottomText)
        {
            if (!((LocalizedReference)bottomScript).IsEmpty)
            {
                CinemaBarSystem.Bottom.SetScript(bottomScript.GetLocalizedString());
            }
            else if (!((LocalizedReference)bottomPrompt).IsEmpty)
            {
                CinemaBarSystem.Bottom.SetPrompt(bottomPrompt.GetLocalizedString(), bottomAction);
            }
        }
    }

    public void Hide()
    {
        CinemaBarSystem.Clear();
        CinemaBarSystem.Out();
    }
}
public class CloudMovement : MonoBehaviour
{
    public Transform mover;

    public float speed = 0.1f;

    public float width = 20f;

    public void Awake()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        Vector3 localPosition = mover.localPosition;
        localPosition.x = PettyRandom.Range(0f - width, width);
        mover.localPosition = localPosition;
    }

    public void Update()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        Vector3 localPosition = mover.localPosition;
        localPosition.x += speed * Time.deltaTime;
        if (localPosition.x > width)
        {
            localPosition.x = 0f - width;
        }
        else if (localPosition.x < 0f - width)
        {
            localPosition.x = width;
        }
        mover.localPosition = localPosition;
    }
}
public class Config : MonoBehaviourSingleton<Config>
{
    [Serializable]
    public class Data
    {
        public string version;

        public string versionNotation;

        public string versionFormat;

        public bool beta;
    }

    [SerializeField]
    public TextAsset configFile;

    public static Data _data;

    public static Data data => _data ?? (_data = JsonUtility.FromJson<Data>(MonoBehaviourSingleton<Config>.instance.configFile.text));

    public override void Awake()
    {
        base.Awake();
        Debug.Log((string.Format(data.versionFormat, data.versionNotation) + " Build: " + data.version));
    }
}
public class CopyRectTransform : MonoBehaviourRect
{
    [SerializeField]
    public RectTransform target;

    [SerializeField]
    [ShowIf("hasTarget")]
    public bool onEnable;

    [SerializeField]
    [ShowIf("hasTarget")]
    public bool onUpdate = true;

    [SerializeField]
    [ShowIf("hasTarget")]
    public bool onValidate;

    [SerializeField]
    [ShowIf("hasTarget")]
    public bool copyPosition = true;

    [SerializeField]
    [ShowIf("hasTarget")]
    public bool copyRotation = true;

    [SerializeField]
    [ShowIf("hasTarget")]
    public bool copySize;

    [SerializeField]
    [ShowIf("hasTarget")]
    public bool copyPivot;

    [SerializeField]
    [ShowIf("hasTarget")]
    public bool copyScale = true;

    [SerializeField]
    [ShowIf("hasTargetAndCopyScale")]
    public bool invertScale;

    public bool hasTarget => target != null;

    public bool hasTargetAndCopyScale
    {
        get
        {
            if (hasTarget)
            {
                return copyScale;
            }
            return false;
        }
    }

    public void OnEnable()
    {
        if (onEnable)
        {
            Copy();
        }
    }

    public void LateUpdate()
    {
        if (onUpdate)
        {
            Copy();
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Copy()
    {
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ac: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b1: Unknown result type (might be due to invalid IL or missing references)
        //IL_009f: Unknown result type (might be due to invalid IL or missing references)
        if (hasTarget)
        {
            if (copyPosition)
            {
                ((Transform)base.rectTransform).position = ((Transform)target).position;
            }
            if (copyRotation)
            {
                ((Transform)base.rectTransform).rotation = ((Transform)target).rotation;
            }
            if (copySize)
            {
                base.rectTransform.sizeDelta = target.sizeDelta;
            }
            if (copyPivot)
            {
                base.rectTransform.pivot = target.pivot;
            }
            if (copyScale)
            {
                ((Transform)base.rectTransform).localScale = (invertScale ? Vector3Ext.Invert(((Transform)target).localScale) : ((Transform)target).localScale);
            }
        }
    }
}
public class CreateLeaderDisplay : MonoBehaviour
{
    [SerializeField]
    public TweenUI startTween;

    [SerializeField]
    public float cardScale = 1f;

    public IEnumerator Start()
    {
        Character player = References.Player;
        Card card = CardManager.Get(References.LeaderData, null, player, inPlay: false, isPlayerCard: true);
        card.entity.returnToPool = false;
        Transform transform = card.transform;
        transform.localScale = Vector3.one * cardScale;
        card.entity.flipper.FlipUpInstant();
        card.hover.Disable();
        ((Behaviour)card.entity.uINavigationItem).enabled = false;
        transform.SetParent(transform);
        transform.localPosition = Vector3.zero;
        transform.localRotation = Quaternion.identity;
        card.entity.wobbler.WobbleRandom();
        yield return card.UpdateData();
        if ((startTween))
        {
            startTween.Fire();
        }
    }
}
public class CrownHolderShop : MonoBehaviour
{
    [SerializeField]
    public Animator animator;

    [SerializeField]
    public GameObject crown;

    [SerializeField]
    public Image crownImage;

    [SerializeField]
    public Image crownWhiteImage;

    [SerializeField]
    public Image interaction;

    [SerializeField]
    public Vector2 popUpOffset = new Vector2(0.7f, 0.25f);

    public CardUpgradeData crownData;

    public string popUpName;

    public string popUpTitle;

    public string popUpBody;

    public bool hover;

    public bool _hasCrown = true;

    public bool hasCrown
    {
        get
        {
            return _hasCrown;
        }
        set
        {
            _hasCrown = value;
            crown.SetActive(value);
            ((Behaviour)interaction).enabled = value;
        }
    }

    public void SetCrownData(CardUpgradeData crownData)
    {
        this.crownData = crownData;
        crownImage.sprite = crownData.image;
        crownWhiteImage.sprite = crownData.image;
        popUpName = (crownData).name;
        popUpTitle = crownData.title;
        popUpBody = crownData.text;
    }

    public CardUpgradeData GetCrownData()
    {
        return crownData;
    }

    public bool CanTake()
    {
        if (_hasCrown)
        {
            return enabled;
        }
        return false;
    }

    public void Hover()
    {
        if (!hover && CanTake())
        {
            hover = true;
            animator.SetBool("Hover", hover);
            CardPopUp.AssignTo(((Graphic)interaction).rectTransform, popUpOffset.x, popUpOffset.y);
            CardPopUp.AddPanel(popUpName, popUpTitle, popUpBody);
        }
    }

    public void UnHover()
    {
        if (hover)
        {
            hover = false;
            animator.SetBool("Hover", hover);
            CardPopUp.RemovePanel(popUpName);
        }
    }

    public void TakeCrown()
    {
        hasCrown = false;
    }
}
public class Cursor3d : MonoBehaviourSingleton<Cursor3d>
{
    public Camera _cam;

    public LayerMask layerMask;

    public bool usingMouse = true;

    public bool usingTouch;

    public GameObject mouseObj;

    public bool showVirtualPointerState = true;

    public static readonly Vector3 offset = new Vector3(0f, 0f, -1f);

    public readonly RaycastHit[] hits = (RaycastHit[])(object)new RaycastHit[1];

    public Camera cam => _cam ?? (_cam = Camera.main);

    public static Vector3 Position { get; set; }

    public static Vector3 PositionWithZ { get; set; }

    public void OnEnable()
    {
        CustomCursor.UpdateState();
    }

    public void Update()
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        if (usingMouse && Physics.RaycastNonAlloc(cam.ScreenPointToRay(InputSystem.MousePosition + offset), hits, 1000f, LayerMask.op_Implicit(layerMask)) > 0)
        {
            SetPosition(((hits[0])).point);
        }
    }

    public Vector2 GetScreenPoint()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        return (cam.WorldToScreenPoint(transform.position));
    }

    public void SetPosition(Vector3 position)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        transform.position = position;
        PositionWithZ = position;
        Position = Vector3Ext.WithZ(PositionWithZ, 0f);
    }
}
public class CursorDisplay : MonoBehaviourRect
{
    [SerializeField]
    public TouchInputModule inputModule;

    [SerializeField]
    public RectTransform pre;

    [SerializeField]
    public TMP_Text text;

    public void LateUpdate()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_0085: Unknown result type (might be due to invalid IL or missing references)
        //IL_0095: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c2: Unknown result type (might be due to invalid IL or missing references)
        //IL_0125: Unknown result type (might be due to invalid IL or missing references)
        //IL_0126: Unknown result type (might be due to invalid IL or missing references)
        Vector2 mousePosition = inputModule.MousePosition;
        Vector2 lastMousePosition = inputModule.LastMousePosition;
        ((Transform)base.rectTransform).position = (mousePosition);
        if ((text))
        {
            Vector2 mouseMove = inputModule.MouseMove;
            text.text = $"({Mathf.RoundToInt(mousePosition.x)}, {Mathf.RoundToInt(mousePosition.y)})\n" + $"({Mathf.RoundToInt(lastMousePosition.x)}, {Mathf.RoundToInt(lastMousePosition.y)})\n" + $"({Mathf.RoundToInt(mouseMove.x)}, {Mathf.RoundToInt(mouseMove.y)})\n" + $"Hovering: {inputModule.Hover}\n" + $"Pressing: {inputModule.Press}";
        }
        if ((pre))
        {
            ((Transform)pre).position = (lastMousePosition);
        }
    }
}
public class CurveAnimator : MonoBehaviourCacheTransform, IPoolable
{
    public static readonly Vector3 rotationInfluence = new Vector3(5f, 7f, 2f);

    public static readonly float rotationDurationMod = 1.5f;

    public static readonly float moveAnimationDur = 0.667f;

    public float pingDuration = 0.667f;

    public Vector3 pingScale = Vector3.one * 1.25f;

    public Vector3 pingMove = Vector3.back;

    public bool active;

    public float Move(Vector3 offset, AnimationCurve curve, float rotationAmount = 1f, float duration = 0.667f)
    {
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        //IL_008b: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        CancelTween();
        if ((gameObject))
        {
            active = true;
            LeanTween.moveLocal(gameObject, offset, duration).setEase(curve).setOnComplete((Action)delegate
            {
                active = false;
            });
            if (rotationAmount != 0f)
            {
                Vector3 offset2 = new Vector3(offset.y * rotationInfluence.x, (0f - offset.x) * rotationInfluence.y, (0f - offset.x) * rotationInfluence.z) * rotationAmount;
                Rotate(offset2, curve, duration * rotationDurationMod);
            }
        }
        return duration;
    }

    public float Rotate(Vector3 offset, AnimationCurve curve, float duration)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.rotateLocal(gameObject, offset, duration).setEase(curve);
        return duration;
    }

    public float Scale(Vector3 offset, AnimationCurve curve, float duration)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        CancelTween();
        LeanTween.scale(gameObject, offset, duration).setEase(curve);
        return duration;
    }

    public float Ping()
    {
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        if ((gameObject))
        {
            CancelTween();
            active = true;
            AnimationCurve ease = Curves.Get("Ping");
            LeanTween.moveLocal(gameObject, pingMove, pingDuration).setEase(ease).setOnComplete((Action)delegate
            {
                active = false;
            });
            LeanTween.scale(gameObject, pingScale, pingDuration).setEase(ease);
            Events.InvokeEntityPing(gameObject);
        }
        return pingDuration;
    }

    public void CancelTween()
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        if ((gameObject))
        {
            LeanTween.cancel(gameObject);
            base.transform.localPosition = Vector3.zero;
            base.transform.localEulerAngles = Vector3.zero;
            base.transform.localScale = Vector3.one;
        }
    }

    public void OnGetFromPool()
    {
    }

    public void OnReturnToPool()
    {
        CancelTween();
        active = false;
    }
}
public class Curves : MonoBehaviourSingleton<Curves>
{
    public List<Curve> list;

    public static AnimationCurve Get(string name)
    {
        return MonoBehaviourSingleton<Curves>.instance.list.First((Curve a) => a.name == name).curve;
    }
}
[Serializable]
public struct Curve
{
    public string name;

    public AnimationCurve curve;
}
public class CustomCursor : MonoBehaviourSingleton<CustomCursor>
{
    [Serializable]
    public class Style
    {
        public string name;

        public Texture2D sprite;

        public Vector2 hotSpot;
    }

    public CursorMode cursorMode;

    public Style[] styles;

    public string currentStyle = "default";

    public Dictionary<string, Style> styleLookup;

    public static bool visible = true;

    public override void Awake()
    {
        base.Awake();
        SetStyle(currentStyle);
    }

    public Style Get(string styleName)
    {
        Style result = null;
        if (styleLookup == null)
        {
            styleLookup = new Dictionary<string, Style>();
            Style[] array = styles;
            foreach (Style style in array)
            {
                styleLookup[style.name] = style;
                if (style.name == styleName)
                {
                    result = style;
                }
            }
        }
        else
        {
            result = styleLookup[styleName];
        }
        return result;
    }

    public void Set(Style style)
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        MonoBehaviourSingleton<CustomCursor>.instance.currentStyle = style.name;
        Cursor.SetCursor(style.sprite, style.hotSpot, MonoBehaviourSingleton<CustomCursor>.instance.cursorMode);
    }

    public static void SetStyle(string styleName)
    {
        Style style = MonoBehaviourSingleton<CustomCursor>.instance.Get(styleName);
        if (style != null)
        {
            MonoBehaviourSingleton<CustomCursor>.instance.Set(style);
        }
    }

    public void OnApplicationFocus(bool focus)
    {
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        if (focus)
        {
            UpdateState();
        }
        else
        {
            Cursor.SetCursor((Texture2D)null, Vector2.zero, (CursorMode)0);
        }
    }

    public static void UpdateState()
    {
        if (visible && (MonoBehaviourSingleton<Cursor3d>.instance == null || MonoBehaviourSingleton<Cursor3d>.instance.usingMouse))
        {
            Cursor.visible = true;
            SetStyle(MonoBehaviourSingleton<CustomCursor>.instance.currentStyle);
        }
        else
        {
            Cursor.visible = false;
        }
    }
}
public class DailyGenerator : MonoBehaviour
{
    [SerializeField]
    public Script[] deckRandomizers;

    [SerializeField]
    public GameModifierData[] goodModifiers;

    [SerializeField]
    public GameModifierData[] badModifiers;

    [SerializeField]
    public GameModifierData[] neutralModifiers;

    [HideInInspector]
    public bool running;

    public IEnumerator Run(int seed, GameMode gameMode)
    {
        running = true;
        Random.InitState(seed);
        Names.Reset();
        ClassData classData = IArrayExt.RandomItem<ClassData>(gameMode.classes);
        References.PlayerData = new PlayerData(classData, classData.startingInventory.Clone());
        string assetName = IArrayExt.RandomItem<string>(MetaprogressionSystem.GetAllPets());
        CardData item = AddressableLoader.Get<CardData>("CardData", assetName).Clone();
        References.PlayerData.inventory.deck.Insert(0, item);
        CardData item2 = IArrayExt.RandomItem<CardData>(classData.leaders).Clone();
        References.PlayerData.inventory.deck.Insert(0, item2);
        Campaign.Data = new CampaignData(gameMode, seed)
        {
            GameMode = gameMode,
            GameVersion = Config.data.version,
            Seed = seed
        };
        yield return IArrayExt.RandomItem<Script>(deckRandomizers).Run();
        int num = Random.Range(-100, 0);
        foreach (CardData item3 in References.PlayerData.inventory.deck)
        {
            num += item3.value - 25;
            if (item3.upgrades != null)
            {
                num += item3.upgrades.Count * 50;
            }
        }
        Debug.Log($"Daily Generator → Deck Value: {num}");
        int num2 = 0;
        List<GameModifierData> list = IEnumerableExt.InRandomOrder<GameModifierData>((IEnumerable<GameModifierData>)badModifiers).ToList();
        for (int i = 0; i < 2; i++)
        {
            GameModifierData gameModifierData = list.FirstOrDefault((GameModifierData a) => a.visible);
            if (!(gameModifierData))
            {
                break;
            }
            list.Remove(gameModifierData);
            ModifierSystem.AddModifier(Campaign.Data, gameModifierData);
            num += gameModifierData.value;
            Debug.Log($"Daily Generator → Adding [{(gameModifierData).name}] Modifier. New Deck Value: {num}");
            num2++;
        }
        List<GameModifierData> list2 = IEnumerableExt.InRandomOrder<GameModifierData>((IEnumerable<GameModifierData>)goodModifiers).ToList();
        for (int j = 0; j < 1; j++)
        {
            GameModifierData gameModifierData2 = list2.FirstOrDefault((GameModifierData a) => a.visible);
            if (!(gameModifierData2))
            {
                break;
            }
            list2.Remove(gameModifierData2);
            ModifierSystem.AddModifier(Campaign.Data, gameModifierData2);
            num += gameModifierData2.value;
            Debug.Log($"Daily Generator → Adding [{(gameModifierData2).name}] Modifier. New Deck Value: {num}");
            num2++;
        }
        while (num2 < 6 && Mathf.Abs(num) > 20)
        {
            List<GameModifierData> list3 = ((num > 0 && list.Count > 0) ? list : list2);
            if (list3.Count <= 0)
            {
                break;
            }
            GameModifierData gameModifierData3 = list3.FirstOrDefault((GameModifierData a) => !a.visible);
            if (!(gameModifierData3))
            {
                break;
            }
            list3.Remove(gameModifierData3);
            ModifierSystem.AddModifier(Campaign.Data, gameModifierData3);
            num += gameModifierData3.value;
            Debug.Log($"Daily Generator → Adding [{(gameModifierData3).name}] Modifier. New Deck Value: {num}");
            num2++;
            if (num2 >= 3 && Random.Range(0f, 1f) < 0.5f)
            {
                break;
            }
        }
        yield return Events.InvokeCampaignInit();
        running = false;
    }

    public IEnumerator Test(GameMode gameMode, int days = 730)
    {
        Debug.Log($"Daily Generator → Testing {days} Days");
        int dayOffset = DailyFetcher.DayOffset;
        Dictionary<GameModifierData, int> modifiers = new Dictionary<GameModifierData, int>();
        GameModifierData[] array = goodModifiers;
        foreach (GameModifierData key in array)
        {
            modifiers[key] = 0;
        }
        array = badModifiers;
        foreach (GameModifierData key2 in array)
        {
            modifiers[key2] = 0;
        }
        array = neutralModifiers;
        foreach (GameModifierData key3 in array)
        {
            modifiers[key3] = 0;
        }
        int total = 0;
        for (int i = 0; i < days; i++)
        {
            DailyFetcher.DayOffset = dayOffset + i;
            yield return DailyFetcher.FetchDateTime();
            int seed = DailyFetcher.GetSeed();
            yield return Run(seed, gameMode);
            foreach (GameModifierData modifier in Campaign.Data.Modifiers)
            {
                modifiers[modifier]++;
                total++;
            }
        }
        DailyFetcher.DayOffset = dayOffset;
        yield return DailyFetcher.FetchDateTime();
        Debug.Log("Daily Generator → Results:");
        foreach (KeyValuePair<GameModifierData, int> item in modifiers)
        {
            Debug.Log($"{(item.Key).name} Count: {item.Value} ({Mathf.RoundToInt((float)item.Value / (float)total * 100f)}%)");
        }
    }
}
public class DailyTimer : MonoBehaviour
{
    [SerializeField]
    public TMP_Text textElement;

    [SerializeField]
    public UnityEvent action;

    public int secondsRemaining;

    public float secondTimer;

    public void OnEnable()
    {
        DateTime dateTime = DailyFetcher.GetDateTime();
        float num = (float)(DailyFetcher.GetNextDateTime() - dateTime).TotalSeconds;
        secondsRemaining = Mathf.FloorToInt(num);
        secondTimer = num - (float)secondsRemaining;
        UpdateText();
    }

    public void Update()
    {
        secondTimer -= Time.deltaTime;
        if (!(secondTimer < 0f))
        {
            return;
        }
        while (secondTimer < 0f)
        {
            secondsRemaining--;
            secondTimer += 1f;
        }
        if (secondsRemaining <= 0)
        {
            UnityEvent obj = action;
            if (obj != null)
            {
                obj.Invoke();
            }
        }
        UpdateText();
    }

    public void UpdateText()
    {
        TimeSpan timeSpan = TimeSpan.FromSeconds(Mathf.Max(0, secondsRemaining));
        textElement.text = $"{timeSpan.Hours:D2}:{timeSpan.Minutes:D2}:{timeSpan.Seconds:D2}";
    }
}
public class Console : MonoBehaviourSingleton<Console>
{
    public abstract class Command
    {
        public bool success;

        public string[] predictedArgs;

        public virtual string id => "";

        public virtual string desc => "";

        public virtual string format => id;

        public virtual bool hidden => false;

        public virtual bool logOnSuccess => true;

        public string failMessage { get; set; }

        public virtual bool IsRoutine => false;

        public virtual void Run(string args)
        {
        }

        public virtual IEnumerator Routine(string args)
        {
            return null;
        }

        public virtual IEnumerator GetArgOptions(string currentArgs)
        {
            return null;
        }

        public void Fail(string message)
        {
            success = false;
            failMessage = failMessage;
            LogError(message);
        }

        public void FailCannotUse()
        {
            Fail("Cannot use [" + id + "] command here");
        }

        public bool TryGetPlayer(out Character player, bool doFail = true)
        {
            player = null;
            if (!(Campaign.instance))
            {
                if (doFail)
                {
                    FailCannotUse();
                }
                return false;
            }
            player = References.Player;
            if (!(player))
            {
                if (doFail)
                {
                    FailCannotUse();
                }
                return false;
            }
            return true;
        }

        public static string[] Split(string text)
        {
            if (text.Length <= 0)
            {
                return new string[1] { "" };
            }
            return text.Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
        }

        public Command()
        {
        }
    }

    public class CommandHelp : Command
    {
        public override string id => "help";

        public override bool hidden => true;

        public override bool logOnSuccess => false;

        public override void Run(string args)
        {
            ToggleHelp();
        }
    }

    public class CommandRepeat : Command
    {
        public override string id => "repeat";

        public override string format => "repeat <times>";

        public override bool logOnSuccess => false;

        public override void Run(string args)
        {
            if (previous.Count > 0)
            {
                int result = 1;
                if (args.Length > 0)
                {
                    int.TryParse(args, out result);
                }
                new Routine(Repeat(previous[0], result));
            }
        }

        public static IEnumerator Repeat(string command, int repeats)
        {
            while (repeats > 0)
            {
                repeats--;
                yield return HandleCommand(command);
            }
        }
    }

    public class CommandGainCard : Command
    {
        public override string id => "gain card";

        public override string format => "gain card <name>";

        public override bool IsRoutine => true;

        public override IEnumerator Routine(string args)
        {
            if (args.Length > 0)
            {
                if (!TryGetPlayer(out var player))
                {
                    yield break;
                }
                yield return AddressableLoader.LoadGroup("CardData");
                IEnumerable<CardData> source = from a in AddressableLoader.GetGroup<CardData>("CardData")
                                               where string.Equals((a).name, args, StringComparison.CurrentCultureIgnoreCase)
                                               select a;
                if (source.Any())
                {
                    CardData cardData = source.First();
                    if (cardData != null)
                    {
                        CardData cardData2 = cardData.Clone();
                        player.data.inventory.deck.Add(cardData2);
                        if ((Battle.instance) && (player.handContainer))
                        {
                            Card card = CardManager.Get(cardData2, Battle.instance.playerCardController, player, inPlay: true, isPlayerCard: true);
                            card.entity.flipper.FlipDownInstant();
                            card.transform.localPosition = new Vector3(-100f, 0f, 0f);
                            yield return card.UpdateData();
                            player.handContainer.Add(card.entity);
                            player.handContainer.TweenChildPositions();
                            ActionQueue.Add(new ActionReveal(card.entity));
                            ActionQueue.Add(new ActionRunEnableEvent(card.entity));
                            yield return ActionQueue.Wait();
                        }
                        yield break;
                    }
                }
                Fail("Card [" + args + "] does not exist!");
            }
            else
            {
                Fail("You must provide a card name");
            }
        }

        public override IEnumerator GetArgOptions(string currentArgs)
        {
            yield return AddressableLoader.LoadGroup("CardData");
            IEnumerable<CardData> source = from a in AddressableLoader.GetGroup<CardData>("CardData")
                                           where (a).name.ToLower().Contains(currentArgs.ToLower())
                                           select a;
            predictedArgs = source.Select((CardData cardData) => (cardData).name).ToArray();
        }
    }

    public class CommandGainUpgrade : Command
    {
        public override string id => "gain upgrade";

        public override string format => "gain upgrade <name>";

        public override bool IsRoutine => true;

        public override IEnumerator Routine(string args)
        {
            if (args.Length > 0)
            {
                if (TryGetPlayer(out var player, doFail: false))
                {
                    yield return AddressableLoader.LoadGroup("CardUpgradeData");
                    try
                    {
                        CardUpgradeData cardUpgradeData = AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData").First((CardUpgradeData a) => string.Equals((a).name, args, StringComparison.CurrentCultureIgnoreCase));
                        player.data.inventory.upgrades.Add(cardUpgradeData.Clone());
                    }
                    catch
                    {
                        Fail("Upgrade [" + args + "] does not exist!");
                    }
                    yield break;
                }
                GameObject val = GameObject.FindWithTag("CharmHolder");
                if (val == null)
                {
                    yield break;
                }
                CardCharmHolder cardCharmHolder = val.GetComponent<CardCharmHolder>();
                if (cardCharmHolder == null)
                {
                    yield break;
                }
                yield return AddressableLoader.LoadGroup("CardUpgradeData");
                try
                {
                    CardUpgradeData cardUpgradeData2 = AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData").First((CardUpgradeData a) => string.Equals((a).name, args, StringComparison.CurrentCultureIgnoreCase));
                    cardCharmHolder.Create(cardUpgradeData2.Clone());
                    cardCharmHolder.SetPositions();
                }
                catch
                {
                    Fail("Upgrade [" + args + "] does not exist!");
                }
            }
            else
            {
                Fail("You must provide an upgrade name");
            }
        }

        public override IEnumerator GetArgOptions(string currentArgs)
        {
            yield return AddressableLoader.LoadGroup("CardUpgradeData");
            IEnumerable<CardUpgradeData> enumerable = from a in AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData")
                                                      where (a).name.ToLower().Contains(currentArgs.ToLower())
                                                      select a;
            List<string> list = new List<string>();
            foreach (CardUpgradeData item in enumerable)
            {
                list.Add((item).name);
            }
            predictedArgs = list.ToArray();
        }
    }

    public class CommandGainGold : Command
    {
        public override string id => "gain blings";

        public override string format => "gain blings <amount>";

        public override void Run(string args)
        {
            int result = 10;
            Character player;
            if (args.Length > 0 && !int.TryParse(args, out result))
            {
                Fail("Invalid amount! (" + args + ")");
            }
            else if (TryGetPlayer(out player))
            {
                player.GainGold(result);
            }
        }
    }

    public class CommandSpawn : Command
    {
        public override string id => "spawn";

        public override string format => "spawn <unit>";

        public override bool IsRoutine => true;

        public override IEnumerator Routine(string args)
        {
            if (!(References.Battle))
            {
                Fail("Must be in battle to use this command");
                yield break;
            }
            if (args.Length <= 0)
            {
                Fail("You must provide a card name");
                yield break;
            }
            if (!(slotHover))
            {
                Fail("You must hover over a slot to use this command");
                yield break;
            }
            if (!slotHover.Empty)
            {
                Fail("That slot is not empty!");
                yield break;
            }
            yield return AddressableLoader.LoadGroup("CardData");
            IEnumerable<CardData> source = from a in AddressableLoader.GetGroup<CardData>("CardData")
                                           where a.cardType.unit && string.Equals((a).name, args, StringComparison.CurrentCultureIgnoreCase)
                                           select a;
            if (source.Any())
            {
                CardData cardData = source.First();
                if (cardData != null)
                {
                    CardData data = cardData.Clone();
                    Card card = CardManager.Get(data, References.Battle.playerCardController, slotHover.owner, inPlay: true, slotHover.owner.team == References.Player.team);
                    card.entity.flipper.FlipDownInstant();
                    card.transform.localPosition = new Vector3(-100f, 0f, 0f);
                    yield return card.UpdateData();
                    slotHover.Add(card.entity);
                    slotHover.TweenChildPositions();
                    ActionQueue.Add(new ActionReveal(card.entity));
                    ActionQueue.Add(new ActionRunEnableEvent(card.entity));
                    yield return ActionQueue.Wait();
                    yield break;
                }
            }
            Fail("Card [" + args + "] does not exist!");
        }

        public override IEnumerator GetArgOptions(string currentArgs)
        {
            yield return AddressableLoader.LoadGroup("CardData");
            IEnumerable<CardData> source = from a in AddressableLoader.GetGroup<CardData>("CardData")
                                           where a.cardType.unit && (a).name.ToLower().Contains(currentArgs.ToLower())
                                           select a;
            predictedArgs = source.Select((CardData cardData) => (cardData).name).ToArray();
        }
    }

    public class CommandBattleWin : Command
    {
        public override string id => "battle win";

        public override void Run(string args)
        {
            if (Battle.instance == null)
            {
                FailCannotUse();
            }
            else if (Battle.instance.phase == Battle.Phase.End)
            {
                Fail("The battle is already over!");
            }
            else
            {
                Battle.instance.PlayerWin();
            }
        }
    }

    public class CommandBattleLose : Command
    {
        public override string id => "battle lose";

        public override void Run(string args)
        {
            if (Battle.instance == null)
            {
                FailCannotUse();
            }
            else if (Battle.instance.phase == Battle.Phase.End)
            {
                Fail("The battle is already over!");
            }
            else
            {
                Battle.instance.EnemyWin();
            }
        }
    }

    public class CommandBattleSkip : Command
    {
        public override string id => "battle skip";

        public override string desc => "to next wave";

        public override void Run(string args)
        {
            if (Battle.instance == null)
            {
                FailCannotUse();
                return;
            }
            if (Battle.instance.phase == Battle.Phase.End)
            {
                Fail("The battle is already over!");
                return;
            }
            foreach (Entity item in Battle.GetCardsOnBoard(Battle.instance.enemy))
            {
                item.RemoveFromContainers();
                CardManager.ReturnToPool(item);
            }
            ActionQueue.Add(new ActionEndTurn(Battle.instance.player));
            Battle.instance.playerCardController.Disable();
            CardPopUp.Clear();
        }
    }

    public class CommandBattleAuto : Command
    {
        public override string id => "battle auto";

        public override string desc => "play out the rest of the battle automatically";

        public override void Run(string args)
        {
            if (!(References.Battle))
            {
                FailCannotUse();
            }
            else if (References.Battle.phase == Battle.Phase.End)
            {
                Fail("The battle is already over!");
            }
            else
            {
                References.Battle.auto = !References.Battle.auto;
            }
        }
    }

    public class CommandSkipTurn : Command
    {
        public override string id => "skip turn";

        public override void Run(string args)
        {
            if (Battle.instance == null)
            {
                FailCannotUse();
                return;
            }
            if (Battle.instance.phase == Battle.Phase.End)
            {
                Fail("The battle is already over!");
                return;
            }
            ActionQueue.Add(new ActionEndTurn(Battle.instance.player));
            Battle.instance.playerCardController.Disable();
            CardPopUp.Clear();
        }
    }

    public class CommandSetHealth : Command
    {
        public override string id => "set health";

        public override string format => "set health <value>";

        public override void Run(string args)
        {
            if (args.Length < 1)
            {
                Fail("You must provide a value");
                return;
            }
            if (hover == null)
            {
                Fail("Please hover over a card to use this command");
                return;
            }
            if (!int.TryParse(args, out var result) || result <= 0)
            {
                Fail("Invalid value! (" + args + ")");
                return;
            }
            if (!((Behaviour)hover).enabled || !hover.data.hasHealth)
            {
                Fail("Cannot use on this card");
                return;
            }
            hover.hp.current = result;
            hover.hp.max = Mathf.Max(hover.hp.max, hover.hp.current);
            hover.PromptUpdate();
        }
    }

    public class CommandSetAttack : Command
    {
        public override string id => "set attack";

        public override string format => "set attack <value>";

        public override void Run(string args)
        {
            if (args.Length < 1)
            {
                Fail("You must provide a value");
                return;
            }
            if (hover == null)
            {
                Fail("Please hover over a card to use this command");
                return;
            }
            if (!int.TryParse(args, out var result) || result <= 0)
            {
                Fail("Invalid value! (" + args + ")");
                return;
            }
            if (!((Behaviour)hover).enabled || !hover.data.hasAttack)
            {
                Fail("Cannot use on this card");
                return;
            }
            hover.damage.current = result;
            hover.damage.max = result;
            hover.PromptUpdate();
        }
    }

    public class CommandSetCounter : Command
    {
        public override string id => "set counter";

        public override string format => "set counter <value>";

        public override void Run(string args)
        {
            if (args.Length < 1)
            {
                Fail("You must provide a value");
                return;
            }
            if (hover == null)
            {
                Fail("Please hover over a card to use this command");
                return;
            }
            if (!int.TryParse(args, out var result) || result <= 0)
            {
                Fail("Invalid value! (" + args + ")");
                return;
            }
            if (!((Behaviour)hover).enabled || !hover.data.hasAttack)
            {
                Fail("Cannot use on this card");
                return;
            }
            hover.counter.current = result;
            hover.counter.max = Mathf.Max(hover.counter.max, result);
            hover.PromptUpdate();
        }
    }

    public class CommandAddStatus : Command
    {
        public override string id => "add status";

        public override string format => "add status <name>";

        public override bool IsRoutine => true;

        public override IEnumerator Routine(string args)
        {
            if (args.Length > 0)
            {
                if (hover != null)
                {
                    if (((Behaviour)hover).enabled)
                    {
                        string[] array = Command.Split(args);
                        string statusName = array[0];
                        int count = 1;
                        if (array.Length > 1)
                        {
                            int.TryParse(array[1], out count);
                        }
                        yield return AddressableLoader.LoadGroup("StatusEffectData");
                        IEnumerable<StatusEffectData> source = from a in AddressableLoader.GetGroup<StatusEffectData>("StatusEffectData")
                                                               where a.visible && !(a).name.Contains(' ') && string.Equals((a).name, statusName, StringComparison.CurrentCultureIgnoreCase)
                                                               select a;
                        if (source.Any())
                        {
                            StatusEffectData statusEffectData = source.First();
                            if (statusEffectData != null)
                            {
                                yield return StatusEffectSystem.Apply(hover, null, statusEffectData, count);
                                yield break;
                            }
                        }
                        Fail("StatusEffect [" + statusName + "] does not exist!");
                    }
                    else
                    {
                        Fail("Cannot use on that card");
                    }
                }
                else
                {
                    Fail("Please hover over a card to use this command");
                }
            }
            else
            {
                Fail("You must provide a StatusEffect name");
            }
        }

        public override IEnumerator GetArgOptions(string currentArgs)
        {
            yield return AddressableLoader.LoadGroup("StatusEffectData");
            IEnumerable<StatusEffectData> source = from a in AddressableLoader.GetGroup<StatusEffectData>("StatusEffectData")
                                                   where a.visible && !(a).name.Contains(' ') && (a).name.ToLower().Contains(currentArgs.ToLower())
                                                   select a;
            predictedArgs = source.Select((StatusEffectData effectData) => (effectData).name).ToArray();
        }
    }

    public class CommandAddUpgrade : Command
    {
        public override string id => "add upgrade";

        public override string format => "add upgrade <name>";

        public override bool IsRoutine => true;

        public override IEnumerator Routine(string args)
        {
            if (args.Length > 0)
            {
                if (hover != null)
                {
                    yield return AddressableLoader.LoadGroup("CardUpgradeData");
                    IEnumerable<CardUpgradeData> source = from a in AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData")
                                                          where (a).name.ToLower() == args.ToLower()
                                                          select a;
                    if (source.Any())
                    {
                        CardUpgradeData cardUpgradeData = source.First();
                        if (cardUpgradeData != null)
                        {
                            if (cardUpgradeData.CanAssign(hover))
                            {
                                yield return cardUpgradeData.Clone().Assign(hover);
                                yield break;
                            }
                            Fail("Upgrade [" + (cardUpgradeData).name + "] cannot be assigned to [" + hover.data.title + "]");
                            yield break;
                        }
                    }
                    Fail("Upgrade [" + args + "] does not exist!");
                }
                else
                {
                    Fail("Please hover over a card to use this command");
                }
            }
            else
            {
                Fail("You must provide an upgrade name");
            }
        }

        public override IEnumerator GetArgOptions(string currentArgs)
        {
            yield return AddressableLoader.LoadGroup("CardUpgradeData");
            IEnumerable<CardUpgradeData> source = from a in AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData")
                                                  where (a).name.ToLower().Contains(currentArgs.ToLower())
                                                  select a;
            predictedArgs = source.Select((CardUpgradeData upgradeData) => (upgradeData).name).ToArray();
        }
    }

    public class CommandDestroy : Command
    {
        public override string id => "destroy";

        public override void Run(string args)
        {
            if (hover == null)
            {
                Fail("Please hover over a card to use this command");
                return;
            }
            if (!((Behaviour)hover).enabled)
            {
                Fail("Cannot destroy this card");
                return;
            }
            hover.RemoveFromContainers();
            CardManager.ReturnToPool(hover);
            CardPopUp.Clear();
        }
    }

    public class CommandDestroyAll : Command
    {
        public override string id => "destroy all";

        public override void Run(string args)
        {
            if (Battle.instance == null)
            {
                Fail("Must be in battle to use this command");
                return;
            }
            foreach (Entity item in Battle.GetCardsOnBoard(Battle.instance.enemy))
            {
                item.RemoveFromContainers();
                CardManager.ReturnToPool(item);
            }
            ActionQueue.Add(new ActionEndTurn(Battle.instance.player));
            Battle.instance.playerCardController.Disable();
            CardPopUp.Clear();
        }
    }

    public class CommandHit : Command
    {
        public override string id => "hit";

        public override string format => "hit <damage>";

        public override bool IsRoutine => true;

        public override IEnumerator Routine(string args)
        {
            if (!(hover))
            {
                Fail("Please hover over a card to use this command");
                yield break;
            }
            int result = 1;
            if (args.Length > 0)
            {
                int.TryParse(args, out result);
            }
            Character player = References.Player;
            if (player != null && (player.entity))
            {
                Hit hit = new Hit(player.entity, hover, result)
                {
                    canRetaliate = false
                };
                yield return hit.Process();
            }
            else
            {
                FailCannotUse();
            }
        }
    }

    public class CommandKill : Command
    {
        public override string id => "kill";

        public override void Run(string args)
        {
            if (hover == null)
            {
                Fail("Please hover over a card to use this command");
                return;
            }
            if (!((Behaviour)hover).enabled)
            {
                Fail("Cannot kill this card");
                return;
            }
            hover.forceKill = true;
            hover.PromptUpdate();
        }
    }

    public class CommandKillAll : Command
    {
        public override string id => "kill all";

        public override void Run(string args)
        {
            if (Battle.instance == null)
            {
                Fail("Must be in battle to use this command");
                return;
            }
            foreach (Entity item in Battle.GetCardsOnBoard(Battle.instance.enemy))
            {
                item.forceKill = true;
                item.PromptUpdate();
            }
            ActionQueue.Add(new ActionEndTurn(Battle.instance.player));
            Battle.instance.playerCardController.Disable();
        }
    }

    public class CommandReroll : Command
    {
        public override string id => "reroll";

        public override string desc => "new leaders, or card rewards";

        public override void Run(string args)
        {
            foreach (IRerollable item in Object.FindObjectsOfType<MonoBehaviour>().OfType<IRerollable>())
            {
                Debug.Log($"Rerolling [{item}]");
                if (item.Reroll())
                {
                    return;
                }
            }
            Fail("Nothing to reroll");
        }
    }

    public class CommandSystemDisable : Command
    {
        public override string id => "system disable";

        public override string format => "system disable <name>";

        public override void Run(string args)
        {
            if (args.Length <= 0)
            {
                Fail("You must provide a system name");
                return;
            }
            Type type = Type.GetType(args + ",Assembly-CSharp");
            if (type == null)
            {
                Fail("System '" + args + "' not found! (it's case sensitive)");
                return;
            }
            Object obj = Object.FindObjectOfType(type);
            MonoBehaviour val = (MonoBehaviour)(object)((obj is MonoBehaviour) ? obj : null);
            if (val == null)
            {
                Fail("System '" + args + "' does not exist!");
                return;
            }
            if (!((Behaviour)val).enabled)
            {
                Fail("'" + args + "' is already disabled");
            }
            ((Behaviour)val).enabled = false;
        }

        public override IEnumerator GetArgOptions(string currentArgs)
        {
            yield return null;
            IEnumerable<GameSystem> source = from a in Object.FindObjectsOfType<GameSystem>()
                                             where ((Behaviour)a).enabled && ((object)a).GetType().ToString().ToLower()
                                                 .Contains(currentArgs.ToLower())
                                             select a;
            predictedArgs = source.Select((GameSystem s) => ((object)s).GetType().ToString()).ToArray();
        }
    }

    public class CommandSystemEnable : Command
    {
        public override string id => "system enable";

        public override string format => "system enable <name>";

        public override void Run(string args)
        {
            if (args.Length <= 0)
            {
                Fail("You must provide a system name");
                return;
            }
            Type type = Type.GetType(args + ",Assembly-CSharp");
            if (type == null)
            {
                Fail("System '" + args + "' not found! (it's case sensitive)");
                return;
            }
            Object obj = Object.FindObjectOfType(type);
            MonoBehaviour val = (MonoBehaviour)(object)((obj is MonoBehaviour) ? obj : null);
            if (val == null)
            {
                Fail("System '" + args + "' does not exist!");
                return;
            }
            if (((Behaviour)val).enabled)
            {
                Fail("'" + args + "' is already enabled");
            }
            ((Behaviour)val).enabled = true;
        }

        public override IEnumerator GetArgOptions(string currentArgs)
        {
            yield return null;
            IEnumerable<GameSystem> source = from a in Object.FindObjectsOfType<GameSystem>()
                                             where !((Behaviour)a).enabled && ((object)a).GetType().ToString().ToLower()
                                                 .Contains(currentArgs.ToLower())
                                             select a;
            predictedArgs = source.Select((GameSystem s) => ((object)s).GetType().ToString()).ToArray();
        }
    }

    public class CommandGameSpeed : Command
    {
        public override string id => "gamespeed";

        public override string format => "gamespeed <value>";

        public override void Run(string args)
        {
            float result;
            if (args.Length <= 0)
            {
                Fail("You must provide a value (1 = normal speed, 2 = double speed, 0.5 = half speed)");
            }
            else if (float.TryParse(args, out result) && result >= 0f)
            {
                Events.InvokeTimeScaleChange(result);
            }
            else
            {
                Fail("Invalid value! (" + args + ")");
            }
        }
    }

    public class CommandMapJump : Command
    {
        public override string id => "map jump";

        public override string desc => "to the selected map node";

        public override void Run(string args)
        {
            MapNode[] array = Object.FindObjectsOfType<MapNode>();
            if (array.Length == 0)
            {
                FailCannotUse();
                return;
            }
            MapNode mapNode = array.FirstOrDefault((MapNode n) => n.IsHovered);
            if (mapNode == null)
            {
                Fail("You must be hovering over a map node");
                return;
            }
            Character player = References.Player;
            if (player != null)
            {
                MapNew.MoveTo(player, mapNode);
                if (!mapNode.campaignNode.type.canSkip)
                {
                    mapNode.campaignNode.SetCleared();
                }
                mapNode.map.Continue(forceCanSkip: true);
            }
            else
            {
                Fail("Player does not exist!");
            }
        }
    }

    public class CommandMapInfo : Command
    {
        public override string id => "map info";

        public override string format => "map info";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            MapNode[] array = Object.FindObjectsOfType<MapNode>();
            if (array.Length == 0)
            {
                FailCannotUse();
                return;
            }
            MapNode mapNode = array.FirstOrDefault((MapNode n) => n.IsHovered);
            if (!(mapNode))
            {
                Fail("You must be hovering over a map node");
                return;
            }
            Debug.Log($"[{mapNode.campaignNode.name} {mapNode.campaignNode.id}] info:");
            foreach (KeyValuePair<string, object> datum in mapNode.campaignNode.data)
            {
                object value = datum.Value;
                if (!(value is ICollection<string> values))
                {
                    if (value is SaveCollection<string> saveCollection)
                    {
                        Debug.Log((datum.Key + ": " + string.Join(", ", saveCollection.collection)));
                    }
                    else
                    {
                        Debug.Log($"{datum.Key}: {datum.Value}");
                    }
                }
                else
                {
                    Debug.Log((datum.Key + ": " + string.Join(", ", values)));
                }
            }
        }
    }

    public class CommandSetSaveProfile : Command
    {
        public override string id => "save profile";

        public override string format => "save profile <name>";

        public override string desc => "switch save profile";

        public override void Run(string args)
        {
            if (Campaign.instance == null)
            {
                SaveSystem.SetProfile(args);
            }
            else
            {
                Fail("Cannot switch save profile here!");
            }
        }
    }

    public class CommandVolume : Command
    {
        public readonly string busName;

        public readonly string internalId = "volume";

        public readonly string internalFormat = "volume <0-1>";

        public override string id => internalId;

        public override string format => internalFormat;

        public CommandVolume(string busName = "Master")
        {
            string text = busName.ToLower();
            this.busName = ((text == "sfx") ? "SFX" : StringExt.ToUpperFirstLetter(text));
            if (text != "master")
            {
                internalId = "volume " + text;
                internalFormat = internalId + " <0-1>";
            }
        }

        public override void Run(string args)
        {
            float result;
            if (args.Length <= 0)
            {
                Fail("You must provide a value between 0 and 1");
            }
            else if (float.TryParse(args, out result))
            {
                AudioSettingsSystem.Volume(busName, result);
            }
            else
            {
                Fail("Invalid value! (" + args + ")");
            }
        }
    }

    public abstract class CommandOptions : Command
    {
        public override string format => id + " <" + string.Join("/", options) + ">";

        public virtual string[] options => new string[2] { "on", "off" };

        public override IEnumerator GetArgOptions(string currentArgs)
        {
            predictedArgs = options.Where((string a) => a.Contains(currentArgs.ToLower())).ToArray();
            yield return null;
        }

        public CommandOptions()
        {
        }
    }

    public abstract class CommandToggle : CommandOptions
    {
        public override void Run(string args)
        {
            string text = args.ToLower();
            if (!(text == "on"))
            {
                if (text == "off")
                {
                    TurnOff();
                }
                else
                {
                    Fail("You must enter either 'on' or 'off'");
                }
            }
            else
            {
                TurnOn();
            }
        }

        public virtual void TurnOn()
        {
        }

        public virtual void TurnOff()
        {
        }

        public CommandToggle()
        {
        }
    }

    public class CommandToggleHUD : CommandToggle
    {
        public override string id => "hud";

        public override void TurnOn()
        {
            Settings.Save("HudAlpha", 1f);
        }

        public override void TurnOff()
        {
            Settings.Save("HudAlpha", 0f);
        }
    }

    public class CommandToggleFps : CommandToggle
    {
        public override string id => "fps";

        public override void TurnOn()
        {
            Settings.Save("ShowFps", value: true);
        }

        public override void TurnOff()
        {
            Settings.Save("ShowFps", value: false);
        }
    }

    public class CommandCursor : CommandOptions
    {
        public override string id => "cursor";

        public override string[] options => new string[3] { "off", "game", "system" };

        public override void Run(string args)
        {
            switch (args)
            {
                case "off":
                    CustomCursor.visible = false;
                    CustomCursor.UpdateState();
                    break;
                case "game":
                    CustomCursor.visible = true;
                    CustomCursor.SetStyle("default");
                    CustomCursor.UpdateState();
                    break;
                case "system":
                    CustomCursor.visible = true;
                    CustomCursor.SetStyle("system");
                    CustomCursor.UpdateState();
                    break;
                default:
                    Fail("Invalid cursor option");
                    break;
            }
        }
    }

    public class CommandToggleHandOverlay : CommandToggle
    {
        public override string id => "handoverlay";

        public override void TurnOn()
        {
            Settings.Save("HideHandOverlay", value: false);
        }

        public override void TurnOff()
        {
            Settings.Save("HideHandOverlay", value: true);
        }
    }

    public class CommandPrompt : Command
    {
        public override string id => "prompt";

        public override string format => "prompt <anchor> <x> <y> <maxWidth> <text>";

        public override void Run(string args)
        {
            List<string> list = IArrayExt.ToList<string>(args.Split(' '));
            if (list.Count > 4)
            {
                if (Enum.TryParse<Prompt.Anchor>(StringExt.ToUpperFirstLetter(list[0]), out var result) && float.TryParse(list[1], out var result2) && float.TryParse(list[2], out var result3) && float.TryParse(list[3], out var result4))
                {
                    list.RemoveRange(0, 4);
                    string.Join(" ", list);
                    PromptSystem.Create(result, result2, result3, result4);
                }
                else
                {
                    Fail("Invalid arguments");
                }
            }
        }
    }

    public class CommandPromptHide : Command
    {
        public override string id => "prompthide";

        public override void Run(string args)
        {
            PromptSystem.Hide();
        }
    }

    public class CommandErrorTest : Command
    {
        public override string id => "errortest";

        public override string format => "errortest <message>";

        public override void Run(string args)
        {
            MonoBehaviourSingleton<Console>.instance.Toggle();
            throw new Exception(args);
        }
    }

    public class CommandPanSpeed : Command
    {
        public override string id => "pan speed";

        public override string format => "pan speed <value (default 5)>";

        public override void Run(string args)
        {
            if (Object.FindObjectOfType<Scroller>() != null)
            {
                List<string> list = IArrayExt.ToList<string>(args.Split(' '));
                if (list.Count <= 0 || !float.TryParse(list[0], out var _))
                {
                    Fail("Please enter a value");
                }
            }
            else
            {
                Fail("You must be in the town scene to use this command");
            }
        }
    }

    public class CommandNextBattle : Command
    {
        public override string id => "next battle";

        public override string format => "next battle <battle>";

        public override bool IsRoutine => true;

        public override IEnumerator Routine(string args)
        {
            Campaign campaign = References.Campaign;
            if (campaign != null)
            {
                if (args.Length > 0)
                {
                    yield return AddressableLoader.LoadGroup("BattleData");
                    BattleData battleData = AddressableLoader.GetGroup<BattleData>("BattleData").FirstOrDefault((BattleData a) => string.Equals((a).name, args.Trim(), StringComparison.CurrentCultureIgnoreCase));
                    if ((battleData))
                    {
                        CampaignNode item = Campaign.FindCharacterNode(References.Player);
                        int num = campaign.nodes.IndexOf(item);
                        CampaignNode campaignNode = null;
                        for (int i = num; i < campaign.nodes.Count; i++)
                        {
                            CampaignNode campaignNode2 = campaign.nodes[i];
                            if (!campaignNode2.cleared && campaignNode2.type.isBattle)
                            {
                                campaignNode = campaignNode2;
                                break;
                            }
                        }
                        if (campaignNode != null)
                        {
                            campaignNode.data = new Dictionary<string, object>
                            {
                                ["battle"] = (battleData).name,
                                ["waves"] = battleData.generationScript.Run(battleData, 1000)
                            };
                        }
                        else
                        {
                            Fail("There are no more battles!");
                        }
                    }
                    else
                    {
                        Fail("Battle [" + args + "] does not exist!");
                    }
                }
                else
                {
                    Fail("You must provide a battle name");
                }
            }
            else
            {
                Fail("You must be mid-run to use this command");
            }
        }

        public override IEnumerator GetArgOptions(string currentArgs)
        {
            yield return AddressableLoader.LoadGroup("BattleData");
            IEnumerable<BattleData> source = from a in AddressableLoader.GetGroup<BattleData>("BattleData")
                                             where (a).name.ToLower().Contains(currentArgs.ToLower())
                                             select a;
            predictedArgs = source.Select((BattleData upgradeData) => (upgradeData).name).ToArray();
        }
    }

    public class CommandProgressGain : Command
    {
        public override string id => "progress gain";

        public override string format => "progress gain <amount>";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            MetaprogressSequence metaprogressSequence = Object.FindObjectOfType<MetaprogressSequence>();
            float result;
            if (metaprogressSequence == null)
            {
                Fail("You must be on the end screen to use this command");
            }
            else if (metaprogressSequence.running)
            {
                Fail("Wait for current progress sequence to end please");
            }
            else if (float.TryParse(args.Trim(), out result))
            {
                ((MonoBehaviour)metaprogressSequence).StartCoroutine(metaprogressSequence.Sequence(result));
            }
            else
            {
                Fail("Invalid progress amount");
            }
        }
    }

    public class CommandProgressReset : Command
    {
        public override string id => "progress reset";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            SaveSystem.DeleteProgress();
        }
    }

    public class LoadModCommand : Command
    {
        public override string format => "loadmod modguid";

        public override string id => "loadmod";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            string text = args.Split(' ')[0];
            foreach (WildfrostMod mod in Bootstrap.Mods)
            {
                if (mod.GUID == text)
                {
                    mod.ModLoad();
                    break;
                }
            }
        }
    }

    public class PublishMod : Command
    {
        public override string format => "publish modguid";

        public override string id => "publish";

        public override bool IsRoutine => false;

        public override async void Run(string args)
        {
            string text = args.Split(' ')[0];
            foreach (WildfrostMod mod in Bootstrap.Mods)
            {
                if (mod.GUID == text)
                {
                    mod.UpdateOrPublishWorkshop();
                    break;
                }
            }
        }
    }

    public class UnLoadModCommand : Command
    {
        public override string format => "unloadmod modguid";

        public override string id => "unloadmod";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            string text = args.Split(' ')[0];
            foreach (WildfrostMod mod in Bootstrap.Mods)
            {
                if (mod.GUID == text)
                {
                    mod.ModUnload();
                    break;
                }
            }
        }
    }

    public class CommandScreenshot : Command
    {
        public override string id => "screenshot";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            string text = Application.persistentDataPath + "/Screenshots";
            if (!Directory.Exists(text))
            {
                Directory.CreateDirectory(text);
            }
            string[] files = Directory.GetFiles(text, "screen*.png");
            int num = 0;
            string[] array = files;
            for (int i = 0; i < array.Length; i++)
            {
                if (int.TryParse(array[i].Split(new string[1] { "screen" }, StringSplitOptions.None)[1].Replace(".png", ""), out var result))
                {
                    num = Mathf.Max(num, result);
                }
            }
            ScreenCapture.CaptureScreenshot($"{text}/screen{num + 1}.png");
        }
    }

    public class CommandBlood : Command
    {
        public readonly Dictionary<string, string> colours = new Dictionary<string, string>
        {
            { "red", "#E04141" },
            { "berry", "#FD557E" },
            { "black", "#222929" },
            { "blue", "#639FF1" },
            { "green", "#B8CC4B" },
            { "purple", "#392463" },
            { "pink", "#FE69FF" },
            { "snow", "#A9D5E9" }
        };

        public override string id => "blood";

        public override string format => "blood <color> <amount>";

        public override bool IsRoutine => true;

        public override IEnumerator Routine(string args)
        {
            string[] array = args.Split(' ');
            string obj = ((array.Length == 0) ? "" : (colours.ContainsKey(array[0]) ? colours[array[0]] : array[0]));
            int result = 1;
            if (array.Length > 1)
            {
                int.TryParse(array[1].Trim(), out result);
            }
            if (result < 1)
            {
                result = 1;
            }
            float num = Mathf.Min((float)(result - 1) * 0.05f, 1f);
            Color color = default(Color);
            bool setColor = ColorUtility.TryParseHtmlString(obj, ref color);
            Routine.Clump clump = new Routine.Clump();
            for (int i = 0; i < result; i++)
            {
                Vector3 pos = Cursor3d.Position + PettyRandom.Vector3() * num;
                clump.Add(Create(pos, setColor, color));
            }
            yield return clump.WaitForEnd();
        }

        public static IEnumerator Create(Vector3 pos, bool setColor, Color color)
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_0008: Unknown result type (might be due to invalid IL or missing references)
            //IL_0015: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            AsyncOperationHandle<GameObject> handle = AddressableLoader.InstantiateAsync("SplatterParticle", pos, Quaternion.identity);
            yield return handle;
            if (setColor && (handle.Result))
            {
                SplatterParticle component = handle.Result.GetComponent<SplatterParticle>();
                if (component != null)
                {
                    component.color = color;
                }
            }
        }

        public override IEnumerator GetArgOptions(string currentArgs)
        {
            predictedArgs = colours.Keys.Where((string a) => a.Contains(currentArgs.ToLower())).ToArray();
            yield break;
        }
    }

    public class CommandRunFinalBossScript : Command
    {
        public override string id => "finalbosstest";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            PlayerData playerData = References.PlayerData;
            if (playerData != null)
            {
                FinalBossDeckGenerationSystem.SetNewBoss(playerData);
            }
            else
            {
                Fail("Cannot use this command here");
            }
        }
    }

    public class CommandDailyReset : Command
    {
        public override string id => "daily reset";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            SaveSystem.DeleteProgressData("dailyPlayed");
        }
    }

    public class CommandDailyOffset : Command
    {
        public override string id => "daily offset";

        public override string format => "daily offset <days>";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            if (int.TryParse(args, out var result))
            {
                DailyFetcher.DayOffset = result;
                Object.FindObjectOfType<BalloonSequence>()?.Close();
            }
            else
            {
                Fail("Pls provide number of offset days");
            }
        }
    }

    public class CommandEncrypt : Command
    {
        public override string id => "encrypt";

        public override string format => "encrypt";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            Encrypt("Save.sav");
            Encrypt("Campaign.sav");
            Encrypt("CampaignDemo.sav");
            Encrypt("CampaignDaily.sav");
            Encrypt("Stats.sav");
            Encrypt("History.sav");
        }

        public static void Encrypt(string fileName)
        {
            string text = SaveSystem.folderName + "/Decrypt/" + fileName;
            if (ES3.FileExists(text, ES3Settings.defaultSettings))
            {
                byte[] array = ES3.LoadRawBytes(text, ES3Settings.defaultSettings);
                string text2 = SaveSystem.folderName + "/" + fileName;
                ES3.SaveRaw(array, text2, SaveSystem.settings);
                Debug.Log(("Re-encrypted [" + fileName + "]"));
            }
            else
            {
                Debug.Log(("[" + text + "] does not exist!"));
            }
        }
    }

    public class CommandDecrypt : Command
    {
        public override string id => "decrypt";

        public override string format => "decrypt";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            Decrypt("Save.sav");
            Decrypt("Campaign.sav");
            Decrypt("CampaignDemo.sav");
            Decrypt("CampaignDaily.sav");
            Decrypt("CampaignTutorial.sav");
            Decrypt("Stats.sav");
            Decrypt("History.sav");
        }

        public static void Decrypt(string fileName)
        {
            string text = SaveSystem.folderName + "/" + fileName;
            if (ES3.FileExists(text, SaveSystem.settings))
            {
                byte[] array = ES3.LoadRawBytes(text, SaveSystem.settings);
                string text2 = SaveSystem.folderName + "/Decrypt/" + fileName;
                ES3.SaveRaw(array, text2, ES3Settings.defaultSettings);
                Debug.Log(("Decrypted [" + fileName + "] to [" + text2 + "]"));
            }
            else
            {
                Debug.Log(("[" + text + "] does not exist!"));
            }
        }
    }

    public class CommandDisplay : Command
    {
        public override string id => "resolution";

        public override string format => "resolution <width> <height>";

        public override bool IsRoutine => false;

        public override void Run(string args)
        {
            string[] array = args.Split(' ');
            if (array.Length > 1 && int.TryParse(array[0].Trim(), out var result) && int.TryParse(array[1].Trim(), out var result2))
            {
                ScreenSystem.SetResolutionWindowed(result, result2);
            }
            else
            {
                Fail("Incorrect format. Should be written as \"resolution <width> <height>\"");
            }
        }
    }

    [SerializeField]
    public KeyCode[] toggle = (KeyCode[])(object)new KeyCode[2]
    {
        (KeyCode)96,
        (KeyCode)293
    };

    [SerializeField]
    public KeyCode takePredict = (KeyCode)9;

    [SerializeField]
    public Color logColor;

    [SerializeField]
    public Color logErrorColor;

    [SerializeField]
    public string unknownCommandFormat = "Unknown Command: {0}";

    [SerializeField]
    public Canvas canvas;

    [SerializeField]
    public TMP_InputField input;

    [SerializeField]
    public TMP_Text textPrefab;

    [SerializeField]
    public Transform log;

    [SerializeField]
    public GameObject helpWindow;

    [SerializeField]
    public TMP_Text helpText;

    [SerializeField]
    public ConsoleArgsDisplay argsDisplay;

    [Header("Saving Commands")]
    [SerializeField]
    public KeyCode[] saveKeys;

    [SerializeField]
    public string saveFileName;

    [SerializeField]
    public string[] savedCommands;

    public static readonly List<string> previous = new List<string>();

    public int preIndex;

    public static List<Command> commands;

    public static bool active;

    public static Entity hover;

    public static CardSlot slotHover;

    public bool promptUpdatePredict;

    public void Start()
    {
        LoadCommands();
        ((Component)canvas).gameObject.SetActive(false);
        Commands();
        PopulateHelp();
        helpWindow.SetActive(false);
        StartCoroutine(UpdatePredictRoutine());
    }

    public IEnumerator UpdatePredictRoutine()
    {
        while (true)
        {
            if (promptUpdatePredict)
            {
                promptUpdatePredict = false;
                yield return PredictArgsRoutine(input.text);
            }
            yield return null;
        }
    }

    public void OnEnable()
    {
        Events.OnEntityHover += Hover;
        Events.OnSlotHover += SlotHover;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= Hover;
        Events.OnSlotHover -= SlotHover;
    }

    public static void Hover(Entity entity)
    {
        hover = entity;
    }

    public static void SlotHover(CardSlot slot)
    {
        slotHover = slot;
    }

    public void Update()
    {
        if (CheckToggle())
        {
            return;
        }
        if (active)
        {
            if (Input.GetKeyDown((KeyCode)27))
            {
                Toggle();
            }
            else if (!CheckTakePredict())
            {
                CheckScrollPrevious();
                CheckRunCommand();
                CheckSaveCommand();
                KeepFocus();
            }
        }
        else
        {
            CheckRunSavedCommands();
        }
    }

    public bool CheckToggle()
    {
        if (((IEnumerable<KeyCode>)toggle).Any((Func<KeyCode, bool>)Input.GetKeyDown))
        {
            Toggle();
            return true;
        }
        return false;
    }

    public bool CheckTakePredict()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        if (Input.GetKeyDown(takePredict) && argsDisplay.Count > 0)
        {
            Command exactCommand = GetExactCommand(input.text.TrimStart());
            if (exactCommand != null)
            {
                input.text = exactCommand.id + " " + argsDisplay.TopArgument;
            }
            else
            {
                input.text = argsDisplay.TopCommand;
            }
            input.MoveToEndOfLine(false, false);
            return true;
        }
        return false;
    }

    public void CheckScrollPrevious()
    {
        if (Input.GetKeyDown((KeyCode)273))
        {
            if (previous.Count > 0)
            {
                preIndex = Mathf.Min(preIndex + 1, previous.Count - 1);
                input.text = previous[preIndex];
            }
            input.MoveToEndOfLine(false, false);
        }
        else if (Input.GetKeyDown((KeyCode)274))
        {
            if (previous.Count > 0)
            {
                preIndex = Mathf.Max(preIndex - 1, 0);
                input.text = previous[preIndex];
            }
            input.MoveToEndOfLine(false, false);
        }
    }

    public void CheckRunCommand()
    {
        if (Input.GetKeyDown((KeyCode)13))
        {
            string text = input.text.Trim();
            if (text.Length > 0)
            {
                new Routine(HandleCommand(text));
                input.text = "";
                preIndex = -1;
            }
        }
    }

    public void CheckSaveCommand()
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        for (int i = 0; i < saveKeys.Length; i++)
        {
            KeyCode val = saveKeys[i];
            if (!Input.GetKeyDown(val))
            {
                continue;
            }
            string text = input.text.Trim();
            if (text.Length > 0)
            {
                savedCommands[i] = text;
                Log($"Command '{text}' Saved to {val}");
                SaveCommands();
                input.text = "";
                preIndex = -1;
            }
            else if (savedCommands.Length > i)
            {
                string text2 = savedCommands[i];
                if (text2.Length > 0)
                {
                    new Routine(HandleCommand(text2));
                    input.text = "";
                    preIndex = -1;
                }
            }
        }
    }

    public void KeepFocus()
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Expected O, but got Unknown
        if (!input.isFocused)
        {
            EventSystem current = EventSystem.current;
            if (current != null)
            {
                current.SetSelectedGameObject(((Component)input).gameObject, (BaseEventData)null);
                input.OnPointerClick(new PointerEventData(current));
            }
        }
    }

    public void CheckRunSavedCommands()
    {
        int num = Mathf.Min(saveKeys.Length, savedCommands.Length);
        for (int i = 0; i < num; i++)
        {
            if (Input.GetKeyDown(saveKeys[i]))
            {
                string text = savedCommands[i];
                if (text.Length > 0)
                {
                    new Routine(HandleCommand(text));
                }
            }
        }
    }

    public static void Commands()
    {
        commands = new List<Command>
        {
            new CommandHelp(),
            new CommandGainCard(),
            new CommandGainUpgrade(),
            new CommandGainGold(),
            new CommandSetHealth(),
            new CommandSetAttack(),
            new CommandSetCounter(),
            new CommandAddStatus(),
            new CommandAddUpgrade(),
            new CommandHit(),
            new CommandKill(),
            new CommandKillAll(),
            new CommandDestroy(),
            new CommandDestroyAll(),
            new CommandSpawn(),
            new CommandBattleWin(),
            new CommandBattleLose(),
            new CommandBattleSkip(),
            new CommandBattleAuto(),
            new CommandSkipTurn(),
            new CommandMapJump(),
            new CommandMapInfo(),
            new CommandSystemDisable(),
            new CommandSystemEnable(),
            new CommandGameSpeed(),
            new CommandSetSaveProfile(),
            new CommandVolume(),
            new CommandVolume("Music"),
            new CommandVolume("Sfx"),
            new CommandVolume("Ambience"),
            new CommandToggleHUD(),
            new CommandToggleFps(),
            new CommandToggleHandOverlay(),
            new CommandCursor(),
            new CommandReroll(),
            new CommandRepeat(),
            new CommandPrompt(),
            new CommandPromptHide(),
            new CommandErrorTest(),
            new CommandPanSpeed(),
            new CommandNextBattle(),
            new CommandProgressGain(),
            new CommandProgressReset(),
            new CommandScreenshot(),
            new CommandBlood(),
            new CommandRunFinalBossScript(),
            new CommandDailyReset(),
            new CommandDailyOffset(),
            new CommandEncrypt(),
            new CommandDecrypt(),
            new CommandDisplay(),
            new LoadModCommand(),
            new UnLoadModCommand(),
            new PublishMod()
        };
    }

    public void SaveCommands()
    {
        File.WriteAllLines(Application.persistentDataPath + "\\" + saveFileName, savedCommands);
    }

    public void LoadCommands()
    {
        string path = Application.persistentDataPath + "\\" + saveFileName;
        if (File.Exists(path))
        {
            savedCommands = File.ReadAllLines(path);
            return;
        }
        savedCommands = new string[saveKeys.Length];
        savedCommands[0] = "repeat";
    }

    public static IEnumerator HandleCommand(string text)
    {
        Debug.Log(text);
        bool commandFound = false;
        if (commands == null)
        {
            Commands();
        }
        for (int num = commands.Count - 1; num >= 0; num--)
        {
            Command command = commands[num];
            if (text.StartsWith(command.id))
            {
                commandFound = true;
                string args = text.Replace(command.id, "").Trim();
                command.success = true;
                if (command.IsRoutine)
                {
                    yield return command.Routine(args);
                }
                else
                {
                    command.Run(args);
                }
                if (command.success && command.logOnSuccess)
                {
                    Log(text);
                }
                break;
            }
        }
        if (!commandFound)
        {
            LogError(string.Format(MonoBehaviourSingleton<Console>.instance.unknownCommandFormat, text));
        }
        previous.Insert(0, text);
    }

    public static void Log(string text)
    {
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        TMP_Text obj = Object.Instantiate<TMP_Text>(MonoBehaviourSingleton<Console>.instance.textPrefab, MonoBehaviourSingleton<Console>.instance.log);
        obj.text = text;
        ((Graphic)obj).color = MonoBehaviourSingleton<Console>.instance.logColor;
        ((Component)obj).gameObject.SetActive(true);
    }

    public static void LogError(string text)
    {
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        TMP_Text obj = Object.Instantiate<TMP_Text>(MonoBehaviourSingleton<Console>.instance.textPrefab, MonoBehaviourSingleton<Console>.instance.log);
        obj.text = text;
        ((Graphic)obj).color = MonoBehaviourSingleton<Console>.instance.logErrorColor;
        ((Component)obj).gameObject.SetActive(true);
    }

    public void PredictArgs()
    {
        promptUpdatePredict = true;
    }

    public IEnumerator PredictArgsRoutine(string text)
    {
        text = text.TrimStart();
        if (text.Length > 0)
        {
            yield return (object)new WaitForEndOfFrame();
            yield return null;
            Command[] array = commands.Where((Command a) => a.id.StartsWith(text)).ToArray();
            int num = array.Length;
            Bounds bounds = input.textComponent.textBounds;
            float x = 10f;
            if (num > 0)
            {
                argsDisplay.Show();
                argsDisplay.DisplayCommands(array.OrderByDescending((Command a) => a.id.Length).ToArray());
                argsDisplay.MoveTo(x);
            }
            else
            {
                Command exactCommand = GetExactCommand(text);
                if (exactCommand != null)
                {
                    string args = text.Replace(exactCommand.id + " ", "");
                    yield return exactCommand.GetArgOptions(args);
                    if (exactCommand.predictedArgs != null && exactCommand.predictedArgs.Length != 0)
                    {
                        argsDisplay.Show();
                        string[] array2 = exactCommand.predictedArgs.Where((string a) => string.Equals(a, args, StringComparison.CurrentCultureIgnoreCase)).ToArray();
                        if (array2.Length != 0)
                        {
                            argsDisplay.DisplayArgs(array2);
                        }
                        else
                        {
                            argsDisplay.DisplayArgs(exactCommand.predictedArgs.OrderByDescending((string a) => a.Length).ToArray());
                        }
                        argsDisplay.MoveTo(x + 10f + ((bounds)).size.x);
                    }
                    else
                    {
                        argsDisplay.Hide();
                    }
                }
                else
                {
                    argsDisplay.Hide();
                }
            }
            bounds = default(Bounds);
        }
        else
        {
            argsDisplay.Hide();
        }
        yield return null;
    }

    public static Command GetExactCommand(string text)
    {
        return commands.FirstOrDefault((Command a) => text.StartsWith(a.id + " "));
    }

    public void Toggle()
    {
        active = !active;
        ((Component)canvas).gameObject.SetActive(active);
        if (active)
        {
            preIndex = -1;
            InputSystem.Disable();
        }
        else
        {
            input.text = "";
            InputSystem.Enable();
        }
    }

    public static void ToggleHelp()
    {
        MonoBehaviourSingleton<Console>.instance.helpWindow.SetActive(!MonoBehaviourSingleton<Console>.instance.helpWindow.activeSelf);
    }

    public void PopulateHelp()
    {
        string text = "";
        foreach (Command command in commands)
        {
            if (!command.hidden)
            {
                string text2 = command.format;
                if (command.desc.Length > 0)
                {
                    text2 = text2 + " <i><#fffd>" + command.desc + "</color></i>";
                }
                text = text + text2 + "\n";
            }
        }
        helpText.text = text.TrimEnd();
    }

    public Console()
    {
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        KeyCode[] array = new KeyCode[8];
        RuntimeHelpers.InitializeArray(array, (RuntimeFieldHandle)/*OpCode not supported: LdMemberToken*/);
        saveKeys = (KeyCode[])(object)array;
        saveFileName = "commands.sav";
        base..ctor();
    }
}
public class ConsoleArgsDisplay : MonoBehaviourRect
{
    [SerializeField]
    public TMP_Text textPrefab;

    [SerializeField]
    public int poolStartSize = 20;

    [SerializeField]
    public int maxItems = 30;

    public Queue<TMP_Text> pool = new Queue<TMP_Text>();

    public List<TMP_Text> outOfPool = new List<TMP_Text>();

    public Console.Command[] commands;

    public string[] current;

    public Vector2 targetPos;

    public int Count => current.Length;

    public string TopArgument => current.Last();

    public string TopCommand => commands.Last().id + ((commands.Last().format != commands.Last().id) ? " " : "");

    public void Awake()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        targetPos = base.rectTransform.anchoredPosition;
        for (int i = 0; i < poolStartSize; i++)
        {
            pool.Enqueue(Object.Instantiate<TMP_Text>(textPrefab, transform));
        }
    }

    public void Update()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        base.rectTransform.anchoredPosition = Delta.Lerp(base.rectTransform.anchoredPosition, targetPos, 0.1f, Time.deltaTime);
    }

    public void Show()
    {
        gameObject.SetActive(true);
    }

    public void Hide()
    {
        gameObject.SetActive(false);
    }

    public void MoveTo(float x)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        targetPos = Vector2Ext.WithX(targetPos, x);
    }

    public void DisplayCommands(Console.Command[] commands)
    {
        string[] array = commands.Select((Console.Command a) => a.format).ToArray();
        if (current == null || !array.SequenceEqual(current))
        {
            Create(array);
            current = array;
            this.commands = commands;
        }
    }

    public void DisplayArgs(string[] items)
    {
        if (current == null || !items.SequenceEqual(current))
        {
            Create(items);
            current = items;
        }
    }

    public void Clear()
    {
        foreach (TMP_Text item in outOfPool)
        {
            Pool(item);
        }
        outOfPool.Clear();
    }

    public void Create(string[] items)
    {
        Clear();
        int num = items.Length - 1;
        while (num >= 0 && Create(items[num]))
        {
            num--;
        }
    }

    public bool Create(string item)
    {
        bool result = false;
        if (outOfPool.Count < maxItems + 1)
        {
            TMP_Text val = ((pool.Count > 0) ? pool.Dequeue() : Object.Instantiate<TMP_Text>(textPrefab, transform));
            if (outOfPool.Count < maxItems)
            {
                val.text = item;
                val.transform.SetAsLastSibling();
                result = true;
            }
            else
            {
                val.text = "...";
                val.transform.SetAsLastSibling();
            }
            ((Component)val).gameObject.SetActive(true);
            outOfPool.Add(val);
        }
        return result;
    }

    public void Pool(TMP_Text inst)
    {
        pool.Enqueue(inst);
        ((Component)inst).gameObject.SetActive(false);
    }
}
public class ConsoleLog : MonoBehaviour
{
    [SerializeField]
    public TMP_Text textAsset;

    [SerializeField]
    public AnimationCurve fadeCurve;

    [SerializeField]
    public float fadeDuration = 4f;

    public float fade;

    public void OnEnable()
    {
        fade = 0f;
    }

    public void Update()
    {
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        fade += Time.deltaTime;
        if (fade > fadeDuration)
        {
            GameObjectExt.Destroy(gameObject);
        }
        else
        {
            ((Graphic)textAsset).color = ColorExt.With(((Graphic)textAsset).color, -1f, -1f, -1f, fadeCurve.Evaluate(fade / fadeDuration));
        }
    }
}
public class DebugMenu : MonoBehaviour
{
    [SerializeField]
    public GameObject menu;

    [SerializeField]
    public float holdTime = 2f;

    [SerializeField]
    public TMP_Text resultText;

    public float currentHoldTime;

    public bool active;

    public void Update()
    {
        if (active)
        {
            return;
        }
        if (CheckMouse() || CheckController())
        {
            currentHoldTime += Time.unscaledDeltaTime;
            if (currentHoldTime > holdTime)
            {
                Activate();
            }
        }
        else
        {
            currentHoldTime = 0f;
        }
    }

    public static bool CheckMouse()
    {
        if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            if (!Input.GetKey((KeyCode)32))
            {
                return Input.GetKey((KeyCode)325);
            }
            return true;
        }
        return false;
    }

    public static bool CheckController()
    {
        if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            if (!InputSystem.IsButtonHeld("Backpack") || !InputSystem.IsButtonHeld("Redraw Bell"))
            {
                if (InputSystem.IsButtonHeld("Up"))
                {
                    return InputSystem.IsButtonHeld("Down");
                }
                return false;
            }
            return true;
        }
        return false;
    }

    public void Activate()
    {
        active = true;
        menu.gameObject.SetActive(true);
        resultText.text = "";
    }

    public void Deactivate()
    {
        active = false;
        menu.gameObject.SetActive(false);
    }

    public void DeleteSave()
    {
        int value = SaveSystem.LoadProgressData("tutorialProgress", 0);
        string value2 = SaveSystem.LoadProgressData("version", "0");
        SaveSystem.DeleteProgress();
        SaveSystem.DeleteCampaign(AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal"));
        SaveSystem.SaveProgressData("tutorialProgress", value);
        SaveSystem.SaveProgressData("version", value2);
        resultText.text = "Save Data Deleted!";
    }

    public void ResetTutorial()
    {
        SaveSystem.DeleteProgressData("tutorialProgress");
        resultText.text = "Tutorial Reset!";
    }

    public void RunCommand(string command)
    {
        new Routine(Console.HandleCommand(command));
        resultText.text = command;
    }
}
public class FpsDrawer : MonoBehaviour
{
    public TextMeshProUGUI fpsText;

    [SerializeField]
    public bool @default = true;

    public float deltaTime;

    public void Awake()
    {
        if (!Settings.Load("ShowFps", @default))
        {
            gameObject.SetActive(false);
        }
        Events.OnSettingChanged += SettingChanged;
    }

    public void OnDestroy()
    {
        Events.OnSettingChanged -= SettingChanged;
    }

    public void SettingChanged(string key, object value)
    {
        if (key == "ShowFps" && value is bool active)
        {
            gameObject.SetActive(active);
        }
    }

    public void Update()
    {
        deltaTime += (Time.unscaledDeltaTime - deltaTime) * 0.1f;
        float num = 1f / deltaTime;
        ((TMP_Text)fpsText).text = $"{Mathf.Ceil(num)}\n{Random.seed}";
    }
}
public class DeckDisplay : MonoBehaviour
{
    [SerializeField]
    public Character owner;

    public DeckDisplaySequence displaySequence;

    public CompanionLimitSequence companionLimitSequence;

    public CompanionRecoverSequence companionRecoverSequence;

    [SerializeField]
    public CardController[] cardControllers;

    [SerializeField]
    public CardContainer[] cardContainers;

    public UINavigationItem backButtonNavigationItem;

    public void SetOwner(Character owner)
    {
        this.owner = owner;
        displaySequence.owner = owner;
        CardController[] array = cardControllers;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].owner = owner;
        }
        CardContainer[] array2 = cardContainers;
        for (int i = 0; i < array2.Length; i++)
        {
            array2[i].owner = owner;
        }
        if (companionLimitSequence != null)
        {
            companionLimitSequence.owner = owner;
        }
        if (companionRecoverSequence != null)
        {
            companionRecoverSequence.owner = owner;
        }
    }
}
public class Dice : MonoBehaviour
{
    public int value = -1;

    [SerializeField]
    public Rigidbody2D rb;

    [SerializeField]
    public SpriteRenderer spriteRenderer;

    [SerializeField]
    public Vector2 throwSpeed = new Vector2(20f, 40f);

    [SerializeField]
    public Vector2 spinAmount = new Vector2(4f, 6f);

    [SerializeField]
    public Vector2 drag = new Vector2(5f, 6f);

    [Header("Faces")]
    [SerializeField]
    public Sprite[] faceSprites;

    [SerializeField]
    public int[] faceValues = new int[6] { 1, 2, 3, 4, 5, 6 };

    public void Roll()
    {
        int num = faceValues.Length - 1;
        int num2 = Random.Range(0, num);
        value = faceValues[num2];
        Sprite sprite = faceSprites[num2];
        spriteRenderer.sprite = sprite;
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Throw()
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        Dice[] array = Object.FindObjectsOfType<Dice>();
        foreach (Dice dice in array)
        {
            Vector3 val = Vector3.zero - ((Component)dice).transform.position;
            Vector3 normalized = ((val)).normalized;
            dice.Throw((normalized));
        }
    }

    public void Throw(Vector2 direction)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        rb.drag = Vector2Ext.Random(drag);
        rb.angularDrag = Vector2Ext.Random(drag);
        rb.velocity = direction * Vector2Ext.Random(throwSpeed);
        Rigidbody2D obj = rb;
        Vector2 velocity = rb.velocity;
        obj.angularVelocity = ((velocity)).magnitude * Vector2Ext.Random(spinAmount);
        Roll();
    }

    public void DisableCollisions()
    {
        rb.simulated = false;
    }
}
public class DisableForReleaseBuild : MonoBehaviour
{
    [SerializeField]
    public bool disableGameObject = true;

    [SerializeField]
    public bool disableComponent;

    public void OnEnable()
    {
        if (disableGameObject)
        {
            gameObject.SetActive(false);
        }
        if (disableComponent)
        {
            enabled = false;
        }
    }
}
public class DisableIf : MonoBehaviour
{
    [SerializeField]
    public bool not;

    [SerializeField]
    public bool RELEASE;

    [SerializeField]
    public bool DEMO;

    [SerializeField]
    public bool CHALLENGES;

    [SerializeField]
    public bool BATTLE_LOG;

    [SerializeField]
    public bool ANALYTICS;

    [SerializeField]
    public bool JOURNAL_PAGES;

    [SerializeField]
    public bool HARD_MODE;

    [SerializeField]
    public bool CANNOT_EXIT;

    [SerializeField]
    public bool BETA;

    [SerializeField]
    public bool NEW_FROST_BELLS;

    [SerializeField]
    public bool destroy;

    public void OnEnable()
    {
        bool flag = false;
        if (RELEASE)
        {
            flag = true;
        }
        if (CHALLENGES)
        {
            flag = true;
        }
        if (BATTLE_LOG)
        {
            flag = true;
        }
        if (JOURNAL_PAGES)
        {
            flag = true;
        }
        if (NEW_FROST_BELLS)
        {
            flag = true;
        }
        if ((not && !flag) || (!not && flag))
        {
            Disable();
        }
    }

    public void Disable()
    {
        if (destroy)
        {
            GameObjectExt.DestroyImmediate(gameObject);
        }
        else
        {
            gameObject.SetActive(false);
        }
    }
}
public class DisableWhenDeckpackOpened : MonoBehaviour
{
    [SerializeField]
    public Behaviour[] components;

    [SerializeField]
    public GameObject[] gameObjects;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnDeckpackOpen += new UnityAction(Open);
        Events.OnDeckpackClose += new UnityAction(Close);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnDeckpackOpen -= new UnityAction(Open);
        Events.OnDeckpackClose -= new UnityAction(Close);
    }

    public void Open()
    {
        Behaviour[] array = components;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].enabled = false;
        }
        GameObject[] array2 = gameObjects;
        for (int i = 0; i < array2.Length; i++)
        {
            array2[i].SetActive(false);
        }
    }

    public void Close()
    {
        Behaviour[] array = components;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].enabled = true;
        }
        GameObject[] array2 = gameObjects;
        for (int i = 0; i < array2.Length; i++)
        {
            array2[i].SetActive(true);
        }
    }
}
public class Discarder : MonoBehaviour
{
    public void Discard(Entity entity)
    {
        CoroutineManager.Start(ClearStatusEffects(entity));
        entity.counter.current = entity.counter.max;
        entity.uses.current = entity.uses.max;
        entity.PromptUpdate();
    }

    public static IEnumerator ClearStatusEffects(Entity entity)
    {
        Debug.Log($"DISCARDER → Clearing Status Effects [{entity}]");
        int count = entity.statusEffects.Count;
        for (int i = count - 1; i >= 0; i--)
        {
            StatusEffectData statusEffectData = entity.statusEffects[i];
            if ((statusEffectData) && statusEffectData.removeOnDiscard)
            {
                yield return statusEffectData.Remove();
            }
        }
    }
}
public class EnableIfSetting : MonoBehaviour
{
    public enum Type
    {
        Bool,
        String,
        Int,
        FloatMin,
        FloatMax
    }

    [SerializeField]
    public string key;

    [SerializeField]
    public Type type;

    [SerializeField]
    [ShowIf("TypeBool")]
    public bool expectedBool = true;

    [SerializeField]
    [ShowIf("TypeBool")]
    public bool defaultBool;

    [SerializeField]
    [ShowIf("TypeString")]
    public string expectedString;

    [SerializeField]
    [ShowIf("TypeString")]
    public string defaultString;

    [SerializeField]
    [ShowIf("TypeInt")]
    public string expectedInt;

    [SerializeField]
    [ShowIf("TypeInt")]
    public string defaultInt;

    [SerializeField]
    [ShowIf("TypeFloatMin")]
    public float minFloat;

    [SerializeField]
    [ShowIf("TypeFloatMax")]
    public float maxFloat;

    [SerializeField]
    [ShowIf("TypeFloat")]
    public float defaultFloat;

    public bool TypeBool => type == Type.Bool;

    public bool TypeString => type == Type.String;

    public bool TypeInt => type == Type.Int;

    public bool TypeFloat
    {
        get
        {
            Type type = this.type;
            return type == Type.FloatMin || type == Type.FloatMax;
        }
    }

    public bool TypeFloatMin => type == Type.FloatMin;

    public bool TypeFloatMax => type == Type.FloatMax;

    public void Awake()
    {
        switch (type)
        {
            case Type.Bool:
                gameObject.SetActive(Settings.Load(key, defaultBool) == expectedBool);
                break;
            case Type.String:
                gameObject.SetActive(Settings.Load(key, defaultString) == expectedString);
                break;
            case Type.Int:
                gameObject.SetActive(Settings.Load(key, defaultInt) == expectedInt);
                break;
            case Type.FloatMin:
                gameObject.SetActive(Settings.Load(key, defaultFloat) >= minFloat);
                break;
            case Type.FloatMax:
                gameObject.SetActive(Settings.Load(key, defaultFloat) <= maxFloat);
                break;
        }
    }
}
public class Card : EntityDisplay
{
    public enum PlayType
    {
        None,
        Play,
        Place
    }

    [SerializeField]
    public Vector2 baseSize = new Vector2(740f, 1100f);

    public int frameLevel;

    [Required(null)]
    public Canvas canvas;

    [Required(null)]
    public CanvasGroup canvasGroup;

    [Required(null)]
    [BoxGroup("Text Elements")]
    public TextMeshProUGUI titleText;

    [Required(null)]
    [BoxGroup("Text Elements")]
    public TextMeshProUGUI descText;

    [Required(null)]
    [BoxGroup("Images")]
    public Image mainImage;

    [Required(null)]
    [BoxGroup("Images")]
    public Image backImage;

    [Required(null)]
    [BoxGroup("Images")]
    public Image backgroundImage;

    [Required(null)]
    [BoxGroup("Images")]
    public Image frameImage;

    [Required(null)]
    [BoxGroup("Images")]
    public CardFrameSetter frameSetter;

    [Required(null)]
    [SerializeField]
    public UINavigationItem uINavigationItem;

    [Required(null)]
    [SerializeField]
    public GameObject frontGroup;

    [Required(null)]
    [SerializeField]
    public GameObject backGroup;

    public UpgradeHolder charmHolder;

    public UpgradeHolder tokenHolder;

    public UpgradeHolder crownHolder;

    public ItemHolderPetCreator itemHolderPet;

    public LargeUIScaleUpdater[] scalers;

    [BoxGroup("Idle Animation")]
    public CardIdleAnimation imageIdleAnimator;

    [BoxGroup("Idle Animation")]
    public CardIdleAnimation backgroundIdleAnimator;

    public int currentEffectBonus;

    public float currentEffectFactor;

    public bool currentSilenced;

    public HashSet<KeywordData> keywords = new HashSet<KeywordData>();

    public HashSet<CardData> mentionedCards;

    public bool hasScriptableImage;

    [SerializeField]
    public ScriptableCardImage scriptableImage;

    public void FlipUp()
    {
        backGroup.SetActive(false);
        frontGroup.SetActive(true);
    }

    public void FlipDown()
    {
        backGroup.SetActive(true);
        frontGroup.SetActive(false);
    }

    public override Canvas GetCanvas()
    {
        return canvas;
    }

    public override IEnumerator UpdateData(bool doPing = false)
    {
        name = (entity.data).name;
        Debug.Log(("Updating Data for [" + name + "]"));
        entity.damage.current = entity.data.damage;
        entity.damage.max = entity.data.damage;
        entity.hp.current = entity.data.hp;
        entity.hp.max = entity.data.hp;
        entity.counter.current = entity.data.counter;
        entity.counter.max = entity.data.counter;
        entity.uses.current = entity.data.uses;
        entity.uses.max = entity.data.uses;
        entity.effectBonus = entity.data.effectBonus;
        entity.effectFactor = entity.data.effectFactor;
        backgroundImage.sprite = entity.data.backgroundSprite;
        Vector2 val = Vector2.one;
        if ((entity.data.mainSprite))
        {
            mainImage.sprite = entity.data.mainSprite;
            Rect rect = mainImage.sprite.rect;
            val = ((rect)).size / baseSize;
        }
        float num = Vector2Ext.Max(val);
        Transform val2 = ((Component)mainImage).transform;
        val2.localScale = (new Vector2(num, num));
        val2.localPosition = (new Vector2(0f, val.y - 1f));
        int num2 = ((!(entity.owner) || entity.owner.team == 1) ? 1 : (-1));
        TransformExt.SetScaleX(val2, (float)num2 * val2.localScale.x);
        TransformExt.SetScaleX(((Component)backgroundImage).transform, (float)num2 * ((Component)backgroundImage).transform.localScale.x);
        if (hasScriptableImage)
        {
            foreach (Transform item in val2.parent)
            {
                Transform val3 = item;
                if (((Component)val3).gameObject != ((Component)mainImage).gameObject)
                {
                    GameObjectExt.Destroy(((Component)val3).gameObject);
                }
            }
            if (!(entity.data.scriptableImagePrefab))
            {
                ((Component)mainImage).gameObject.SetActive(true);
            }
        }
        if ((entity.data.scriptableImagePrefab))
        {
            hasScriptableImage = true;
            scriptableImage = Object.Instantiate<ScriptableCardImage>(entity.data.scriptableImagePrefab, ((Component)mainImage).transform.parent);
            scriptableImage.Assign(entity);
            Transform obj = ((Component)scriptableImage).transform;
            obj.localScale = ((obj.localScale) * new Vector2(num * (float)num2, num));
            Transform obj2 = ((Component)scriptableImage).transform;
            obj2.localPosition += new Vector3(0f, val.y - 1f, 0f);
            ((Component)mainImage).gameObject.SetActive(false);
        }
        SetName(entity.data.title);
        currentEffectBonus = entity.data.effectBonus;
        currentEffectFactor = entity.data.effectFactor;
        currentSilenced = entity.silenced;
        if (!entity.startingEffectsApplied)
        {
            entity.attackEffects = entity.data.attackEffects.Select((CardData.StatusEffectStacks a) => a.Clone()).ToList();
            entity.traits.Clear();
            foreach (CardData.TraitStacks trait in entity.data.traits)
            {
                entity.traits.Add(new Entity.TraitStacks(trait.data, trait.count));
            }
            CardData.StatusEffectStacks[] startWithEffects = entity.data.startWithEffects;
            foreach (CardData.StatusEffectStacks statusEffectStacks in startWithEffects)
            {
                yield return StatusEffectSystem.Apply(entity, null, statusEffectStacks.data, statusEffectStacks.count, temporary: false, null, fireEvents: true, applyEvenIfZero: true);
            }
            yield return entity.UpdateTraits();
            if (entity.data.injuries != null)
            {
                foreach (CardData.StatusEffectStacks injury in entity.data.injuries)
                {
                    yield return StatusEffectSystem.Apply(entity, null, injury.data, injury.count);
                }
            }
            entity.startingEffectsApplied = true;
        }
        SetDescription();
        if ((entity.data.idleAnimationProfile))
        {
            if ((imageIdleAnimator))
            {
                imageIdleAnimator.entity = entity;
            }
            if ((backgroundIdleAnimator))
            {
                backgroundIdleAnimator.entity = entity;
            }
        }
        charmHolder?.Clear();
        tokenHolder?.Clear();
        crownHolder?.Clear();
        List<CardUpgradeData> upgrades = entity.data.upgrades;
        if (upgrades != null && upgrades.Count > 0)
        {
            foreach (CardUpgradeData upgrade in entity.data.upgrades)
            {
                upgrade.Display(entity);
            }
        }
        yield return base.UpdateData(doPing);
    }

    public override IEnumerator UpdateDisplay(bool doPing = true)
    {
        yield return base.UpdateDisplay(doPing);
        bool flag = entity.effectBonus != currentEffectBonus || entity.effectFactor != currentEffectFactor || entity.silenced != currentSilenced;
        if (flag || promptUpdateDescription)
        {
            SetDescription();
            promptUpdateDescription = false;
            if (flag)
            {
                currentEffectBonus = entity.effectBonus;
                currentEffectFactor = entity.effectFactor;
                currentSilenced = entity.silenced;
                yield return StatusEffectSystem.EffectBonusChangedEvent(entity);
            }
        }
        if (hasScriptableImage)
        {
            scriptableImage.UpdateEvent();
        }
    }

    public void SetName()
    {
        SetName(entity.data.title);
    }

    public void SetName(string name)
    {
        string text = name;
        if (entity.data.injuries.Count > 0)
        {
            text = "<color=red>" + text + "</color>";
        }
        ((TMP_Text)titleText).text = text;
    }

    public void SetDescription()
    {
        string description = GetDescription(entity);
        keywords = Text.GetKeywords(description);
        mentionedCards = Text.GetMentionedCards(description);
        string text = Text.Process(description, entity.effectBonus, entity.effectFactor, entity.data.cardType.descriptionColours);
        AddInjuryText(ref text, entity.data);
        if (StringExt.IsNullOrWhitespace(text))
        {
            LocalizedString flavourKey = entity.data.flavourKey;
            if (flavourKey != null && !((LocalizedReference)flavourKey).IsEmpty)
            {
                string localizedString = entity.data.flavourKey.GetLocalizedString();
                text = "<i><color=#" + entity.data.cardType.descriptionColours.flavourColour + ">" + localizedString;
            }
        }
        if (StringExt.IsNullOrWhitespace(text))
        {
            ((TMP_Text)descText).text = "";
        }
        else
        {
            ((TMP_Text)descText).text = "<color=#" + entity.data.cardType.descriptionColours.textColour + ">" + text;
        }
    }

    public static string GetDescription(CardData data, bool silenced = false)
    {
        string text = "";
        AddAttackEffectText(ref text, data.attackEffects, silenced);
        AddCustomCardText(ref text, data, silenced);
        AddPassiveEffectText(ref text, data.startWithEffects, silenced);
        AddUpgradeText(ref text, data, silenced);
        AddTraitText(ref text, data, silenced);
        return text;
    }

    public static string GetDescription(Entity entity)
    {
        string text = "";
        AddAttackEffectText(ref text, entity.attackEffects, entity.silenced);
        AddCustomCardText(ref text, entity.data, entity.silenced);
        AddPassiveEffectText(ref text, entity.statusEffects, entity.silenced);
        AddUpgradeText(ref text, entity.data, entity.silenced);
        AddTraitText(ref text, entity);
        return text;
    }

    public static void AddAttackEffectText(ref string text, ICollection<CardData.StatusEffectStacks> attackEffects, bool silenced = false)
    {
        if (attackEffects.Count <= 0)
        {
            return;
        }
        Dictionary<string, string> dictionary = new Dictionary<string, string>();
        foreach (CardData.StatusEffectStacks attackEffect in attackEffects)
        {
            string applyFormat = attackEffect.data.GetApplyFormat();
            if (!StringExt.IsNullOrWhitespace(applyFormat) && !StringExt.IsNullOrWhitespace(attackEffect.data.keyword))
            {
                if (dictionary.ContainsKey(applyFormat))
                {
                    dictionary[applyFormat] += $", <{attackEffect.count}><keyword={attackEffect.data.keyword}>";
                }
                else
                {
                    dictionary[applyFormat] = $"<{attackEffect.count}><keyword={attackEffect.data.keyword}>";
                }
            }
            else if (!((LocalizedReference)attackEffect.data.textKey).IsEmpty)
            {
                dictionary.Add(attackEffect.data.GetDesc(attackEffect.count), "");
            }
        }
        foreach (KeyValuePair<string, string> item in dictionary)
        {
            if (!StringExt.IsNullOrWhitespace(text))
            {
                text += "\n";
            }
            string text2 = item.Key.Replace("{0}", item.Value);
            text += (silenced ? ("<s>" + text2 + "</s>") : text2);
        }
    }

    public static void AddCustomCardText(ref string text, CardData data, bool silenced = false)
    {
        if (data.HasCustomText)
        {
            if (!StringExt.IsNullOrWhitespace(text))
            {
                text += "\n";
            }
            text += data.GetCustomText(silenced);
        }
    }

    public static void AddPassiveEffectText(ref string text, ICollection<CardData.StatusEffectStacks> passiveEffects, bool silenced = false)
    {
        if (passiveEffects.Count <= 0)
        {
            return;
        }
        foreach (CardData.StatusEffectStacks passiveEffect in passiveEffects)
        {
            if (StringExt.IsNullOrWhitespace(passiveEffect.data.keyword) && passiveEffect.data.HasDesc)
            {
                if (!StringExt.IsNullOrWhitespace(text))
                {
                    text += "\n";
                }
                text += passiveEffect.data.GetDesc(passiveEffect.count, silenced);
            }
        }
    }

    public static void AddPassiveEffectText(ref string text, ICollection<StatusEffectData> passiveEffects, bool silenced = false)
    {
        if (passiveEffects.Count <= 0)
        {
            return;
        }
        foreach (StatusEffectData item in passiveEffects.OrderBy((StatusEffectData a) => a.textOrder))
        {
            if (StringExt.IsNullOrWhitespace(item.keyword) && item.HasDesc)
            {
                if (!StringExt.IsNullOrWhitespace(text))
                {
                    text += "\n";
                }
                text += item.GetDesc(item.count, silenced);
            }
        }
    }

    public static void AddUpgradeText(ref string text, CardData data, bool silenced = false)
    {
    }

    public static void AddTraitText(ref string text, CardData data, bool silenced = false)
    {
        if (data.traits == null || data.traits.Count <= 0)
        {
            return;
        }
        int count = data.traits.Count;
        string traitSeparator = GetTraitSeparator(count);
        string text2 = "";
        for (int i = 0; i < count; i++)
        {
            CardData.TraitStacks traitStacks = data.traits[i];
            text2 += GetTraitText(traitStacks.data, traitStacks.count, silenced);
            if (i < count - 1)
            {
                text2 += traitSeparator;
            }
        }
        if (!StringExt.IsNullOrWhitespace(text2))
        {
            text = text + "\n" + text2;
        }
    }

    public static void AddTraitText(ref string text, Entity entity)
    {
        if (entity.traits == null || entity.traits.Count <= 0)
        {
            return;
        }
        int count = entity.traits.Count;
        string traitSeparator = GetTraitSeparator(count);
        string text2 = "";
        for (int i = 0; i < count; i++)
        {
            Entity.TraitStacks traitStacks = entity.traits[i];
            text2 += GetTraitText(traitStacks.data, traitStacks.count, entity.silenced || traitStacks.silenced);
            if (i < count - 1)
            {
                text2 += traitSeparator;
            }
        }
        if (!StringExt.IsNullOrWhitespace(text2))
        {
            text = text + "\n" + text2;
        }
    }

    public static string GetTraitSeparator(int traitCount)
    {
        if (traitCount <= 2)
        {
            return "\n";
        }
        return ", ";
    }

    public static string GetTraitText(TraitData trait, int count, bool silenced = false)
    {
        string arg = (trait.keyword).name.ToLower();
        if (!silenced)
        {
            return $"<keyword={arg} {count}>";
        }
        return $"<keyword={arg} {count} silenced>";
    }

    public static void AddInjuryText(ref string text, CardData data)
    {
        int count = data.injuries.Count;
        if (count > 0)
        {
            if (!StringExt.IsNullOrWhitespace(text))
            {
                text += "\n";
            }
            text = text + "<color=red>" + MonoBehaviourSingleton<StringReference>.instance.injured.GetLocalizedString();
            if (count > 1)
            {
                text += $" {count}";
            }
            text += "</color>";
        }
    }

    public override void OnGetFromPool()
    {
        base.OnGetFromPool();
        imageIdleAnimator.OnGetFromPool();
        backgroundIdleAnimator.OnGetFromPool();
        LargeUIScaleUpdater[] array = scalers;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].PromptUpdate();
        }
    }

    public override void OnReturnToPool()
    {
        //IL_00d0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d6: Expected O, but got Unknown
        base.OnReturnToPool();
        FlipUp();
        imageIdleAnimator.OnReturnToPool();
        backgroundIdleAnimator.OnReturnToPool();
        if ((crownHolder))
        {
            crownHolder.Clear();
        }
        if ((charmHolder))
        {
            charmHolder.Clear();
        }
        if ((tokenHolder))
        {
            tokenHolder.Clear();
        }
        itemHolderPet.DestroyCurrent();
        canvasGroup.alpha = 1f;
        currentEffectBonus = 0;
        currentEffectFactor = 1f;
        currentSilenced = false;
        canvas.overrideSorting = false;
        if (!hasScriptableImage)
        {
            return;
        }
        foreach (Transform item in ((Component)mainImage).transform.parent)
        {
            Transform val = item;
            if (((Component)val).gameObject != ((Component)mainImage).gameObject)
            {
                GameObjectExt.Destroy(((Component)val).gameObject);
            }
        }
        ((Component)mainImage).gameObject.SetActive(true);
        hasScriptableImage = false;
    }

    public void OnDrawGizmos()
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_006b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0075: Unknown result type (might be due to invalid IL or missing references)
        Gizmos.color = Color.magenta;
        if (!entity.data.TryGetCustomData("splitOriginalId", out var value, 0uL))
        {
            return;
        }
        foreach (Entity card in References.Battle.cards)
        {
            if (card.data.id == value)
            {
                Vector3 position = base.transform.position;
                Vector3 position2 = card.transform.position;
                Gizmos.DrawLine(position, position2);
                Gizmos.DrawCube(position, Vector3.one * 0.5f);
            }
        }
    }
}
public class CharacterDisplay : EntityDisplay
{
    [SerializeField]
    public int team = 1;

    public GoldDisplay goldDisplay;

    [Space]
    public DeckDisplay deckDisplay;

    public HandOverlay handOverlay;

    public int currentEffectBonus;

    public float currentEffectFactor;

    public Character _character;

    public bool IsDeckpackOpen
    {
        get
        {
            if (!Deckpack.IsOpen)
            {
                return ((Component)deckDisplay.companionLimitSequence).gameObject.activeSelf;
            }
            return true;
        }
    }

    public Character character
    {
        get
        {
            if (!(_character))
            {
                _character = ((Component)entity).GetComponent<Character>();
            }
            return _character;
        }
    }

    public static void FindAndAssign(Character character)
    {
        CharacterDisplay[] array = Object.FindObjectsOfType<CharacterDisplay>();
        foreach (CharacterDisplay characterDisplay in array)
        {
            if (!(characterDisplay.entity) && characterDisplay.team == character.team)
            {
                characterDisplay.Assign(character);
                return;
            }
        }
        throw new Exception("Could not find CharacterDisplay for Character [" + (character).name + "]");
    }

    public void Assign(Character character)
    {
        Debug.Log($"[{(character).name}] assigned to {this}");
        entity = character.entity;
        deckDisplay?.SetOwner(character);
        handOverlay?.SetOwner(character);
        character.entity.display = this;
        character.entity.PromptUpdate();
    }

    public void UnAssign()
    {
        entity = null;
    }

    public override IEnumerator UpdateDisplay(bool doPingIcons = true)
    {
        ClearStatusIcons();
        if ((goldDisplay) && (character))
        {
            goldDisplay.Set(((character.data.inventory.gold)).Value);
        }
        if (entity.effectBonus != currentEffectBonus || entity.effectFactor != currentEffectFactor)
        {
            currentEffectBonus = entity.effectBonus;
            currentEffectFactor = entity.effectFactor;
            yield return StatusEffectSystem.EffectBonusChangedEvent(entity);
        }
    }

    public void ToggleInventory()
    {
        if (Deckpack.IsOpen)
        {
            Deckpack.Close();
            deckDisplay.displaySequence.End();
        }
        else
        {
            Deckpack.Open();
            deckDisplay.displaySequence.Begin();
        }
    }

    public void OpenInventory()
    {
        if (!Deckpack.IsOpen)
        {
            ToggleInventory();
        }
    }

    public void CloseInventory()
    {
        if (Deckpack.IsOpen)
        {
            ToggleInventory();
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void ForceUpdateDisplay()
    {
        StartCoroutine(UpdateDisplay());
    }
}
public abstract class EntityDisplay : MonoBehaviourCacheTransform, IPoolable
{
    public Entity entity;

    public CardHover hover;

    [BoxGroup("Icon Groups")]
    public RectTransform healthLayoutGroup;

    [BoxGroup("Icon Groups")]
    public RectTransform damageLayoutGroup;

    [BoxGroup("Icon Groups")]
    public RectTransform counterLayoutGroup;

    [BoxGroup("Icon Groups")]
    public RectTransform crownLayoutGroup;

    public Dictionary<string, RectTransform> iconGroups;

    public StatusIcon healthIcon;

    public StatusIcon damageIcon;

    public StatusIcon counterIcon;

    public StatusIcon reactionIcon;

    [ReadOnly]
    public bool init;

    public bool promptUpdateDescription;

    public virtual void Awake()
    {
        iconGroups = new Dictionary<string, RectTransform>();
        if (healthLayoutGroup != null)
        {
            iconGroups["health"] = healthLayoutGroup;
        }
        if (damageLayoutGroup != null)
        {
            iconGroups["damage"] = damageLayoutGroup;
        }
        if (counterLayoutGroup != null)
        {
            iconGroups["counter"] = counterLayoutGroup;
        }
        if (crownLayoutGroup != null)
        {
            iconGroups["crown"] = crownLayoutGroup;
        }
    }

    public virtual void Reset()
    {
        init = false;
    }

    public virtual IEnumerator UpdateData(bool doPing = false)
    {
        yield return UpdateDisplay(doPing);
        init = true;
        Events.InvokeEntityDataUpdated(entity);
    }

    public virtual IEnumerator UpdateDisplay(bool doPing = true)
    {
        if ((healthLayoutGroup))
        {
            if (!(healthIcon))
            {
                if (entity.hp.max > 0 || entity.hp.current > 0 || ((entity.data) && entity.data.hasHealth))
                {
                    healthIcon = SetStatusIcon("health", "health", entity.hp, doPing);
                }
            }
            else
            {
                UpdateStatusIcon(healthIcon, entity.hp, doPing);
            }
        }
        if ((damageLayoutGroup))
        {
            if (!(damageIcon))
            {
                if (entity.HasAttackIcon())
                {
                    damageIcon = SetStatusIcon("damage", "damage", entity.damage + entity.tempDamage, doPing);
                }
            }
            else
            {
                UpdateStatusIcon(damageIcon, entity.damage + entity.tempDamage, doPing);
            }
        }
        if ((counterLayoutGroup))
        {
            if (!(counterIcon))
            {
                if (entity.counter.max > 0)
                {
                    counterIcon = SetStatusIcon("counter", "counter", entity.counter, doPing);
                }
            }
            else
            {
                UpdateStatusIcon(counterIcon, entity.counter, doPing);
            }
            if (!(reactionIcon))
            {
                if (entity.statusEffects.Any((StatusEffectData a) => a.isReaction))
                {
                    reactionIcon = SetStatusIcon("reaction", "counter", Stat.Default, doPing);
                }
            }
            else
            {
                UpdateStatusIcon(reactionIcon, Stat.Default, doPing);
            }
        }
        foreach (StatusEffectData statusEffect in entity.statusEffects)
        {
            if (statusEffect.visible && !StringExt.IsNullOrEmpty(statusEffect.iconGroupName))
            {
                SetStatusIcon(statusEffect.type, statusEffect.iconGroupName, new Stat(statusEffect.count, 0), doPing);
            }
        }
        foreach (KeyValuePair<string, RectTransform> iconGroup in iconGroups)
        {
            foreach (RectTransform item in (Transform)iconGroup.Value)
            {
                StatusIcon component = ((Component)item).GetComponent<StatusIcon>();
                if ((component))
                {
                    component.CheckRemove();
                }
            }
        }
        Events.InvokeEntityDisplayUpdated(entity);
        yield return null;
    }

    public virtual Canvas GetCanvas()
    {
        return null;
    }

    public StatusIcon FindStatusIcon(string type)
    {
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        StatusIcon statusIcon = null;
        foreach (KeyValuePair<string, RectTransform> iconGroup in iconGroups)
        {
            foreach (RectTransform item in (Transform)iconGroup.Value)
            {
                StatusIcon component = ((Component)item).GetComponent<StatusIcon>();
                if ((component) && component.type == type)
                {
                    statusIcon = component;
                    break;
                }
            }
            if ((statusIcon))
            {
                break;
            }
        }
        return statusIcon;
    }

    public StatusIcon SetStatusIcon(string type, string iconGroupName, Stat value, bool doPing = true)
    {
        StatusIcon statusIcon = FindStatusIcon(type);
        if ((statusIcon))
        {
            UpdateStatusIcon(statusIcon, value, doPing);
        }
        else
        {
            statusIcon = CardManager.NewStatusIcon(type, (Transform)(object)iconGroups[iconGroupName]);
            if (!(statusIcon))
            {
                Debug.LogError(("Status Icon for [" + type + "] NOT FOUND!"));
            }
            else
            {
                if ((hover))
                {
                    CardHover component = ((Component)statusIcon).GetComponent<CardHover>();
                    component.master = hover;
                    ((Behaviour)component).enabled = true;
                }
                statusIcon.Assign(entity);
                statusIcon.SetValue(value, doPing);
                if (doPing)
                {
                    statusIcon.CreateEvent();
                    Events.InvokeStatusIconCreated(statusIcon);
                }
            }
        }
        return statusIcon;
    }

    public static void UpdateStatusIcon(StatusIcon icon, Stat value, bool doPing = true)
    {
        icon.SetValue(value, doPing);
    }

    public void RemoveStatusIcon(string type, string iconGroupName)
    {
        StatusIcon statusIcon = FindStatusIcon(type);
        if (statusIcon != null)
        {
            statusIcon.Destroy();
        }
    }

    public void ClearStatusIcons()
    {
        foreach (KeyValuePair<string, RectTransform> iconGroup in iconGroups)
        {
            RectTransformExt.DestroyAllChildren(iconGroup.Value);
        }
    }

    public virtual void OnGetFromPool()
    {
        init = false;
        promptUpdateDescription = false;
    }

    public virtual void OnReturnToPool()
    {
        ClearStatusIcons();
    }

    public EntityDisplay()
    {
    }
}
public class CardCharm : UpgradeDisplay
{
    public Transform holder;

    public Vector3 movementInfluence = new Vector3(-1f, 0.5f, 0f);

    public float rotationMax = 90f;

    public Vector2 wobbleFactorRange = (new Vector3(4.5f, 5.5f));

    public Vector2 wobbleDampingRange = new Vector2(0.9f, 0.95f);

    public Vector2 wobbleAccRange = new Vector2(0.65f, 0.75f);

    [SerializeField]
    [ReadOnly]
    public float wobbleFactor;

    [SerializeField]
    [ReadOnly]
    public float wobbleDamping;

    [SerializeField]
    [ReadOnly]
    public float wobbleAcc;

    public Vector3 prePosition;

    public float rotation;

    public float rotationVelocity;

    public float startingZAngle;

    public void Start()
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        wobbleFactor = Vector2Ext.PettyRandom(wobbleFactorRange);
        wobbleDamping = Vector2Ext.PettyRandom(wobbleDampingRange);
        wobbleAcc = Vector2Ext.PettyRandom(wobbleAccRange);
    }

    public void OnEnable()
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        if (holder != null)
        {
            prePosition = holder.position;
        }
    }

    public void Update()
    {
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        //IL_0088: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        //IL_0095: Unknown result type (might be due to invalid IL or missing references)
        //IL_009a: Unknown result type (might be due to invalid IL or missing references)
        //IL_009c: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a4: Unknown result type (might be due to invalid IL or missing references)
        rotationVelocity -= rotation * wobbleAcc * Time.deltaTime;
        rotationVelocity = Delta.Multiply(rotationVelocity, wobbleDamping, Time.deltaTime);
        rotation += rotationVelocity * 200f * Time.deltaTime;
        transform.eulerAngles = new Vector3(0f, 0f, startingZAngle + rotation);
        Vector3 position = holder.position;
        Vector3 movement = position - prePosition;
        Wobble(movement);
        prePosition = position;
    }

    public void Wobble(Vector3 movement)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3.Scale(movement, movementInfluence);
        float num = ((val)).magnitude * wobbleFactor;
        rotation = Mathf.Clamp(rotation + num, 0f - rotationMax, rotationMax);
    }

    public void SetAngle(float angle)
    {
        startingZAngle = angle;
    }

    public void StopWobble()
    {
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        rotationVelocity = 0f;
        rotation = 0f;
        transform.eulerAngles = new Vector3(0f, 0f, startingZAngle);
    }
}
public class CardCharmHolder : UpgradeHolder
{
    [SerializeField]
    public float angleAdd = 20f;

    [SerializeField]
    public Vector2 charmPivot = new Vector2(0.5f, 0.9f);

    [SerializeField]
    public Image ropeImage;

    public override void SetPositions()
    {
        int count = list.Count;
        float num = (0f - (float)(count - 1) * 0.5f) * angleAdd;
        for (int i = 0; i < count; i++)
        {
            if (list[i] is CardCharm cardCharm)
            {
                cardCharm.SetAngle(num + (float)i * angleAdd);
                ((Component)cardCharm).transform.SetSiblingIndex(CalculateSiblingIndex(i, count));
            }
        }
        Image obj = ropeImage;
        if (obj != null)
        {
            ((Component)obj).gameObject.SetActive(count > 0);
        }
    }

    public static int CalculateSiblingIndex(int listIndex, int listLength)
    {
        float num = (float)(listLength - 1) * 0.5f;
        float num2 = (float)listIndex - num;
        float num3 = Mathf.Sign(num2);
        return Mathf.FloorToInt(num + num2 * (0f - num3)) * 2 + Mathf.Clamp((int)num2, 0, 1);
    }

    public override void Add(UpgradeDisplay upgrade)
    {
        base.Add(upgrade);
        CharmAdded(upgrade);
    }

    public override void Insert(int index, UpgradeDisplay upgrade)
    {
        base.Insert(index, upgrade);
        CharmAdded(upgrade);
    }

    public void CharmAdded(UpgradeDisplay upgrade)
    {
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        if (upgrade is CardCharm cardCharm)
        {
            cardCharm.holder = transform;
            ((RectTransform)((Component)cardCharm).transform).pivot = charmPivot;
        }
    }

    public override void Clear()
    {
        base.Clear();
        Image obj = ropeImage;
        if (obj != null)
        {
            ((Component)obj).gameObject.SetActive(false);
        }
    }
}
public class CrownHolder : UpgradeHolder
{
    [SerializeField]
    public float gap = 0.3f;

    [SerializeField]
    public float angleRange = 1f;

    [SerializeField]
    public float xRange = 0.02f;

    [SerializeField]
    public float xMax = 0.1f;

    public int seed;

    public void Awake()
    {
        seed = PettyRandom.Range(10000, 9999999);
    }

    public override void SetPositions()
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d8: Unknown result type (might be due to invalid IL or missing references)
        //IL_0088: Unknown result type (might be due to invalid IL or missing references)
        //IL_0098: Unknown result type (might be due to invalid IL or missing references)
        //IL_009d: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a2: Unknown result type (might be due to invalid IL or missing references)
        State state = Random.state;
        Random.InitState(seed);
        Vector2 val = Vector2.zero;
        Vector3 zero = Vector3.zero;
        foreach (RectTransform item in transform)
        {
            item.anchoredPosition = val;
            ((Transform)item).localEulerAngles = zero;
            float num = Random.Range(-1f, 1f);
            float num2 = val.x + num * xRange;
            if (num2 > xMax || num2 < 0f - xMax)
            {
                num *= -1f;
            }
            val += new Vector2(num * xRange, gap);
            zero.z += num * angleRange;
        }
        Random.state = state;
    }
}
public abstract class UpgradeHolder : MonoBehaviour
{
    [SerializeField]
    public AssetReference prefabRef;

    [SerializeField]
    public CardCharmDragHandler dragHandler;

    [SerializeField]
    public List<UpgradeDisplay> list = new List<UpgradeDisplay>();

    [Button(/*Could not decode attribute arguments.*/)]
    public virtual void SetPositions()
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        foreach (RectTransform item in transform)
        {
            item.anchoredPosition = Vector2.zero;
        }
    }

    public virtual UpgradeDisplay Create(CardUpgradeData upgradeData)
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        AsyncOperationHandle<GameObject> val = prefabRef.InstantiateAsync(transform, false);
        val.WaitForCompletion();
        UpgradeDisplay component = val.Result.GetComponent<UpgradeDisplay>();
        ((Component)component).gameObject.SetActive(true);
        component.SetData(upgradeData);
        (component).name = (upgradeData).name;
        if ((dragHandler))
        {
            CardCharmInteraction component2 = ((Component)component).GetComponent<CardCharmInteraction>();
            if (component2 != null)
            {
                component2.dragHandler = dragHandler;
                component2.onDrag.AddListener((UnityAction<UpgradeDisplay>)dragHandler.Drag);
                component2.onDragEnd.AddListener((UnityAction<UpgradeDisplay>)dragHandler.Release);
            }
        }
        Add(component);
        return component;
    }

    public virtual void Add(UpgradeDisplay upgrade)
    {
        Insert(0, upgrade);
    }

    public virtual void Insert(int index, UpgradeDisplay upgrade)
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        list.Insert(index, upgrade);
        ((Component)upgrade).transform.SetParent(transform, false);
        ((Component)upgrade).transform.localPosition = Vector3.zero;
        ((Component)upgrade).transform.localEulerAngles = Vector3.zero;
    }

    public virtual void Remove(UpgradeDisplay upgrade)
    {
        list.Remove(upgrade);
        ((Component)upgrade).transform.SetParent((Transform)null, false);
    }

    public virtual void Remove(CardUpgradeData upgradeData)
    {
        UpgradeDisplay upgradeDisplay = list.Find((UpgradeDisplay a) => a.data == upgradeData);
        if (upgradeDisplay != null)
        {
            Remove(upgradeDisplay);
        }
    }

    public virtual int IndexOf(UpgradeDisplay upgrade)
    {
        return list.IndexOf(upgrade);
    }

    public virtual void Clear()
    {
        list.Clear();
        TransformExt.DestroyAllChildren(transform);
    }

    public UpgradeHolder()
    {
    }
}
public class UpgradeDisplay : MonoBehaviour
{
    [SerializeField]
    public Image image;

    public UINavigationItem navigationItem;

    public Image _raycast;

    public CardUpgradeData data { get; set; }

    public Image raycast => _raycast ?? (_raycast = GetComponent<Image>());

    public bool CanRaycast
    {
        set
        {
            ((Graphic)raycast).raycastTarget = value;
        }
    }

    public virtual void SetData(CardUpgradeData data)
    {
        this.data = data;
        image.sprite = data.image;
    }
}
public class Entity : MonoBehaviourCacheTransform, IPoolable
{
    [Serializable]
    public class TraitStacks
    {
        public TraitData data;

        public int count;

        public int silenceCount;

        public int tempCount;

        public int init;

        public bool effectsDisabled;

        public readonly List<StatusEffectData> passiveEffects = new List<StatusEffectData>();

        public bool silenced => silenceCount > 0;

        public bool ReadyToInit
        {
            get
            {
                if (init < count)
                {
                    return !silenced;
                }
                return false;
            }
        }

        public bool MustDisable
        {
            get
            {
                if (init == count && silenced)
                {
                    return !effectsDisabled;
                }
                return false;
            }
        }

        public bool MustEnable
        {
            get
            {
                if (init == count && !silenced)
                {
                    return effectsDisabled;
                }
                return false;
            }
        }

        public bool StacksRemoved => count < init;

        public TraitStacks(TraitData data, int count, bool temporary = false)
        {
            this.data = data;
            this.count = count;
            if (temporary)
            {
                tempCount = count;
            }
        }

        public IEnumerator DisableEffects()
        {
            foreach (StatusEffectData passiveEffect in passiveEffects)
            {
                yield return passiveEffect.Remove();
            }
            passiveEffects.Clear();
            effectsDisabled = true;
            init = 0;
        }

        public IEnumerator EnableEffects(Entity entity)
        {
            int stacks = count - init;
            yield return AddEffectStacks(entity, stacks);
        }

        public IEnumerator AddEffectStacks(Entity entity, int stacks)
        {
            StatusEffectData[] effects = data.effects;
            foreach (StatusEffectData effectData in effects)
            {
                yield return StatusEffectSystem.Apply(entity, null, effectData, stacks, temporary: true, delegate (StatusEffectData a)
                {
                    passiveEffects.Add(a);
                });
            }
            effectsDisabled = false;
            init += stacks;
        }

        public IEnumerator RemoveEffectStacks(Entity entity, int removeStacks)
        {
            StatusEffectData[] effects = data.effects;
            foreach (StatusEffectData dataType in effects)
            {
                StatusEffectData statusEffectData = entity.FindStatus(dataType);
                if ((statusEffectData))
                {
                    yield return statusEffectData.RemoveStacks(removeStacks, removeTemporary: true);
                }
            }
            init -= removeStacks;
        }
    }

    public bool inPlay = true;

    public CardData _data;

    public EntityDisplay display;

    public int height = 1;

    public bool paused;

    [HorizontalLine(/*Could not decode attribute arguments.*/)]
    public Wobbler wobbler;

    public Flipper flipper;

    public UINavigationItem uINavigationItem;

    public CurveAnimator curveAnimator;

    public CardIdleAnimation imminentAnimation;

    [Required(null)]
    public Transform offset;

    [HorizontalLine(/*Could not decode attribute arguments.*/)]
    [ReadOnly]
    public bool dragging;

    [ReadOnly]
    public int blockRecall;

    [SerializeField]
    [ReadOnly]
    public List<CardContainer> _containers;

    public CardContainer[] _preContainers;

    public bool alive = true;

    public Character owner;

    public SplatterSurface splatterSurface;

    public bool inCardPool;

    public bool returnToPool = true;

    [HorizontalLine(/*Could not decode attribute arguments.*/)]
    public List<CardData.StatusEffectStacks> attackEffects;

    public List<StatusEffectData> statusEffects;

    public Stat damage;

    public SafeInt tempDamage;

    public Stat hp;

    public Stat counter;

    public Stat uses;

    public int effectBonus;

    public float effectFactor = 1f;

    [ReadOnly]
    public Hit lastHit;

    public bool promptUpdate;

    [ReadOnly]
    public Vector3 random3;

    public bool forceKill;

    public TargetMode targetMode;

    public int positionPriority = 1;

    [ReadOnly]
    public bool startingEffectsApplied;

    [HideInInspector]
    public Entity triggeredBy;

    public int cannotBeHitCount;

    public int silenceCount;

    public readonly List<TraitStacks> traits = new List<TraitStacks>();

    public Canvas canvas;

    public int traitUpdateRunning;

    public CardData data
    {
        get
        {
            return _data;
        }
        set
        {
            _data = value;
            if ((_data))
            {
                if (!_data.canBeHit)
                {
                    cannotBeHitCount++;
                }
                targetMode = _data.targetMode;
            }
        }
    }

    public CardContainer[] containers => _containers?.Select((CardContainer c) => c.Group).ToArray();

    public List<CardContainer> actualContainers => _containers;

    public CardContainer[] preContainers => _preContainers?.Select((CardContainer c) => c.Group).ToArray();

    public CardContainer[] preActualContainers => _preContainers;

    public bool NeedsTarget
    {
        get
        {
            if (targetMode.NeedsTarget)
            {
                return data.needsTarget;
            }
            return false;
        }
    }

    public bool canBeHit => cannotBeHitCount <= 0;

    public bool silenced => silenceCount > 0;

    public int DrawOrder
    {
        get
        {
            if (!(canvas) && (display))
            {
                canvas = display.GetCanvas();
            }
            if (!(canvas != null))
            {
                return 0;
            }
            return canvas.sortingOrder;
        }
        set
        {
            if (!(canvas) && (display))
            {
                canvas = display.GetCanvas();
            }
            if (!(canvas))
            {
                return;
            }
            canvas.overrideSorting = !value.Equals(0);
            if (canvas.overrideSorting)
            {
                canvas.sortingOrder = value;
                Canvas componentInParent = GetComponentInParent<Canvas>();
                if ((componentInParent))
                {
                    canvas.sortingLayerID = componentInParent.sortingLayerID;
                }
            }
        }
    }

    public bool IsSnowed => SnowAmount() > 0;

    public void AddTo(CardContainer container)
    {
        _containers.Add(container);
    }

    public void RemoveFrom(CardContainer container)
    {
        _containers.Remove(container);
    }

    public List<Entity> GetAllAllies()
    {
        List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(owner);
        cardsOnBoard.Remove(this);
        return cardsOnBoard;
    }

    public List<Entity> GetAllies()
    {
        List<Entity> list = new List<Entity>();
        foreach (CardContainer row in Battle.instance.GetRows(owner))
        {
            for (int i = 0; i < row.Count; i++)
            {
                Entity entity = row[i];
                if (entity != this)
                {
                    list.Add(entity);
                }
            }
        }
        return list;
    }

    public List<Entity> GetAlliesInRow()
    {
        List<Entity> list = new List<Entity>();
        CardContainer[] array = containers;
        foreach (CardContainer cardContainer in array)
        {
            for (int j = 0; j < cardContainer.Count; j++)
            {
                Entity entity = cardContainer[j];
                if (entity != this)
                {
                    list.Add(entity);
                }
            }
        }
        return list;
    }

    public List<Entity> GetAlliesInRow(int rowIndex)
    {
        List<Entity> list = new List<Entity>();
        foreach (Entity item in References.Battle.GetRow(owner, rowIndex))
        {
            if (item != this)
            {
                list.Add(item);
            }
        }
        return list;
    }

    public List<Entity> GetAllEnemies()
    {
        return Battle.GetCardsOnBoard(Battle.GetOpponent(owner));
    }

    public List<Entity> GetEnemies()
    {
        List<Entity> list = new List<Entity>();
        List<CardContainer> list2 = new List<CardContainer>();
        foreach (KeyValuePair<Character, List<CardContainer>> row in Battle.instance.rows)
        {
            if (row.Key != owner)
            {
                list2.AddRange(Battle.instance.GetRows(row.Key));
            }
        }
        foreach (CardContainer item in list2)
        {
            foreach (Entity item2 in item)
            {
                if (item2 != this && !list.Contains(item2))
                {
                    list.Add(item2);
                }
            }
        }
        return list;
    }

    public List<Entity> GetEnemiesInRow(int rowIndex)
    {
        List<Entity> list = new List<Entity>();
        if (containers != null && rowIndex >= 0)
        {
            List<CardContainer> list2 = new List<CardContainer>();
            foreach (KeyValuePair<Character, List<CardContainer>> row in Battle.instance.rows)
            {
                if (row.Key != owner)
                {
                    list2.Add(Battle.instance.GetRow(row.Key, rowIndex));
                }
            }
            foreach (CardContainer item in list2)
            {
                foreach (Entity item2 in item)
                {
                    list.Add(item2);
                }
            }
        }
        return list;
    }

    public StatusEffectData FindStatus(string type)
    {
        return statusEffects.Find((StatusEffectData a) => a.type == type);
    }

    public StatusEffectData FindStatus(StatusEffectData dataType)
    {
        return statusEffects.Find((StatusEffectData a) => (a).name == (dataType).name);
    }

    public IEnumerator ClearStatuses()
    {
        for (int i = statusEffects.Count - 1; i >= 0; i--)
        {
            yield return statusEffects[i].Remove();
        }
        statusEffects.Clear();
        startingEffectsApplied = false;
    }

    public int SnowAmount()
    {
        StatusEffectData statusEffectData = FindStatus("snow");
        if (!(statusEffectData))
        {
            return 0;
        }
        return statusEffectData.count;
    }

    public Vector3 GetScaleFromContainers()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        if (containers == null || containers.Length == 0)
        {
            return Vector3.one;
        }
        Vector3 val = Vector3.zero;
        CardContainer[] array = containers;
        foreach (CardContainer cardContainer in array)
        {
            val += cardContainer.GetChildScale(this);
        }
        return val / (float)_containers.Count;
    }

    public Vector3 GetPositionFromContainers()
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3.zero;
        CardContainer[] array = containers;
        foreach (CardContainer cardContainer in array)
        {
            val += ((Component)cardContainer).transform.position + cardContainer.GetChildPosition(this);
        }
        return val / (float)_containers.Count;
    }

    public void RemoveFromContainers()
    {
        LeanTween.cancel(gameObject);
        _preContainers = actualContainers.ToArray();
        CardContainer[] array = containers;
        foreach (CardContainer cardContainer in array)
        {
            if ((cardContainer))
            {
                cardContainer.Remove(this);
            }
        }
    }

    public void ResetDrawOrder()
    {
        int num = 0;
        CardContainer[] array = containers;
        foreach (CardContainer cardContainer in array)
        {
            num = Mathf.Max(num, cardContainer.GetChildDrawOrder(this));
        }
        DrawOrder = num;
    }

    public bool InHand()
    {
        if ((owner) && (owner.handContainer) && _containers.Count == 1)
        {
            return containers[0] == owner.handContainer;
        }
        return false;
    }

    public bool InContainer(CardContainer container)
    {
        foreach (CardContainer actualContainer in actualContainers)
        {
            if (actualContainer == container)
            {
                return true;
            }
        }
        return false;
    }

    public bool InContainerGroup(CardContainer container)
    {
        CardContainer[] array = containers;
        for (int i = 0; i < array.Length; i++)
        {
            if (array[i] == container)
            {
                return true;
            }
        }
        return false;
    }

    public void Awake()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        random3 = PettyRandom.Vector3();
    }

    public void Update()
    {
        if (promptUpdate && enabled)
        {
            promptUpdate = false;
            if ((display))
            {
                CoroutineManager.Start((!display.init) ? display.UpdateData() : display.UpdateDisplay());
            }
            if (alive && ReadyToDie())
            {
                forceKill = false;
                CoroutineManager.Start(Kill());
            }
        }
    }

    public bool ReadyToDie()
    {
        if (forceKill)
        {
            return true;
        }
        if (hp.current <= 0 && (!(data) || ((data) && data.cardType.canDie)))
        {
            return !statusEffects.Exists((StatusEffectData a) => a.preventDeath);
        }
        return false;
    }

    public IEnumerator Reset()
    {
        yield return ClearStatuses();
        if (display is Card card)
        {
            yield return card.UpdateData();
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void PromptUpdate()
    {
        promptUpdate = true;
    }

    public bool CanPlayOn(Entity target, bool ignoreRowCheck = false)
    {
        if (data.playOnSlot || !NeedsTarget || (targetMode.TargetRow && !ignoreRowCheck) || target == this)
        {
            return false;
        }
        if (damage.current + ((tempDamage)).Value > 0 && !target.canBeHit)
        {
            return false;
        }
        if (!targetMode.CanTarget(target))
        {
            return false;
        }
        bool flag = owner.team == target.owner.team;
        if (!data.canPlayOnEnemy && !flag)
        {
            return false;
        }
        if (!data.canPlayOnFriendly && flag)
        {
            return false;
        }
        if (!data.canPlayOnHand && IArrayExt.Contains<CardContainer>(target.containers, owner.handContainer))
        {
            return false;
        }
        if (!data.canPlayOnBoard && Battle.IsOnBoard(target))
        {
            return false;
        }
        TargetConstraint[] targetConstraints = data.targetConstraints;
        if (targetConstraints != null && targetConstraints.Length > 0 && data.targetConstraints.Any((TargetConstraint c) => !c.Check(target)))
        {
            return false;
        }
        if (damage.max <= 0 && attackEffects.Any((CardData.StatusEffectStacks s) => !s.data.CanPlayOn(target)))
        {
            return false;
        }
        return true;
    }

    public bool CanPlayOn(CardContainer container, bool ignoreRowCheck = false)
    {
        if (!(container))
        {
            return false;
        }
        if (container == owner.discardContainer && this.CanRecall())
        {
            return true;
        }
        switch (data.playType)
        {
            case Card.PlayType.Place:
                if (container is CardSlot cardSlot && container.canBePlacedOn && container.owner == owner)
                {
                    int num3 = positionPriority;
                    if (num3 != -1 && num3 != 2)
                    {
                        return true;
                    }
                    if (cardSlot.Group is CardSlotLane cardSlotLane2)
                    {
                        return cardSlotLane2.slots.IndexOf(cardSlot) == ((positionPriority == -1) ? (cardSlotLane2.slots.Count - 1) : 0);
                    }
                    return false;
                }
                return false;
            case Card.PlayType.Play:
                if (!NeedsTarget || !container.canPlayOn)
                {
                    return false;
                }
                if (targetMode.TargetRow && !ignoreRowCheck)
                {
                    if (container is CardSlotLane && data.canPlayOnBoard)
                    {
                        if (data.playOnSlot && container.Count >= container.max)
                        {
                            return false;
                        }
                        if (!data.playOnSlot)
                        {
                            Entity[] targets = targetMode.GetTargets(this, null, container);
                            if (targets == null || targets.Length <= 0)
                            {
                                return false;
                            }
                        }
                        if (!(container.owner == owner))
                        {
                            return data.canPlayOnEnemy;
                        }
                        return data.canPlayOnFriendly;
                    }
                }
                else if (data.playOnSlot && container is CardSlot && data.canPlayOnBoard && container.Group is CardSlotLane cardSlotLane)
                {
                    if (!container.Empty)
                    {
                        if (owner.team != container.owner.team)
                        {
                            return false;
                        }
                        int num = cardSlotLane.Count;
                        int num2 = cardSlotLane.max;
                        if (data.canShoveToOtherRow)
                        {
                            foreach (CardContainer item in cardSlotLane.shoveTo)
                            {
                                num += item.Count;
                                num2 += item.max;
                            }
                        }
                        if (num >= num2)
                        {
                            return false;
                        }
                    }
                    if (!(cardSlotLane.owner == owner))
                    {
                        return data.canPlayOnEnemy;
                    }
                    return data.canPlayOnFriendly;
                }
                return false;
            default:
                return false;
        }
    }

    public IEnumerator Kill(DeathType deathType = DeathType.Normal)
    {
        if (alive)
        {
            alive = false;
            if ((display) && (display.hover))
            {
                display.hover.Disable();
            }
            LeanTween.cancel(gameObject);
            Routine.Clump clump = new Routine.Clump();
            clump.Add(StatusEffectSystem.EntityDestroyedEvent(this, deathType));
            yield return null;
            RemoveFromContainers();
            base.transform.SetParent((Transform)null);
            Events.InvokeEntityKilled(this, deathType);
            yield return clump.WaitForEnd();
        }
    }

    public void OnDisable()
    {
        Events.InvokeEntityDisabled(this);
    }

    public void OnDestroy()
    {
        Events.InvokeEntityDisabled(this);
        Events.InvokeEntityDestroyed(this);
        if (statusEffects.Count <= 0)
        {
            return;
        }
        Debug.Log($"[{this}] Destroyed! Removing [{statusEffects.Count}] status effects...");
        foreach (StatusEffectData item in statusEffects.Where((StatusEffectData status) => (status)))
        {
            item.Destroy();
        }
        statusEffects.Clear();
    }

    public TraitStacks GainTrait(TraitData traitData, int count, bool temporary = false)
    {
        TraitStacks traitStacks = traits.FirstOrDefault((TraitStacks a) => a.data == traitData);
        if (traitStacks != null)
        {
            traitStacks.count += count;
            if (temporary)
            {
                traitStacks.tempCount += count;
            }
            traits.Remove(traitStacks);
            traits.Add(traitStacks);
            return traitStacks;
        }
        TraitStacks traitStacks2 = new TraitStacks(traitData, count, temporary);
        traits.Add(traitStacks2);
        return traitStacks2;
    }

    public IEnumerator UpdateTraits(TraitStacks moveToFront = null)
    {
        if (traitUpdateRunning > 0)
        {
            yield return (object)new WaitUntil((Func<bool>)(() => traitUpdateRunning <= 0));
            if (!this.IsAliveAndExists())
            {
                yield break;
            }
        }
        traitUpdateRunning++;
        if (moveToFront != null)
        {
            traits.Remove(moveToFront);
            traits.Insert(0, moveToFront);
        }
        for (int j = traits.Count - 1; j >= 0; j--)
        {
            TraitStacks traitStacks = traits[j];
            if (traitStacks.count <= 0)
            {
                Debug.Log(("> [" + name + " " + (traitStacks.data).name + "] Removed! Removing effects [" + string.Join(", ", traitStacks.passiveEffects) + "]"));
                traits.RemoveAt(j);
                yield return traitStacks.DisableEffects();
            }
        }
        foreach (TraitStacks trait in traits)
        {
            trait.silenceCount = 0;
        }
        for (int num = traits.Count - 1; num >= 0; num--)
        {
            TraitStacks traitStacks2 = traits[num];
            TraitData[] overrides = traitStacks2.data.overrides;
            if (overrides != null && overrides.Length > 0)
            {
                for (int num2 = num - 1; num2 >= 0; num2--)
                {
                    TraitStacks traitStacks3 = traits[num2];
                    if (IArrayExt.Contains<TraitData>(traitStacks2.data.overrides, traitStacks3.data))
                    {
                        traitStacks3.silenceCount++;
                    }
                }
            }
        }
        foreach (TraitStacks item in traits.Where((TraitStacks a) => a.MustDisable))
        {
            Debug.Log(("> [" + name + " " + (item.data).name + "] Silenced! Removing effects [" + string.Join(", ", item.passiveEffects) + "]"));
            yield return item.DisableEffects();
        }
        foreach (TraitStacks t2 in traits.Where((TraitStacks a) => a.ReadyToInit || a.MustEnable))
        {
            yield return t2.EnableEffects(this);
            Debug.Log(("> [" + name + " " + (t2.data).name + "] Enabled! Adding effects [" + string.Join(", ", t2.passiveEffects) + "]"));
        }
        foreach (TraitStacks t2 in traits.Where((TraitStacks a) => a.StacksRemoved))
        {
            int j = t2.init - t2.count;
            yield return t2.RemoveEffectStacks(this, j);
            Debug.Log(string.Format("> [{0} {1}] Removing {2} Stacks of effects [{3}]", name, (t2.data).name, j, string.Join(", ", t2.passiveEffects)));
        }
        traitUpdateRunning--;
    }

    public void OnGetFromPool()
    {
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        inCardPool = false;
        wobbler.OnGetFromPool();
        flipper.OnGetFromPool();
        curveAnimator.OnGetFromPool();
        splatterSurface.OnGetFromPool();
        offset.localScale = Vector3.one;
        offset.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
        _preContainers = null;
    }

    public void OnReturnToPool()
    {
        inCardPool = true;
        Events.InvokeEntityDisabled(this);
        Events.InvokeEntityDestroyed(this);
        if (statusEffects.Count > 0)
        {
            Debug.Log($"[{this}] Destroyed! Removing [{statusEffects.Count}] status effects...");
            foreach (StatusEffectData statusEffect in statusEffects)
            {
                if ((statusEffect))
                {
                    statusEffect.Destroy();
                }
            }
            statusEffects.Clear();
        }
        IRemoveWhenPooled component = GetComponent<IRemoveWhenPooled>();
        MonoBehaviour val = (MonoBehaviour)((component is MonoBehaviour) ? component : null);
        if (val != null)
        {
            Object.Destroy(val);
        }
        enabled = false;
        dragging = false;
        blockRecall = 0;
        alive = true;
        attackEffects.Clear();
        statusEffects.Clear();
        traits.Clear();
        effectBonus = 0;
        effectFactor = 1f;
        ((tempDamage)).Value = 0;
        forceKill = false;
        startingEffectsApplied = false;
        cannotBeHitCount = 0;
        silenceCount = 0;
        _containers.Clear();
        lastHit = null;
        wobbler.OnReturnToPool();
        flipper.OnReturnToPool();
        curveAnimator.OnReturnToPool();
        splatterSurface.OnReturnToPool();
        positionPriority = 1;
        promptUpdate = false;
        triggeredBy = null;
        ((Behaviour)uINavigationItem).enabled = true;
        LeanTween.cancel(gameObject);
    }
}
public class EventManager : MonoBehaviour
{
    public static EventManager instance;

    public Transform eventRoutineHolder;

    [SerializeField]
    public TweenUI enterTween;

    public static Transform EventRoutineHolder => instance.eventRoutineHolder;

    public void Awake()
    {
        instance = this;
    }

    public void OnEnable()
    {
        if (GameManager.Ready)
        {
            CinemaBarSystem.InInstant();
            enterTween.Fire();
        }
    }

    public void OnDisable()
    {
        CinemaBarSystem.OutInstant();
    }
}
public class EventRoutine : SceneRoutine
{
    public Character _player;

    public CampaignNode node;

    public Character player => _player ?? (_player = References.Player);

    public Dictionary<string, object> data => node.data;

    public virtual IEnumerator Populate()
    {
        return null;
    }

    public void CheckAddUpgrades(int cardIndex, CardData cardDataClone)
    {
        string key = $"upgrades{cardIndex}";
        if (!node.data.ContainsKey(key))
        {
            return;
        }
        string[] saveCollection = node.data.GetSaveCollection<string>(key);
        foreach (string assetName in saveCollection)
        {
            CardUpgradeData cardUpgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", assetName);
            if ((cardUpgradeData))
            {
                cardUpgradeData.Clone().Assign(cardDataClone);
            }
        }
    }
}
public class EventRoutineCharm : EventRoutine
{
    [SerializeField]
    public Animator animator;

    [SerializeField]
    public OpenCharmBlockSequence openSequence;

    [SerializeField]
    public Transform charmBlock;

    [SerializeField]
    public LocalizedString takeKey;

    [SerializeField]
    public SfxLoop loop;

    public bool routineActive;

    public void Open(BaseEventData eventData)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        PointerEventData val = (PointerEventData)(object)((eventData is PointerEventData) ? eventData : null);
        if ((val == null || (int)val.button == 0) && !DictionaryExt.Get<bool>(base.data, "open") && !routineActive)
        {
            StartCoroutine(OpenRoutine());
        }
    }

    public IEnumerator OpenRoutine()
    {
        node.cleared = true;
        DeckpackBlocker.Block();
        CinemaBarSystem.Clear();
        Events.InvokeScreenShake(0.25f, 0f);
        Events.InvokeScreenRumble(0f, 0.25f, 0f, 0.05f, 0.2f, 0.3f);
        SfxSystem.OneShot("event:/sfx/location/charm/rumble");
        base.data["open"] = true;
        routineActive = true;
        yield return Sequences.Wait(0.1f);
        animator.SetTrigger("OpenMouth");
        yield return Sequences.Wait(0.35f);
        animator.SetTrigger("DropCharm");
        SfxSystem.OneShot("event:/sfx/location/charm/drop");
        yield return Sequences.Wait(1f);
        animator.SetBool("Zoom", true);
        routineActive = false;
    }

    public override IEnumerator Populate()
    {
        animator.SetBool("OpenMouth", DictionaryExt.Get<bool>(base.data, "open"));
        yield return null;
    }

    public override IEnumerator Run()
    {
        CinemaBarSystem.Top.SetPrompt(takeKey.GetLocalizedString(), "Select");
        loop.Play();
        yield return (object)new WaitUntil((Func<bool>)(() => DictionaryExt.Get<bool>(base.data, "open") && !routineActive));
        yield return Sequences.Wait(0.15f);
        string assetName = DictionaryExt.Get<string>(base.data, "charm");
        CardUpgradeData charmData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", assetName).Clone();
        openSequence.SetCharm(charmData, charmBlock);
        openSequence.SetCharacter(base.player);
        ((Component)charmBlock).gameObject.SetActive(false);
        yield return openSequence.Run();
        DeckpackBlocker.Unblock();
        loop.Stop();
        CinemaBarSystem.Clear();
    }
}
public class EventRoutineCharmShop : EventRoutine
{
    [Serializable]
    public class Data
    {
        public List<UpgradedCard> cards;

        public List<CharmShopItemData> items;
    }

    [Serializable]
    public class UpgradedCard
    {
        public string cardDataName;

        public string[] upgradeNames;

        public int price;

        public float priceFactor;

        public bool purchased;
    }

    [Serializable]
    public class CharmShopItemData
    {
        public string upgradeDataName;

        public int price;

        public float priceFactor;

        public bool purchased;

        public CharmShopItemData()
        {
        }

        public CharmShopItemData(string upgradeDataName, int price, float priceFactor = 1f)
        {
            this.upgradeDataName = upgradeDataName;
            this.price = Mathf.RoundToInt((float)price * priceFactor);
            this.priceFactor = priceFactor;
        }
    }

    [SerializeField]
    public ShopPriceManager priceManager;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardContainer cardContainer;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public CardCharmHolder[] holders;

    [SerializeField]
    public GainCharmSequence gainCharmSequence;

    [SerializeField]
    public Talker talker;

    public const float speechBubDelay = 1f;

    public float speechBubTimer;

    public ShopItem currentHover;

    public readonly List<ShopItem> items = new List<ShopItem>();

    public bool promptEnd;

    public void PromptEnd()
    {
        promptEnd = true;
    }

    public void OnEnable()
    {
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
    }

    public void EntityHover(Entity entity)
    {
        ShopItem component = ((Component)entity).GetComponent<ShopItem>();
        if (component != null)
        {
            Hover(component);
        }
    }

    public void EntityUnHover(Entity entity)
    {
        ShopItem component = ((Component)entity).GetComponent<ShopItem>();
        if (component != null)
        {
            UnHover(component);
        }
    }

    public void Update()
    {
        if (speechBubTimer > 0f)
        {
            speechBubTimer -= Time.deltaTime;
        }
    }

    public override IEnumerator Populate()
    {
        Data shopData = DictionaryExt.Get<Data>(base.data, "data");
        cardContainer.SetSize(shopData.cards.Count, 0.8f);
        foreach (UpgradedCard card3 in shopData.cards)
        {
            CardData cardData = AddressableLoader.Get<CardData>("CardData", card3.cardDataName).Clone();
            if (card3.upgradeNames != null)
            {
                string[] upgradeNames = card3.upgradeNames;
                foreach (string assetName in upgradeNames)
                {
                    CardUpgradeData cardUpgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", assetName);
                    if ((cardUpgradeData))
                    {
                        cardUpgradeData.Clone().Assign(cardData);
                    }
                }
            }
            Card card2 = CardManager.Get(cardData, cardController, base.player, inPlay: false, isPlayerCard: true);
            cardContainer.Add(card2.entity);
            ShopItem target = ((Component)card2.entity).gameObject.AddComponent<ShopItem>();
            priceManager.Add(target, ShopPrice.Position.Bottom).SetPrice(card3.price, card3.priceFactor);
            yield return card2.UpdateData();
        }
        cardContainer.SetChildPositions();
        foreach (CharmShopItemData item in shopData.items)
        {
            CardUpgradeData upgradeDataClone = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", item.upgradeDataName).Clone();
            CreateUpgrade(upgradeDataClone, item.price, item.priceFactor);
        }
        foreach (UpgradedCard card in shopData.cards)
        {
            if (card.purchased)
            {
                Entity entity = cardContainer.First((Entity a) => (a.data).name == card.cardDataName);
                if ((entity))
                {
                    priceManager.Remove(((Component)entity).GetComponent<ShopItem>());
                    entity.RemoveFromContainers();
                    CardManager.ReturnToPool(entity);
                }
            }
        }
        for (int j = 0; j < items.Count; j++)
        {
            if (shopData.items[j].purchased)
            {
                GameObjectExt.Destroy(((Component)items[j]).gameObject);
            }
        }
    }

    public override IEnumerator Run()
    {
        int num = DictionaryExt.Get<int>(base.data, "enterCount", 0) + 1;
        base.data["enterCount"] = num;
        if (num == 1)
        {
            talker.Say("greet", PettyRandom.Range(0.5f, 1f));
            foreach (Entity item in cardContainer)
            {
                Events.InvokeEntityOffered(item);
            }
        }
        cardController.owner = base.player;
        cardContainer.owner = base.player;
        cardSelector.character = base.player;
        while (!promptEnd)
        {
            yield return null;
        }
        if (DictionaryExt.Get<Data>(base.data, "data").items.Count((CharmShopItemData i) => !i.purchased) <= 0)
        {
            node.SetCleared();
        }
        ((Behaviour)cardController).enabled = false;
        ((Behaviour)cardSelector).enabled = false;
        foreach (ShopItem item2 in items)
        {
            if ((item2))
            {
                CardCharmInteraction component = ((Component)item2).GetComponent<CardCharmInteraction>();
                if (component != null)
                {
                    component.canHover = false;
                    component.canDrag = false;
                }
            }
        }
        if (base.player.entity.display is CharacterDisplay characterDisplay && (characterDisplay.goldDisplay))
        {
            characterDisplay.goldDisplay.HideChange();
        }
    }

    public void Bub(string speechType, params object[] inserts)
    {
        if (speechBubTimer <= 0f)
        {
            talker.Say(speechType, 0f, inserts);
            speechBubTimer = 1f;
        }
    }

    public void TryBuy(Entity entity)
    {
        if (Deckpack.IsOpen)
        {
            return;
        }
        ShopItem component = ((Component)entity).GetComponent<ShopItem>();
        if (component == null)
        {
            return;
        }
        int price = component.GetPrice();
        if (((base.player.data.inventory.gold)).Value - price >= 0)
        {
            SfxSystem.OneShot("event:/sfx/location/shop/buying");
            priceManager.Remove(component);
            base.player.SpendGold(price);
            cardSelector.TakeCard(entity);
            DictionaryExt.Get<Data>(base.data, "data").cards.Find((UpgradedCard a) => a.cardDataName == (entity.data).name).purchased = true;
            Events.InvokeShopItemPurchase(component);
            talker.Say("thanks", 0f);
        }
        else
        {
            Bub("no");
        }
    }

    public void TryBuy(ShopItem item)
    {
        if (Deckpack.IsOpen)
        {
            return;
        }
        int price = item.GetPrice();
        if (((base.player.data.inventory.gold)).Value - price >= 0)
        {
            int num = items.IndexOf(item);
            SfxSystem.OneShot("event:/sfx/location/shop/buying");
            base.player.SpendGold(price);
            priceManager.Remove(item);
            UpgradeDisplay componentInChildren = ((Component)holders[num]).GetComponentInChildren<UpgradeDisplay>();
            if (componentInChildren != null)
            {
                GameObjectExt.Destroy(((Component)componentInChildren).gameObject);
                DictionaryExt.Get<Data>(base.data, "data").items[num].purchased = true;
                gainCharmSequence.SetCharm(componentInChildren.data);
                gainCharmSequence.SetCharacter(base.player);
                StartCoroutine(gainCharmSequence.Run());
                Events.InvokeShopItemPurchase(item);
                talker.Say("thanks", 0f);
            }
        }
        else
        {
            Bub("no");
        }
    }

    public void Hover(ShopItem item)
    {
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        if ((currentHover))
        {
            UnHover(currentHover);
        }
        currentHover = item;
        if (base.player.entity.display is CharacterDisplay characterDisplay && (characterDisplay.goldDisplay) && (priceManager.Get(item)))
        {
            int price = item.GetPrice();
            if (price <= base.player.data.inventory.gold)
            {
                characterDisplay.goldDisplay.ShowChange(-price);
            }
        }
        Events.InvokeShopItemHover(item);
    }

    public void UnHover(ShopItem item)
    {
        if (currentHover == item)
        {
            currentHover = null;
            if (base.player.entity.display is CharacterDisplay characterDisplay && (characterDisplay.goldDisplay))
            {
                characterDisplay.goldDisplay.HideChange();
            }
            Events.InvokeShopItemUnHover(item);
        }
    }

    public void CreateUpgrade(CardUpgradeData upgradeDataClone, int price, float priceFactor)
    {
        //IL_0097: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cc: Unknown result type (might be due to invalid IL or missing references)
        CardCharmHolder cardCharmHolder = holders.FirstOrDefault((CardCharmHolder a) => ((Component)a).transform.childCount == 0);
        if ((cardCharmHolder))
        {
            UpgradeDisplay upgradeDisplay = cardCharmHolder.Create(upgradeDataClone);
            ShopItem shopItem = ((Component)upgradeDisplay).gameObject.AddComponent<ShopItem>();
            items.Add(shopItem);
            ShopPrice shopPrice = priceManager.Add(shopItem, ShopPrice.Position.Bottom);
            shopPrice.SetPrice(price, priceFactor);
            shopPrice.SetOffset(new Vector3(0f, -1.5f, 0f));
            shopPrice.scaleWithTarget = 0f;
            shopPrice.scaleOffsetWithTarget = 0f;
            CardCharmInteraction component = ((Component)upgradeDisplay).GetComponent<CardCharmInteraction>();
            component.popUpOffset = new Vector2(1f, -0.25f);
            component.onHover.AddListener((UnityAction<UpgradeDisplay>)delegate
            {
                Hover(shopItem);
            });
            component.onUnHover.AddListener((UnityAction<UpgradeDisplay>)delegate
            {
                UnHover(shopItem);
            });
            component.onDrag.AddListener((UnityAction<UpgradeDisplay>)delegate
            {
                TryBuy(shopItem);
            });
        }
    }
}
public class EventRoutineClunkShop : EventRoutine
{
    [Serializable]
    public class Data
    {
        public List<CardItem> cards = new List<CardItem>();

        public List<CharmItem> charms = new List<CharmItem>();
    }

    [Serializable]
    public abstract class Item
    {
        public int price;

        public float priceFactor = 1f;

        public bool purchased;

        public Item()
        {
        }
    }

    [Serializable]
    public class CardItem : Item
    {
        public string dataName;

        public CardItem()
        {
        }

        public CardItem(CardData cardData, float priceFactor = 1f)
        {
            dataName = (cardData).name;
            price = Mathf.RoundToInt((float)cardData.value * priceFactor);
        }
    }

    [Serializable]
    public class CharmItem : Item
    {
        public string dataName;

        public CharmItem()
        {
        }

        public CharmItem(string upgradeDataName, int price, float priceFactor = 1f)
        {
            dataName = upgradeDataName;
            base.price = price;
            price = Mathf.RoundToInt((float)price * priceFactor);
        }
    }

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public ShopPriceManager priceManager;

    [SerializeField]
    public CardContainer[] cardContainers;

    [SerializeField]
    public CardCharmHolder[] charmHolders;

    [SerializeField]
    public GainCharmSequence gainCharmSequence;

    public ShopItem currentHover;

    public bool promptEnd;

    public void OnEnable()
    {
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
    }

    public void EntityHover(Entity entity)
    {
        ShopItem component = ((Component)entity).GetComponent<ShopItem>();
        if (component != null)
        {
            Hover(component);
        }
    }

    public void EntityUnHover(Entity entity)
    {
        ShopItem component = ((Component)entity).GetComponent<ShopItem>();
        if (component != null)
        {
            UnHover(component);
        }
    }

    public override IEnumerator Run()
    {
        cardController.owner = base.player;
        cardSelector.character = base.player;
        ((Behaviour)cardController).enabled = true;
        ((Behaviour)cardSelector).enabled = true;
        while (!promptEnd)
        {
            yield return null;
        }
        promptEnd = false;
        ((Behaviour)cardController).enabled = false;
        ((Behaviour)cardSelector).enabled = false;
    }

    public override IEnumerator Populate()
    {
        CinemaBarSystem.Clear();
        UnPopulate();
        Data shopData = DictionaryExt.Get<Data>(base.data, "shopData");
        int cardCount = shopData.cards.Count;
        for (int i = 0; i < cardCount; i++)
        {
            CardItem item = shopData.cards[i];
            if (!item.purchased)
            {
                CardContainer container = ((cardContainers.Length > i) ? cardContainers[i] : null);
                if (!(container))
                {
                    break;
                }
                container.SetSize(1, 0.67f);
                CardData cardData = AddressableLoader.Get<CardData>("CardData", item.dataName).Clone();
                Card card = CardManager.Get(cardData, cardController, base.player, inPlay: false, isPlayerCard: true);
                yield return card.UpdateData();
                container.Add(card.entity);
                container.SetChildPositions();
                ShopItem target = ((Component)card).gameObject.AddComponent<ShopItem>();
                priceManager.Add(target, ShopPrice.Position.Bottom).SetPrice(item.price, item.priceFactor);
            }
        }
        int count = shopData.charms.Count;
        for (int j = 0; j < count; j++)
        {
            CharmItem charmItem = shopData.charms[j];
            if (!charmItem.purchased)
            {
                CardCharmHolder cardCharmHolder = ((charmHolders.Length > j) ? charmHolders[j] : null);
                if (cardCharmHolder == null)
                {
                    break;
                }
                CardUpgradeData upgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", charmItem.dataName).Clone();
                UpgradeDisplay charm = cardCharmHolder.Create(upgradeData);
                cardCharmHolder.SetPositions();
                ShopItem shopItem = ((Component)charm).gameObject.AddComponent<ShopItem>();
                CardCharmInteraction orAdd = GameObjectExt.GetOrAdd<CardCharmInteraction>(((Component)charm).gameObject);
                orAdd.canHover = true;
                orAdd.canDrag = true;
                orAdd.onHover.AddListener((UnityAction<UpgradeDisplay>)delegate
                {
                    Hover(shopItem);
                });
                orAdd.onUnHover.AddListener((UnityAction<UpgradeDisplay>)delegate
                {
                    UnHover(shopItem);
                });
                orAdd.onDrag.AddListener((UnityAction<UpgradeDisplay>)delegate
                {
                    TryBuyCharm(charm as CardCharm);
                });
                orAdd.popUpOffset = new Vector2(0.8f, -0.3f);
                priceManager.Add(shopItem, ShopPrice.Position.Top).SetPrice(charmItem.price, charmItem.priceFactor);
            }
        }
    }

    public void UnPopulate()
    {
        CardContainer[] array = cardContainers;
        foreach (CardContainer obj in array)
        {
            obj.DestroyAll();
            obj.Clear();
        }
        CardCharmHolder[] array2 = charmHolders;
        for (int i = 0; i < array2.Length; i++)
        {
            array2[i].Clear();
        }
        priceManager.Clear();
    }

    public bool TryBuy(ShopItem item)
    {
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        bool result = false;
        int price = item.GetPrice();
        if (base.player.data.inventory.gold >= price)
        {
            SfxSystem.OneShot("event:/sfx/location/shop/buying");
            priceManager.Remove(item);
            base.player.SpendGold(price);
            Events.InvokeShopItemPurchase(item);
            result = true;
        }
        return result;
    }

    public void TryBuy(Entity entity)
    {
        ShopItem component = ((Component)entity).GetComponent<ShopItem>();
        if (component != null && TryBuy(component))
        {
            DictionaryExt.Get<Data>(base.data, "shopData").cards.Find((CardItem a) => a.dataName == (entity.data).name).purchased = true;
            cardSelector.TakeCard(entity);
        }
    }

    public void TryBuyCharm(CardCharm charm)
    {
        ShopItem component = ((Component)charm).GetComponent<ShopItem>();
        if (component != null && TryBuy(component))
        {
            DictionaryExt.Get<Data>(base.data, "shopData").charms.Find((CharmItem a) => a.dataName == (charm.data).name).purchased = true;
            gainCharmSequence.SetCharacter(base.player);
            gainCharmSequence.SetCharm(charm.data);
            gainCharmSequence.Begin();
            GameObjectExt.Destroy(((Component)charm).gameObject);
        }
    }

    public void Hover(ShopItem item)
    {
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        if (base.player.entity.display is CharacterDisplay characterDisplay && characterDisplay.goldDisplay != null && priceManager.Get(item) != null)
        {
            int price = item.GetPrice();
            if (price <= base.player.data.inventory.gold)
            {
                currentHover = item;
                characterDisplay.goldDisplay.ShowChange(-price);
            }
        }
        Events.InvokeShopItemHover(item);
    }

    public void UnHover(ShopItem item)
    {
        if (currentHover == item)
        {
            if (base.player.entity.display is CharacterDisplay characterDisplay && characterDisplay.goldDisplay != null)
            {
                characterDisplay.goldDisplay.HideChange();
            }
            currentHover = null;
            Events.InvokeShopItemUnHover(item);
        }
    }

    public void End()
    {
        promptEnd = true;
        ((Behaviour)cardController).enabled = false;
    }
}
public class EventRoutineCompanion : EventRoutine, IRerollable
{
    [SerializeField]
    public ChooseNewCardSequence sequence;

    [SerializeField]
    public InspectNewUnitSequence inspectSequence;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public CardContainer cardContainer;

    [SerializeField]
    public Animator animator;

    [SerializeField]
    public ParticleSystem chunkParticles;

    [SerializeField]
    public ParticleSystem chunkBigParticles;

    [SerializeField]
    public ParticleSystem breakFx;

    [SerializeField]
    public LocalizedString breakKey;

    [SerializeField]
    public LocalizedString chooseKey;

    [SerializeField]
    public SfxLoop loop1;

    [SerializeField]
    public SfxLoop loop2;

    public bool analyticsEventSent;

    public bool broken => DictionaryExt.Get<int>(base.data, "damage") > 3;

    public void Hit(BaseEventData eventData)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        PointerEventData val = (PointerEventData)(object)((eventData is PointerEventData) ? eventData : null);
        if ((val == null || (int)val.button == 0) && !broken)
        {
            base.data["damage"] = DictionaryExt.Get<int>(base.data, "damage") + 1;
            UpdateAnimator();
            TakeHit();
        }
    }

    public void UpdateAnimator()
    {
        animator.SetInteger("Damage", DictionaryExt.Get<int>(base.data, "damage"));
        animator.SetBool("Broken", broken);
    }

    public void TakeHit()
    {
        //IL_0085: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        animator.SetTrigger("Hit");
        if (broken)
        {
            Events.InvokeScreenShake(5f, 0f);
            if (chunkParticles != null)
            {
                chunkParticles.Play();
            }
            if (chunkBigParticles != null)
            {
                chunkBigParticles.Play();
            }
            if (breakFx != null)
            {
                breakFx.Play();
            }
            ScreenFlashSystem.SetDrawOrder("Transition", 0);
            ScreenFlashSystem.SetColour(ColorExt.WithAlpha(Color.white, 0.45f));
            ScreenFlashSystem.Run(0.175f);
            CinemaBarSystem.Top.SetPrompt(chooseKey.GetLocalizedString(), "Select");
            SfxSystem.OneShot("event:/sfx/location/travelers/break");
        }
        else
        {
            Events.InvokeScreenShake(1f, 0f);
            if (chunkParticles != null)
            {
                chunkParticles.Play();
            }
            SfxSystem.OneShot("event:/sfx/location/travelers/hit");
        }
    }

    public override IEnumerator Populate()
    {
        string[] saveCollection = base.data.GetSaveCollection<string>("cards");
        cardContainer.SetSize(saveCollection.Length, 0.8f);
        Routine.Clump clump = new Routine.Clump();
        for (int i = 0; i < saveCollection.Length; i++)
        {
            string assetName = saveCollection[i];
            CardData cardDataClone = AddressableLoader.Get<CardData>("CardData", assetName).Clone();
            CheckAddUpgrades(i, cardDataClone);
            Card card = CardManager.Get(cardDataClone, cardController, base.player, inPlay: false, isPlayerCard: true);
            if (!((Component)cardContainer).gameObject.activeInHierarchy)
            {
                card.entity.flipper.FlipDownInstant();
            }
            cardContainer.Add(card.entity);
            clump.Add(card.UpdateData());
        }
        yield return clump.WaitForEnd();
        foreach (Entity item in cardContainer)
        {
            Transform transform = item.transform;
            transform.localPosition = cardContainer.GetChildPosition(item);
            transform.localScale = cardContainer.GetChildScale(item);
            transform.localEulerAngles = cardContainer.GetChildRotation(item);
        }
        UpdateAnimator();
        if (broken)
        {
            CinemaBarSystem.Clear();
        }
        else
        {
            CinemaBarSystem.Top.SetPrompt(breakKey.GetLocalizedString(), "Select");
        }
    }

    public override IEnumerator Run()
    {
        cardController.owner = base.player;
        cardSelector.character = base.player;
        loop1.Play();
        bool loop2Started = false;
        while (!broken)
        {
            if (!loop2Started && DictionaryExt.Get<int>(base.data, "damage") > 2)
            {
                loop2.Play();
                loop2Started = true;
            }
            yield return null;
        }
        loop1.Stop();
        loop2.Stop();
        if (!analyticsEventSent)
        {
            foreach (Entity item in cardContainer)
            {
                Events.InvokeEntityOffered(item);
            }
            analyticsEventSent = true;
        }
        yield return Sequences.Wait(0.3f);
        yield return sequence.Run();
        CinemaBarSystem.Clear();
        node.SetCleared();
    }

    public void TrySelect(Entity entity)
    {
        ActionSelect action = new ActionSelect(entity, delegate
        {
            inspectSequence.SetUnit(entity);
            inspectSequence.Begin();
            ((Behaviour)cardController).enabled = false;
            cardController.UnHover(entity);
        });
        if (Events.CheckAction(action))
        {
            ActionQueue.Add(action);
        }
    }

    public void TrySkip()
    {
        ActionSelect action = new ActionSelect(null, delegate
        {
            sequence.Skip();
        });
        if (Events.CheckAction(action))
        {
            ActionQueue.Add(action);
        }
    }

    public void CardSelected(Entity entity)
    {
        sequence.End();
        ((Behaviour)cardController).enabled = false;
        Events.InvokeEntityChosen(entity);
    }

    public bool Reroll()
    {
        if (!((Component)cardContainer).gameObject.activeInHierarchy || !((Behaviour)cardSelector).enabled || InspectSystem.IsActive())
        {
            return false;
        }
        InspectNewUnitSequence inspectNewUnitSequence = Object.FindObjectOfType<InspectNewUnitSequence>();
        if (inspectNewUnitSequence != null && ((Component)inspectNewUnitSequence).gameObject.activeSelf)
        {
            return false;
        }
        CardData[] list = ((Component)cardController.owner).GetComponent<CharacterRewards>().Pull<CardData>(node, "Units", base.data.GetSaveCollection<string>("cards").Length);
        base.data["cards"] = ((IList<CardData>)list).ToSaveCollectionOfNames<CardData>();
        foreach (Entity item in cardContainer)
        {
            CardManager.ReturnToPool(item);
        }
        cardContainer.Clear();
        StartCoroutine(Populate());
        CardPopUp.Clear();
        return true;
    }
}
public class EventRoutineCopyItem : EventRoutine
{
    public CardContainer cardContainer;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public CardType[] canCopyCardTypes;

    [SerializeField]
    public LocalizedString promptKey;

    [SerializeField]
    public LocalizedString confirmPromptKey;

    [SerializeField]
    public TweenUI moveToSide;

    [SerializeField]
    public TweenUI moveToCentre;

    [SerializeField]
    public Transform toCopyAnchor;

    [SerializeField]
    public Talker talker;

    public Button backButton;

    public bool cardsCreated;

    public bool promptOpenGrid;

    public bool promptCloseGrid;

    public bool promptCopy;

    public Entity toCopy;

    public int toCopyOriginalIndex;

    public Entity copyEntity;

    public bool promptEnd;

    public bool gridOpen;

    public override IEnumerator Run()
    {
        int num = DictionaryExt.Get<int>(base.data, "enterCount") + 1;
        base.data["enterCount"] = num;
        cardController.owner = base.player;
        cardSelector.character = base.player;
        cardContainer.owner = base.player;
        CinemaBarSystem.Top.SetPrompt(promptKey.GetLocalizedString(), "Select");
        promptOpenGrid = true;
        while (!promptEnd || promptCopy)
        {
            if (promptOpenGrid)
            {
                promptOpenGrid = false;
                if (!gridOpen)
                {
                    yield return OpenGrid();
                }
            }
            else if (promptCloseGrid)
            {
                promptCloseGrid = false;
                if (gridOpen)
                {
                    yield return CloseGrid();
                }
            }
            else if (promptCopy)
            {
                yield return CopyRoutine();
                promptCopy = false;
            }
            yield return null;
        }
        CinemaBarSystem.Clear();
        if (DictionaryExt.Get<int>(base.data, "canCopy") <= 0)
        {
            node.SetCleared();
        }
    }

    public IEnumerator OpenGrid()
    {
        gridOpen = true;
        cardController.Enable();
        if (!cardsCreated)
        {
            cardsCreated = true;
            Routine.Clump clump = new Routine.Clump();
            clump.Add(CreateCards());
            clump.Add(Sequences.Wait(0.2f));
            yield return clump.WaitForEnd();
        }
        ((Component)cardContainer).gameObject.SetActive(true);
        ((Component)cardContainer).transform.localScale = Vector3.one * 0.5f;
        LeanTween.scale(((Component)cardContainer).gameObject, Vector3.one, 1.25f).setEase(LeanTweenType.easeOutElastic);
    }

    public IEnumerator CreateCards()
    {
        Routine.Clump clump = new Routine.Clump();
        List<CardData> list = new List<CardData>();
        foreach (CardData item in base.player.data.inventory.deck)
        {
            if (IArrayExt.Contains<CardType>(canCopyCardTypes, item.cardType))
            {
                list.Add(item);
            }
        }
        foreach (CardData item2 in base.player.data.inventory.reserve)
        {
            if (IArrayExt.Contains<CardType>(canCopyCardTypes, item2.cardType))
            {
                list.Add(item2);
            }
        }
        foreach (CardData item3 in list)
        {
            Card card = CardManager.Get(item3, cardController, base.player, inPlay: false, isPlayerCard: true);
            cardContainer.Add(card.entity);
            clump.Add(card.UpdateData());
        }
        yield return clump.WaitForEnd();
        cardContainer.SetChildPositions();
    }

    public IEnumerator CloseGrid()
    {
        gridOpen = false;
        float num = 0.3f;
        LeanTween.scale(((Component)cardContainer).gameObject, Vector3.zero, num).setEase(LeanTweenType.easeInBack).setOnComplete((Action)delegate
        {
            ((Component)cardContainer).gameObject.SetActive(false);
        });
        yield return (object)new WaitForSeconds(num);
    }

    public void Copy(Entity entity)
    {
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        if (toCopy == entity)
        {
            promptCopy = true;
            copyEntity = entity;
            End();
        }
        else if (!(toCopy))
        {
            moveToCentre.Fire();
            toCopy = entity;
            toCopyOriginalIndex = cardContainer.IndexOf(entity);
            cardContainer.Remove(entity);
            entity.transform.SetParent(toCopyAnchor);
            LeanTween.moveLocal(((Component)entity).gameObject, Vector3.zero, 0.33f).setEaseOutQuart();
            promptCloseGrid = true;
            CinemaBarSystem.Top.SetPrompt(confirmPromptKey.GetLocalizedString(), "Select");
        }
    }

    public IEnumerator CopyRoutine()
    {
        ((Selectable)backButton).interactable = false;
        int num = DictionaryExt.Get<int>(base.data, "canCopy") - 1;
        base.data["canCopy"] = num;
        if (num <= 0)
        {
            PromptCloseGrid();
        }
        CardData cardData = copyEntity.data.Clone(runCreateScripts: false);
        cardData.upgrades.RemoveAll((CardUpgradeData a) => a.type == CardUpgradeData.Type.Crown);
        Card card = CardManager.Get(cardData, cardController, base.player, inPlay: false, isPlayerCard: true);
        yield return card.UpdateData();
        card.transform.position = copyEntity.transform.position;
        cardSelector.TakeCard(card.entity);
        promptCloseGrid = true;
        yield return (object)new WaitForSeconds(0.5f);
    }

    public void Back()
    {
        if ((toCopy))
        {
            promptOpenGrid = true;
            cardContainer.Insert(toCopyOriginalIndex, toCopy);
            toCopy = null;
            cardContainer.SetChildPositions();
            moveToSide.Fire();
            CinemaBarSystem.Top.SetPrompt(promptKey.GetLocalizedString(), "Select");
        }
        else
        {
            End();
        }
    }

    public void PromptCloseGrid()
    {
        promptCloseGrid = true;
    }

    public void End()
    {
        promptEnd = true;
        ((Selectable)backButton).interactable = false;
        cardController.Disable();
    }
}
public class EventRoutineCurseItems : EventRoutine
{
    [SerializeField]
    public ChooseNewCardSequence sequence;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public CardContainer cardContainer;

    [SerializeField]
    public Transform curseCardContainer;

    [SerializeField]
    public LocalizedString chooseKey;

    [SerializeField]
    public float cardScale = 0.8f;

    [SerializeField]
    public GameObject backButton;

    [SerializeField]
    public Talker talker;

    [SerializeField]
    public EventReference takeSfxEvent;

    public bool analyticsEventSent;

    public readonly List<Entity> cards = new List<Entity>();

    public readonly List<Entity> curses = new List<Entity>();

    public override IEnumerator Populate()
    {
        Routine.Clump clump = new Routine.Clump();
        string[] saveCollection = base.data.GetSaveCollection<string>("cards");
        cardContainer.SetSize(saveCollection.Length, cardScale);
        for (int i = 0; i < saveCollection.Length; i++)
        {
            string assetName = saveCollection[i];
            CardData cardDataClone = AddressableLoader.Get<CardData>("CardData", assetName).Clone();
            CheckAddUpgrades(i, cardDataClone);
            Card card = CardManager.Get(cardDataClone, cardController, base.player, inPlay: false, isPlayerCard: true);
            cards.Add(card.entity);
            card.entity.flipper.FlipDownInstant();
            cardContainer.Add(card.entity);
            clump.Add(card.UpdateData());
        }
        string[] saveCollection2 = base.data.GetSaveCollection<string>("curses");
        foreach (string text in saveCollection2)
        {
            if (text != null)
            {
                Card card2 = CardManager.Get(AddressableLoader.Get<CardData>("CardData", text).Clone(), cardController, base.player, inPlay: false, isPlayerCard: true);
                ((Behaviour)card2.entity.uINavigationItem).enabled = false;
                curses.Add(card2.entity);
                card2.transform.SetParent(curseCardContainer);
                clump.Add(card2.UpdateData());
                card2.entity.flipper.FlipDownInstant();
            }
            else
            {
                curses.Add(null);
            }
        }
        yield return clump.WaitForEnd();
        for (int k = 0; k < cardContainer.Count; k++)
        {
            Entity entity = cardContainer[k];
            Transform transform = entity.transform;
            transform.localPosition = cardContainer.GetChildPosition(entity);
            transform.localScale = cardContainer.GetChildScale(entity);
            transform.localEulerAngles = cardContainer.GetChildRotation(entity);
            Entity entity2 = curses[k];
            if ((entity2))
            {
                Transform transform2 = entity2.transform;
                transform2.position = transform.position;
                transform2.localScale = Vector3.one * 0.85f;
                transform2.localEulerAngles = new Vector3(0f, 0f, 0f - Random.Range(5f, 10f));
            }
        }
    }

    public override IEnumerator Run()
    {
        int num = DictionaryExt.Get<int>(base.data, "enterCount", 0) + 1;
        base.data["enterCount"] = num;
        if (num == 1)
        {
            talker.Say("greet", PettyRandom.Range(0.5f, 1f));
        }
        sequence.owner = base.player;
        cardController.owner = base.player;
        cardSelector.character = base.player;
        CinemaBarSystem.Top.SetScript(chooseKey.GetLocalizedString());
        if (!DictionaryExt.Get<bool>(base.data, "analyticsEventSent", false))
        {
            foreach (Entity item in cardContainer)
            {
                Events.InvokeEntityOffered(item);
            }
            base.data["analyticsEventSent"] = true;
        }
        yield return sequence.Run();
        CinemaBarSystem.Clear();
        if (DictionaryExt.Get<SaveCollection<string>>(base.data, "cards").Count <= 0)
        {
            node.SetCleared();
        }
    }

    public void TrySelect(Entity entity)
    {
        ActionSelect action = new ActionSelect(entity, delegate
        {
            StartCoroutine(TakeCard(entity));
        });
        if (Events.CheckAction(action))
        {
            ActionQueue.Add(action);
        }
    }

    public IEnumerator TakeCard(Entity entity)
    {
        SfxSystem.OneShot(takeSfxEvent);
        cardController.Disable();
        backButton.SetActive(false);
        int index = cards.IndexOf(entity);
        Transform transform = entity.transform;
        Entity curse = curses[index];
        if ((curse))
        {
            Transform transform2 = curse.transform;
            transform2.position = transform.position;
            transform2.localScale = Vector3.one * cardScale;
            transform2.localRotation = Quaternion.identity;
            ((Component)curse).gameObject.SetActive(true);
            curse.flipper.FlipDownInstant();
        }
        cards.RemoveAt(index);
        SaveCollection<string> saveCollection = DictionaryExt.Get<SaveCollection<string>>(base.data, "cards");
        saveCollection.Remove(index);
        base.data["cards"] = saveCollection;
        curses.RemoveAt(index);
        SaveCollection<string> saveCollection2 = DictionaryExt.Get<SaveCollection<string>>(base.data, "curses");
        saveCollection2.Remove(index);
        base.data["curses"] = saveCollection2;
        cardSelector.TakeCard(entity);
        Events.InvokeEntityChosen(entity);
        talker.Say("thanks", 0f, entity.data.title);
        if ((curse))
        {
            yield return (object)new WaitForSeconds(0.5f);
            curse.flipper.FlipUp();
            yield return (object)new WaitForSeconds(0.5f);
            cardSelector.TakeCard(curse);
            Events.InvokeEntityChosen(curse);
        }
        yield return (object)new WaitForSeconds(0.3f);
        cardController.Enable();
        backButton.SetActive(true);
    }

    public void Back()
    {
        cardContainer.DestroyAll();
        cardContainer.Clear();
        cards.Clear();
        foreach (Entity curse in curses)
        {
            if ((curse))
            {
                CardManager.ReturnToPool(curse);
            }
        }
        curses.Clear();
        sequence.End();
    }
}
public class EventRoutineGnomeShop : EventRoutine, IRerollable
{
    [Serializable]
    public class Data
    {
        public string[] pool;

        public List<string> cards;

        public int price;

        public int priceAdd;

        public int cyclesThroughPool;
    }

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public CardContainer cardContainer;

    [SerializeField]
    public ShopPriceManager priceManager;

    [SerializeField]
    public ShopItem bell;

    [SerializeField]
    public float cardScale = 0.8f;

    public Entity currentCard;

    public bool promptReroll;

    public bool promptEnd;

    public override IEnumerator Populate()
    {
        Data data = DictionaryExt.Get<Data>(base.data, "data");
        priceManager.Add(bell, ShopPrice.Position.Bottom).SetPrice(data.price);
        cardContainer.SetSize(1, cardScale);
        string nextCard = GetNextCard(data);
        yield return CreateCard(nextCard);
    }

    public override IEnumerator Run()
    {
        cardController.owner = base.player;
        cardContainer.owner = base.player;
        cardSelector.character = base.player;
        currentCard.flipper.FlipUp();
        while (!promptEnd)
        {
            if (promptReroll)
            {
                yield return RerollRoutine();
                promptReroll = false;
            }
            else
            {
                yield return null;
            }
        }
    }

    public void TakeCard()
    {
        cardSelector.TakeCard(currentCard);
        cardController.Disable();
        Events.InvokeEntityChosen(currentCard);
        priceManager.Remove(bell);
        Button component = ((Component)bell).GetComponent<Button>();
        if (component != null)
        {
            ((Selectable)component).interactable = false;
        }
        promptEnd = true;
        node.SetCleared();
    }

    public string GetNextCard(Data shopData)
    {
        if (shopData.cards == null)
        {
            shopData.cards = new List<string>();
        }
        if (shopData.cards.Count <= 0)
        {
            Random.InitState(node.seed);
            for (int i = 0; i < shopData.cyclesThroughPool; i++)
            {
                Random.Range(0f, 1f);
            }
            string[] pool = shopData.pool;
            foreach (string item in pool)
            {
                shopData.cards.Insert(Random.Range(0, shopData.cards.Count), item);
            }
            shopData.cyclesThroughPool++;
        }
        string result = shopData.cards[0];
        shopData.cards.RemoveAt(0);
        return result;
    }

    public IEnumerator CreateCard(string cardDataName)
    {
        Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", cardDataName).Clone(), cardController, base.player, inPlay: false, isPlayerCard: true);
        currentCard = card.entity;
        card.transform.position = new Vector3(-999f, 0f, 0f);
        card.entity.flipper.FlipDownInstant();
        cardContainer.Add(card.entity);
        yield return card.UpdateData();
        cardContainer.SetChildPositions();
    }

    public void HitBell()
    {
        if (!promptEnd && !promptReroll)
        {
            int price = bell.GetPrice();
            if (((base.player.data.inventory.gold)).Value - price >= 0)
            {
                SfxSystem.OneShot("event:/sfx/location/shop/buying");
                base.player.SpendGold(price);
                Events.InvokeShopItemPurchase(bell);
                Reroll();
                priceManager.Remove(bell);
            }
        }
    }

    public bool Reroll()
    {
        promptReroll = true;
        return true;
    }

    public IEnumerator RerollRoutine()
    {
        cardController.Disable();
        InputSystem.Disable();
        currentCard.flipper.FlipDown();
        currentCard.RemoveFromContainers();
        Data shopData = DictionaryExt.Get<Data>(base.data, "data");
        string nextCard = GetNextCard(shopData);
        Entity preCard = currentCard;
        yield return CreateCard(nextCard);
        CardManager.ReturnToPool(preCard);
        currentCard.flipper.FlipUp();
        shopData.price += shopData.priceAdd;
        priceManager.Add(bell, ShopPrice.Position.Bottom).SetPrice(shopData.price);
        InputSystem.Enable();
        cardController.Enable();
    }
}
public class EventRoutineInjuredCompanion : EventRoutine
{
    [SerializeField]
    public ChooseNewCardSequence sequence;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardContainer cardContainer;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public InspectNewUnitSequence inspectSequence;

    [SerializeField]
    public StatusEffectData injuryEffect;

    [SerializeField]
    public SpriteRenderer[] bloodSplats;

    [SerializeField]
    public PromptShower tutorialPrompt;

    [SerializeField]
    public GameObject missingDataDisplay;

    public override IEnumerator Populate()
    {
        CardSaveData cardSaveData = DictionaryExt.Get<CardSaveData>(base.data, "cardSaveData");
        if (!MissingCardSystem.IsMissing(cardSaveData))
        {
            CardData cardData = cardSaveData.Load(keepId: false);
            AddInjuryIfNecessary(cardData);
            IListExt.RemoveWhere<CardUpgradeData>((IList<CardUpgradeData>)cardData.upgrades, (Predicate<CardUpgradeData>)((CardUpgradeData a) => a.type == CardUpgradeData.Type.Crown));
            yield return CreateCard(cardData);
        }
        else
        {
            missingDataDisplay.SetActive(true);
            End();
        }
    }

    public void AddInjuryIfNecessary(CardData cardData)
    {
        if (cardData.injuries == null)
        {
            cardData.injuries = new List<CardData.StatusEffectStacks>();
        }
        if (cardData.injuries.Count <= 0)
        {
            cardData.injuries.Add(new CardData.StatusEffectStacks(injuryEffect, 1));
        }
    }

    public override IEnumerator Run()
    {
        CinemaBarSystem.In();
        if (cardContainer.Count > 0)
        {
            tutorialPrompt.Show(cardContainer[0].data.title);
        }
        yield return Sequences.Wait(0.1f);
        yield return sequence.Run();
        CinemaBarSystem.Clear();
        node.SetCleared();
    }

    public IEnumerator CreateCard(CardData cardDataClone)
    {
        cardSelector.character = base.player;
        cardController.owner = base.player;
        cardContainer.SetSize(1, 0.8f);
        cardContainer.owner = base.player;
        Card card = CardManager.Get(cardDataClone, cardController, base.player, inPlay: false, isPlayerCard: true);
        card.entity.flipper.FlipDownInstant();
        cardContainer.Add(card.entity);
        SetBloodSplatColours(card.entity);
        yield return card.UpdateData();
        foreach (Entity item in cardContainer)
        {
            Transform transform = item.transform;
            transform.localPosition = cardContainer.GetChildPosition(item);
            transform.localScale = cardContainer.GetChildScale(item);
            transform.localEulerAngles = cardContainer.GetChildRotation(item);
        }
    }

    public void SetBloodSplatColours(Entity entity)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        Color bloodColour = Object.FindObjectOfType<SplatterSystem>().GetBloodColour(entity);
        SpriteRenderer[] array = bloodSplats;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].color = bloodColour;
        }
    }

    public void TrySelect(Entity entity)
    {
        ActionSelect action = new ActionSelect(entity, delegate
        {
            inspectSequence.SetUnit(entity);
            inspectSequence.Begin();
            ((Behaviour)cardController).enabled = false;
            cardController.UnHover(entity);
        });
        if (Events.CheckAction(action))
        {
            ActionQueue.Add(action);
        }
    }

    public void CardSelected(Entity entity)
    {
        Events.InvokeEntityChosen(entity);
        End();
    }

    public void End()
    {
        sequence.End();
        ((Behaviour)cardController).enabled = false;
        tutorialPrompt.Hide();
    }
}
public class EventRoutineMuncher : EventRoutine
{
    [SerializeField]
    public Animator muncherAnimator;

    [SerializeField]
    public TweenUI muncherMoveToSide;

    [SerializeField]
    public TweenUI muncherMoveToMid;

    public CardContainer cardContainer;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardType[] canEatCardTypes;

    [SerializeField]
    public LocalizedString initialPromptKey;

    [SerializeField]
    public LocalizedString feedPromptKey;

    [SerializeField]
    public ParticleSystem munchParticles;

    public Button backButton;

    [Header("Speech Bubs")]
    [SerializeField]
    public Talker talker;

    [SerializeField]
    public Vector2 sayDelay = new Vector2(0.8f, 1f);

    [SerializeField]
    public float greetingChance = 1f;

    [SerializeField]
    public float explainChance = 1f;

    public bool hoveringMuncher;

    public bool promptOpenGrid;

    public bool promptCloseGrid;

    public bool promptEnd;

    public bool gridOpen;

    public override IEnumerator Run()
    {
        int num = DictionaryExt.Get<int>(base.data, "enterCount") + 1;
        base.data["enterCount"] = num;
        cardController.owner = base.player;
        cardContainer.owner = base.player;
        UpdatePrompt();
        SfxSystem.OneShot("event:/sfx/location/muncher/enter");
        if (Random.value <= greetingChance && num == 1)
        {
            StartCoroutine(SayGreeting());
        }
        while (!promptEnd)
        {
            if (promptOpenGrid)
            {
                promptOpenGrid = false;
                if (!gridOpen && DictionaryExt.Get<int>(base.data, "canEat") > 0)
                {
                    base.data["openCount"] = DictionaryExt.Get<int>(base.data, "openCount") + 1;
                    gridOpen = true;
                    if (Random.value <= greetingChance)
                    {
                        StartCoroutine(SayExplain());
                    }
                    yield return OpenGrid();
                }
            }
            else if (promptCloseGrid)
            {
                promptCloseGrid = false;
                if (gridOpen)
                {
                    gridOpen = false;
                    yield return CloseGrid();
                }
            }
            yield return null;
        }
        CinemaBarSystem.Clear();
        if (DictionaryExt.Get<int>(base.data, "canEat") <= 0)
        {
            node.SetCleared();
        }
    }

    public IEnumerator SayGreeting()
    {
        float num = Vector2Ext.Random(sayDelay);
        yield return (object)new WaitForSeconds(num);
        if (DictionaryExt.Get<int>(base.data, "openCount") <= 0)
        {
            talker.Say("greet", 0f);
        }
    }

    public IEnumerator SayExplain()
    {
        float num = Vector2Ext.Random(sayDelay);
        yield return (object)new WaitForSeconds(num);
        if (DictionaryExt.Get<int>(base.data, "openCount") == 1)
        {
            talker.Say("explain", 0f);
        }
    }

    public IEnumerator OpenGrid()
    {
        SfxSystem.OneShot("event:/sfx/location/muncher/slide_right");
        CinemaBarSystem.Clear();
        muncherMoveToSide.Fire();
        cardController.Enable();
        Routine.Clump clump = new Routine.Clump();
        clump.Add(CreateCards());
        clump.Add(Sequences.Wait(0.2f));
        yield return clump.WaitForEnd();
        ((Component)cardContainer).gameObject.SetActive(true);
        ((Component)cardContainer).transform.localScale = Vector3.one * 0.5f;
        LeanTween.scale(((Component)cardContainer).gameObject, Vector3.one, 1.25f).setEase(LeanTweenType.easeOutElastic);
        UpdatePrompt();
    }

    public IEnumerator CreateCards()
    {
        Routine.Clump clump = new Routine.Clump();
        List<CardData> list = new List<CardData>();
        foreach (CardData item in base.player.data.inventory.deck)
        {
            if (IArrayExt.Contains<CardType>(canEatCardTypes, item.cardType))
            {
                list.Add(item);
            }
        }
        foreach (CardData item2 in base.player.data.inventory.reserve)
        {
            if (IArrayExt.Contains<CardType>(canEatCardTypes, item2.cardType))
            {
                list.Add(item2);
            }
        }
        foreach (CardData item3 in list)
        {
            Card card = CardManager.Get(item3, cardController, base.player, inPlay: false, isPlayerCard: true);
            cardContainer.Add(card.entity);
            clump.Add(card.UpdateData());
        }
        yield return clump.WaitForEnd();
        cardContainer.SetChildPositions();
    }

    public IEnumerator CloseGrid()
    {
        UpdatePrompt();
        cardController.Disable();
        float num = 0.5f;
        LeanTween.scale(((Component)cardContainer).gameObject, Vector3.zero, num).setEase(LeanTweenType.easeInBack).setOnComplete((Action)delegate
        {
            foreach (Entity item in cardContainer)
            {
                CardManager.ReturnToPool(item);
            }
            cardContainer.Clear();
            ((Component)cardContainer).gameObject.SetActive(false);
        });
        yield return (object)new WaitForSeconds(num);
        yield return null;
        SfxSystem.OneShot("event:/sfx/location/muncher/slide_left");
        muncherMoveToMid.Fire();
    }

    public void UpdatePrompt()
    {
        if (DictionaryExt.Get<int>(base.data, "canEat") > 0)
        {
            if (gridOpen)
            {
                CinemaBarSystem.Top.SetPrompt(feedPromptKey.GetLocalizedString(), "Select");
            }
            else
            {
                CinemaBarSystem.Top.SetPrompt(initialPromptKey.GetLocalizedString(), "Select");
            }
        }
        else
        {
            CinemaBarSystem.Clear();
        }
    }

    public void PromptOpenGrid(BaseEventData eventData)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        PointerEventData val = (PointerEventData)(object)((eventData is PointerEventData) ? eventData : null);
        if (val == null || (int)val.button == 0)
        {
            promptOpenGrid = true;
        }
    }

    public void PromptCloseGrid()
    {
        promptCloseGrid = true;
    }

    public void End()
    {
        promptEnd = true;
    }

    public void HoverMuncher()
    {
        hoveringMuncher = true;
    }

    public void UnHoverMuncher()
    {
        hoveringMuncher = false;
    }

    public void DragCardStart(Entity entity)
    {
        muncherAnimator.SetBool("DraggingCard", true);
        Events.InvokeMuncherDrag();
        NavigationState.Start(new NavigationStateMuncher(this));
    }

    public void DragCardEnd(Entity entity)
    {
        muncherAnimator.SetBool("DraggingCard", false);
        NavigationState.BackToPreviousState();
        Events.InvokeMuncherDragCancel();
        cardController.hoverEntity = null;
    }

    public void TryEatIfHovering(Entity entity)
    {
        if (hoveringMuncher && TryEat(entity))
        {
            Events.InvokeMuncherFeed(entity);
        }
    }

    public bool TryEat(Entity entity)
    {
        if (DictionaryExt.Get<int>(base.data, "canEat") > 0 && IArrayExt.Contains<CardType>(canEatCardTypes, entity.data.cardType))
        {
            Eat(entity);
            return true;
        }
        return false;
    }

    public void Eat(Entity entity)
    {
        if (IListExt.RemoveWhere<CardData>((IList<CardData>)entity.owner.data.inventory.deck, (Predicate<CardData>)((CardData a) => entity.data.id == a.id)))
        {
            Debug.Log(("[" + (entity.data).name + "] Removed From [" + (base.player).name + "] deck"));
        }
        else if (IListExt.RemoveWhere<CardData>((IList<CardData>)entity.owner.data.inventory.reserve, (Predicate<CardData>)((CardData a) => entity.data.id == a.id)))
        {
            Debug.Log(("[" + (entity.data).name + "] Removed From [" + (base.player).name + "] reserve"));
        }
        int num = DictionaryExt.Get<int>(base.data, "canEat") - 1;
        base.data["canEat"] = num;
        if (num <= 0)
        {
            PromptCloseGrid();
            talker.Say("full", 0f);
        }
        else
        {
            int num2 = DictionaryExt.Get<int>(base.data, "thankCount") + 1;
            base.data["thankCount"] = num2;
            if (num2 < 1)
            {
                talker.Say("thanks", 0f);
            }
        }
        entity.RemoveFromContainers();
        if (num > 0)
        {
            cardContainer.TweenChildPositions();
        }
        CardManager.ReturnToPool(entity);
        muncherAnimator.SetTrigger("Munch");
        Events.InvokeScreenShake(0.5f, 0f);
        munchParticles.Play();
    }
}
public class ItemEventRoutine : EventRoutine, IRerollable
{
    [SerializeField]
    public ChooseNewCardSequence sequence;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public CardContainer cardContainer;

    [SerializeField]
    public SpriteRenderer backgroundImage;

    [SerializeField]
    public Animator animator;

    [SerializeField]
    public ParticleSystem pulseParticleSystem;

    [SerializeField]
    public Button skipButton;

    [SerializeField]
    public LocalizedString openKey;

    [SerializeField]
    public LocalizedString chooseKey;

    [SerializeField]
    public SfxLoop loop;

    [SerializeField]
    public GameObject backButton;

    public bool cardTaken;

    public bool showCards;

    public bool promptOpen;

    public bool analyticsEventSent;

    public bool IsOpen => DictionaryExt.Get<bool>(base.data, "open");

    public void RunOpenRoutine(BaseEventData eventData)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        PointerEventData val = (PointerEventData)(object)((eventData is PointerEventData) ? eventData : null);
        if (val == null || (int)val.button == 0)
        {
            promptOpen = true;
        }
    }

    public IEnumerator OpenRoutine()
    {
        DeckpackBlocker.Block();
        SfxSystem.OneShot("event:/sfx/location/item_chest/claim");
        base.data["open"] = true;
        animator.SetBool("Open", true);
        Events.InvokeScreenRumble(0f, 1f, 0.05f, 0.7f, 0.2f, 0.05f);
        yield return Sequences.Wait(1f);
        Events.InvokeScreenShake(5f, 0f);
        animator.SetBool("Zoom", true);
        yield return null;
        Open();
        DeckpackBlocker.Unblock();
    }

    public void Open()
    {
        showCards = true;
        CinemaBarSystem.Top.SetPrompt(chooseKey.GetLocalizedString(), "");
        base.data["open"] = true;
        Image component = ((Component)backgroundImage).GetComponent<Image>();
        if (component != null)
        {
            ((Behaviour)component).enabled = false;
        }
        ParticleSystem obj = pulseParticleSystem;
        if (obj != null)
        {
            obj.Stop();
        }
        UINavigationDefaultSystem.SetStartingItem();
        if ((backButton))
        {
            backButton.SetActive(true);
        }
    }

    public void Close()
    {
        showCards = false;
        animator.SetBool("Open", false);
        CinemaBarSystem.Top.SetPrompt(openKey.GetLocalizedString(), "Select");
        Image component = ((Component)backgroundImage).GetComponent<Image>();
        if (component != null)
        {
            ((Behaviour)component).enabled = true;
        }
        ParticleSystem obj = pulseParticleSystem;
        if (obj != null)
        {
            obj.Play();
        }
    }

    public override IEnumerator Populate()
    {
        string[] saveCollection = base.data.GetSaveCollection<string>("cards");
        cardContainer.SetSize(saveCollection.Length, 0.8f);
        Routine.Clump clump = new Routine.Clump();
        for (int i = 0; i < saveCollection.Length; i++)
        {
            string assetName = saveCollection[i];
            CardData cardDataClone = AddressableLoader.Get<CardData>("CardData", assetName).Clone();
            CheckAddUpgrades(i, cardDataClone);
            Card card = CardManager.Get(cardDataClone, cardController, base.player, inPlay: false, isPlayerCard: true);
            if (!((Component)cardContainer).gameObject.activeInHierarchy)
            {
                card.entity.flipper.FlipDownInstant();
            }
            cardContainer.Add(card.entity);
            clump.Add(card.UpdateData());
        }
        yield return clump.WaitForEnd();
        foreach (Entity item in cardContainer)
        {
            Transform transform = item.transform;
            transform.localPosition = cardContainer.GetChildPosition(item);
            transform.localScale = cardContainer.GetChildScale(item);
            transform.localEulerAngles = cardContainer.GetChildRotation(item);
        }
        if (DictionaryExt.Get<bool>(base.data, "open"))
        {
            Open();
            animator.SetBool("Zoom", true);
        }
        else
        {
            Close();
        }
    }

    public override IEnumerator Run()
    {
        sequence.owner = base.player;
        cardController.owner = base.player;
        cardSelector.character = base.player;
        if (!DictionaryExt.Get<bool>(base.data, "open"))
        {
            loop.Play();
        }
        while (!DictionaryExt.Get<bool>(base.data, "open"))
        {
            if (promptOpen)
            {
                promptOpen = false;
                if (!DictionaryExt.Get<bool>(base.data, "open"))
                {
                    loop.Stop();
                    yield return OpenRoutine();
                }
            }
            yield return null;
        }
        if (!analyticsEventSent)
        {
            foreach (Entity item in cardContainer)
            {
                Events.InvokeEntityOffered(item);
            }
            analyticsEventSent = true;
        }
        yield return sequence.Run();
        CinemaBarSystem.Clear();
        if (cardTaken)
        {
            node.SetCleared();
        }
    }

    public void TrySelect(Entity entity)
    {
        if (cardTaken)
        {
            return;
        }
        ActionSelect action = new ActionSelect(entity, delegate
        {
            cardSelector.TakeCard(entity);
            cardController.Disable();
            if ((skipButton))
            {
                ((Selectable)skipButton).interactable = false;
            }
            if ((backButton))
            {
                backButton.SetActive(false);
            }
            cardTaken = true;
            Events.InvokeEntityChosen(entity);
        });
        if (Events.CheckAction(action))
        {
            ActionQueue.Add(action);
        }
    }

    public void TrySkip()
    {
        ActionSelect action = new ActionSelect(null, delegate
        {
            sequence.Skip();
        });
        if (Events.CheckAction(action))
        {
            ActionQueue.Add(action);
        }
    }

    public bool Reroll()
    {
        if (!((Component)cardContainer).gameObject.activeInHierarchy || !((Behaviour)cardSelector).enabled || InspectSystem.IsActive())
        {
            return false;
        }
        InspectNewUnitSequence inspectNewUnitSequence = Object.FindObjectOfType<InspectNewUnitSequence>();
        if (inspectNewUnitSequence != null && ((Component)inspectNewUnitSequence).gameObject.activeSelf)
        {
            return false;
        }
        CardData[] list = ((Component)cardController.owner).GetComponent<CharacterRewards>().Pull<CardData>(node, "Items", base.data.GetSaveCollection<string>("cards").Length);
        base.data["cards"] = ((IList<CardData>)list).ToSaveCollectionOfNames<CardData>();
        foreach (Entity item in cardContainer)
        {
            CardManager.ReturnToPool(item);
        }
        cardContainer.Clear();
        StartCoroutine(Populate());
        CardPopUp.Clear();
        return true;
    }
}
public class ShopItem : MonoBehaviour, IRemoveWhenPooled
{
    public int price;

    public float priceFactor;

    public int GetPrice()
    {
        return Mathf.RoundToInt((float)price * priceFactor);
    }
}
public class ShopPrice : MonoBehaviour
{
    public enum Position
    {
        Top,
        Bottom
    }

    public ShopItem target;

    public Transform follow;

    [SerializeField]
    public Vector3 offset;

    [SerializeField]
    public TMP_Text textAsset;

    [SerializeField]
    public string format = "{0}<sprite name=bling>";

    [SerializeField]
    public string discountedFormat = "<color=red><s>{1}</s></color> {0}<sprite name=bling>";

    public float scaleWithTarget = 0.5f;

    public float scaleOffsetWithTarget = 0.5f;

    public void Set(ShopItem target, Vector3 offset)
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        this.target = target;
        follow = ((Component)target).transform;
        this.offset = offset;
    }

    public void SetOffset(Vector3 offset)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        this.offset = offset;
    }

    public void SetPrice(int price, float priceFactor = 1f)
    {
        target.price = price;
        target.priceFactor = priceFactor;
        if (priceFactor != 1f)
        {
            SetText(string.Format(discountedFormat, target.GetPrice(), price));
        }
        else
        {
            SetText(string.Format(format, price));
        }
    }

    public void SetText(string text)
    {
        textAsset.text = text;
    }

    public bool Check()
    {
        return follow != null;
    }

    public void UpdatePosition()
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_007f: Unknown result type (might be due to invalid IL or missing references)
        //IL_008a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0095: Unknown result type (might be due to invalid IL or missing references)
        if (follow == null)
        {
            GameObjectExt.Destroy(gameObject);
            return;
        }
        Vector3 val = offset;
        if (scaleOffsetWithTarget > 0f)
        {
            val = Vector3.Scale(val, Vector3.Lerp(Vector3.one, follow.localScale, scaleOffsetWithTarget));
        }
        transform.position = follow.position + val;
        if (scaleWithTarget > 0f)
        {
            transform.localScale = Vector3.Lerp(Vector3.one, follow.localScale, scaleWithTarget);
        }
    }
}
public class ShopPriceManager : MonoBehaviour
{
    [Serializable]
    public struct PositionProfile
    {
        public ShopPrice.Position type;

        public Vector3 offset;
    }

    [SerializeField]
    public ShopPrice pricePrefab;

    [SerializeField]
    public List<ShopPrice> targets = new List<ShopPrice>();

    [SerializeField]
    public PositionProfile[] positionProfiles;

    public void LateUpdate()
    {
        for (int num = targets.Count - 1; num >= 0; num--)
        {
            ShopPrice shopPrice = targets[num];
            if (!(shopPrice))
            {
                targets.RemoveAt(num);
            }
            else
            {
                shopPrice.UpdatePosition();
            }
        }
    }

    public ShopPrice Add(ShopItem target, ShopPrice.Position position)
    {
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        PositionProfile positionProfile = positionProfiles.FirstOrDefault((PositionProfile a) => a.type == position);
        ShopPrice shopPrice = Object.Instantiate<ShopPrice>(pricePrefab, transform, false);
        shopPrice.Set(target, positionProfile.offset);
        ((Component)shopPrice).gameObject.SetActive(true);
        targets.Add(shopPrice);
        return shopPrice;
    }

    public ShopPrice Get(ShopItem target)
    {
        return targets.Find((ShopPrice a) => a.target == target);
    }

    public void Remove(ShopItem target)
    {
        ShopPrice shopPrice = Get(target);
        GameObjectExt.Destroy(((Component)shopPrice).gameObject);
        targets.Remove(shopPrice);
    }

    public void Clear()
    {
        foreach (ShopPrice target in targets)
        {
            ComponentExt.Destroy((Component)(object)target);
        }
        targets.Clear();
    }
}
public class ShopRoutine : EventRoutine
{
    [Serializable]
    public class Data : ICloneable
    {
        public List<Item> items = new List<Item>();

        public List<string[]> upgrades = new List<string[]>();

        public List<string> charms = new List<string>();

        public int charmPrice = 50;

        public int charmPriceAdd = 20;

        public bool hasCrown = true;

        public string crownType;

        public int crownPrice = 120;

        public int crownPriceAdd = 30;

        public int openCount;

        public object Clone()
        {
            return new Data
            {
                items = items.Select((Item a) => (Item)a.Clone()).ToList(),
                upgrades = IListExt.Clone<string[]>((IEnumerable<string[]>)upgrades),
                charms = IListExt.Clone<string>((IEnumerable<string>)charms),
                charmPrice = charmPrice,
                charmPriceAdd = charmPriceAdd,
                hasCrown = hasCrown,
                crownType = crownType,
                crownPrice = crownPrice,
                crownPriceAdd = crownPriceAdd,
                openCount = openCount
            };
        }
    }

    [Serializable]
    public class Item : ICloneable
    {
        public string category;

        public string cardDataName;

        public int price;

        public float priceFactor = 1f;

        public bool purchased;

        public Item()
        {
        }

        public Item(string category, CardData cardData, int priceOffset, float priceFactor = 1f)
        {
            this.category = category;
            cardDataName = (cardData).name;
            price = Mathf.RoundToInt((float)cardData.value * priceFactor) + priceOffset;
        }

        public object Clone()
        {
            return new Item
            {
                category = category,
                cardDataName = cardDataName,
                price = price,
                priceFactor = priceFactor,
                purchased = purchased
            };
        }
    }

    [Serializable]
    public struct Container
    {
        public string category;

        public CardContainer container;

        public float cardScale;

        public ShopPrice.Position pricePosition;
    }

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public float cardContainerRandomAngle = 2f;

    [SerializeField]
    public ShopPriceManager priceManager;

    [SerializeField]
    public Animator animator;

    [SerializeField]
    public LocalizedString enterKey;

    [SerializeField]
    public string brokenVaseCardName = "BrokenVase";

    [Header("Card Containers")]
    [SerializeField]
    public Container[] containers;

    [Header("Charms")]
    [SerializeField]
    public CharmMachine charmMachine;

    [SerializeField]
    public OpenCharmBlockSequence openSequence;

    [SerializeField]
    public Transform charmBlock;

    [Header("Crown")]
    [SerializeField]
    public CrownHolderShop crownHolder;

    [SerializeField]
    public GainCrownSequence gainCrownSequence;

    [Header("Speech Bubs")]
    [SerializeField]
    public Talker talker;

    [SerializeField]
    public Vector2 sayDelay = new Vector2(0.8f, 1f);

    [SerializeField]
    public float speechBubDelay = 1f;

    [Header("Music")]
    [SerializeField]
    public EventReference music;

    [SerializeField]
    public SfxLoop ovenCrackleLoop;

    public bool open;

    public bool promptOpen;

    public bool promptClose;

    public bool promptEnd;

    public bool promptBuyCharm;

    public bool promptBuyCrown;

    public bool endWhenClosed = true;

    public List<Entity> entities;

    public ShopItem currentHover;

    public float speechBubTimer;

    public int secretCount;

    public ShopItem secretClick;

    public int secretClickCount;

    public void OnEnable()
    {
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
    }

    public void EntityHover(Entity entity)
    {
        ShopItem component = ((Component)entity).GetComponent<ShopItem>();
        if (component != null)
        {
            Hover(component);
        }
    }

    public void EntityUnHover(Entity entity)
    {
        ShopItem component = ((Component)entity).GetComponent<ShopItem>();
        if (component != null)
        {
            UnHover(component);
        }
    }

    public void Update()
    {
        if (speechBubTimer > 0f)
        {
            speechBubTimer -= Time.deltaTime;
        }
    }

    public override IEnumerator Run()
    {
        secretCount = Random.Range(7, 10);
        CinemaBarSystem.Top.SetPrompt(enterKey.GetLocalizedString(), "Select");
        MusicSystem.StopMusic((STOP_MODE)0);
        MusicSystem.StartMusic(music);
        MusicSystem.SetParam("shop_enter", 0f);
        cardController.owner = base.player;
        cardSelector.character = base.player;
        while (!promptEnd)
        {
            if (promptBuyCharm)
            {
                yield return BuyCharmRoutine();
            }
            else if (promptBuyCrown)
            {
                yield return BuyCrownRoutine();
            }
            else if (!open && promptOpen)
            {
                yield return OpenRoutine();
                ovenCrackleLoop.Play();
            }
            else if (open && promptClose)
            {
                yield return CloseRoutine();
                if (endWhenClosed)
                {
                    End();
                }
            }
            else
            {
                yield return null;
            }
        }
        promptEnd = false;
        ovenCrackleLoop.Stop();
        ((Behaviour)cardController).enabled = false;
        ((Behaviour)cardSelector).enabled = false;
        if (base.player.entity.display is CharacterDisplay characterDisplay && (characterDisplay.goldDisplay))
        {
            characterDisplay.goldDisplay.HideChange();
        }
    }

    public void Bub(string speechType, params object[] inserts)
    {
        if (speechBubTimer <= 0f)
        {
            talker.Say(speechType, 0f, inserts);
            speechBubTimer = speechBubDelay;
        }
    }

    public void Open(BaseEventData eventData)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        PointerEventData val = (PointerEventData)(object)((eventData is PointerEventData) ? eventData : null);
        if ((val == null || (int)val.button == 0) && !open && !promptOpen)
        {
            promptOpen = true;
        }
    }

    public void Close()
    {
        if (open && !promptClose)
        {
            promptClose = true;
        }
    }

    public IEnumerator OpenRoutine()
    {
        SfxSystem.OneShot("event:/sfx/location/shop/visit");
        animator.SetBool("Zoom", true);
        promptOpen = false;
        open = true;
        int num = (int)DictionaryExt.GetValueOrDefault<string, object>(base.data, "openCount", (object)0);
        if (num <= 0)
        {
            float num2 = Vector2Ext.Random(sayDelay) - 0.5f;
            if (DictionaryExt.Get<Data>(base.data, "shopData").items.Count((Item a) => a.cardDataName == brokenVaseCardName) > 0)
            {
                talker.Say("broken vase", num2);
                talker.Say("broken vase price", num2 + 1f);
            }
            else
            {
                talker.Say("greet1", num2);
                talker.Say("greet2", num2 + 1f);
            }
            speechBubTimer = speechBubDelay;
            Container[] array = containers;
            for (int i = 0; i < array.Length; i++)
            {
                foreach (Entity item in array[i].container)
                {
                    Events.InvokeEntityOffered(item);
                }
            }
        }
        base.data["openCount"] = num + 1;
        yield return (object)new WaitForSeconds(0.5f);
        yield return AdjustMusicToInside(0.5f);
    }

    public IEnumerator CloseRoutine()
    {
        animator.SetBool("Zoom", false);
        promptClose = false;
        open = false;
        yield return null;
    }

    public static IEnumerator AdjustMusicToInside(float totalTime)
    {
        float v = 0f;
        float add = 1f / totalTime;
        while (v < 1f)
        {
            v += Time.deltaTime * add;
            MusicSystem.SetParam("shop_enter", v);
            AmbienceSystem.SetParam("shop_enter", v);
            yield return null;
        }
    }

    public void End()
    {
        promptEnd = true;
    }

    public void TryBuy(Entity entity)
    {
        if (Deckpack.IsOpen)
        {
            return;
        }
        ShopItem component = ((Component)entity).GetComponent<ShopItem>();
        if (component == null)
        {
            return;
        }
        int price = component.GetPrice();
        int num = ((base.player.data.inventory.gold)).Value - price;
        if (num >= 0)
        {
            Bub("thanks");
            SfxSystem.OneShot("event:/sfx/location/shop/buying");
            priceManager.Remove(component);
            base.player.SpendGold(price);
            cardSelector.TakeCard(entity);
            DictionaryExt.Get<Data>(base.data, "shopData").items.Find((Item a) => a.cardDataName == (entity.data).name).purchased = true;
            Events.InvokeShopItemPurchase(component);
        }
        else if (SecretCheck(num, component))
        {
            TryBuy(entity);
            Events.InvokeShopItemHaggled(component);
        }
        else
        {
            Bub("not enough gold");
        }
    }

    public void TryBuyCharm(BaseEventData eventData)
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        if (Deckpack.IsOpen)
        {
            return;
        }
        PointerEventData val = (PointerEventData)(object)((eventData is PointerEventData) ? eventData : null);
        if (val != null && (int)val.button != 0)
        {
            return;
        }
        Data data = DictionaryExt.Get<Data>(base.data, "shopData");
        if (data.charms.Count <= 0)
        {
            return;
        }
        int num = ((base.player.data.inventory.gold)).Value - data.charmPrice;
        if (num >= 0)
        {
            if (charmMachine.CanRun())
            {
                Bub("thanks");
                promptBuyCharm = true;
            }
            return;
        }
        ShopItem component = ((Component)charmMachine).GetComponent<ShopItem>();
        if (SecretCheck(num, component))
        {
            TryBuyCharm(eventData);
            Events.InvokeShopItemHaggled(component);
        }
        else
        {
            Bub("not enough gold");
        }
    }

    public void TryBuyCrown(BaseEventData eventData)
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        if (Deckpack.IsOpen)
        {
            return;
        }
        PointerEventData val = (PointerEventData)(object)((eventData is PointerEventData) ? eventData : null);
        if (val != null && (int)val.button != 0)
        {
            return;
        }
        Data data = DictionaryExt.Get<Data>(base.data, "shopData");
        if (!data.hasCrown)
        {
            return;
        }
        int num = ((base.player.data.inventory.gold)).Value - GetCrownPrice(data);
        if (num >= 0)
        {
            if (crownHolder.CanTake())
            {
                Bub("thanks");
                promptBuyCrown = true;
            }
            return;
        }
        ShopItem component = ((Component)crownHolder).GetComponent<ShopItem>();
        if (SecretCheck(num, component))
        {
            TryBuyCrown(eventData);
            Events.InvokeShopItemHaggled(component);
        }
        else
        {
            Bub("not enough gold");
        }
    }

    public bool SecretCheck(int goldDiff, ShopItem item)
    {
        if (goldDiff == -1)
        {
            if (secretClick != item)
            {
                secretClick = item;
                secretClickCount = 1;
            }
            else if (++secretClickCount >= secretCount)
            {
                speechBubTimer = 0f;
                int num = item.GetPrice() - 1;
                Bub("secret", num);
                ref SafeInt gold = ref base.player.data.inventory.gold;
                int value = ((gold)).Value;
                ((gold)).Value = value + 1;
                secretClick = null;
                return true;
            }
        }
        return false;
    }

    public IEnumerator BuyCharmRoutine()
    {
        promptBuyCharm = false;
        SfxSystem.OneShot("event:/sfx/location/shop/buying");
        Data shopData = DictionaryExt.Get<Data>(base.data, "shopData");
        ((Behaviour)cardController).enabled = false;
        ((Behaviour)crownHolder).enabled = false;
        ((Behaviour)charmMachine).enabled = false;
        base.player.SpendGold(shopData.charmPrice);
        string c = shopData.charms[0];
        ShopItem item = ((Component)charmMachine).GetComponent<ShopItem>();
        priceManager.Remove(item);
        yield return charmMachine.Run();
        shopData.charms.RemoveAt(0);
        shopData.charmPrice += shopData.charmPriceAdd;
        CardUpgradeData charmData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", c).Clone();
        openSequence.SetCharm(charmData, charmBlock);
        openSequence.SetCharacter(base.player);
        yield return openSequence.Run();
        if (shopData.charms.Count > 0)
        {
            ((Behaviour)charmMachine).enabled = true;
            CreateCharmPrice();
        }
        ((Behaviour)cardController).enabled = true;
        ((Behaviour)crownHolder).enabled = true;
        Events.InvokeShopItemPurchase(item);
    }

    public IEnumerator BuyCrownRoutine()
    {
        promptBuyCrown = false;
        Data data = DictionaryExt.Get<Data>(base.data, "shopData");
        SfxSystem.OneShot("event:/sfx/location/shop/buying");
        base.player.SpendGold(GetCrownPrice(data));
        crownHolder.TakeCrown();
        data.hasCrown = false;
        ShopItem item = ((Component)crownHolder).GetComponent<ShopItem>();
        priceManager.Remove(item);
        gainCrownSequence.SetData(crownHolder.GetCrownData().Clone());
        yield return gainCrownSequence.Run();
        Events.InvokeShopItemPurchase(item);
    }

    public void Hover(ShopItem item)
    {
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        if ((currentHover))
        {
            UnHover(currentHover);
        }
        currentHover = item;
        if (base.player.entity.display is CharacterDisplay characterDisplay && (characterDisplay.goldDisplay) && (priceManager.Get(item)))
        {
            int price = item.GetPrice();
            if (price <= base.player.data.inventory.gold)
            {
                characterDisplay.goldDisplay.ShowChange(-price);
            }
        }
        Events.InvokeShopItemHover(item);
    }

    public void UnHover(ShopItem item)
    {
        if (currentHover == item)
        {
            currentHover = null;
            if (base.player.entity.display is CharacterDisplay characterDisplay && (characterDisplay.goldDisplay))
            {
                characterDisplay.goldDisplay.HideChange();
            }
            Events.InvokeShopItemUnHover(item);
        }
    }

    public override IEnumerator Populate()
    {
        yield return UnPopulate();
        Data shopData = DictionaryExt.Get<Data>(base.data, "shopData");
        entities = new List<Entity>();
        Container[] array = containers;
        for (int i = 0; i < array.Length; i++)
        {
            Container c = array[i];
            List<Item> list = shopData.items.FindAll((Item a) => a.category == c.category);
            c.container.SetSize(list.Count, c.cardScale);
            CardContainer container = c.container;
            container.owner = base.player;
            ((Component)container).transform.localEulerAngles = Vector3Ext.WithZ(((Component)container).transform.localEulerAngles, PettyRandom.Range(0f - cardContainerRandomAngle, cardContainerRandomAngle));
            foreach (Item item2 in list)
            {
                CardData cardDataClone = AddressableLoader.GetCardDataClone(item2.cardDataName);
                int num = shopData.items.IndexOf(item2);
                if (shopData.upgrades.Count > num)
                {
                    string[] array2 = shopData.upgrades[num];
                    if (array2 != null)
                    {
                        string[] array3 = array2;
                        foreach (string assetName in array3)
                        {
                            AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", assetName).Clone().Assign(cardDataClone);
                        }
                    }
                }
                Card card = CardManager.Get(cardDataClone, cardController, base.player, inPlay: false, isPlayerCard: true);
                yield return card.UpdateData();
                container.Add(card.entity);
                entities.Add(card.entity);
                ShopItem target = ((Component)card.entity).gameObject.AddComponent<ShopItem>();
                priceManager.Add(target, c.pricePosition).SetPrice(item2.price, item2.priceFactor);
            }
            foreach (Entity item3 in container)
            {
                Transform transform = item3.transform;
                transform.localPosition = container.GetChildPosition(item3);
                transform.localScale = container.GetChildScale(item3);
                transform.localEulerAngles = container.GetChildRotation(item3);
            }
        }
        foreach (Item item in shopData.items)
        {
            if (item.purchased)
            {
                Entity entity = entities.Find((Entity a) => (a.data).name == item.cardDataName);
                if ((entity))
                {
                    priceManager.Remove(((Component)entity).GetComponent<ShopItem>());
                    entity.RemoveFromContainers();
                    CardManager.ReturnToPool(entity);
                }
            }
        }
        if ((charmMachine) && shopData.charms.Count <= 0)
        {
            ((Behaviour)charmMachine).enabled = false;
        }
        else
        {
            CreateCharmPrice();
        }
        if ((crownHolder) && !shopData.hasCrown)
        {
            crownHolder.TakeCrown();
            yield break;
        }
        string assetName2 = (StringExt.IsNullOrWhitespace(shopData.crownType) ? "Crown" : shopData.crownType);
        CardUpgradeData cardUpgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", assetName2);
        if ((cardUpgradeData))
        {
            crownHolder.SetCrownData(cardUpgradeData);
        }
        CreateCrownPrice();
    }

    public void CreateCharmPrice()
    {
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        Data data = DictionaryExt.Get<Data>(base.data, "shopData");
        if (charmMachine != null && data.charms.Count > 0)
        {
            ShopPrice shopPrice = priceManager.Add(((Component)charmMachine).GetComponent<ShopItem>(), ShopPrice.Position.Bottom);
            shopPrice.SetPrice(data.charmPrice);
            shopPrice.SetOffset(new Vector3(0f, -0.33f, 0f));
            shopPrice.scaleWithTarget = 0f;
            shopPrice.scaleOffsetWithTarget = 0f;
        }
    }

    public void CreateCrownPrice()
    {
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        Data data = DictionaryExt.Get<Data>(base.data, "shopData");
        if (crownHolder != null && data.hasCrown)
        {
            ShopPrice shopPrice = priceManager.Add(((Component)crownHolder).GetComponent<ShopItem>(), ShopPrice.Position.Bottom);
            shopPrice.SetPrice(GetCrownPrice(data));
            shopPrice.SetOffset(new Vector3(0f, -0.3f, 0f));
            shopPrice.scaleWithTarget = 0f;
            shopPrice.scaleOffsetWithTarget = 0f;
        }
    }

    public static int GetCrownPrice(Data shopData)
    {
        return shopData.crownPrice + shopData.crownPriceAdd * StatsSystem.Get().Get("shopItemsBought", "crown", 0);
    }

    public IEnumerator UnPopulate()
    {
        List<Entity> list = new List<Entity>();
        Container[] array = containers;
        for (int i = 0; i < array.Length; i++)
        {
            Container container = array[i];
            foreach (Entity item in container.container)
            {
                list.Add(item);
            }
            container.container.Clear();
        }
        foreach (Entity item2 in list)
        {
            CardManager.ReturnToPool(item2);
        }
        priceManager.Clear();
        yield return null;
    }
}
public class ExportCards : MonoBehaviour
{
    [SerializeField]
    public string folder = "ExportCards";

    public Camera _camera;

    public Camera camera => _camera ?? (_camera = Camera.main);

    public IEnumerator Start()
    {
        yield return (object)new WaitUntil((Func<bool>)(() => CardManager.init));
        List<CardData> group = AddressableLoader.GetGroup<CardData>("CardData");
        foreach (CardData cardData in group)
        {
            if (!(cardData.mainSprite == null) && !((cardData.mainSprite).name == "Nothing"))
            {
                Card card = CardManager.Get(cardData, null, null, inPlay: false, isPlayerCard: false);
                yield return card.UpdateData();
                card.transform.position = Vector3.zero;
                yield return null;
                Screenshot(Application.dataPath + "/../" + folder + "/" + (cardData.cardType).name, ((TMP_Text)card.titleText).text + " (" + (card).name + ").png");
                yield return null;
                CardManager.ReturnToPool(card);
            }
        }
    }

    public void Screenshot(string directory, string fileName)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Expected O, but got Unknown
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Expected O, but got Unknown
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        string text = directory + "/" + fileName;
        Texture2D val = new Texture2D(Screen.width, Screen.height, (TextureFormat)5, false);
        RenderTexture val2 = new RenderTexture(((Texture)val).width, ((Texture)val).height, 24);
        camera.targetTexture = val2;
        camera.Render();
        RenderTexture.active = val2;
        val.ReadPixels(new Rect(0f, 0f, (float)((Texture)val).width, (float)((Texture)val).height), 0, 0);
        val.Apply();
        byte[] bytes = ImageConversion.EncodeToPNG(val);
        Directory.CreateDirectory(directory);
        File.WriteAllBytes(text, bytes);
        Debug.Log(text);
    }
}
public class EyePositionSaver : MonoBehaviour
{
}
public class EyePupil : MonoBehaviour
{
    [SerializeField]
    public Transform target;

    [SerializeField]
    public AnimationCurve aimAmount;

    [SerializeField]
    public float lerp = 0.2f;

    public Vector3 targetPos;

    public void OnEnable()
    {
        Events.OnEntityHover += EntityHover;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
    }

    public void Update()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        target.localPosition = Delta.Lerp(target.localPosition, targetPos, lerp, Time.deltaTime);
    }

    public void EntityHover(Entity entity)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        LookAt(entity.transform.position);
    }

    public void LookAt(Vector3 worldPosition)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3Ext.WithZ(worldPosition - transform.position, 0f);
        float num = aimAmount.Evaluate(((val)).magnitude);
        targetPos = ((val)).normalized * num;
    }
}
public class Flipper : MonoBehaviourCacheTransform, IPoolable
{
    public enum State
    {
        None,
        FlipUp,
        FlipDown
    }

    public State state;

    [SerializeField]
    public Entity entity;

    [SerializeField]
    public CardHover hover;

    public Vector2 flipUpDurationRand = new Vector2(0.5f, 0.6f);

    public Vector2 flipDownDurationRand = new Vector2(0.5f, 0.6f);

    public AnimationCurve flipUpCurve;

    public AnimationCurve flipDownCurve;

    public Vector3 flipPositionOffset = new Vector3(0f, 1f, -1f);

    public AnimationCurve flipPositionCurve;

    public UnityEvent onFlipUp;

    public UnityEvent onFlipDown;

    public float preAngle;

    public float angle;

    [ReadOnly]
    public bool flipped;

    public float t = 1f;

    public float duration;

    public bool isCompleteFired = true;

    public void Update()
    {
        //IL_007a: Unknown result type (might be due to invalid IL or missing references)
        //IL_007f: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bb: Unknown result type (might be due to invalid IL or missing references)
        if (!(t <= duration))
        {
            return;
        }
        isCompleteFired = false;
        t += Time.deltaTime;
        float num = t / duration;
        switch (state)
        {
            case State.FlipUp:
                UpdateAngle((1f - flipUpCurve.Evaluate(num)) * 180f);
                base.transform.localPosition = flipPositionCurve.Evaluate(num) * flipPositionOffset;
                break;
            case State.FlipDown:
                UpdateAngle(flipDownCurve.Evaluate(num) * 180f);
                base.transform.localPosition = flipPositionCurve.Evaluate(num) * flipPositionOffset;
                break;
        }
        if (t > duration)
        {
            if (!isCompleteFired)
            {
                Events.InvokeEntityFlipComplete(entity);
                isCompleteFired = true;
            }
            state = State.None;
        }
    }

    public void UpdateAngle(float angle)
    {
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        this.angle = angle;
        if (preAngle < 90f && angle >= 90f)
        {
            flipped = true;
            onFlipDown.Invoke();
        }
        if (preAngle > 90f && angle <= 90f)
        {
            flipped = false;
            onFlipUp.Invoke();
        }
        preAngle = angle;
        base.transform.localEulerAngles = Vector3Ext.WithY(base.transform.localEulerAngles, angle);
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void FlipUp(bool force = false)
    {
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        if (force || flipped || state == State.FlipDown)
        {
            preAngle = angle;
            t = 0f;
            duration = Vector2Ext.PettyRandom(flipUpDurationRand);
            state = State.FlipUp;
            hover.SetHoverable(value: true);
            Events.InvokeEntityFlipUp(entity);
        }
    }

    public void FlipUpInstant()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        base.transform.localEulerAngles = Vector3Ext.WithY(base.transform.localEulerAngles, 0f);
        angle = 0f;
        preAngle = 0f;
        flipped = false;
        onFlipUp.Invoke();
        state = State.None;
        hover.SetHoverable(value: true);
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void FlipDown(bool force = false)
    {
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        if (force || !flipped || state == State.FlipUp)
        {
            preAngle = angle;
            t = 0f;
            duration = Vector2Ext.PettyRandom(flipDownDurationRand);
            state = State.FlipDown;
            hover.SetHoverable(value: false);
            Events.InvokeEntityFlipDown(entity);
        }
    }

    public void FlipDownInstant()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        base.transform.localEulerAngles = Vector3Ext.WithY(base.transform.localEulerAngles, 180f);
        angle = 180f;
        preAngle = 180f;
        flipped = true;
        onFlipDown.Invoke();
        state = State.None;
        hover.SetHoverable(value: false);
    }

    public void OnGetFromPool()
    {
    }

    public void OnReturnToPool()
    {
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        state = State.None;
        preAngle = 0f;
        angle = 0f;
        flipped = false;
        t = 1f;
        duration = 0f;
        isCompleteFired = true;
        base.transform.localRotation = Quaternion.identity;
        base.transform.localPosition = Vector3.zero;
    }
}
public class FloatingText : MonoBehaviour
{
    [SerializeField]
    public TMP_Text textAsset;

    [SerializeField]
    public Canvas canvas;

    [SerializeField]
    public CanvasGroup canvasGroup;

    public static FloatingText Create(Vector3 position)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        FloatingText fromPool = FloatingTextManager.GetFromPool();
        ((Component)fromPool).transform.position = position;
        return fromPool;
    }

    public static FloatingText Create(Vector3 position, string text)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        FloatingText fromPool = FloatingTextManager.GetFromPool();
        ((Component)fromPool).transform.position = position;
        fromPool.SetText(text);
        return fromPool;
    }

    public FloatingText SetText(string text)
    {
        textAsset.text = text;
        return this;
    }

    public FloatingText Reset()
    {
        canvas.overrideSorting = false;
        canvasGroup.alpha = 1f;
        return this;
    }

    public FloatingText SetSortingLayer(string sortingLayerName, int orderInLayer)
    {
        canvas.overrideSorting = true;
        canvas.sortingLayerName = sortingLayerName;
        canvas.sortingOrder = orderInLayer;
        return this;
    }

    public FloatingText Animate(string animationName, float strength = 1f)
    {
        FloatingTextManager.Animation animation = FloatingTextManager.GetAnimation(animationName);
        if (animation.tweens != null && animation.tweens.Length != 0)
        {
            StartCoroutine(AnimateRoutine(animation, strength));
        }
        return this;
    }

    public FloatingText Fade(string fadeCurveName, float duration = 1f, float delay = 0f)
    {
        StartCoroutine(FadeRoutine(FloatingTextManager.GetFadeCurve(fadeCurveName).curve, duration, delay));
        return this;
    }

    public FloatingText Fade(AnimationCurve curve, float duration = 1f, float delay = 0f)
    {
        StartCoroutine(FadeRoutine(curve, duration, delay));
        return this;
    }

    public FloatingText DestroyAfterSeconds(float seconds)
    {
        StartCoroutine(DestroyAfterSecondsRoutine(seconds));
        return this;
    }

    public IEnumerator AnimateRoutine(FloatingTextManager.Animation animation, float strength)
    {
        animation.Fire(gameObject, strength);
        yield return DestroyAfterSecondsRoutine(animation.GetDuration());
    }

    public IEnumerator DestroyAfterSecondsRoutine(float seconds)
    {
        yield return Sequences.Wait(seconds);
        FloatingTextManager.ReturnToPool(this);
    }

    public IEnumerator FadeRoutine(AnimationCurve curve, float duration = 1f, float delay = 0f)
    {
        if (delay > 0f)
        {
            yield return Sequences.Wait(delay);
        }
        if (curve.length > 1)
        {
            Keyframe val = curve[0];
            float t1 = ((val)).time;
            val = curve[curve.length - 1];
            float num = ((val)).time - t1;
            float currentTime = 0f;
            float scale = num / duration;
            while (currentTime <= duration)
            {
                canvasGroup.alpha = curve.Evaluate(t1 + currentTime * scale);
                currentTime += Time.deltaTime;
                yield return null;
            }
        }
        FloatingTextManager.ReturnToPool(this);
    }
}
public class FloatingTextManager : MonoBehaviourSingleton<FloatingTextManager>
{
    [Serializable]
    public struct Animation
    {
        [Serializable]
        public struct Tween
        {
            public enum Property
            {
                Move,
                Scale,
                Rotate
            }

            public LeanTweenType ease;

            [ShowIf("IsAnimationCurve")]
            public AnimationCurve curve;

            public float duration;

            public float delay;

            public Property property;

            public bool relative;

            public Vector3 to;

            public bool hasFrom;

            [ShowIf("hasFrom")]
            public Vector3 from;

            public bool IsAnimationCurve => ease == LeanTweenType.animationCurve;

            public void Fire(GameObject target, float strength)
            {
                //IL_0028: Unknown result type (might be due to invalid IL or missing references)
                //IL_002d: Unknown result type (might be due to invalid IL or missing references)
                //IL_010f: Unknown result type (might be due to invalid IL or missing references)
                //IL_0114: Unknown result type (might be due to invalid IL or missing references)
                //IL_009d: Unknown result type (might be due to invalid IL or missing references)
                //IL_00a2: Unknown result type (might be due to invalid IL or missing references)
                //IL_0074: Unknown result type (might be due to invalid IL or missing references)
                //IL_0076: Unknown result type (might be due to invalid IL or missing references)
                //IL_007c: Unknown result type (might be due to invalid IL or missing references)
                //IL_0081: Unknown result type (might be due to invalid IL or missing references)
                //IL_006d: Unknown result type (might be due to invalid IL or missing references)
                //IL_004c: Unknown result type (might be due to invalid IL or missing references)
                //IL_004e: Unknown result type (might be due to invalid IL or missing references)
                //IL_0054: Unknown result type (might be due to invalid IL or missing references)
                //IL_0059: Unknown result type (might be due to invalid IL or missing references)
                //IL_0045: Unknown result type (might be due to invalid IL or missing references)
                //IL_015b: Unknown result type (might be due to invalid IL or missing references)
                //IL_015d: Unknown result type (might be due to invalid IL or missing references)
                //IL_0163: Unknown result type (might be due to invalid IL or missing references)
                //IL_0168: Unknown result type (might be due to invalid IL or missing references)
                //IL_0154: Unknown result type (might be due to invalid IL or missing references)
                //IL_0133: Unknown result type (might be due to invalid IL or missing references)
                //IL_0135: Unknown result type (might be due to invalid IL or missing references)
                //IL_013b: Unknown result type (might be due to invalid IL or missing references)
                //IL_0140: Unknown result type (might be due to invalid IL or missing references)
                //IL_012c: Unknown result type (might be due to invalid IL or missing references)
                //IL_00e9: Unknown result type (might be due to invalid IL or missing references)
                //IL_00eb: Unknown result type (might be due to invalid IL or missing references)
                //IL_00f1: Unknown result type (might be due to invalid IL or missing references)
                //IL_00f6: Unknown result type (might be due to invalid IL or missing references)
                //IL_00e2: Unknown result type (might be due to invalid IL or missing references)
                //IL_00c1: Unknown result type (might be due to invalid IL or missing references)
                //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
                //IL_00c9: Unknown result type (might be due to invalid IL or missing references)
                //IL_00ce: Unknown result type (might be due to invalid IL or missing references)
                //IL_00ba: Unknown result type (might be due to invalid IL or missing references)
                LTDescr lTDescr = null;
                switch (property)
                {
                    case Property.Move:
                        {
                            Vector3 localPosition = target.transform.localPosition;
                            if (hasFrom)
                            {
                                target.transform.localPosition = (relative ? (localPosition + from * strength) : from);
                            }
                            lTDescr = LeanTween.moveLocal(target, relative ? (localPosition + to * strength) : to, duration);
                            break;
                        }
                    case Property.Rotate:
                        {
                            Vector3 localEulerAngles = target.transform.localEulerAngles;
                            if (hasFrom)
                            {
                                target.transform.localEulerAngles = (relative ? (localEulerAngles + from * strength) : from);
                            }
                            lTDescr = LeanTween.rotateLocal(target, relative ? (localEulerAngles + to * strength) : to, duration);
                            break;
                        }
                    case Property.Scale:
                        {
                            Vector3 localScale = target.transform.localScale;
                            if (hasFrom)
                            {
                                target.transform.localScale = (relative ? (localScale + from * strength) : from);
                            }
                            lTDescr = LeanTween.scale(target, relative ? (localScale + to * strength) : to, duration);
                            break;
                        }
                }
                if (IsAnimationCurve)
                {
                    lTDescr?.setEase(curve);
                }
                else
                {
                    lTDescr?.setEase(ease);
                }
                if (delay > 0f)
                {
                    lTDescr?.setDelay(delay);
                }
            }

            public float GetDuration()
            {
                return duration + delay;
            }
        }

        public string name;

        public Tween[] tweens;

        public void Fire(GameObject target, float strength)
        {
            Tween[] array = tweens;
            foreach (Tween tween in array)
            {
                tween.Fire(target, strength);
            }
        }

        public float GetDuration()
        {
            float num = 0f;
            Tween[] array = tweens;
            foreach (Tween tween in array)
            {
                num += tween.GetDuration();
            }
            return num;
        }
    }

    [Serializable]
    public struct FadeCurve
    {
        public string name;

        public AnimationCurve curve;
    }

    [SerializeField]
    public FloatingText prefab;

    [SerializeField]
    public Animation[] animations;

    [SerializeField]
    public FadeCurve[] fadeCurves;

    public Dictionary<string, Animation> animationDictionary;

    public Dictionary<string, FadeCurve> fadeCurveDictionary;

    public static Queue<FloatingText> pool = new Queue<FloatingText>();

    public void Start()
    {
        animationDictionary = new Dictionary<string, Animation>();
        Animation[] array = animations;
        for (int i = 0; i < array.Length; i++)
        {
            Animation value = array[i];
            animationDictionary[value.name] = value;
        }
        fadeCurveDictionary = new Dictionary<string, FadeCurve>();
        FadeCurve[] array2 = fadeCurves;
        for (int i = 0; i < array2.Length; i++)
        {
            FadeCurve value2 = array2[i];
            fadeCurveDictionary[value2.name] = value2;
        }
    }

    public static Animation GetAnimation(string name)
    {
        return MonoBehaviourSingleton<FloatingTextManager>.instance.animationDictionary[name];
    }

    public static FadeCurve GetFadeCurve(string name)
    {
        return MonoBehaviourSingleton<FloatingTextManager>.instance.fadeCurveDictionary[name];
    }

    public static FloatingText GetFromPool()
    {
        if (pool.Count > 0)
        {
            FloatingText floatingText = pool.Dequeue();
            ((Component)floatingText).gameObject.SetActive(true);
            return floatingText;
        }
        return MonoBehaviourSingleton<FloatingTextManager>.instance.CreatePrefab();
    }

    public static void ReturnToPool(FloatingText item)
    {
        item.Reset();
        ((MonoBehaviour)item).StopAllCoroutines();
        ((Component)item).gameObject.SetActive(false);
        ((Component)item).transform.SetParent(((Component)MonoBehaviourSingleton<FloatingTextManager>.instance).transform);
        pool.Enqueue(item);
    }

    public FloatingText CreatePrefab()
    {
        FloatingText floatingText = Object.Instantiate<FloatingText>(prefab, transform);
        ((Component)floatingText).gameObject.SetActive(true);
        return floatingText;
    }
}
public class FlyOffScreen : MonoBehaviourCacheTransform
{
    [Header("Movement")]
    public Vector3 velocity;

    [SerializeField]
    public Vector3 grav = new Vector3(0f, -80f, 0f);

    [SerializeField]
    public Vector3 rotation = new Vector3(0f, 100f, 320f);

    [SerializeField]
    public Vector3 frictMult = new Vector3(0.95f, 1f, 0.92f);

    [Header("Fade")]
    public CanvasGroup canvasGroup;

    [SerializeField]
    public float alpha = 2f;

    [SerializeField]
    public float fade = 2f;

    [Header("Rotation Amount")]
    [SerializeField]
    public Vector2 rotateRangeX = new Vector2(1f, 2f);

    [SerializeField]
    public Vector2 rotateRangeY = new Vector2(0f, 1f);

    [SerializeField]
    public Vector2 rotateRangeZ = new Vector2(1f, 2f);

    public void Awake()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        ((rotation)).Scale(new Vector3(Vector2Ext.PettyRandom(rotateRangeX), Vector2Ext.PettyRandom(rotateRangeY), Vector2Ext.PettyRandom(rotateRangeZ)));
        Begin();
    }

    public void Update()
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        //IL_0076: Unknown result type (might be due to invalid IL or missing references)
        //IL_0091: Unknown result type (might be due to invalid IL or missing references)
        //IL_0096: Unknown result type (might be due to invalid IL or missing references)
        //IL_009b: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a2: Unknown result type (might be due to invalid IL or missing references)
        velocity += grav * Time.deltaTime;
        velocity = Delta.Multiply(velocity, frictMult, Time.deltaTime);
        base.transform.position = base.transform.position + velocity * Time.deltaTime;
        Vector3 localEulerAngles = base.transform.localEulerAngles;
        localEulerAngles += rotation * (Mathf.Sign(velocity.x) * Time.deltaTime);
        base.transform.localEulerAngles = localEulerAngles;
        alpha -= fade * Time.deltaTime;
        if (alpha <= 0f)
        {
            End();
        }
        else
        {
            canvasGroup.alpha = Mathf.Min(1f, alpha);
        }
    }

    public void Knockback(Hit lastHit)
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bf: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = ((lastHit != null && (lastHit.attacker)) ? Vector3Ext.WithZ(base.transform.position - lastHit.attacker.transform.position, 0f) : Vector3Ext.WithX(Vector3.up, PettyRandom.Range(-1f, 1f)));
        Vector3 normalized = ((val)).normalized;
        Debug.Log($"knockback dir: {normalized}");
        float num = Mathf.Clamp(normalized.x * PettyRandom.Range(5f, 10f), -1f, 1f);
        float num2 = PettyRandom.Range(15f, 25f);
        float num3 = 0f - PettyRandom.Range(10f, 30f);
        Knockback(new Vector3(num, num2, num3));
    }

    public void Knockback(Vector3 dir)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        velocity = dir;
    }

    public virtual void Begin()
    {
    }

    public virtual void End()
    {
        GameObjectExt.Destroy(gameObject);
    }
}
public class GameManager : MonoBehaviourSingleton<GameManager>
{
    public const float CARD_WIDTH = 3f;

    public const float CARD_HEIGHT = 4.5f;

    public static readonly Vector2 CARD_SIZE = new Vector2(3f, 4.5f);

    public const float LARGE_UI = 0f;

    [SerializeField]
    public int targetFrameRate = -1;

    [SerializeField]
    public int editorTargetFrameRate = 60;

    public static int tasksInProgress = 0;

    public static bool init;

    public static bool End;

    public static bool paused;

    public static readonly CultureInfo CultureInfo = CultureInfo.CreateSpecificCulture("en-GB");

    public static bool Busy
    {
        get
        {
            if (tasksInProgress <= 0)
            {
                return !init;
            }
            return true;
        }
    }

    public static bool Ready => init;

    public IEnumerator Start()
    {
        Thread.CurrentThread.CurrentCulture = CultureInfo;
        Application.targetFrameRate = targetFrameRate;
        Random.InitState((int)DateTime.Now.Ticks);
        Debug.Log("RELEASE = TRUE");
        yield return null;
        yield return (object)new WaitUntil((Func<bool>)(() => Bootstrap.Count <= 0));
        init = true;
        Events.InvokeGameStart();
    }

    public void OnApplicationQuit()
    {
        Debug.Log(">>>> GAME END <<<<");
        End = true;
        Events.InvokeGameEnd();
    }

    public static void Quit()
    {
        Application.Quit();
    }
}
public class Glow : MonoBehaviourRect
{
    [SerializeField]
    public Image image;

    [SerializeField]
    public AnimationCurve fadeCurve;

    [SerializeField]
    public float fadeDuration = 0.5f;

    public float delay;

    public float t;

    public Glow SetSize(Vector2 size)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        base.rectTransform.sizeDelta = size;
        return this;
    }

    public Glow SetPosition(Vector2 position)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        base.rectTransform.anchoredPosition = position;
        return this;
    }

    public Glow SetColor(Color color)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        ((Graphic)image).color = color;
        return this;
    }

    public Glow RandomColor(float saturation = 1f, float brightness = 1f)
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        ((Graphic)image).color = Color.HSVToRGB(PettyRandom.Range(0f, 1f), saturation, brightness);
        return this;
    }

    public Glow Fade(AnimationCurve curve, float duration, float delay = 0f)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        ((Graphic)image).color = ColorExt.WithAlpha(((Graphic)image).color, 0f);
        fadeCurve = curve;
        fadeDuration = duration;
        t = 0f;
        this.delay = delay;
        return this;
    }

    public void Update()
    {
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        if (delay > 0f)
        {
            delay -= Time.deltaTime;
            return;
        }
        t += Time.deltaTime / fadeDuration;
        ((Graphic)image).color = ColorExt.WithAlpha(((Graphic)image).color, fadeCurve.Evaluate(t));
        if (t > 1f)
        {
            Object.Destroy(gameObject);
        }
    }
}
public class GoldDisplay : MonoBehaviour
{
    [SerializeField]
    public Image icon;

    [SerializeField]
    public bool doPing = true;

    [SerializeField]
    public LeanTweenType pingEase = LeanTweenType.easeOutElastic;

    [SerializeField]
    [ShowIf("PingIsAnimationCurve")]
    public AnimationCurve pingCurve;

    [SerializeField]
    public float pingDur = 1f;

    [SerializeField]
    public TMP_Text textAsset;

    [SerializeField]
    [TextArea]
    public string format = "{0}";

    [SerializeField]
    [TextArea]
    public string formatAdd = "{0}<#ffff00>+{1}";

    [SerializeField]
    [TextArea]
    public string formatSub = "{0}<#e05822>-{1}";

    [SerializeField]
    [TextArea]
    public string formatChangeUp = "<s>{0}</s><#ffff00> {2}";

    [SerializeField]
    [TextArea]
    public string formatChangeDown = "<s>{0}</s><#e05822> {2}";

    [SerializeField]
    public float addDelay = 1f;

    [SerializeField]
    public float totalAddTime = 1f;

    [SerializeField]
    public float addBetweenTimeMax = 0.05f;

    public int goldPre;

    public float current;

    public float change;

    public bool PingIsAnimationCurve => pingEase == LeanTweenType.animationCurve;

    public float add { get; set; }

    public void Set(int amount)
    {
        if (amount != goldPre)
        {
            add += amount - goldPre;
            UpdateText();
            ResolveAfter(addDelay);
            if (doPing && pingDur > 0f && pingEase != 0)
            {
                Ping();
            }
        }
        goldPre = amount;
    }

    public void ShowChange(int change)
    {
        this.change = change;
        UpdateText();
    }

    public void HideChange()
    {
        change = 0f;
        UpdateText();
    }

    public void Ping()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(gameObject);
        LTDescr lTDescr = LeanTween.scale(gameObject, Vector3.one, pingDur).setFrom(Vector3.zero);
        if (PingIsAnimationCurve)
        {
            lTDescr.setEase(pingCurve);
        }
        else
        {
            lTDescr.setEase(pingEase);
        }
    }

    public void UpdateText()
    {
        if (change == 0f)
        {
            if (add == 0f)
            {
                textAsset.text = string.Format(format, current);
            }
            else if (add > 0f)
            {
                textAsset.text = string.Format(formatAdd, current, add);
            }
            else if (add < 0f)
            {
                textAsset.text = string.Format(formatSub, current, 0f - add);
            }
        }
        else if (change > 0f)
        {
            textAsset.text = string.Format(formatChangeUp, current, change, current + change);
        }
        else if (change < 0f)
        {
            textAsset.text = string.Format(formatChangeDown, current, change, current + change);
        }
    }

    public void ResolveAfter(float delay)
    {
        StopAllCoroutines();
        StartCoroutine(ResolveAdd(delay));
    }

    public IEnumerator ResolveAdd(float delay)
    {
        yield return Sequences.Wait(delay);
        float timeBetween = Mathf.Min(totalAddTime / Mathf.Abs(add), addBetweenTimeMax);
        Events.InvokeGoldCounterStart(this, add);
        while (add != 0f)
        {
            if (add > 0f)
            {
                add--;
                current += 1f;
            }
            else
            {
                add++;
                current -= 1f;
            }
            UpdateText();
            yield return Sequences.Wait(timeBetween);
        }
    }
}
public class HandleSpinner : MonoBehaviour
{
    [SerializeField]
    public Transform handle;

    [SerializeField]
    public float startSpeed = 100f;

    [SerializeField]
    public float targetSpeed = 100f;

    [SerializeField]
    public float acceleration = 10f;

    [SerializeField]
    public float deceleration = 10f;

    public bool spinning;

    public float speed;

    [Button(/*Could not decode attribute arguments.*/)]
    public void Spin()
    {
        enabled = true;
        spinning = true;
        speed = startSpeed;
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Stop()
    {
        spinning = false;
    }

    public void Update()
    {
        float num = (0f - speed) * Time.deltaTime;
        transform.Rotate(num, 0f, 0f);
        handle.Rotate(0f - num, 0f, 0f);
        if (spinning)
        {
            speed = Mathf.Min(speed + acceleration * Time.deltaTime, targetSpeed);
        }
        else
        {
            speed = Mathf.Max(0f, speed - deceleration * Time.deltaTime);
        }
    }
}
public class HandOverlay : MonoBehaviour
{
    [SerializeField]
    [ReadOnly]
    public Character owner;

    [SerializeField]
    public CardContainer drawContainer;

    [SerializeField]
    public CardContainer handContainer;

    [SerializeField]
    public CardContainer discardContainer;

    [SerializeField]
    public TweenUI showTween;

    [SerializeField]
    public TweenUI hideTween;

    [SerializeField]
    public SpriteSetter[] spriteSetters;

    [Header("Shadow For Battle Phase")]
    [SerializeField]
    public CanvasGroup shadow;

    [SerializeField]
    public LeanTweenType shadowFadeEase = LeanTweenType.easeInOutQuart;

    [SerializeField]
    public float shadowFadeDur = 1f;

    public bool shadowActive;

    public void Start()
    {
        Events.OnBattlePhaseStart += BattlePhaseStart;
        Events.OnSettingChanged += SettingChanged;
        UpdateVisibility(Settings.Load("HideHandOverlay", defaultValue: false));
    }

    public void OnDestroy()
    {
        Events.OnBattlePhaseStart -= BattlePhaseStart;
        Events.OnSettingChanged -= SettingChanged;
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        if (phase == Battle.Phase.Battle)
        {
            if (!shadowActive)
            {
                LeanTween.cancel(((Component)shadow).gameObject);
                shadow.LeanAlpha(1f, shadowFadeDur).setEase(shadowFadeEase);
                shadowActive = true;
            }
        }
        else if (shadowActive)
        {
            LeanTween.cancel(((Component)shadow).gameObject);
            shadow.LeanAlpha(0f, shadowFadeDur).setEase(shadowFadeEase);
            shadowActive = false;
        }
    }

    public void SettingChanged(string key, object value)
    {
        if (key == "HideHandOverlay" && value is bool hidden)
        {
            UpdateVisibility(hidden);
        }
    }

    public void UpdateVisibility(bool hidden)
    {
        gameObject.SetActive(!hidden);
    }

    public void SetOwner(Character character)
    {
        owner = character;
        drawContainer.owner = owner;
        handContainer.owner = owner;
        discardContainer.owner = owner;
        owner.drawContainer = drawContainer;
        owner.handContainer = handContainer;
        owner.discardContainer = discardContainer;
        handContainer.SetSize(owner.data.handSize, handContainer.CardScale);
        SpriteSetter[] array = spriteSetters;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].Set((character.data.classData).name);
        }
    }

    public IEnumerator Show()
    {
        SfxSystem.OneShot("event:/sfx/inventory/showup");
        showTween.Fire();
        yield return Sequences.Wait(showTween.GetDuration());
    }

    public IEnumerator Hide()
    {
        hideTween.Fire();
        yield return Sequences.Wait(hideTween.GetDuration());
    }
}
public class HelpPanelShower : MonoBehaviour
{
    [SerializeField]
    public LocalizedString key;

    [SerializeField]
    public Prompt.Emote.Type emote = Prompt.Emote.Type.Explain;

    [SerializeField]
    public LocalizedString[] buttonTextKeys;

    [SerializeField]
    public string[] buttonHotKeys;

    [SerializeField]
    public bool canGoBack = true;

    public void SetKey(LocalizedString key, Prompt.Emote.Type? emoteType = null)
    {
        this.key = key;
        if (emoteType.HasValue)
        {
            emote = emoteType.Value;
        }
    }

    public void Show()
    {
        HelpPanelSystem.Show(key);
        HelpPanelSystem.SetEmote(emote);
        HelpPanelSystem.SetBackButtonActive(canGoBack);
    }

    public void AddButton(int index, HelpPanelSystem.ButtonType type, UnityAction action)
    {
        HelpPanelSystem.AddButton(type, buttonTextKeys[index], buttonHotKeys[index], action);
    }
}
[RequireComponent(typeof(CanvasGroup))]
public class HUDCanvas : MonoBehaviour
{
    public CanvasGroup _canvasGroup;

    public CanvasGroup canvasGroup => _canvasGroup ?? (_canvasGroup = GetComponent<CanvasGroup>());

    public void Awake()
    {
        canvasGroup.alpha = Settings.Load("HudAlpha", 1f);
        Events.OnSettingChanged += SettingChanged;
    }

    public void OnDestroy()
    {
        Events.OnSettingChanged -= SettingChanged;
    }

    public void SettingChanged(string key, object value)
    {
        if (key == "HudAlpha" && value is float alpha)
        {
            canvasGroup.alpha = alpha;
        }
    }
}
public class InputAction : MonoBehaviour
{
    public UnityEvent action;

    public void Run()
    {
        if (InputSystem.Enabled)
        {
            UnityEvent obj = action;
            if (obj != null)
            {
                obj.Invoke();
            }
        }
    }
}
public class ItemHolderPet : MonoBehaviour
{
    public Entity owner;

    public virtual void Show()
    {
        if (!gameObject.activeSelf)
        {
            gameObject.SetActive(true);
        }
    }

    public virtual void Used()
    {
        GameObjectExt.Destroy(gameObject);
    }
}
public class ItemHolderPetNoomlin : ItemHolderPet
{
    [SerializeField]
    public ItemHolderPetUsed usedPrefab;

    [SerializeField]
    public TweenUI showTween;

    [SerializeField]
    public AngleWobbler headWobbler;

    [Header("Head")]
    [SerializeField]
    public Sprite[] headOptions;

    [SerializeField]
    public Image head;

    [Header("SFX")]
    [SerializeField]
    public EventReference showSfx;

    [SerializeField]
    public EventReference usedSfx;

    public override void Show()
    {
        //IL_0092: Unknown result type (might be due to invalid IL or missing references)
        //IL_0097: Unknown result type (might be due to invalid IL or missing references)
        base.Show();
        if ((head) && headOptions.Length != 0)
        {
            int num = IntExt.Mod(Mathf.RoundToInt((float)headOptions.Length * owner.data.random3.x), headOptions.Length);
            head.sprite = headOptions[num];
        }
        showTween.Fire();
        headWobbler.WobbleRandom();
        if (!((showSfx)).IsNull && owner.inPlay)
        {
            SfxSystem.OneShot(showSfx);
        }
    }

    public override void Used()
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        base.Used();
        ItemHolderPetUsed itemHolderPetUsed = Object.Instantiate<ItemHolderPetUsed>(usedPrefab, (Transform)null);
        ((Component)itemHolderPetUsed).transform.position = transform.position;
        ((Component)itemHolderPetUsed).transform.eulerAngles = transform.eulerAngles;
        itemHolderPetUsed.SetUp(head.sprite);
        if (!((usedSfx)).IsNull && owner.inPlay)
        {
            SfxSystem.OneShot(usedSfx);
        }
    }
}
public class ItemHolderPetCreator : MonoBehaviour
{
    [SerializeField]
    public Entity owner;

    public ItemHolderPet currentPet;

    public void Create(ItemHolderPet prefab)
    {
        DestroyCurrent();
        currentPet = Object.Instantiate<ItemHolderPet>(prefab, transform);
        currentPet.owner = owner;
        currentPet.Show();
    }

    public void DestroyCurrent()
    {
        if ((currentPet))
        {
            GameObjectExt.Destroy(((Component)currentPet).gameObject);
        }
    }

    public void Used()
    {
        if ((currentPet))
        {
            currentPet.Used();
        }
    }
}
public class ItemHolderPetUsed : MonoBehaviour
{
    [SerializeField]
    public Image headImage;

    [SerializeField]
    public Vector2 velocityRangeX = new Vector2(10f, 15f);

    [SerializeField]
    public Vector2 velocityRangeY = new Vector2(11f, 13f);

    [SerializeField]
    public Vector2 velocityRangeZ = new Vector2(-15f, -10f);

    public void Start()
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        Vector3 dir = default(Vector3);
        ((dir))..ctor(FloatExt.WithRandomSign(Vector2Ext.PettyRandom(velocityRangeX), 0.5f), Vector2Ext.PettyRandom(velocityRangeY), Vector2Ext.PettyRandom(velocityRangeZ));
        GameObjectExt.GetOrAdd<FlyOffScreen>(gameObject).Knockback(dir);
    }

    public void SetUp(Sprite headSprite)
    {
        if (headImage != null)
        {
            headImage.sprite = headSprite;
        }
    }
}
public class LeaderboardsFetcher : MonoBehaviour
{
    public enum Type
    {
        Global,
        Friends,
        Around
    }

    public enum Result
    {
        Success,
        NoConnection,
        TooManyRequests,
        Cancel
    }

    [SerializeField]
    public Scores.Type boardType = Scores.Type.Daily;

    public bool playerRankFetched;

    public uint fetchCount;

    public Leaderboard? leaderboard;

    public int fetchBoardTaskId;

    public int fetchScoresTaskId;

    public int fetchPlayerRankTaskId;

    public int dayOffset = -1;

    public Result result { get; set; }

    public bool playerHasRank { get; set; }

    public uint playerRank { get; set; }

    public uint totalScores { get; set; }

    public LeaderboardEntry[] info { get; set; }

    public void ResetPlayerRank()
    {
        playerRankFetched = false;
        playerHasRank = false;
        playerRank = 0u;
    }

    public async Task Fetch(Type type, int dayOffset, int entriesPerPage, int page = -1)
    {
        DateTime date = DailyFetcher.GetDateTime().AddDays(-dayOffset);
        if (this.dayOffset != dayOffset || !leaderboard.HasValue)
        {
            this.dayOffset = dayOffset;
            Task<Leaderboard?> fetchBoardTask = Scores.GetLeaderboard(boardType, date);
            fetchBoardTaskId = fetchBoardTask.Id;
            await fetchBoardTask;
            if (fetchBoardTaskId == fetchBoardTask.Id)
            {
                leaderboard = fetchBoardTask.Result;
            }
        }
        if (!leaderboard.HasValue)
        {
            return;
        }
        LeaderboardsFetcher leaderboardsFetcher = this;
        Leaderboard value = leaderboard.Value;
        leaderboardsFetcher.totalScores = (uint)((value)).EntryCount;
        if (!playerRankFetched)
        {
            await FetchPlayerRankIfNecessary(leaderboard.Value);
        }
        if (page < 0)
        {
            page = (playerHasRank ? Mathf.FloorToInt((float)(playerRank - 1) / (float)entriesPerPage) : 0);
        }
        switch (type)
        {
            case Type.Global:
                {
                    Task<LeaderboardEntry[]> fetchGlobalScoresTask = Scores.GetGlobal(leaderboard.Value, entriesPerPage, 1 + page * entriesPerPage);
                    fetchScoresTaskId = fetchGlobalScoresTask.Id;
                    await fetchGlobalScoresTask;
                    if (fetchScoresTaskId == fetchGlobalScoresTask.Id)
                    {
                        info = fetchGlobalScoresTask.Result;
                    }
                    break;
                }
            case Type.Friends:
                {
                    Task<LeaderboardEntry[]> fetchFriendsScoresTask = Scores.GetFriends(leaderboard.Value, entriesPerPage);
                    fetchScoresTaskId = fetchFriendsScoresTask.Id;
                    await fetchFriendsScoresTask;
                    if (fetchScoresTaskId == fetchFriendsScoresTask.Id)
                    {
                        info = fetchFriendsScoresTask.Result;
                    }
                    break;
                }
        }
    }

    public async Task FetchPlayerRankIfNecessary(Leaderboard board)
    {
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        Task<LeaderboardEntry[]> fetchPlayerRankTask = Scores.GetAround(board, 0);
        fetchPlayerRankTaskId = fetchPlayerRankTask.Id;
        await fetchPlayerRankTask;
        if (fetchPlayerRankTask.Id == fetchPlayerRankTaskId)
        {
            LeaderboardEntry[] array = fetchPlayerRankTask.Result;
            if (array != null && array.Length > 0)
            {
                playerHasRank = true;
                playerRank = (uint)array[0].GlobalRank;
            }
            playerRankFetched = true;
        }
    }
}
public class LinkEnable : MonoBehaviour
{
    public GameObject linkTo;

    public void OnEnable()
    {
        StartCoroutine(EnableAfterEndOfFrame());
    }

    public IEnumerator EnableAfterEndOfFrame()
    {
        yield return (object)new WaitForEndOfFrame();
        linkTo.gameObject.SetActive(true);
    }

    public void OnDisable()
    {
        StopAllCoroutines();
        linkTo.gameObject.SetActive(false);
    }
}
public class LocaleListener : MonoBehaviour
{
    [SerializeField]
    public UnityEvent<Locale> OnLocaleChanged;

    public void OnEnable()
    {
        LocalizationSettings.Instance.OnSelectedLocaleChanged += LocaleChanged;
    }

    public void OnDisable()
    {
        LocalizationSettings.Instance.OnSelectedLocaleChanged -= LocaleChanged;
    }

    public void LocaleChanged(Locale locale)
    {
        OnLocaleChanged?.Invoke(locale);
    }
}
public class LocalizeActionString : MonoBehaviour
{
    [SerializeField]
    public LocalizedString mouseString;

    [SerializeField]
    public LocalizedString joystickString;

    [SerializeField]
    public UnityEvent<string> onUpdate;

    [SerializeField]
    public bool preferTextActions;

    public void OnEnable()
    {
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Expected O, but got Unknown
        LocalizationSettings.Instance.OnSelectedLocaleChanged += LocaleChanged;
        Events.OnButtonStyleChanged += new UnityAction(ButtonStyleChanged);
        UpdateText();
    }

    public void OnDisable()
    {
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Expected O, but got Unknown
        LocalizationSettings.Instance.OnSelectedLocaleChanged -= LocaleChanged;
        Events.OnButtonStyleChanged -= new UnityAction(ButtonStyleChanged);
    }

    public void UpdateText()
    {
        string text = ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<Cursor3d>.instance.usingMouse ? mouseString : joystickString, preferTextActions);
        onUpdate?.Invoke(text);
    }

    public void LocaleChanged(Locale locale)
    {
        UpdateText();
    }

    public void ButtonStyleChanged()
    {
        UpdateText();
    }
}
public class MapNew : MonoBehaviour
{
    [SerializeField]
    public Transform positioner;

    [SerializeField]
    public Transform nodesGroup;

    [SerializeField]
    public MapPath pathPrefab;

    [SerializeField]
    public MapStamp stamp;

    public static Vector3 prePosition = Vector3.zero;

    public readonly List<MapNode> nodes = new List<MapNode>();

    public readonly List<MapPath> paths = new List<MapPath>();

    [SerializeField]
    public Sprite[] detailSprites;

    public bool active = true;

    public MapPath[] fadedPaths;

    public MapNode hoverNode;

    public MapNode[] fadedNodes;

    public bool interactable = true;

    public void OnEnable()
    {
        Events.OnMapNodeHover += HoverNode;
        Events.OnMapNodeUnHover += UnHoverNode;
    }

    public void OnDisable()
    {
        Events.OnMapNodeHover -= HoverNode;
        Events.OnMapNodeUnHover -= UnHoverNode;
    }

    public IEnumerator Start()
    {
        yield return (object)new WaitUntil((Func<bool>)(() => !Transition.Running));
        References.Map = this;
        TransformExt.DestroyAllChildren(nodesGroup);
        nodes.Clear();
        paths.Clear();
        foreach (CampaignNode node in Campaign.instance.nodes)
        {
            CreateNode(node);
        }
        foreach (MapNode node2 in nodes)
        {
            List<MapNode> list = new List<MapNode>();
            if (node2.campaignNode.connections != null)
            {
                foreach (CampaignNode.Connection connection in node2.campaignNode.connections)
                {
                    MapNode mapNode = FindNode(Campaign.GetNode(connection.otherId));
                    list.Add(mapNode);
                    mapNode.connectedTo++;
                }
            }
            node2.connections = list.ToArray();
        }
        foreach (MapNode node3 in nodes)
        {
            if (!node3.campaignNode.revealed)
            {
                ((Component)node3).gameObject.SetActive(false);
            }
        }
        CreatePaths();
        positioner.localPosition = prePosition;
        yield return Sequences.Wait(0.5f);
        Continue();
    }

    public IEnumerator Restart()
    {
        yield return SceneManager.Unload("Campaign");
        new Routine(Transition.To("Campaign"));
    }

    public MapNode CreateNode(CampaignNode campaignNode)
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        MapNode mapNode = Object.Instantiate<MapNode>(campaignNode.type.mapNodePrefab, nodesGroup);
        ((Component)mapNode).transform.localPosition = Vector2Ext.WithZ(campaignNode.position, 0f);
        mapNode.Assign(campaignNode);
        nodes.Add(mapNode);
        mapNode.map = this;
        (mapNode).name = $"MapNode{nodes.Count}";
        return mapNode;
    }

    public MapNode FindNode(CampaignNode campaignNode)
    {
        return nodes.Find((MapNode a) => a.campaignNode == campaignNode);
    }

    public List<MapPath> FindPaths(MapNode fromNode)
    {
        return paths.FindAll((MapPath a) => a.StartNode == fromNode);
    }

    public void CreatePaths()
    {
        MapNode mapNode = null;
        foreach (MapNode node in nodes)
        {
            if (node.connections.Length != 0)
            {
                mapNode = node;
                break;
            }
        }
        new List<MapNode>();
        while (mapNode != null)
        {
            if (mapNode.connections.Length == 1)
            {
                CreatePath(mapNode, mapNode.connections[0]);
                mapNode = mapNode.connections[0];
            }
            else if (mapNode.connections.Length > 1)
            {
                MapNode mapNode2 = null;
                MapNode[] connections = mapNode.connections;
                foreach (MapNode mapNode3 in connections)
                {
                    List<MapNode> list = new List<MapNode> { mapNode, mapNode3 };
                    MapNode mapNode4 = mapNode3;
                    while (mapNode4 != null)
                    {
                        if (mapNode4.connectedTo == 1 && mapNode4.connections.Length != 0)
                        {
                            list.Add(mapNode4.connections[0]);
                            mapNode4 = mapNode4.connections[0];
                        }
                        else
                        {
                            mapNode2 = mapNode4;
                            mapNode4 = null;
                        }
                    }
                    CreatePath(list.ToArray());
                }
                if (mapNode2 != null)
                {
                    mapNode = mapNode2;
                }
            }
            else
            {
                mapNode = null;
            }
        }
    }

    public MapPath CreatePath(params MapNode[] nodes)
    {
        MapPath mapPath = Object.Instantiate<MapPath>(pathPrefab, nodesGroup);
        foreach (MapNode node in nodes)
        {
            mapPath.Add(node);
        }
        mapPath.Setup();
        paths.Add(mapPath);
        return mapPath;
    }

    public IEnumerator Reveal()
    {
        MapNode currentNode = FindNode(Campaign.FindCharacterNode(References.Player));
        yield return Sequences.Wait(0.5f);
        yield return Reveal(currentNode);
    }

    public IEnumerator Reveal(MapNode fromNode)
    {
        if (fromNode.campaignNode.type.isBattle && !fromNode.campaignNode.cleared)
        {
            yield break;
        }
        fromNode.Reveal();
        List<MapNode> endNodes = new List<MapNode>();
        List<MapPath> list = FindPaths(fromNode);
        foreach (MapPath path in list)
        {
            yield return path.Reveal();
            MapNode endNode = path.EndNode;
            if (!endNodes.Contains(endNode))
            {
                endNodes.Add(endNode);
            }
        }
        foreach (MapNode item in endNodes)
        {
            if (!item.campaignNode.type.isBattle)
            {
                yield return Reveal(item);
            }
        }
    }

    public void UpdateInteractability(bool forceCanSkip = false)
    {
        MapNode mapNode = FindNode(Campaign.FindCharacterNode(References.Player));
        List<MapNode> allConnections = GetAllConnections(mapNode, forceCanSkip);
        foreach (MapNode node in nodes)
        {
            bool flag = allConnections.Contains(node);
            node.reachable = flag || node.campaignNode.cleared;
            node.hoverable = interactable && flag;
            bool flag2 = IArrayExt.Contains<MapNode>(mapNode.connections, node);
            bool flag3 = mapNode.campaignNode.cleared || !mapNode.campaignNode.type.mustClear;
            node.SetSelectable(interactable && flag2 && flag3);
        }
        mapNode.SetSelectable(interactable && mapNode.interactable && !mapNode.campaignNode.cleared);
        foreach (MapPath path in paths)
        {
            if (((Component)path).gameObject.activeSelf)
            {
                path.CheckReachable();
            }
        }
    }

    public void Focus()
    {
        MapNode startNode = FindNode(Campaign.FindCharacterNode(References.Player));
        MapNode[] array = GetAllConnections(startNode).ToArray();
        if (array.Length != 0)
        {
            FocusOn(array);
        }
    }

    public void FocusOn(params MapNode[] nodes)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3.zero;
        foreach (MapNode mapNode in nodes)
        {
            val += ((Component)mapNode).transform.localPosition;
        }
        val /= (float)nodes.Length;
        Vector3 to = -val;
        LeanTween.moveLocal(((Component)positioner).gameObject, to, 0.5f).setEase(LeanTweenType.easeInOutQuad);
        prePosition = to;
    }

    public List<MapNode> GetAllConnections(MapNode startNode, bool forceCanSkip = false)
    {
        List<MapNode> list = new List<MapNode>();
        List<MapNode> list2 = new List<MapNode> { startNode };
        while (list2.Count > 0)
        {
            MapNode mapNode = list2[0];
            list2.RemoveAt(0);
            if (!list.Contains(mapNode))
            {
                list.Add(mapNode);
            }
            if (!(mapNode.campaignNode.cleared || forceCanSkip) && !mapNode.campaignNode.type.canSkip)
            {
                continue;
            }
            MapNode[] connections = mapNode.connections;
            foreach (MapNode item in connections)
            {
                if (!list2.Contains(item))
                {
                    list2.Add(item);
                }
            }
        }
        return list;
    }

    public bool TryMoveTo(MapNode node)
    {
        Character player = References.Player;
        CampaignNode campaignNode = Campaign.FindCharacterNode(player);
        if (campaignNode == node.campaignNode || campaignNode.connections.Exists((CampaignNode.Connection a) => a.otherId == node.campaignNode.id))
        {
            if (!node.campaignNode.type.isBattle || player.GetCompanionCount() <= player.data.companionLimit)
            {
                MoveTo(player, node);
                Enter(player, node);
                return true;
            }
            if (player.entity.display is CharacterDisplay characterDisplay)
            {
                characterDisplay.deckDisplay.companionLimitSequence.Begin();
            }
            return false;
        }
        return false;
    }

    public static void MoveTo(Character character, MapNode node)
    {
        Campaign.MoveCharacter(character, node.campaignNode);
    }

    public void Enter(Character character, MapNode node)
    {
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        interactable = false;
        UpdateInteractability();
        stamp.Stamp(((Component)node).transform.position);
        Campaign.TryEnterNode(node.campaignNode);
    }

    public static IEnumerator CheckCompanionLimit()
    {
        Character player = References.Player;
        EntityDisplay display = player.entity.display;
        CharacterDisplay playerDisplay = display as CharacterDisplay;
        if (playerDisplay != null && player.GetCompanionCount() > player.data.companionLimit)
        {
            playerDisplay.deckDisplay.companionLimitSequence.Begin();
            yield return (object)new WaitUntil((Func<bool>)(() => !playerDisplay.deckDisplay.companionLimitSequence.IsRunning));
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Continue(bool forceCanSkip = false)
    {
        interactable = true;
        foreach (MapNode node in nodes)
        {
            node.Refresh();
        }
        MapNode fromNode = FindNode(Campaign.FindCharacterNode(References.Player));
        StartCoroutine(Reveal(fromNode));
        UpdateInteractability(forceCanSkip);
        Focus();
        stamp.FadeOut();
    }

    public void HoverNode(MapNode node)
    {
        //IL_016d: Unknown result type (might be due to invalid IL or missing references)
        if (hoverNode != null)
        {
            UnHoverNode(hoverNode);
        }
        MapNode mapNode = FindNode(Campaign.FindCharacterNode(References.Player));
        if (mapNode.connections.Length <= 1 || !(node != mapNode) || node.connectedTo != 1)
        {
            return;
        }
        List<MapPath> list = FindPaths(mapNode);
        MapPath mapPath = null;
        List<MapPath> list2 = new List<MapPath>();
        foreach (MapPath item in list)
        {
            if (item.ContainsNode(node))
            {
                mapPath = item;
            }
            else
            {
                list2.Add(item);
            }
        }
        if (!(mapPath != null))
        {
            return;
        }
        hoverNode = node;
        foreach (MapPath item2 in list)
        {
            if (item2 != mapPath)
            {
                item2.FadeTo(0.5f, 0f);
            }
        }
        List<MapNode> allConnections = GetAllConnections(node);
        List<MapNode> list3 = new List<MapNode>();
        foreach (MapNode node2 in nodes)
        {
            bool flag = allConnections.Contains(node2);
            if (!node2.campaignNode.cleared && !flag && !mapPath.ContainsNode(node2))
            {
                list3.Add(node2);
                node2.color = new Color(1f, 1f, 1f, 0.5f);
            }
        }
        fadedPaths = list2.ToArray();
        fadedNodes = list3.ToArray();
    }

    public void UnHoverNode(MapNode node)
    {
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        if (!(hoverNode == node))
        {
            return;
        }
        if (fadedPaths != null)
        {
            MapPath[] array = fadedPaths;
            foreach (MapPath mapPath in array)
            {
                if (mapPath.reachable)
                {
                    mapPath.FadeTo(1f, 0f);
                }
            }
            fadedPaths = null;
        }
        if (fadedNodes != null)
        {
            MapNode[] array2 = fadedNodes;
            foreach (MapNode mapNode in array2)
            {
                if (mapNode.reachable)
                {
                    mapNode.color = Color.white;
                }
            }
            fadedNodes = null;
        }
        hoverNode = null;
    }
}
public class MapNode : MonoBehaviour
{
    public MapNew map;

    public CampaignNode campaignNode;

    public MapNode[] connections;

    public int connectedTo;

    public bool interactable;

    [SerializeField]
    public Animator animator;

    [SerializeField]
    public GameObject highlight;

    [SerializeField]
    public GameObject glow;

    [SerializeField]
    public UINavigationItem uINavigationItem;

    [SerializeField]
    public MapNodeSpriteSetter spriteSetter;

    [SerializeField]
    [HideIf("HasSpriteSetter")]
    public Sprite[] spriteOptions;

    [SerializeField]
    [HideIf("HasSpriteSetter")]
    public Sprite[] clearedSpriteOptions;

    public int spriteIndex;

    [SerializeField]
    public EventReference highlightSfx;

    public bool selectable;

    public bool _hoverable = true;

    public bool _pressable = true;

    public bool reachable = true;

    public bool hasSprite;

    public bool hover;

    public bool press;

    [SerializeField]
    public Transform scaler;

    [SerializeField]
    public SpriteRenderer spriteRenderer;

    [SerializeField]
    public MapNodeLabel label;

    public bool HasSpriteSetter => (spriteSetter);

    public bool hoverable
    {
        get
        {
            return _hoverable;
        }
        set
        {
            //IL_00af: Unknown result type (might be due to invalid IL or missing references)
            //IL_0094: Unknown result type (might be due to invalid IL or missing references)
            //IL_001d: Unknown result type (might be due to invalid IL or missing references)
            //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
            //IL_0052: Unknown result type (might be due to invalid IL or missing references)
            //IL_005c: Unknown result type (might be due to invalid IL or missing references)
            //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
            //IL_00f1: Unknown result type (might be due to invalid IL or missing references)
            //IL_00fb: Unknown result type (might be due to invalid IL or missing references)
            if (_hoverable != value)
            {
                if (value)
                {
                    if (hasSprite)
                    {
                        spriteRenderer.color = Color.white;
                    }
                    if ((scaler))
                    {
                        LeanTween.cancel(((Component)scaler).gameObject);
                        LeanTween.scale(((Component)scaler).gameObject, Vector3.one * 1f, 0.33f).setEase(LeanTweenType.easeOutBack);
                    }
                }
                else
                {
                    Color val = (reachable ? new Color(1f, 1f, 1f, 1f) : new Color(1f, 1f, 1f, 0.25f));
                    if (hasSprite)
                    {
                        spriteRenderer.color = val;
                    }
                    if ((scaler))
                    {
                        LeanTween.cancel(((Component)scaler).gameObject);
                        LeanTween.scale(((Component)scaler).gameObject, Vector3.one * 0.9f, 0.33f).setEase(LeanTweenType.easeOutBack);
                    }
                    if (hover)
                    {
                        UnHover();
                    }
                }
            }
            if ((uINavigationItem))
            {
                ((Behaviour)uINavigationItem).enabled = value;
            }
            _hoverable = value;
        }
    }

    public bool pressable
    {
        get
        {
            return _pressable;
        }
        set
        {
            _pressable = value;
        }
    }

    public bool IsHovered => hover;

    public Color color
    {
        set
        {
            //IL_000e: Unknown result type (might be due to invalid IL or missing references)
            if (hasSprite)
            {
                spriteRenderer.color = value;
            }
        }
    }

    public void Assign(CampaignNode node)
    {
        hasSprite = (spriteRenderer);
        Random.InitState(node.seed);
        if (!HasSpriteSetter && spriteOptions.Length != 0)
        {
            spriteIndex = Random.Range(0, spriteOptions.Length);
        }
        campaignNode = node;
        Refresh();
        interactable = node.type.interactable;
        if (hasSprite)
        {
            Collider2D component = ((Component)spriteRenderer).GetComponent<Collider2D>();
            if (component != null)
            {
                ComponentExt.Destroy((Component)(object)component);
            }
            ((Component)spriteRenderer).gameObject.AddComponent<BoxCollider2D>();
        }
        if ((glow))
        {
            glow.SetActive(node.glow && !node.cleared);
        }
    }

    public void Refresh()
    {
        if (!hasSprite)
        {
            return;
        }
        if (HasSpriteSetter)
        {
            spriteSetter.Set(this);
            return;
        }
        Sprite val = spriteOptions[spriteIndex];
        Sprite val2 = val;
        if (clearedSpriteOptions.Length != 0)
        {
            val2 = clearedSpriteOptions[spriteIndex % clearedSpriteOptions.Length];
        }
        SetSprite((!campaignNode.cleared) ? val : ((val2) ? val2 : val));
    }

    public void SetSprite(Sprite sprite)
    {
        spriteRenderer.sprite = sprite;
    }

    public void OnEnable()
    {
        CheckForFocus();
    }

    public void CheckForFocus()
    {
        if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse && (highlight) && highlight.gameObject.activeSelf && (uINavigationItem) && ((Behaviour)uINavigationItem).isActiveAndEnabled)
        {
            MonoBehaviourSingleton<UINavigationSystem>.instance.SetCurrentNavigationItem(uINavigationItem);
        }
    }

    public void Reveal()
    {
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_007e: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        campaignNode.revealed = true;
        if (!gameObject.activeSelf)
        {
            gameObject.SetActive(true);
            transform.localScale = Vector3.zero;
            LeanTween.scale(gameObject, Vector3.one, Random.Range(0.4f, 0.5f)).setEase(LeanTweenType.easeOutBack);
            transform.localEulerAngles = new Vector3(0f, 0f, Random.Range(45f, 90f));
            LeanTween.rotateLocal(gameObject, Vector3.zero, Random.Range(0.4f, 0.5f)).setEase(LeanTweenType.easeOutBack);
            Events.InvokeMapNodeReveal(this);
            if (!hover && MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem == uINavigationItem)
            {
                Hover();
            }
        }
    }

    public void Hover()
    {
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        if (interactable && hoverable && !hover)
        {
            hover = true;
            LeanTween.cancel(((Component)spriteRenderer).gameObject);
            LeanTween.scale(((Component)spriteRenderer).gameObject, Vector3.one * 1.1f, 0.23f).setEase(LeanTweenType.easeOutBack);
            if ((label))
            {
                label.Show();
            }
            Events.InvokeMapNodeHover(this);
        }
    }

    public void UnHover()
    {
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        if (hover)
        {
            hover = false;
            LeanTween.cancel(((Component)spriteRenderer).gameObject);
            LeanTween.scale(((Component)spriteRenderer).gameObject, Vector3.one * 1f, 0.13f).setEase(LeanTweenType.easeOutBack);
            if ((label))
            {
                label.Hide();
            }
            Events.InvokeMapNodeUnHover(this);
        }
    }

    public void Press(BaseEventData eventData)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        PointerEventData val = (PointerEventData)(object)((eventData is PointerEventData) ? eventData : null);
        if ((val == null || (int)val.button == 0) && interactable && pressable && !press && hover)
        {
            press = true;
            color = new Color(0.85f, 0.85f, 0.85f);
        }
    }

    public void Release(BaseEventData eventData)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        PointerEventData val = (PointerEventData)(object)((eventData is PointerEventData) ? eventData : null);
        if ((val == null || (int)val.button == 0) && press)
        {
            press = false;
            color = Color.white;
            if (hover)
            {
                Select();
            }
        }
    }

    public void Select()
    {
        if (selectable && map.TryMoveTo(this))
        {
            Events.InvokeMapNodeSelect(this);
            animator.Play("Select");
            glow.SetActive(false);
        }
        else
        {
            Events.InvokeMapNodeSelect(null);
            animator.Play("Shake");
        }
    }

    public void SetSelectable(bool value)
    {
        //IL_0088: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        if (!selectable && value)
        {
            if ((animator))
            {
                animator.Play("Selectable");
            }
            if ((highlight))
            {
                highlight.gameObject.SetActive(true);
                highlight.transform.localScale = Vector3.zero;
                LeanTween.scale(highlight, Vector3.one, 1.25f).setEase(LeanTweenType.easeOutElastic).setDelay(0.25f);
            }
            SfxSystem.OneShot(highlightSfx);
            CheckForFocus();
        }
        else if (selectable && !value)
        {
            if ((animator))
            {
                animator.Stop();
            }
            if ((highlight))
            {
                highlight.gameObject.SetActive(false);
            }
        }
        selectable = value;
    }

    public override string ToString()
    {
        return name;
    }
}
public class MapNodeLabel : MonoBehaviour
{
    [SerializeField]
    public SpriteRenderer spriteRenderer;

    [SerializeField]
    public TextMeshFitter textFitter;

    public Vector3 startPos;

    public Color startColor;

    public void Awake()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        startPos = transform.localPosition;
        startColor = spriteRenderer.color;
    }

    public void Show()
    {
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_0076: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a5: Unknown result type (might be due to invalid IL or missing references)
        gameObject.SetActive(true);
        LeanTween.cancel(gameObject);
        LeanTween.cancel(((Component)spriteRenderer).gameObject);
        transform.localPosition = startPos + new Vector3(0f, -0.15f, 0f);
        LeanTween.moveLocal(gameObject, startPos, 1f).setEase(LeanTweenType.easeOutElastic);
        spriteRenderer.color = ColorExt.With(startColor, -1f, -1f, -1f, 0f);
        LeanTween.color(((Component)spriteRenderer).gameObject, startColor, 0.25f).setEase(LeanTweenType.easeOutQuart);
    }

    public void Hide()
    {
        gameObject.SetActive(false);
    }
}
public abstract class MapNodeSpriteSetter : MonoBehaviour
{
    public virtual void Set(MapNode mapNode)
    {
    }

    public MapNodeSpriteSetter()
    {
    }
}
public class MapNodeSpriteSetterBattle : MapNodeSpriteSetter
{
    [SerializeField]
    public SpriteRenderer @base;

    [SerializeField]
    public SpriteRenderer icon;

    [SerializeField]
    public LocalizeStringEvent battleNameString;

    [SerializeField]
    public GameObject iconObj;

    [SerializeField]
    public GameObject flagObj;

    public override void Set(MapNode mapNode)
    {
        if ((@base))
        {
            AreaData areaData = References.Areas[mapNode.campaignNode.areaIndex];
            @base.sprite = areaData.battleBaseSprite;
        }
        if (mapNode.campaignNode.type is CampaignNodeTypeBattle && mapNode.campaignNode.data.TryGetValue("battle", out var value) && value is string assetName)
        {
            BattleData battleData = AddressableLoader.Get<BattleData>("BattleData", assetName);
            if (battleData != null)
            {
                icon.sprite = battleData.sprite;
                if ((battleNameString))
                {
                    battleNameString.StringReference = battleData.nameRef;
                }
            }
        }
        if (mapNode.campaignNode.cleared && (flagObj))
        {
            flagObj.SetActive(true);
            iconObj.SetActive(false);
        }
    }
}
public class MapNodeSpriteSetterItem : MapNodeSpriteSetter
{
    [SerializeField]
    public Sprite normalSprite;

    [SerializeField]
    public Sprite bigSprite;

    [SerializeField]
    public Sprite clearedSprite;

    public override void Set(MapNode mapNode)
    {
        object value;
        if (mapNode.campaignNode.cleared)
        {
            mapNode.SetSprite(clearedSprite);
        }
        else if (mapNode.campaignNode.data.TryGetValue("cards", out value) && value is SaveCollection<string> { Count: > 3 })
        {
            mapNode.SetSprite(bigSprite);
        }
        else
        {
            mapNode.SetSprite(normalSprite);
        }
    }
}
public class MapPath : MonoBehaviour
{
    public struct Node
    {
        public MapNode mapNode;

        public Transform point;
    }

    [SerializeField]
    public Transform linePointPrefab;

    [SerializeField]
    public Transform lastPoint;

    [SerializeField]
    public Vector2 midPointOffset = new Vector2(0f, 1f);

    [SerializeField]
    public float pathShort = 1f;

    [SerializeField]
    public Vector2 pathNodePull = new Vector2(0.75f, 1.2f);

    [SerializeField]
    public LineRenderer line;

    [SerializeField]
    public CurvedLineRenderer curve;

    [Header("Tweens")]
    [SerializeField]
    public LeanTweenType revealEase = LeanTweenType.easeInOutCubic;

    [SerializeField]
    public float revealSpeed = 1f;

    public List<Node> nodes = new List<Node>();

    public bool reachable = true;

    public float alpha = 1f;

    public LTDescr alphaTween;

    public MapNode StartNode { get; set; }

    public MapNode EndNode => nodes[nodes.Count - 1].mapNode;

    public int NodeCount => nodes.Count;

    public bool ContainsNode(MapNode node)
    {
        return nodes.Exists((Node a) => a.mapNode == node);
    }

    public void Add(MapNode node)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_006b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0075: Unknown result type (might be due to invalid IL or missing references)
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        //IL_0091: Unknown result type (might be due to invalid IL or missing references)
        Vector3 localPosition = ((Component)node).transform.localPosition;
        if (lastPoint != null)
        {
            Vector3 val = (lastPoint.localPosition + localPosition) * 0.5f;
            Vector3 val2 = new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f));
            Vector3 localPosition2 = val + ((val2)).normalized * Vector2Ext.Random(midPointOffset);
            AddPoint(localPosition2);
        }
        if (StartNode == null)
        {
            MapNode mapNode2 = (StartNode = node);
        }
        Transform point = AddPoint(localPosition);
        nodes.Add(new Node
        {
            mapNode = node,
            point = point
        });
        lastPoint = point;
    }

    public MapNode Get(int index)
    {
        return nodes[index].mapNode;
    }

    public MapNode[] GetNodes()
    {
        List<MapNode> list = new List<MapNode>();
        foreach (Node node in nodes)
        {
            list.Add(node.mapNode);
        }
        return list.ToArray();
    }

    public void Setup()
    {
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0097: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ff: Unknown result type (might be due to invalid IL or missing references)
        //IL_0104: Unknown result type (might be due to invalid IL or missing references)
        //IL_010e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0113: Unknown result type (might be due to invalid IL or missing references)
        //IL_0118: Unknown result type (might be due to invalid IL or missing references)
        //IL_011b: Unknown result type (might be due to invalid IL or missing references)
        if (nodes.Count > 1)
        {
            Transform point = nodes[0].point;
            PullTowards(((Component)point).transform, ((Component)nodes[1].point).transform.localPosition, pathShort);
            Transform point2 = nodes[nodes.Count - 1].point;
            PullTowards(((Component)point2).transform, ((Component)nodes[nodes.Count - 2].point).transform.localPosition, pathShort);
            for (int i = 1; i < nodes.Count - 1; i++)
            {
                Transform transform = ((Component)nodes[i - 1].mapNode).transform;
                Transform transform2 = ((Component)nodes[i].point).transform;
                Transform transform3 = ((Component)nodes[i + 1].mapNode).transform;
                Vector3 towards = (transform.localPosition + transform3.localPosition) * 0.5f;
                PullTowards(transform2, towards, Vector2Ext.Random(pathNodePull));
            }
            curve.UpdatePoints();
            bool flag = true;
            foreach (Node node in nodes)
            {
                if (!node.mapNode.campaignNode.revealed)
                {
                    flag = false;
                    break;
                }
            }
            if (!flag)
            {
                Hide();
            }
            return;
        }
        throw new Exception("MapPath Error: MUST HAVE more than 1 node in the path");
    }

    public void PullTowards(Transform point, Vector3 towards, float amount)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        Vector3 localPosition = point.localPosition;
        Vector3 val = towards - localPosition;
        Vector3 val2 = ((val)).normalized * amount;
        point.localPosition += val2;
    }

    public Transform AddPoint(Vector3 localPosition)
    {
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        Transform obj = Object.Instantiate<Transform>(linePointPrefab, transform);
        obj.localPosition = localPosition;
        ((Component)obj).gameObject.SetActive(true);
        return obj;
    }

    public void Hide()
    {
        if (gameObject.activeSelf)
        {
            gameObject.SetActive(false);
        }
    }

    public IEnumerator Reveal()
    {
        if (gameObject.activeSelf)
        {
            yield break;
        }
        gameObject.SetActive(true);
        SetAlpha(1f);
        UpdatePathVisibility(0f);
        float delayPerNode = 0.2f / revealSpeed;
        float num = (float)nodes.Count * delayPerNode;
        LeanTween.value(gameObject, 0f, 1f, num).setEase(revealEase).setOnUpdate(delegate (float a)
        {
            UpdatePathVisibility(a);
        });
        Events.InvokeMapPathReveal(num);
        foreach (Node node in nodes)
        {
            yield return Sequences.Wait(delayPerNode);
            node.mapNode.Reveal();
        }
    }

    public void CheckReachable()
    {
        if (!reachable)
        {
            return;
        }
        reachable = false;
        int num = Mathf.Max(2, nodes.Count - 1);
        for (int i = 1; i < num; i++)
        {
            if (nodes[i].mapNode.reachable)
            {
                reachable = true;
                break;
            }
        }
        if (!reachable)
        {
            SetUnreachable();
        }
    }

    public void SetUnreachable()
    {
        reachable = false;
        FadeTo(0f);
    }

    public void FadeTo(float alpha, float time = 0.3f)
    {
        if (Mathf.Abs(this.alpha - alpha) > 0.01f)
        {
            if (time > 0f)
            {
                alphaTween = LeanTween.value(gameObject, this.alpha, alpha, time).setEase(LeanTweenType.easeInOutQuad).setOnUpdate(SetAlpha);
            }
            else
            {
                SetAlpha(alpha);
            }
            this.alpha = alpha;
        }
    }

    public void UpdatePathVisibility(float value)
    {
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Expected O, but got Unknown
        //IL_00d9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00de: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fd: Unknown result type (might be due to invalid IL or missing references)
        //IL_0114: Unknown result type (might be due to invalid IL or missing references)
        //IL_0119: Unknown result type (might be due to invalid IL or missing references)
        //IL_011e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0128: Expected O, but got Unknown
        //IL_0088: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00aa: Unknown result type (might be due to invalid IL or missing references)
        //IL_00af: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b9: Expected O, but got Unknown
        int num = 1;
        if (value <= 0.01f)
        {
            line.widthCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
            {
                new Keyframe(0f, 0f, 0f, 0f),
                new Keyframe(1f, 0f, 0f, 0f)
            });
        }
        else if (value >= 0.99f)
        {
            line.widthCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
            {
                new Keyframe(0f, (float)num, 0f, 0f),
                new Keyframe(1f, (float)num, 0f, 0f)
            });
        }
        else
        {
            line.widthCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
            {
                new Keyframe(0f, (float)num, 0f, 0f),
                new Keyframe(value - 0.01f, (float)num, 0f, 0f),
                new Keyframe(value, 0f, 0f, 0f)
            });
        }
    }

    public void SetColour(Color value)
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        line.colorGradient.colorKeys = (GradientColorKey[])(object)new GradientColorKey[2]
        {
            new GradientColorKey(value, 0f),
            new GradientColorKey(value, 1f)
        };
    }

    public void SetAlpha(float value)
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        Gradient colorGradient = line.colorGradient;
        colorGradient.alphaKeys = (GradientAlphaKey[])(object)new GradientAlphaKey[2]
        {
            new GradientAlphaKey(value, 0f),
            new GradientAlphaKey(value, 1f)
        };
        line.colorGradient = colorGradient;
    }
}
[RequireComponent(typeof(SpriteRenderer))]
public class MapStamp : MonoBehaviour
{
    public SpriteRenderer spriteRenderer;

    public void Awake()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
    }

    public void Stamp(Vector3 position)
    {
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_0098: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a8: Unknown result type (might be due to invalid IL or missing references)
        gameObject.SetActive(true);
        transform.position = position;
        transform.localEulerAngles = new Vector3(0f, 0f, (float)Random.Range(-20, 20));
        LeanTween.cancel(gameObject);
        transform.localScale = Vector3.one * 2f;
        LeanTween.scale(gameObject, Vector3.one, 0.5f).setEase(LeanTweenType.easeOutBounce);
        spriteRenderer.color = new Color(1f, 1f, 1f, 0f);
        LeanTween.color(gameObject, Color.white, 0.33f).setEase(LeanTweenType.easeOutQuad);
    }

    public void FadeOut()
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(gameObject);
        LeanTween.color(gameObject, new Color(1f, 1f, 1f, 0f), 0.33f).setEase(LeanTweenType.easeOutQuad).setOnComplete((Action)delegate
        {
            gameObject.SetActive(false);
        });
    }
}
public class MonoBehaviourCacheTransform : MonoBehaviour
{
    public Transform _transform;

    public Transform transform => _transform ?? (_transform = GetComponent<Transform>());
}
public class MonoBehaviourRect : MonoBehaviour
{
    public RectTransform _rectTransform;

    public RectTransform rectTransform
    {
        get
        {
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            //IL_0018: Expected O, but got Unknown
            //IL_001d: Expected O, but got Unknown
            RectTransform obj = _rectTransform;
            if (obj == null)
            {
                RectTransform val = (RectTransform)transform;
                RectTransform val2 = val;
                _rectTransform = val;
                obj = val2;
            }
            return obj;
        }
    }
}
public class MonoBehaviourRectSingleton<T> : MonoBehaviour where T : MonoBehaviour
{
    public static T _instance;

    public RectTransform _rectTransform;

    public static T instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = Object.FindObjectOfType<T>();
            }
            return _instance;
        }
    }

    public RectTransform rectTransform
    {
        get
        {
            //IL_0015: Unknown result type (might be due to invalid IL or missing references)
            //IL_001f: Expected O, but got Unknown
            if (_rectTransform == null)
            {
                _rectTransform = (RectTransform)transform;
            }
            return _rectTransform;
        }
    }
}
public class MonoBehaviourSingleton<T> : MonoBehaviour where T : MonoBehaviour
{
    public static T instance { get; set; }

    public virtual void Awake()
    {
        instance = (T)(object)((this is T) ? this : null);
        Debug.Log($"Singleton<{typeof(T)}> Created");
    }
}
public class Mover : MonoBehaviour
{
    public Vector3 velocity;

    public float frictMult = 0.9f;

    public bool removeWhenStopped = true;

    public bool removeWhenDisabled = true;

    public void Update()
    {
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        if (removeWhenStopped && ((velocity)).sqrMagnitude <= 0.01f)
        {
            Object.Destroy(this);
            return;
        }
        Transform transform = transform;
        transform.position += velocity * Time.deltaTime;
        velocity = Delta.Multiply(velocity, frictMult, Time.deltaTime);
    }

    public void OnDisable()
    {
        if (removeWhenDisabled)
        {
            Object.Destroy(this);
        }
    }
}
public class OpenURL : MonoBehaviour
{
    [SerializeField]
    public string url;

    public void Open()
    {
        Application.OpenURL(url);
    }
}
public class Page : MonoBehaviour
{
    [Header("Dragging")]
    public bool canDrag = true;

    [Header("Zooming")]
    public bool canZoom = true;

    [ShowIf("canZoom")]
    [MinMaxSlider(-100f, 100f)]
    public Vector2 zoomRange = new Vector2(0f, 80f);

    [ShowIf("canZoom")]
    [Range(0f, 1f)]
    public float zoomSpeed = 0.1f;

    public bool dragging;

    public Vector3 dragGrabPos;

    public float zoom;

    public float zoomTarget;

    public bool inspecting;

    public void OnEnable()
    {
        Events.OnInspect += InspectStart;
        Events.OnInspectEnd += InspectEnd;
    }

    public void OnDisable()
    {
        Events.OnInspect -= InspectStart;
        Events.OnInspectEnd -= InspectEnd;
    }

    public void Update()
    {
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_0107: Unknown result type (might be due to invalid IL or missing references)
        //IL_010d: Unknown result type (might be due to invalid IL or missing references)
        if (inspecting)
        {
            return;
        }
        if (canDrag)
        {
            if (dragging)
            {
                Drag();
            }
            if (dragging && !Input.GetMouseButton(2))
            {
                StopDrag();
            }
            if (Input.GetMouseButtonDown(2))
            {
                StartDrag();
            }
        }
        float num = 0f - Input.mouseScrollDelta.y;
        if (num > 0f)
        {
            zoomTarget = Mathf.Min(zoomTarget + num * zoomSpeed, 1f);
        }
        else if (num < 0f)
        {
            zoomTarget = Mathf.Max(zoomTarget + num * zoomSpeed, 0f);
        }
        if (zoom != zoomTarget)
        {
            zoom = Delta.Lerp(zoom, zoomTarget, 0.1f, Time.deltaTime);
            float num2 = zoomRange.x + (zoomRange.y - zoomRange.x) * zoom;
            transform.localPosition = Vector3Ext.WithZ(transform.localPosition, num2);
        }
    }

    public void InspectStart(Entity entity)
    {
        inspecting = true;
        StopDrag();
    }

    public void InspectEnd(Entity entity)
    {
        inspecting = false;
    }

    public void StartDrag()
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        dragging = true;
        dragGrabPos = transform.position - Cursor3d.PositionWithZ;
    }

    public void Drag()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        transform.position = Cursor3d.PositionWithZ + dragGrabPos;
    }

    public void StopDrag()
    {
        dragging = false;
    }
}
public class PlatformSpecific : MonoBehaviour
{
    [SerializeField]
    public bool editor = true;

    [SerializeField]
    public bool windows = true;

    [SerializeField]
    public bool @switch = true;

    [SerializeField]
    public bool android = true;

    [SerializeField]
    public bool iOs = true;

    [FormerlySerializedAs("mustBeRelease")]
    [SerializeField]
    public bool release;

    [SerializeField]
    public bool demo;

    [SerializeField]
    public bool notDemo;

    public void Awake()
    {
        bool flag = true;
        if (!windows)
        {
            flag = false;
        }
        if (demo)
        {
            flag = false;
        }
        if (!flag)
        {
            gameObject.SetActive(false);
        }
    }
}
public class PlayerGetGold : MonoBehaviour
{
    public void GetGold(int amount)
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        Character player = References.Player;
        if (player != null)
        {
            Inventory inventory = player.data.inventory;
            inventory.gold += amount;
            player.entity.PromptUpdate();
        }
    }
}
public class PointAtCard : MonoBehaviour
{
    [SerializeField]
    public Transform holder;

    [SerializeField]
    public float moveAmount = 0.25f;

    [SerializeField]
    public float lerp = 0.1f;

    public Vector3 targetPos;

    public Transform t;

    public Camera cam;

    public void OnEnable()
    {
        cam = Camera.main;
        t = transform;
        Events.OnEntityHover += EntityHover;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
    }

    public void Update()
    {
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            SetTargetPos(((Component)MonoBehaviourSingleton<Cursor3d>.instance).transform.position);
        }
        t.localPosition = Delta.Lerp(t.localPosition, targetPos, lerp, Time.deltaTime);
    }

    public void EntityHover(Entity entity)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        SetTargetPos(entity.transform.position);
    }

    public void SetTargetPos(Vector3 target)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        Vector3 vectorTo = GetVectorTo(target);
        targetPos = vectorTo * moveAmount;
    }

    public Vector3 GetVectorTo(Vector3 to)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        Vector3 result = cam.WorldToScreenPoint(to) - cam.WorldToScreenPoint(holder.position);
        if (((result)).magnitude > 1f)
        {
            ((result)).Normalize();
        }
        return result;
    }
}
public class PositionBasedOnScene : MonoBehaviour
{
    [Serializable]
    public class ScenePosition
    {
        [SerializeField]
        public string sceneName;

        [SerializeField]
        public Vector3 position;
    }

    [SerializeField]
    public ScenePosition[] positions;

    public bool hasRectTransform;

    public RectTransform rt;

    public Transform t;

    public void OnEnable()
    {
        t = transform;
        Transform obj = t;
        RectTransform val = (RectTransform)(object)((obj is RectTransform) ? obj : null);
        if (val != null)
        {
            hasRectTransform = true;
            rt = val;
        }
        Events.OnSceneChanged += ActiveSceneChanged;
    }

    public void OnDisable()
    {
        Events.OnSceneChanged -= ActiveSceneChanged;
    }

    public void ActiveSceneChanged(Scene to)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        ScenePosition scenePosition = positions.FirstOrDefault((ScenePosition a) => a.sceneName == ((to)).name);
        if (scenePosition != null)
        {
            SetPosition(scenePosition.position);
        }
    }

    public void SetPosition(Vector3 pos)
    {
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        if (hasRectTransform)
        {
            rt.anchoredPosition = (pos);
        }
        else
        {
            t.localPosition = pos;
        }
    }
}
public class PrefabLoaderAsync : MonoBehaviour
{
    [SerializeField]
    public bool onAwake;

    [ShowIf("onAwake")]
    [SerializeField]
    public AssetReferenceGameObject prefabRef;

    [ShowIf("onAwake")]
    [SerializeField]
    public UnityEvent<GameObject> onComplete;

    public AsyncOperationHandle<GameObject> handle;

    public bool busy;

    public void Awake()
    {
        if (onAwake)
        {
            StartCoroutine(Load(prefabRef));
        }
    }

    public IEnumerator Load(AssetReferenceGameObject prefabRef)
    {
        while (busy)
        {
            yield return null;
        }
        busy = true;
        if (handle.IsValid())
        {
            Addressables.Release<GameObject>(handle);
        }
        handle = ((AssetReference)prefabRef).InstantiateAsync(transform, false);
        yield return handle;
        onComplete?.Invoke(handle.Result);
        busy = false;
    }

    public void OnDestroy()
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        if (handle.IsValid())
        {
            Addressables.Release<GameObject>(handle);
        }
    }
}
public class PromptShower : MonoBehaviour
{
    [SerializeField]
    public bool showOnEnable = true;

    [SerializeField]
    public bool showOnce = true;

    [SerializeField]
    [ShowIf("showOnce")]
    public string saveDataString;

    [SerializeField]
    public Prompt.Anchor anchor;

    [SerializeField]
    public Vector2 position;

    [SerializeField]
    public float width;

    [SerializeField]
    public Prompt.Emote.Type emote;

    [SerializeField]
    public LocalizedString localizedString;

    public void OnEnable()
    {
        if (showOnEnable)
        {
            Show(null);
        }
    }

    public void Show(object insert)
    {
        if (showOnce)
        {
            if (SaveSystem.LoadProgressData(saveDataString, defaultValue: false))
            {
                return;
            }
            SaveSystem.SaveProgressData(saveDataString, value: true);
        }
        PromptSystem.Hide();
        PromptSystem.Create(anchor, position.x, position.y, width, emote);
        if (insert != null)
        {
            PromptSystem.SetTextAction(() => string.Format(localizedString.GetLocalizedString(), insert));
        }
        else
        {
            PromptSystem.SetTextAction(() => localizedString.GetLocalizedString());
        }
    }

    public void Hide()
    {
        PromptSystem.Hide();
    }
}
public class RandomPosition : MonoBehaviour
{
    [SerializeField]
    public Vector2 x;

    [SerializeField]
    public Vector2 y;

    public void OnEnable()
    {
        Randomize();
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Randomize()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        transform.localPosition = (new Vector2(Vector2Ext.Random(x), Vector2Ext.Random(y)));
    }
}
public class SceneLoader : MonoBehaviour
{
    public string sceneKey;

    public SceneType sceneType = SceneType.Temporary;

    public bool loading;

    public void Load()
    {
        if (!loading)
        {
            StopAllCoroutines();
            StartCoroutine(LoadRoutine());
        }
    }

    public IEnumerator LoadRoutine()
    {
        loading = true;
        yield return SceneManager.Load(sceneKey, sceneType);
        loading = false;
    }
}
public class SceneRoutine : MonoBehaviour
{
    public virtual IEnumerator Run()
    {
        return null;
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void PromptRun()
    {
        if (Application.isPlaying)
        {
            new Routine(Run());
        }
    }
}
public class SceneUnloader : MonoBehaviour
{
    public bool active = true;

    public void Unload()
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        if (active)
        {
            active = false;
            Scene scene = gameObject.scene;
            new Routine(SceneManager.Unload(((scene)).name));
        }
    }

    public void UnloadAfter(float delay)
    {
        StopAllCoroutines();
        StartCoroutine(UnloadAfterRoutine(delay));
    }

    public IEnumerator UnloadAfterRoutine(float delay)
    {
        yield return (object)new WaitForSeconds(delay);
        Unload();
    }
}
public class ScriptableCardImage : MonoBehaviour
{
    public Entity entity;

    public void Assign(Entity entity)
    {
        this.entity = entity;
        AssignEvent();
    }

    public virtual void AssignEvent()
    {
    }

    public virtual void UpdateEvent()
    {
    }
}
public class SetOtherActive : MonoBehaviour
{
    [SerializeField]
    public GameObject other;

    [SerializeField]
    public bool setOnEnable = true;

    [SerializeField]
    public float delay;

    [SerializeField]
    public bool setOnDisable;

    public void OnEnable()
    {
        if (delay > 0f)
        {
            StartCoroutine(SetActiveAfter(other, setOnEnable, delay));
        }
        else
        {
            other.SetActive(setOnEnable);
        }
    }

    public static IEnumerator SetActiveAfter(GameObject obj, bool active, float delay)
    {
        yield return (object)new WaitForSeconds(delay);
        obj.SetActive(active);
    }

    public void OnDisable()
    {
        StopAllCoroutines();
        other.SetActive(setOnDisable);
    }
}
public class SetStartingHand : MonoBehaviour
{
    [SerializeField]
    public CardData[] startingHand;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleStart += new UnityAction(BattleStart);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleStart -= new UnityAction(BattleStart);
    }

    public void BattleStart()
    {
        References.Player.OrderNextCards(startingHand.Select((CardData a) => (a).name).ToArray());
    }
}
public class SfxLoop : MonoBehaviour
{
    [Serializable]
    public struct Param
    {
        public string name;

        public float value;
    }

    [SerializeField]
    public bool onEnable = true;

    [SerializeField]
    public bool useAreaAmbience;

    [SerializeField]
    [HideIf("useAreaAmbience")]
    public EventReference eventRef;

    [SerializeField]
    public Param[] @params;

    public EventInstance loop;

    public bool playing;

    public EventReference e
    {
        get
        {
            //IL_0014: Unknown result type (might be due to invalid IL or missing references)
            //IL_0009: Unknown result type (might be due to invalid IL or missing references)
            if (!useAreaAmbience)
            {
                return eventRef;
            }
            return References.GetCurrentArea().ambienceEvent;
        }
    }

    public void OnEnable()
    {
        if (onEnable)
        {
            Play();
        }
    }

    public void OnDisable()
    {
        Stop();
    }

    public void Play()
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        loop = SfxSystem.Loop(e);
        Param[] array = @params;
        for (int i = 0; i < array.Length; i++)
        {
            Param param = array[i];
            SetParam(param.name, param.value);
        }
        playing = true;
    }

    public void Stop()
    {
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        if (playing)
        {
            SfxSystem.EndLoop(loop);
            playing = false;
        }
    }

    public void SetParam(string name, float value)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        SfxSystem.SetParam(loop, name, value);
    }

    public void SetParam(float value)
    {
        if (@params.Length != 0)
        {
            SetParam(@params[0].name, value);
        }
    }
}
public class SfxOneshot : MonoBehaviour
{
    [SerializeField]
    public EventReference eventRef;

    [SerializeField]
    [HideIf("onEnable")]
    public bool onAwake;

    [SerializeField]
    [HideIf("onAwake")]
    public bool onEnable = true;

    [SerializeField]
    public float pitch = 1f;

    [SerializeField]
    public float delay;

    public void Awake()
    {
        if (onAwake && !onEnable)
        {
            if (delay > 0f)
            {
                StartCoroutine(FireAfterDelay());
            }
            else
            {
                Fire();
            }
        }
    }

    public void OnEnable()
    {
        if (onEnable)
        {
            if (delay > 0f)
            {
                StartCoroutine(FireAfterDelay());
            }
            else
            {
                Fire();
            }
        }
    }

    public void Fire()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        EventInstance val = SfxSystem.OneShot(eventRef);
        ((val)).setPitch(pitch);
    }

    public IEnumerator FireAfterDelay()
    {
        yield return (object)new WaitForSeconds(delay);
        Fire();
    }
}
[RequireComponent(typeof(Graphic))]
public class Shadow : MonoBehaviourCacheTransform
{
    [SerializeField]
    public Graphic graphic;

    [SerializeField]
    public Vector2 alphaRange;

    public Transform target;

    public CanvasGroup canvasGroup;

    public float preAlpha = -1f;

    public void Assign(Entity entity)
    {
        target = ((Component)entity.offset).transform;
        if (entity.display is Card { canvasGroup: { } val })
        {
            canvasGroup = val;
        }
    }

    public void UpdateAlpha()
    {
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        if (Mathf.Abs(canvasGroup.alpha - preAlpha) > 0.01f)
        {
            graphic.color = ColorExt.WithAlpha(graphic.color, Mathf.Lerp(alphaRange.x, alphaRange.y, canvasGroup.alpha));
        }
        preAlpha = canvasGroup.alpha;
    }
}
public class ShadowManager : MonoBehaviour
{
    [SerializeField]
    public Shadow shadowPrefab;

    [SerializeField]
    public Vector2 limitX = new Vector2(-999f, 999f);

    [SerializeField]
    public Vector2 limitY = new Vector2(-999f, 999f);

    [SerializeField]
    public Vector2 limitZ = new Vector2(0f, 999f);

    [Header("Offset")]
    [SerializeField]
    public Vector3 offset = new Vector3(0.18f, -3.1f, 0f);

    [SerializeField]
    public Vector3 offsetBasedOnScale = new Vector3(0f, 0f, 0f);

    [Header("Scale")]
    [SerializeField]
    [Range(0f, 1f)]
    public float considerScale = 0.5f;

    [SerializeField]
    public Vector3 baseScale = new Vector3(2f / 3f, 2f / 3f, 2f / 3f);

    public readonly Dictionary<ulong, Shadow> active = new Dictionary<ulong, Shadow>();

    public readonly Queue<Shadow> pool = new Queue<Shadow>();

    public void OnEnable()
    {
        Events.OnEntityCreated += Assign;
        Events.OnEntityDestroyed += EntityDestroyed;
    }

    public void OnDisable()
    {
        Events.OnEntityCreated -= Assign;
        Events.OnEntityDestroyed -= EntityDestroyed;
    }

    public void Assign(Entity entity)
    {
        if (entity.inPlay)
        {
            Shadow shadow = Get();
            active[entity.data.id] = shadow;
            shadow.Assign(entity);
        }
    }

    public void EntityDestroyed(Entity entity)
    {
        if ((entity.data) && active.TryGetValue(entity.data.id, out var value))
        {
            active.Remove(entity.data.id);
            Pool(value);
        }
    }

    public void LateUpdate()
    {
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0052: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_006b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Unknown result type (might be due to invalid IL or missing references)
        //IL_007f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        //IL_008b: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e1: Unknown result type (might be due to invalid IL or missing references)
        //IL_0109: Unknown result type (might be due to invalid IL or missing references)
        //IL_0120: Unknown result type (might be due to invalid IL or missing references)
        //IL_012a: Unknown result type (might be due to invalid IL or missing references)
        foreach (Shadow value in active.Values)
        {
            Transform transform = value.transform;
            Vector3 val = value.target.lossyScale - baseScale;
            Vector3 val2 = baseScale + val * considerScale;
            Vector3 val3 = Vector3.Scale(offset, val2) + Vector3.Scale(offsetBasedOnScale, val);
            transform.localScale = val2;
            Vector3 val4 = value.target.position + val3;
            val4.x = Mathf.Clamp(val4.x, limitX.x, limitX.y);
            val4.y = Mathf.Clamp(val4.y, limitY.x, limitY.y);
            val4.z = Mathf.Clamp(val4.z, limitZ.x, limitZ.y);
            transform.position = val4;
            transform.localEulerAngles = new Vector3(0f, 0f, value.target.eulerAngles.z);
            value.UpdateAlpha();
        }
    }

    public Shadow Get()
    {
        Shadow obj = ((pool.Count > 0) ? pool.Dequeue() : Object.Instantiate<Shadow>(shadowPrefab, transform));
        ((Component)obj).gameObject.SetActive(true);
        return obj;
    }

    public void Pool(Shadow shadow)
    {
        ((Component)shadow).gameObject.SetActive(false);
        pool.Enqueue(shadow);
    }
}
public class SliderSfx : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
{
    [SerializeField]
    public Slider slider;

    [SerializeField]
    public EventReference sfxEvent;

    public bool drag;

    public void Fire()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        SfxSystem.OneShot(sfxEvent);
    }

    public void OnPointerDown(PointerEventData eventData)
    {
        drag = true;
    }

    public void OnPointerUp(PointerEventData eventData)
    {
        if (drag)
        {
            Fire();
        }
        drag = false;
    }
}
public class SnowfallParticles : MonoBehaviour
{
    [SerializeField]
    [Range(0f, 1f)]
    [OnValueChanged("Evaluate")]
    public float storminess;

    [SerializeField]
    public AnimationCurve updateCurve;

    [Header("References")]
    [SerializeField]
    public ParticleSystem backSnow;

    [SerializeField]
    public ParticleSystem midSnow;

    [SerializeField]
    public ParticleSystem frontSnow;

    [SerializeField]
    public ParticleSystem bloops;

    [SerializeField]
    public SpriteRenderer fade;

    [Header("Values To Adjust")]
    [SerializeField]
    public AnimationCurve angleRange;

    [SerializeField]
    public AnimationCurve backEmissionRange;

    [SerializeField]
    public AnimationCurve midEmissionRange;

    [SerializeField]
    public AnimationCurve frontEmissionRange;

    [SerializeField]
    public AnimationCurve bloopsEmissionRange;

    [SerializeField]
    public AnimationCurve fadeAlphaRange;

    [SerializeField]
    public AnimationCurve simulationSpeedRange;

    [SerializeField]
    public AnimationCurve backSnowGravityRange;

    [SerializeField]
    public AnimationCurve midSnowGravityRange;

    [SerializeField]
    public AnimationCurve frontSnowGravityRange;

    [SerializeField]
    public AnimationCurve bloopsGravityRange;

    [SerializeField]
    public AnimationCurve xRange;

    [SerializeField]
    public AnimationCurve backSnowXSpeedRange;

    [SerializeField]
    public AnimationCurve midSnowXSpeedRange;

    [SerializeField]
    public AnimationCurve frontSnowXSpeedRange;

    [SerializeField]
    public AnimationCurve bloopsXSpeedRange;

    public MainModule backSnowMain;

    public MainModule midSnowMain;

    public MainModule frontSnowMain;

    public MainModule bloopsMain;

    public EmissionModule backSnowEmission;

    public EmissionModule midSnowEmission;

    public EmissionModule frontSnowEmission;

    public EmissionModule bloopsEmission;

    public VelocityOverLifetimeModule backSnowVel;

    public VelocityOverLifetimeModule midSnowVel;

    public VelocityOverLifetimeModule frontSnowVel;

    public VelocityOverLifetimeModule bloopsVel;

    public float t = 1f;

    public float storminessFrom;

    public float storminessTo;

    public float d = 1f;

    public void Awake()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        //IL_007e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0083: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0094: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
        backSnowMain = backSnow.main;
        midSnowMain = midSnow.main;
        frontSnowMain = frontSnow.main;
        bloopsMain = bloops.main;
        backSnowEmission = backSnow.emission;
        midSnowEmission = midSnow.emission;
        frontSnowEmission = frontSnow.emission;
        bloopsEmission = bloops.emission;
        backSnowVel = backSnow.velocityOverLifetime;
        midSnowVel = midSnow.velocityOverLifetime;
        frontSnowVel = frontSnow.velocityOverLifetime;
        bloopsVel = bloops.velocityOverLifetime;
    }

    public void OnEnable()
    {
        Events.OnSetWeatherIntensity += SetStorminess;
        Evaluate();
    }

    public void OnDisable()
    {
        Events.OnSetWeatherIntensity -= SetStorminess;
    }

    public void SetStorminess(float amount, float duration)
    {
        storminessFrom = storminess;
        storminessTo = amount;
        t = 0f;
        d = duration;
    }

    public void Update()
    {
        if (t < 1f)
        {
            t += Time.deltaTime / d;
            float num = updateCurve.Evaluate(t);
            storminess = storminessFrom + (storminessTo - storminessFrom) * num;
            Evaluate();
        }
    }

    public void Evaluate()
    {
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bb: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e0: Unknown result type (might be due to invalid IL or missing references)
        //IL_0147: Unknown result type (might be due to invalid IL or missing references)
        //IL_016c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0191: Unknown result type (might be due to invalid IL or missing references)
        //IL_01b9: Unknown result type (might be due to invalid IL or missing references)
        transform.localEulerAngles = new Vector3(0f, 0f, angleRange.Evaluate(storminess));
        ((backSnowEmission)).rateOverTime = MinMaxCurve.op_Implicit(backEmissionRange.Evaluate(storminess));
        ((midSnowEmission)).rateOverTime = MinMaxCurve.op_Implicit(midEmissionRange.Evaluate(storminess));
        ((frontSnowEmission)).rateOverTime = MinMaxCurve.op_Implicit(frontEmissionRange.Evaluate(storminess));
        ((bloopsEmission)).rateOverTime = MinMaxCurve.op_Implicit(bloopsEmissionRange.Evaluate(storminess));
        fade.color = ColorExt.With(fade.color, -1f, -1f, -1f, fadeAlphaRange.Evaluate(storminess));
        float simulationSpeed = simulationSpeedRange.Evaluate(storminess);
        ((backSnowMain)).simulationSpeed = simulationSpeed;
        ((midSnowMain)).simulationSpeed = simulationSpeed;
        ((frontSnowMain)).simulationSpeed = simulationSpeed;
        ((bloopsMain)).simulationSpeed = simulationSpeed;
        float num = backSnowGravityRange.Evaluate(storminess);
        ((backSnowMain)).gravityModifier = new MinMaxCurve(0f - num, num);
        float num2 = midSnowGravityRange.Evaluate(storminess);
        ((midSnowMain)).gravityModifier = new MinMaxCurve(0f - num2, num2);
        float num3 = frontSnowGravityRange.Evaluate(storminess);
        ((frontSnowMain)).gravityModifier = new MinMaxCurve(0f - num3, num3);
        float num4 = bloopsGravityRange.Evaluate(storminess);
        ((bloopsMain)).gravityModifier = new MinMaxCurve(0f - num4, num4);
        TransformExt.SetLocalX(transform, xRange.Evaluate(storminess));
        ((backSnowVel)).xMultiplier = backSnowXSpeedRange.Evaluate(storminess);
        ((midSnowVel)).xMultiplier = midSnowXSpeedRange.Evaluate(storminess);
        ((frontSnowVel)).xMultiplier = frontSnowXSpeedRange.Evaluate(storminess);
        ((bloopsVel)).xMultiplier = bloopsXSpeedRange.Evaluate(storminess);
    }
}
public class SpeechBub : MonoBehaviourRect
{
    [SerializeField]
    public TMP_Text textAsset;

    [SerializeField]
    public Transform tail;

    [SerializeField]
    public float minHeight = 1f;

    [SerializeField]
    public float tailOffsetX = -0.225f;

    [SerializeField]
    public float tailOffsetY = -0.125f;

    [SerializeField]
    public float tailAngleOffset = 45f;

    [SerializeField]
    public bool constantAngle = true;

    [SerializeField]
    public string highlightHex = "328AD7";

    [Header("Animations")]
    [SerializeField]
    public TweenUI destroyTween;

    [SerializeField]
    public AnimationCurve moveCurve;

    [SerializeField]
    public Vector2 moveDurRange = new Vector2(0.75f, 1f);

    public float tailAnchorX = 1f;

    public float tailAnchorY = -1f;

    public Transform target;

    public float duration;

    public float durationMax;

    public bool _hasTail = true;

    public bool destroying;

    public float durationFactor => duration / durationMax;

    public bool hasTail
    {
        get
        {
            return _hasTail;
        }
        set
        {
            _hasTail = value;
            ((Component)tail).gameObject.SetActive(value);
        }
    }

    public bool sizeUpdated { get; set; }

    public void OnEnable()
    {
        SfxSystem.OneShot("event:/sfx/ui/speech_bubble");
    }

    public void Set(SpeechBubbleData data)
    {
        textAsset.text = ProcessText(data.text);
        target = data.target;
        hasTail = target != null;
        duration = data.duration;
        durationMax = data.duration;
        StartCoroutine(UpdateSizeNextFrame());
    }

    public void SetPosition(Vector3 localPos)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        sizeUpdated = false;
        LeanTween.cancel(gameObject);
        LeanTween.moveLocal(gameObject, localPos, Vector2Ext.PettyRandom(moveDurRange)).setEase(moveCurve);
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void UpdateSize()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cd: Unknown result type (might be due to invalid IL or missing references)
        float num = textAsset.margin.y + textAsset.margin.w;
        float num2 = minHeight;
        Bounds textBounds = textAsset.textBounds;
        float num3 = Mathf.Max(num2, ((textBounds)).size.y + num);
        base.rectTransform.sizeDelta = Vector2Ext.WithY(base.rectTransform.sizeDelta, num3);
        if (hasTail)
        {
            Vector2 sizeDelta = base.rectTransform.sizeDelta;
            float num4 = tailAnchorX * 0.5f * sizeDelta.x + tailOffsetX * tailAnchorX;
            float num5 = tailAnchorY * 0.5f * sizeDelta.y + tailOffsetY * tailAnchorY;
            tail.localPosition = (new Vector2(num4, num5));
        }
    }

    public IEnumerator UpdateSizeNextFrame()
    {
        yield return null;
        UpdateSize();
        sizeUpdated = true;
    }

    public void LateUpdate()
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0097: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c8: Unknown result type (might be due to invalid IL or missing references)
        if (!destroying)
        {
            Transform transform = transform;
            if (constantAngle && transform.eulerAngles.z != 0f)
            {
                transform.eulerAngles = Vector3Ext.WithZ(transform.eulerAngles, 0f);
            }
            duration -= Time.deltaTime;
            if (duration <= 0f)
            {
                destroying = true;
                StartCoroutine(Destroy());
            }
            if (hasTail && target != null)
            {
                tail.eulerAngles = Vector3Ext.WithZ(tail.eulerAngles, Angle((tail.position), (target.position)) + tailAngleOffset);
            }
        }
    }

    public static float Angle(Vector2 from, Vector2 to)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        Vector2 val = to - from;
        int num = ((val.y >= 0f) ? 1 : (-1));
        return Vector2.Angle(Vector2.right, val) * (float)num;
    }

    public IEnumerator Destroy()
    {
        destroyTween.Fire();
        yield return (object)new WaitForSeconds(destroyTween.GetDuration());
        GameObjectExt.Destroy(gameObject);
    }

    public string ProcessText(string input)
    {
        string text = input.Trim();
        int length = text.Length;
        for (int i = 0; i < length; i++)
        {
            if (text[i] != '<')
            {
                continue;
            }
            string text2 = Text.FindTag(text, i);
            if (text2.Length <= 0)
            {
                continue;
            }
            string text3 = highlightHex;
            text = text.Remove(i, text2.Length + 2);
            int num = text2.IndexOf(' ');
            if (num > 0)
            {
                string text4 = text2.Substring(0, num);
                if (text4[0] == '#')
                {
                    text3 = text4.Substring(1);
                    text2 = text2.Substring(num);
                }
            }
            string text5 = "<#" + text3 + ">" + text2 + "</color>";
            text = text.Insert(i, text5);
            i += text5.Length;
            length = text.Length;
            i--;
        }
        return text;
    }
}
public class SpeechBubbleSpawn : MonoBehaviourRect
{
    public float spacing = 0.01f;

    public readonly List<SpeechBub> bubbles = new List<SpeechBub>();

    public void OnEnable()
    {
        Object.FindObjectOfType<SpeechBubbleSystem>()?.AddSpawnPoint(this);
    }

    public void OnDisable()
    {
        Object.FindObjectOfType<SpeechBubbleSystem>()?.RemoveSpawnPoint(this);
    }

    public void Update()
    {
        bool flag = false;
        for (int num = bubbles.Count - 1; num >= 0; num--)
        {
            SpeechBub speechBub = bubbles[num];
            if (!(speechBub))
            {
                bubbles.RemoveAt(num);
            }
            else if (!flag)
            {
                flag = speechBub.sizeUpdated;
            }
        }
        if (flag)
        {
            UpdateSize();
            UpdatePositions();
        }
    }

    public SpeechBub Create(SpeechBub prefab, SpeechBubbleData data)
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        SpeechBub speechBub = Object.Instantiate<SpeechBub>(prefab, transform);
        Transform transform = ((Component)speechBub).transform;
        transform.localPosition = Vector3.zero;
        RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
        if (val != null)
        {
            val.sizeDelta = Vector2Ext.WithX(val.sizeDelta, base.rectTransform.sizeDelta.x);
        }
        bubbles.Add(speechBub);
        speechBub.Set(data);
        UpdateSize();
        UpdatePositions();
        return speechBub;
    }

    public void UpdateSize()
    {
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_009b: Unknown result type (might be due to invalid IL or missing references)
        Vector2 val = new Vector2(0f, 0f);
        int count = bubbles.Count;
        for (int i = 0; i < count; i++)
        {
            SpeechBub speechBub = bubbles[i];
            if ((speechBub))
            {
                Vector2 sizeDelta = speechBub.rectTransform.sizeDelta;
                val.x = Mathf.Max(val.x, sizeDelta.x);
                val.y += sizeDelta.y + ((i > 0) ? spacing : 0f);
            }
        }
        if ((base.rectTransform))
        {
            base.rectTransform.sizeDelta = val;
        }
    }

    public void UpdatePositions()
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0082: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        //IL_0089: Unknown result type (might be due to invalid IL or missing references)
        //IL_008a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0097: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00aa: Unknown result type (might be due to invalid IL or missing references)
        //IL_00af: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c8: Unknown result type (might be due to invalid IL or missing references)
        if (!(base.rectTransform))
        {
            return;
        }
        Vector2 sizeDelta = base.rectTransform.sizeDelta;
        Vector2 val = default(Vector2);
        ((val))..ctor((0f - sizeDelta.x) * 0.5f, sizeDelta.y * 0.5f);
        int count = bubbles.Count;
        for (int i = 0; i < count; i++)
        {
            SpeechBub speechBub = bubbles[i];
            if ((speechBub))
            {
                if (i < count - 1 && speechBub.hasTail)
                {
                    speechBub.hasTail = false;
                }
                Vector2 sizeDelta2 = speechBub.rectTransform.sizeDelta;
                Vector2 val2 = val + new Vector2(sizeDelta2.x * 0.5f, (0f - sizeDelta2.y) * 0.5f);
                speechBub.SetPosition((val2));
                val.y -= sizeDelta2.y;
            }
        }
    }
}
public class Spinner : MonoBehaviour
{
    [SerializeField]
    public bool ignoreTimeScale;

    public Vector3 speed = new Vector3(0f, 0f, 1f);

    public bool setTargetSpeed;

    [ShowIf("setTargetSpeed")]
    public Vector3 targetSpeed;

    [ShowIf("setTargetSpeed")]
    public float targetSpeedAcc = 100f;

    public void Update()
    {
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        if (setTargetSpeed)
        {
            float num = targetSpeedAcc * Time.deltaTime;
            speed = Vector3.MoveTowards(speed, targetSpeed, num);
        }
        transform.localEulerAngles = transform.localEulerAngles + speed * (ignoreTimeScale ? Time.unscaledDeltaTime : Time.deltaTime);
    }
}
public class SpriteSetter : MonoBehaviour
{
    [SerializeField]
    public Image image;

    [SerializeField]
    public Profile[] sprites;

    public void Set(string @in)
    {
        Profile profile = sprites.FirstOrDefault((Profile a) => a.@string == @in);
        if (profile != null)
        {
            image.sprite = profile.sprite;
        }
    }
}
[Serializable]
public class Profile
{
    public string @string;

    public Sprite sprite;
}
[RequireComponent(typeof(Image))]
[RequireComponent(typeof(StatusIcon))]
public class IconUpdater : MonoBehaviour
{
    public Sprite iconIfValueBelowMax;

    public Sprite iconIfValueAboveMax;

    public Image image;

    public Sprite defaultIcon;

    public void Awake()
    {
        image = GetComponent<Image>();
        defaultIcon = image.sprite;
    }

    public void CheckUpdate(Stat previousValue, Stat newValue)
    {
        StatusIcon component = GetComponent<StatusIcon>();
        if (component != null && component.target != null)
        {
            if (newValue.current < newValue.max && previousValue.current >= previousValue.max)
            {
                image.sprite = ((iconIfValueBelowMax != null) ? iconIfValueBelowMax : defaultIcon);
            }
            else if (iconIfValueAboveMax != null && newValue.current > newValue.max && previousValue.current <= previousValue.max)
            {
                image.sprite = ((iconIfValueAboveMax != null) ? iconIfValueAboveMax : defaultIcon);
            }
            else if (newValue.current == newValue.max && previousValue.current != previousValue.max)
            {
                image.sprite = defaultIcon;
            }
        }
    }
}
public class StatusIcon : MonoBehaviourRect
{
    public string type;

    public TMP_Text textElement;

    public bool persistent;

    [SerializeField]
    public bool alterTextColours = true;

    [ShowIf("alterTextColours")]
    public Color textColour = Color.black;

    [ShowIf("alterTextColours")]
    public Color textColourAboveMax = Color.white;

    [ShowIf("alterTextColours")]
    public Color textColourBelowMax = Color.white;

    [ShowIf("alterTextColours")]
    public Material textMaterialAboveMax;

    public Image fill;

    public Stat value;

    [SerializeField]
    public string textFormat = "{0}";

    [SerializeField]
    public int textAdd;

    public Material normalMaterial;

    public bool currentMaterialIsNormal = true;

    public UnityEvent onCreate;

    public UnityEventStatStat onValueDown;

    public UnityEventStatStat onValueUp;

    public UnityEvent afterUpdate;

    public UnityEvent onDestroy;

    public Entity target { get; set; }

    public virtual Stat GetValue()
    {
        return value;
    }

    public void SetValue(Stat value, bool doPing = true)
    {
        if (doPing)
        {
            UpdateEvent(this.value, value);
        }
        this.value = value;
        afterUpdate.Invoke();
        if ((fill))
        {
            fill.type = (Type)3;
            fill.fillAmount = Mathf.Clamp((float)value.current / (float)value.max, 0f, 1f);
        }
    }

    public virtual void Assign(Entity entity)
    {
        target = entity;
    }

    public void CreateEvent()
    {
        onCreate.Invoke();
    }

    public void UpdateEvent(Stat previousValue, Stat newValue)
    {
        if (newValue.current < previousValue.current)
        {
            ((UnityEvent<Stat, Stat>)onValueDown).Invoke(previousValue, newValue);
        }
        else if (newValue.current > previousValue.current)
        {
            ((UnityEvent<Stat, Stat>)onValueUp).Invoke(previousValue, newValue);
        }
        Events.InvokeStatusIconChanged(this, previousValue, newValue);
    }

    public void DestroyEvent()
    {
        onDestroy.Invoke();
    }

    public void SetText()
    {
        //IL_0082: Unknown result type (might be due to invalid IL or missing references)
        //IL_007a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        if (!(textElement))
        {
            return;
        }
        Stat stat = GetValue();
        textElement.text = string.Format(textFormat, stat.current + textAdd);
        if (!alterTextColours)
        {
            return;
        }
        ((Graphic)textElement).color = ((stat.current > stat.max) ? textColourAboveMax : ((stat.current < stat.max) ? textColourBelowMax : textColour));
        if (stat.current > stat.max)
        {
            if (currentMaterialIsNormal && (textMaterialAboveMax))
            {
                normalMaterial = textElement.fontSharedMaterial;
                currentMaterialIsNormal = false;
                textElement.fontSharedMaterial = textMaterialAboveMax;
            }
        }
        else if (!currentMaterialIsNormal && (normalMaterial))
        {
            currentMaterialIsNormal = true;
            textElement.fontSharedMaterial = normalMaterial;
        }
    }

    public void Ping()
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        if ((base.rectTransform))
        {
            base.rectTransform.LeanCancel();
            base.rectTransform.LeanScale(Vector3.one, 1f).setEaseOutElastic().setFrom(new Vector3(0f, 0f, 1f));
        }
    }

    public virtual void CheckRemove()
    {
        if (!persistent && !(target.statusEffects.Find((StatusEffectData a) => a.type == type)))
        {
            SetValue(default(Stat));
        }
    }

    public void CheckDestroy(Stat previousValue, Stat newValue)
    {
        if (newValue.current <= 0 && newValue.max <= 0 && !persistent)
        {
            Destroy();
        }
    }

    public void Destroy()
    {
        DestroyEvent();
        GameObjectExt.Destroy(gameObject);
    }
}
public class StatusIconCharge : StatusIcon
{
    public Sprite chargedSprite;

    public Material chargedMaterial;

    public Sprite snowSprite;

    public Material snowMaterial;

    public Image _image;

    public Sprite baseSprite;

    public Material baseMaterial;

    public Image image
    {
        get
        {
            if (_image == null)
            {
                _image = GetComponent<Image>();
                baseSprite = _image.sprite;
            }
            return _image;
        }
    }

    public void Awake()
    {
        baseMaterial = textElement.fontSharedMaterial;
    }

    public void CheckSetSprite()
    {
        Stat stat = GetValue();
        Sprite val = baseSprite;
        Material val2 = baseMaterial;
        if (base.target != null && base.target.IsSnowed)
        {
            val = snowSprite ?? baseSprite;
            val2 = snowMaterial ?? baseMaterial;
            ((Component)textElement).gameObject.SetActive(true);
        }
        else if (stat.current <= 0)
        {
            val = chargedSprite ?? baseSprite;
            val2 = chargedMaterial ?? baseMaterial;
            ((Component)textElement).gameObject.SetActive(false);
        }
        else
        {
            ((Component)textElement).gameObject.SetActive(true);
        }
        if (val != null)
        {
            image.sprite = val;
        }
        if (val2 != null)
        {
            textElement.fontSharedMaterial = val2;
        }
    }
}
public class StatusIconCounter : StatusIcon
{
    [SerializeField]
    public Image image;

    [SerializeField]
    public Sprite customSprite;

    [SerializeField]
    public Material customMaterial;

    [SerializeField]
    public Sprite snowSprite;

    [SerializeField]
    public Material snowMaterial;

    public CardIdleAnimation imminentAnimation;

    public Sprite baseSprite;

    public Material baseMaterial;

    public void Awake()
    {
        baseSprite = image.sprite;
        baseMaterial = textElement.fontSharedMaterial;
    }

    public void CheckSetSprite()
    {
        Stat stat = GetValue();
        Sprite val = baseSprite;
        Material val2 = baseMaterial;
        if (base.target != null && base.target.IsSnowed)
        {
            val = snowSprite ?? baseSprite;
            val2 = snowMaterial ?? baseMaterial;
        }
        else if (stat.current <= 1)
        {
            val = customSprite ?? baseSprite;
            val2 = customMaterial ?? baseMaterial;
        }
        if (val != null)
        {
            image.sprite = val;
        }
        if (val2 != null)
        {
            textElement.fontSharedMaterial = val2;
        }
    }
}
[RequireComponent(typeof(StatusIcon))]
public class StatusIconHealth : MonoBehaviour
{
    [Serializable]
    public class Type
    {
        public string name;

        public GameObject group;

        public TMP_Text textElement;

        public Image fill;

        public void Assign(StatusIcon icon)
        {
            group.SetActive(true);
            icon.textElement = textElement;
            icon.fill = fill;
        }
    }

    [SerializeField]
    public Type[] types;

    [SerializeField]
    public GameObject current;

    public StatusIcon _icon;

    public StatusIcon icon => _icon ?? (_icon = GetComponent<StatusIcon>());

    public void SetType()
    {
        if (icon.target == null)
        {
            return;
        }
        string cardTypeName = (icon.target.data.cardType).name;
        if (current == null || (current).name != cardTypeName)
        {
            Type type = Array.Find(types, (Type a) => a.name == cardTypeName);
            if (type != null)
            {
                current.SetActive(false);
                type.Assign(icon);
                current = type.group;
            }
        }
    }
}
public class StatusIconReaction : StatusIcon
{
    public Sprite snowSprite;

    public Image _image;

    public Sprite baseSprite;

    public int snowPre;

    public Image image
    {
        get
        {
            if (_image == null)
            {
                _image = GetComponent<Image>();
                baseSprite = _image.sprite;
            }
            return _image;
        }
    }

    public void UpdateDisplay()
    {
        int num = ((base.target) ? base.target.SnowAmount() : 0);
        if (num > 0 && (snowSprite))
        {
            image.sprite = snowSprite;
        }
        else
        {
            image.sprite = baseSprite;
        }
        snowPre = num;
    }

    public override void CheckRemove()
    {
        if (!base.target.statusEffects.Any((StatusEffectData a) => a.isReaction))
        {
            SetValue(default(Stat));
            base.target.display.reactionIcon = null;
        }
    }
}
public class StatusIconSnow : StatusIcon
{
    public void CustomSetText()
    {
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        TMP_Text val = textElement;
        Stat stat = GetValue();
        int num = stat.current + base.target.counter.current;
        if (val != null)
        {
            val.text = num.ToString();
            if (alterTextColours)
            {
                ((Graphic)val).color = ((num > stat.max) ? textColourAboveMax : textColour);
            }
        }
    }

    public void CustomDestroy()
    {
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        Transform parent = transform.parent;
        if (!(parent != null))
        {
            return;
        }
        foreach (Transform item in parent)
        {
            StatusIcon component = ((Component)item).GetComponent<StatusIcon>();
            if (component.type == "counter")
            {
                component.Ping();
                break;
            }
        }
    }
}
public class SteamManager : MonoBehaviour
{
    public const int appId = 1811990;

    public static bool init { get; set; }

    public async void Awake()
    {
        try
        {
            SteamClient.Init(1811990u, true);
            if (SteamClient.RestartAppIfNecessary(1811990u))
            {
                GameManager.Quit();
            }
            else
            {
                init = true;
            }
        }
        catch (Exception arg)
        {
            Debug.LogError($"Steam failed to initialize! ({arg})");
            Debug.Log($"Steam failed to initialize! ({arg})");
            GameManager.Quit();
        }
        List<string> steamFiles = new List<string>();
        int i = 1;
        while (true)
        {
            Query val = Query.All;
            val = ((val)).WhereUserSubscribed(default(SteamId));
            ResultPage? val2 = await ((val)).GetPageAsync(i);
            if (!val2.HasValue)
            {
                break;
            }
            object source;
            ResultPage valueOrDefault;
            if (!val2.HasValue)
            {
                source = null;
            }
            else
            {
                valueOrDefault = val2.GetValueOrDefault();
                source = ((valueOrDefault)).Entries;
            }
            if (!((IEnumerable<Item>)source).Any())
            {
                break;
            }
            object obj;
            if (!val2.HasValue)
            {
                obj = null;
            }
            else
            {
                valueOrDefault = val2.GetValueOrDefault();
                obj = ((valueOrDefault)).Entries;
            }
            foreach (Item item in (IEnumerable<Item>)obj)
            {
                Item pageEntry = item;
                string directory = ((pageEntry)).Directory;
                if (string.IsNullOrEmpty(directory) || ((pageEntry)).IsDownloadPending || ((pageEntry)).NeedsUpdate || (!string.IsNullOrEmpty(directory) && Directory.GetLastWriteTimeUtc(directory) < ((pageEntry)).Updated))
                {
                    await ((pageEntry)).DownloadAsync((System.Action<float>)null, (System.Action<string>)null, 60, default(CancellationToken), true);
                    directory = ((pageEntry)).Directory;
                }
                steamFiles.Add(directory);
                pageEntry = default(Item);
            }
            i++;
        }
        foreach (string item2 in steamFiles)
        {
            Bootstrap.LoadModAtPath(item2);
        }
    }

    public void OnEnable()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        if (init)
        {
            Debug.Log($"Steam Initialized {SteamClient.Name} ({SteamClient.SteamId})");
        }
    }

    public void OnDisable()
    {
        SteamClient.Shutdown();
    }
}
public class StringReference : MonoBehaviourSingleton<StringReference>
{
    public LocalizedString injured;

    public LocalizedString tutorialCharm1;

    public LocalizedString tutorialCharm2;

    public LocalizedString tutorialCrown;

    public LocalizedString tutorialInjury;

    public LocalizedString tutorialInjuryMultiple;

    public LocalizedString tutorialCompanion1;

    public LocalizedString tutorialCompanion1Gamepad;

    public LocalizedString tutorialCompanion1Touch;

    public LocalizedString tutorialCompanion2;

    public LocalizedString tutorialItem;

    public LocalizedString tutorialBattle1_1;

    public LocalizedString tutorialBattle1_2;

    public LocalizedString tutorialBattle1_3;

    public LocalizedString tutorialBattle1_4;

    public LocalizedString tutorialBattle1_41;

    public LocalizedString tutorialBattle1_5;

    public LocalizedString tutorialBattle1_6;

    public LocalizedString tutorialBattle1_7;

    public LocalizedString tutorialBattle1_8;

    public LocalizedString tutorialBattle2_1;

    public LocalizedString tutorialBattle2_1Gamepad;

    public LocalizedString tutorialBattle2_2;

    public LocalizedString tutorialBattle2_3;

    public LocalizedString tutorialBattle2_4;

    public LocalizedString tutorialBattle2_41a;

    public LocalizedString tutorialBattle2_41b;

    public LocalizedString tutorialBattle2_5;

    public LocalizedString tutorialBattle2_6;

    public LocalizedString tutorialBattle3_1;
}
public class Swayer : MonoBehaviour
{
    [SerializeField]
    public bool randomStart;

    [Header("Position")]
    [OnValueChanged("SwayPositionToggled")]
    public bool swayPosition;

    [ShowIf("swayPosition")]
    public Vector3 positionInfluence = Vector3.one;

    [ShowIf("swayPosition")]
    public Vector3 positionSway = Vector3.one;

    [Header("Rotation")]
    [OnValueChanged("SwayRotationToggled")]
    public bool swayRotation;

    [ShowIf("swayRotation")]
    public Vector3 rotationInfluence = Vector3.one;

    [ShowIf("swayRotation")]
    public Vector3 rotationSway = Vector3.one;

    public Vector3 startPosition;

    public Vector3 startRotation;

    public float t;

    public Transform transform;

    public void Awake()
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        transform = GetComponent<Transform>();
        startPosition = transform.localPosition;
        startRotation = transform.localEulerAngles;
        if (randomStart)
        {
            t = PettyRandom.Range(0f, 10f);
        }
    }

    public void Update()
    {
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_007c: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cc: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d3: Unknown result type (might be due to invalid IL or missing references)
        float num = Time.timeSinceLevelLoad + t;
        if (swayPosition)
        {
            Vector3 localPosition = startPosition + Vector3.Scale(new Vector3(Mathf.Sin(num * positionSway.x), Mathf.Sin(num * positionSway.y), Mathf.Sin(num * positionSway.z)), positionInfluence);
            transform.localPosition = localPosition;
        }
        if (swayRotation)
        {
            Vector3 localEulerAngles = startRotation + Vector3.Scale(new Vector3(Mathf.Sin(num * rotationSway.x), Mathf.Sin(num * rotationSway.y), Mathf.Sin(num * rotationSway.z)), rotationInfluence);
            transform.localEulerAngles = localEulerAngles;
        }
    }

    public void SwayPositionToggled()
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        if (!swayPosition)
        {
            transform.localPosition = startPosition;
        }
    }

    public void SwayRotationToggled()
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        if (!swayRotation)
        {
            transform.localEulerAngles = startRotation;
        }
    }
}
public class SwayerColour : MonoBehaviour
{
    [SerializeField]
    public bool randomStart;

    [HideIf("sprite")]
    public Graphic graphic;

    [HideIf("ui")]
    public SpriteRenderer renderer;

    public Gradient gradient;

    public float speed = 1f;

    public AnimationCurve curve;

    public float t;

    public bool ui => graphic != null;

    public bool sprite => renderer != null;

    public void Awake()
    {
        if (randomStart)
        {
            t = PettyRandom.Range(0f, 10f);
        }
    }

    public void Update()
    {
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        t = (t + Time.deltaTime * speed) % 1f;
        float num = curve.Evaluate(t);
        Color color = gradient.Evaluate(num);
        if (ui)
        {
            graphic.color = color;
        }
        if (sprite)
        {
            renderer.color = color;
        }
    }
}
public class AbilityTargetSystem : GameSystem
{
    public Transform targetGroup;

    public GameObject targetPrefab;

    public Dictionary<CardContainer, GameObject> currentTargets;

    public void OnEnable()
    {
        Events.OnAbilityTargetAdd += AddTarget;
        Events.OnAbilityTargetRemove += RemoveTarget;
        Events.OnSceneChanged += SceneChanged;
    }

    public void OnDisable()
    {
        Events.OnAbilityTargetAdd -= AddTarget;
        Events.OnAbilityTargetRemove -= RemoveTarget;
        Events.OnSceneChanged -= SceneChanged;
        Clear();
    }

    public void AddTarget(CardContainer container)
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        GameObject val = Object.Instantiate<GameObject>(targetPrefab, targetGroup);
        val.transform.position = ((Component)container).transform.position;
        if (currentTargets == null)
        {
            currentTargets = new Dictionary<CardContainer, GameObject>();
        }
        currentTargets[container] = val;
    }

    public void RemoveTarget(CardContainer container)
    {
        if (currentTargets != null && currentTargets.ContainsKey(container))
        {
            GameObjectExt.Destroy(currentTargets[container]);
            currentTargets.Remove(container);
        }
    }

    public void SceneChanged(Scene scene)
    {
        Clear();
    }

    public void Clear()
    {
        if (currentTargets == null)
        {
            return;
        }
        foreach (KeyValuePair<CardContainer, GameObject> item in currentTargets.Where((KeyValuePair<CardContainer, GameObject> pair) => pair.Value != null))
        {
            GameObjectExt.Destroy(item.Value);
        }
        currentTargets = null;
    }
}
public class AchievementsSystem : MonoBehaviour
{
    public static readonly Dictionary<string, string> ChallengeAchievement = new Dictionary<string, string>
    {
        { "Challenge Charm 1", "ACHIEVEMENT_0" },
        { "Challenge Charm 2", "ACHIEVEMENT_1" },
        { "Challenge Charm 3", "ACHIEVEMENT_2" },
        { "Challenge Charm 4", "ACHIEVEMENT_3" },
        { "Challenge Charm 5", "ACHIEVEMENT_4" },
        { "Challenge Charm 6", "ACHIEVEMENT_5" },
        { "Challenge Charm 7", "ACHIEVEMENT_6" },
        { "Challenge Charm 8", "ACHIEVEMENT_7" },
        { "Challenge Charm 9", "ACHIEVEMENT_8" },
        { "Challenge Charm 10", "ACHIEVEMENT_9" },
        { "Challenge Charm 11", "ACHIEVEMENT_10" },
        { "Challenge Charm 12", "ACHIEVEMENT_11" },
        { "Challenge Charm 13", "ACHIEVEMENT_12" },
        { "Challenge Charm 14", "ACHIEVEMENT_13" },
        { "Challenge Charm 15", "ACHIEVEMENT_14" },
        { "Challenge Charm 16", "ACHIEVEMENT_15" },
        { "Challenge Charm 17", "ACHIEVEMENT_16" },
        { "Challenge Charm 18", "ACHIEVEMENT_17" },
        { "Challenge Charm 19", "ACHIEVEMENT_18" },
        { "Challenge Charm 20", "ACHIEVEMENT_19" },
        { "Challenge Charm 21", "ACHIEVEMENT_20" },
        { "Challenge Charm 22", "ACHIEVEMENT_21" },
        { "Challenge Charm 23", "ACHIEVEMENT_22" },
        { "Challenge Charm 24", "ACHIEVEMENT_23" },
        { "Challenge Charm 25", "ACHIEVEMENT_24" },
        { "Challenge Charm 26", "ACHIEVEMENT_25" },
        { "Challenge Charm 27", "ACHIEVEMENT_26" }
    };

    public void OnEnable()
    {
        Events.OnChallengeCompletedSaved += ChallengeCompleted;
    }

    public void OnDisable()
    {
        Events.OnChallengeCompletedSaved -= ChallengeCompleted;
    }

    public static void ChallengeCompleted(ChallengeData challengeData)
    {
        if (SteamManager.init)
        {
            Check((challengeData).name);
        }
    }

    public static void Check(string challengeName)
    {
        if (ChallengeAchievement.TryGetValue(challengeName, out var value))
        {
            Achieve(value);
        }
    }

    public static void Achieve(string achievementId)
    {
        Debug.Log(("Steam Achievement [" + achievementId + "] Unlocked!"));
        Achievement val = default(Achievement);
        ((val))..ctor(achievementId);
        ((val)).Trigger(true);
    }
}
public class AddSecretCardsSystem : GameSystem
{
    [SerializeField]
    public GameModifierData[] requiredModifiers;

    [SerializeField]
    public string[] cardsToAdd;

    [SerializeField]
    public string[] possibleNodeTypes;

    [SerializeField]
    public int[] tiers = new int[2] { 2, 4 };

    public bool HasRequiredModifiers()
    {
        if (Campaign.Data.GameMode.mainGameMode)
        {
            return StormBellManager.TrueFinalBossPointThresholdReached();
        }
        return false;
    }

    public void OnEnable()
    {
        Events.OnCampaignGenerated += Add;
        Events.OnEntityEnterBackpack += EntityEnterBackpack;
        if (Campaign.Data.Modifiers == null || !HasRequiredModifiers())
        {
            enabled = false;
        }
    }

    public void OnDisable()
    {
        Events.OnCampaignGenerated -= Add;
        Events.OnEntityEnterBackpack -= EntityEnterBackpack;
    }

    public async Task Add()
    {
        HashSet<CampaignNode> hashSet = new HashSet<CampaignNode>();
        foreach (CampaignNode node2 in References.Campaign.nodes)
        {
            if (IArrayExt.Contains<int>(tiers, node2.tier) && IArrayExt.Contains<string>(possibleNodeTypes, (node2.type).name))
            {
                hashSet.Add(node2);
            }
        }
        if (hashSet.Count < cardsToAdd.Length)
        {
            return;
        }
        List<CampaignNode> list = IEnumerableExt.InRandomOrder<CampaignNode>((IEnumerable<CampaignNode>)hashSet).OrderByDescending(OrderNodesBySingular).ToList();
        string[] array = cardsToAdd;
        foreach (string cardName in array)
        {
            CampaignNode node = list[0];
            list.RemoveAt(0);
            AddCardToNode(node, cardName);
            list.RemoveAll((CampaignNode a) => a.tier == node.tier);
        }
    }

    public static int OrderNodesBySingular(CampaignNode a)
    {
        if (a.dataLinkedTo == -1)
        {
            List<int> linkedToThis = a.linkedToThis;
            if ((linkedToThis == null || linkedToThis.Count <= 0) && (a.connections.Count > 1 || a.connectedTo > 1))
            {
                return 1;
            }
        }
        return -1;
    }

    public void EntityEnterBackpack(Entity entity)
    {
        if (cardsToAdd.Any((string a) => (entity).name == a))
        {
            Campaign.FindCharacterNode(References.Player).glow = false;
        }
    }

    public static void AddCardToNode(CampaignNode node, string cardName)
    {
        node.glow = true;
        CampaignNodeType type = node.type;
        if (!(type is CampaignNodeTypeItem) && !(type is CampaignNodeTypeCurseItems))
        {
            if (!(type is CampaignNodeTypeShop))
            {
                if (type is CampaignNodeTypeCharmShop)
                {
                    EventRoutineCharmShop.Data data = DictionaryExt.Get<EventRoutineCharmShop.Data>(node.data, "data");
                    float num = Random.Range(0.8f, 1.2f);
                    CardData cardData = AddressableLoader.Get<CardData>("CardData", cardName);
                    int index = IListExt.RandomIndex<EventRoutineCharmShop.UpgradedCard>((IList<EventRoutineCharmShop.UpgradedCard>)data.cards);
                    data.cards[index] = new EventRoutineCharmShop.UpgradedCard
                    {
                        cardDataName = cardName,
                        upgradeNames = Array.Empty<string>(),
                        price = Mathf.RoundToInt((float)cardData.value * num),
                        priceFactor = 1f,
                        purchased = false
                    };
                }
                return;
            }
            ShopRoutine.Data data2 = DictionaryExt.Get<ShopRoutine.Data>(node.data, "shopData");
            float priceFactor = Random.Range(0.8f, 1.2f);
            CardData cardData2 = AddressableLoader.Get<CardData>("CardData", cardName);
            {
                foreach (int item in IEnumerableExt.InRandomOrder<int>((IEnumerable<int>)IListExt.GetIndices<ShopRoutine.Item>((IList<ShopRoutine.Item>)data2.items)))
                {
                    if (data2.items[item].category == "Items" && (data2.upgrades == null || data2.upgrades.Count <= item || data2.upgrades[item] == null || data2.upgrades[item].Length == 0))
                    {
                        float priceFactor2 = data2.items[item].priceFactor;
                        data2.items[item] = new ShopRoutine.Item("Items", cardData2, 0, priceFactor)
                        {
                            priceFactor = priceFactor2
                        };
                        break;
                    }
                }
                return;
            }
        }
        SaveCollection<string> saveCollection = DictionaryExt.Get<SaveCollection<string>>(node.data, "cards");
        bool flag = false;
        foreach (int item2 in IEnumerableExt.InRandomOrder<int>((IEnumerable<int>)IListExt.GetIndices<string>((IList<string>)saveCollection.collection)))
        {
            if (!node.data.ContainsKey($"upgrades{item2}"))
            {
                saveCollection[item2] = cardName;
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            int num2 = Random.Range(0, saveCollection.Count - 1);
            saveCollection[num2] = cardName;
            node.data.Remove($"upgrades{num2}");
        }
    }
}
public class Analytics : GameSystem
{
}
public class BattleLogSystem : GameSystem
{
    public List<BattleLog> list = new List<BattleLog>();

    public static readonly Dictionary<string, string> damageTypes = new Dictionary<string, string>
    {
        { "shroom", "<sprite name=shroom>" },
        { "spikes", "<sprite name=teeth>" },
        { "overload", "<sprite name=overload>" }
    };

    [SerializeField]
    public LocalizedString logTurnKey;

    [SerializeField]
    public LocalizedString logHitKey;

    [SerializeField]
    public LocalizedString logDamageKey;

    [SerializeField]
    public LocalizedString logSpecialDamageKey;

    [SerializeField]
    public LocalizedString logDestroyKey;

    [SerializeField]
    public LocalizedString logConsumedKey;

    [SerializeField]
    public LocalizedString logEatenKey;

    [SerializeField]
    public LocalizedString logSacrificedKey;

    [SerializeField]
    public LocalizedString logBlockKey;

    [SerializeField]
    public LocalizedString logStatusKey;

    [SerializeField]
    public LocalizedString logStatusFromKey;

    [SerializeField]
    public LocalizedString logHealKey;

    [SerializeField]
    public LocalizedString logRestoredKey;

    [SerializeField]
    public LocalizedString logBoostKey;

    [SerializeField]
    public LocalizedString logDamageUpKey;

    [SerializeField]
    public LocalizedString logDamageUpSelfKey;

    [SerializeField]
    public LocalizedString logDamageDownKey;

    [SerializeField]
    public LocalizedString logDamageDownSelfKey;

    [SerializeField]
    public LocalizedString logHealthUpKey;

    [SerializeField]
    public LocalizedString logHealthUpSelfKey;

    [SerializeField]
    public LocalizedString logHealthDownKey;

    [SerializeField]
    public LocalizedString logHealthDownSelfKey;

    [SerializeField]
    public LocalizedString logCounterUpKey;

    [SerializeField]
    public LocalizedString logCounterUpSelfKey;

    [SerializeField]
    public LocalizedString logCounterDownKey;

    [SerializeField]
    public LocalizedString logCounterDownSelfKey;

    [SerializeField]
    public LocalizedString logEnterBattleKey;

    [SerializeField]
    public LocalizedString logRecalledKey;

    [SerializeField]
    public LocalizedString logSummonedKey;

    [SerializeField]
    public LocalizedString logBattleWinKey;

    [SerializeField]
    public LocalizedString logBattleLoseKey;

    [SerializeField]
    public LocalizedString logFleeKey;

    public void OnEnable()
    {
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0099: Expected O, but got Unknown
        Events.OnBattlePhaseStart += BattlePhaseStart;
        Events.OnBattleTurnEnd += TurnEnd;
        Events.OnEntityHit += Hit;
        Events.OnEntityMove += EntityMove;
        Events.OnStatusEffectApplied += StatusApplied;
        Events.OnEntityPostHit += PostHit;
        Events.OnEntityKilled += EntityKilled;
        Events.OnEntityFlee += EntityFlee;
        Events.OnBattleEnd += new UnityAction(BattleEnd);
    }

    public void OnDisable()
    {
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0099: Expected O, but got Unknown
        Events.OnBattlePhaseStart -= BattlePhaseStart;
        Events.OnBattleTurnEnd -= TurnEnd;
        Events.OnEntityHit -= Hit;
        Events.OnEntityMove -= EntityMove;
        Events.OnStatusEffectApplied -= StatusApplied;
        Events.OnEntityPostHit -= PostHit;
        Events.OnEntityKilled -= EntityKilled;
        Events.OnEntityFlee -= EntityFlee;
        Events.OnBattleEnd -= new UnityAction(BattleEnd);
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        if (phase == Battle.Phase.Init)
        {
            list.Clear();
        }
    }

    public void TurnEnd(int turnNumber)
    {
        if (!References.Battle.ended)
        {
            Log(logTurnKey, BattleLogType.Turn, turnNumber + 1);
        }
    }

    public void Hit(Hit hit)
    {
        if (hit.countsAsHit && hit.Offensive)
        {
            if (!hit.BasicHit || !(hit.attacker) || !(hit.attacker.data))
            {
                LogDamage(hit.target, hit.damage + hit.damageBlocked, hit.damageType);
            }
            else
            {
                LogHit(hit.attacker, hit.target, hit.damage + hit.damageBlocked, hit.damageType);
            }
        }
    }

    public void EntityMove(Entity entity)
    {
        if (Battle.IsOnBoard(entity) && !Battle.IsOnBoard(entity.preContainers))
        {
            Log(logEnterBattleKey, BattleLogType.Enter, GetBattleEntity(entity));
        }
    }

    public void StatusApplied(StatusEffectApply apply)
    {
        if ((apply.effectData) && !StringExt.IsNullOrWhitespace(apply.effectData.type) && apply.count > 0)
        {
            switch (apply.effectData.type)
            {
                case "heal":
                    LogHeal(apply.applier, apply.target);
                    break;
                case "damage up":
                    LogDamageUp(apply.applier, apply.target, apply.count);
                    break;
                case "damage down":
                    LogDamageDown(apply.applier, apply.target, apply.count);
                    break;
                case "max health up":
                    LogHealthUp(apply.applier, apply.target, apply.count);
                    break;
                case "max health down":
                    LogHealthDown(apply.applier, apply.target, apply.count);
                    break;
                case "counter up":
                case "max counter up":
                    LogCounterUp(apply.applier, apply.target, apply.count);
                    break;
                case "counter down":
                case "max counter down":
                    LogCounterDown(apply.applier, apply.target, apply.count);
                    break;
                default:
                    LogStatus(apply.applier, apply.target, apply.effectData, apply.count);
                    break;
            }
        }
    }

    public void PostHit(Hit hit)
    {
        if (hit.countsAsHit && hit.Offensive && hit.damageBlocked > 0)
        {
            LogBlock(hit.target, hit.damageBlocked);
        }
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        if (deathType != DeathType.Consume)
        {
            if (DeathSystem.KilledByOwnTeam(entity))
            {
                Log(logSacrificedKey, BattleLogType.Die, GetBattleEntity(entity));
            }
            else
            {
                Log(logDestroyKey, BattleLogType.Die, GetBattleEntity(entity));
            }
        }
        else
        {
            Log(logConsumedKey, BattleLogType.Consume, GetBattleEntity(entity));
        }
    }

    public void EntityFlee(Entity entity)
    {
        Log(logFleeKey, BattleLogType.Flee, GetBattleEntity(entity));
    }

    public void BattleEnd()
    {
        if (References.Battle.winner == References.Battle.player)
        {
            Log(logBattleWinKey, BattleLogType.Win);
        }
        else
        {
            Log(logBattleLoseKey, BattleLogType.Win);
        }
    }

    public void LogHit(Entity attacker, Entity target, int damage, string damageType)
    {
        if ((target))
        {
            Log(logHitKey, BattleLogType.Attack, GetBattleEntity(attacker), GetBattleEntity(target), damage);
        }
    }

    public void LogDamage(Entity target, int damage, string damageType)
    {
        if (damage > 0)
        {
            if (damageTypes.TryGetValue(damageType, out var value))
            {
                Log(logSpecialDamageKey, BattleLogType.Debuff, GetBattleEntity(target), damage, value);
            }
            else
            {
                Log(logDamageKey, BattleLogType.Debuff, GetBattleEntity(target), damage);
            }
        }
    }

    public void LogBlock(Entity target, int damageBlocked)
    {
        Log(logBlockKey, BattleLogType.Buff, GetBattleEntity(target), damageBlocked);
    }

    public void LogStatus(Entity applier, Entity target, StatusEffectData status, int count)
    {
        if (status.isStatus)
        {
            BattleLogType type = (status.offensive ? BattleLogType.Debuff : BattleLogType.Buff);
            if ((applier) && applier.data.id != target.data.id)
            {
                Log(logStatusFromKey, type, GetBattleEntity(applier), GetBattleEntity(target), count, status.type);
            }
            else
            {
                Log(logStatusKey, type, GetBattleEntity(target), count, status.type);
            }
        }
    }

    public void LogHeal(Entity healer, Entity target)
    {
        Log(logHealKey, BattleLogType.Heal, GetBattleEntity(healer), GetBattleEntity(target));
    }

    public void LogRestore(Entity target, int amount)
    {
        Log(logRestoredKey, BattleLogType.Heal, GetBattleEntity(target), amount);
    }

    public void LogDamageUp(Entity applier, Entity target, int amount)
    {
        if (!(applier) || applier == target)
        {
            Log(logDamageUpSelfKey, BattleLogType.Buff, GetBattleEntity(target), amount);
        }
        else
        {
            Log(logDamageUpKey, BattleLogType.Buff, GetBattleEntity(applier), GetBattleEntity(target), amount);
        }
    }

    public void LogDamageDown(Entity applier, Entity target, int amount)
    {
        if (!(applier) || applier == target)
        {
            Log(logDamageDownSelfKey, BattleLogType.Debuff, GetBattleEntity(target), amount);
        }
        else
        {
            Log(logDamageDownKey, BattleLogType.Debuff, GetBattleEntity(applier), GetBattleEntity(target), amount);
        }
    }

    public void LogHealthUp(Entity applier, Entity target, int amount)
    {
        if (!(applier) || applier == target)
        {
            Log(logHealthUpSelfKey, BattleLogType.Buff, GetBattleEntity(target), amount);
        }
        else
        {
            Log(logHealthUpKey, BattleLogType.Buff, GetBattleEntity(applier), GetBattleEntity(target), amount);
        }
    }

    public void LogHealthDown(Entity applier, Entity target, int amount)
    {
        if (!(applier) || applier == target)
        {
            Log(logHealthDownSelfKey, BattleLogType.Debuff, GetBattleEntity(target), amount);
        }
        else
        {
            Log(logHealthDownKey, BattleLogType.Debuff, GetBattleEntity(applier), GetBattleEntity(target), amount);
        }
    }

    public void LogCounterUp(Entity applier, Entity target, int amount)
    {
        if (!(applier) || applier == target)
        {
            Log(logCounterUpSelfKey, BattleLogType.Debuff, GetBattleEntity(target), amount);
        }
        else
        {
            Log(logCounterUpKey, BattleLogType.Debuff, GetBattleEntity(applier), GetBattleEntity(target), amount);
        }
    }

    public void LogCounterDown(Entity applier, Entity target, int amount)
    {
        if (!(applier) || applier == target)
        {
            Log(logCounterDownSelfKey, BattleLogType.Buff, GetBattleEntity(target), amount);
        }
        else
        {
            Log(logCounterDownKey, BattleLogType.Buff, GetBattleEntity(applier), GetBattleEntity(target), amount);
        }
    }

    public void Log(LocalizedString textKey, BattleLogType type, params object[] args)
    {
        BattleLog battleLog = default(BattleLog);
        battleLog.textKey = textKey;
        battleLog.type = type;
        battleLog.args = args;
        BattleLog item = battleLog;
        list.Add(item);
    }

    public static BattleEntity GetBattleEntity(Entity entity)
    {
        BattleEntity battleEntity = default(BattleEntity);
        battleEntity.cardType = (entity.data.cardType).name;
        battleEntity.friendly = entity.owner.team == References.Player.team;
        battleEntity.forceTitle = entity.data.forceTitle;
        BattleEntity result = battleEntity;
        if (StringExt.IsNullOrWhitespace(result.forceTitle))
        {
            if (((LocalizedReference)entity.data.titleKey).IsEmpty)
            {
                result.forceTitle = entity.data.titleFallback;
            }
            else
            {
                result.titleKey = entity.data.titleKey;
            }
        }
        return result;
    }
}
[Serializable]
public struct BattleLog
{
    public LocalizedString textKey;

    public object[] args;

    public BattleLogType type;
}
[Serializable]
public struct BattleEntity
{
    public LocalizedString titleKey;

    public string forceTitle;

    public string cardType;

    public bool friendly;
}
public enum BattleLogType
{
    None,
    Turn,
    Attack,
    Heal,
    Enter,
    Flee,
    Buff,
    Debuff,
    EnemyDie,
    Die,
    Consume,
    Win,
    Lose
}
public class BattleUndoSystem : GameSystem
{
    [SerializeField]
    public BattleSaveSystem battleSaveSystem;

    [SerializeField]
    public GameObject button;

    public void Undo()
    {
    }
}
public class BlingParticleSystem : GameSystem
{
    [SerializeField]
    public BlingParticle blingPrefab;

    [SerializeField]
    public int initialPoolSize = 20;

    [SerializeField]
    public Sprite lowValueSprite;

    [SerializeField]
    public Sprite highValueSprite;

    [SerializeField]
    public int highValueAmount = 5;

    public readonly Queue<BlingParticle> pool = new Queue<BlingParticle>();

    public void Start()
    {
        for (int i = 0; i < initialPoolSize; i++)
        {
            Pool(Object.Instantiate<BlingParticle>(blingPrefab, transform));
        }
    }

    public void OnEnable()
    {
        Events.OnDropGold += DropGold;
    }

    public void OnDisable()
    {
        Events.OnDropGold -= DropGold;
    }

    public void DropGold(int amount, string source, Character owner, Vector3 position)
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        int num = PettyRandom.Range(3, 5);
        owner.data.inventory.goldOwed += amount;
        while (amount > 0)
        {
            BlingParticle blingParticle = Get();
            ((Component)blingParticle).transform.position = position;
            ((Component)blingParticle).gameObject.SetActive(true);
            blingParticle.owner = owner;
            if (num > 0 || amount < highValueAmount)
            {
                blingParticle.value = 1;
                blingParticle.sprite = lowValueSprite;
                num--;
            }
            else
            {
                blingParticle.value = highValueAmount;
                blingParticle.sprite = highValueSprite;
            }
            amount -= blingParticle.value;
        }
    }

    public BlingParticle Get()
    {
        if (pool.Count > 0)
        {
            return pool.Dequeue();
        }
        return Object.Instantiate<BlingParticle>(blingPrefab, transform);
    }

    public void Pool(BlingParticle particle)
    {
        ((Component)particle).gameObject.SetActive(false);
        pool.Enqueue(particle);
    }
}
public class BossRewardCompatibilitySystem : GameSystem
{
    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnCampaignLoaded += new UnityAction(CampaignLoaded);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnCampaignLoaded -= new UnityAction(CampaignLoaded);
    }

    public void CampaignLoaded()
    {
        bool flag = false;
        foreach (CampaignNode node in Campaign.instance.nodes)
        {
            if (!node.type.isBattle || !(node.type is CampaignNodeTypeBoss) || node.data.ContainsKey("rewards"))
            {
                continue;
            }
            if (!flag)
            {
                CharacterRewards component = ((Component)References.Player).GetComponent<CharacterRewards>();
                if (component != null)
                {
                    component.Populate(References.PlayerData.classData);
                    component.RemoveLockedCards();
                    flag = true;
                }
            }
            CampaignNodeTypeBoss.GetRewards(node);
            Debug.Log($"Boss Node [{node.name}][{node.id}] doesn't contain any boss reward data! Pulling new rewards!");
        }
    }
}
public class CameraAnimationSystem : GameSystem
{
    [Serializable]
    public struct Animation
    {
        public string name;

        public Curve[] curves;
    }

    [Serializable]
    public struct Curve
    {
        public AnimationCurve curve;

        public Vector3 moveAmount;

        public Vector3 rotateAmount;

        public Vector2 durationRange;
    }

    public class RunCurve
    {
        public Curve curve;

        public float time;

        public float duration;

        public float value;

        public bool IsDone => time >= duration;

        public RunCurve(Curve curve)
        {
            //IL_000f: Unknown result type (might be due to invalid IL or missing references)
            this.curve = curve;
            duration = Vector2Ext.PettyRandom(curve.durationRange);
        }

        public void Update(float delta)
        {
            time += delta;
            value = curve.curve.Evaluate(time / duration);
        }

        public Vector3 GetPosOffset()
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            return curve.moveAmount * value;
        }

        public Vector3 GetRotOffset()
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            return curve.rotateAmount * value;
        }
    }

    public Transform target;

    public Animation[] animations;

    public Dictionary<string, Animation> lookup;

    public List<RunCurve> running = new List<RunCurve>();

    public void OnEnable()
    {
        lookup = new Dictionary<string, Animation>();
        Animation[] array = animations;
        for (int i = 0; i < array.Length; i++)
        {
            Animation value = array[i];
            lookup[value.name] = value;
        }
        running.Clear();
        Events.OnCameraAnimation += Run;
    }

    public void OnDisable()
    {
        Events.OnCameraAnimation -= Run;
    }

    public void Update()
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        //IL_0092: Unknown result type (might be due to invalid IL or missing references)
        int count = running.Count;
        if (count <= 0)
        {
            return;
        }
        Vector3 val = Vector3.zero;
        Vector3 val2 = Vector3.zero;
        float deltaTime = Time.deltaTime;
        for (int num = count - 1; num >= 0; num--)
        {
            RunCurve runCurve = running[num];
            runCurve.Update(deltaTime);
            val += runCurve.GetPosOffset();
            val2 += runCurve.GetRotOffset();
            if (runCurve.IsDone)
            {
                running.RemoveAt(num);
            }
        }
        target.localPosition = val;
        target.localEulerAngles = val2;
    }

    public void Run(string name)
    {
        if (lookup.ContainsKey(name))
        {
            Run(lookup[name]);
        }
    }

    public void Run(Animation animation)
    {
        Curve[] curves = animation.curves;
        foreach (Curve curve in curves)
        {
            running.Add(new RunCurve(curve));
        }
    }
}
public class CameraRumbleSystem : GameSystem
{
    public Transform target;

    [HorizontalLine(/*Could not decode attribute arguments.*/)]
    public float strength = 1f;

    public Vector3 positionInfluence = new Vector3(1f, 1f, 1f);

    public Vector3 rotationInfluence = new Vector3(1f, 1f, 1f);

    public float t;

    public float d;

    [SerializeField]
    public AnimationCurve curve;

    public bool active;

    public float delay;

    public void OnEnable()
    {
        Events.OnScreenRumble += Rumble;
    }

    public void OnDisable()
    {
        Events.OnScreenRumble -= Rumble;
    }

    public void Update()
    {
        //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d3: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_0085: Unknown result type (might be due to invalid IL or missing references)
        //IL_008a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ab: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b1: Unknown result type (might be due to invalid IL or missing references)
        if (!active)
        {
            return;
        }
        if (delay > 0f)
        {
            delay -= Time.deltaTime;
            return;
        }
        t += Time.deltaTime;
        float num = ((t <= d) ? curve.Evaluate(t) : 0f) * strength * CameraShakerSystem.ShakeAmount;
        if (num > 0f)
        {
            target.localPosition = Vector3.Cross(positionInfluence, PettyRandom.Vector3()) * num;
            target.localEulerAngles = Vector3.Cross(rotationInfluence, PettyRandom.Vector3()) * num;
        }
        else
        {
            target.localPosition = Vector3.zero;
            target.localEulerAngles = Vector3.zero;
        }
        if (t > d)
        {
            active = false;
        }
    }

    public void Rumble(float startStrength, float endStrength, float delay, float fadeInTime, float holdTime, float fadeOutTime)
    {
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0052: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0094: Unknown result type (might be due to invalid IL or missing references)
        //IL_0099: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a3: Expected O, but got Unknown
        //IL_00b0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c0: Unknown result type (might be due to invalid IL or missing references)
        this.delay = delay;
        t = 0f;
        d = fadeInTime + holdTime + fadeOutTime;
        curve = new AnimationCurve((Keyframe[])(object)new Keyframe[4]
        {
            new Keyframe(0f, startStrength, 0f, 0f),
            new Keyframe(fadeInTime, endStrength, 0f, 0f),
            new Keyframe(fadeInTime + holdTime, endStrength, 0f, 0f),
            new Keyframe(d, 0f, 0f, 0f)
        });
        active = true;
        target.localPosition = Vector3.zero;
        target.localEulerAngles = Vector3.zero;
    }
}
public class CameraShakerSystem : GameSystem
{
    public Transform target;

    [HorizontalLine(/*Could not decode attribute arguments.*/)]
    public float magnitudeMod = 1f;

    public float angularMod = 0.67f;

    public float accelerationMod = 300f;

    [HorizontalLine(/*Could not decode attribute arguments.*/)]
    [SerializeField]
    public AnimationCurve hitStrengthCurve;

    [HorizontalLine(/*Could not decode attribute arguments.*/)]
    [Range(0f, 1f)]
    public float frict = 0.2f;

    [Range(0f, 180f)]
    public float angleRand = 20f;

    [Range(0f, 1f)]
    public float angularFrict = 0.1f;

    [HorizontalLine(/*Could not decode attribute arguments.*/)]
    public Vector3 positionInfluence = new Vector3(0.2f, 0.2f, 0f);

    public Vector3 rotationInfluence = new Vector3(1f, 1f, 1f);

    public Vector2 pos;

    public Vector2 velocity;

    public float angle;

    public float angularSpeed;

    public static float ShakeAmount;

    public void OnEnable()
    {
        Events.OnEntityHit += Hit;
        Events.OnScreenShake += Shake;
        Events.OnSettingChanged += SettingChanged;
        ShakeAmount = Settings.Load("ScreenShake", 1f);
    }

    public void OnDisable()
    {
        Events.OnEntityHit -= Hit;
        Events.OnScreenShake -= Shake;
        Events.OnSettingChanged -= SettingChanged;
        Stop();
    }

    public static void SettingChanged(string key, object value)
    {
        if (key == "ScreenShake" && value is float shakeAmount)
        {
            ShakeAmount = shakeAmount;
        }
    }

    public void Hit(Hit hit)
    {
        if (hit.Offensive && hit.screenShake > 0f)
        {
            float hitDirection = GetHitDirection(hit);
            int offensiveness = hit.GetOffensiveness();
            float magnitude = hit.screenShake * hitStrengthCurve.Evaluate((float)offensiveness);
            Shake(magnitude, hitDirection);
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Shake(float magnitude = 1f)
    {
        Shake(magnitude, PettyRandom.value * 360f);
    }

    public void Shake(float magnitude = 1f, float? direction = null)
    {
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        float radians = ((direction ?? PettyRandom.Range(0f, 360f)) + PettyRandom.Range(0f - angleRand, angleRand)) * ((float)Math.PI / 180f);
        float len = ((velocity)).magnitude + magnitude * magnitudeMod * ShakeAmount;
        velocity = Lengthdir.ToVector2(len, radians);
        angularSpeed += magnitude * ShakeAmount * FloatExt.WithRandomSign(angularMod, 0.5f);
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Stop()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        velocity = Vector2.zero;
        pos = Vector2.zero;
        angle = 0f;
        angularSpeed = 0f;
        if (target != null)
        {
            target.localPosition = Vector3.zero;
            target.localEulerAngles = Vector3.zero;
        }
    }

    public void Update()
    {
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_006f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0075: Unknown result type (might be due to invalid IL or missing references)
        //IL_007f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        //IL_0089: Unknown result type (might be due to invalid IL or missing references)
        //IL_010c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0112: Unknown result type (might be due to invalid IL or missing references)
        //IL_0117: Unknown result type (might be due to invalid IL or missing references)
        //IL_0144: Unknown result type (might be due to invalid IL or missing references)
        //IL_014a: Unknown result type (might be due to invalid IL or missing references)
        //IL_014f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        float magnitude = ((pos)).magnitude;
        if (magnitude > 0.01f)
        {
            float radians = Vector2Ext.Angle(pos);
            Vector2 val = Lengthdir.ToVector2(magnitude * accelerationMod, radians);
            velocity -= val * Time.deltaTime;
        }
        velocity = Delta.Multiply(velocity, 1f - frict, Time.deltaTime);
        pos += velocity * Time.deltaTime;
        angularSpeed -= angle * accelerationMod * Time.deltaTime;
        angularSpeed = Delta.Multiply(angularSpeed, 1f - angularFrict, Time.deltaTime);
        angle += angularSpeed * Time.deltaTime;
        target.localPosition = Vector3.Scale(new Vector3(0f - pos.x, pos.y, angle), positionInfluence);
        target.localEulerAngles = Vector3.Scale(new Vector3(0f - pos.x, pos.y, angle), rotationInfluence);
    }

    public float GetHitDirection(Hit hit)
    {
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        if (!(hit.attacker))
        {
            return PettyRandom.Range(0f, 360f);
        }
        return Vector3Ext.AngleTo(hit.attacker.transform.position, hit.target.transform.position);
    }
}
public class CancelCardDragSystem : GameSystem
{
    [SerializeField]
    public string input = "Back";

    public void Update()
    {
        if (InputSystem.Enabled && !InputSystem.reset && !InputSystem.IsButtonPressed("Back"))
        {
            return;
        }
        CardController[] array = Object.FindObjectsOfType<CardController>();
        foreach (CardController cardController in array)
        {
            if ((cardController.dragging))
            {
                cardController.DragCancel();
            }
        }
    }
}
public class CardDiscoverSystem : GameSystem
{
    [Serializable]
    public struct PhaseChange
    {
        public string phasedCardName;

        public string originalCardName;
    }

    public static CardDiscoverSystem instance;

    [SerializeField]
    public PhaseChange[] phaseChanges;

    public List<string> discoveredCards;

    public List<string> discoveredCharms;

    public void OnEnable()
    {
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Expected O, but got Unknown
        instance = this;
        discoveredCards = SaveSystem.LoadProgressData<List<string>>("cardsDiscovered");
        if (discoveredCards == null)
        {
            discoveredCards = new List<string>();
        }
        discoveredCharms = SaveSystem.LoadProgressData<List<string>>("charmsDiscovered");
        if (discoveredCharms == null)
        {
            discoveredCharms = new List<string>();
        }
        Events.OnPreCampaignPopulate += new UnityAction(CampaignStart);
        Events.OnEntityKilled += EntityKilled;
        Events.OnEntitySummoned += EntitySummoned;
        Events.OnEntityShowUnlocked += EntityShowUnlocked;
        Events.OnUpgradeGained += UpgradeGained;
        Events.OnEntityEnterBackpack += EntityEnterBackpack;
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnPreCampaignPopulate -= new UnityAction(CampaignStart);
        Events.OnEntityKilled -= EntityKilled;
        Events.OnEntitySummoned -= EntitySummoned;
        Events.OnEntityShowUnlocked -= EntityShowUnlocked;
        Events.OnUpgradeGained -= UpgradeGained;
        Events.OnEntityEnterBackpack -= EntityEnterBackpack;
    }

    public void CampaignStart()
    {
        foreach (CardData item in References.PlayerData.inventory.deck)
        {
            DiscoverCard(item);
            foreach (CardUpgradeData upgrade in item.upgrades)
            {
                DiscoverCharm((upgrade).name);
            }
        }
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        if ((References.Battle) && entity.owner.team == References.Battle.enemy.team)
        {
            DiscoverCard(entity.data);
            DiscoverCard(phaseChanges.FirstOrDefault((PhaseChange a) => a.phasedCardName == (entity.data).name).originalCardName);
        }
    }

    public void EntitySummoned(Entity entity, Entity summonedBy)
    {
        DiscoverCard(entity.data);
    }

    public void EntityShowUnlocked(Entity entity)
    {
        DiscoverCard(entity.data);
    }

    public void UpgradeGained(CardUpgradeData upgradeData)
    {
        if (upgradeData.type == CardUpgradeData.Type.Charm)
        {
            DiscoverCharm((upgradeData).name);
        }
    }

    public void EntityEnterBackpack(Entity entity)
    {
        DiscoverCard(entity.data);
        foreach (CardUpgradeData upgrade in entity.data.upgrades)
        {
            if (upgrade.type == CardUpgradeData.Type.Charm)
            {
                DiscoverCharm((upgrade).name);
            }
        }
    }

    public void DiscoverCard(CardData cardData)
    {
        if (cardData.cardType.discoverInJournal)
        {
            DiscoverCard((cardData).name);
        }
    }

    public void DiscoverCard(string cardDataName)
    {
        if (!discoveredCards.Contains(cardDataName))
        {
            discoveredCards.Add(cardDataName);
            SaveSystem.SaveProgressData("cardsDiscovered", discoveredCards);
        }
    }

    public void DiscoverCharm(string charmName)
    {
        if (!discoveredCharms.Contains(charmName))
        {
            discoveredCharms.Add(charmName);
            SaveSystem.SaveProgressData("charmsDiscovered", discoveredCharms);
        }
    }

    public static void CheckDiscoverCharm(string charmName)
    {
        instance.DiscoverCharm(charmName);
    }
}
public class CardFramesSystem : GameSystem
{
    public static CardFramesSystem instance;

    public Dictionary<string, int> frameLevels = new Dictionary<string, int>();

    public Dictionary<string, int> newFrameLevels = new Dictionary<string, int>();

    public bool show;

    public void OnEnable()
    {
        frameLevels = SaveSystem.LoadProgressData<Dictionary<string, int>>("frameLevels") ?? new Dictionary<string, int>();
        newFrameLevels = SaveSystem.LoadProgressData<Dictionary<string, int>>("newFrameLevels") ?? new Dictionary<string, int>();
        instance = this;
        Events.OnCampaignEnd += CampaignEnd;
        Events.OnSettingChanged += SettingChanged;
        show = Settings.Load("SpecialCardFrames", 1) == 1;
    }

    public void OnDisable()
    {
        Events.OnCampaignEnd -= CampaignEnd;
        Events.OnSettingChanged -= SettingChanged;
    }

    public void SettingChanged(string key, object value)
    {
        if (!(key != "SpecialCardFrames") && value is int num)
        {
            show = num == 1;
        }
    }

    public static int GetFrameLevel(string cardDataName)
    {
        if (!instance.show)
        {
            return 0;
        }
        instance.frameLevels.TryGetValue(cardDataName, out var value);
        return value;
    }

    public void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
    {
        if (result == Campaign.Result.Win)
        {
            bool anyChange = false;
            if (CheckTrueWin())
            {
                SetFrameLevel(2, out anyChange);
            }
            else
            {
                SetFrameLevel(1, out anyChange);
            }
            if (anyChange)
            {
                SaveSystem.SaveProgressData("frameLevels", frameLevels);
                SaveSystem.SaveProgressData("newFrameLevels", newFrameLevels);
            }
        }
    }

    public static bool CheckTrueWin()
    {
        return SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "trueWin", defaultValue: false);
    }

    public void SetFrameLevel(int level, out bool anyChange)
    {
        anyChange = false;
        foreach (CardData item in References.PlayerData.inventory.deck)
        {
            if (TrySetFrameLevel(item, level))
            {
                anyChange = true;
            }
        }
    }

    public bool TrySetFrameLevel(CardData cardData, int level)
    {
        if (!cardData.cardType.miniboss && (!frameLevels.TryGetValue((cardData).name, out var value) || value < level))
        {
            frameLevels[(cardData).name] = level;
            newFrameLevels[(cardData).name] = level;
            return true;
        }
        return false;
    }

    public bool AnyNewFrames()
    {
        return newFrameLevels.Count > 0;
    }

    public IEnumerator DisplayNewFrames()
    {
        yield return DisplayNewFrames(2);
        yield return DisplayNewFrames(1);
        newFrameLevels.Clear();
        SaveSystem.SaveProgressData("newFrameLevels", newFrameLevels);
    }

    public IEnumerator DisplayNewFrames(int level)
    {
        string[] cards = GetNewCards(level);
        if (cards.Length != 0)
        {
            InputSystem.Disable();
            yield return SceneManager.Load("CardFramesUnlocked", SceneType.Temporary);
            InputSystem.Enable();
            CardFramesUnlockedSequence cardFramesUnlockedSequence = Object.FindObjectOfType<CardFramesUnlockedSequence>();
            yield return cardFramesUnlockedSequence.Run(level, cards);
            yield return SceneManager.WaitUntilUnloaded("CardFramesUnlocked");
        }
    }

    public string[] GetNewCards(int level)
    {
        return (from a in newFrameLevels
                where a.Value == level
                select a.Key).ToArray();
    }
}
public abstract class ChallengeListenerSystem : GameSystem
{
    public ChallengeData challengeData;

    public ChallengeSystem challengeSystem;

    public void Assign(ChallengeData challengeData, ChallengeSystem challengeSystem)
    {
        this.challengeData = challengeData;
        this.challengeSystem = challengeSystem;
    }

    public void Complete()
    {
        challengeSystem.SetAsComplete(challengeData);
        Object.Destroy(this);
    }

    public ChallengeListenerSystem()
    {
    }
}
public class ChallengeListenerSystemDefeatBossWithoutSnow : ChallengeListenerSystem
{
    public const string effectType = "snow";

    public int nodeId;

    public bool snowApplied;

    public bool isBossBattle;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Expected O, but got Unknown
        Events.OnBattleStart += new UnityAction(BattleStart);
        Events.OnBattleLoaded += new UnityAction(BattleLoaded);
        Events.OnBattleSaved += new UnityAction(BattleSaved);
        Events.OnBattleEnd += new UnityAction(BattleEnd);
        Events.OnStatusEffectApplied += StatusApplied;
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Expected O, but got Unknown
        Events.OnBattleStart -= new UnityAction(BattleStart);
        Events.OnBattleLoaded -= new UnityAction(BattleLoaded);
        Events.OnBattleSaved -= new UnityAction(BattleSaved);
        Events.OnBattleEnd -= new UnityAction(BattleEnd);
        Events.OnStatusEffectApplied -= StatusApplied;
    }

    public void StatusApplied(StatusEffectApply apply)
    {
        if (isBossBattle && !snowApplied && apply.target.owner.team == References.Battle.enemy.team && apply.effectData.type == "snow" && apply.target.data.cardType.miniboss)
        {
            snowApplied = true;
        }
    }

    public void BattleStart()
    {
        CampaignNode campaignNode = Campaign.FindCharacterNode(References.Player);
        isBossBattle = campaignNode.type.isBattle && campaignNode.type.isBoss;
        if (isBossBattle)
        {
            nodeId = campaignNode.id;
            snowApplied = false;
        }
    }

    public void BattleLoaded()
    {
        CampaignNode campaignNode = Campaign.FindCharacterNode(References.Player);
        isBossBattle = campaignNode.type.isBattle && campaignNode.type.isBoss;
        if (isBossBattle)
        {
            nodeId = SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "DefeatBossWithoutSnowNodeId", -1);
            if (nodeId == campaignNode.id)
            {
                snowApplied = SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "DefeatBossWithoutSnowSnowApplied", defaultValue: false);
            }
        }
    }

    public void BattleSaved()
    {
        if (isBossBattle && nodeId >= 0)
        {
            SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "DefeatBossWithoutSnowNodeId", nodeId);
            SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "DefeatBossWithoutSnowSnowApplied", snowApplied);
        }
    }

    public void BattleEnd()
    {
        if (isBossBattle && !snowApplied && References.Battle.winner == References.Player)
        {
            Complete();
        }
        isBossBattle = false;
        snowApplied = false;
        nodeId = -1;
    }
}
public class ChallengeListenerSystemHighCardsInHand : ChallengeListenerSystem
{
    public const int required = 12;

    public readonly List<Entity> summonedToCheck = new List<Entity>();

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnCardDrawEnd += new UnityAction(CardDrawEnd);
        Events.OnEntitySummoned += EntitySummoned;
        Events.OnEntityMove += EntityMove;
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnCardDrawEnd -= new UnityAction(CardDrawEnd);
        Events.OnEntitySummoned -= EntitySummoned;
        Events.OnEntityMove -= EntityMove;
    }

    public void CardDrawEnd()
    {
        CheckRequirement();
    }

    public void EntitySummoned(Entity entity, Entity summonedBy)
    {
        summonedToCheck.Add(entity);
    }

    public void EntityMove(Entity entity)
    {
        int num = summonedToCheck.IndexOf(entity);
        if (num >= 0)
        {
            summonedToCheck.RemoveAt(num);
            CheckRequirement();
        }
    }

    public void CheckRequirement()
    {
        if (References.Player.handContainer.Count >= 12)
        {
            Complete();
        }
    }
}
public class ChallengeListenerSystemWinWithOnlyPet : ChallengeListenerSystem
{
    public void OnEnable()
    {
        Events.OnCampaignEnd += CampaignEnd;
    }

    public void OnDisable()
    {
        Events.OnCampaignEnd -= CampaignEnd;
    }

    public void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
    {
        if (result != Campaign.Result.Win)
        {
            return;
        }
        string text = null;
        int num = 0;
        foreach (CardData item in References.PlayerData.inventory.deck)
        {
            if ((item.cardType).name == "Friendly")
            {
                if (++num > 1)
                {
                    text = null;
                    break;
                }
                text = (item).name;
            }
        }
        if (num == 1 && IArrayExt.Contains<string>(MetaprogressionSystem.GetUnlockedPets(), text))
        {
            Complete();
        }
    }
}
public class ChallengeListenerSystemWinWithoutCharms : ChallengeListenerSystem
{
    public void OnEnable()
    {
        Events.OnCampaignEnd += CampaignEnd;
    }

    public void OnDisable()
    {
        Events.OnCampaignEnd -= CampaignEnd;
    }

    public void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
    {
        if (result != Campaign.Result.Win)
        {
            return;
        }
        bool flag = false;
        foreach (CardData item in References.PlayerData.inventory.deck)
        {
            if (item.upgrades.Any((CardUpgradeData a) => a.type == CardUpgradeData.Type.Charm))
            {
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            Complete();
        }
    }
}
public class ChallengeProgressSystem : GameSystem
{
    public static ChallengeProgressSystem instance;

    public List<ChallengeProgress> progress;

    public bool saveRequired;

    public void Awake()
    {
        instance = this;
    }

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnCampaignSaved += new UnityAction(CheckSave);
        Events.OnCampaignLoaded += new UnityAction(Load);
        instance.progress = LoadProgress();
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnCampaignSaved -= new UnityAction(CheckSave);
        Events.OnCampaignLoaded -= new UnityAction(Load);
    }

    public static int GetProgress(string challengeName)
    {
        return (instance.progress?.FirstOrDefault((ChallengeProgress a) => a.challengeName == challengeName))?.currentValue ?? 0;
    }

    public static void AddProgress(string challengeName, int add)
    {
        ChallengeProgress challengeProgress = instance.progress.FirstOrDefault((ChallengeProgress a) => a.challengeName == challengeName);
        if (challengeProgress == null)
        {
            ChallengeProgress challengeProgress2 = SaveSystem.LoadProgressData<List<ChallengeProgress>>("challengeProgress", null)?.FirstOrDefault((ChallengeProgress a) => a.challengeName == challengeName);
            challengeProgress = ((challengeProgress2 == null) ? new ChallengeProgress(challengeName, 0) : new ChallengeProgress(challengeName, challengeProgress2.currentValue));
            instance.progress.Add(challengeProgress);
        }
        instance.saveRequired = true;
        challengeProgress.currentValue += add;
    }

    public static List<ChallengeProgress> LoadProgress()
    {
        List<ChallengeProgress> list = SaveSystem.LoadProgressData("challengeProgress", new List<ChallengeProgress>());
        foreach (ChallengeProgress item in list)
        {
            item.originalValue = item.currentValue;
        }
        return list;
    }

    public void CheckSave()
    {
        if (saveRequired)
        {
            if (Campaign.Data.GameMode.doSave)
            {
                SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "challengeProgress", progress);
            }
            SaveSystem.SaveProgressData("challengeProgress", progress);
            saveRequired = false;
        }
    }

    public void Load()
    {
        progress = LoadProgress();
        List<ChallengeProgress> list = SaveSystem.LoadCampaignData<List<ChallengeProgress>>(Campaign.Data.GameMode, "challengeProgress", null);
        if (list == null)
        {
            return;
        }
        foreach (ChallengeProgress inCampaignData in list)
        {
            ChallengeProgress challengeProgress = progress.FirstOrDefault((ChallengeProgress a) => a.challengeName == inCampaignData.challengeName);
            if (challengeProgress != null && inCampaignData.currentValue >= challengeProgress.currentValue)
            {
                challengeProgress.originalValue = inCampaignData.originalValue;
            }
        }
    }
}
public class ChallengeSystem : GameSystem
{
    public List<ChallengeData> activeChallenges;

    public List<ChallengeData> saveRequired;

    public void OnEnable()
    {
        //IL_0122: Unknown result type (might be due to invalid IL or missing references)
        //IL_012c: Expected O, but got Unknown
        List<string> list = SaveSystem.LoadProgressData<List<string>>("completedChallenges", null) ?? new List<string>();
        activeChallenges = new List<ChallengeData>();
        foreach (ChallengeData allChallenge in GetAllChallenges())
        {
            if (list.Contains((allChallenge).name))
            {
                continue;
            }
            bool flag = true;
            ChallengeData[] requires = allChallenge.requires;
            foreach (ChallengeData challengeData in requires)
            {
                if (!list.Contains((challengeData).name))
                {
                    flag = false;
                    break;
                }
            }
            if (flag)
            {
                activeChallenges.Add(allChallenge);
            }
        }
        foreach (ChallengeData item in activeChallenges.Where((ChallengeData a) => a.listener.checkType == ChallengeListener.CheckType.CustomSystem))
        {
            item.listener.AddCustomSystem(item, this);
        }
        Events.OnStatChanged += StatChanged;
        Events.OnOverallStatsSaved += OverallStatsChanged;
        Events.OnCampaignSaved += new UnityAction(CheckSave);
    }

    public void OnDisable()
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        Events.OnStatChanged -= StatChanged;
        Events.OnOverallStatsSaved -= OverallStatsChanged;
        Events.OnCampaignSaved -= new UnityAction(CheckSave);
    }

    public void StatChanged(string stat, string key, int oldValue, int newValue)
    {
        for (int num = activeChallenges.Count - 1; num >= 0; num--)
        {
            ChallengeData challengeData = activeChallenges[num];
            ChallengeListener listener = challengeData.listener;
            if (listener.checkType == ChallengeListener.CheckType.MidRun && listener.Check(stat, key))
            {
                listener.Set((challengeData).name, oldValue, newValue);
                if (ChallengeProgressSystem.GetProgress((challengeData).name) >= challengeData.goal)
                {
                    activeChallenges.RemoveAt(num);
                    saveRequired.Add(challengeData);
                }
            }
        }
    }

    public void OverallStatsChanged(CampaignStats stats)
    {
        bool flag = false;
        for (int num = activeChallenges.Count - 1; num >= 0; num--)
        {
            ChallengeData challengeData = activeChallenges[num];
            ChallengeListener listener = challengeData.listener;
            if (listener.checkType == ChallengeListener.CheckType.EndOfRun && listener.CheckComplete(stats))
            {
                ChallengeProgressSystem.AddProgress((challengeData).name, 1);
                if (ChallengeProgressSystem.GetProgress((challengeData).name) >= challengeData.goal)
                {
                    activeChallenges.RemoveAt(num);
                    saveRequired.Add(challengeData);
                    flag = true;
                }
            }
        }
        if (flag)
        {
            CheckSave();
        }
    }

    public void SetAsComplete(ChallengeData challengeData)
    {
        activeChallenges.Remove(challengeData);
        saveRequired.Add(challengeData);
        CheckSave();
    }

    public void CheckSave()
    {
        if (saveRequired.Count <= 0)
        {
            return;
        }
        List<string> list = SaveSystem.LoadProgressData<List<string>>("completedChallenges", null) ?? new List<string>();
        List<string> list2 = SaveSystem.LoadProgressData<List<string>>("townNew", null) ?? new List<string>();
        List<string> list3 = SaveSystem.LoadProgressData<List<string>>("unlocked", null) ?? new List<string>();
        foreach (ChallengeData item in saveRequired)
        {
            list.Add((item).name);
            list2.Add((item.reward).name);
            list3.Add((item.reward).name);
            Events.InvokeChallengeCompletedSaved(item);
        }
        SaveSystem.SaveProgressData("completedChallenges", list);
        SaveSystem.SaveProgressData("townNew", list2);
        SaveSystem.SaveProgressData("unlocked", list3);
        saveRequired.Clear();
    }

    public static IEnumerable<ChallengeData> GetAllChallenges()
    {
        return from a in AddressableLoader.GetGroup<ChallengeData>("ChallengeData")
               where a.reward.IsActive
               select a;
    }
}
public class ChangePhaseAnimationSystem : GameSystem
{
    public class Target
    {
        public Entity entity;

        public Transform previousParent;

        public Target(Entity entity)
        {
            this.entity = entity;
            previousParent = entity.transform.parent;
        }
    }

    [SerializeField]
    public Transform container;

    [SerializeField]
    public float zoomAmount = 3f;

    [SerializeField]
    public Image fade;

    [SerializeField]
    public Color fadeColor;

    [SerializeField]
    public Color flashColor;

    [SerializeField]
    public Image flash;

    [SerializeField]
    public AnimationCurve flashCurve;

    public float slowmo = 0.1f;

    public float durationIn = 0.3f;

    public float durationOut = 0.9f;

    public readonly List<Target> targets = new List<Target>();

    public void Assign(Entity target)
    {
        targets.Add(new Target(target));
        target.transform.SetParent(container, true);
        target.ResetDrawOrder();
    }

    public void ClearFocus()
    {
        foreach (Target target in targets)
        {
            if ((target.entity) && (target.entity.transform) && (target.previousParent))
            {
                target.entity.transform.SetParent(target.previousParent);
            }
        }
        targets.Clear();
    }

    public void RemoveTarget(Entity entity)
    {
        for (int num = targets.Count - 1; num >= 0; num--)
        {
            if (targets[num].entity == entity)
            {
                targets.RemoveAt(num);
            }
        }
    }

    public void Flash()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        ScreenFlashSystem.SetDrawOrder("ParticlesFront", 0);
        ScreenFlashSystem.SetColour(flashColor);
        ScreenFlashSystem.Run(0.2f);
    }

    public IEnumerator Focus(Entity target)
    {
        Assign(target);
        HitFlashSystem.Remove(target);
        LeanTween.value(gameObject, Time.timeScale, slowmo, 0.05f).setEase(LeanTweenType.linear).setOnUpdate(Events.InvokeTimeScaleChange);
        LeanTween.value(gameObject, Time.timeScale, 1f, 0.25f).setDelay(durationIn).setEase(LeanTweenType.linear)
            .setOnUpdate(Events.InvokeTimeScaleChange);
        LeanTween.value(gameObject, ((Graphic)fade).color.a, fadeColor.a, durationIn).setEase(LeanTweenType.easeInOutQuint).setOnUpdate(delegate (float a)
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0021: Unknown result type (might be due to invalid IL or missing references)
            ((Graphic)fade).color = ColorExt.With(((Graphic)fade).color, -1f, -1f, -1f, a);
        });
        Vector3 to = Vector3Ext.WithZ(target.transform.position, zoomAmount);
        LeanTween.cancel(((Component)References.MinibossCameraMover).gameObject);
        LeanTween.move(((Component)References.MinibossCameraMover).gameObject, to, Mathf.Min(durationIn, 0.4f)).setEase(LeanTweenType.easeOutBack);
        yield return Sequences.Wait(durationIn);
        LeanTween.value(gameObject, Time.timeScale, 1f, 0.25f).setEase(LeanTweenType.linear).setOnUpdate(Events.InvokeTimeScaleChange);
    }

    public IEnumerator UnFocus()
    {
        yield return Sequences.Wait(0.1f);
        LeanTween.moveLocal(((Component)References.MinibossCameraMover).gameObject, Vector3.zero, durationOut).setEase(LeanTweenType.easeOutBack);
        LeanTween.value(gameObject, ((Graphic)fade).color.a, 0f, 0.25f).setEase(LeanTweenType.easeInOutQuart).setOnUpdate(delegate (float a)
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0021: Unknown result type (might be due to invalid IL or missing references)
            ((Graphic)fade).color = ColorExt.With(((Graphic)fade).color, -1f, -1f, -1f, a);
        });
        yield return Sequences.Wait(durationOut);
        ClearFocus();
        PauseMenu.Unblock();
        DeckpackBlocker.Unblock();
    }
}
public class CinemaBarSystem : GameSystem
{
    public class State
    {
        public readonly bool wasActive;

        public readonly string topScript;

        public readonly string topPrompt;

        public readonly string topPromptAction;

        public readonly string bottomScript;

        public readonly string bottomPrompt;

        public readonly string bottomPromptAction;

        public readonly string sortingLayerName;

        public readonly int sortingOrderInLayer;

        public State()
        {
            wasActive = IsActive();
            topScript = Top.script.text;
            topPrompt = Top.prompt.text;
            topPromptSystem.Action = Top.buttonImage.actionName;
            bottomScript = Bottom.script.text;
            bottomPrompt = Bottom.prompt.text;
            bottomPromptSystem.Action = Bottom.buttonImage.actionName;
            sortingLayerName = instance.canvas.sortingLayerName;
            sortingOrderInLayer = instance.canvas.sortingOrder;
        }

        public void Restore()
        {
            bool flag = IsActive();
            if (flag && !wasActive)
            {
                Out();
            }
            else if (!flag && wasActive)
            {
                In();
            }
            Top.SetScript(topScript);
            Top.SetPrompt(topPrompt, topPromptAction);
            Bottom.SetScript(bottomScript);
            Bottom.SetPrompt(bottomPrompt, bottomPromptAction);
            SetSortingLayer(sortingLayerName, sortingOrderInLayer);
        }
    }

    [Serializable]
    public class Section
    {
        public RectTransform transform;

        public TMP_Text prompt;

        public ControllerButtonImage buttonImage;

        public TMP_Text script;

        public TextTypewrite typewriter;

        public void SetPrompt(string text, string actionName)
        {
            prompt.text = text;
            buttonImage.Set(actionName);
        }

        public void RemovePrompt()
        {
            SetPrompt("", "");
        }

        public void SetScript(string text)
        {
            script.text = text;
        }

        public void RemoveScript()
        {
            SetScript("");
        }

        public void Clear()
        {
            SetPrompt("", "");
            SetScript("");
        }
    }

    public static CinemaBarSystem _instance;

    [SerializeField]
    public Canvas canvas;

    [SerializeField]
    public Section top;

    [SerializeField]
    public Section bottom;

    public static Section Top;

    public static Section Bottom;

    public const float from = -1.5f;

    public const float to = 0.4f;

    public const float inDur = 0.5f;

    public const LeanTweenType inEase = LeanTweenType.easeOutBack;

    public const float outDur = 0.2f;

    public const LeanTweenType outEase = LeanTweenType.easeInQuad;

    public static CinemaBarSystem instance => _instance ?? (_instance = Object.FindObjectOfType<CinemaBarSystem>(true));

    public void Awake()
    {
        Top = top;
        Bottom = bottom;
    }

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnCampaignFinal += new UnityAction(CampaignFinal);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnCampaignFinal -= new UnityAction(CampaignFinal);
    }

    public static void CampaignFinal()
    {
        Clear();
        OutInstant();
    }

    public static void Clear()
    {
        ((MonoBehaviour)instance).StopAllCoroutines();
        Top.Clear();
        Bottom.Clear();
    }

    public static void SetScript(string text, bool typewriterAnimation)
    {
        string text2 = "";
        if (text.Contains("|"))
        {
            int num = text.IndexOf('|');
            text2 = text.Substring(0, num);
            text = text.Substring(num + 1);
        }
        Top.script.text = text2;
        Bottom.script.text = text;
        ((MonoBehaviour)instance).StopAllCoroutines();
        if (typewriterAnimation)
        {
            ((MonoBehaviour)instance).StartCoroutine(Typewrite());
        }
    }

    public static IEnumerator Typewrite()
    {
        if (!StringExt.IsNullOrWhitespace(Top.script.text))
        {
            Bottom.script.maxVisibleCharacters = 0;
            yield return Top.typewriter.Write();
            yield return (object)new WaitForSeconds(1f);
        }
        yield return Bottom.typewriter.Write();
    }

    public static bool IsActive()
    {
        return ((Component)instance).gameObject.activeSelf;
    }

    public static void In()
    {
        GameObject gameObject = ((Component)instance).gameObject;
        gameObject.SetActive(true);
        Clear();
        LeanTween.cancel(gameObject);
        SetPosition(-1.5f);
        LeanTween.value(gameObject, -1.5f, 0.4f, 0.5f).setEase(LeanTweenType.easeOutBack).setOnUpdate(SetPosition);
    }

    public static void InInstant()
    {
        GameObject gameObject = ((Component)instance).gameObject;
        gameObject.SetActive(true);
        Clear();
        LeanTween.cancel(gameObject);
        SetPosition(0.4f);
    }

    public static void Out()
    {
        if (!(instance == null) && !(((Component)instance).gameObject == null) && ((Component)instance).gameObject.activeSelf)
        {
            LeanTween.cancel(((Component)instance).gameObject);
            SetPosition(0.4f);
            LeanTween.value(((Component)instance).gameObject, 0.4f, -1.5f, 0.2f).setEase(LeanTweenType.easeInQuad).setOnUpdate(SetPosition)
                .setOnComplete((Action)delegate
                {
                    ResetSortingLayer();
                    ((Component)instance).gameObject.SetActive(false);
                });
        }
    }

    public static void OutInstant()
    {
        if ((instance) && (((Component)instance).gameObject) && ((Component)instance).gameObject.activeSelf)
        {
            LeanTween.cancel(((Component)instance).gameObject);
            SetPosition(-1.5f);
            ResetSortingLayer();
            ((Component)instance).gameObject.SetActive(false);
        }
    }

    public static void SetSortingLayer(string name, int orderInLayer = 0)
    {
        instance.canvas.sortingLayerName = name;
        instance.canvas.sortingOrder = orderInLayer;
    }

    public static void ResetSortingLayer()
    {
        SetSortingLayer("CinemaBars");
    }

    public static void SetPosition(float value)
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        Top.transform.anchoredPosition = Vector2Ext.WithY(Top.transform.anchoredPosition, 0f - value);
        Bottom.transform.anchoredPosition = Vector2Ext.WithY(Bottom.transform.anchoredPosition, value);
    }
}
public class ClickParticleSystem : GameSystem
{
    [SerializeField]
    public ParticleSystem fxPrefab;

    [SerializeField]
    public Transform group;

    public readonly List<ParticleSystem> pool = new List<ParticleSystem>();

    public void Update()
    {
        if (InputSystem.IsSelectPressed())
        {
            Pop();
        }
    }

    public void Pop()
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        ParticleSystem val = Get();
        ((Component)val).transform.position = Cursor3d.PositionWithZ;
        val.Play(true);
        StartCoroutine(ReturnToPoolWhenFinished(val));
    }

    public IEnumerator ReturnToPoolWhenFinished(ParticleSystem ps)
    {
        while (ps.isPlaying)
        {
            yield return null;
        }
        ((Component)ps).gameObject.SetActive(false);
        pool.Add(ps);
    }

    public ParticleSystem Get()
    {
        if (pool.Count > 0)
        {
            ParticleSystem obj = pool[0];
            pool.RemoveAt(0);
            ((Component)obj).gameObject.SetActive(true);
            return obj;
        }
        return Object.Instantiate<ParticleSystem>(fxPrefab, group);
    }
}
public class CombineCardSystem : GameSystem
{
    [Serializable]
    public struct Combo
    {
        public string[] cardNames;

        public string resultingCardName;

        public bool AllCardsInDeck(CardDataList deck)
        {
            bool result = true;
            string[] array = cardNames;
            foreach (string cardName in array)
            {
                if (!HasCard(cardName, deck))
                {
                    result = false;
                    break;
                }
            }
            return result;
        }

        public bool HasCard(string cardName, CardDataList deck)
        {
            foreach (CardData item in deck)
            {
                if ((item).name == cardName)
                {
                    return true;
                }
            }
            return false;
        }
    }

    [SerializeField]
    public string combineSceneName;

    [SerializeField]
    public Combo[] combos;

    public void OnEnable()
    {
        Events.OnEntityEnterBackpack += EntityEnterBackpack;
    }

    public void OnDisable()
    {
        Events.OnEntityEnterBackpack -= EntityEnterBackpack;
    }

    public void EntityEnterBackpack(Entity entity)
    {
        Combo[] array = combos;
        for (int i = 0; i < array.Length; i++)
        {
            Combo combo = array[i];
            if (IArrayExt.Contains<string>(combo.cardNames, (entity.data).name) && combo.AllCardsInDeck(References.PlayerData.inventory.deck))
            {
                StopAllCoroutines();
                StartCoroutine(CombineSequence(combo));
                break;
            }
        }
    }

    public IEnumerator CombineSequence(Combo combo)
    {
        CombineCardSequence combineSequence = null;
        yield return SceneManager.Load(combineSceneName, SceneType.Temporary, delegate (Scene scene)
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            combineSequence = SceneExt.FindObjectOfType<CombineCardSequence>(scene);
        });
        if ((combineSequence))
        {
            yield return combineSequence.Run(combo.cardNames, combo.resultingCardName);
        }
        yield return SceneManager.Unload(combineSceneName);
    }
}
public class CombineSystem : GameSystem
{
    public static CombineSystem instance;

    [SerializeField]
    public Fader fader;

    [SerializeField]
    public Graphic flash;

    [SerializeField]
    public AnimationCurve flashCurve;

    [SerializeField]
    public AnimationCurve bounceCurve;

    [SerializeField]
    public Transform group;

    [SerializeField]
    public Transform pointPrefab;

    [SerializeField]
    public ParticleSystem ps;

    public readonly List<Transform> points = new List<Transform>();

    public readonly Dictionary<Entity, Transform> originalParents = new Dictionary<Entity, Transform>();

    public void Awake()
    {
        instance = this;
    }

    public IEnumerator Combine(Entity[] entities, Entity finalEntity)
    {
        fader.In();
        Vector3 val = Vector3.zero;
        Entity[] array = entities;
        foreach (Entity entity in array)
        {
            val += entity.transform.position;
        }
        val /= (float)entities.Length;
        group.position = val;
        array = entities;
        foreach (Entity entity2 in array)
        {
            Transform val2 = Object.Instantiate<Transform>(pointPrefab, entity2.transform.position, Quaternion.identity, group);
            ((Component)val2).gameObject.SetActive(true);
            originalParents[entity2] = entity2.transform.parent;
            entity2.transform.SetParent(val2);
            points.Add(val2);
        }
        Vector3 localPosition;
        foreach (Transform point in points)
        {
            localPosition = point.localPosition;
            LeanTween.moveLocal(to: ((localPosition)).normalized * 0.5f, gameObject: ((Component)point).gameObject, time: 0.4f).setEaseInBack();
        }
        yield return (object)new WaitForSeconds(0.4f);
        Flash(0.5f);
        Events.InvokeScreenShake(1f, 0f);
        array = entities;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].wobbler.WobbleRandom();
        }
        foreach (Transform point2 in points)
        {
            localPosition = point2.localPosition;
            LeanTween.moveLocal(to: ((localPosition)).normalized * 3f, gameObject: ((Component)point2).gameObject, time: 1f).setEase(bounceCurve);
        }
        LeanTween.moveLocal(((Component)group).gameObject, new Vector3(0f, 0f, -2f), 1f).setEaseInOutQuad();
        LeanTween.rotateZ(((Component)group).gameObject, PettyRandom.Range(160f, 180f), 1f).setOnUpdateVector3(delegate
        {
            //IL_001a: Unknown result type (might be due to invalid IL or missing references)
            foreach (Transform point3 in points)
            {
                ((Component)point3).transform.eulerAngles = Vector3.zero;
            }
        }).setEaseInOutQuad();
        yield return (object)new WaitForSeconds(1f);
        Flash();
        Events.InvokeScreenShake(1f, 0f);
        if (ps != null)
        {
            ps.Play();
        }
        finalEntity.data = finalEntity.data.Clone(finalEntity.data.random3, finalEntity.data.id, runCreateScripts: false);
        finalEntity.data.forceTitle = finalEntity.data.title;
        Routine.Clump clump = new Routine.Clump();
        array = IArrayExt.Without<Entity>(entities, finalEntity);
        foreach (Entity entity3 in array)
        {
            finalEntity.data.forceTitle += entity3.data.title;
            clump.Add(Combine(entity3, finalEntity));
        }
        yield return clump.WaitForEnd();
        foreach (Entity.TraitStacks item in finalEntity.traits.Where((Entity.TraitStacks a) => (a.data).name == "Build"))
        {
            item.count = 0;
        }
        yield return StatusEffectSystem.BuildEvent(finalEntity);
        yield return finalEntity.UpdateTraits();
        finalEntity.curveAnimator.Ping();
        finalEntity.wobbler.WobbleRandom();
        finalEntity.counter.current = finalEntity.counter.max;
        finalEntity.alive = false;
        yield return finalEntity.display.UpdateData();
        yield return finalEntity.UpdateTraits();
        finalEntity.alive = true;
        yield return StatusEffectSystem.EntityEnableEvent(finalEntity);
        fader.Out();
        yield return (object)new WaitForSeconds(1f);
        foreach (KeyValuePair<Entity, Transform> item2 in originalParents.Where((KeyValuePair<Entity, Transform> pair) => (pair.Key) && (pair.Value)))
        {
            item2.Key.transform.SetParent(item2.Value);
            item2.Key.TweenToContainer();
            item2.Key.wobbler.WobbleRandom();
        }
        originalParents.Clear();
        foreach (Transform item3 in points.Where((Transform p) => (p)))
        {
            Object.Destroy(((Component)item3).gameObject);
        }
        points.Clear();
        ((Component)group).transform.localEulerAngles = Vector3.zero;
    }

    public static IEnumerator Combine(Entity entity, Entity inTo)
    {
        if (!inTo.data.hasAttack)
        {
            inTo.data.hasAttack = entity.data.hasAttack;
        }
        if (!inTo.data.hasHealth)
        {
            inTo.data.hasHealth = entity.data.hasHealth;
        }
        inTo.data.damage += entity.data.damage;
        inTo.data.hp += entity.data.hp;
        inTo.data.counter = Mathf.Max(inTo.data.counter, entity.data.counter);
        inTo.attackEffects = IArrayExt.ToList<CardData.StatusEffectStacks>(CardData.StatusEffectStacks.Stack(inTo.attackEffects, entity.attackEffects));
        List<StatusEffectData> list = IListExt.Clone<StatusEffectData>((IEnumerable<StatusEffectData>)entity.statusEffects);
        foreach (Entity.TraitStacks trait in entity.traits)
        {
            foreach (StatusEffectData passiveEffect in trait.passiveEffects)
            {
                list.Remove(passiveEffect);
            }
            int num = trait.count - trait.tempCount;
            if (num > 0)
            {
                inTo.GainTrait(trait.data, num);
            }
        }
        Events.InvokeScreenShake(1f, 0f);
        Routine.Clump clump = new Routine.Clump();
        foreach (StatusEffectData item in list)
        {
            clump.Add(StatusEffectSystem.Apply(inTo, item.applier, item, item.count));
        }
        yield return clump.WaitForEnd();
        entity.RemoveFromContainers();
        CardManager.ReturnToPool(entity);
    }

    public void Flash(float intensity = 1f, float duration = 0.1f)
    {
        ((Component)flash).gameObject.SetActive(true);
        LeanTween.cancel(((Component)flash).gameObject);
        LeanTween.value(((Component)flash).gameObject, 0f, intensity, duration).setEase(flashCurve).setOnUpdate(delegate (float a)
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0021: Unknown result type (might be due to invalid IL or missing references)
            flash.color = ColorExt.With(flash.color, -1f, -1f, -1f, a);
        })
            .setOnComplete((Action)delegate
            {
                ((Component)flash).gameObject.SetActive(false);
            });
    }
}
public class ControllerButtonSystem : GameSystem
{
    public static ControllerButtonSystem instance;

    public static JoystickButtonStyle style;

    [SerializeField]
    public JoystickButtonStyle defaultControllerStyle;

    [SerializeField]
    public JoystickButtonStyle mouseStyle;

    [SerializeField]
    public JoystickButtonStyle touchStyle;

    [SerializeField]
    public JoystickButtonStyle[] styles;

    public void Awake()
    {
        instance = this;
    }

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnControllerSwitched += new UnityAction(ControllerSwitched);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnControllerSwitched -= new UnityAction(ControllerSwitched);
    }

    public static void ControllerSwitched()
    {
        if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            SetControllerStyle();
        }
    }

    public static void SetMouseStyle()
    {
        style = instance.mouseStyle;
        Events.InvokeButtonStyleChanged();
    }

    public static void SetTouchStyle()
    {
        style = instance.touchStyle;
        Events.InvokeButtonStyleChanged();
    }

    public static void SetControllerStyle()
    {
        Player playerController = RewiredControllerManager.GetPlayerController(0);
        Controller controller = null;
        double num = -1.0;
        foreach (Joystick joystick in playerController.controllers.Joysticks)
        {
            double lastTimeActive = ((Controller)joystick).GetLastTimeActive();
            if (lastTimeActive > num)
            {
                num = lastTimeActive;
                controller = (Controller)(object)joystick;
            }
        }
        if (controller != null)
        {
            style = instance.styles.FirstOrDefault((JoystickButtonStyle a) => a.guids.Contains(controller.hardwareTypeGuid));
            if (style == null)
            {
                style = instance.defaultControllerStyle;
            }
            Debug.LogWarning(("ControllerButtonStyle Set: [" + (style).name + "]"));
            Events.InvokeButtonStyleChanged();
        }
    }

    public static Sprite Get(string action)
    {
        if (StringExt.IsNullOrWhitespace(action))
        {
            return null;
        }
        Player playerController = RewiredControllerManager.GetPlayerController(0);
        return style.GetElement(playerController, action).buttonSprite;
    }

    public static JoystickButtonStyle.ElementButton GetElement(Player player, string actionName)
    {
        return style.GetElement(player, actionName);
    }

    public static string ProcessActionTags(LocalizedString key, bool preferTextActions = true)
    {
        return ProcessActionTags(key.GetLocalizedString(), preferTextActions);
    }

    public static string ProcessActionTags(string text, bool preferTextActions)
    {
        Player playerController = RewiredControllerManager.GetPlayerController(0);
        int num = 0;
        do
        {
            num = text.IndexOf("<action=", num);
            if (num < 0)
            {
                break;
            }
            int num2 = text.IndexOf('>', num) - num + 1;
            string text2 = text.Substring(num + 8, num2 - 9);
            Debug.Log(("Action: " + text2));
            text = text.Remove(num, num2);
            JoystickButtonStyle.ElementButton element = style.GetElement(playerController, text2);
            if (element != null)
            {
                if (((LocalizedReference)element.textKey).IsEmpty || !preferTextActions)
                {
                    string name = (element.buttonSprite).name;
                    Debug.Log(("Button Sprite Index for [" + text2 + "]: " + name));
                    text = text.Insert(num, "<sprite name=" + name + ">");
                }
                else
                {
                    string text3 = element.text;
                    Debug.Log(("Button Key Name for [" + text2 + "]: " + text3));
                    text = text.Insert(num, text3);
                }
            }
            else
            {
                Debug.Log("No element using that action! (or System.Action doesn't exist...)");
            }
        }
        while (num >= 0);
        return text;
    }
}
public class CounterImminentDisplaySystem : GameSystem
{
    [SerializeField]
    public bool disableCardAnimationHover = true;

    [SerializeField]
    public bool disableIconAnimationHover = true;

    public List<Entity> currentImminent = new List<Entity>();

    public List<Entity> currentHover = new List<Entity>();

    public void OnEnable()
    {
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
        Events.OnEntityDisplayUpdated += EntityCheck;
        Events.OnEntityEnabled += EntityCheck;
        Events.OnEntityDisabled += EntityDisabled;
        Events.OnInspect += EntityHover;
        Events.OnInspectEnd += EntityUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
        Events.OnEntityDisplayUpdated -= EntityCheck;
        Events.OnEntityEnabled -= EntityCheck;
        Events.OnEntityDisabled -= EntityDisabled;
        Events.OnInspect -= EntityHover;
        Events.OnInspectEnd -= EntityUnHover;
    }

    public void EntityHover(Entity entity)
    {
        if (!(entity != null))
        {
            return;
        }
        currentHover.Add(entity);
        if (currentImminent.Contains(entity))
        {
            if (disableCardAnimationHover)
            {
                SetCardAnimation(entity, enable: false);
            }
            if (disableIconAnimationHover)
            {
                SetCounterIconAnimation(entity, enable: false);
            }
        }
    }

    public void EntityUnHover(Entity entity)
    {
        if (!(entity != null))
        {
            return;
        }
        currentHover.Remove(entity);
        if (((Behaviour)entity).enabled && currentImminent.Contains(entity))
        {
            if (disableCardAnimationHover)
            {
                SetCardAnimation(entity, enable: true);
            }
            if (disableIconAnimationHover)
            {
                SetCounterIconAnimation(entity, enable: true);
            }
        }
    }

    public void EntityDisabled(Entity entity)
    {
        if (currentImminent.Contains(entity))
        {
            currentImminent.Remove(entity);
            SetCardAnimation(entity, enable: false);
            SetCounterIconAnimation(entity, enable: false);
        }
    }

    public void SetCardAnimation(Entity entity, bool enable)
    {
        if (entity.imminentAnimation != null)
        {
            if (enable)
            {
                entity.imminentAnimation.FadeIn();
            }
            else
            {
                entity.imminentAnimation.FadeOut();
            }
        }
    }

    public void SetCounterIconAnimation(Entity entity, bool enable)
    {
        if (entity.display.counterIcon != null && entity.display.counterIcon is StatusIconCounter { imminentAnimation: var imminentAnimation } && imminentAnimation != null)
        {
            if (enable)
            {
                imminentAnimation.FadeIn();
            }
            else
            {
                imminentAnimation.FadeOut();
            }
        }
    }

    public void EntityCheck(Entity entity)
    {
        if (!((Behaviour)entity).enabled)
        {
            return;
        }
        if (!currentImminent.Contains(entity))
        {
            if (Imminent(entity))
            {
                currentImminent.Add(entity);
                SetCardAnimation(entity, enable: true);
                SetCounterIconAnimation(entity, enable: true);
            }
        }
        else if (!Imminent(entity))
        {
            currentImminent.Remove(entity);
            SetCardAnimation(entity, enable: false);
            SetCounterIconAnimation(entity, enable: false);
        }
    }

    public bool Imminent(Entity entity)
    {
        if (!entity.IsSnowed)
        {
            return entity.counter.current == 1;
        }
        return false;
    }
}
public class DeathSystem : GameSystem
{
    public static readonly Dictionary<ulong, int> treatAsTeam = new Dictionary<ulong, int>();

    public void OnEnable()
    {
        Events.OnEntityKilled += EntityKilled;
        Events.OnEntityCreated += EntityCreated;
    }

    public void OnDisable()
    {
        Events.OnEntityKilled -= EntityKilled;
        Events.OnEntityCreated -= EntityCreated;
    }

    public static void EntityCreated(Entity entity)
    {
        treatAsTeam.Remove(entity.data.id);
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        if ((entity) && entity.display is Card card && ((Component)card).GetComponent<ICardDestroyed>() == null)
        {
            switch (deathType)
            {
                default:
                    Destroy(card);
                    break;
                case DeathType.Sacrifice:
                    Sacrifice(card);
                    break;
                case DeathType.Consume:
                    Consume(card);
                    break;
            }
        }
    }

    public void Destroy(Card card)
    {
        CardDestroyed cardDestroyed = ((Component)card).gameObject.AddComponent<CardDestroyed>();
        cardDestroyed.canvasGroup = card.canvasGroup;
        cardDestroyed.Knockback(card.entity.lastHit);
        card.transform.parent = transform;
    }

    public void Sacrifice(Card card)
    {
        ((Component)card).gameObject.AddComponent<CardDestroyedSacrifice>();
        card.transform.parent = transform;
    }

    public void Consume(Card card)
    {
        ((Component)card).gameObject.AddComponent<CardDestroyedConsume>();
        card.transform.parent = transform;
    }

    public static bool KilledByOwnTeam(Entity entity)
    {
        if (entity.lastHit != null && (entity.lastHit.owner) && entity.lastHit.owner.team == entity.owner.team)
        {
            return entity.lastHit.attacker != entity;
        }
        return false;
    }

    public static void TreatAsTeam(ulong cardDataId, int team)
    {
        treatAsTeam.Add(cardDataId, team);
    }

    public static bool CheckTeamIsAlly(Entity entity, Entity checkAgainst)
    {
        if (treatAsTeam.TryGetValue(entity.data.id, out var value))
        {
            return checkAgainst.owner.team == value;
        }
        return checkAgainst.owner.team == entity.owner.team;
    }
}
public class DiscardDisplaySystem : GameSystem
{
    [SerializeField]
    public Transform display;

    [SerializeField]
    public TweenUI showTween;

    [SerializeField]
    public TweenUI hideTween;

    public Entity entityDrag;

    public CardContainer hoverDiscardContainer;

    public bool draggingCanDiscard;

    public void OnEnable()
    {
        Events.OnEntityDrag += EntityDrag;
        Events.OnEntityRelease += EntityRelease;
        Events.OnContainerHover += ContainerHover;
        Events.OnContainerUnHover += ContainerUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityDrag -= EntityDrag;
        Events.OnEntityRelease -= EntityRelease;
        Events.OnContainerHover -= ContainerHover;
        Events.OnContainerUnHover -= ContainerUnHover;
    }

    public void EntityDrag(Entity entity)
    {
        entityDrag = entity;
        draggingCanDiscard = entity.CanRecall();
    }

    public void EntityRelease(Entity entity)
    {
        if (entityDrag == entity)
        {
            entityDrag = null;
            Hide();
        }
    }

    public void ContainerHover(CardContainer container)
    {
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        if (entityDrag != null && draggingCanDiscard && container != null && entityDrag.owner != null && container == entityDrag.owner.discardContainer)
        {
            hoverDiscardContainer = container;
            display.position = ((Component)container).transform.position;
            Show();
        }
    }

    public void ContainerUnHover(CardContainer container)
    {
        if (hoverDiscardContainer == container)
        {
            hoverDiscardContainer = null;
            Hide();
        }
    }

    public void Show()
    {
        ((Component)display).gameObject.SetActive(true);
        showTween?.Fire();
    }

    public void Hide()
    {
        StartCoroutine(HideRoutine());
    }

    public IEnumerator HideRoutine()
    {
        if (hideTween != null)
        {
            hideTween.Fire();
            yield return Sequences.Wait(hideTween.GetDuration());
        }
        ((Component)display).gameObject.SetActive(false);
    }
}
public class DiscardHealSystem : GameSystem
{
    [SerializeField]
    public int healAmount = 5;

    [SerializeField]
    public LocalizedString healTextKey;

    [SerializeField]
    public Vector3 healPopupOffset = Vector3.up;

    public void OnEnable()
    {
        Events.OnDiscard += Discard;
    }

    public void OnDisable()
    {
        Events.OnDiscard -= Discard;
    }

    public void Discard(Entity entity)
    {
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        ActionDiscardEffect action = new ActionDiscardEffect(entity, healAmount);
        if (Events.CheckAction(action))
        {
            ActionQueue.Add(action);
            if (entity.data.hasHealth)
            {
                Vector3 position = entity.transform.position + healPopupOffset;
                string text = "<size=0.5>" + string.Format(healTextKey.GetLocalizedString(), healAmount);
                FloatingText.Create(position).SetText(text).SetSortingLayer("PopUp", 10)
                    .Animate("Spring")
                    .Fade("Smooth");
            }
        }
    }
}
public class DropGoldSystem : GameSystem
{
    [SerializeField]
    public float goldFactor = 0.02f;

    [SerializeField]
    public int goldPerUpgrade = 5;

    [SerializeField]
    public bool dropGoldOnFlee = true;

    public void OnEnable()
    {
        Events.OnEntityKilled += EntityKilled;
        Events.OnEntityFlee += EntityFlee;
    }

    public void OnDisable()
    {
        Events.OnEntityKilled -= EntityKilled;
        Events.OnEntityFlee -= EntityFlee;
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        if (deathType == DeathType.Normal)
        {
            TryDropGold(entity, "Kill");
        }
    }

    public void EntityFlee(Entity entity)
    {
        if (dropGoldOnFlee)
        {
            TryDropGold(entity, "Flee");
        }
    }

    public void TryDropGold(Entity entity, string source)
    {
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        if (!(entity.owner) || entity.owner.team != References.Player.team)
        {
            int goldToDrop = GetGoldToDrop(entity);
            if (goldToDrop > 0)
            {
                Events.InvokeDropGold(goldToDrop, source, References.Player, entity.transform.position);
            }
        }
    }

    public int GetGoldToDrop(Entity entity)
    {
        int num = Mathf.RoundToInt((float)entity.data.value * goldFactor * References.PlayerData.enemyGoldFactor);
        int num2 = ((num > 0) ? Mathf.Max(0, num + Mathf.RoundToInt(entity.data.random3.z)) : 0);
        if (entity.data.upgrades != null)
        {
            num2 += entity.data.upgrades.Count * goldPerUpgrade;
        }
        return num2;
    }
}
public class ErrorHandlerSystem : GameSystem
{
    [SerializeField]
    public bool displayErrors = true;

    [SerializeField]
    [ShowIf("displayErrors")]
    public GameObject errorDisplay;

    [SerializeField]
    [ShowIf("displayErrors")]
    public TMP_InputField errorText;

    [SerializeField]
    [ShowIf("displayErrors")]
    public bool freezeTimeScale = true;

    [SerializeField]
    [ShowIf("displayErrors")]
    public EventReference sfxEvent;

    [SerializeField]
    public bool showPersistentMessage = true;

    [SerializeField]
    [ShowIf("showPersistentMessage")]
    public GameObject persistentMessage;

    public const string format = "\n\n[{0}] {1}\n{2}";

    public float timeScalePre = 1f;

    public static int errorCount;

    public static string path => Application.persistentDataPath + "/Errors.log";

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Application.logMessageReceived += new LogCallback(HandleLog);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Application.logMessageReceived -= new LogCallback(HandleLog);
    }

    public void HandleLog(string log, string stacktrace, LogType type)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Invalid comparison between Unknown and I4
        if ((int)type == 4)
        {
            errorCount++;
            using (StreamWriter streamWriter = new StreamWriter(path, append: true))
            {
                streamWriter.WriteLine("\n\n[{0}] {1}\n{2}", DateTime.Now, log, stacktrace);
            }
            if (displayErrors)
            {
                ShowError(log + "\n" + stacktrace);
            }
            else if (showPersistentMessage)
            {
                ShowPersistentMessage();
            }
        }
    }

    public void ShowError(string text)
    {
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        errorDisplay.SetActive(true);
        errorText.text = text;
        if (freezeTimeScale)
        {
            timeScalePre = Time.timeScale;
            Time.timeScale = 0f;
        }
        SfxSystem.OneShot(sfxEvent.Guid);
    }

    public void HideError()
    {
        errorDisplay.SetActive(false);
        Time.timeScale = timeScalePre;
        if (showPersistentMessage && errorCount > 0)
        {
            ShowPersistentMessage();
        }
    }

    public void ExitGame()
    {
        GameManager.Quit();
    }

    public void ShowPersistentMessage()
    {
        persistentMessage.SetActive(true);
    }

    public void HidePersistentMessage()
    {
        persistentMessage.SetActive(false);
    }
}
public class FinalBossDeckGenerationSystem : GameSystem
{
    public void OnEnable()
    {
        Events.OnCampaignEnd += CampaignEnd;
    }

    public void OnDisable()
    {
        Events.OnCampaignEnd -= CampaignEnd;
    }

    public static void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
    {
        if (Campaign.Data.GameMode.mainGameMode)
        {
            if (CheckTrueWin(result))
            {
                RevertToDefaultBoss();
            }
            else if (CheckResult(result))
            {
                SetNewBoss(playerData);
            }
        }
    }

    public static bool CheckResult(Campaign.Result result)
    {
        bool flag = SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "trueWin", defaultValue: false);
        if (result != Campaign.Result.Win || flag)
        {
            return result != Campaign.Result.Win && flag;
        }
        return true;
    }

    public static bool CheckTrueWin(Campaign.Result result)
    {
        bool flag = SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "trueWin", defaultValue: false);
        return result == Campaign.Result.Win && flag;
    }

    public static void SetNewBoss(PlayerData playerData)
    {
        SaveSystem.SaveProgressData("finalBossDeck", playerData.inventory.deck.SaveArray<CardData, CardSaveData>());
        SaveSystem.SaveProgressData("newFinalBoss", value: true);
        Debug.Log(("~ Player's Deck Saved! [" + string.Join(", ", playerData.inventory.deck.Select((CardData a) => (a).name)) + "]"));
    }

    public static void RevertToDefaultBoss()
    {
        SaveSystem.DeleteProgressData("finalBossDeck");
        SaveSystem.DeleteProgressData("newFinalBoss");
        Debug.Log("~ TRUE VICTORY! Reverting Final Boss To Default");
    }
}
public class FinalBossSequenceSystem : GameSystem
{
    [SerializeField]
    public WispAnimator wispPrefab;

    [SerializeField]
    public Canvas canvas;

    [SerializeField]
    public Image background;

    [SerializeField]
    public ParticleSystem blipFX;

    [SerializeField]
    public ParticleSystem bigBlipFX;

    [SerializeField]
    public AnimationCurve hitMoveCurve;

    [SerializeField]
    public AnimationCurve hitRotateCurve;

    [SerializeField]
    public string sealCard = "LuminVase";

    [SerializeField]
    public Color possessFlashColor;

    [FormerlySerializedAs("flashColor")]
    [SerializeField]
    public Color luminFlashColor;

    [SerializeField]
    public LocalizedString continueKey;

    [SerializeField]
    public LocalizedString throwKey;

    [Header("SFX")]
    [SerializeField]
    public EventReference shadeSpawnSfxEvent;

    [SerializeField]
    public EventReference shadeFleeSfxEvent;

    [SerializeField]
    public EventReference shadeMoveSfxEvent;

    [SerializeField]
    public EventReference shadeFlashSfxEvent;

    [SerializeField]
    public EventReference cameraInSfxEvent;

    [SerializeField]
    public EventReference cameraOutHeroSfxEvent;

    [SerializeField]
    public EventReference cameraOutVaseSfxEvent;

    [SerializeField]
    public EventReference shakeHeroSfxEvent;

    [SerializeField]
    public EventReference shakeVaseSfxEvent;

    [SerializeField]
    public EventReference vaseSpawnSfxEvent;

    [SerializeField]
    public EventReference hitHeroSfxEvent;

    [SerializeField]
    public EventReference hitVaseSfxEvent;

    [SerializeField]
    public EventReference pingHeroSfxEvent;

    [SerializeField]
    public EventReference pingVaseSfxEvent;

    [SerializeField]
    public SfxLoop darkLoop;

    [SerializeField]
    public SfxLoop brightLoop;

    [SerializeField]
    public SfxLoop shadeLoop;

    public WispAnimator wisp;

    public bool running;

    public bool blockWisp;

    public Entity leader;

    public Entity blockCard;

    public CampaignNode playerNode;

    public void OnEnable()
    {
        Events.OnEntityKilled += EntityKilled;
        Events.PreBattleEnd += PreBattleEnd;
        playerNode = Campaign.FindCharacterNode(References.Player);
        if (!playerNode.finalNode || !Campaign.Data.GameMode.mainGameMode)
        {
            Object.Destroy(this);
        }
    }

    public void OnDisable()
    {
        Events.OnEntityKilled -= EntityKilled;
        Events.PreBattleEnd -= PreBattleEnd;
    }

    public void EntityKilled(Entity entity, DeathType type)
    {
        //IL_008b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ab: Unknown result type (might be due to invalid IL or missing references)
        //IL_011f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0124: Unknown result type (might be due to invalid IL or missing references)
        if ((References.Battle) && entity.data.cardType.miniboss && entity.owner.team == References.Battle.enemy.team && References.Battle.minibosses.Count((Entity a) => a != entity && a.owner.team == References.Battle.enemy.team) <= 0)
        {
            wisp = Object.Instantiate<WispAnimator>(wispPrefab, entity.transform.position, Quaternion.identity, transform);
            wisp.KnockBackFrom(Vector3.zero);
            leader = Battle.GetCards(References.Battle.player).FirstOrDefault((Entity a) => a.data.cardType.miniboss);
            if ((leader) && leader.IsAliveAndExists())
            {
                wisp.SetTarget(leader.transform);
            }
            SfxSystem.OneShot(shadeSpawnSfxEvent);
            shadeLoop.Play();
        }
    }

    public async Task PreBattleEnd()
    {
        if (!(wisp))
        {
            return;
        }
        if (!wisp.TargetExists())
        {
            wisp.maxSpeed = 0f;
            wisp.gravitate *= 0.5f;
            return;
        }
        if (!playerNode.finalNode)
        {
            StartCoroutine(Flee());
        }
        else
        {
            StartCoroutine(PossessLeader());
        }
        while (running)
        {
            await Task.Delay(25);
        }
    }

    public IEnumerator PossessLeader()
    {
        if (!leader.IsAliveAndExists())
        {
            yield break;
        }
        PauseMenu.Block();
        running = true;
        CardData blockCardData = GetBlockCard();
        blockWisp = (blockCardData);
        if (!blockWisp)
        {
            References.LeaderData.SetCustomData("eyes", "frost");
        }
        wisp.maxSpeed = 0f;
        wisp.gravitate *= 0.5f;
        yield return (object)new WaitForSeconds(1f);
        AmbienceSystem.SetParam("shade_visit", 1f);
        SfxSystem.OneShot(cameraInSfxEvent);
        if (blockWisp)
        {
            brightLoop.Play();
        }
        else
        {
            darkLoop.Play();
        }
        CinemaBarSystem.In();
        CinemaBarSystem.SetSortingLayer("Inspect", 1);
        ((Component)canvas).gameObject.SetActive(true);
        leader.transform.SetParent(((Component)canvas).transform);
        Vector2 val = default(Vector2);
        ((val))..ctor(1.5f, 2f);
        LeanTween.move(((Component)leader).gameObject, new Vector3(-3f, 0.25f, -3f), Vector2Ext.Random(val)).setEase(LeanTweenType.easeInOutQuart);
        LeanTween.move(((Component)wisp).gameObject, new Vector3(3f, 0.25f, -3f), Vector2Ext.Random(val)).setEase(LeanTweenType.easeInOutQuart);
        wisp.SetSortingLayer("Inspect", 1);
        yield return (object)new WaitForSeconds(val.y);
        if (blockWisp)
        {
            yield return BlockWisp(blockCardData);
        }
        SfxSystem.OneShot(shadeMoveSfxEvent);
        SfxSystem.OneShot(shadeFlashSfxEvent);
        wisp.JumpToTarget();
        wisp.FadeToColour(new Color(0.6f, 0.2f, 1f), 0.5f, 0.4f);
        Events.InvokeScreenRumble(1f, 0f, 0f, 0.1f, 0.9f, 0.001f);
        yield return (object)new WaitForSeconds(1f);
        Events.InvokeScreenShake(1f, 0f);
        GameObjectExt.Destroy(((Component)wisp).gameObject);
        ((Component)blipFX).transform.position = wisp.transform.position;
        blipFX.Play();
        shadeLoop.Stop();
        Entity hitCard = leader;
        if (blockWisp)
        {
            SfxSystem.OneShot(hitVaseSfxEvent);
            hitCard = blockCard;
            ReturnLeader();
        }
        else
        {
            SfxSystem.OneShot(hitHeroSfxEvent);
        }
        LeanTween.value(gameObject, Time.timeScale, 0.1f, 0.05f).setEase(LeanTweenType.linear).setOnUpdate(Events.InvokeTimeScaleChange);
        ScreenFlashSystem.SetDrawOrder("ParticlesFront", 999);
        if (blockWisp)
        {
            ScreenFlashSystem.SetColour(luminFlashColor);
            ScreenFlashSystem.Run(0.25f);
        }
        else
        {
            ScreenFlashSystem.SetColour(possessFlashColor);
            ScreenFlashSystem.SetMaterialAdditive();
            ScreenFlashSystem.Run(0.15f);
        }
        hitCard.wobbler.WobbleRandom();
        hitCard.curveAnimator.Move(new Vector3(-2f, 0f, 0f), hitMoveCurve, 0f, 1f);
        hitCard.curveAnimator.Rotate(new Vector3(0f, 0f, 10f), hitRotateCurve, 1f);
        yield return (object)new WaitForSeconds(0.25f);
        LeanTween.value(gameObject, Time.timeScale, 1f, 0.25f).setEase(LeanTweenType.linear).setOnUpdate(Events.InvokeTimeScaleChange);
        yield return (object)new WaitForSeconds(0.25f);
        SfxSystem.OneShot(blockWisp ? shakeVaseSfxEvent : shakeHeroSfxEvent);
        ZoomInOn(((Component)hitCard).gameObject);
        Events.InvokeScreenRumble(0f, 1f, 0.4f, 0.3f, 0.2f, 0.1f);
        if (blockWisp)
        {
            LeanTween.value(1f, 0.9f, 1f).setEaseInOutQuart().setOnUpdate(delegate (float a)
            {
                //IL_000c: Unknown result type (might be due to invalid IL or missing references)
                //IL_0012: Unknown result type (might be due to invalid IL or missing references)
                ((Graphic)background).color = ColorExt.WithAlpha(((Graphic)background).color, a);
            });
        }
        yield return (object)new WaitForSeconds(1.1f);
        brightLoop.Stop();
        darkLoop.Stop();
        SfxSystem.OneShot(blockWisp ? pingVaseSfxEvent : pingHeroSfxEvent);
        Ping(hitCard);
        if (!blockWisp)
        {
            FrostEyeSystem.Create(leader);
        }
        CinemaBarSystem.Top.SetPrompt(continueKey.GetLocalizedString(), "Select");
        yield return (object)new WaitUntil((Func<bool>)InputSystem.IsSelectPressed);
        AmbienceSystem.SetParam("shade_visit", 0f);
        ((Component)canvas).gameObject.SetActive(false);
        if (blockWisp)
        {
            CardManager.ReturnToPool(blockCard);
            SfxSystem.OneShot(cameraOutVaseSfxEvent);
        }
        else
        {
            ReturnLeader();
            SfxSystem.OneShot(cameraOutHeroSfxEvent);
        }
        CinemaBarSystem.Out();
        CinemaBarSystem.SetSortingLayer("CinemaBars");
        running = false;
        PauseMenu.Unblock();
    }

    public CardData GetBlockCard()
    {
        return References.PlayerData.inventory.deck.FirstOrDefault((CardData a) => (a).name == sealCard);
    }

    public IEnumerator BlockWisp(CardData blockCardData)
    {
        blockCard = CardManager.Get(blockCardData, leader.display.hover.controller, leader.owner, inPlay: true, isPlayerCard: true).entity;
        yield return blockCard.display.UpdateData();
        SfxSystem.OneShot(vaseSpawnSfxEvent);
        LeanTween.value(gameObject, Time.timeScale, 0.1f, 0.25f).setEase(LeanTweenType.linear).setOnUpdate(Events.InvokeTimeScaleChange);
        blockCard.transform.localScale = leader.transform.localScale;
        blockCard.transform.SetParent(((Component)canvas).transform);
        blockCard.transform.SetPositionAndRotation(new Vector3(0f, -5f, -2f), Quaternion.identity);
        LeanTween.move(((Component)blockCard).gameObject, Vector3Ext.WithY(blockCard.transform.position, -3f), 0.5f).setIgnoreTimeScale(useUnScaledTime: true).setEaseOutBack();
        blockCard.DrawOrder = 2;
        CinemaBarSystem.Top.SetPrompt(StringExt.Format(throwKey.GetLocalizedString(), new object[1] { blockCardData.title }), "Select");
        yield return (object)new WaitUntil((Func<bool>)InputSystem.IsSelectPressed);
        CinemaBarSystem.Top.RemovePrompt();
        LeanTween.move(((Component)blockCard).gameObject, Vector3Ext.WithX(leader.transform.position, -2.5f), 1f).setEaseOutQuint();
        LeanTween.move(((Component)leader).gameObject, Vector3Ext.WithX(leader.transform.position, -5f), 0.75f).setEaseOutQuint();
        LeanTween.value(gameObject, Time.timeScale, 1f, 0.15f).setEase(LeanTweenType.linear).setOnUpdate(Events.InvokeTimeScaleChange);
    }

    public IEnumerator Flee()
    {
        SfxSystem.OneShot(shadeFleeSfxEvent);
        shadeLoop.Stop();
        running = true;
        wisp.SetTarget(((Component)References.Battle.enemy.reserveContainer).transform);
        wisp.JumpToTarget();
        yield return (object)new WaitForSeconds(1f);
        running = false;
    }

    public static void ZoomInOn(GameObject target, float zPos = -2f)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(target);
        LeanTween.moveLocal(target, Vector3Ext.WithZ(Vector3.zero, zPos), 0.5f).setEase(LeanTweenType.easeInOutQuad);
        LeanTween.rotateLocal(target, Vector3.zero, 0.5f).setEase(LeanTweenType.easeInOutQuad);
    }

    public void Ping(Entity entity)
    {
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        entity.curveAnimator.Ping();
        entity.wobbler.WobbleRandom(2f);
        Events.InvokeScreenShake(2f, 0f);
        ((Component)bigBlipFX).transform.position = entity.transform.position;
        bigBlipFX.Play();
    }

    public void ReturnLeader()
    {
        leader.transform.SetParent((Transform)(object)leader.actualContainers[0].holder);
        leader.TweenToContainer();
        leader.wobbler.WobbleRandom();
    }
}
public class FontSetterSystem : GameSystem
{
    [Serializable]
    public struct LocaleFont
    {
        public string localeCode;

        public AssetReferenceT<TMP_FontAsset> fontRef;
    }

    [SerializeField]
    public AssetReferenceT<TMP_FontAsset> defaultFontRef;

    [SerializeField]
    public LocaleFont[] localeFonts;

    public static AssetReferenceT<TMP_FontAsset> defaultRef;

    public static AssetReferenceT<TMP_FontAsset> currentRef;

    public static TMP_FontAsset current;

    public static Dictionary<string, AssetReferenceT<TMP_FontAsset>> lookup;

    public static readonly List<FontSetter> fontSetters = new List<FontSetter>();

    public void Awake()
    {
        lookup = new Dictionary<string, AssetReferenceT<TMP_FontAsset>>();
        LocaleFont[] array = localeFonts;
        for (int i = 0; i < array.Length; i++)
        {
            LocaleFont localeFont = array[i];
            lookup[localeFont.localeCode] = localeFont.fontRef;
        }
        defaultRef = defaultFontRef;
        LocaleChanged(LocalizationSettings.SelectedLocale);
    }

    public void OnEnable()
    {
        LocalizationSettings.Instance.OnSelectedLocaleChanged += LocaleChanged;
    }

    public void OnDisable()
    {
        LocalizationSettings.Instance.OnSelectedLocaleChanged -= LocaleChanged;
    }

    public static void Register(FontSetter fontSetter)
    {
        fontSetters.Add(fontSetter);
        if (current != null)
        {
            fontSetter.SetFont(current);
        }
    }

    public static void Unregister(FontSetter fontSetter)
    {
        fontSetters.Remove(fontSetter);
    }

    public static void LocaleChanged(Locale locale)
    {
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        if (current != null)
        {
            ((AssetReference)currentRef).ReleaseAsset();
        }
        Dictionary<string, AssetReferenceT<TMP_FontAsset>> dictionary = lookup;
        LocaleIdentifier identifier = locale.Identifier;
        AssetReferenceT<TMP_FontAsset> obj;
        if (!dictionary.ContainsKey(((identifier)).Code))
        {
            obj = defaultRef;
        }
        else
        {
            Dictionary<string, AssetReferenceT<TMP_FontAsset>> dictionary2 = lookup;
            identifier = locale.Identifier;
            obj = dictionary2[((identifier)).Code];
        }
        currentRef = obj;
        current = currentRef.LoadAssetAsync().WaitForCompletion();
        UpdateFontSetters();
    }

    public static void UpdateFontSetters()
    {
        foreach (FontSetter fontSetter in fontSetters)
        {
            fontSetter.SetFont(current);
        }
    }
}
public class FrostEyeSystem : GameSystem
{
    [SerializeField]
    public AssetReference frostEyePrefab;

    public static AssetReference frostEyePrefabRef;

    public static readonly List<Entity> toProcess = new List<Entity>();

    public static readonly Dictionary<Card, List<GameObject>> toRemove = new Dictionary<Card, List<GameObject>>();

    public void OnEnable()
    {
        frostEyePrefabRef = frostEyePrefab;
        Events.OnEntityCreated += EntityCreated;
        Events.OnEntityDataUpdated += EntityDataUpdated;
        Events.OnCardPooled += CardPooled;
    }

    public void OnDisable()
    {
        Events.OnEntityCreated -= EntityCreated;
        Events.OnEntityDataUpdated -= EntityDataUpdated;
        Events.OnCardPooled -= CardPooled;
    }

    public static void EntityCreated(Entity entity)
    {
        Dictionary<string, object> customData = entity.data.customData;
        if (((customData != null) ? DictionaryExt.GetValueOrDefault<string, object>(customData, "eyes", null) : null) is string text && text == "frost")
        {
            toProcess.Add(entity);
        }
    }

    public static void EntityDataUpdated(Entity entity)
    {
        if (toProcess.Contains(entity))
        {
            toProcess.Remove(entity);
            Create(entity);
        }
    }

    public static void Create(Entity entity)
    {
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_0085: Unknown result type (might be due to invalid IL or missing references)
        //IL_0133: Unknown result type (might be due to invalid IL or missing references)
        //IL_0138: Unknown result type (might be due to invalid IL or missing references)
        //IL_014c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0151: Unknown result type (might be due to invalid IL or missing references)
        //IL_0167: Unknown result type (might be due to invalid IL or missing references)
        //IL_0175: Unknown result type (might be due to invalid IL or missing references)
        //IL_017f: Unknown result type (might be due to invalid IL or missing references)
        if (!(entity.display is Card card))
        {
            return;
        }
        Transform parent = ((Component)card.mainImage).transform.parent;
        AvatarEyePositions componentInChildren = ((Component)parent).GetComponentInChildren<AvatarEyePositions>();
        if (componentInChildren != null)
        {
            Transform transform = ((Component)componentInChildren).transform;
            AvatarEyePositions.Eye[] eyes = componentInChildren.eyes;
            foreach (AvatarEyePositions.Eye eye in eyes)
            {
                Transform transform2 = frostEyePrefabRef.InstantiateAsync(transform, false).WaitForCompletion().transform;
                transform2.localPosition = eye.pos;
                transform2.localScale = eye.scale;
            }
            return;
        }
        EyeData eyeData = AddressableLoader.GetGroup<EyeData>("EyeData").FirstOrDefault((EyeData a) => a.cardData == (entity.data).name);
        if (!(eyeData))
        {
            return;
        }
        Transform val = ((IEnumerable)parent).Cast<Transform>().FirstOrDefault((Func<Transform, bool>)((Transform a) => ((Component)a).gameObject.activeSelf));
        if ((val))
        {
            toRemove.Add(card, new List<GameObject>());
            EyeData.Eye[] eyes2 = eyeData.eyes;
            for (int i = 0; i < eyes2.Length; i++)
            {
                EyeData.Eye eye2 = eyes2[i];
                Transform transform3 = frostEyePrefabRef.InstantiateAsync(val, false).WaitForCompletion().transform;
                transform3.SetLocalPositionAndRotation((eye2.position), Quaternion.Euler(0f, 0f, eye2.rotation));
                transform3.localScale = Vector2Ext.WithZ(eye2.scale, 1f);
                toRemove[card].Add(((Component)transform3).gameObject);
            }
        }
    }

    public static void CardPooled(Card card)
    {
        if (!toRemove.ContainsKey(card))
        {
            return;
        }
        Debug.Log($"Destroying [{toRemove[card].Count}] Frosteye objects from [{(card).name}]");
        foreach (GameObject item in toRemove[card])
        {
            Object.Destroy(item);
        }
        toRemove.Remove(card);
    }
}
public class FrostoscopeMapSystem : GameSystem
{
    [SerializeField]
    public UnlockData requiresUnlock;

    [SerializeField]
    public string[] visibleDuringScenes = new string[2] { "MapNew", "Event" };

    [SerializeField]
    public GameObject button;

    public void OnEnable()
    {
        Events.OnSceneChanged += SceneChanged;
        CheckIfUnlocked();
    }

    public void OnDisable()
    {
        Events.OnSceneChanged -= SceneChanged;
    }

    public void SceneChanged(Scene scene)
    {
        bool active = IArrayExt.Contains<string>(visibleDuringScenes, ((scene)).name);
        button.SetActive(active);
    }

    public void CheckIfUnlocked()
    {
        if (!MetaprogressionSystem.IsUnlocked(requiresUnlock))
        {
            gameObject.SetActive(false);
        }
    }
}
public abstract class GameSystem : MonoBehaviour
{
    public void Enable()
    {
        enabled = true;
    }

    public void Disable()
    {
        enabled = false;
    }

    public GameSystem()
    {
    }
}
public class HelpPanelSystem : GameSystem
{
    [Serializable]
    public struct ButtonProfile
    {
        [SerializeField]
        public ButtonType type;

        [SerializeField]
        public GameObject prefab;
    }

    public enum ButtonType
    {
        Positive,
        Negative
    }



    public static HelpPanelSystem _instance;

    public static GameObject _rtCamera;

    [SerializeField]
    public TMP_Text title;

    [SerializeField]
    public TMP_Text body;

    [SerializeField]
    public TMP_Text note;

    [SerializeField]
    public ImageSprite image;

    [SerializeField]
    public LayoutElement imageLayout;

    [Header("Button Options")]
    [SerializeField]
    public Transform buttonGroup;

    [SerializeField]
    public GameObject backButton;

    [SerializeField]
    public ButtonProfile[] buttonPrefabs;

    public static readonly Dictionary<ButtonType, ButtonProfile> buttonProfileLookup = new Dictionary<ButtonType, ButtonProfile>();

    [Header("Emotes")]
    [SerializeField]
    public Image emote;

    [SerializeField]
    public Prompt.Emote[] emoteTypes;

    [Header("SFX")]
    [SerializeField]
    public EventReference popUpSfx;

    public static bool Active;

    public static HelpPanelSystem instance => _instance ?? (_instance = Object.FindObjectOfType<HelpPanelSystem>(true));

    public static GameObject rtCamera => _rtCamera ?? (_rtCamera = ((Component)Object.FindObjectsOfType<Camera>(true).First((Camera a) => (a).name == "RenderTextureCamera")).gameObject);

    public void Awake()
    {
        buttonProfileLookup.Clear();
        ButtonProfile[] array = buttonPrefabs;
        for (int i = 0; i < array.Length; i++)
        {
            ButtonProfile value = array[i];
            buttonProfileLookup[value.type] = value;
        }
    }

    public void OnEnable()
    {
        Active = true;
        rtCamera.SetActive(true);
    }

    public void OnDisable()
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        Active = false;
        rtCamera.SetActive(false);
        foreach (Transform item in buttonGroup)
        {
            GameObjectExt.Destroy(((Component)item).gameObject);
        }
        ((Component)imageLayout).gameObject.SetActive(false);
    }

    public static void SetBackButtonActive(bool active)
    {
        instance.backButton.SetActive(active);
    }

    public static void Show(LocalizedString key)
    {
        //IL_00bc: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c1: Unknown result type (might be due to invalid IL or missing references)
        string[] array = key.GetLocalizedString().Split('|');
        ((Component)instance.title).gameObject.SetActive(array.Length != 0);
        ((Component)instance.body).gameObject.SetActive(array.Length > 1);
        ((Component)instance.note).gameObject.SetActive(array.Length > 2);
        instance.title.text = ((array.Length != 0) ? array[0] : "");
        instance.body.text = ((array.Length > 1) ? array[1] : "");
        instance.note.text = ((array.Length > 2) ? array[2] : "");
        SfxSystem.OneShot(instance.popUpSfx);
        ((Component)instance).gameObject.SetActive(true);
    }

    public static void SetEmote(Prompt.Emote.Type emoteType)
    {
        Prompt.Emote emote = instance.emoteTypes.FirstOrDefault((Prompt.Emote a) => a.type == emoteType);
        instance.emote.sprite = emote.sprite;
    }

    public static void AddButton(
        HelpPanelSystem.ButtonType type,
        LocalizedString textKey,
        string hotKey,
        UnityAction onSelect)
    {
        HelpPanelSystem.ButtonProfile buttonProfile;
        if (!HelpPanelSystem.buttonProfileLookup.TryGetValue(type, out buttonProfile))
            return;
        GameObject gameObject = UnityEngine.Object.Instantiate<GameObject>(buttonProfile.prefab, HelpPanelSystem.instance.buttonGroup);
        gameObject.GetComponent<RewiredHotKeyController>()?.SetActionName(hotKey);
        Button componentInChildren = gameObject.GetComponentInChildren<Button>();
        if (onSelect != null)
            componentInChildren.onClick.AddListener(onSelect);
        componentInChildren.onClick.AddListener((UnityAction)(() => HelpPanelSystem.instance.gameObject.SetActive(false)));
        gameObject.GetComponentInChildren<LocalizeStringEvent>().StringReference = textKey;
    }

    public static void SetImage(float width, float height, Sprite sprite)
    {
        ((Component)instance.imageLayout).gameObject.SetActive(true);
        instance.image.SetSprite(sprite);
        instance.imageLayout.preferredWidth = width;
        instance.imageLayout.preferredHeight = height;
    }
}
public class HitAnimationSystem : GameSystem
{
    [SerializeField]
    public AnimationCurve hitCurve;

    [SerializeField]
    public float strength = 0.65f;

    [SerializeField]
    public AnimationCurve strengthCurve;

    [SerializeField]
    public float duration = 0.667f;

    [SerializeField]
    public AnimationCurve durationCurve;

    [SerializeField]
    public float wobble = 2f;

    [SerializeField]
    public AnimationCurve wobbleCurve;

    public void OnEnable()
    {
        Events.OnEntityHit += EntityHit;
        Events.OnEntityDodge += EntityDodge;
    }

    public void OnDisable()
    {
        Events.OnEntityHit -= EntityHit;
        Events.OnEntityDodge -= EntityDodge;
    }

    public void EntityDodge(Hit hit)
    {
        if (hit.Offensive && hit.doAnimation)
        {
            Entity target = hit.target;
            if (target != null && target.display is Card)
            {
                CardTakeHit(hit);
            }
        }
    }

    public void EntityHit(Hit hit)
    {
        if (hit.Offensive && hit.doAnimation && hit.countsAsHit)
        {
            Entity target = hit.target;
            if (target != null && target.display is Card)
            {
                CardTakeHit(hit);
            }
        }
    }

    public void CardTakeHit(Hit hit)
    {
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_007d: Unknown result type (might be due to invalid IL or missing references)
        //IL_008a: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0091: Unknown result type (might be due to invalid IL or missing references)
        //IL_0096: Unknown result type (might be due to invalid IL or missing references)
        //IL_0099: Unknown result type (might be due to invalid IL or missing references)
        //IL_009c: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00dd: Unknown result type (might be due to invalid IL or missing references)
        CurveAnimator curveAnimator = hit.target.curveAnimator;
        if (curveAnimator != null)
        {
            int offensiveness = hit.GetOffensiveness();
            float num = strength * strengthCurve.Evaluate((float)offensiveness);
            float num2 = duration * durationCurve.Evaluate((float)offensiveness);
            float num3 = wobble * wobbleCurve.Evaluate((float)offensiveness);
            Vector3 attackerPos = ((hit.attacker) ? hit.attacker.transform.position : Vector3.zero);
            Vector3 hitDirection = GetHitDirection(hit.target.transform.position, attackerPos);
            curveAnimator.Move(hitDirection * num, hitCurve, 0f, num2);
            if (num3 > 0f && (hit.target.wobbler))
            {
                hit.target.wobbler.Wobble(hitDirection * num3);
            }
        }
    }

    public static Vector3 GetHitDirection(Vector3 targetPos, Vector3 attackerPos)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = targetPos - attackerPos;
        return ((val)).normalized;
    }
}
public class HitFlashSystem : GameSystem
{
    public class HitFlash
    {
        public Material material;

        public float time;

        public Dictionary<Image, Material> imageDict = new Dictionary<Image, Material>();

        public List<TMP_Text> textElements = new List<TMP_Text>();

        public Entity target { get; set; }

        public bool ended => time <= 0f;

        public HitFlash(Entity entity, Material material, float duration)
        {
            target = entity;
            this.material = material;
            time = duration;
            Start();
        }

        public void Start()
        {
            Image[] componentsInChildren = ((Component)target).GetComponentsInChildren<Image>(true);
            TMP_Text[] componentsInChildren2 = ((Component)target).GetComponentsInChildren<TMP_Text>(true);
            Image[] array = componentsInChildren;
            foreach (Image val in array)
            {
                if (((Behaviour)val).enabled && val.sprite != null && ((Component)val).gameObject.GetComponent<Mask>() == null)
                {
                    imageDict.Add(val, ((Graphic)val).material);
                    ((Graphic)val).material = material;
                }
            }
            TMP_Text[] array2 = componentsInChildren2;
            foreach (TMP_Text val2 in array2)
            {
                if (((Behaviour)val2).enabled)
                {
                    textElements.Add(val2);
                    ((Behaviour)val2).enabled = false;
                }
            }
        }

        public void Update(float delta)
        {
            time -= delta;
            if (time <= 0f)
            {
                End();
            }
        }

        public void End()
        {
            foreach (KeyValuePair<Image, Material> item in imageDict)
            {
                if (item.Key != null)
                {
                    ((Graphic)item.Key).material = item.Value;
                }
            }
            foreach (TMP_Text textElement in textElements)
            {
                if (textElement != null)
                {
                    ((Behaviour)textElement).enabled = true;
                }
            }
        }
    }

    public static HitFlashSystem instance;

    [SerializeField]
    public float flashDuration = 0.1f;

    [SerializeField]
    public Material damageMaterial;

    public readonly List<HitFlash> list = new List<HitFlash>();

    public void Awake()
    {
        instance = this;
    }

    public void OnEnable()
    {
        Events.OnEntityHit += EntityHit;
    }

    public void Update()
    {
        for (int num = list.Count - 1; num >= 0; num--)
        {
            HitFlash hitFlash = list[num];
            hitFlash.Update(Time.deltaTime);
            if (hitFlash.ended)
            {
                list.RemoveAt(num);
            }
        }
    }

    public void OnDisable()
    {
        Events.OnEntityHit -= EntityHit;
        foreach (HitFlash item in list)
        {
            item.End();
        }
        list.Clear();
    }

    public void EntityHit(Hit hit)
    {
        if (hit.Offensive && !hit.nullified)
        {
            HitFlash hitFlash = list.Find((HitFlash a) => a.target == hit.target);
            if (hitFlash != null)
            {
                hitFlash.time = flashDuration;
            }
            else
            {
                list.Add(new HitFlash(hit.target, damageMaterial, flashDuration));
            }
        }
    }

    public void RemoveFromTarget(Entity entity)
    {
        HitFlash hitFlash = list.Find((HitFlash a) => a.target == entity);
        if (hitFlash != null)
        {
            hitFlash.End();
            list.Remove(hitFlash);
        }
    }

    public static void Remove(Entity entity)
    {
        if (instance != null)
        {
            instance.RemoveFromTarget(entity);
        }
    }
}
public class Hover3dSystem : GameSystem
{
    public Camera cam;

    [SerializeField]
    public LayerMask layerMask;

    [SerializeField]
    public List<Hoverable3d> hoverList;

    public List<Hoverable3d> newList;

    public readonly RaycastHit[] hits = (RaycastHit[])(object)new RaycastHit[5];

    public void OnEnable()
    {
        cam = Camera.main;
        hoverList = new List<Hoverable3d>();
        newList = new List<Hoverable3d>();
    }

    public void Update()
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        int num = Physics.RaycastNonAlloc(cam.ScreenPointToRay((MonoBehaviourSingleton<Cursor3d>.instance.GetScreenPoint())), hits, 100f, LayerMask.op_Implicit(layerMask));
        for (int i = 0; i < num; i++)
        {
            RaycastHit val = hits[i];
            Hoverable3d component = ((Component)((val)).transform).GetComponent<Hoverable3d>();
            if (component != null)
            {
                newList.Add(component);
                if (!hoverList.Contains(component))
                {
                    component.Hover();
                }
            }
        }
        foreach (Hoverable3d hover in hoverList)
        {
            if (!newList.Contains(hover))
            {
                hover.UnHover();
            }
        }
        hoverList.Clear();
        hoverList.AddRange(newList);
        newList.Clear();
    }
}
public class Hoverable3d : GameSystem
{
    [SerializeField]
    public UnityEvent onHover;

    [SerializeField]
    public UnityEvent onUnHover;

    public void Hover()
    {
        UnityEvent obj = onHover;
        if (obj != null)
        {
            obj.Invoke();
        }
    }

    public void UnHover()
    {
        UnityEvent obj = onUnHover;
        if (obj != null)
        {
            obj.Invoke();
        }
    }
}
public class IdleAnimationSystem : GameSystem
{
    public readonly List<Entity> current = new List<Entity>();

    public void OnEnable()
    {
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
        current.Clear();
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
    }

    public void EntityHover(Entity entity)
    {
        if ((entity.data.idleAnimationProfile) && entity.display is Card card)
        {
            card.imageIdleAnimator.FadeIn();
            card.backgroundIdleAnimator.FadeIn();
            current.Add(entity);
        }
    }

    public void EntityUnHover(Entity entity)
    {
        if (current.Contains(entity) && entity.display is Card card)
        {
            card.imageIdleAnimator.FadeOut();
            card.backgroundIdleAnimator.FadeOut();
            current.Remove(entity);
        }
    }
}
public class InjuredCompanionEventSystem : GameSystem
{
    public void OnEnable()
    {
        Events.OnCampaignLoadPreset += CampaignLoadPreset;
    }

    public void OnDisable()
    {
        Events.OnCampaignLoadPreset -= CampaignLoadPreset;
    }

    public static int GetCampaignInsertPosition(RunHistory mostRecentRun)
    {
        int num = mostRecentRun.stats?.Count("battlesWon") ?? 0;
        int num2 = ((num >= 6) ? 23 : ((num >= 3) ? 11 : 2));
        Debug.Log($"InjuredCompanionEventSystem - Battles Won: {num} - Insert Pos: {num2}");
        return num2;
    }

    public static void CampaignLoadPreset(ref string[] lines)
    {
        if (Campaign.Data.GameMode.mainGameMode && !Campaign.Data.GameMode.tutorialRun)
        {
            RunHistory mostRecentRun = GetMostRecentRun();
            if (mostRecentRun != null && mostRecentRun.result == Campaign.Result.Lose && HasEligibleCompanion(mostRecentRun))
            {
                int campaignInsertPosition = GetCampaignInsertPosition(mostRecentRun);
                lines[0] = lines[0].Insert(campaignInsertPosition, "#");
                lines[1] = lines[1].Insert(campaignInsertPosition, " ");
                lines[2] = lines[2].Insert(campaignInsertPosition, lines[2][campaignInsertPosition - 1].ToString());
                lines[3] = lines[3].Insert(campaignInsertPosition, lines[3][campaignInsertPosition - 1].ToString());
            }
        }
    }

    public static RunHistory GetMostRecentRun()
    {
        List<RunHistory> list = SaveSystem.LoadHistoryData<List<RunHistory>>("list");
        if (list != null && list.Count > 0)
        {
            for (int num = list.Count - 1; num >= 0; num--)
            {
                if (list[num] != null)
                {
                    string gameModeName = list[num].gameModeName;
                    if (gameModeName != null)
                    {
                        GameMode gameMode = AddressableLoader.Get<GameMode>("GameMode", gameModeName);
                        if ((gameMode) && gameMode.mainGameMode)
                        {
                            return list[num];
                        }
                    }
                }
            }
        }
        return null;
    }

    public static bool HasEligibleCompanion(RunHistory run)
    {
        string[] unlockedPets = MetaprogressionSystem.GetUnlockedPets();
        CardSaveData[] deck = run.inventory.deck;
        for (int i = 0; i < deck.Length; i++)
        {
            if (IsEligible(deck[i], unlockedPets))
            {
                return true;
            }
        }
        deck = run.inventory.reserve;
        for (int i = 0; i < deck.Length; i++)
        {
            if (IsEligible(deck[i], unlockedPets))
            {
                return true;
            }
        }
        return false;
    }

    public static bool IsEligible(CardSaveData card, string[] illegal)
    {
        if (IArrayExt.Contains<string>(illegal, card.name))
        {
            return false;
        }
        CardData cardData = card.Peek();
        if ((cardData))
        {
            return (cardData.cardType).name == "Friendly";
        }
        return false;
    }

    public static List<CardSaveData> GetEligibleCompanions(RunHistory run)
    {
        string[] unlockedPets = MetaprogressionSystem.GetUnlockedPets();
        List<CardSaveData> list = new List<CardSaveData>();
        CardSaveData[] deck = run.inventory.deck;
        foreach (CardSaveData cardSaveData in deck)
        {
            if (IsEligible(cardSaveData, unlockedPets))
            {
                list.Add(cardSaveData);
            }
        }
        deck = run.inventory.reserve;
        foreach (CardSaveData cardSaveData2 in deck)
        {
            if (IsEligible(cardSaveData2, unlockedPets))
            {
                list.Add(cardSaveData2);
            }
        }
        return list;
    }
}
public class InjurySystem : GameSystem
{
    [Serializable]
    public class SaveState
    {
        public int campaignNodeId;

        public List<ulong> injuredThisBattleIds;

        public SaveState()
        {
        }

        public SaveState(int campaignNodeId, IEnumerable<CardData> injuredThisBattle)
        {
            this.campaignNodeId = campaignNodeId;
            injuredThisBattleIds = injuredThisBattle.Select((CardData a) => a.id).ToList();
        }

        public List<CardData> Load()
        {
            List<CardData> list = new List<CardData>();
            foreach (CardData item in References.PlayerData.inventory.deck)
            {
                int num = injuredThisBattleIds.IndexOf(item.id);
                if (num >= 0)
                {
                    injuredThisBattleIds.RemoveAt(num);
                    list.Add(item);
                }
            }
            return list;
        }
    }

    [SerializeField]
    public CardType[] typesThatCanBeInjured;

    [SerializeField]
    public StatusEffectData injuryEffect;

    [SerializeField]
    public List<CardData> injuredThisBattle;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Expected O, but got Unknown
        Events.OnBattleStart += new UnityAction(BattleStart);
        Events.OnEntityKilled += EntityKilled;
        Events.OnBattleSaved += new UnityAction(BattleSaved);
        Events.OnBattleLoaded += new UnityAction(BattleLoaded);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Expected O, but got Unknown
        Events.OnBattleStart -= new UnityAction(BattleStart);
        Events.OnEntityKilled -= EntityKilled;
        Events.OnBattleSaved -= new UnityAction(BattleSaved);
        Events.OnBattleLoaded -= new UnityAction(BattleLoaded);
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        CardData originalCardData;
        if (IsPlayerCard(entity.data))
        {
            if (!AnyAliveClonesOfThisCard(entity.data))
            {
                Injure(entity.data);
            }
        }
        else if (IsCloneOfPlayerCard(entity.data, out originalCardData) && !IsCardAlive(originalCardData) && !AnyAliveClonesOfThisCard(originalCardData))
        {
            Injure(originalCardData);
        }
    }

    public void BattleStart()
    {
        if (injuredThisBattle == null)
        {
            injuredThisBattle = new List<CardData>();
        }
        injuredThisBattle.Clear();
    }

    public void BattleSaved()
    {
        if (Campaign.Data.GameMode.doSave)
        {
            CardData[] injuriesThisBattle = GetInjuriesThisBattle();
            if (injuriesThisBattle != null && injuriesThisBattle.Length > 0)
            {
                SaveState value = new SaveState(Campaign.FindCharacterNode(References.Player).id, injuriesThisBattle);
                SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "battleInjuredThisBattle", value);
            }
        }
    }

    public void BattleLoaded()
    {
        SaveState saveState = SaveSystem.LoadCampaignData<SaveState>(Campaign.Data.GameMode, "battleInjuredThisBattle");
        if (saveState == null || Campaign.FindCharacterNode(References.Player).id != saveState.campaignNodeId || saveState.injuredThisBattleIds == null)
        {
            return;
        }
        injuredThisBattle = saveState.Load();
        foreach (CardData item in injuredThisBattle)
        {
            CardData cardData = item;
            if (cardData.injuries == null)
            {
                cardData.injuries = new List<CardData.StatusEffectStacks>();
            }
            if (item.injuries.Count <= 0)
            {
                item.injuries.Add(new CardData.StatusEffectStacks(injuryEffect, 1));
            }
        }
    }

    public static bool IsPlayerCard(CardData cardData)
    {
        return References.PlayerData.inventory.deck.Any((CardData a) => a.id == cardData.id);
    }

    public static bool IsCloneOfPlayerCard(CardData cardData, out CardData originalCardData)
    {
        if (cardData.TryGetCustomData("splitOriginalId", out var value, 0uL))
        {
            foreach (CardData item in References.PlayerData.inventory.deck)
            {
                if (item.id == value)
                {
                    originalCardData = item;
                    return true;
                }
            }
        }
        originalCardData = null;
        return false;
    }

    public void Injure(CardData cardData)
    {
        if (CanInjure(cardData))
        {
            if (cardData.injuries == null)
            {
                cardData.injuries = new List<CardData.StatusEffectStacks>();
            }
            if (cardData.injuries.Count <= 0)
            {
                cardData.injuries.Add(new CardData.StatusEffectStacks(injuryEffect, 1));
            }
            if (injuredThisBattle == null)
            {
                injuredThisBattle = new List<CardData>();
            }
            injuredThisBattle.Add(cardData);
            Events.InvokeCardInjured(cardData);
        }
    }

    public bool CanInjure(CardData cardData)
    {
        if ((cardData))
        {
            return CanInjure(cardData.cardType);
        }
        return false;
    }

    public bool CanInjure(CardType cardType)
    {
        return IArrayExt.Contains<CardType>(typesThatCanBeInjured, cardType);
    }

    public static CardData[] GetInjuriesThisBattle()
    {
        InjurySystem injurySystem = Object.FindObjectOfType<InjurySystem>();
        if ((injurySystem) && injurySystem.injuredThisBattle != null)
        {
            return injurySystem.injuredThisBattle.Where(IsPlayerCard).ToArray();
        }
        return new CardData[0];
    }

    public static bool IsCardAlive(CardData cardData)
    {
        foreach (Entity card in References.Battle.cards)
        {
            if (card.data.id == cardData.id && card.IsAliveAndExists())
            {
                return true;
            }
        }
        return false;
    }

    public static bool AnyAliveClonesOfThisCard(CardData originalCardData)
    {
        bool result = false;
        foreach (Entity card in References.Battle.cards)
        {
            if (card.data.customData != null && card.data.customData.TryGetValue("splitOriginalId", out var value) && value is ulong num && num == originalCardData.id && card.IsAliveAndExists())
            {
                result = true;
                break;
            }
        }
        return result;
    }
}
public class InputSystem : GameSystem
{
    public static InputSystem instance;

    [Header("Hold Direction Settings")]
    public float holdDirectionStartTime = 0.1f;

    public float holdDirectionFlowTime = 0.05f;

    public static Player mainPlayer;

    public static bool enabled = true;

    public static bool isLongHeld;

    public static float holdDirectionTime;

    public static bool wasSelectHeldLong;

    public static bool wasSelectHeldLong2;

    public static bool AllowDynamicSelectRelease = true;

    public static int _reset;

    public static bool Enabled
    {
        get
        {
            if (enabled)
            {
                return !Transition.Running;
            }
            return false;
        }
    }

    public static Vector3 MousePosition { get; set; }

    public static bool reset
    {
        get
        {
            return _reset > 0;
        }
        set
        {
            _reset = (value ? 2 : 0);
        }
    }

    public void Awake()
    {
        instance = this;
        mainPlayer = ReInput.players.GetPlayer(0);
    }

    public void LateUpdate()
    {
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        wasSelectHeldLong = wasSelectHeldLong2;
        wasSelectHeldLong2 = mainPlayer.GetButtonTimedPress("Select", 0.1f);
        if (Input.touchCount > 0)
        {
            Touch touch = Input.GetTouch(0);
            MousePosition = (((touch)).position);
        }
        else
        {
            MousePosition = Input.mousePosition;
        }
        _reset--;
    }

    public new static void Enable()
    {
        enabled = true;
    }

    public new static void Disable()
    {
        enabled = false;
    }

    public static bool IsButtonPressed(string input, bool positive = true)
    {
        if (!(Enabled && positive))
        {
            return mainPlayer.GetNegativeButtonDown(input);
        }
        return mainPlayer.GetButtonDown(input);
    }

    public static bool IsButtonHeld(string input, bool positive = true)
    {
        if (!(Enabled && positive))
        {
            return mainPlayer.GetNegativeButton(input);
        }
        return mainPlayer.GetButton(input);
    }

    public static bool IsButtonLongHeld(string input, bool positive = true)
    {
        if (!(Enabled && positive))
        {
            return mainPlayer.GetNegativeButtonLongPress(input);
        }
        return mainPlayer.GetButtonLongPress(input);
    }

    public static bool IsButtonReleased(string input, bool positive = true)
    {
        if (!(Enabled && positive))
        {
            return mainPlayer.GetNegativeButtonUp(input);
        }
        return mainPlayer.GetButtonUp(input);
    }

    public static bool WasButtonPressed(string input, bool positive = true)
    {
        if (!(Enabled && positive))
        {
            return mainPlayer.GetNegativeButtonPrev(input);
        }
        return mainPlayer.GetButtonPrev(input);
    }

    public static bool WasButtonReleased(string input, bool positive = true)
    {
        if (!(Enabled && positive))
        {
            return !mainPlayer.GetNegativeButtonPrev(input);
        }
        return !mainPlayer.GetButtonPrev(input);
    }

    public static bool IsSelectPressed()
    {
        return IsButtonPressed("Select");
    }

    public static bool IsSelectHeld()
    {
        return IsButtonHeld("Select");
    }

    public static bool IsSelectReleased()
    {
        return IsButtonReleased("Select");
    }

    public static bool IsDynamicSelectReleased(bool allowSelectAgainToRelease)
    {
        if (!Enabled)
        {
            return false;
        }
        if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse && wasSelectHeldLong && !IsSelectHeld())
        {
            return true;
        }
        if (allowSelectAgainToRelease)
        {
            return IsSelectPressed();
        }
        return !IsSelectHeld();
    }

    public static bool CheckLongHold()
    {
        if (IsButtonLongHeld("Move Vertical") || IsButtonLongHeld("Move Vertical", positive: false) || IsButtonLongHeld("Move Horizontal") || IsButtonLongHeld("Move Horizontal", positive: false))
        {
            if (!isLongHeld)
            {
                holdDirectionTime = instance.holdDirectionStartTime;
            }
            isLongHeld = true;
        }
        if (isLongHeld)
        {
            if (!RewiredControllerManager.instance.IsButtonReleased() && RewiredControllerManager.instance.IsButtonHeld())
            {
                holdDirectionTime -= Time.unscaledDeltaTime;
                if (holdDirectionTime <= 0f)
                {
                    holdDirectionTime = instance.holdDirectionFlowTime;
                    return true;
                }
                return false;
            }
            isLongHeld = false;
        }
        return isLongHeld;
    }

    public static float GetAxis(string actionName)
    {
        if (Enabled)
        {
            return mainPlayer.GetAxis(actionName);
        }
        return 0f;
    }

    public static float GetAxisDelta(string actionName)
    {
        if (Enabled)
        {
            return mainPlayer.GetAxisDelta(actionName);
        }
        return 0f;
    }
}
public class InspectCharmsSystem : GameSystem
{
    [SerializeField]
    public InspectSystem inspectSystem;

    [SerializeField]
    public CardCharm charmPrefab;

    [SerializeField]
    public GridLayoutGroup grid;

    [SerializeField]
    public string[] closeInputs = new string[3] { "Select", "Back", "Inspect" };

    public readonly List<CardCharm> charms = new List<CardCharm>();

    public const int maxCharms = 30;

    public const int maxColumns = 6;

    public float wait;

    public void Update()
    {
        if (wait <= 0f && !MonoBehaviourSingleton<Cursor3d>.instance.usingMouse && closeInputs.Any((string i) => InputSystem.IsButtonPressed(i)))
        {
            Hide();
        }
        if (wait > 0f)
        {
            wait -= Time.deltaTime;
        }
    }

    public void Show()
    {
        gameObject.SetActive(true);
        Create(inspectSystem.inspect.data.upgrades.Where((CardUpgradeData a) => a.type == CardUpgradeData.Type.Charm).ToArray());
        wait = 0.15f;
    }

    public void Create(CardUpgradeData[] cardUpgrades)
    {
        int num = Mathf.Min(30, cardUpgrades.Length);
        SetGridSize(num);
        for (int i = 0; i < num; i++)
        {
            CardCharm cardCharm = Object.Instantiate<CardCharm>(charmPrefab, ((Component)grid).transform);
            cardCharm.SetData(cardUpgrades[i]);
            cardCharm.holder = ((Component)cardCharm).transform;
            charms.Add(cardCharm);
        }
    }

    public void SetGridSize(int count)
    {
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        int num = Mathf.Min(6, count);
        int num2 = Mathf.CeilToInt((float)count / 6f);
        Transform transform = ((Component)grid).transform;
        RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
        if (val != null)
        {
            val.sizeDelta = new Vector2((float)num * grid.cellSize.x, (float)num2 * grid.cellSize.y);
        }
    }

    public void TryHide()
    {
        if (wait <= 0f)
        {
            Hide();
        }
    }

    public void Hide()
    {
        foreach (CardCharm charm in charms)
        {
            GameObjectExt.Destroy(((Component)charm).gameObject);
        }
        charms.Clear();
        gameObject.SetActive(false);
    }
}
public class InspectSystem : GameSystem
{
    [SerializeField]
    public GameObject container;

    [SerializeField]
    public Transform cardHolder;

    [SerializeField]
    public string openInput = "Inspect";

    [SerializeField]
    public string[] closeInputs = new string[3] { "Select", "Back", "Inspect" };

    [SerializeField]
    public string inspectCharmsInput = "Options";

    [SerializeField]
    public float cardScale = 1f;

    [SerializeField]
    public Vector2 cardRandomAngle = new Vector2(0f, 2f);

    [SerializeField]
    public List<Entity> hover = new List<Entity>();

    [SerializeField]
    public bool idleAnimation = true;

    [SerializeField]
    public float idleAnimationFactor = 1f;

    [SerializeField]
    public float canInspectDelay = 0.1f;

    [SerializeField]
    public float canEndDelay = 0.1f;

    [SerializeField]
    public KeywordData injuredKeyword;

    public float wait;

    [Header("Inspect Charms")]
    [SerializeField]
    public GameObject inspectCharmsLayout;

    [SerializeField]
    public InspectCharmsSystem inspectCharmsSystem;

    [Header("Pop up panels")]
    [SerializeField]
    public RectTransform leftPopGroup;

    [SerializeField]
    public RectTransform leftOverflowPopGroup;

    [SerializeField]
    public RectTransform rightPopGroup;

    [SerializeField]
    public RectTransform rightOverflowPopGroup;

    [SerializeField]
    public RectTransform bottomPopGroup;

    [SerializeField]
    public RectTransform notePopGroup;

    [SerializeField]
    public RectTransform[] overflowOrder;

    [SerializeField]
    public CardPopUpPanel popUpPrefab;

    [SerializeField]
    public CardTooltip cardTooltipPrefab;

    [SerializeField]
    public LayoutGroup[] layoutsToFix;

    [Header("Fading")]
    [SerializeField]
    public CanvasGroup backgroundFade;

    [SerializeField]
    public CanvasGroup cardInfoFade;

    [SerializeField]
    public float fadeInDur = 0.2f;

    [SerializeField]
    public float fadeOutDur = 0.1f;

    public float fade;

    [Header("Card Info Elements")]
    [SerializeField]
    public TMP_Text nameText;

    [SerializeField]
    public ImageSprite typeIcon;

    [SerializeField]
    public TMP_Text typeText;

    [Header("Tribe Flag")]
    [SerializeField]
    public Image flagImage;

    public Entity drag;

    public Entity press;

    public Transform previousParent;

    public int previousChildIndex;

    public const float enableAnimationDelay = 0.1f;

    public float enableAnimationTimer;

    public float currentIdleAnimationFactor;

    public bool hasAnyCharms;

    public readonly List<Tooltip> popups = new List<Tooltip>();

    public readonly List<KeywordData> currentPoppedKeywords = new List<KeywordData>();

    public Entity inspect { get; set; }

    public static bool IsActive()
    {
        InspectSystem inspectSystem = Object.FindObjectOfType<InspectSystem>();
        if ((inspectSystem))
        {
            return (inspectSystem.inspect);
        }
        return false;
    }

    public void OnEnable()
    {
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
        Events.OnEntityDrag += EntityDrag;
        Events.OnEntityRelease += EntityRelease;
        Events.OnEntityDestroyed += EntityUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
        Events.OnEntityDrag -= EntityDrag;
        Events.OnEntityRelease -= EntityRelease;
        Events.OnEntityDestroyed -= EntityUnHover;
    }

    public void Update()
    {
        if ((inspect))
        {
            if (wait <= 0f && !MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
            {
                if (hasAnyCharms && !((Component)inspectCharmsSystem).gameObject.activeSelf && InputSystem.IsButtonPressed(inspectCharmsInput))
                {
                    inspectCharmsSystem.Show();
                }
                if (!((Component)inspectCharmsSystem).gameObject.activeSelf && closeInputs.Any((string i) => InputSystem.IsButtonPressed(i)))
                {
                    InspectEnd();
                }
            }
        }
        else if (!(press))
        {
            if (!GameManager.paused && wait <= 0f && !(drag) && hover.Count == 1 && InputSystem.IsButtonPressed(openInput))
            {
                press = hover[0];
            }
        }
        else if (!GameManager.paused && !InputSystem.IsButtonHeld(openInput))
        {
            if (hover.Count == 1 && hover[0] == press)
            {
                ActionInspect actionInspect = new ActionInspect(press, this);
                if (Events.CheckAction(actionInspect))
                {
                    actionInspect.Process();
                }
            }
            press = null;
        }
        if (enableAnimationTimer > 0f)
        {
            enableAnimationTimer -= Time.deltaTime;
            if (enableAnimationTimer <= 0f)
            {
                EnableIdleAnimation();
            }
        }
        if (wait > 0f)
        {
            wait -= Time.deltaTime;
        }
    }

    public void Inspect(Entity entity)
    {
        //IL_00db: Unknown result type (might be due to invalid IL or missing references)
        //IL_010e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0119: Unknown result type (might be due to invalid IL or missing references)
        //IL_0131: Unknown result type (might be due to invalid IL or missing references)
        //IL_0157: Unknown result type (might be due to invalid IL or missing references)
        inspect = entity;
        SetFlag();
        hasAnyCharms = entity.HasAnyCharms();
        inspectCharmsLayout.SetActive(hasAnyCharms);
        container.SetActive(true);
        StopAllCoroutines();
        StartCoroutine(FadeIn());
        nameText.text = entity.data.title;
        typeIcon.SetSprite(entity.data.cardType.icon);
        typeText.text = entity.data.cardType.title;
        CreatePopups();
        entity.ForceUnHover();
        previousParent = entity.transform.parent;
        previousChildIndex = entity.transform.GetSiblingIndex();
        entity.transform.SetParent(cardHolder, true);
        LeanTween.moveLocal(((Component)entity).gameObject, Vector3.zero, 0.5f).setEase(LeanTweenType.easeOutQuart);
        entity.wobbler?.WobbleRandom();
        LeanTween.scale(((Component)entity).gameObject, Vector3.one * cardScale, 0.67f).setEase(LeanTweenType.easeOutBack);
        float num = FloatExt.WithRandomSign(Vector2Ext.PettyRandom(cardRandomAngle), 0.5f);
        LeanTween.rotateLocal(((Component)entity).gameObject, new Vector3(0f, 0f, num), 1f).setEase(LeanTweenType.easeOutBack);
        if (idleAnimation)
        {
            enableAnimationTimer = 0.1f;
        }
        Events.InvokeInspect(entity);
        Events.InvokeEntityFocus(entity);
        wait = canEndDelay;
    }

    public void SetFlag()
    {
        ClassData @class = GetClass(inspect.data);
        if ((@class))
        {
            ((Component)flagImage).gameObject.SetActive(true);
            flagImage.sprite = @class.flag;
        }
        else
        {
            ((Component)flagImage).gameObject.SetActive(false);
        }
    }

    public static ClassData GetClass(CardData cardData)
    {
        if (cardData.cardType.tag == "Enemy")
        {
            return null;
        }
        if ((cardData.cardType).name == "Leader")
        {
            ClassData[] classes = References.Classes;
            foreach (ClassData classData in classes)
            {
                CardData[] leaders = classData.leaders;
                for (int j = 0; j < leaders.Length; j++)
                {
                    if ((leaders[j]).name == (cardData).name)
                    {
                        return classData;
                    }
                }
            }
        }
        else
        {
            ClassData[] classes = References.Classes;
            foreach (ClassData classData2 in classes)
            {
                foreach (CardData item in classData2.startingInventory.deck)
                {
                    if ((item).name == (cardData).name)
                    {
                        return classData2;
                    }
                }
                RewardPool[] rewardPools = classData2.rewardPools;
                foreach (RewardPool rewardPool in rewardPools)
                {
                    if (rewardPool.isGeneralPool)
                    {
                        continue;
                    }
                    foreach (DataFile item2 in rewardPool.list)
                    {
                        if ((item2).name == (cardData).name)
                        {
                            return classData2;
                        }
                    }
                }
            }
        }
        return null;
    }

    public void TryInspectEnd()
    {
        if (wait <= 0f)
        {
            InspectEnd();
        }
    }

    public void InspectEnd()
    {
        inspect.transform.parent = previousParent;
        inspect.transform.SetSiblingIndex(previousChildIndex);
        inspect.TweenToContainer();
        inspect.wobbler?.WobbleRandom();
        DisableIdleAnimation();
        StopAllCoroutines();
        StartCoroutine(FadeOut());
        Events.InvokeInspectEnd(inspect);
        inspect = null;
        wait = canInspectDelay;
    }

    public IEnumerator FadeIn()
    {
        UpdateFade(0f);
        LeanTween.cancel(gameObject);
        LeanTween.value(gameObject, fade, 1f, fadeInDur).setEase(LeanTweenType.easeOutQuad).setOnUpdate(UpdateFade);
        yield return null;
    }

    public IEnumerator FadeOut()
    {
        LeanTween.cancel(gameObject);
        LeanTween.value(gameObject, fade, 0f, fadeOutDur).setEase(LeanTweenType.easeOutQuad).setOnUpdate(UpdateFade);
        yield return fadeOutDur;
        yield return null;
        ClearPopups();
        container.SetActive(false);
    }

    public void UpdateFade(float value)
    {
        fade = value;
        backgroundFade.alpha = fade;
        cardInfoFade.alpha = fade;
    }

    public void CreatePopups()
    {
        CreateIconPopups(inspect.display.healthLayoutGroup, (Transform)(object)leftPopGroup);
        CreateIconPopups(inspect.display.damageLayoutGroup, (Transform)(object)rightPopGroup);
        CreateIconPopups(inspect.display.counterLayoutGroup, (Transform)(object)bottomPopGroup);
        if (inspect.display is Card card)
        {
            foreach (CardData mentionedCard in card.mentionedCards)
            {
                Popup(mentionedCard, (Transform)(object)rightPopGroup);
            }
            foreach (KeywordData keyword in card.keywords)
            {
                Popup(keyword, (Transform)(object)rightPopGroup);
            }
        }
        foreach (KeywordData hiddenKeyword in inspect.GetHiddenKeywords())
        {
            Popup(hiddenKeyword, (Transform)(object)rightPopGroup);
        }
        List<CardData.StatusEffectStacks> injuries = inspect.data.injuries;
        if (injuries != null && injuries.Count > 0)
        {
            Popup(injuredKeyword, (Transform)(object)rightPopGroup);
        }
        CoroutineManager.Start(FixLayoutsAfterFrame());
    }

    public void CreateIconPopups(RectTransform iconLayoutGroup, Transform popGroup)
    {
        CardPopUpTarget[] componentsInChildren = ((Component)iconLayoutGroup).GetComponentsInChildren<CardPopUpTarget>();
        for (int i = 0; i < componentsInChildren.Length; i++)
        {
            KeywordData[] keywords = componentsInChildren[i].keywords;
            foreach (KeywordData keyword in keywords)
            {
                Popup(keyword, popGroup);
            }
        }
    }

    public void ClearPopups()
    {
        foreach (Tooltip popup in popups)
        {
            GameObjectExt.Destroy(((Component)popup).gameObject);
        }
        popups.Clear();
        currentPoppedKeywords.Clear();
    }

    public IEnumerator FixLayoutsAfterFrame()
    {
        yield return null;
        yield return FixLayouts();
    }

    public IEnumerator FixLayouts()
    {
        yield return null;
        LayoutGroup[] array = layoutsToFix;
        foreach (LayoutGroup val in array)
        {
            VerticalLayoutGroup val2 = (VerticalLayoutGroup)(object)((val is VerticalLayoutGroup) ? val : null);
            if (val2 == null)
            {
                HorizontalLayoutGroup val3 = (HorizontalLayoutGroup)(object)((val is HorizontalLayoutGroup) ? val : null);
                if (val3 != null)
                {
                    HorizontalLayoutGroupExt.FitToChildren(val3);
                }
            }
            else
            {
                VerticalLayoutGroupExt.FitToChildren(val2);
            }
        }
        if (CheckOverflow(bottomPopGroup))
        {
            yield return FixLayouts();
        }
    }

    public bool CheckOverflow(params RectTransform[] checkCollide)
    {
        for (int i = 0; i < overflowOrder.Length - 1; i++)
        {
            RectTransform val = overflowOrder[i];
            if (((Transform)val).childCount > 0 && CheckCollide(val, checkCollide))
            {
                Transform child = ((Transform)val).GetChild(((Transform)val).childCount - 1);
                RectTransform parent = overflowOrder[i + 1];
                child.SetParent((Transform)(object)parent);
                child.SetSiblingIndex(0);
                return true;
            }
        }
        return false;
    }

    public static bool CheckCollide(RectTransform target, IEnumerable<RectTransform> checks)
    {
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        foreach (RectTransform check in checks)
        {
            if (RectOverlap(target, check))
            {
                Debug.Log($"[{target.rect}] Overlaps [{check.rect}]");
                return true;
            }
        }
        return false;
    }

    public static bool RectOverlap(RectTransform a, RectTransform b)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_006b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Unknown result type (might be due to invalid IL or missing references)
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        //IL_007a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        //IL_0097: Unknown result type (might be due to invalid IL or missing references)
        //IL_009e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00af: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c4: Unknown result type (might be due to invalid IL or missing references)
        Vector3 position = ((Transform)a).position;
        Rect rect = a.rect;
        Vector2 size = ((rect)).size;
        Vector2 pivot = a.pivot;
        float num = position.x - pivot.x * size.x;
        float num2 = position.y - pivot.y * size.y;
        Rect val = default(Rect);
        ((val))..ctor(num, num2, size.x, size.y);
        Vector3 position2 = ((Transform)b).position;
        rect = b.rect;
        Vector2 size2 = ((rect)).size;
        Vector2 pivot2 = b.pivot;
        float num3 = position2.x - pivot2.x * size2.x;
        float num4 = position2.y - pivot2.y * size2.y;
        Rect val2 = default(Rect);
        ((val2))..ctor(num3, num4, size2.x, size2.y);
        return ((val)).Overlaps(val2);
    }

    public CardPopUpPanel Popup(KeywordData keyword, Transform group)
    {
        if (!currentPoppedKeywords.Contains(keyword))
        {
            CardPopUpPanel cardPopUpPanel = Object.Instantiate<CardPopUpPanel>(popUpPrefab, group);
            (((Component)cardPopUpPanel).gameObject).name = (keyword).name;
            cardPopUpPanel.Set(keyword);
            Events.InvokePopupPanelCreated(keyword, cardPopUpPanel);
            currentPoppedKeywords.Add(keyword);
            popups.Add(cardPopUpPanel);
            {
                foreach (KeywordData keyword2 in Text.GetKeywords(keyword.body))
                {
                    CardPopUpPanel cardPopUpPanel2 = Popup(keyword2, group);
                    HashSetExt.AddIfNotNull<Tooltip>(cardPopUpPanel.children, (Tooltip)cardPopUpPanel2);
                }
                return cardPopUpPanel;
            }
        }
        return null;
    }

    public CardTooltip Popup(CardData cardData, Transform group)
    {
        CardTooltip cardTooltip = Object.Instantiate<CardTooltip>(cardTooltipPrefab, group);
        (((Component)cardTooltip).gameObject).name = (cardData).name;
        cardTooltip.Set(cardData);
        popups.Add(cardTooltip);
        foreach (KeywordData keyword in cardTooltip.keywords)
        {
            CardPopUpPanel cardPopUpPanel = Popup(keyword, group);
            HashSetExt.AddIfNotNull<Tooltip>(cardTooltip.children, (Tooltip)cardPopUpPanel);
        }
        return cardTooltip;
    }

    public void EnableIdleAnimation()
    {
        if ((inspect?.data?.idleAnimationProfile) && inspect.display is Card card && idleAnimationFactor != 0f)
        {
            if ((card.imageIdleAnimator))
            {
                card.imageIdleAnimator.FadeIn();
                card.imageIdleAnimator.strength *= idleAnimationFactor;
            }
            if ((card.backgroundIdleAnimator))
            {
                card.backgroundIdleAnimator.FadeIn();
                card.backgroundIdleAnimator.strength *= idleAnimationFactor;
            }
            currentIdleAnimationFactor = idleAnimationFactor;
        }
    }

    public void DisableIdleAnimation()
    {
        if (inspect?.display is Card card)
        {
            if ((card.imageIdleAnimator))
            {
                card.imageIdleAnimator.FadeOut();
                card.imageIdleAnimator.strength /= currentIdleAnimationFactor;
            }
            if ((card.backgroundIdleAnimator))
            {
                card.backgroundIdleAnimator.FadeOut();
                card.backgroundIdleAnimator.strength /= currentIdleAnimationFactor;
            }
        }
    }

    public void EntityHover(Entity entity)
    {
        if (!hover.Contains(entity))
        {
            hover.Add(entity);
        }
    }

    public void EntityUnHover(Entity entity)
    {
        hover.Remove(entity);
    }

    public void EntityDrag(Entity entity)
    {
        drag = entity;
    }

    public void EntityRelease(Entity entity)
    {
        if (entity == drag)
        {
            drag = null;
        }
    }
}
public class JournalPageUnlockSystem : GameSystem
{
    [SerializeField]
    public JournalPageData[] pages;

    public void OnEnable()
    {
        Events.OnCampaignLoadPreset += InsertJournalPages;
    }

    public void OnDisable()
    {
        Events.OnCampaignLoadPreset -= InsertJournalPages;
    }

    public void InsertJournalPages(ref string[] lines)
    {
        List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
        JournalPageData[] array = pages;
        foreach (JournalPageData journalPageData in array)
        {
            if (!journalPageData.unlockOnMap || unlockedList.Contains((journalPageData.unlock).name) || !IsLegal(journalPageData))
            {
                continue;
            }
            int num = 0;
            for (int num2 = lines[0].Length - 1; num2 >= 0; num2--)
            {
                if (lines[2][num2] == journalPageData.mapTierIndex && (lines[0][num2] == journalPageData.mapAfterLetter || lines[1][num2] == journalPageData.mapAfterLetter))
                {
                    num = num2 + 1;
                    break;
                }
            }
            lines[0] = lines[0].Insert(num, journalPageData.mapNodeType.letter);
            lines[1] = lines[1].Insert(num, " ");
            lines[2] = lines[2].Insert(num, lines[2][num - 1].ToString());
            lines[3] = lines[3].Insert(num, lines[3][num - 1].ToString());
        }
    }

    public static bool IsLegal(JournalPageData page)
    {
        if (IArrayExt.Contains<GameMode>(page.legalGameModes, Campaign.Data.GameMode) && IArrayExt.Contains<ClassData>(page.legalTribes, References.PlayerData.classData) && HasRequiredStormPoints(page))
        {
            return HasRequiredModifiers(page);
        }
        return false;
    }

    public static bool HasRequiredStormPoints(JournalPageData page)
    {
        if (page.requiresStormPoints <= 0)
        {
            return true;
        }
        return StormBellManager.GetCurrentStormPoints(StormBellManager.GetActiveStormBells()) >= page.requiresStormPoints;
    }

    public static bool HasRequiredModifiers(JournalPageData page)
    {
        GameModifierData[] requiresModifiers = page.requiresModifiers;
        if (requiresModifiers != null && requiresModifiers.Length > 0)
        {
            if (Campaign.Data.Modifiers != null)
            {
                return IListExt.ContainsAll<GameModifierData>((IList<GameModifierData>)Campaign.Data.Modifiers, (IEnumerable<GameModifierData>)page.requiresModifiers);
            }
            return false;
        }
        return true;
    }

    public static CampaignGenerator.Node CreateNode(float x, float y, string type, int positionIndex)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        Vector2 val = Random.Vector2();
        x += val.x;
        y += val.y;
        return new CampaignGenerator.Node(x, y, 1f, 0, positionIndex, 0, type);
    }
}
public class KillComboSystem : GameSystem
{
    public string[] colors = new string[1] { "ffffff" };

    public string format = "<line-height=0.35><size=0.7><#{1}>x{0}\n<size=0.35>Combo\n\n<#FFD150>+{2}<sprite name=bling>";

    public int min = 2;

    public int baseGold;

    public int goldPerCombo = 5;

    public int count = 1;

    public void OnEnable()
    {
        Events.OnBattlePhaseStart += BattlePhaseStart;
        Events.OnBattleTurnEnd += BattleTurnEnd;
        Events.OnEntityKilled += EntityKilled;
    }

    public void OnDisable()
    {
        Events.OnBattlePhaseStart -= BattlePhaseStart;
        Events.OnBattleTurnEnd -= BattleTurnEnd;
        Events.OnEntityKilled -= EntityKilled;
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        if (phase == Battle.Phase.Init)
        {
            count = 1;
        }
    }

    public void BattleTurnEnd(int turnNumber)
    {
        count = 1;
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0094: Unknown result type (might be due to invalid IL or missing references)
        //IL_0095: Unknown result type (might be due to invalid IL or missing references)
        //IL_009f: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00df: Unknown result type (might be due to invalid IL or missing references)
        if ((References.Player) && entity.owner != References.Player)
        {
            if (count >= min)
            {
                Vector3 position = entity.transform.position;
                int goldAmount = GetGoldAmount(count);
                int num = Mathf.Clamp(count - min, 0, colors.Length - 1);
                string arg = colors[num];
                string text = string.Format(format, count, arg, goldAmount);
                FloatingText.Create(position + Vector3.down * 0.5f, text).Animate("Spring").Fade("Smooth", 0.5f, 0.5f);
                Events.InvokeDropGold(goldAmount, "Combo", References.Player, position);
                SfxSystem.OneShot("event:/sfx/attack/combo_marker");
                Events.InvokeKillCombo(count);
            }
            count++;
        }
    }

    public int GetGoldAmount(int killCount)
    {
        return Mathf.RoundToInt((float)(baseGold + (1 + killCount - min) * goldPerCombo) * References.PlayerData.comboGoldFactor);
    }
}
public class LastStandSystem : GameSystem
{
    [SerializeField]
    public StatusEffectData effect;

    [SerializeField]
    public StatusEffectData killEffect;

    [SerializeField]
    public Transform entityGroup;

    [SerializeField]
    public GameObject background;

    [SerializeField]
    public GameObject button;

    [SerializeField]
    public Dice playerDicePrefab;

    [SerializeField]
    public Dice enemyDicePrefab;

    [SerializeField]
    public Dice bossDicePrefab;

    [SerializeField]
    public Transform playerDiceGroup;

    [SerializeField]
    public Transform enemyDiceGroup;

    [SerializeField]
    public CardType[] legalCardTypes;

    [SerializeField]
    [ReadOnly]
    public int lastStandCount;

    public static Battle.Phase previousPhase;

    public static StatusEffectLastStand target;

    public static Entity subject;

    public static Entity attacker;

    public List<Entity> entities;

    public readonly Dictionary<Entity, Transform> previousParents = new Dictionary<Entity, Transform>();

    public readonly List<Dice> dice = new List<Dice>();

    public int result = -1;

    public bool diceRolled;

    public bool _active;

    public bool active
    {
        get
        {
            return _active;
        }
        set
        {
            _active = value;
            background.SetActive(value);
            button.SetActive(value);
        }
    }

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleStart += new UnityAction(BattleStart);
        Events.OnBattlePhaseStart += BattlePhaseStart;
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleStart -= new UnityAction(BattleStart);
        Events.OnBattlePhaseStart -= BattlePhaseStart;
    }

    public void BattleStart()
    {
        Entity entity = References.Battle.cards.FirstOrDefault((Entity a) => a.data.cardType.miniboss && a.owner == References.Player);
        if (entity != null)
        {
            new Routine(StatusEffectSystem.Apply(entity, null, effect, 1));
        }
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        if (phase == Battle.Phase.LastStand)
        {
            ActionQueue.Stack(new ActionSequence(Process())
            {
                note = "Last Stand"
            }, fixedPosition: true);
        }
    }

    public IEnumerator Process()
    {
        BattleMusicSystem musicSystem = Object.FindObjectOfType<BattleMusicSystem>();
        if (musicSystem != null)
        {
            musicSystem.FadePitchTo(0.3333f);
        }
        entities = Battle.GetCardsOnBoard();
        foreach (Entity entity in entities)
        {
            previousParents[entity] = entity.transform.parent;
            entity.transform.parent = entityGroup;
            entity.silenceCount++;
        }
        active = true;
        yield return (object)new WaitUntil((Func<bool>)(() => diceRolled));
        yield return RollSequence();
        Clear();
        foreach (KeyValuePair<Entity, Transform> item in previousParents.Where((KeyValuePair<Entity, Transform> pair) => pair.Key != null && pair.Value != null))
        {
            item.Key.transform.parent = item.Value;
        }
        previousParents.Clear();
        active = false;
        if (musicSystem != null)
        {
            musicSystem.FadePitchTo(1f);
        }
        target.preventDeath = false;
        switch (result)
        {
            case 0:
                Debug.Log("Player Wins!");
                if (Battle.IsOnBoard(attacker) && attacker.owner.team != subject.owner.team)
                {
                    yield return AttackAndKill(References.Battle.player, attacker);
                }
                break;
            case 1:
                Debug.Log("Enemy Wins!");
                yield return AttackAndKill(References.Battle.enemy, subject);
                break;
        }
        result = -1;
        References.Battle.CancelTurn();
        foreach (Entity item2 in entities.Where((Entity e) => e != null))
        {
            item2.silenceCount--;
        }
        entities = null;
        if (target != null)
        {
            target.ReEnable();
        }
        if (!References.Battle.CheckEnd())
        {
            References.Battle.phase = previousPhase;
        }
    }

    public void Roll()
    {
        button.SetActive(false);
        diceRolled = true;
    }

    public IEnumerator RollSequence()
    {
        Debug.Log("Last Stand: Rolling Dice...");
        float delayBetween = 1f;
        Entity[] legalEntities = entities.Where((Entity a) => IArrayExt.Contains<CardType>(legalCardTypes, a.data.cardType)).ToArray();
        int count = legalEntities.Count((Entity a) => a.owner == References.Battle.player);
        CreateDice(count, playerDicePrefab, playerDiceGroup);
        int playerTotal = ThrowDice(playerDiceGroup);
        yield return (object)new WaitForSeconds(delayBetween);
        int num = legalEntities.Count((Entity a) => a.owner == References.Battle.enemy && !a.data.cardType.miniboss);
        num += lastStandCount;
        CreateDice(num, enemyDicePrefab, enemyDiceGroup);
        int count2 = legalEntities.Count((Entity a) => a.owner == References.Battle.enemy && a.data.cardType.miniboss);
        CreateDice(count2, bossDicePrefab, enemyDiceGroup);
        int enemyTotal = ThrowDice(enemyDiceGroup);
        yield return (object)new WaitForSeconds(delayBetween);
        do
        {
            result = ((playerTotal <= enemyTotal) ? ((enemyTotal > playerTotal) ? 1 : (-1)) : 0);
            if (result == -1)
            {
                Debug.Log("It's a draw!");
                playerTotal = ThrowDice(playerDiceGroup);
                yield return (object)new WaitForSeconds(delayBetween);
                enemyTotal = ThrowDice(enemyDiceGroup);
                yield return (object)new WaitForSeconds(delayBetween);
            }
        }
        while (result == -1);
        lastStandCount++;
    }

    public void Clear()
    {
        foreach (Dice die in dice)
        {
            GameObjectExt.Destroy(((Component)die).gameObject);
        }
        dice.Clear();
        diceRolled = false;
    }

    public void CreateDice(int count, Dice prefab, Transform group)
    {
        for (int i = 0; i < count; i++)
        {
            Dice dice = Object.Instantiate<Dice>(prefab, group);
            ((Component)dice).gameObject.SetActive(true);
            this.dice.Add(dice);
        }
    }

    public static int ThrowDice(Transform group)
    {
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        int num = 0;
        float num2 = 0.5f;
        Dice[] componentsInChildren = ((Component)group).GetComponentsInChildren<Dice>();
        for (int i = 0; i < componentsInChildren.Length; i++)
        {
            Dice dice = componentsInChildren[i];
            ((Component)dice).transform.localPosition = new Vector3(num2 * (float)i, 0f);
            Vector2 val = new Vector2(Random.Range(-1f, 1f), 1f);
            dice.Throw(((val)).normalized);
            num += dice.value;
        }
        return num;
    }

    public IEnumerator AttackAndKillAll(Character attackingTeam, Character defendingTeam)
    {
        Entity[] source = entities.Where((Entity a) => IArrayExt.Contains<CardType>(legalCardTypes, a.data.cardType)).ToArray();
        List<Entity> attackers = source.Where((Entity a) => a.owner == attackingTeam).ToList();
        List<Entity> defenders = entities.Where((Entity a) => a.owner == defendingTeam).ToList();
        while (defenders.Count > 0)
        {
            Entity entity = IListExt.RandomItem<Entity>((IList<Entity>)attackers);
            Entity entity2 = IListExt.RandomItem<Entity>((IList<Entity>)defenders);
            defenders.Remove(entity2);
            Hit hit = new Hit(entity, entity2, 99)
            {
                canRetaliate = false,
                canBeNullified = false
            };
            hit.AddStatusEffect(killEffect, 1);
            Trigger trigger = new Trigger(entity, entity, "laststand", new Entity[1] { entity2 });
            trigger.countsAsTrigger = false;
            trigger.hits = new Hit[1] { hit };
            Trigger trigger2 = trigger;
            yield return trigger2.Process();
            yield return (object)new WaitForSeconds(Random.Range(0f, 0.1f));
        }
        yield return (object)new WaitForSeconds(1f);
    }

    public IEnumerator AttackOnce(Character attackingTeam)
    {
        List<Entity> list = (from a in entities.Where((Entity a) => IArrayExt.Contains<CardType>(legalCardTypes, a.data.cardType)).ToArray()
                             where a.owner == attackingTeam
                             select a).ToList();
        IListExt.Shuffle<Entity>((IList<Entity>)list);
        foreach (Entity attacker in list)
        {
            if (!attacker.data.hasAttack)
            {
                continue;
            }
            Entity[] array = ((attacker.targetMode != null) ? attacker.targetMode.GetTargets(attacker, null, null) : null);
            if (array != null && array.Length != 0)
            {
                Hit[] hits = array.Select((Entity a) => new Hit(attacker, a)
                {
                    canRetaliate = false,
                    canBeNullified = false
                }).ToArray();
                Trigger trigger = new Trigger(attacker, attacker, "laststand", array)
                {
                    countsAsTrigger = false,
                    hits = hits
                };
                yield return trigger.Process();
                yield return (object)new WaitForSeconds(Random.Range(0.1f, 0.1f));
            }
        }
        yield return (object)new WaitForSeconds(1f);
    }

    public IEnumerator AttackAndKill(Character attackingTeam, Entity target)
    {
        target.alive = false;
        Entity[] source = entities.Where((Entity a) => IArrayExt.Contains<CardType>(legalCardTypes, a.data.cardType)).ToArray();
        List<Entity> attackers = source.Where((Entity a) => a.owner == attackingTeam).ToList();
        IListExt.Shuffle<Entity>((IList<Entity>)attackers);
        int attackersCount = attackers.Count;
        for (int i = 0; i < attackersCount; i++)
        {
            bool num = i == attackersCount - 1;
            Entity attacker = attackers[i];
            Hit hit = new Hit(attacker, target, 0)
            {
                canRetaliate = false,
                canBeNullified = false,
                extraOffensiveness = 5
            };
            hit.FlagAsOffensive();
            if (num)
            {
                target.alive = true;
                hit.AddStatusEffect(killEffect, 1);
                hit.extraOffensiveness = 10;
                yield return (object)new WaitForSeconds(0.25f);
            }
            Trigger trigger = new Trigger(attacker, attacker, "laststand", new Entity[1] { target });
            trigger.countsAsTrigger = false;
            trigger.hits = new Hit[1] { hit };
            Trigger trigger2 = trigger;
            yield return trigger2.Process();
            yield return (object)new WaitForSeconds(Random.Range(0f, 0.01f));
        }
        yield return (object)new WaitForSeconds(1f);
    }
}
public class LogSystem : GameSystem
{
    public const int backups = 9;

    public const string format = "[{0}] {1}\n";

    public static string toLog = "";

    public static int logDelay = 0;

    public const int logDelayMax = 10;

    public static string directory => Application.persistentDataPath ?? "";

    public static string path => directory + "/Log.log";

    public void OnEnable()
    {
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Expected O, but got Unknown
        if (!Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }
        CreateBackups();
        Application.logMessageReceived += new LogCallback(Log);
        LogSystemInformation();
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Application.logMessageReceived -= new LogCallback(Log);
    }

    public void OnDestroy()
    {
        if (!StringExt.IsNullOrEmpty(toLog))
        {
            Write(toLog);
        }
    }

    public void Update()
    {
        if (logDelay < 0)
        {
            if (!StringExt.IsNullOrEmpty(toLog))
            {
                Write(toLog);
                toLog = "";
                logDelay = 10;
            }
        }
        else
        {
            logDelay--;
        }
    }

    public static void Write(string str)
    {
        using StreamWriter streamWriter = new StreamWriter(path, append: true);
        streamWriter.Write(str);
    }

    public static void Log(string log, string stacktrace, LogType type)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Invalid comparison between Unknown and I4
        if ((int)type == 0 || (int)type == 4)
        {
            log = "\n\n" + log + "\n" + stacktrace;
        }
        Log(log);
    }

    public static void Log(string log)
    {
        toLog += $"[{DateTime.Now}] {log}\n";
    }

    public static void CreateBackups()
    {
        for (int num = 8; num >= 0; num--)
        {
            string fileName = GetFileName(num);
            if (File.Exists(fileName))
            {
                string fileName2 = GetFileName(num + 1);
                File.Copy(fileName, fileName2, overwrite: true);
                if (num == 0)
                {
                    File.Delete(fileName);
                }
            }
        }
    }

    public static string GetFileName(int backupNumber)
    {
        if (backupNumber <= 0)
        {
            return path;
        }
        return $"{path}.{backupNumber}";
    }

    public static void LogSystemInformation()
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        Log("\n" + SystemInfo.deviceModel + $"\n{SystemInfo.deviceType} ({SystemInfo.deviceName}) [{SystemInfo.deviceUniqueIdentifier}]" + "\n" + SystemInfo.operatingSystem + $"\n{SystemInfo.processorType} ({SystemInfo.processorCount} Cores, {SystemInfo.processorFrequency}hz)" + "\n" + SystemInfo.graphicsDeviceVendor + " | " + SystemInfo.graphicsDeviceName + " (" + SystemInfo.graphicsDeviceVersion + ")" + $"\nShader Level: {SystemInfo.graphicsShaderLevel}" + $"\nGraphics Memory: {SystemInfo.graphicsMemorySize}" + $"\nSystem Memory: {SystemInfo.systemMemorySize}");
    }
}
public class MapAreaNameRevealSystem : GameSystem
{
    public readonly Dictionary<int, CampaignNode> areaNameNodes = new Dictionary<int, CampaignNode>();

    public void OnEnable()
    {
        Events.OnMapNodeReveal += MapNodeReveal;
        foreach (CampaignNode node in References.Campaign.nodes)
        {
            if (!node.revealed && !node.type.interactable && node.type.letter.StartsWith("area"))
            {
                areaNameNodes[node.areaIndex] = node;
            }
        }
    }

    public void OnDisable()
    {
        Events.OnMapNodeReveal -= MapNodeReveal;
    }

    public void MapNodeReveal(MapNode mapNode)
    {
        if (areaNameNodes.TryGetValue(mapNode.campaignNode.areaIndex, out var value))
        {
            References.Map.FindNode(value).Reveal();
            areaNameNodes.Remove(value.areaIndex);
        }
    }
}
public class MetaprogressionSystem : GameSystem
{
    public static readonly Dictionary<string, object> data = new Dictionary<string, object>
    {
        {
            "pets",
            new Dictionary<string, string>
            {
                { "Wolfie", null },
                { "BerryPet", "Pet 1" },
                { "DemonPet", "Pet 2" },
                { "DrawPet", "Pet 3" },
                { "Jagzag", "Pet 4" },
                { "InkPet", "Pet 4a" },
                { "BoostPet", "Pet 5" }
            }
        },
        {
            "items",
            new List<string> { "Slapcrackers", "Snowcracker", "Hooker", "ScrapPile", "MegaMimik", "Krono" }
        },
        {
            "companions",
            new List<string> { "TinyTyko", "Bombom", "Blue", "LuminCat", "TheBaker", "Havok" }
        },
        {
            "events",
            new List<string> { "CampaignNodeCopyItem", "CampaignNodeCharmShop", "CampaignNodeCurseItems" }
        },
        {
            "buildings",
            new List<string> { "InventorHut", "IcebreakerHut", "HotSpring" }
        },
        {
            "charms",
            new Dictionary<string, string>
            {
                { "Charm 1", "CardUpgradeFury" },
                { "Charm 2", "CardUpgradeSnowImmune" },
                { "Charm 3", "CardUpgradeAttackIncreaseCounter" },
                { "Charm 4", "CardUpgradeAttackRemoveEffects" },
                { "Charm 5", "CardUpgradeShellBecomesSpice" },
                { "Charm 6", "CardUpgradeEffigy" },
                { "Charm 7", "CardUpgradeShroomReduceHealth" },
                { "Charm 8", "CardUpgradeAttackConsume" },
                { "Charm 9", "CardUpgradeBlue" },
                { "Charm 10", "CardUpgradeGreed" },
                { "Charm 11", "CardUpgradeRemoveCharmLimit" },
                { "Charm 12", "CardUpgradeFrenzyReduceAttack" },
                { "Charm 13", "CardUpgradeConsumeAddHealth" },
                { "Charm 14", "CardUpgradeAttackAndHealth" },
                { "Charm 15", "CardUpgradeCritical" },
                { "Charm 16", "CardUpgradeSpark" },
                { "Charm 17", "CardUpgradeBootleg" },
                { "Charm 18", "CardUpgradeHunger" },
                { "Charm 19", "CardUpgradeShadeClay" },
                { "Charm 20", "CardUpgradePlink" },
                { "Charm 21", "CardUpgradeFlameberry" },
                { "Charm 22", "CardUpgradeGlass" },
                { "Charm 23", "CardUpgradeMuncher" },
                { "Charm 24", "CardUpgradeHeartmist" },
                { "Charm 25", "CardUpgradeHeartburn" },
                { "Charm 26", "CardUpgradeMime" },
                { "Charm 27", "CardUpgradeShredder" }
            }
        }
    };

    public static T Get<T>(string key) where T : class
    {
        return data[key] as T;
    }

    public static void Add<T, Y>(string key, Y keyValue, T value) where T : class where Y : class
    {
        Dictionary<Y, T> dictionary = (Dictionary<Y, T>)data[key];
        if (!dictionary.TryAdd(keyValue, value))
        {
            dictionary[keyValue] = value;
        }
        data[key] = dictionary;
    }

    public static bool Remove<T, Y>(string key, Y keyValue, T value) where T : class where Y : class
    {
        Dictionary<Y, T> dictionary = (Dictionary<Y, T>)data[key];
        bool result = dictionary.Remove(keyValue);
        data[key] = dictionary;
        return result;
    }

    public static void Add<T>(string key, T value) where T : class
    {
        List<T> list = (List<T>)data[key];
        list.Add(value);
        data[key] = list;
    }

    public static bool Remove<T>(string key, T value) where T : class
    {
        List<T> list = (List<T>)data[key];
        bool result = list.Remove(value);
        data[key] = list;
        return result;
    }

    public static T Get<T>(string key, T defaultValue)
    {
        if (data.ContainsKey(key))
        {
            object obj = data[key];
            if (obj is T)
            {
                return (T)obj;
            }
        }
        if (!SaveSystem.Enabled)
        {
            return defaultValue;
        }
        return SaveSystem.LoadProgressData(key, defaultValue);
    }

    public static void Set<T>(string key, T value)
    {
        if (SaveSystem.Enabled)
        {
            SaveSystem.SaveProgressData(key, value);
        }
    }

    public static List<string> GetUnlockedList()
    {
        return SaveSystem.LoadProgressData("unlocked", new List<string>());
    }

    public static IEnumerable<UnlockData> GetUnlocked(Predicate<UnlockData> match)
    {
        return from n in GetUnlockedList()
               select AddressableLoader.Get<UnlockData>("UnlockData", n) into unlock
               where unlock != null && unlock.IsActive && match(unlock)
               select unlock;
    }

    public static List<UnlockData> GetRemainingUnlocks(List<string> alreadyUnlocked = null)
    {
        if (alreadyUnlocked == null)
        {
            alreadyUnlocked = GetUnlockedList();
        }
        return (from a in AddressableLoader.GetGroup<UnlockData>("UnlockData")
                where (a.IsActive && !alreadyUnlocked.Contains((a).name)) || !a.IsActive
                orderby a.lowPriority
                select a).ToList();
    }

    public static bool IsUnlocked(UnlockData unlockData, List<string> alreadyUnlocked = null)
    {
        if (!(unlockData == null))
        {
            if (unlockData.IsActive)
            {
                return IsUnlocked((unlockData).name, alreadyUnlocked);
            }
            return false;
        }
        return true;
    }

    public static bool IsUnlocked(string unlockDataName, List<string> alreadyUnlocked = null)
    {
        if (alreadyUnlocked == null)
        {
            alreadyUnlocked = GetUnlockedList();
        }
        return alreadyUnlocked.Contains(unlockDataName);
    }

    public static List<ClassData> GetLockedClasses()
    {
        List<string> unlockedList = GetUnlockedList();
        return References.Classes.Where((ClassData c) => c.requiresUnlock != null && !IsUnlocked(c.requiresUnlock, unlockedList)).ToList();
    }

    public static List<string> GetLockedItems(List<UnlockData> remainingUnlocks)
    {
        int num = remainingUnlocks.Count((UnlockData a) => a.type == UnlockData.Type.Item);
        List<string> list = Get<List<string>>("items");
        int num2 = list.Count - num;
        List<string> list2 = new List<string>();
        for (int i = num2; i < list.Count; i++)
        {
            list2.Add(list[i]);
        }
        return list2;
    }

    public static List<string> GetLockedCompanions(List<UnlockData> remainingUnlocks)
    {
        int num = remainingUnlocks.Count((UnlockData a) => a.type == UnlockData.Type.Companion);
        List<string> list = Get<List<string>>("companions");
        int num2 = list.Count - num;
        List<string> list2 = new List<string>();
        for (int i = num2; i < list.Count; i++)
        {
            list2.Add(list[i]);
        }
        return list2;
    }

    public static List<string> GetLockedCharms(List<UnlockData> remainingUnlocks)
    {
        Dictionary<string, string> dictionary = Get<Dictionary<string, string>>("charms");
        List<string> list = new List<string>();
        foreach (UnlockData remainingUnlock in remainingUnlocks)
        {
            if (remainingUnlock.type == UnlockData.Type.Charm && dictionary.TryGetValue((remainingUnlock).name, out var value))
            {
                list.Add(value);
            }
        }
        return list;
    }

    public static string[] GetAllPets()
    {
        return GetPetDict().Keys.ToArray();
    }

    public static Dictionary<string, string> GetPetDict()
    {
        return Get<Dictionary<string, string>>("pets");
    }

    public static string[] GetUnlockedPets()
    {
        Dictionary<string, string> petDict = GetPetDict();
        List<string> list = SaveSystem.LoadProgressData<List<string>>("petHutUnlocks", null);
        List<string> list2 = new List<string>();
        foreach (var (item, text3) in petDict)
        {
            if (text3 == null || (list != null && list.Contains(text3)))
            {
                list2.Add(item);
            }
        }
        return list2.ToArray();
    }

    public static void SetUnlocksReady(string unlockName)
    {
        List<string> list = SaveSystem.LoadProgressData("townNew", new List<string>());
        list.Add(unlockName);
        SaveSystem.SaveProgressData("townNew", list);
        UnlockReadyIcon[] array = Object.FindObjectsOfType<UnlockReadyIcon>(true);
        for (int i = 0; i < array.Length; i++)
        {
            array[i].Set(unlocksReady: true);
        }
    }

    public static bool CheckUnlockRequirements(UnlockData unlock, ICollection<string> alreadyUnlocked)
    {
        return unlock.requires.All((UnlockData requirement) => requirement.IsActive && alreadyUnlocked.Contains((requirement).name));
    }

    public static bool AnyUnlocksReady()
    {
        return SaveSystem.LoadProgressData("townNew", new List<string>()).Count > 0;
    }
}
public class MinibossDeathZoomSystem : GameSystem
{
    [SerializeField]
    public Transform container;

    [SerializeField]
    public float zoomAmount = 4f;

    [SerializeField]
    public Image fade;

    [SerializeField]
    public Color fadeColor;

    [SerializeField]
    public Color flashColor;

    [SerializeField]
    public Image flash;

    [SerializeField]
    public AnimationCurve flashCurve;

    [SerializeField]
    public float slowmo = 0.1f;

    [SerializeField]
    public float duration = 0.3f;

    [SerializeField]
    public Vector3 limit = new Vector3(5.5f, 2.5f, 5f);

    public Entity target;

    public Transform targetPreviousParent;

    public bool pauseBlocked;

    public bool slowmoActive;

    public void OnEnable()
    {
        Events.OnEntityKilled += EntityKilled;
    }

    public void OnDisable()
    {
        Events.OnEntityKilled -= EntityKilled;
        UnblockPause();
        EndSlowmo();
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        if ((entity) && (entity.data))
        {
            CardType cardType = entity.data.cardType;
            if (cardType != null && cardType.miniboss && References.Battle.minibosses.Count((Entity a) => a != entity && a.owner == entity.owner) <= 0)
            {
                Run(entity);
            }
        }
    }

    public void Run(Entity target)
    {
        StartCoroutine(Routine(target));
    }

    public void BlockPause()
    {
        if (!pauseBlocked)
        {
            pauseBlocked = true;
            PauseMenu.Block();
            DeckpackBlocker.Block();
            if (Deckpack.IsOpen && References.Player.entity.display is CharacterDisplay characterDisplay)
            {
                characterDisplay.CloseInventory();
            }
        }
    }

    public void UnblockPause()
    {
        if (pauseBlocked)
        {
            pauseBlocked = false;
            DeckpackBlocker.Unblock();
            PauseMenu.Unblock();
        }
    }

    public void Slowmo()
    {
        if (!slowmoActive)
        {
            slowmoActive = true;
            LeanTween.value(Time.timeScale, slowmo, 0.05f).setEase(LeanTweenType.linear).setOnUpdate(Events.InvokeTimeScaleChange);
        }
    }

    public void EndSlowmo()
    {
        if (slowmoActive)
        {
            slowmoActive = false;
            LeanTween.value(Time.timeScale, 1f, 0.25f).setEase(LeanTweenType.linear).setOnUpdate(Events.InvokeTimeScaleChange);
        }
    }

    public IEnumerator Routine(Entity target)
    {
        BlockPause();
        if ((this.target))
        {
            this.target.transform.SetParent(targetPreviousParent);
        }
        yield return null;
        this.target = target;
        targetPreviousParent = target.transform.parent;
        target.transform.SetParent(container);
        target.ResetDrawOrder();
        HitFlashSystem.Remove(target);
        FlyOffScreen component = ((Component)target).GetComponent<FlyOffScreen>();
        if ((component))
        {
            component.velocity.z = 0f;
            component.velocity = ((component.velocity)).normalized * 20f;
            component.velocity.z = -3f;
        }
        ScreenFlashSystem.SetDrawOrder("Inspect", 1);
        ScreenFlashSystem.SetColour(flashColor);
        ScreenFlashSystem.Run(0.1f);
        Slowmo();
        LeanTween.value(gameObject, ((Graphic)fade).color.a, fadeColor.a, duration).setEase(LeanTweenType.easeInOutQuint).setOnUpdate(delegate (float a)
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0021: Unknown result type (might be due to invalid IL or missing references)
            ((Graphic)fade).color = ColorExt.With(((Graphic)fade).color, -1f, -1f, -1f, a);
        });
        Vector3 val = Vector3Ext.WithZ(target.transform.position, zoomAmount) - References.MinibossCameraMover.position;
        val = Vector3Ext.Clamp(val, -limit, limit);
        LeanTween.cancel(((Component)References.MinibossCameraMover).gameObject);
        LeanTween.moveLocal(((Component)References.MinibossCameraMover).gameObject, val, Mathf.Min(duration, 0.4f)).setEase(LeanTweenType.easeOutBack);
        yield return Sequences.Wait(duration);
        EndSlowmo();
        LeanTween.moveLocal(((Component)References.MinibossCameraMover).gameObject, Vector3.zero, 1f).setEase(LeanTweenType.easeOutBack);
        LeanTween.value(gameObject, ((Graphic)fade).color.a, 0f, 0.25f).setEase(LeanTweenType.easeInOutQuart).setOnUpdate(delegate (float a)
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0021: Unknown result type (might be due to invalid IL or missing references)
            ((Graphic)fade).color = ColorExt.With(((Graphic)fade).color, -1f, -1f, -1f, a);
        });
        yield return Sequences.Wait(1f);
        if ((this.target))
        {
            this.target.transform.SetParent(targetPreviousParent);
        }
        this.target = null;
        UnblockPause();
    }
}
public class MinibossIntroSystem : GameSystem
{
    [Serializable]
    public struct MinibossAnimation
    {
        public CardData cardData;

        public CardAnimation animation;
    }

    [SerializeField]
    public Transform container;

    [Header("Focus")]
    [SerializeField]
    public float focusAmount = 0.75f;

    [SerializeField]
    public float zoomAmount = 3f;

    [SerializeField]
    public CurveProfile focusTween;

    [SerializeField]
    public CurveProfile unfocusTween;

    [Header("Fade")]
    [SerializeField]
    public Image fade;

    [SerializeField]
    public Color fadeColor;

    [Header("Move miniboss to position")]
    [SerializeField]
    public Vector3 move = new Vector3(0f, 0f, -1f);

    [SerializeField]
    public CurveProfile moveTween;

    [SerializeField]
    public CurveProfile returnTween;

    [Header("Pauses before/after miniboss animation")]
    [SerializeField]
    public float pauseBefore = 0.33f;

    [SerializeField]
    public float pauseAfter = 1f;

    [Header("Delays")]
    [SerializeField]
    public float delayBefore = 0.2f;

    [SerializeField]
    public float delayAfter = 0.2f;

    [Header("Miniboss animations")]
    [SerializeField]
    public CardAnimation defaultAnimation;

    [SerializeField]
    public MinibossAnimation[] specificAnimations;

    [Header("SFX")]
    [SerializeField]
    public EventReference zoomSfx;

    [SerializeField]
    public EventReference shakeSfx;

    public readonly List<Entity> ignore = new List<Entity>();

    public Dictionary<string, CardAnimation> animationLookup;

    public Entity target;

    public Transform targetPreviousParent;

    public Routine routine;

    public bool hasRun;

    public void OnEnable()
    {
        Events.OnSceneChanged += SceneChanged;
        Events.OnEntityMove += EntityMove;
        animationLookup = new Dictionary<string, CardAnimation>();
        MinibossAnimation[] array = specificAnimations;
        for (int i = 0; i < array.Length; i++)
        {
            MinibossAnimation minibossAnimation = array[i];
            animationLookup[(minibossAnimation.cardData).name] = minibossAnimation.animation;
        }
    }

    public void OnDisable()
    {
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        Events.OnSceneChanged -= SceneChanged;
        Events.OnEntityMove -= EntityMove;
        StopAllCoroutines();
        routine?.Stop();
        if ((References.MinibossCameraMover))
        {
            LeanTween.cancel(((Component)References.MinibossCameraMover).gameObject);
            References.MinibossCameraMover.localPosition = Vector3.zero;
        }
    }

    public void Ignore(Entity entity)
    {
        ignore.Add(entity);
    }

    public void SceneChanged(Scene scene)
    {
        ignore.Clear();
        hasRun = false;
    }

    public void EntityMove(Entity entity)
    {
        if (!hasRun && !ignore.Contains(entity))
        {
            CardType cardType = entity.data.cardType;
            if (cardType != null && cardType.miniboss && entity.owner == Battle.instance.enemy && Battle.IsOnBoard(entity) && !Battle.IsOnBoard(entity.preContainers))
            {
                Activate(entity);
                hasRun = true;
            }
        }
    }

    public void Activate(Entity target)
    {
        ignore.Add(target);
        routine = new Routine(Routine(target));
        ActionQueue.Stack(new ActionSequence(WaitForRoutineToEnd()));
    }

    public IEnumerator WaitForRoutineToEnd()
    {
        while (routine.IsRunning)
        {
            yield return null;
        }
    }

    public void Assign(Entity target)
    {
        UnAssign();
        this.target = target;
        targetPreviousParent = target.transform.parent;
        target.transform.SetParent(container, true);
        target.ResetDrawOrder();
    }

    public void UnAssign()
    {
        if ((target))
        {
            target.transform.SetParent(targetPreviousParent);
        }
        target = null;
    }

    public IEnumerator Routine(Entity target)
    {
        Events.InvokeSetWeatherIntensity(1f, 1f);
        Assign(target);
        LeanTween.value(gameObject, ((Graphic)fade).color.a, fadeColor.a, focusTween.duration).setEase(LeanTweenType.easeInOutQuart).setOnUpdate(delegate (float a)
        {
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            //IL_002b: Unknown result type (might be due to invalid IL or missing references)
            ((Graphic)fade).color = ColorExt.With(((Graphic)fade).color, -1f, -1f, -1f, a);
        });
        target.flipper?.FlipUpInstant();
        CinemaBarSystem.SetSortingLayer("Inspect", 1);
        CinemaBarSystem.In();
        LeanTween.cancel(((Component)target).gameObject);
        yield return Sequences.Wait(delayBefore);
        Events.InvokeMinibossIntro(target);
        LeanTween.moveLocal(((Component)target).gameObject, Vector3.zero, moveTween.duration).setEase(moveTween.curve);
        yield return Sequences.Wait(pauseBefore);
        PauseMenu.Block();
        Vector3 originalCameraPos = Vector3.zero;
        Vector3 to = Vector3Ext.WithZ(Vector3.Lerp(originalCameraPos, container.position, focusAmount), zoomAmount);
        LeanTween.cancel(((Component)References.MinibossCameraMover).gameObject);
        LeanTween.move(((Component)References.MinibossCameraMover).gameObject, to, focusTween.duration).setEase(focusTween.curve);
        SfxSystem.OneShot(zoomSfx);
        CardAnimation valueOrDefault = DictionaryExt.GetValueOrDefault<string, CardAnimation>(animationLookup, (target).name, defaultAnimation);
        SfxSystem.OneShot(shakeSfx);
        yield return valueOrDefault.Routine(target);
        yield return Sequences.Wait(pauseAfter);
        _ = target.actualContainers[0];
        Vector3 containerScale = target.GetContainerScale();
        Vector3 containerWorldRotation = target.GetContainerWorldRotation();
        Vector3 containerWorldPosition = target.GetContainerWorldPosition();
        LeanTween.cancel(((Component)target).gameObject);
        LeanTween.scale(((Component)target).gameObject, containerScale, returnTween.duration).setEase(returnTween.curve);
        LeanTween.rotate(((Component)target).gameObject, containerWorldRotation, returnTween.duration).setEase(returnTween.curve);
        LeanTween.move(((Component)target).gameObject, containerWorldPosition, returnTween.duration).setEase(returnTween.curve).setOnComplete((Action)delegate
        {
            target.wobbler?.WobbleRandom();
        });
        LeanTween.moveLocal(((Component)References.MinibossCameraMover).gameObject, originalCameraPos, unfocusTween.duration).setEase(LeanTweenType.easeInOutBack);
        LeanTween.value(gameObject, ((Graphic)fade).color.a, 0f, unfocusTween.duration).setEase(unfocusTween.curve).setOnUpdate(delegate (float a)
        {
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            //IL_002b: Unknown result type (might be due to invalid IL or missing references)
            ((Graphic)fade).color = ColorExt.With(((Graphic)fade).color, -1f, -1f, -1f, a);
        });
        CinemaBarSystem.Out();
        Events.InvokeSetWeatherIntensity(0.25f, 3f);
        Events.InvokeMinibossIntroDone(target);
        yield return Sequences.Wait(unfocusTween.duration);
        UnAssign();
        PauseMenu.Unblock();
        yield return Sequences.Wait(delayAfter);
    }
}
public class AddCharmSlotModifierSystem : GameSystem
{
    public void OnEnable()
    {
        Events.OnEntityEnterBackpack += EntityEnterBackpack;
    }

    public void OnDisable()
    {
        Events.OnEntityEnterBackpack -= EntityEnterBackpack;
    }

    public static void EntityEnterBackpack(Entity entity)
    {
        AddCharmSlot(entity.data);
    }

    public static void AddCharmSlot(CardData target)
    {
        if (target.customData != null && target.customData.TryGetValue("extraCharmSlots", out var value) && value is int num)
        {
            target.customData["extraCharmSlots"] = num + 1;
        }
        else
        {
            target.SetCustomData("extraCharmSlots", 1);
        }
    }
}
public class AddFrenzyToBossesModifierSystem : GameSystem
{
    public StatusEffectData _effect;

    public StatusEffectData effect => _effect ?? (_effect = AddressableLoader.Get<StatusEffectData>("StatusEffectData", "MultiHit"));

    public void OnEnable()
    {
        Events.OnCardDataCreated += CardDataCreated;
    }

    public void OnDisable()
    {
        Events.OnCardDataCreated -= CardDataCreated;
    }

    public void CardDataCreated(CardData cardData)
    {
        switch ((cardData.cardType).name)
        {
            case "Miniboss":
            case "Boss":
            case "BossSmall":
                cardData.startWithEffects = CardData.StatusEffectStacks.Stack(cardData.startWithEffects, new CardData.StatusEffectStacks[1]
                {
                new CardData.StatusEffectStacks(effect, 1)
                });
                break;
        }
    }
}
public class BlockConsumeModifierSystem : GameSystem
{
    public const int toBlockPerBattle = 1;

    public int toBlock;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnBattleStart += new UnityAction(BattleStart);
        Events.OnBattleLoaded += new UnityAction(BattleLoaded);
        Events.OnActionQueued += ActionQueued;
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnBattleStart -= new UnityAction(BattleStart);
        Events.OnBattleLoaded -= new UnityAction(BattleLoaded);
        Events.OnActionQueued -= ActionQueued;
    }

    public void BattleStart()
    {
        toBlock = 1;
        SaveData();
    }

    public void BattleLoaded()
    {
        LoadData();
    }

    public void ActionQueued(PlayAction action)
    {
        if (toBlock > 0 && action is ActionConsume { blocked: false } actionConsume)
        {
            toBlock--;
            actionConsume.Block();
            SaveData();
        }
    }

    public void SaveData()
    {
        int id = Campaign.FindCharacterNode(References.Battle.player).id;
        SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "BlockConsumeModifierSystemBattleId", id);
        SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "BlockConsumeModifierSystemToBlock", toBlock);
    }

    public void LoadData()
    {
        int id = Campaign.FindCharacterNode(References.Battle.player).id;
        if (SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "BlockConsumeModifierSystemBattleId", -1) == id)
        {
            toBlock = SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "BlockConsumeModifierSystemToBlock", 0);
        }
    }
}
public class BlockForMinibossesModifierSystem : GameSystem
{
    public const float healthFactor = 0.75f;

    public const float blockPerHealthLost = 0.25f;

    public static StatusEffectData _effect;

    public static StatusEffectData effect => _effect ?? (_effect = AddressableLoader.Get<StatusEffectData>("StatusEffectData", "Block"));

    public void OnEnable()
    {
        Events.OnCardDataCreated += CardDataCreated;
    }

    public void OnDisable()
    {
        Events.OnCardDataCreated -= CardDataCreated;
    }

    public static void CardDataCreated(CardData cardData)
    {
        if ((cardData.cardType).name == "Miniboss" && cardData.hasHealth)
        {
            int hp = cardData.hp;
            cardData.hp = Mathf.CeilToInt((float)cardData.hp * 0.75f);
            int num = hp - cardData.hp;
            int count = Mathf.Max(1, Mathf.CeilToInt((float)num * 0.25f));
            cardData.startWithEffects = CardData.StatusEffectStacks.Stack(cardData.startWithEffects, new CardData.StatusEffectStacks[1]
            {
                new CardData.StatusEffectStacks(effect, count)
            });
        }
    }
}
public class BombskullClunkersModifierSystem : GameSystem
{
    public static CardUpgradeData _upgradeData;

    public readonly List<ulong> ids = new List<ulong>();

    public static CardUpgradeData upgradeData => _upgradeData ?? (_upgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", "CardUpgradeBombskull"));

    public void OnEnable()
    {
        Events.OnCardDataCreated += CardDataCreated;
        Events.OnEntityCreated += EntityCreated;
    }

    public void OnDisable()
    {
        Events.OnCardDataCreated -= CardDataCreated;
        Events.OnEntityCreated -= EntityCreated;
    }

    public void CardDataCreated(CardData cardData)
    {
        if ((cardData.cardType).name == "Clunker")
        {
            ids.Add(cardData.id);
        }
    }

    public void EntityCreated(Entity entity)
    {
        if (ids.Contains(entity.data.id))
        {
            ids.Remove(entity.data.id);
            if ((entity.owner) && entity.owner.team == References.Player.team)
            {
                upgradeData.Clone().Assign(entity.data);
            }
        }
    }
}
public class BoostAllEffectsModifierSystem : GameSystem
{
    public const int add = 1;

    public void OnEnable()
    {
        Events.OnCardDataCreated += CardDataCreated;
    }

    public void OnDisable()
    {
        Events.OnCardDataCreated -= CardDataCreated;
    }

    public static void CardDataCreated(CardData cardData)
    {
        foreach (CardData.StatusEffectStacks item in cardData.attackEffects.Where((CardData.StatusEffectStacks e) => e.data.stackable))
        {
            item.count++;
        }
        foreach (CardData.StatusEffectStacks item2 in cardData.startWithEffects.Where((CardData.StatusEffectStacks e) => !e.data.isStatus && e.data.canBeBoosted))
        {
            item2.count++;
        }
        foreach (CardData.TraitStacks item3 in cardData.traits.Where((CardData.TraitStacks t) => t.data.keyword.canStack))
        {
            item3.count++;
        }
    }
}
public class BoostAllHealthModifierSystem : GameSystem
{
    public const int healthAdd = 2;

    public void OnEnable()
    {
        Events.OnCardDataCreated += CardDataCreated;
    }

    public void OnDisable()
    {
        Events.OnCardDataCreated -= CardDataCreated;
    }

    public static void CardDataCreated(CardData cardData)
    {
        if ((cardData.cardType).name == "Friendly" && cardData.hasHealth)
        {
            cardData.hp += 2;
        }
    }
}
public class BoostArea2EnemyDamageModifierSystem : GameSystem
{
    public const int area = 1;

    public const int damageAdd = 1;

    public bool correctArea;

    public void OnEnable()
    {
        Events.PreBattleSetUp += PreBattleSetUp;
        Events.PostBattleSetUp += PostBattleSetUp;
    }

    public void OnDisable()
    {
        Events.PreBattleSetUp -= PreBattleSetUp;
        Events.PostBattleSetUp -= PostBattleSetUp;
    }

    public void PreBattleSetUp(CampaignNode node)
    {
        correctArea = node.areaIndex == 1;
        if (correctArea)
        {
            Events.OnCardDataCreated += CardDataCreated;
        }
    }

    public void PostBattleSetUp(CampaignNode node)
    {
        if (correctArea)
        {
            Events.OnCardDataCreated -= CardDataCreated;
        }
        correctArea = false;
    }

    public void CardDataCreated(CardData cardData)
    {
        if (!correctArea)
        {
            return;
        }
        switch ((cardData.cardType).name)
        {
            case "Enemy":
            case "Miniboss":
            case "Boss":
                if (cardData.hasAttack)
                {
                    cardData.damage++;
                }
                break;
        }
    }
}
public class BoostArea3EnemyDamageModifierSystem : GameSystem
{
    public const int area = 2;

    public const int damageAdd = 1;

    public bool correctArea;

    public void OnEnable()
    {
        Events.PreBattleSetUp += PreBattleSetUp;
        Events.PostBattleSetUp += PostBattleSetUp;
    }

    public void OnDisable()
    {
        Events.PreBattleSetUp -= PreBattleSetUp;
        Events.PostBattleSetUp -= PostBattleSetUp;
    }

    public void PreBattleSetUp(CampaignNode node)
    {
        correctArea = node.areaIndex == 2;
        if (correctArea)
        {
            Events.OnCardDataCreated += CardDataCreated;
        }
    }

    public void PostBattleSetUp(CampaignNode node)
    {
        if (correctArea)
        {
            Events.OnCardDataCreated -= CardDataCreated;
        }
        correctArea = false;
    }

    public void CardDataCreated(CardData cardData)
    {
        if (!correctArea)
        {
            return;
        }
        switch ((cardData.cardType).name)
        {
            case "Enemy":
            case "Miniboss":
            case "Boss":
                if (cardData.hasAttack)
                {
                    cardData.damage++;
                }
                break;
        }
    }
}
public class BoostEnemyDamageModifierSystem : GameSystem
{
    public const int attackAdd = 1;

    public const int healthAdd = 1;

    public void OnEnable()
    {
        Events.OnCardDataCreated += CardDataCreated;
    }

    public void OnDisable()
    {
        Events.OnCardDataCreated -= CardDataCreated;
    }

    public static void CardDataCreated(CardData cardData)
    {
        switch ((cardData.cardType).name)
        {
            case "Enemy":
            case "Miniboss":
            case "Boss":
            case "BossSmall":
                if (cardData.hasAttack)
                {
                    cardData.damage++;
                }
                if (cardData.hasHealth)
                {
                    cardData.hp++;
                }
                break;
        }
    }
}
public class BoostFriendlyDamageModifierSystem : GameSystem
{
    public const int attackAdd = 1;

    public void OnEnable()
    {
        Events.OnCardDataCreated += CardDataCreated;
    }

    public void OnDisable()
    {
        Events.OnCardDataCreated -= CardDataCreated;
    }

    public static void CardDataCreated(CardData cardData)
    {
        if ((cardData.cardType).name == "Friendly" && cardData.hasAttack)
        {
            cardData.damage++;
        }
    }
}
public class BoostMinibossHealthModifierSystem : GameSystem
{
    public const float healthFactor = 1.1f;

    public void OnEnable()
    {
        Events.OnCardDataCreated += CardDataCreated;
    }

    public void OnDisable()
    {
        Events.OnCardDataCreated -= CardDataCreated;
    }

    public void CardDataCreated(CardData cardData)
    {
        string name = (cardData.cardType).name;
        if (name == "Miniboss" || name == "Boss")
        {
            if (cardData.hasHealth)
            {
                BoostHealth(cardData, 1.1f);
            }
            else
            {
                BoostStatusEffect(cardData, "scrap", 1.1f);
            }
        }
    }

    public void BoostHealth(CardData cardData, float factor)
    {
        float num = (float)cardData.hp * factor;
        cardData.hp = Mathf.RoundToInt(num);
    }

    public void BoostStatusEffect(CardData cardData, string statusType, float factor)
    {
        CardData.StatusEffectStacks[] startWithEffects = cardData.startWithEffects;
        foreach (CardData.StatusEffectStacks statusEffectStacks in startWithEffects)
        {
            if (!(statusEffectStacks.data.type != statusType))
            {
                float num = (float)statusEffectStacks.count * factor;
                statusEffectStacks.count = Mathf.RoundToInt(num);
            }
        }
    }
}
public class DeadweightAfterBossModifierSystem : GameSystem
{
    [SerializeField]
    public string cardDataName = "Deadweight";

    [SerializeField]
    public ChooseNewCardSequence gainCardSequencePrefab;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleWin += new UnityAction(BattleWin);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleWin -= new UnityAction(BattleWin);
    }

    public void BattleWin()
    {
        if (Campaign.FindCharacterNode(References.Player).type.isBoss)
        {
            CardData cardData = AddressableLoader.Get<CardData>("CardData", cardDataName);
            ActionQueue.Add(new ActionSequence(GainCardRoutine(cardData)));
        }
    }

    public IEnumerator GainCardRoutine(CardData cardData)
    {
        CardData data = cardData.Clone();
        ChooseNewCardSequence sequence = Object.Instantiate<ChooseNewCardSequence>(gainCardSequencePrefab, References.Player.entity.display.transform);
        CardSelector componentInChildren = ((Component)sequence).GetComponentInChildren<CardSelector>();
        if (componentInChildren != null)
        {
            componentInChildren.character = References.Player;
            ((UnityEvent<Entity>)componentInChildren.selectEvent).AddListener((UnityAction<Entity>)Events.InvokeEntityChosen);
        }
        sequence.owner = References.Player;
        sequence.cardController.owner = References.Player;
        Card card = CardManager.Get(data, sequence.cardController, References.Player, inPlay: false, isPlayerCard: true);
        card.entity.flipper.FlipDownInstant();
        sequence.cardContainer.Add(card.entity);
        yield return card.UpdateData();
        card.transform.localPosition = Vector3.down;
        card.entity.wobbler.WobbleRandom();
        sequence.cardContainer.TweenChildPositions();
        Events.InvokeEntityOffered(card.entity);
        yield return sequence.Run();
        GameObjectExt.Destroy(((Component)sequence).gameObject);
    }
}
public class DoubleGoblingGoldModifierSystem : GameSystem
{
    public const float multiplier = 2f;

    public void OnEnable()
    {
        Events.OnCardDataCreated += CardDataCreated;
    }

    public void OnDisable()
    {
        Events.OnCardDataCreated -= CardDataCreated;
    }

    public static void CardDataCreated(CardData cardData)
    {
        if ((cardData).name == "Gobling")
        {
            CardData.StatusEffectStacks obj = cardData.startWithEffects[1];
            obj.count = Mathf.RoundToInt((float)obj.count * 2f);
        }
    }
}
public class DrainLeaderAfterBattleSystem : GameSystem
{
    [SerializeField]
    public int[] modifyAfterBattleTier = new int[1] { 5 };

    [SerializeField]
    public CardScript modifyScript;

    [SerializeField]
    public bool modifyLeader;

    [SerializeField]
    [HideIf("modifyLeader")]
    public int modifyCardIndex;

    [SerializeField]
    public ModifyCardSequence sequencePrefab;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleWinPreRewards += new UnityAction(BattleWinPreRewards);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleWinPreRewards -= new UnityAction(BattleWinPreRewards);
    }

    public void BattleWinPreRewards()
    {
        CampaignNodeType type = Campaign.FindCharacterNode(References.Player).type;
        if (!(type is CampaignNodeTypeBattle) || !type.isBoss)
        {
            return;
        }
        CardData highestHealthCard = References.PlayerData.inventory.deck.OrderByDescending((CardData a) => a.hp).FirstOrDefault();
        if ((highestHealthCard))
        {
            CardData cardData = IEnumerableExt.InRandomOrder<CardData>(References.PlayerData.inventory.deck.Where((CardData a) => a.hp == highestHealthCard.hp)).FirstOrDefault();
            if ((cardData))
            {
                ActionQueue.Add(new ActionSequence(ModifyCardRoutine(cardData)));
            }
        }
    }

    public IEnumerator ModifyCardRoutine(CardData cardToModify)
    {
        ModifyCardSequence sequence = Object.Instantiate<ModifyCardSequence>(sequencePrefab, References.Player.entity.display.transform);
        yield return sequence.Run(cardToModify, modifyScript);
        GameObjectExt.Destroy(((Component)sequence).gameObject);
    }
}
public class DrainLeaderModifierSystem : GameSystem
{
    public const int addHealth = -1;

    public void OnEnable()
    {
        Events.PostBattle += PostBattle;
    }

    public void OnDisable()
    {
        Events.PostBattle -= PostBattle;
    }

    public void PostBattle(CampaignNode campaignNode)
    {
        CardData cardData = References.PlayerData.inventory.deck.FirstOrDefault((CardData a) => a.cardType.miniboss);
        if ((cardData) && cardData.hp > 1)
        {
            int hp = cardData.hp;
            cardData.hp = Mathf.Max(1, cardData.hp + -1);
            Debug.Log($"[{this}] draining leader health ({hp} → {cardData.hp})");
        }
    }
}
public class DrawExtraWhenRedrawNotChargedSystem : MonoBehaviour
{
    public const int extraDraw = 3;

    public RedrawBellSystem _redrawBellSystem;

    public RedrawBellSystem redrawBellSystem => _redrawBellSystem ?? (_redrawBellSystem = Object.FindObjectOfType<RedrawBellSystem>());

    public void OnEnable()
    {
        Events.OnGetHandSize += GetHandSize;
    }

    public void OnDisable()
    {
        Events.OnGetHandSize -= GetHandSize;
    }

    public void GetHandSize(ref int handSize)
    {
        if (!redrawBellSystem.IsCharged)
        {
            handSize += 3;
        }
    }
}
public class DrawWhenRedrawChargedModifierSystem : GameSystem
{
    public const int drawAmount = 1;

    public RedrawBellSystem _redrawBellSystem;

    public bool drawOnTurnEnd;

    public RedrawBellSystem redrawBellSystem => _redrawBellSystem ?? (_redrawBellSystem = Object.FindObjectOfType<RedrawBellSystem>());

    public void OnEnable()
    {
        Events.OnBattleTurnStart += BattleTurnStart;
        Events.OnBattleTurnEnd += BattleTurnEnd;
    }

    public void OnDisable()
    {
        Events.OnBattleTurnStart -= BattleTurnStart;
        Events.OnBattleTurnEnd -= BattleTurnEnd;
    }

    public void BattleTurnStart(int turn)
    {
        if (redrawBellSystem.IsCharged && !Battle.instance.ended)
        {
            drawOnTurnEnd = true;
        }
    }

    public void BattleTurnEnd(int turn)
    {
        if (drawOnTurnEnd && !Battle.instance.ended)
        {
            drawOnTurnEnd = false;
            ActionQueue.Stack(new ActionDraw(References.Player));
        }
    }
}
public class MoreCardRewardsModifierSystem : MonoBehaviour
{
    public const int toAdd = 1;

    public readonly List<int> tiersToAddTo = new List<int>();

    public void OnEnable()
    {
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        Events.OnPullRewards += PullRewards;
        tiersToAddTo.Clear();
        List<int> list = new List<int> { 0, 1, 2, 3, 4 };
        State state = Random.state;
        Random.InitState(Campaign.Data.Seed);
        for (int i = 0; i < 2; i++)
        {
            if (list.Count <= 0)
            {
                break;
            }
            tiersToAddTo.Add(IListExt.TakeRandom<int>((IList<int>)list));
        }
        Random.state = state;
        Debug.Log(("MoreCardRewardsModifierSystem → tiers to add to: [" + string.Join(", ", tiersToAddTo) + "]"));
    }

    public void OnDisable()
    {
        Events.OnPullRewards -= PullRewards;
    }

    public void PullRewards(object pulledBy, ref string poolName, ref int itemCount, ref List<DataFile> result)
    {
        if (pulledBy is CampaignNode campaignNode && tiersToAddTo.Contains(campaignNode.tier) && campaignNode.type is CampaignNodeTypeItem)
        {
            itemCount++;
            Debug.Log($"MoreCardRewardsModifierSystem → adding +{1} to Reward Pool \"{poolName}\" Pull ({(campaignNode.type).name} node index: {campaignNode.id})");
        }
    }
}
public class NegativeCharmAfterBossModifierSystem : GameSystem
{
    [SerializeField]
    public GainNegativeCharmSequence gainNegativeCharmSequencePrefab;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleWin += new UnityAction(BattleWin);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleWin -= new UnityAction(BattleWin);
    }

    public void BattleWin()
    {
        if (Campaign.FindCharacterNode(References.Player).type.isBoss)
        {
            ActionQueue.Stack(new ActionSequence(GainCharmRoutine()));
        }
    }

    public IEnumerator GainCharmRoutine()
    {
        GainNegativeCharmSequence sequence = Object.Instantiate<GainNegativeCharmSequence>(gainNegativeCharmSequencePrefab, References.Player.entity.display.transform);
        yield return sequence.Run();
        GameObjectExt.Destroy(((Component)sequence).gameObject);
    }
}
public class PermadeathModifierSystem : GameSystem
{
    public static readonly string[] LegalTypes = new string[1] { "Friendly" };

    public void OnEnable()
    {
        Events.OnEntityKilled += EntityKilled;
    }

    public void OnDisable()
    {
        Events.OnEntityKilled -= EntityKilled;
    }

    public static void EntityKilled(Entity entity, DeathType deathType)
    {
        if (IsPlayerCard(entity) && IsLegalCardType(entity))
        {
            RemoveFromDeck(entity, References.PlayerData.inventory);
        }
    }

    public static bool IsPlayerCard(Entity entity)
    {
        if (entity.owner == References.Player)
        {
            return References.PlayerData.inventory.deck.Contains(entity.data);
        }
        return false;
    }

    public static bool IsLegalCardType(Entity entity)
    {
        return IArrayExt.Contains<string>(LegalTypes, (entity.data.cardType).name);
    }

    public static void RemoveFromDeck(Entity entity, Inventory inventory)
    {
        Debug.Log($"Permadeath System → deleting [{entity.data}]");
        inventory.deck.Remove(entity.data);
    }
}
public class RecallChargeRedrawBellModifierSystem : GameSystem
{
    public RedrawBellSystem _redrawBellSystem;

    public RedrawBellSystem redrawBellSystem => _redrawBellSystem ?? (_redrawBellSystem = Object.FindObjectOfType<RedrawBellSystem>());

    public void OnEnable()
    {
        Events.OnDiscard += EntityDiscard;
    }

    public void OnDisable()
    {
        Events.OnDiscard -= EntityDiscard;
    }

    public void EntityDiscard(Entity entity)
    {
        if (entity.data.cardType.tag == "Friendly")
        {
            int counter = Mathf.Max(0, redrawBellSystem.counter.current - 2);
            redrawBellSystem.SetCounter(counter);
        }
    }
}
public class RedrawBellStartChargedModifierSystem : GameSystem
{
    public void OnEnable()
    {
        Events.OnRedrawBellRevealed += RedrawBellRevealed;
    }

    public void OnDisable()
    {
        Events.OnRedrawBellRevealed -= RedrawBellRevealed;
    }

    public static void RedrawBellRevealed(RedrawBellSystem redrawBellSystem)
    {
        redrawBellSystem.SetCounter(0);
    }
}
public class ModifierSystem : GameSystem
{
    public void OnEnable()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        Events.OnCampaignInit += RunInitScripts;
        Events.OnCampaignStart += new UnityAction(AddSystems);
        Events.OnCampaignLoaded += new UnityAction(AddSystems);
        Events.OnCampaignGenerated += RunStartScripts;
    }

    public void OnDisable()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        Events.OnCampaignInit -= RunInitScripts;
        Events.OnCampaignStart -= new UnityAction(AddSystems);
        Events.OnCampaignLoaded -= new UnityAction(AddSystems);
        Events.OnCampaignGenerated -= RunStartScripts;
    }

    public static void AddModifier(CampaignData data, GameModifierData modifier)
    {
        if (data.Modifiers == null)
        {
            List<GameModifierData> list2 = (data.Modifiers = new List<GameModifierData>());
        }
        data.Modifiers.Add(modifier);
    }

    public static void RemoveModifier(CampaignData data, GameModifierData modifier)
    {
        data.Modifiers?.Remove(modifier);
    }

    public static void AddSystems()
    {
        if (Campaign.Data.Modifiers == null)
        {
            return;
        }
        foreach (GameModifierData item in Campaign.Data.Modifiers.OrderByDescending((GameModifierData m) => m.scriptPriority))
        {
            string[] systemsToAdd = item.systemsToAdd;
            foreach (string text in systemsToAdd)
            {
                if (Campaign.instance.systems.GetComponent(text) is GameSystem gameSystem)
                {
                    Debug.Log($"[{item}] enabling system: {gameSystem}");
                    ((Behaviour)gameSystem).enabled = true;
                }
                else
                {
                    Debug.Log($"[{item}] adding system: {text}");
                    GameObjectExt.AddComponentByName(Campaign.instance.systems, text);
                }
            }
        }
    }

    public static IEnumerator RunInitScripts()
    {
        return RunInitScripts(Campaign.Data.Modifiers);
    }

    public async Task RunStartScripts()
    {
        Routine routine = new Routine(RunCampaignStartScripts(Campaign.Data.Modifiers));
        while (routine.IsRunning && (this))
        {
            await Task.Delay(5);
        }
    }

    public static IEnumerator RunInitScripts(IReadOnlyCollection<GameModifierData> modifiers)
    {
        if (modifiers == null)
        {
            yield break;
        }
        Debug.Log($"Running [{modifiers.Count}] Modifier Set Up Scripts");
        foreach (GameModifierData item in modifiers.OrderByDescending((GameModifierData m) => m.scriptPriority))
        {
            Debug.Log($"Running [{item}] Setup Scripts");
            Script[] setupScripts = item.setupScripts;
            foreach (Script script in setupScripts)
            {
                yield return script.Run();
            }
        }
    }

    public static IEnumerator RunCampaignStartScripts(IReadOnlyCollection<GameModifierData> modifiers)
    {
        if (modifiers == null)
        {
            yield break;
        }
        Debug.Log($"Running [{modifiers.Count}] Modifier Campaign Start Scripts");
        foreach (GameModifierData item in modifiers.OrderByDescending((GameModifierData m) => m.scriptPriority))
        {
            Debug.Log($"Running [{item}] Campaign Start Scripts");
            Script[] startScripts = item.startScripts;
            foreach (Script script in startScripts)
            {
                yield return script.Run();
            }
        }
    }
}
public class ModifierUnlockSystem : GameSystem
{
    [Serializable]
    public struct Requirement
    {
        public string[] requiresModifiers;
    }

    [SerializeField]
    public Requirement[] requirements;
}
public class NoTargetTextSystem : GameSystem
{
    public static NoTargetTextSystem instance;

    [SerializeField]
    public AnimationCurve shakeCurve;

    [SerializeField]
    public Vector3 shakeAmount = new Vector3(1f, 0f, 0f);

    [SerializeField]
    public Vector2 shakeDurationRange = new Vector2(0.3f, 0.4f);

    [SerializeField]
    public TMP_Text textElement;

    [SerializeField]
    public Vector3 textPopOffset = new Vector3(0f, 1.5f, -1f);

    [SerializeField]
    public EventReference sfxEvent;

    [Header("Text")]
    [SerializeField]
    public LocalizedString noTargetToAttackText;

    [SerializeField]
    public LocalizedString noAlliesToHealText;

    [SerializeField]
    public LocalizedString noTargetForStatusText;

    [SerializeField]
    public LocalizedString noSpaceToSummonText;

    [SerializeField]
    public LocalizedString noCardsToDrawText;

    [SerializeField]
    public LocalizedString noAllyToBoostText;

    [SerializeField]
    public LocalizedString noEnemyToBoostText;

    [SerializeField]
    public LocalizedString requiresJunkText;

    [SerializeField]
    public LocalizedString cantSplitText;

    [SerializeField]
    public LocalizedString noSummonedAlliesText;

    [SerializeField]
    public LocalizedString playCrownCardsText;

    [SerializeField]
    public LocalizedString noAllyToAttackText;

    [SerializeField]
    public LocalizedString cantMoveText;

    public readonly Dictionary<NoTargetType, string> strings = new Dictionary<NoTargetType, string>();

    public void OnEnable()
    {
        instance = this;
        LocalizationSettings.SelectedLocaleChanged += LocaleChanged;
        PopulateStrings();
    }

    public void OnDisable()
    {
        LocalizationSettings.SelectedLocaleChanged -= LocaleChanged;
    }

    public void LocaleChanged(Locale locale)
    {
        PopulateStrings();
    }

    public void PopulateStrings()
    {
        strings.Clear();
        strings[NoTargetType.NoTargetToAttack] = noTargetToAttackText.GetLocalizedString();
        strings[NoTargetType.NoAllyToHeal] = noAlliesToHealText.GetLocalizedString();
        strings[NoTargetType.NoTargetForStatus] = noTargetForStatusText.GetLocalizedString();
        strings[NoTargetType.NoSpaceToSummon] = noSpaceToSummonText.GetLocalizedString();
        strings[NoTargetType.NoCardsToDraw] = noCardsToDrawText.GetLocalizedString();
        strings[NoTargetType.NoAllyToBoost] = noAllyToBoostText.GetLocalizedString();
        strings[NoTargetType.NoEnemyToBoost] = noEnemyToBoostText.GetLocalizedString();
        strings[NoTargetType.RequiresJunk] = requiresJunkText.GetLocalizedString();
        strings[NoTargetType.CantSplit] = cantSplitText.GetLocalizedString();
        strings[NoTargetType.NoSummonedAllies] = noSummonedAlliesText.GetLocalizedString();
        strings[NoTargetType.PlayCrownCardsFirst] = playCrownCardsText.GetLocalizedString();
        strings[NoTargetType.NoAllyToAttack] = noAllyToAttackText.GetLocalizedString();
        strings[NoTargetType.CantMove] = cantMoveText.GetLocalizedString();
    }

    public static bool Exists()
    {
        return (instance);
    }

    public static IEnumerator Run(Entity entity, NoTargetType type, params object[] args)
    {
        return instance._Run(entity, type, args);
    }

    public IEnumerator _Run(Entity entity, NoTargetType type, params object[] args)
    {
        if (enabled)
        {
            yield return Sequences.WaitForAnimationEnd(entity);
            float num = Vector2Ext.Random(shakeDurationRange);
            entity.curveAnimator.Move(Vector3Ext.WithX(shakeAmount, FloatExt.WithRandomSign(shakeAmount.x, 0.5f)), shakeCurve, 1f, num);
            textElement.text = ((type == NoTargetType.None) ? "" : StringExt.Format(strings[type], args));
            PopText(entity.transform.position);
            yield return (object)new WaitForSeconds(num);
        }
    }

    public void PopText(Vector3 fromPos)
    {
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        //IL_007e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d5: Unknown result type (might be due to invalid IL or missing references)
        GameObject obj = ((Component)textElement).gameObject;
        obj.SetActive(true);
        LeanTween.cancel(obj);
        obj.transform.position = fromPos;
        LeanTween.move(obj, fromPos + textPopOffset, 1.5f).setEaseOutElastic();
        ((Graphic)textElement).color = ColorExt.WithAlpha(((Graphic)textElement).color, 1f);
        LeanTween.value(obj, 1f, 0f, 0.2f).setDelay(1.3f).setOnUpdate(delegate (float a)
        {
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            ((Graphic)textElement).color = ColorExt.WithAlpha(((Graphic)textElement).color, a);
        })
            .setOnComplete((Action)delegate
            {
                obj.SetActive(false);
            });
        SfxSystem.OneShot(sfxEvent);
    }
}
public enum NoTargetType
{
    None,
    NoTargetToAttack,
    NoAllyBehind,
    NoAllyAhead,
    NoAlliesInRow,
    NoAllies,
    NoAllyToHeal,
    NoTargetForStatus,
    NoSpaceToSummon,
    NoCardsToDraw,
    NoAllyToBoost,
    NoEnemyToBoost,
    RequiresJunk,
    CantSplit,
    NoSummonedAllies,
    PlayCrownCardsFirst,
    NoAllyToAttack,
    CantMove
}
public class OverallStatsSystem : GameSystem
{
    public static OverallStatsSystem instance;

    [SerializeField]
    public CampaignStats stats;

    public void Awake()
    {
        instance = this;
    }

    public void OnEnable()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnCampaignEnd += CampaignEnd;
        Events.OnGameStart += new UnityAction(GameStart);
    }

    public void OnDisable()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnCampaignEnd -= CampaignEnd;
        Events.OnGameStart -= new UnityAction(GameStart);
    }

    public static CampaignStats Get()
    {
        return instance.stats;
    }

    public void GameStart()
    {
        if (SaveSystem.Enabled && SaveSystem.StatsExists() && SaveSystem.StatsDataExists("stats"))
        {
            stats = SaveSystem.LoadStatsData<CampaignStats>("stats");
        }
        else
        {
            stats = new CampaignStats();
        }
    }

    public void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
    {
        Combine(this.stats, stats);
        bool mainGameMode = Campaign.Data.GameMode.mainGameMode;
        bool dailyRun = Campaign.Data.GameMode.dailyRun;
        switch (result)
        {
            case Campaign.Result.Win:
                if (SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "trueWin", defaultValue: false))
                {
                    this.stats.Add("results", "trueWin", 1);
                    if (mainGameMode)
                    {
                        this.stats.Add("currentTrueWinStreak", 1);
                        this.stats.Max("bestTrueWinStreak", this.stats.Get("currentTrueWinStreak", 1));
                    }
                }
                else
                {
                    this.stats.Add("results", "win", 1);
                }
                if (mainGameMode)
                {
                    this.stats.Add("currentWinStreak", 1);
                    this.stats.Max("bestWinStreak", this.stats.Get("currentWinStreak", 1));
                    this.stats.Min("bestWinTime", stats.hours * 3600 + Mathf.FloorToInt(stats.time));
                }
                if (dailyRun)
                {
                    this.stats.Add("dailyRunResults", "win", 1);
                }
                this.stats.Add("winsWithTribe", playerData.classData.id, 1);
                foreach (string item in playerData.inventory.deck.Select((CardData a) => (a).name).ToHashSet())
                {
                    this.stats.Add("winsWithCardInDeck", item, 1);
                }
                break;
            case Campaign.Result.Lose:
                this.stats.Add("results", "lose", 1);
                if (mainGameMode)
                {
                    ResetWinStreak();
                }
                if (dailyRun)
                {
                    this.stats.Add("dailyRunResults", "lose", 1);
                }
                this.stats.Add("loseWithTribe", playerData.classData.id, 1);
                break;
            case Campaign.Result.Restart:
                this.stats.Add("results", "restart", 1);
                if (mainGameMode)
                {
                    ResetWinStreak();
                }
                if (dailyRun)
                {
                    this.stats.Add("dailyRunResults", "restart", 1);
                }
                this.stats.Add("loseWithTribe", playerData.classData.id, 1);
                break;
        }
        Save();
    }

    public void ResetWinStreak()
    {
        stats.Set("currentWinStreak", 0);
        stats.Set("currentTrueWinStreak", 0);
    }

    public void Save()
    {
        SaveSystem.SaveStatsData("stats", stats);
        Events.InvokeOverallStatsSaved(stats);
    }

    public static void Combine(CampaignStats stats, CampaignStats other)
    {
        stats.time += other.time;
        stats.hours += other.hours;
        if (other.add != null)
        {
            foreach (KeyValuePair<string, Dictionary<string, int>> item in other.add)
            {
                foreach (KeyValuePair<string, int> item2 in item.Value)
                {
                    Change(item.Key, item2.Key, item2.Value, ref stats.add, Add);
                }
            }
        }
        if (other.max == null)
        {
            return;
        }
        foreach (KeyValuePair<string, Dictionary<string, int>> item3 in other.max)
        {
            foreach (KeyValuePair<string, int> item4 in item3.Value)
            {
                Change(item3.Key, item4.Key, item4.Value, ref stats.max, Max);
            }
        }
    }

    public static void Change(string stat, string key, int value, ref Dictionary<string, Dictionary<string, int>> values, Func<int, int, int> action)
    {
        int num = 0;
        if (values == null)
        {
            values = new Dictionary<string, Dictionary<string, int>>();
        }
        Dictionary<string, int> dictionary;
        if (!values.ContainsKey(stat))
        {
            dictionary = new Dictionary<string, int>();
            values[stat] = dictionary;
        }
        else
        {
            Dictionary<string, int> dictionary2 = values[stat];
            if (dictionary2 != null)
            {
                dictionary = dictionary2;
            }
            else
            {
                dictionary = new Dictionary<string, int>();
                values[stat] = dictionary;
            }
        }
        if (dictionary.ContainsKey(key))
        {
            int arg = dictionary[key];
            num = action(arg, value);
        }
        else
        {
            num = value;
        }
        dictionary[key] = num;
    }

    public static int Add(int value, int add)
    {
        return value + add;
    }

    public static int Max(int value, int max)
    {
        return Mathf.Max(value, max);
    }
}
public class PlayCrownCardsFirstSystem : GameSystem
{
    public bool crownPhase;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleStart += new UnityAction(BattleStart);
        Events.OnCheckAction += CheckAction;
        Events.OnBattleTurnEnd += BattleTurnEnd;
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleStart -= new UnityAction(BattleStart);
        Events.OnCheckAction -= CheckAction;
        Events.OnBattleTurnEnd -= BattleTurnEnd;
    }

    public void BattleStart()
    {
        crownPhase = true;
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
        if (!crownPhase)
        {
            return;
        }
        PlayAction PlayAction = action;
        if (!(Playaction is ActionMove actionMove))
        {
            if (Playaction is ActionTrigger actionTrigger && !actionTrigger.entity.data.HasCrown)
            {
                allow = false;
                if (NoTargetTextSystem.Exists())
                {
                    StartCoroutine(NoTargetTextSystem.Run(actionTrigger.entity, NoTargetType.PlayCrownCardsFirst));
                }
            }
        }
        else if (!actionMove.entity.data.HasCrown && !Battle.IsOnBoard(actionMove.entity) && Battle.IsOnBoard(actionMove.toContainers))
        {
            allow = false;
            if (NoTargetTextSystem.Exists())
            {
                StartCoroutine(NoTargetTextSystem.Run(actionMove.entity, NoTargetType.PlayCrownCardsFirst));
            }
        }
    }

    public void BattleTurnEnd(int turnNumber)
    {
        crownPhase = false;
        enabled = false;
    }
}
public class PointCameraAtHoverCardSystem : GameSystem
{
    [SerializeField]
    public Transform cameraMover;

    [SerializeField]
    public bool affectInPlay = true;

    [SerializeField]
    public bool affectNotInPlay = true;

    [Header("Rotate To Face Card")]
    [SerializeField]
    [Range(0f, 1f)]
    public float aimLerp = 0.05f;

    [SerializeField]
    [Range(0f, 1f)]
    public float aimResetLerp = 0.0125f;

    [SerializeField]
    [Range(0f, 1f)]
    public float aimAmount = 0.05f;

    [Header("Pull Position Towards Card")]
    [SerializeField]
    [Range(0f, 1f)]
    public float pullLerp = 0.05f;

    [SerializeField]
    [Range(0f, 1f)]
    public float pullResetLerp = 0.0125f;

    [SerializeField]
    [Range(0f, 1f)]
    public float pullAmount = 0.05f;

    [SerializeField]
    public float pullClamp = 10f;

    public Entity current;

    public float amount;

    public readonly Quaternion originalRotation = Quaternion.identity;

    public Quaternion toRotation;

    public readonly Vector3 originalPosition = Vector3.zero;

    public Vector3 toPosition;

    public void OnEnable()
    {
        amount = Settings.Load("CameraSway", 1f);
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
        Events.OnEntityDestroyed += EntityUnHover;
        Events.OnSceneChanged += SceneChanged;
        Events.OnSettingChanged += SettingChanged;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
        Events.OnEntityDestroyed -= EntityUnHover;
        Events.OnSceneChanged -= SceneChanged;
        Events.OnSettingChanged -= SettingChanged;
    }

    public void Update()
    {
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0052: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00da: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fe: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0093: Unknown result type (might be due to invalid IL or missing references)
        //IL_009e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0121: Unknown result type (might be due to invalid IL or missing references)
        //IL_0127: Unknown result type (might be due to invalid IL or missing references)
        //IL_0132: Unknown result type (might be due to invalid IL or missing references)
        bool flag = (current);
        if (aimAmount > 0f)
        {
            if (flag)
            {
                Vector3 val = current.transform.position - cameraMover.position;
                toRotation = Quaternion.Lerp(originalRotation, Quaternion.FromToRotation(transform.forward, val), aimAmount * amount);
            }
            float num = ((!flag) ? aimResetLerp : aimLerp);
            cameraMover.rotation = Delta.Lerp(cameraMover.rotation, toRotation, num, Time.deltaTime);
        }
        if (pullAmount > 0f)
        {
            if (flag)
            {
                Vector3 val2 = Vector3.ClampMagnitude(current.transform.position, pullClamp);
                toPosition = Vector3.Lerp(originalPosition, originalPosition + val2, pullAmount * amount);
            }
            float num2 = ((!flag) ? pullResetLerp : pullLerp);
            cameraMover.localPosition = Delta.Lerp(cameraMover.localPosition, toPosition, num2, Time.deltaTime);
        }
    }

    public void EntityHover(Entity entity)
    {
        if (Check(entity))
        {
            current = entity;
        }
    }

    public void EntityUnHover(Entity entity)
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        if (current == entity)
        {
            toRotation = originalRotation;
            toPosition = originalPosition;
            current = null;
        }
    }

    public void SceneChanged(Scene scene)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        cameraMover.SetLocalPositionAndRotation(originalPosition, originalRotation);
    }

    public bool Check(Entity entity)
    {
        if (!entity.inPlay || !affectInPlay)
        {
            if (!entity.inPlay)
            {
                return affectNotInPlay;
            }
            return false;
        }
        return true;
    }

    public void SettingChanged(string key, object value)
    {
        if (key == "CameraSway" && value is float num)
        {
            amount = num;
        }
    }
}
public class PopUpAddStatsSystem : GameSystem
{
    [SerializeField]
    public LocalizedString counterRef;

    [SerializeField]
    public LocalizedString counterThisTurnRef;

    [SerializeField]
    public LocalizedString counterFrozenRef;

    [SerializeField]
    public LocalizedString reactionRef;

    [SerializeField]
    public LocalizedString reactionJoinRef;

    [SerializeField]
    public LocalizedString reactionFrozenRef;

    [SerializeField]
    public LocalizedString reactionSilencedRef;

    public Entity hover;

    public bool hoverEntityIsSnowed;

    public bool hoverEntitySilenced;

    public const string buffedColour = "#5F5";

    public const string debuffedColour = "#e8a0a0";

    public void OnEnable()
    {
        Events.OnEntityHover += HoverChanged;
        Events.OnPopupCreated += PopupCreated;
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= HoverChanged;
        Events.OnPopupCreated -= PopupCreated;
    }

    public void HoverChanged(Entity entity)
    {
        hover = entity;
        hoverEntityIsSnowed = entity.IsSnowed;
        hoverEntitySilenced = entity.silenced;
    }

    public void PopupCreated(KeywordData keyword, CardPopUpPanel panel)
    {
        if ((hover))
        {
            switch ((keyword).name)
            {
                case "Health":
                    {
                        string text3 = "<color=white>";
                        text3 = ((hover.hp.current < hover.hp.max) ? (text3 + string.Format("<color={0}>{1}</color>", "#e8a0a0", hover.hp.current)) : ((hover.hp.current <= hover.hp.max) ? (text3 + $"{hover.hp.current}") : (text3 + string.Format("<color={0}>{1}</color>", "#5F5", hover.hp.current))));
                        text3 += $"/{hover.hp.max}</color>";
                        panel.AddToTitle(text3);
                        panel.BuildTextElement();
                        break;
                    }
                case "Attack":
                    {
                        string text2 = "<color=white>";
                        int num = hover.damage.current + ((hover.tempDamage)).Value;
                        text2 = ((num < hover.damage.max) ? (text2 + string.Format("<color={0}>{1}</color>", "#e8a0a0", num)) : ((num <= hover.damage.max) ? (text2 + $"{num}") : (text2 + string.Format("<color={0}>{1}</color>", "#5F5", num))));
                        text2 += $"/{hover.damage.max}</color>";
                        panel.AddToTitle(text2);
                        panel.BuildTextElement();
                        break;
                    }
                case "Counter":
                    {
                        string text = "<color=white>";
                        text = ((hover.counter.current <= hover.counter.max) ? (text + $"{hover.counter.current}") : (text + string.Format("<color={0}>{1}</color>", "#e8a0a0", hover.counter.current)));
                        text += $"/{hover.counter.max}</color>";
                        panel.AddToTitle(text);
                        panel.AddToBody(BuildCounterBodyText(hoverEntityIsSnowed, hover.counter.current));
                        panel.BuildTextElement();
                        break;
                    }
                case "Reaction":
                    panel.AddToBody(BuildReactionBodyText(hoverEntityIsSnowed, hoverEntitySilenced));
                    panel.BuildTextElement();
                    break;
            }
        }
    }

    public string BuildCounterBodyText(bool frozen, int turnsTilTrigger)
    {
        if (!frozen)
        {
            if (turnsTilTrigger <= 1)
            {
                return counterThisTurnRef.GetLocalizedString();
            }
            return StringExt.Format(counterRef.GetLocalizedString(), new object[1] { turnsTilTrigger });
        }
        return counterFrozenRef.GetLocalizedString();
    }

    public string BuildReactionBodyText(bool frozen, bool silenced)
    {
        if (silenced)
        {
            return reactionSilencedRef.GetLocalizedString();
        }
        if (frozen)
        {
            return reactionFrozenRef.GetLocalizedString();
        }
        List<string> list = new List<string>();
        foreach (StatusEffectData statusEffect in hover.statusEffects)
        {
            if (statusEffect.isReaction && !((LocalizedReference)statusEffect.textKey).IsEmpty)
            {
                list.Add(FormatReactionText(statusEffect));
            }
        }
        foreach (Entity.TraitStacks trait in hover.traits)
        {
            if (trait.data.isReaction)
            {
                list.Add("<" + FirstCharToLowerCase(trait.data.keyword.body) + ">");
            }
        }
        return StringExt.Format(reactionRef.GetLocalizedString(), new object[1] { string.Join(reactionJoinRef.GetLocalizedString(), list) });
    }

    public static string FormatReactionText(StatusEffectData effect)
    {
        string text = Text.GetEffectText(effect.textKey, effect.textInsert, effect.count);
        for (int i = 0; i < text.Length; i++)
        {
            if (text[i] != '<')
            {
                continue;
            }
            int num = text.IndexOf('>', i);
            string text2 = text.Substring(i + 1, num - i - 1);
            string text3 = text2;
            if (text2.Contains('='))
            {
                string[] array = text2.Split('=');
                string text4 = array[0].Trim();
                if (!(text4 == "keyword"))
                {
                    if (text4 == "card")
                    {
                        string assetName = array[1].Trim();
                        text3 = AddressableLoader.Get<CardData>("CardData", assetName).title;
                    }
                }
                else
                {
                    KeywordData keywordData = Text.ToKeyword(array[1]);
                    text3 = ((!StringExt.IsNullOrWhitespace(keywordData.iconName)) ? ("><sprite name=" + keywordData.iconName + "><") : keywordData.title);
                }
            }
            text = text.Replace(text.Substring(i, num - i + 1), text3);
            i += text3.Length;
        }
        return ("<" + FirstCharToLowerCase(text) + ">").Replace("<>", "");
    }

    public static string FirstCharToLowerCase(string str)
    {
        if (char.IsUpper(str[0]))
        {
            if (str.Length != 1)
            {
                return char.ToLower(str[0]) + str[1..];
            }
            return str.ToLower();
        }
        return str;
    }
}
public class ProgressSystem : GameSystem
{
}
public class Prompt : MonoBehaviourRect
{
    public delegate string GetTextCallback();

    public enum Anchor
    {
        Mid,
        Top,
        Left,
        Right,
        Bottom,
        TopLeft,
        TopRight,
        BottomLeft,
        BottomRight
    }

    [Serializable]
    public struct Emote
    {
        public enum Type
        {
            None,
            Basic,
            Point,
            Scared,
            Talk,
            Explain,
            Sad,
            Happy
        }

        public enum Position
        {
            Left,
            Right,
            Above,
            Below
        }

        public Type type;

        public Sprite sprite;
    }

    [SerializeField]
    public TMP_Text textAsset;

    [SerializeField]
    public LayoutElement layoutElement;

    [SerializeField]
    public RectTransform textBox;

    [SerializeField]
    public float noteSize = 0.3f;

    [SerializeField]
    public string noteColorHex = "fffa";

    [SerializeField]
    public Emote[] emotes;

    [SerializeField]
    public Image emoteImage;

    [SerializeField]
    public string focusFormat = "<#fff>{0}</color>";

    public GetTextCallback SetTextAction;

    public float width;

    public Emote.Type emoteType;

    public Emote.Position emotePosition;

    public bool active { get; set; }

    public void OnEnable()
    {
        LocalizationSettings.Instance.OnSelectedLocaleChanged += LocaleChanged;
    }

    public void OnDisable()
    {
        LocalizationSettings.Instance.OnSelectedLocaleChanged -= LocaleChanged;
    }

    public void LocaleChanged(Locale locale)
    {
        RunSetTextAction();
    }

    public void RunSetTextAction()
    {
        SetText(SetTextAction?.Invoke());
    }

    public void SetAnchor(Anchor anchor)
    {
        switch (anchor)
        {
            case Anchor.Mid:
                SetAnchor(0.5f, 0.5f);
                break;
            case Anchor.Top:
                SetAnchor(0.5f, 1f);
                break;
            case Anchor.Left:
                SetAnchor(0f, 0.5f);
                break;
            case Anchor.Right:
                SetAnchor(1f, 0.5f);
                break;
            case Anchor.Bottom:
                SetAnchor(0.5f, 0f);
                break;
            case Anchor.TopLeft:
                SetAnchor(0f, 1f);
                break;
            case Anchor.TopRight:
                SetAnchor(1f, 1f);
                break;
            case Anchor.BottomLeft:
                SetAnchor(0f, 0f);
                break;
            case Anchor.BottomRight:
                SetAnchor(1f, 0f);
                break;
            default:
                throw new ArgumentException($"Invalid Anchor {anchor}");
        }
    }

    public void SetAnchor(float x, float y)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        SetAnchor(new Vector2(x, y));
    }

    public void SetAnchor(Vector2 anchor)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        base.rectTransform.anchorMin = anchor;
        base.rectTransform.anchorMax = anchor;
        base.rectTransform.pivot = anchor;
    }

    public void SetPosition(Vector2 position)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        base.rectTransform.anchoredPosition = position;
    }

    public void SetPosition(Vector2 position, Anchor anchor)
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        SetAnchor(anchor);
        base.rectTransform.anchoredPosition = position;
    }

    public void SetMaxWidth(float value)
    {
        layoutElement.preferredWidth = value;
        width = value;
    }

    public void SetText(string text)
    {
        float result = 0f;
        int num = text.IndexOf('+');
        if (num >= 0)
        {
            string s = text.Substring(num + 1);
            text = text.Substring(0, num);
            float.TryParse(s, out result);
        }
        layoutElement.preferredWidth = width + result;
        string note = "";
        if (text.Contains("|"))
        {
            int num2 = text.IndexOf('|');
            note = text.Substring(num2 + 1);
            text = text.Substring(0, num2);
        }
        SetText(ProcessText(text), note);
        SetEmote(emoteType, emotePosition);
    }

    public void SetText(string text, string note = "")
    {
        if (!StringExt.IsNullOrWhitespace(note))
        {
            text += $"\n\n<size={noteSize}><#{noteColorHex}>{note}";
        }
        textAsset.text = text;
    }

    public string ProcessText(string input)
    {
        string text = input.Trim();
        _ = input.Length;
        while (true)
        {
            int num = text.IndexOf('[');
            if (num < 0)
            {
                break;
            }
            int num2 = text.IndexOf(']', num);
            if (num2 <= num)
            {
                break;
            }
            string tag = text.Substring(num, num2 - num).Substring(1, num2 - num - 1);
            string text2 = ProcessTag(tag);
            string text3 = text.Substring(0, num);
            string text4 = text.Substring(num2 + 1);
            text = text3 + text2 + text4;
        }
        return text;
    }

    public string ProcessTag(string tag)
    {
        return string.Format(focusFormat, tag);
    }

    public void SetEmote(Emote.Type emoteType, Emote.Position position)
    {
        this.emoteType = emoteType;
        emotePosition = position;
        Emote emote = emotes.FirstOrDefault((Emote e) => e.type == emoteType);
        if ((emote.sprite))
        {
            ((Component)emoteImage).gameObject.SetActive(true);
            emoteImage.sprite = emote.sprite;
            SetEmotePosition(position);
        }
        else
        {
            ((Component)emoteImage).gameObject.SetActive(false);
        }
    }

    public void SetEmotePosition(Emote.Position position, float offsetX = 0f, float offsetY = 0f, float forceFlip = 0f)
    {
        StopAllCoroutines();
        StartCoroutine(SetEmotePositionRoutine(position, offsetX, offsetY, forceFlip));
    }

    public IEnumerator SetEmotePositionRoutine(Emote.Position position, float offsetX = 0f, float offsetY = 0f, float forceFlip = 0f)
    {
        Rect rect = textBox.rect;
        while (rect == textBox.rect)
        {
            yield return null;
        }
        rect = textBox.rect;
        float num = ((rect)).width * 0.5f + 0.1f;
        float num2 = ((rect)).height * 0.5f + 0.69f;
        RectTransform val = (RectTransform)((Component)emoteImage).transform;
        switch (position)
        {
            case Emote.Position.Left:
                val.anchoredPosition = new Vector2(0f - num + offsetX, 0f + offsetY);
                break;
            case Emote.Position.Right:
                val.anchoredPosition = new Vector2(num + offsetX, 0f + offsetY);
                break;
            case Emote.Position.Above:
                val.anchoredPosition = new Vector2((0f - num) * 0.5f + offsetX, num2 + offsetY);
                break;
            case Emote.Position.Below:
                val.anchoredPosition = new Vector2(0f + offsetX, 0f - num2 + offsetY);
                break;
        }
        float num3 = ((forceFlip != 0f) ? forceFlip : ((((Transform)val).position.x < 0f) ? 1f : (-1f)));
        ((Transform)val).localScale = new Vector3(num3, 1f, 1f);
    }

    public void Ping()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(gameObject);
        transform.localScale = Vector3.one * 0f;
        LeanTween.scale(gameObject, Vector3.one, 1.5f).setEase(LeanTweenType.easeOutElastic);
    }

    public void Hide()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        active = false;
        LeanTween.cancel(gameObject);
        transform.localScale = Vector3.one;
        LeanTween.scale(gameObject, Vector3.zero, 0.167f).setEase(LeanTweenType.easeInBack).setOnComplete((Action)delegate
        {
            gameObject.SetActive(false);
        });
    }

    public void Enable()
    {
        active = true;
        gameObject.SetActive(true);
    }
}
public class PromptSystem : GameSystem
{
    public static PromptSystem instance;

    [SerializeField]
    public Prompt prompt;

    [SerializeField]
    public EventReference popUpSfx;

    [SerializeField]
    public EventReference denySfx;

    public static Prompt Prompt => instance.prompt;

    public static void SetSortingLayer(string layerName, int sortingOrder)
    {
        Canvas component = ((Component)instance).GetComponent<Canvas>();
        if ((component))
        {
            component.sortingLayerName = layerName;
            component.sortingOrder = sortingOrder;
        }
    }

    public void OnEnable()
    {
        Events.OnSceneChanged += SceneChanged;
        instance = this;
    }

    public void OnDisable()
    {
        Events.OnSceneChanged -= SceneChanged;
    }

    public void SceneChanged(Scene scene)
    {
        if ((prompt) && ((Component)prompt).gameObject.activeSelf)
        {
            ((Component)prompt).gameObject.SetActive(false);
        }
    }

    public static void Create(Prompt.Anchor anchor, Vector2 anchoredPosition, float maxWidth, Prompt.Emote.Type emoteType = Prompt.Emote.Type.Basic, Prompt.Emote.Position emotePosition = Prompt.Emote.Position.Above)
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        if ((instance))
        {
            instance.DoCreate(anchor, anchoredPosition, maxWidth, emoteType, emotePosition);
        }
    }

    public static void Create(Prompt.Anchor anchor, float x, float y, float maxWidth, Prompt.Emote.Type emoteType = Prompt.Emote.Type.Basic, Prompt.Emote.Position emotePosition = Prompt.Emote.Position.Above)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        Create(anchor, new Vector2(x, y), maxWidth, emoteType, emotePosition);
    }

    public static void SetTextAction(Prompt.GetTextCallback action)
    {
        Prompt.SetTextSystem.Action = action;
        Prompt.RunSetTextAction();
    }

    public void DoCreate(Prompt.Anchor anchor, Vector2 anchoredPosition, float maxWidth, Prompt.Emote.Type emoteType = Prompt.Emote.Type.Basic, Prompt.Emote.Position emotePosition = Prompt.Emote.Position.Above)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        prompt.Enable();
        prompt.SetPosition(anchoredPosition, anchor);
        prompt.SetMaxWidth(maxWidth);
        prompt.SetEmote(emoteType, emotePosition);
        prompt.Ping();
        SfxSystem.OneShot(popUpSfx);
        SfxSystem.OneShot("event:/sfx/map/location_showup");
    }

    public static void Hide()
    {
        Object.FindObjectOfType<PromptSystem>()?.DoHide();
    }

    public void DoHide()
    {
        if ((prompt) && prompt.active)
        {
            prompt.Hide();
        }
    }

    public static void Shake()
    {
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        if ((instance))
        {
            GameObject gameObject = ((Component)instance).gameObject;
            LeanTween.cancel(gameObject);
            gameObject.transform.localPosition = new Vector3(0.25f, 0f, -3f);
            LeanTween.moveLocal(gameObject, new Vector3(0f, 0f, -3f), 1f).setEase(LeanTweenType.easeOutElastic);
            SfxSystem.OneShot(instance.denySfx);
        }
    }
}
public class RedrawBellSystem : GameSystem
{
    public RectTransform _rectTransform;

    [SerializeField]
    public GameObject bell;

    [SerializeField]
    public GameObject bellActive;

    [SerializeField]
    public ParticleSystem chargeParticleSystem;

    [SerializeField]
    public ParticleSystem hitParticleSystem;

    [SerializeField]
    public UINavigationItem navigationItem;

    [Header("Counter")]
    [SerializeField]
    public int counterChange = -1;

    [SerializeField]
    public StatusIcon counterIcon;

    [Header("Keyword Popup")]
    [SerializeField]
    public KeywordData popUpKeyword;

    [SerializeField]
    public Vector2 popUpOffset = new Vector2(-1f, -1f);

    [SerializeField]
    public LocalizedString textNotCharged;

    [SerializeField]
    public LocalizedString textCharged;

    public Animator _animator;

    public Character owner;

    public CardController controller;

    public Stat counter;

    public bool reset;

    [HideInInspector]
    public bool interactable;

    public bool poppedUp;

    public static UINavigationItem nav;

    public RectTransform rectTransform
    {
        get
        {
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            //IL_0018: Expected O, but got Unknown
            //IL_001d: Expected O, but got Unknown
            RectTransform obj = _rectTransform;
            if (obj == null)
            {
                RectTransform val = (RectTransform)transform;
                RectTransform val2 = val;
                _rectTransform = val;
                obj = val2;
            }
            return obj;
        }
    }

    public Animator animator => _animator ?? (_animator = GetComponent<Animator>());

    public bool IsCharged => counter.current <= 0;

    public void OnEnable()
    {
        nav = navigationItem;
        Events.OnSceneChanged += SceneChanged;
        Events.OnBattlePhaseStart += BattlePhaseStart;
        Events.OnBattleTurnEnd += CounterIncrement;
    }

    public void OnDisable()
    {
        Events.OnSceneChanged -= SceneChanged;
        Events.OnBattlePhaseStart -= BattlePhaseStart;
        Events.OnBattleTurnEnd -= CounterIncrement;
    }

    public void BecomeInteractable()
    {
        if (!interactable)
        {
            interactable = true;
            Assign(Battle.instance.player, Battle.instance.playerCardController);
            Show();
        }
    }

    public void Show()
    {
        bell.SetActive(true);
        interactable = true;
        reset = false;
        counter.max = owner.data.redrawBell;
        SetCounter(counter.max);
        Events.InvokeRedrawBellRevealed(this);
        AnimatorTrigger("Enter");
        SfxSystem.OneShot("event:/sfx/inventory/redraw_bell_showup");
    }

    public void Hide()
    {
        bell.SetActive(false);
        interactable = false;
        if (poppedUp)
        {
            UnPop();
        }
        bellActive.SetActive(false);
    }

    public void SceneChanged(Scene scene)
    {
        if (interactable && ((scene)).name != "Battle")
        {
            Hide();
        }
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        switch (phase)
        {
            case Battle.Phase.Play:
                BecomeInteractable();
                break;
            case Battle.Phase.End:
                Hide();
                break;
        }
    }

    public void CounterIncrement(int turnNumber)
    {
        if (Battle.instance.phase != Battle.Phase.End)
        {
            Counter();
        }
    }

    public void Assign(Character owner, CardController controller)
    {
        this.owner = owner;
        this.controller = controller;
        GetComponentInChildren<ToggleBasedOnCardController>(true)?.AssignCardController(controller);
    }

    public void Activate()
    {
        if (!interactable)
        {
            return;
        }
        int handSize = Events.GetHandSize(References.PlayerData.handSize);
        ActionRedraw action = new ActionRedraw(owner, handSize);
        if (Events.CheckAction(action))
        {
            ActionQueue.Add(action);
            ActionQueue.Add(new ActionEndTurn(owner));
            controller.Disable();
            if (IsCharged)
            {
                owner.freeAction = true;
                reset = false;
            }
            else
            {
                reset = true;
            }
            Events.InvokeRedrawBellHit(this);
            SfxSystem.OneShot("event:/sfx/inventory/redraw_bell_use");
            SetCounter(counter.max);
            AnimatorTrigger("Ring");
            Events.InvokeScreenShake(1f, 0f);
            Events.InvokeUINavigationReset();
            hitParticleSystem.Play();
        }
    }

    public void Counter()
    {
        if (reset)
        {
            reset = false;
            return;
        }
        int num = Mathf.Clamp(counter.current + counterChange, 0, counter.max);
        if (num != counter.current)
        {
            SetCounter(num);
            AnimatorTrigger("Shake");
            SfxSystem.OneShot("event:/sfx/inventory/redraw_bell_countdown");
        }
    }

    public void SetCounter(int value)
    {
        bool isCharged = IsCharged;
        counter.current = value;
        if ((counterIcon))
        {
            counterIcon.SetValue(counter);
        }
        animator.SetBool("Charged", IsCharged);
        if (!isCharged && IsCharged)
        {
            SfxSystem.OneShot("event:/sfx/inventory/redraw_bell_charged");
        }
    }

    public void Pop()
    {
        if (!poppedUp && (popUpKeyword))
        {
            int handSize = Events.GetHandSize(References.PlayerData.handSize);
            string text = StringExt.Format(popUpKeyword.body, new object[1] { handSize });
            text += (IsCharged ? ("\n\n" + textCharged.GetLocalizedString()) : ("\n\n" + textNotCharged.GetLocalizedString()));
            CardPopUp.AssignTo(rectTransform, popUpOffset.x, popUpOffset.y);
            CardPopUp.AddPanel(popUpKeyword, text);
            poppedUp = true;
        }
    }

    public void UnPop()
    {
        if (poppedUp)
        {
            CardPopUp.RemovePanel((popUpKeyword).name);
            poppedUp = false;
        }
    }

    public void AnimatorTrigger(string name)
    {
        animator.SetTrigger(name);
    }

    public void AnimatorSetHover(bool value)
    {
        animator.SetBool("Hover", value);
    }

    public void AnimatorSetPress(bool value)
    {
        animator.SetBool("Press", value);
    }

    public void PlayChargeParticleSystem()
    {
        chargeParticleSystem.Play();
    }
}
public class RenameMidBattleSystem : MonoBehaviour
{
    public void OnEnable()
    {
        Events.OnRename += Rename;
    }

    public void OnDisable()
    {
        Events.OnRename -= Rename;
    }

    public void Rename(Entity entity, string newName)
    {
        foreach (Entity card2 in References.Battle.cards)
        {
            if (card2.inPlay && card2.data.id == entity.data.id && card2.display is Card card)
            {
                card.SetName(newName);
            }
        }
    }
}
public class RunHistorySystem : GameSystem
{
    public const int max = 50;

    public void OnEnable()
    {
        Events.OnCampaignEnd += CampaignEnd;
    }

    public void OnDisable()
    {
        Events.OnCampaignEnd -= CampaignEnd;
    }

    public static void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
    {
        Debug.Log("Saving Run History...");
        List<RunHistory> list = SaveSystem.LoadHistoryData<List<RunHistory>>("list") ?? new List<RunHistory>();
        list.Add(new RunHistory(Campaign.Data.GameMode, result, stats, playerData));
        if (list.Count > 50)
        {
            list.RemoveAt(0);
        }
        SaveSystem.SaveHistoryData("list", list);
        Debug.Log("Run History Saved!");
    }
}
public class BattleSaveSystem : GameSystem
{
    public static BattleSaveSystem instance;

    public bool loading;

    public bool justLoaded;

    public BattleSaveData state;

    public bool saveRequired;

    public bool campaignNodeIdSet;

    public int campaignNodeId;

    public void OnEnable()
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Expected O, but got Unknown
        instance = this;
        Events.OnBattlePreTurnStart += BattleTurnEnd;
        Events.OnCampaignFinal += new UnityAction(CampaignFinal);
    }

    public void OnDisable()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnBattlePreTurnStart -= BattleTurnEnd;
        Events.OnCampaignFinal -= new UnityAction(CampaignFinal);
    }

    public void OnApplicationQuit()
    {
        CheckSave();
    }

    public static BattleSaveData GetBattleState()
    {
        return instance.state;
    }

    public void BattleTurnEnd(int turnCount)
    {
        if (justLoaded)
        {
            justLoaded = false;
            return;
        }
        BuildBattleState();
        saveRequired = true;
    }

    public void CampaignFinal()
    {
        CheckSave();
    }

    public void CheckSave()
    {
        if (saveRequired && !loading)
        {
            if (Campaign.Data.GameMode.doSave)
            {
                Save();
            }
            Events.InvokeBattleSaved();
            Events.InvokeCampaignSaved();
            saveRequired = false;
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Save()
    {
        if (state == null)
        {
            Debug.LogWarning("Cannot save Battle State right now!");
            return;
        }
        Debug.Log("> Saving Battle State...");
        SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "battleState", state);
    }

    public void BuildBattleState()
    {
        Events.InvokeBattleStateBuild();
        StopWatch.Start();
        if (!campaignNodeIdSet)
        {
            campaignNodeId = Campaign.FindCharacterNode(References.Battle.player).id;
        }
        state = new BattleSaveData
        {
            gold = ((References.PlayerData.inventory.gold)).Value + References.PlayerData.inventory.goldOwed,
            campaignNodeId = campaignNodeId,
            turnCount = References.Battle.turnCount + 1,
            statuses = (from e in StatusEffectSystem.activeEffects
                        where (e) && e.count > e.temporary && (e.target) && e.target.alive
                        select new BattleSaveData.Status(e)).ToArray()
        };
        foreach (StatusEffectData activeEffect in StatusEffectSystem.activeEffects)
        {
            object midBattleData = activeEffect.GetMidBattleData();
            if (midBattleData != null)
            {
                string key = $"{activeEffect.target.data.id}{(activeEffect).name}";
                state.storeStatusData[key] = midBattleData;
            }
        }
        RedrawBellSystem redrawBellSystem = Object.FindObjectOfType<RedrawBellSystem>();
        if (redrawBellSystem != null)
        {
            state.redrawBellCount = redrawBellSystem.counter.current;
        }
        WaveDeploySystemOverflow waveDeploySystemOverflow = Object.FindObjectOfType<WaveDeploySystemOverflow>();
        if (waveDeploySystemOverflow != null)
        {
            state.enemyWaves = waveDeploySystemOverflow.Save();
        }
        BattleMusicSystem battleMusicSystem = Object.FindObjectOfType<BattleMusicSystem>();
        if (battleMusicSystem != null)
        {
            state.battleMusicState = battleMusicSystem.Save();
        }
        state.playerRows = new BattleSaveData.ContainerGroup(References.Battle.GetRows(References.Battle.player));
        state.enemyRows = new BattleSaveData.ContainerGroup(References.Battle.GetRows(References.Battle.enemy));
        state.playerHand = new BattleSaveData.Container(References.Battle.player.handContainer);
        state.playerDraw = new BattleSaveData.Container(References.Battle.player.drawContainer);
        state.playerDiscard = new BattleSaveData.Container(References.Battle.player.discardContainer);
        state.playerReserve = new BattleSaveData.Container(References.Battle.player.reserveContainer);
        state.enemyReserve = new BattleSaveData.Container(References.Battle.enemy.reserveContainer);
        Debug.Log($"> Battle State Built ({StopWatch.Stop()}ms)");
        Events.InvokeBattleStateBuilt(state);
    }

    public bool TryLoadBattleState(CampaignNode campaignNode)
    {
        state = SaveSystem.LoadCampaignData<BattleSaveData>(Campaign.Data.GameMode, "battleState", null);
        if (state == null)
        {
            return false;
        }
        if (state.campaignNodeId != campaignNode.id)
        {
            state = null;
            return false;
        }
        return true;
    }

    public bool TryLoadBattleState(BattleSaveData state)
    {
        this.state = state;
        return state != null;
    }

    public IEnumerator LoadRoutine()
    {
        loading = true;
        References.Battle.loadMidBattle = true;
        References.Battle.turnCount = state.turnCount;
        ((References.PlayerData.inventory.gold)).Value = state.gold;
        References.Player.entity.PromptUpdate();
        Object.FindObjectOfType<BattleMusicSystem>()?.Load(state.battleMusicState);
        Routine.Clump clump = new Routine.Clump();
        CardSlotLane[] rows = References.Battle.GetRows(References.Battle.player).Cast<CardSlotLane>().ToArray();
        clump.Add(CreateCardsInRows(rows, state.playerRows.containers));
        CardSlotLane[] rows2 = References.Battle.GetRows(References.Battle.enemy).Cast<CardSlotLane>().ToArray();
        clump.Add(CreateCardsInRows(rows2, state.enemyRows.containers));
        clump.Add(CreateCards(References.Battle.player.handContainer, state.playerHand.cards));
        clump.Add(CreateCards(References.Battle.player.drawContainer, state.playerDraw.cards));
        clump.Add(CreateCards(References.Battle.player.discardContainer, state.playerDiscard.cards));
        clump.Add(CreateCards(References.Battle.player.reserveContainer, state.playerReserve.cards));
        clump.Add(CreateCards(References.Battle.enemy.reserveContainer, state.enemyReserve.cards));
        yield return clump.WaitForEnd();
        BattleSaveData.Status[] statuses = state.statuses;
        foreach (BattleSaveData.Status status in statuses)
        {
            Entity entity = References.Battle.cards.FirstOrDefault((Entity a) => a.data.id == status.targetId);
            if (!(entity))
            {
                Debug.LogError($"No Entity[{status.targetId}] found for Status ({status.name} {status.count})");
                continue;
            }
            entity.display.promptUpdateDescription = true;
            Entity applier = References.Battle.cards.FirstOrDefault((Entity a) => a.data.id == status.applierId);
            StatusEffectData statusEffectData = AddressableLoader.Get<StatusEffectData>("StatusEffectData", status.name);
            if ((statusEffectData))
            {
                yield return StatusEffectSystem.Apply(entity, applier, statusEffectData, status.count, temporary: false, null, fireEvents: false);
            }
            else
            {
                Debug.LogError($"Effect [{status.name}] not found for target ({(entity.data).name} {status.targetId})");
            }
        }
        foreach (Entity card in References.Battle.cards)
        {
            yield return UpdateCard(card, state.storeStatusData);
        }
        Object.FindObjectOfType<WaveDeploySystemOverflow>()?.Load(state.enemyWaves, (IReadOnlyCollection<CardData>)(object)References.Battle.cards.Select((Entity a) => a.data).ToArray());
        RedrawBellSystem redrawBellSystem = Object.FindObjectOfType<RedrawBellSystem>();
        if (redrawBellSystem != null)
        {
            redrawBellSystem.BecomeInteractable();
            redrawBellSystem.SetCounter(state.redrawBellCount);
        }
        Events.InvokeBattleLoaded();
        justLoaded = true;
        loading = false;
    }

    public static IEnumerator CreateCardsInRows(IReadOnlyList<CardSlotLane> rows, IReadOnlyList<BattleSaveData.Container> rowSaveDatas)
    {
        Dictionary<ulong, Entity> entities = new Dictionary<ulong, Entity>();
        CardController cardController = References.Battle.playerCardController;
        Routine.Clump clump = new Routine.Clump();
        for (int rowI = 0; rowI < rows.Count; rowI++)
        {
            CardSlotLane row = rows[rowI];
            BattleEntityData[] cards = rowSaveDatas[rowI].cards;
            for (int i = 0; i < cards.Length; i++)
            {
                BattleEntityData d = cards[i];
                if (d == null)
                {
                    continue;
                }
                if (!entities.ContainsKey(d.cardSaveData.id))
                {
                    entities.Add(d.cardSaveData.id, null);
                    int entityIndex = i;
                    clump.Add(CreateCard(d, cardController, row.owner, delegate (Card a)
                    {
                        entities[d.cardSaveData.id] = a.entity;
                        row.slots[entityIndex].Add(a.entity);
                    }));
                }
                else
                {
                    row.slots[i].Add(entities[d.cardSaveData.id]);
                }
            }
            yield return clump.WaitForEnd();
        }
        foreach (Entity value in entities.Values)
        {
            value.containers[0].TweenChildPosition(value);
        }
    }

    public static IEnumerator CreateCards(CardContainer container, IReadOnlyList<BattleEntityData> entitySaveData)
    {
        Character owner = container.owner;
        CardController playerCardController = References.Battle.playerCardController;
        Routine.Clump clump = new Routine.Clump();
        Entity[] entities = new Entity[entitySaveData.Count];
        for (int i = 0; i < entitySaveData.Count; i++)
        {
            BattleEntityData battleEntityData = entitySaveData[i];
            if (battleEntityData != null)
            {
                int arrayIndex = i;
                clump.Add(CreateCard(battleEntityData, playerCardController, owner, delegate (Card a)
                {
                    entities[arrayIndex] = a.entity;
                }));
            }
        }
        yield return clump.WaitForEnd();
        Entity[] array = entities;
        foreach (Entity entity in array)
        {
            container.Add(entity);
        }
        container.SetChildPositions();
    }

    public static IEnumerator CreateCard(BattleEntityData entityData, CardController cardController, Character owner, UnityAction<Card> onComplete)
    {
        Card card = CardManager.Get(entityData.cardSaveData.Load(), cardController, owner, inPlay: true, owner.team == References.Player.team);
        Entity entity = card.entity;
        entity.startingEffectsApplied = true;
        entity.alive = false;
        if (entityData.flipped)
        {
            entity.flipper.FlipDownInstant();
        }
        entity.attackEffects = entityData.attackEffects.Select((StatusEffectSaveData e) => e.Load()).ToList();
        entity.traits.Clear();
        foreach (CardData.TraitStacks trait in entity.data.traits)
        {
            if ((trait.data))
            {
                entity.traits.Add(new Entity.TraitStacks(trait.data, trait.count));
            }
        }
        onComplete?.Invoke(card);
        if (!entityData.flipped)
        {
            ((Behaviour)entity).enabled = true;
        }
        yield return card.UpdateData();
        entity.height = entityData.height;
        entity.damage.current = entityData.damage;
        entity.damage.max = entityData.damageMax;
        entity.hp.current = entityData.hp;
        entity.hp.max = entityData.hpMax;
        entity.counter.current = entityData.counter;
        entity.counter.max = entityData.counterMax;
        entity.uses.current = entityData.uses;
        entity.uses.max = entityData.usesMax;
    }

    public static IEnumerator UpdateCard(Entity card, IReadOnlyDictionary<string, object> customDatas)
    {
        card.alive = true;
        yield return card.UpdateTraits();
        if (customDatas != null)
        {
            foreach (StatusEffectData statusEffect in card.statusEffects)
            {
                if (customDatas.TryGetValue($"{card.data.id}{(statusEffect).name}", out var value))
                {
                    statusEffect.RestoreMidBattleData(value);
                }
            }
        }
        if (((Behaviour)card).enabled)
        {
            Events.InvokeEntityEnabled(card);
            yield return StatusEffectSystem.EntityEnableEvent(card);
        }
        else
        {
            CoroutineManager.Start(card.display.UpdateDisplay());
        }
        card.PromptUpdate();
    }
}
public class SaveBackupSystem : GameSystem
{
    public const float backupCampaignTimer = 5f;

    public static float backupCampaignCooldown = 5f;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnCampaignStart += new UnityAction(CampaignStart);
        Events.OnCampaignSaved += new UnityAction(CampaignSaved);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        Events.OnCampaignStart -= new UnityAction(CampaignStart);
        Events.OnCampaignSaved -= new UnityAction(CampaignSaved);
    }

    public void Update()
    {
        if (backupCampaignCooldown > 0f)
        {
            backupCampaignCooldown -= Time.unscaledDeltaTime;
        }
    }

    public static void CampaignStart()
    {
        string text = SaveSystem.folderName + "/";
        Backup(text + "Save.sav");
        Backup(text + "Stats.sav");
        Backup(text + "History.sav");
    }

    public static void CampaignSaved()
    {
        if (!(backupCampaignCooldown > 0f) && (References.Campaign) && Campaign.Data.GameMode.doSave)
        {
            Backup(string.Concat(SaveSystem.folderName + "/", "Campaign", Campaign.Data.GameMode.saveFileName, ".sav"));
            backupCampaignCooldown = 5f;
        }
    }

    public static void Backup(string filePath)
    {
        StopWatch.Start();
        ES3.CreateBackup(filePath, SaveSystem.settings);
        Debug.Log($"Backup Created ({filePath}) ({StopWatch.Stop()} ms)");
    }
}
public class SaveFileChecker : MonoBehaviour
{
    public static bool saveRequired;

    public void Start()
    {
        Debug.Log("~SAVE FILE CHECKER~");
        List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
        GainUnlocksFromCompletedChallenges(unlockedList);
        CheckChallengeUnlocks(unlockedList);
        CheckUnlockRequirements(unlockedList);
        saveRequired = IListExt.RemoveDuplicates<string>(unlockedList) || saveRequired;
        if (saveRequired)
        {
            SaveSystem.SaveProgressData("unlocked", unlockedList);
        }
    }

    public static void GainUnlocksFromCompletedChallenges(List<string> unlocksList)
    {
        IEnumerable<ChallengeData> allChallenges = ChallengeSystem.GetAllChallenges();
        List<string> list = SaveSystem.LoadProgressData("completedChallenges", new List<string>());
        HashSet<string> hashSet = new HashSet<string>();
        foreach (string challengeName in list)
        {
            ChallengeData challengeData = allChallenges.FirstOrDefault((ChallengeData a) => (a).name == challengeName);
            if (challengeData != null)
            {
                UnlockData reward = challengeData.reward;
                if (reward != null)
                {
                    HashSetExt.AddRange<string>(hashSet, (IEnumerable<string>)GetUnlockAndRequirements(reward));
                }
            }
        }
        if (hashSet.Count <= 0)
        {
            return;
        }
        foreach (string item in hashSet.Where((string add) => !unlocksList.Contains(add)))
        {
            unlocksList.Add(item);
        }
    }

    public static HashSet<string> GetUnlockAndRequirements(UnlockData unlockData)
    {
        HashSet<string> hashSet = new HashSet<string> { (unlockData).name };
        UnlockData[] requires = unlockData.requires;
        foreach (UnlockData unlockData2 in requires)
        {
            HashSetExt.AddRange<string>(hashSet, (IEnumerable<string>)GetUnlockAndRequirements(unlockData2));
        }
        saveRequired = true;
        return hashSet;
    }

    public static void CheckChallengeUnlocks(List<string> unlocksList)
    {
        List<string> completedChallenges = SaveSystem.LoadProgressData("completedChallenges", new List<string>());
        ChallengeData[] array = (from a in ChallengeSystem.GetAllChallenges()
                                 where !completedChallenges.Contains((a).name)
                                 select a).ToArray();
        List<string> removed = new List<string>();
        ChallengeData[] array2 = array;
        foreach (ChallengeData challengeData in array2)
        {
            if (unlocksList.Remove((challengeData.reward).name))
            {
                removed.Add((challengeData.reward).name);
                Debug.Log(("[" + (challengeData.reward).name + "] removed from unlocks since [" + (challengeData).name + "] is not completed"));
            }
        }
        if (removed.Count > 0)
        {
            saveRequired = true;
            List<string> source = SaveSystem.LoadProgressData("inventorHutUnlocks", new List<string>());
            SaveSystem.SaveProgressData("inventorHutUnlocks", source.Where((string a) => !removed.Contains(a)).ToList());
            List<string> source2 = SaveSystem.LoadProgressData("petHutUnlocks", new List<string>());
            SaveSystem.SaveProgressData("petHutUnlocks", source2.Where((string a) => !removed.Contains(a)).ToList());
        }
    }

    public static void CheckUnlockRequirements(List<string> unlocksList)
    {
        bool flag = true;
        while (flag)
        {
            flag = false;
            for (int num = unlocksList.Count - 1; num >= 0; num--)
            {
                string text = unlocksList[num];
                UnlockData unlockData = AddressableLoader.Get<UnlockData>("UnlockData", text);
                if (unlockData == null)
                {
                    Debug.Log(("[" + text + "] no longer exists. removing from save data"));
                    unlocksList.RemoveAt(num);
                    flag = true;
                    saveRequired = true;
                }
                else if (unlockData.requires != null && unlockData.requires.Length != 0)
                {
                    UnlockData[] requires = unlockData.requires;
                    foreach (UnlockData unlockData2 in requires)
                    {
                        if (!unlocksList.Contains((unlockData2).name))
                        {
                            Debug.Log(("[" + text + "] requirements are not met (requires [" + (unlockData2).name + "]). removing from save data"));
                            unlocksList.RemoveAt(num);
                            flag = true;
                            saveRequired = true;
                            break;
                        }
                    }
                }
            }
        }
    }
}
public class SaveSystem : GameSystem
{
    public class Saver
    {
        public readonly string baseFileName;

        public readonly ES3Settings settings;

        public Saver(string baseFileName, ES3Settings settings = null)
        {
            this.baseFileName = baseFileName;
            this.settings = settings ?? ES3Settings.defaultSettings;
        }

        public void SaveValue<TValue>(string key, TValue value, string folderName, string fileName = "")
        {
            StopWatch.Start();
            string text = string.Format(baseFileName, fileName);
            Debug.Log(("Saving [" + text + "] (" + key + ")..."));
            string text2 = folderName + "/" + text;
            try
            {
                ES3.Save<TValue>(key, value, text2, settings);
            }
            catch (InvalidOperationException ex)
            {
                Debug.LogWarning(ex);
            }
            catch (IOException ex2)
            {
                Debug.LogWarning(ex2);
            }
            Debug.Log($"Saving Done! ({StopWatch.Stop()}ms)");
        }

        public TValue LoadValue<TValue>(string key, string folderName, TValue defaultValue, string fileName = "")
        {
            StopWatch.Start();
            string text = string.Format(baseFileName, fileName);
            Debug.Log(("Loading [" + text + "] (" + key + ")..."));
            string text2 = folderName + "/" + text;
            TValue result = defaultValue;
            try
            {
                result = ES3.Load<TValue>(key, text2, defaultValue, settings);
            }
            catch (Exception ex)
            {
                Debug.LogWarning(ex);
                Debug.LogWarning((text2 + " data appears to be corrupt, attempting to restore backup"));
                ES3.RestoreBackup(text2, settings);
                try
                {
                    result = ES3.Load<TValue>(key, text2, defaultValue, settings);
                }
                catch (Exception)
                {
                    Debug.LogWarning("Failed to restore backup :( returning default value...");
                }
            }
            Debug.Log($"Loading Done! ({StopWatch.Stop()}ms)");
            return result;
        }

        public bool FileExists(string folderName, string fileName = "")
        {
            string text = string.Format(baseFileName, fileName);
            return ES3.FileExists(folderName + "/" + text, settings);
        }

        public bool KeyExists(string key, string folderName, string fileName = "")
        {
            string text = string.Format(baseFileName, fileName);
            string text2 = folderName + "/" + text;
            try
            {
                return ES3.KeyExists(key, text2, settings);
            }
            catch (Exception ex)
            {
                Debug.LogWarning(ex);
                Debug.LogWarning((text2 + " data appears to be corrupt, attempting to restore backup"));
                ES3.RestoreBackup(text2, settings);
                try
                {
                    return ES3.KeyExists(key, text2, settings);
                }
                catch (Exception)
                {
                    Debug.LogWarning("Failed to restore backup :( returning default value...");
                    return false;
                }
            }
        }

        public void Delete(string folderName, string fileName = "")
        {
            string text = string.Format(baseFileName, fileName);
            ES3.DeleteFile(folderName + "/" + text, settings);
        }

        public void DeleteKey(string key, string folderName, string fileName = "")
        {
            string text = string.Format(baseFileName, fileName);
            ES3.DeleteKey(key, folderName + "/" + text, settings);
        }

        public void CheckBackup(string folderName, string fileName = "")
        {
            string text = string.Format(baseFileName, fileName);
            string text2 = folderName + "/" + text;
            Debug.Log(("Checking " + text + " for corrupt data..."));
            try
            {
                ES3.KeyExists("a", text2, settings);
            }
            catch (Exception ex)
            {
                Debug.LogWarning(ex);
                Debug.LogWarning((text2 + " data appears to be corrupt, attempting to restore backup"));
                ES3.RestoreBackup(text2, settings);
                try
                {
                    ES3.KeyExists("a", text2, settings);
                    Debug.Log(("Successfully retrieved " + text + " backup"));
                }
                catch (Exception)
                {
                    Debug.LogWarning("Failed to restore backup :(");
                }
            }
        }
    }

    public static SaveSystem instance;

    public bool encode;

    [HideIf("encode")]
    public bool beautify;

    public bool promptSave;

    public bool busy;

    public static readonly string profileFolder = "Profiles";

    public static string folderName = "SaveData";

    public static Saver progressSaver;

    public static Saver campaignSaver;

    public static Saver battleSaver;

    public static Saver statsSaver;

    public static Saver historySaver;

    public static ES3Settings settings;

    public static bool gotSaveTimestamp;

    public static DateTime saveTimestamp;

    public static bool Enabled
    {
        get
        {
            if (instance != null)
            {
                return ((Behaviour)instance).enabled;
            }
            return false;
        }
    }

    public static string Profile { get; set; } = "";


    public void OnEnable()
    {
        Events.InvokeSaveSystemEnabled();
    }

    public void OnDisable()
    {
        Events.InvokeSaveSystemDisabled();
    }

    public void Awake()
    {
        instance = this;
    }

    public void Start()
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Expected O, but got Unknown
        //IL_00de: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e8: Expected O, but got Unknown
        settings = new ES3Settings(new Enum[1] { (Enum)(object)(Directory)0 })
        {
            encryptionType = (EncryptionType)1,
            compressionType = (CompressionType)1,
            prettyPrint = false
        };
        SetProfile(GetProfile(), save: false);
        if (ES3.FileExists(folderName + "/Save.sav"))
        {
            gotSaveTimestamp = true;
            saveTimestamp = ES3.GetTimestamp(folderName + "/Save.sav");
        }
        progressSaver = new Saver("Save{0}.sav", settings);
        campaignSaver = new Saver("Campaign{0}.sav", settings);
        battleSaver = new Saver("Battle{0}.sav", settings);
        statsSaver = new Saver("Stats{0}.sav", settings);
        historySaver = new Saver("History{0}.sav", settings);
        EncryptSaveData();
        Events.OnSaveSystemProfileChanged += new UnityAction(EncryptSaveData);
        progressSaver.CheckBackup(folderName);
        campaignSaver.CheckBackup(folderName);
        campaignSaver.CheckBackup(folderName, "Demo");
        campaignSaver.CheckBackup(folderName, "PressDemo");
        battleSaver.CheckBackup(folderName);
        statsSaver.CheckBackup(folderName);
        historySaver.CheckBackup(folderName);
    }

    public void OnDestroy()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnSaveSystemProfileChanged -= new UnityAction(EncryptSaveData);
    }

    public static void SaveProgressData<T>(string key, T value)
    {
        if (Enabled)
        {
            progressSaver.SaveValue(key, value, folderName);
        }
    }

    public static void SaveCampaignData<T>(GameMode gameMode, string key, T value)
    {
        if (Enabled)
        {
            campaignSaver.SaveValue(key, value, folderName, gameMode.saveFileName);
        }
    }

    public static void SaveStatsData<T>(string key, T value)
    {
        if (Enabled)
        {
            statsSaver.SaveValue(key, value, folderName);
        }
    }

    public static void SaveHistoryData<T>(string key, T value)
    {
        if (Enabled)
        {
            historySaver.SaveValue(key, value, folderName);
        }
    }

    public static T LoadProgressData<T>(string key) where T : class
    {
        return LoadProgressData<T>(key, null);
    }

    public static T LoadCampaignData<T>(GameMode gameMode, string key) where T : class
    {
        return LoadCampaignData<T>(gameMode, key, null);
    }

    public static T LoadStatsData<T>(string key) where T : class
    {
        return LoadStatsData<T>(key, null);
    }

    public static T LoadHistoryData<T>(string key) where T : class
    {
        return LoadHistoryData<T>(key, null);
    }

    public static T LoadProgressData<T>(string key, T defaultValue)
    {
        if (!Enabled)
        {
            return defaultValue;
        }
        return progressSaver.LoadValue(key, folderName, defaultValue);
    }

    public static T LoadCampaignData<T>(GameMode gameMode, string key, T defaultValue)
    {
        if (!Enabled)
        {
            return defaultValue;
        }
        return campaignSaver.LoadValue(key, folderName, defaultValue, gameMode.saveFileName);
    }

    public static T LoadStatsData<T>(string key, T defaultValue)
    {
        if (!Enabled)
        {
            return defaultValue;
        }
        return statsSaver.LoadValue(key, folderName, defaultValue);
    }

    public static T LoadHistoryData<T>(string key, T defaultValue)
    {
        if (!Enabled)
        {
            return defaultValue;
        }
        return historySaver.LoadValue(key, folderName, defaultValue);
    }

    public static bool ProgressExists()
    {
        if (Enabled)
        {
            return progressSaver.FileExists(folderName);
        }
        return false;
    }

    public static bool CampaignExists(GameMode gameMode)
    {
        if (Enabled)
        {
            return campaignSaver.FileExists(folderName, gameMode.saveFileName);
        }
        return false;
    }

    public static bool StatsExists()
    {
        if (Enabled)
        {
            return statsSaver.FileExists(folderName);
        }
        return false;
    }

    public static bool HistoryExists()
    {
        if (Enabled)
        {
            return historySaver.FileExists(folderName);
        }
        return false;
    }

    public static bool ProgressDataExists(string key)
    {
        if (Enabled)
        {
            return progressSaver.KeyExists(key, folderName);
        }
        return false;
    }

    public static bool CampaignDataExists(GameMode gameMode, string key)
    {
        if (Enabled)
        {
            return campaignSaver.KeyExists(key, folderName, gameMode.saveFileName);
        }
        return false;
    }

    public static bool StatsDataExists(string key)
    {
        if (Enabled)
        {
            return statsSaver.KeyExists(key, folderName);
        }
        return false;
    }

    public static bool HistoryDataExists(string key)
    {
        if (Enabled)
        {
            return historySaver.KeyExists(key, folderName);
        }
        return false;
    }

    public static void DeleteProgress()
    {
        if (Enabled)
        {
            progressSaver.Delete(folderName);
        }
    }

    public static void DeleteCampaign(GameMode gameMode)
    {
        if (Enabled)
        {
            campaignSaver.Delete(folderName, gameMode.saveFileName);
        }
    }

    public static void DeleteProfile(string profileName)
    {
        if (Enabled)
        {
            ES3.DeleteDirectory(folderName);
        }
    }

    public static void DeleteStats()
    {
        if (Enabled)
        {
            statsSaver.Delete(folderName);
        }
    }

    public static void DeleteHistory()
    {
        if (Enabled)
        {
            historySaver.Delete(folderName);
        }
    }

    public static void DeleteProgressData(string key)
    {
        if (Enabled)
        {
            progressSaver.DeleteKey(key, folderName);
        }
    }

    public static string GetProfile()
    {
        try
        {
            return ES3.Load<string>("profile", "data.sav", "Default");
        }
        catch (Exception ex)
        {
            Debug.LogWarning(ex);
            return "Default";
        }
    }

    public static void SetProfile(string name, bool save = true)
    {
        Debug.Log(("Save Profile Set: " + name));
        Profile = name;
        folderName = profileFolder + "/" + name;
        if (Enabled)
        {
            Events.InvokeSaveSystemProfileChanged();
        }
        if (save)
        {
            try
            {
                ES3.Save<string>("profile", name, "data.sav");
            }
            catch (Exception ex)
            {
                Debug.LogWarning(ex);
                ES3.DeleteFile("data.sav");
                ES3.Save<string>("profile", name, "data.sav");
            }
        }
    }

    public static void EncryptSaveData()
    {
        ES3Settings defaultSettings = ES3Settings.defaultSettings;
        ES3Settings newSettings = settings;
        ConvertSaveFile(progressSaver, folderName, "", defaultSettings, newSettings);
        ConvertSaveFile(campaignSaver, folderName, "", defaultSettings, newSettings);
        ConvertSaveFile(campaignSaver, folderName, "Demo", defaultSettings, newSettings);
        ConvertSaveFile(statsSaver, folderName, "", defaultSettings, newSettings);
    }

    public static void ConvertSaveFile(Saver saver, string folder, string fileName, ES3Settings oldSettings, ES3Settings newSettings)
    {
        string text = string.Format(saver.baseFileName, fileName);
        string text2 = folderName + "/" + text;
        try
        {
            ES3.KeyExists("a", text2, newSettings);
            Debug.Log(("[" + text + "] save file does not need converting"));
        }
        catch (Exception ex) when (ex is FormatException || ex is ArgumentException || ex is CryptographicException)
        {
            Debug.LogWarning(ex);
            Debug.LogWarning(("[" + text + "] save file needs converting"));
            try
            {
                string text3 = folder + "/" + text;
                ES3.SaveRaw(ES3.LoadRawString(text3, oldSettings), text3, newSettings);
                Debug.Log(("Successfully converted [" + text + "] to new file format"));
            }
            catch (Exception ex2)
            {
                Debug.LogWarning(ex2);
                Debug.LogWarning(("Failed to convert [" + text + "] to new file format"));
            }
        }
    }
}
public class ScoreSubmitSystem : GameSystem
{
    public enum Status
    {
        Submitting,
        Failed,
        Success
    }

    public static ScoreSubmitSystem instance;

    public const int StartScore = -100;

    public static Status status { get; set; }

    public static int? playerRank { get; set; }

    public static int SubmittedTime { get; set; }

    public static int SubmittedGold { get; set; }

    public static int SubmittedBattlesWon { get; set; }

    public static int SubmittedScore { get; set; }

    public static LeaderboardUpdate? result { get; set; }

    public void OnEnable()
    {
        instance = this;
        Events.OnCampaignEnd += CampaignEnd;
    }

    public void OnDisable()
    {
        Events.OnCampaignEnd -= CampaignEnd;
    }

    public static void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
    {
        if (Campaign.Data.GameMode.submitScore)
        {
            bool win = result == Campaign.Result.Win;
            ((MonoBehaviour)instance).StartCoroutine(SubmitScore(win, stats));
        }
    }

    public static IEnumerator SubmitScore(bool win, CampaignStats stats)
    {
        yield return null;
        playerRank = null;
        status = Status.Submitting;
        DateTime date = DateTime.ParseExact(SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "startDate", ""), "dd/MM/yyyy", GameManager.CultureInfo);
        int num = (win ? 1 : 0);
        SubmittedTime = Mathf.RoundToInt((float)(stats.hours * 3600) + stats.time);
        SubmittedGold = stats.Count("goldGained");
        SubmittedBattlesWon = stats.Count("battlesWon");
        SubmittedScore = GetScore(win, SubmittedTime, SubmittedGold, SubmittedBattlesWon);
        if (SteamManager.init)
        {
            Task<LeaderboardUpdate?> task = Scores.Submit(Campaign.Data.GameMode.leaderboardType, date, SubmittedScore, SubmittedTime, num);
            yield return (object)new WaitUntil((Func<bool>)(() => task.IsCompleted));
            result = task.Result;
        }
        else
        {
            result = null;
        }
        if (result.HasValue)
        {
            playerRank = result.Value.NewGlobalRank;
            Debug.Log($"Score Changed? {result.Value.Changed}");
            if (result.Value.Changed)
            {
                Debug.Log($"Global Rank: {result.Value.OldGlobalRank} → {result.Value.NewGlobalRank}");
            }
            status = Status.Success;
        }
        else
        {
            Debug.LogWarning("Submitting score failed!");
            status = Status.Failed;
        }
    }

    public static int GetScore(bool win, int seconds, int gold, int battlesWon)
    {
        int scoreFromTime = GetScoreFromTime(win, seconds);
        int scoreFromGold = GetScoreFromGold(gold);
        int scoreFromBattlesWon = GetScoreFromBattlesWon(battlesWon);
        return scoreFromTime + scoreFromGold + scoreFromBattlesWon;
    }

    public static int GetScoreFromTime(bool win, int seconds)
    {
        if (!win)
        {
            return 0;
        }
        return Mathf.Max(0, 3600 - seconds);
    }

    public static int GetScoreFromGold(int goldRemaining)
    {
        return goldRemaining;
    }

    public static int GetScoreFromBattlesWon(int battlesWon)
    {
        return -100 + battlesWon * 100;
    }
}
public class ScreenFlashSystem : GameSystem
{
    public static ScreenFlashSystem instance;

    [SerializeField]
    public SpriteRenderer renderer;

    [SerializeField]
    public AnimationCurve curve;

    [SerializeField]
    public Material basicMaterial;

    [SerializeField]
    public Material additiveMaterial;

    public Color color;

    public float current;

    public float duration;

    public float amount = 1f;

    public void Awake()
    {
        instance = this;
    }

    public void Update()
    {
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        if (((Renderer)renderer).enabled)
        {
            current += Time.deltaTime;
            float num = Mathf.Min(1f, current / duration);
            float num2 = curve.Evaluate(num) * amount;
            renderer.color = ColorExt.WithAlpha(color, num2);
            if (current >= duration)
            {
                ((Renderer)renderer).enabled = false;
                ((Renderer)renderer).material = basicMaterial;
            }
        }
    }

    public static void SetDrawOrder(string sortingLayer, int orderInLayer)
    {
        instance._SetDrawOrder(sortingLayer, orderInLayer);
    }

    public static void SetColour(Color color)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        instance.color = color;
    }

    public static void SetMaterialAdditive()
    {
        ((Renderer)instance.renderer).material = instance.additiveMaterial;
    }

    public static void Run(float duration)
    {
        instance._Run(duration);
    }

    public void _SetDrawOrder(string sortingLayer, int orderInLayer)
    {
        ((Renderer)renderer).sortingLayerName = sortingLayer;
        ((Renderer)renderer).sortingOrder = orderInLayer;
    }

    public void _Run(float duration)
    {
        current = 0f;
        ((Renderer)renderer).enabled = true;
        this.duration = duration;
        amount = Mathf.Max(0.2f, Settings.Load("ScreenFlash", 1f));
    }
}
public class ScreenSystem : GameSystem
{
    public static ScreenSystem instance;

    public int windowedWidth = 1920;

    public int windowedHeight = 1080;

    public FullScreenMode windowedMode = (FullScreenMode)3;

    public FullScreenMode fullMode = (FullScreenMode)1;

    public int _displayIndex;

    public int current;

    public int vsync;

    public int targetFramerate;

    public int fullScreenWidth => display.systemWidth;

    public int fullScreenHeight => display.systemHeight;

    public int displayIndex
    {
        get
        {
            if (_displayIndex >= Display.displays.Length)
            {
                _displayIndex = Display.displays.Length - 1;
            }
            return _displayIndex;
        }
    }

    public Display display => Display.displays[displayIndex];

    public static bool IsWindowed
    {
        get
        {
            //IL_0000: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Invalid comparison between Unknown and I4
            //IL_0008: Unknown result type (might be due to invalid IL or missing references)
            //IL_000e: Invalid comparison between Unknown and I4
            if ((int)Screen.fullScreenMode != 3)
            {
                return (int)Screen.fullScreenMode == 2;
            }
            return true;
        }
    }

    public void OnEnable()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected I4, but got Unknown
        instance = this;
        FullScreenMode fullScreenMode = Screen.fullScreenMode;
        switch ((int)fullScreenMode)
        {
            case 2:
            case 3:
                current = 0;
                break;
            case 0:
                current = 1;
                break;
            case 1:
                current = 2;
                break;
        }
        Events.OnSettingChanged += SettingChanged;
        int num = Settings.Load("DisplayMode", 2);
        if (num != current)
        {
            Set(num);
        }
        vsync = Settings.Load("Vsync", 1);
        SetVsync(vsync);
        targetFramerate = Settings.Load("TargetFramerate", 2);
        SetTargetFramerate(targetFramerate);
    }

    public void OnDisable()
    {
        Events.OnSettingChanged -= SettingChanged;
    }

    public void SettingChanged(string key, object value)
    {
        if (value is int mode)
        {
            switch (key)
            {
                case "DisplayMode":
                    Set(mode);
                    break;
                case "TargetFramerate":
                    SetTargetFramerate(mode);
                    break;
                case "Vsync":
                    SetVsync(mode);
                    break;
            }
        }
    }

    public void Update()
    {
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        if (Input.GetKeyDown((KeyCode)13) && Input.GetKey((KeyCode)308))
        {
            if (IsWindowed)
            {
                Settings.Save("DisplayMode", ((int)fullMode == 0) ? 1 : 2);
            }
            else
            {
                Settings.Save("DisplayMode", 0);
            }
            SetSettingInt setSettingInt = Object.FindObjectsOfType<SetSettingInt>().FirstOrDefault((SetSettingInt a) => a.Key == "DisplayMode");
            if (setSettingInt != null)
            {
                ((Behaviour)setSettingInt).enabled = false;
                ((Behaviour)setSettingInt).enabled = true;
            }
        }
    }

    public void Set(int mode)
    {
        current = mode;
        switch (IntExt.Mod(mode, 3))
        {
            case 0:
                SetWindowed();
                break;
            case 1:
                SetFull();
                break;
            case 2:
                SetBorderless();
                break;
        }
    }

    public void SetWindowed(int forceWidth = 0, int forceHeight = 0)
    {
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        Debug.Log("Screen Mode: Windowed");
        if (!IsWindowed)
        {
            fullMode = Screen.fullScreenMode;
        }
        Screen.fullScreenMode = windowedMode;
        int num = ((forceWidth > 0) ? forceWidth : windowedWidth);
        int num2 = ((forceHeight > 0) ? forceHeight : windowedHeight);
        Screen.SetResolution(num, num2, windowedMode);
    }

    public void SetFull(int forceWidth = 0, int forceHeight = 0)
    {
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        Debug.Log("Screen Mode: Fullscreen");
        if (IsWindowed)
        {
            windowedWidth = Screen.width;
            windowedHeight = Screen.height;
            windowedMode = Screen.fullScreenMode;
        }
        Screen.fullScreenMode = (FullScreenMode)0;
        int num = ((forceWidth > 0) ? forceWidth : fullScreenWidth);
        int num2 = ((forceHeight > 0) ? forceHeight : fullScreenHeight);
        Screen.SetResolution(num, num2, (FullScreenMode)0);
    }

    public void SetBorderless(int forceWidth = 0, int forceHeight = 0)
    {
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        Debug.Log("Screen Mode: Borderless");
        if (IsWindowed)
        {
            windowedWidth = Screen.width;
            windowedHeight = Screen.height;
            windowedMode = Screen.fullScreenMode;
        }
        Screen.fullScreenMode = (FullScreenMode)1;
        int num = ((forceWidth > 0) ? forceWidth : fullScreenWidth);
        int num2 = ((forceHeight > 0) ? forceHeight : fullScreenHeight);
        Screen.SetResolution(num, num2, (FullScreenMode)1);
    }

    public static void SetTargetFramerate(int mode)
    {
        mode = Mathf.Clamp(mode, 0, 4);
        Application.targetFrameRate = mode switch
        {
            0 => -1,
            1 => 30,
            2 => 60,
            3 => 120,
            4 => 240,
            _ => Application.targetFrameRate,
        };
    }

    public static void SetVsync(int mode)
    {
        QualitySettings.vSyncCount = Mathf.Clamp(mode, 0, 1);
    }

    public static void SetResolutionFullscreen(int width, int height)
    {
        instance.SetFull(width, height);
    }

    public static void SetResolutionBorderless(int width, int height)
    {
        instance.SetBorderless(width, height);
    }

    public static void SetResolutionWindowed(int width, int height)
    {
        instance.SetWindowed(width, height);
    }
}
public class SecretFinalBossSystem : GameSystem
{
    [SerializeField]
    public string[] requireInDeck = new string[1] { "LuminVase" };

    [SerializeField]
    public string targetNodeName = "CampaignNodeFinalBoss";

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleEnd += new UnityAction(BattleEnd);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleEnd -= new UnityAction(BattleEnd);
    }

    public void BattleEnd()
    {
        CampaignNode node = Campaign.FindCharacterNode(References.Player);
        CheckContinuePastFinalBoss(node);
    }

    public void CheckContinuePastFinalBoss(CampaignNode node)
    {
        if (node.finalNode && (node.type).name == targetNodeName && PlayerHasRequiredCards())
        {
            SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "trueWin", value: true);
            node.finalNode = false;
        }
    }

    public bool PlayerHasRequiredCards()
    {
        List<string> list = IArrayExt.ToList<string>(requireInDeck);
        foreach (CardData item in References.PlayerData.inventory.deck)
        {
            int num = list.IndexOf((item).name);
            if (num >= 0)
            {
                list.RemoveAt(num);
                if (list.Count <= 0)
                {
                    break;
                }
            }
        }
        return list.Count <= 0;
    }
}
public class SecretNakedGnomeSystem : GameSystem
{
    public const string nakedGnomeDataName = "NakedGnome";

    public const string nakedGnomeFriendlyDataName = "NakedGnomeFriendly";

    public static bool nakedGnomeSaved;

    [SerializeField]
    public InspectNewUnitSequence gainNakedGnomeSequencePrefab;

    public static Vector3 startPos = new Vector3(0f, 8f, 0f);

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleEnd += new UnityAction(BattleEnd);
        Events.PostBattle += PostBattle;
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleEnd -= new UnityAction(BattleEnd);
        Events.PostBattle -= PostBattle;
    }

    public static void BattleEnd()
    {
        nakedGnomeSaved = (Battle.GetCards(References.Battle.enemy).FirstOrDefault((Entity a) => (a.data).name == "NakedGnome"));
    }

    public void PostBattle(CampaignNode campaignNode)
    {
        if (nakedGnomeSaved)
        {
            ActionQueue.Add(new ActionSequence(Sequence()));
            nakedGnomeSaved = false;
        }
    }

    public IEnumerator Sequence()
    {
        InspectNewUnitSequence sequence = Object.Instantiate<InspectNewUnitSequence>(gainNakedGnomeSequencePrefab, References.Player.entity.display.transform);
        sequence.cardSelector.character = References.Player;
        ((UnityEvent<Entity>)((Component)sequence).GetComponent<CardSelector>()?.selectEvent).AddListener((UnityAction<Entity>)Events.InvokeEntityChosen);
        CardData data = AddressableLoader.Get<CardData>("CardData", "NakedGnomeFriendly").Clone();
        Card card = CardManager.Get(data, null, References.Player, inPlay: false, isPlayerCard: true);
        card.transform.SetParent(sequence.cardHolder);
        card.transform.localPosition = startPos;
        yield return card.UpdateData();
        sequence.SetUnit(card.entity, updateGreeting: false);
        Events.InvokeEntityOffered(card.entity);
        yield return sequence.Run();
    }
}
public class AmbienceSystem : GameSystem
{
    [SerializeField]
    public string[] validScenes = new string[2] { "Battle", "Event" };

    public static EventInstance current;

    public void OnEnable()
    {
        Events.OnSceneChanged += SceneChanged;
    }

    public void OnDisable()
    {
        Events.OnSceneChanged -= SceneChanged;
        Stop((STOP_MODE)0);
    }

    public void SceneChanged(Scene scene)
    {
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        Stop((STOP_MODE)0);
        if (IArrayExt.Contains<string>(validScenes, ((scene)).name))
        {
            Play(References.GetCurrentArea().ambienceEvent);
        }
    }

    public static void Play(EventReference eventId)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        Play(eventId.Guid);
    }

    public static void Play(GUID eventGUID)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Expected O, but got Unknown
        try
        {
            current = RuntimeManager.CreateInstance(eventGUID);
            ((current)).start();
        }
        catch (EventNotFoundException val)
        {
            Debug.LogWarning(val);
        }
    }

    public static void SetParam(string name, float value)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(current))
        {
            ((current)).setParameterByName(name, value, false);
        }
    }

    public static void Stop(STOP_MODE stopMode = 0)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(current))
        {
            ((current)).stop(stopMode);
            ((current)).release();
        }
    }

    public static bool IsRunning(EventInstance instance)
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Invalid comparison between Unknown and I4
        if (((instance)).isValid())
        {
            PLAYBACK_STATE val = default(PLAYBACK_STATE);
            ((instance)).getPlaybackState(ref val);
            if ((int)val != 2)
            {
                return true;
            }
        }
        return false;
    }
}
public class AudioSettingsSystem : GameSystem
{
    [Serializable]
    public class Bus
    {
        public string name;

        public string path;

        public string volumeSettingsKey;

        [Range(0f, 2f)]
        public float volume = 1f;

        [Range(0f, 2f)]
        public float pitch = 1f;

        public Bus bus;

        public ChannelGroup channelGroup;

        public void Init()
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0017: Unknown result type (might be due to invalid IL or missing references)
            bus = RuntimeManager.GetBus(path);
            ((bus)).lockChannelGroup();
            volume = Settings.Load(volumeSettingsKey, 1f);
            UpdateVolume();
            UpdatePitch();
        }

        public void UpdateVolume()
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            ((bus)).setVolume(volume);
        }

        public void UpdatePitch()
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001e: Unknown result type (might be due to invalid IL or missing references)
            ((bus)).getChannelGroup(ref channelGroup);
            ((channelGroup)).setPitch(pitch);
        }
    }

    public static bool Loading;

    [SerializeField]
    public Bus[] buses;

    [SerializeField]
    [Range(0f, 1f)]
    public float slowmoPitchMin = 0.67f;

    [SerializeField]
    [Range(0f, 1f)]
    public float slowmoPitchLerp = 0.25f;

    [SerializeField]
    public bool slowmoLerpUseDelta = true;

    [InfoBox(/*Could not decode attribute arguments.*/)]
    [SerializeField]
    public AssetReference[] banksToLoad;

    public Dictionary<string, Bus> busLookup;

    public float slowmoPitch = 1f;

    public float slowmoPitchTarget = 1f;

    public void Awake()
    {
        StartCoroutine(LoadBanks());
    }

    public void OnEnable()
    {
        Events.OnAudioVolumeChange += SetVolume;
        Events.OnAudioPitchChange += SetPitch;
        Events.OnTimeScaleChange += TimeScaleChange;
    }

    public void OnDisable()
    {
        Events.OnAudioVolumeChange -= SetVolume;
        Events.OnAudioPitchChange -= SetPitch;
        Events.OnTimeScaleChange -= TimeScaleChange;
    }

    public IEnumerator LoadBanks()
    {
        Loading = true;
        Debug.Log("Audio Settings System → Loading Banks");
        AssetReference[] array = banksToLoad;
        foreach (AssetReference val in array)
        {
            RuntimeManager.LoadBank(val, true, (Action)null);
            Debug.Log($"FMOD BANK {val} LOADED");
        }
        while (!RuntimeManager.HaveAllBanksLoaded)
        {
            yield return null;
        }
        while (RuntimeManager.AnySampleDataLoading())
        {
            yield return null;
        }
        busLookup = new Dictionary<string, Bus>();
        Bus[] array2 = buses;
        foreach (Bus bus in array2)
        {
            bus.Init();
            busLookup.Add(bus.name, bus);
        }
        Loading = false;
    }

    public void Update()
    {
        if (slowmoPitch != slowmoPitchTarget)
        {
            if (slowmoLerpUseDelta)
            {
                slowmoPitch = Delta.Lerp(slowmoPitch, slowmoPitchTarget, slowmoPitchLerp, Time.deltaTime);
            }
            else
            {
                slowmoPitch = Mathf.Lerp(slowmoPitch, slowmoPitchTarget, slowmoPitchLerp);
            }
            if (Mathf.Abs(slowmoPitch - slowmoPitchTarget) < 0.01f)
            {
                slowmoPitch = slowmoPitchTarget;
            }
            SetPitch("Master", slowmoPitch);
        }
    }

    public void TimeScaleChange(float value)
    {
        slowmoPitchTarget = slowmoPitchMin + (1f - slowmoPitchMin) * value;
        Bus bus = busLookup["Master"];
        if (bus != null)
        {
            slowmoPitch = bus.pitch;
        }
    }

    public void SetVolume(string busName, float value)
    {
        Bus bus = busLookup[busName];
        if (bus != null)
        {
            bus.volume = value;
            bus.UpdateVolume();
            Settings.Save(bus.volumeSettingsKey, value);
        }
    }

    public static void Volume(string busName, float value)
    {
        AudioSettingsSystem audioSettingsSystem = Object.FindObjectOfType<AudioSettingsSystem>();
        if (audioSettingsSystem != null && ((Behaviour)audioSettingsSystem).enabled)
        {
            audioSettingsSystem.SetVolume(busName, Mathf.Clamp(value, 0f, 1f));
        }
    }

    public static float GetVolume(string busName)
    {
        AudioSettingsSystem audioSettingsSystem = Object.FindObjectOfType<AudioSettingsSystem>();
        if (audioSettingsSystem != null && ((Behaviour)audioSettingsSystem).enabled)
        {
            try
            {
                Bus bus = audioSettingsSystem.busLookup[busName];
                if (bus != null)
                {
                    return bus.volume;
                }
            }
            catch (KeyNotFoundException ex)
            {
                throw new KeyNotFoundException("[" + busName + "] does not exist", ex.InnerException);
            }
        }
        return 0f;
    }

    public void SetPitch(string busName, float value)
    {
        try
        {
            Bus bus = busLookup[busName];
            if (bus != null)
            {
                bus.pitch = value;
                bus.UpdatePitch();
            }
        }
        catch (KeyNotFoundException ex)
        {
            throw new KeyNotFoundException("[" + busName + "] does not exist", ex.InnerException);
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void PromptUpdate()
    {
        Bus[] array = buses;
        foreach (Bus obj in array)
        {
            obj.UpdateVolume();
            obj.UpdatePitch();
        }
    }
}
public class BattleMusicSystem : GameSystem, ISaveable<BattleMusicSaveData>
{
    [Serializable]
    public struct MinibossIntroRef
    {
        [SerializeField]
        public CardData cardData;

        [SerializeField]
        public EventReference introEvent;
    }

    public int startingIntensity;

    public int normalIntensity = 1;

    [Header("Win/Lose Jingles")]
    [SerializeField]
    public EventReference winJingle;

    [SerializeField]
    public EventReference loseJingle;

    [Header("Miniboss Intros")]
    [SerializeField]
    public EventReference minibossIntroDefault;

    [SerializeField]
    public MinibossIntroRef[] minibossIntros;

    [SerializeField]
    public float minibossIntroDuration = 2f;

    public readonly Dictionary<string, EventReference> minibossIntroLookup = new Dictionary<string, EventReference>();

    public Scene currentScene;

    public EventInstance current;

    public EventInstance minibossIntroInstance;

    public int intensity;

    public PARAMETER_ID intensityParameterId;

    public bool bossEntered;

    public float promptStartMiniboss;

    public int bossPhase = 1;

    public float volume = 1f;

    public float pitch = 1f;

    public float targetVolume = 1f;

    public float targetPitch = 1f;

    public const float fadeAmount = 1f;

    public void Awake()
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        MinibossIntroRef[] array = minibossIntros;
        for (int i = 0; i < array.Length; i++)
        {
            MinibossIntroRef minibossIntroRef = array[i];
            minibossIntroLookup[(minibossIntroRef.cardData).name] = minibossIntroRef.introEvent;
        }
    }

    public void OnEnable()
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        Events.OnSceneChanged += SceneChange;
        Events.OnBattlePhaseStart += BattlePhaseChange;
        Events.OnBattleEnd += new UnityAction(BattleEnd);
        Events.OnEntityHit += EntityHit;
        Events.OnEntityMove += EntityMove;
        Events.OnMinibossIntro += MinibossIntro;
        Events.OnEntityChangePhase += EntityChangePhase;
        Check();
    }

    public void OnDisable()
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        Events.OnSceneChanged -= SceneChange;
        Events.OnBattlePhaseStart -= BattlePhaseChange;
        Events.OnBattleEnd -= new UnityAction(BattleEnd);
        Events.OnEntityHit -= EntityHit;
        Events.OnEntityMove -= EntityMove;
        Events.OnMinibossIntro -= MinibossIntro;
        Events.OnEntityChangePhase -= EntityChangePhase;
        StopMusic((STOP_MODE)1);
    }

    public void OnDestroy()
    {
        StopMusic((STOP_MODE)1);
    }

    public void Update()
    {
        //IL_0092: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_00aa: Unknown result type (might be due to invalid IL or missing references)
        if (promptStartMiniboss > 0f)
        {
            promptStartMiniboss -= Time.deltaTime;
            if (promptStartMiniboss <= 0f)
            {
                StartMusic(References.GetCurrentArea().minibossMusicEvent);
                SetParam("bossHealth", 1f);
            }
        }
        float num = 1f * Time.deltaTime;
        if (Mathf.Abs(pitch - targetPitch) > num)
        {
            float num2 = Mathf.Clamp(targetPitch - pitch, 0f - num, num);
            pitch += num2;
            if (IsRunning(current))
            {
                ((current)).setPitch(pitch);
            }
        }
    }

    public void FadePitchTo(float value)
    {
        targetPitch = value;
    }

    public void SceneChange(Scene scene)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        currentScene = scene;
        Check();
    }

    public void BattlePhaseChange(Battle.Phase phase)
    {
        if (phase == Battle.Phase.End)
        {
            StopMusic((STOP_MODE)0);
        }
    }

    public void BattleEnd()
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        if (Battle.instance.winner == Battle.instance.player)
        {
            SfxSystem.OneShot(winJingle);
        }
        else
        {
            SfxSystem.OneShot(loseJingle);
        }
    }

    public void EntityHit(Hit hit)
    {
        if (!bossEntered && intensity == startingIntensity && hit.Offensive)
        {
            SetIntensity(normalIntensity);
        }
    }

    public void EntityMove(Entity entity)
    {
        if (!bossEntered && ((currentScene)).IsValid() && (References.Battle) && entity.owner == References.Battle.enemy)
        {
            CardType cardType = entity.data?.cardType;
            if (cardType != null && cardType.miniboss && Battle.IsOnBoard(entity) && !Battle.IsOnBoard(entity.preContainers))
            {
                bossEntered = true;
                StopMusic((STOP_MODE)0);
            }
        }
    }

    public void MinibossIntro(Entity entity)
    {
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        if (!IsBossBattle())
        {
            EventReference eventRef = (minibossIntroLookup.ContainsKey((entity.data).name) ? minibossIntroLookup[(entity.data).name] : minibossIntroDefault);
            minibossIntroInstance = SfxSystem.OneShot(eventRef);
            promptStartMiniboss = minibossIntroDuration;
        }
    }

    public void EntityChangePhase(Entity entity)
    {
        if (entity.data.cardType.miniboss && entity.owner.team == References.Battle.enemy.team && bossPhase < 2)
        {
            bossPhase++;
            SetParam("finalboss", bossPhase);
        }
    }

    public void Check()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        Scene val = currentScene;
        if (((val)).name == "Battle")
        {
            CampaignNode campaignNode = Campaign.FindCharacterNode(References.Player);
            AreaData areaData = References.Areas[campaignNode.areaIndex];
            if (campaignNode.type is CampaignNodeTypeBattle { overrideMusic: var overrideMusic } campaignNodeTypeBattle && !((overrideMusic)).IsNull)
            {
                StartMusic(campaignNodeTypeBattle.overrideMusic);
            }
            else if (campaignNode.type.isBoss)
            {
                StartMusic(areaData.bossMusicEvent);
            }
            else
            {
                StartMusic(areaData.battleMusicEvent);
                InitBattleMusic();
            }
            if (campaignNode.type.isBoss)
            {
                bossEntered = true;
                bossPhase = 1;
                SetParam("finalboss", bossPhase);
            }
        }
        else
        {
            StopMusic((STOP_MODE)0);
        }
    }

    public void InitBattleMusic()
    {
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        EventDescription val = default(EventDescription);
        ((current)).getDescription(ref val);
        PARAMETER_DESCRIPTION val2 = default(PARAMETER_DESCRIPTION);
        ((val)).getParameterDescriptionByName("Phase", ref val2);
        intensityParameterId = val2.id;
        SetIntensity(startingIntensity);
        bossEntered = false;
    }

    public void StartMusic(EventReference eventReference)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        StartMusic(eventReference.Guid);
    }

    public void StartMusic(GUID eventGUID)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Expected O, but got Unknown
        try
        {
            current = RuntimeManager.CreateInstance(eventGUID);
            ((current)).start();
            ((current)).setPitch(pitch);
        }
        catch (EventNotFoundException val)
        {
            Debug.LogWarning(val);
        }
    }

    public void StopMusic(STOP_MODE stopMode = 1)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        ((current)).stop(stopMode);
        ((current)).release();
        targetPitch = 1f;
        targetVolume = 1f;
    }

    public void SetIntensity(int amount)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        intensity = amount;
        ((current)).setParameterByID(intensityParameterId, (float)intensity, false);
        Debug.Log($"Battle Music System → Intensity Set to {intensity}");
    }

    public void SetParam(string name, float value)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(current))
        {
            ((current)).setParameterByName(name, value, false);
            Debug.Log($"Param Set: {name}: {value}");
        }
    }

    public static bool IsRunning(EventInstance instance)
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Invalid comparison between Unknown and I4
        if (((instance)).isValid())
        {
            PLAYBACK_STATE val = default(PLAYBACK_STATE);
            ((instance)).getPlaybackState(ref val);
            if ((int)val != 2)
            {
                return true;
            }
        }
        return false;
    }

    public static bool IsBossBattle()
    {
        return Campaign.FindCharacterNode(References.Player).type.isBoss;
    }

    public BattleMusicSaveData Save()
    {
        return new BattleMusicSaveData
        {
            intensity = intensity,
            bossEntered = bossEntered,
            bossPhase = bossPhase
        };
    }

    public void Load(BattleMusicSaveData state)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        //IL_0091: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        if (!IsRunning(current) || bossEntered != state.bossEntered || bossPhase != state.bossPhase)
        {
            StopMusic((STOP_MODE)1);
            bossEntered = state.bossEntered;
            bossPhase = state.bossPhase;
            if (IsBossBattle())
            {
                StartMusic(References.GetCurrentArea().bossMusicEvent);
                SetParam("finalboss", bossPhase);
            }
            else if (bossEntered)
            {
                StartMusic(References.GetCurrentArea().minibossMusicEvent);
            }
            else
            {
                StartMusic(References.GetCurrentArea().battleMusicEvent);
                SetIntensity(state.intensity);
            }
        }
    }
}
public class DeathSfxSystem : GameSystem
{
    [Serializable]
    public class Profile
    {
        public EventReference eventReference;

        public CardRef[] cards;

        public float chance;
    }

    [Serializable]
    public class CardRef
    {
        public CardData card;

        public float pitchShift;
    }

    [SerializeField]
    public float globalChance = 0.1f;

    [SerializeField]
    public float globalChanceAdd = 0.02f;

    [SerializeField]
    public Profile[] profiles;

    public float currentGlobalChance;

    public readonly Dictionary<string, Tuple<Profile, float>> profileLookup = new Dictionary<string, Tuple<Profile, float>>();

    public void OnEnable()
    {
        currentGlobalChance = globalChance;
        Events.OnEntityKilled += EntityKilled;
        profileLookup.Clear();
        Profile[] array = profiles;
        foreach (Profile profile in array)
        {
            CardRef[] cards = profile.cards;
            foreach (CardRef cardRef in cards)
            {
                profileLookup[(cardRef.card).name] = new Tuple<Profile, float>(profile, cardRef.pitchShift);
            }
        }
    }

    public void OnDisable()
    {
        Events.OnEntityKilled -= EntityKilled;
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        if (profileLookup.TryGetValue((entity.data).name, out var value))
        {
            Profile item = value.Item1;
            float item2 = value.Item2;
            if (CheckChance(item.chance))
            {
                EventInstance val = SfxSystem.OneShot(item.eventReference);
                ((val)).setPitch(1f + item2);
            }
        }
    }

    public bool CheckChance(float chance)
    {
        if (PettyRandom.Range(0f, 1f) < chance * currentGlobalChance)
        {
            currentGlobalChance = globalChance;
            return true;
        }
        currentGlobalChance += globalChanceAdd;
        return false;
    }
}
public class FleeSfxSystem : GameSystem
{
    [Serializable]
    public class Profile
    {
        public EventReference eventReference;

        public CardData[] cards;

        public float chance;
    }

    [SerializeField]
    public float globalChance = 1f;

    [SerializeField]
    public Profile[] profiles;

    [SerializeField]
    public EventReference fallbackEnemy;

    [SerializeField]
    public EventReference fallbackPlayer;

    [SerializeField]
    public CardData[] excludeFromFallback;

    public readonly Dictionary<string, Profile> profileLookup = new Dictionary<string, Profile>();

    public void OnEnable()
    {
        Events.OnEntityFlee += EntityFlee;
        profileLookup.Clear();
        Profile[] array = profiles;
        foreach (Profile profile in array)
        {
            CardData[] cards = profile.cards;
            foreach (CardData cardData in cards)
            {
                profileLookup[(cardData).name] = profile;
            }
        }
    }

    public void OnDisable()
    {
        Events.OnEntityFlee -= EntityFlee;
    }

    public void EntityFlee(Entity entity)
    {
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0098: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        //IL_009d: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a9: Unknown result type (might be due to invalid IL or missing references)
        if (profileLookup.TryGetValue((entity.data).name, out var value))
        {
            if (CheckChance(value.chance * globalChance))
            {
                SfxSystem.OneShot(value.eventReference);
            }
        }
        else if (excludeFromFallback.All((CardData a) => (a).name != (entity.data).name) && CheckChance(globalChance))
        {
            SfxSystem.OneShot((entity.owner.team == References.Player.team) ? fallbackPlayer : fallbackEnemy);
            SfxSystem.OneShot(fallbackEnemy);
        }
    }

    public static bool CheckChance(float chance)
    {
        return PettyRandom.Range(0f, 1f) < chance;
    }
}
public class MusicSystem : GameSystem
{
    [Serializable]
    public class Music
    {
        public string sceneName;

        public EventReference eventId;
    }

    public static MusicSystem instance;

    public Music[] music;

    public Music[] eventMusic;

    public static EventInstance current;

    public static LTDescr fadePitchTween;

    public static float pitch = 1f;

    public void OnEnable()
    {
        instance = this;
        Events.OnSceneChanged += SceneChanged;
    }

    public void OnDisable()
    {
        Events.OnSceneChanged -= SceneChanged;
        StopMusic((STOP_MODE)0);
    }

    public void SceneChanged(Scene from, Scene to)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        SceneChanged(to);
    }

    public void SceneChanged(Scene scene)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        StopMusic((STOP_MODE)0);
        Music music = this.music.FirstOrDefault((Music a) => a.sceneName == ((scene)).name);
        if (music != null)
        {
            StartMusic(music.eventId.Guid);
        }
    }

    public static void StartMusic(EventReference eventId)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        StartMusic(eventId.Guid);
    }

    public static void StartMusic(GUID eventGUID)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Expected O, but got Unknown
        try
        {
            current = RuntimeManager.CreateInstance(eventGUID);
            ((current)).start();
        }
        catch (EventNotFoundException val)
        {
            Debug.LogWarning(val);
        }
    }

    public static void SetParam(string name, float value)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(current))
        {
            ((current)).setParameterByName(name, value, false);
        }
    }

    public static void StopMusic(STOP_MODE stopMode = 0)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(current))
        {
            ((current)).stop(stopMode);
            ((current)).release();
        }
    }

    public static void FadePitchTo(float value, float time)
    {
        fadePitchTween = LeanTween.value(((Component)instance).gameObject, pitch, value, time).setOnUpdate(delegate (float a)
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            pitch = a;
            if (IsRunning(current))
            {
                ((current)).setPitch(pitch);
            }
        });
    }

    public static bool IsRunning(EventInstance instance)
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Invalid comparison between Unknown and I4
        if (((instance)).isValid())
        {
            PLAYBACK_STATE val = default(PLAYBACK_STATE);
            ((instance)).getPlaybackState(ref val);
            if ((int)val != 2)
            {
                return true;
            }
        }
        return false;
    }
}
public class SfxSystem : GameSystem
{
    public readonly struct Param
    {
        public readonly string name;

        public readonly float value;

        public Param(string name, float value)
        {
            this.name = name;
            this.value = value;
        }
    }

    public class Cooldown
    {
        public string eventName;

        public float current;

        public readonly float max;

        public Cooldown(string eventName, float value)
        {
            this.eventName = eventName;
            current = 0f;
            max = value;
        }

        public void Max()
        {
            current = max;
        }
    }

    public static SfxSystem instance;

    public const float DRAG_THRESHOLD = 0.35f;

    public static readonly Dictionary<string, float> cooldownTimers = new Dictionary<string, float>
    {
        { "event:/sfx/card/hover", 0.1f },
        { "event:/sfx/card/flip_single", 0.075f },
        { "event:/sfx/card/enter_pocket", 0.1f },
        { "event:/sfx/status/block", 0.05f },
        { "event:/sfx/status/demonize", 0.05f },
        { "event:/sfx/status/heal", 0.05f },
        { "event:/sfx/status/power", 0.05f },
        { "event:/sfx/status/shell", 0.05f },
        { "event:/sfx/status/shroom", 0.05f },
        { "event:/sfx/status/snow", 0.05f },
        { "event:/sfx/status/spice", 0.05f },
        { "event:/sfx/status/sun", 0.05f },
        { "event:/sfx/status/teeth", 0.05f },
        { "event:/sfx/status/overburn", 0.05f },
        { "event:/sfx/status/scrap", 0.05f },
        { "event:/sfx/status/frenzy", 0.05f },
        { "event:/sfx/status/frost", 0.05f },
        { "event:/sfx/status/haze", 0.05f },
        { "event:/sfx/status/ink", 0.05f },
        { "event:/sfx/status/bom", 0.05f },
        { "event:/sfx/location/shop/crown_hover", 0.05f },
        { "event:/sfx/location/shop/charm_hover", 0.05f },
        { "event:/sfx/card/ping", 0.05f }
    };

    public static readonly Dictionary<string, Cooldown> cooldowns = new Dictionary<string, Cooldown>();

    [SerializeField]
    public AnimationCurve pathRevealPitch;

    [SerializeField]
    public EventReference test;

    public List<EventInstance> running;

    public Entity dragging;

    public Entity draggingItem;

    public bool dragTrigger;

    public Vector2 dragFrom;

    public EventInstance itemAim;

    public int revealActionsInQueue;

    public EventInstance flipMulti;

    public EventInstance transitionSnow;

    public EventInstance goldCounter;

    public EventInstance muncherFeed;

    public EventInstance drawMulti;

    public EventInstance townProgressionLoop;

    public GoldDisplay goldDisplay;

    public void OnEnable()
    {
        //IL_012e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0138: Expected O, but got Unknown
        //IL_0183: Unknown result type (might be due to invalid IL or missing references)
        //IL_018d: Expected O, but got Unknown
        //IL_0194: Unknown result type (might be due to invalid IL or missing references)
        //IL_019e: Expected O, but got Unknown
        //IL_024f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0259: Expected O, but got Unknown
        //IL_0260: Unknown result type (might be due to invalid IL or missing references)
        //IL_026a: Expected O, but got Unknown
        //IL_02f9: Unknown result type (might be due to invalid IL or missing references)
        //IL_0303: Expected O, but got Unknown
        //IL_030a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0314: Expected O, but got Unknown
        //IL_031b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0325: Expected O, but got Unknown
        instance = this;
        Events.OnEntityHit += EntityHit;
        Events.OnEntityHover += EntityHover;
        Events.OnEntityKilled += EntityKilled;
        Events.OnEntitySelect += EntitySelect;
        Events.OnEntityDrag += EntityDrag;
        Events.OnEntityRelease += EntityRelease;
        Events.OnEntityPlace += EntityPlace;
        Events.OnEntityFlipUp += EntityFlipUp;
        Events.OnEntityFlipDown += EntityFlipDown;
        Events.OnEntityTrigger += EntityTrigger;
        Events.OnEntityMove += EntityMove;
        Events.OnEntityFocus += Focus;
        Events.OnEntityEnterPocket += EntityEnterPocket;
        Events.OnEntityEnterBackpack += EntityEnterBackpack;
        Events.OnBattlePhaseStart += BattlePhaseStart;
        Events.OnStatusEffectApplied += StatusApplied;
        Events.OnCardDraw += CardDraw;
        Events.OnCardDrawEnd += new UnityAction(CardDrawEnd);
        Events.OnStatusIconChanged += StatusIconChanged;
        Events.OnDropGold += DropGold;
        Events.OnGoldFlyToBag += GoldFlyToBag;
        Events.OnCollectGold += CollectGold;
        Events.OnDeckpackOpen += new UnityAction(DeckpackOpen);
        Events.OnDeckpackClose += new UnityAction(DeckpackClose);
        Events.OnMapPathReveal += MapPathReveal;
        Events.OnMapNodeReveal += MapNodeReveal;
        Events.OnMapNodeHover += MapNodeHover;
        Events.OnMapNodeSelect += MapNodeSelect;
        Events.OnActionQueued += ActionQueued;
        Events.OnActionPerform += ActionPerform;
        Events.OnActionFinished += ActionFinished;
        Events.OnTransitionStart += TransitionStart;
        Events.OnTransitionEnd += TransitionEnd;
        Events.OnGoldCounterStart += GoldCounterStart;
        Events.OnMuncherDrag += new UnityAction(MuncherDrag);
        Events.OnMuncherDragCancel += new UnityAction(MuncherDragEnd);
        Events.OnMuncherFeed += MuncherFeed;
        Events.OnBombardShoot += BombardShoot;
        Events.OnBombardRocketFall += BombardRocketFall;
        Events.OnBombardRocketExplode += BombardRocketExplode;
        Events.OnButtonHover += ButtonHover;
        Events.OnButtonPress += ButtonPress;
        Events.OnProgressStart += ProgressStart;
        Events.OnProgressUpdate += ProgressUpdate;
        Events.OnProgressStop += new UnityAction(ProgressStop);
        Events.OnProgressDing += new UnityAction(ProgressDing);
        Events.OnProgressBlip += new UnityAction(ProgressBlip);
        Events.OnTownUnlock += TownUnlockPopUp;
        Events.OnUpgradeHover += UpgradeHover;
        Events.OnUpgradePickup += UpgradePickup;
        Events.OnUpgradeDrop += UpgradeDrop;
        Events.OnUpgradeAssign += UpgradeAssign;
        Events.OnShopItemHover += ShopItemHover;
        Events.OnAbilityTargetAdd += AbilityTargetAdd;
        Events.OnEntityPing += EntityPing;
        running = new List<EventInstance>();
        cooldowns.Clear();
        foreach (KeyValuePair<string, float> cooldownTimer in cooldownTimers)
        {
            cooldowns[cooldownTimer.Key] = new Cooldown(cooldownTimer.Key, cooldownTimer.Value);
        }
    }

    public void OnDisable()
    {
        //IL_0128: Unknown result type (might be due to invalid IL or missing references)
        //IL_0132: Expected O, but got Unknown
        //IL_017d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0187: Expected O, but got Unknown
        //IL_018e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0198: Expected O, but got Unknown
        //IL_0249: Unknown result type (might be due to invalid IL or missing references)
        //IL_0253: Expected O, but got Unknown
        //IL_025a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0264: Expected O, but got Unknown
        //IL_02f3: Unknown result type (might be due to invalid IL or missing references)
        //IL_02fd: Expected O, but got Unknown
        //IL_0304: Unknown result type (might be due to invalid IL or missing references)
        //IL_030e: Expected O, but got Unknown
        //IL_0315: Unknown result type (might be due to invalid IL or missing references)
        //IL_031f: Expected O, but got Unknown
        Events.OnEntityHit -= EntityHit;
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityKilled -= EntityKilled;
        Events.OnEntitySelect -= EntitySelect;
        Events.OnEntityDrag -= EntityDrag;
        Events.OnEntityRelease -= EntityRelease;
        Events.OnEntityPlace -= EntityPlace;
        Events.OnEntityFlipUp -= EntityFlipUp;
        Events.OnEntityFlipDown -= EntityFlipDown;
        Events.OnEntityTrigger -= EntityTrigger;
        Events.OnEntityMove -= EntityMove;
        Events.OnEntityFocus -= Focus;
        Events.OnEntityEnterPocket -= EntityEnterPocket;
        Events.OnEntityEnterBackpack -= EntityEnterBackpack;
        Events.OnBattlePhaseStart -= BattlePhaseStart;
        Events.OnStatusEffectApplied -= StatusApplied;
        Events.OnCardDraw -= CardDraw;
        Events.OnCardDrawEnd -= new UnityAction(CardDrawEnd);
        Events.OnStatusIconChanged -= StatusIconChanged;
        Events.OnDropGold -= DropGold;
        Events.OnGoldFlyToBag -= GoldFlyToBag;
        Events.OnCollectGold -= CollectGold;
        Events.OnDeckpackOpen -= new UnityAction(DeckpackOpen);
        Events.OnDeckpackClose -= new UnityAction(DeckpackClose);
        Events.OnMapPathReveal -= MapPathReveal;
        Events.OnMapNodeReveal -= MapNodeReveal;
        Events.OnMapNodeHover -= MapNodeHover;
        Events.OnMapNodeSelect -= MapNodeSelect;
        Events.OnActionQueued -= ActionQueued;
        Events.OnActionPerform -= ActionPerform;
        Events.OnActionFinished -= ActionFinished;
        Events.OnTransitionStart -= TransitionStart;
        Events.OnTransitionEnd -= TransitionEnd;
        Events.OnGoldCounterStart -= GoldCounterStart;
        Events.OnMuncherDrag -= new UnityAction(MuncherDrag);
        Events.OnMuncherDragCancel -= new UnityAction(MuncherDragEnd);
        Events.OnMuncherFeed -= MuncherFeed;
        Events.OnBombardShoot -= BombardShoot;
        Events.OnBombardRocketFall -= BombardRocketFall;
        Events.OnBombardRocketExplode -= BombardRocketExplode;
        Events.OnButtonHover -= ButtonHover;
        Events.OnButtonPress -= ButtonPress;
        Events.OnProgressStart -= ProgressStart;
        Events.OnProgressUpdate -= ProgressUpdate;
        Events.OnProgressStop -= new UnityAction(ProgressStop);
        Events.OnProgressDing -= new UnityAction(ProgressDing);
        Events.OnProgressBlip -= new UnityAction(ProgressBlip);
        Events.OnTownUnlock -= TownUnlockPopUp;
        Events.OnUpgradeHover -= UpgradeHover;
        Events.OnUpgradePickup -= UpgradePickup;
        Events.OnUpgradeDrop -= UpgradeDrop;
        Events.OnUpgradeAssign -= UpgradeAssign;
        Events.OnShopItemHover -= ShopItemHover;
        Events.OnAbilityTargetAdd -= AbilityTargetAdd;
        Events.OnEntityPing -= EntityPing;
        StopAll((STOP_MODE)1);
        running = null;
    }

    public void Update()
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fa: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ce: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d8: Unknown result type (might be due to invalid IL or missing references)
        //IL_0126: Unknown result type (might be due to invalid IL or missing references)
        for (int num = running.Count - 1; num >= 0; num--)
        {
            EventInstance eventInstance = running[num];
            if (!IsRunning(eventInstance))
            {
                ((eventInstance)).release();
                running.RemoveAt(num);
            }
        }
        foreach (KeyValuePair<string, Cooldown> cooldown in cooldowns)
        {
            if (cooldown.Value.current > 0f)
            {
                cooldown.Value.current -= Time.deltaTime;
            }
        }
        if (dragTrigger)
        {
            if (!(dragging))
            {
                dragTrigger = false;
            }
            else
            {
                Vector2 val = (dragging.transform.position) - dragFrom;
                if (((val)).sqrMagnitude > 0.35f)
                {
                    dragTrigger = false;
                    OneShot("event:/sfx/card/drag");
                }
            }
        }
        if (IsRunning(goldCounter) && (!(goldDisplay) || goldDisplay.add == 0f))
        {
            Stop(goldCounter);
            goldDisplay = null;
        }
    }

    public static EventInstance OneShot(EventReference eventRef)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return OneShot(eventRef.Guid);
    }

    public static EventInstance OneShot(GUID guid)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        EventInstance result = RuntimeManager.CreateInstance(guid);
        ((result)).start();
        return result;
    }

    public static void OneShot(string eventName)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        RuntimeManager.PlayOneShot(eventName, default(Vector3));
    }

    public static void OneShotCheckCooldown(string eventName, bool resetCooldown = true)
    {
        if (CheckCooldown(eventName))
        {
            OneShot(eventName);
            if (resetCooldown)
            {
                SetCooldown(eventName);
            }
        }
    }

    public static void OneShot(string eventName, params Param[] parameters)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        EventInstance val = RuntimeManager.CreateInstance(eventName);
        for (int i = 0; i < parameters.Length; i++)
        {
            Param param = parameters[i];
            ((val)).setParameterByName(param.name, param.value, false);
        }
        ((val)).start();
        ((val)).release();
    }

    public EventInstance Play(string eventPath, params Param[] parameters)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0052: Expected O, but got Unknown
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        try
        {
            EventInstance val = RuntimeManager.CreateInstance(eventPath);
            for (int i = 0; i < parameters.Length; i++)
            {
                Param param = parameters[i];
                ((val)).setParameterByName(param.name, param.value, false);
            }
            running.Add(val);
            ((val)).start();
            return val;
        }
        catch (EventNotFoundException val2)
        {
            Debug.LogWarning(val2);
            return default(EventInstance);
        }
    }

    public EventInstance Play(EventReference eventRef, params Param[] parameters)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0052: Expected O, but got Unknown
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        try
        {
            EventInstance val = RuntimeManager.CreateInstance(eventRef);
            for (int i = 0; i < parameters.Length; i++)
            {
                Param param = parameters[i];
                ((val)).setParameterByName(param.name, param.value, false);
            }
            running.Add(val);
            ((val)).start();
            return val;
        }
        catch (EventNotFoundException val2)
        {
            Debug.LogWarning(val2);
            return default(EventInstance);
        }
    }

    public static void SetParam(EventInstance eventInstance, string param, float value)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(eventInstance))
        {
            ((eventInstance)).setParameterByName(param, value, false);
        }
    }

    public static void Stop(EventInstance eventInstance, STOP_MODE stopMode = 0)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(eventInstance))
        {
            ((eventInstance)).stop(stopMode);
            ((eventInstance)).release();
        }
    }

    public static bool IsRunning(EventInstance eventInstance)
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Invalid comparison between Unknown and I4
        if (((eventInstance)).isValid())
        {
            PLAYBACK_STATE val = default(PLAYBACK_STATE);
            ((eventInstance)).getPlaybackState(ref val);
            if ((int)val != 2)
            {
                return true;
            }
        }
        return false;
    }

    public static void SetCooldown(string eventName)
    {
        if (cooldowns.ContainsKey(eventName))
        {
            cooldowns[eventName].Max();
        }
    }

    public static bool CheckCooldown(string eventName)
    {
        if (cooldowns.ContainsKey(eventName))
        {
            return cooldowns[eventName].current <= 0f;
        }
        return true;
    }

    public static void SetGlobalParam(string paramName, float value)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        System studioSystem = RuntimeManager.StudioSystem;
        ((studioSystem)).setParameterByName(paramName, value, false);
    }

    public static EventInstance Loop(string eventName)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        return instance.Play(eventName);
    }

    public static EventInstance Loop(EventReference eventRef)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        return instance.Play(eventRef);
    }

    public static void EndLoop(EventInstance? inst)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        if (inst.HasValue)
        {
            EventInstance valueOrDefault = inst.GetValueOrDefault();
            if (IsRunning(valueOrDefault))
            {
                Stop(valueOrDefault);
            }
        }
    }

    public static int GetHitPower(Hit hit)
    {
        return hit.damage + hit.damageBlocked + hit.extraOffensiveness;
    }

    public static void EntityHit(Hit hit)
    {
        if (!hit.Offensive || !hit.doAnimation || !hit.countsAsHit || !(hit.target))
        {
            return;
        }
        int hitPower = GetHitPower(hit);
        if (hitPower >= 0)
        {
            switch (hit.damageType)
            {
                case "basic":
                    OneShot("event:/sfx/attack/hit_level", new Param("power", Mathf.Max(1, hitPower)));
                    break;
                case "shroom":
                    OneShot("event:/sfx/status/shroom_damage");
                    break;
                case "spikes":
                    OneShot("event:/sfx/status/teeth_damage");
                    break;
                case "overload":
                    OneShot("event:/sfx/status/overburn_damage");
                    break;
            }
        }
    }

    public static void EntityHover(Entity entity)
    {
        OneShotCheckCooldown("event:/sfx/card/hover", resetCooldown: false);
    }

    public static void EntityKilled(Entity entity, DeathType deathType)
    {
        if (deathType == DeathType.Normal || deathType == DeathType.Eaten)
        {
            OneShot("event:/sfx/card/destroy");
        }
        if ((entity) && (entity.data))
        {
            CardType cardType = entity.data.cardType;
            if (cardType != null && cardType.miniboss)
            {
                OneShot("event:/sfx/card/destroy_boss");
            }
        }
    }

    public static void EntitySelect(Entity entity)
    {
        OneShot("event:/sfx/card/click");
    }

    public void EntityDrag(Entity entity)
    {
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_0089: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0093: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        dragging = entity;
        if (!entity.inPlay)
        {
            dragTrigger = true;
            dragFrom = (entity.transform.position);
            return;
        }
        if (entity.data.cardType.item)
        {
            string eventPath = (entity.IsOffensive() ? "event:/sfx/attack/item_aim_offensive" : "event:/sfx/attack/item_aim_supportive");
            itemAim = Play(eventPath);
            draggingItem = entity;
        }
        if (entity.data.playType == Card.PlayType.Place)
        {
            dragTrigger = true;
            dragFrom = (entity.transform.position);
        }
    }

    public void EntityRelease(Entity entity)
    {
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        if (dragging == entity)
        {
            dragging = null;
            SetCooldown("event:/sfx/card/hover");
        }
        if (draggingItem == entity && IsRunning(itemAim))
        {
            SetParam(itemAim, "stop", 1f);
            draggingItem = null;
        }
    }

    public static void EntityPlace(Entity entity, CardContainer[] containers, bool freeMove)
    {
        OneShot("event:/sfx/card/place");
    }

    public static void EntityFlipUp(Entity entity)
    {
        OneShotCheckCooldown("event:/sfx/card/flip_single");
    }

    public static void EntityFlipDown(Entity entity)
    {
        OneShotCheckCooldown("event:/sfx/card/flip_single");
    }

    public static void EntityTrigger(ref Trigger trigger)
    {
        CardType cardType = trigger.entity.data.cardType;
        if (cardType != null && cardType.item && trigger.triggeredBy == trigger.entity.owner.entity)
        {
            OneShot("event:/sfx/attack/item_use");
        }
    }

    public static void EntityMove(Entity entity)
    {
        Character enemy = Battle.instance.enemy;
        if (enemy != null && entity.owner == enemy && IArrayExt.Contains<CardContainer>(entity.preContainers, enemy.reserveContainer))
        {
            OneShot("event:/sfx/card/enemy_showup");
        }
    }

    public static void Focus(Entity entity)
    {
        OneShot("event:/sfx/card/drag");
    }

    public static void EntityEnterPocket(Entity entity, CardPocket pocket)
    {
        OneShotCheckCooldown("event:/sfx/card/enter_pocket");
    }

    public static void EntityEnterBackpack(Entity entity)
    {
        OneShotCheckCooldown("event:/sfx/card/enter_backpack");
    }

    public static void BattlePhaseStart(Battle.Phase phase)
    {
        if (phase == Battle.Phase.Battle)
        {
            OneShot("event:/sfx/inventory/battle_zoom_in");
        }
        else if (Battle.instance.phase == Battle.Phase.Battle)
        {
            OneShot("event:/sfx/inventory/battle_zoom_out");
        }
    }

    public static void StatusApplied(StatusEffectApply apply)
    {
        if ((apply?.effectData) && apply.target.display.init && apply.target.startingEffectsApplied && !Transition.Running)
        {
            switch (apply.effectData.type)
            {
                case "snow":
                    OneShotCheckCooldown("event:/sfx/status/snow");
                    break;
                case "shroom":
                    OneShotCheckCooldown("event:/sfx/status/shroom");
                    break;
                case "shell":
                    OneShotCheckCooldown("event:/sfx/status/shell");
                    break;
                case "spice":
                    OneShotCheckCooldown("event:/sfx/status/spice");
                    break;
                case "demonize":
                    OneShotCheckCooldown("event:/sfx/status/demonize");
                    break;
                case "block":
                    OneShotCheckCooldown("event:/sfx/status/block");
                    break;
                case "frost":
                    OneShotCheckCooldown("event:/sfx/status/frost");
                    break;
                case "teeth":
                    OneShotCheckCooldown("event:/sfx/status/teeth");
                    break;
                case "overload":
                    OneShotCheckCooldown("event:/sfx/status/overburn");
                    break;
                case "scrap":
                    OneShotCheckCooldown("event:/sfx/status/scrap");
                    break;
                case "frenzy":
                    OneShotCheckCooldown("event:/sfx/status/frenzy");
                    break;
                case "haze":
                    OneShotCheckCooldown("event:/sfx/status/haze");
                    break;
                case "ink":
                    OneShotCheckCooldown("event:/sfx/status/ink");
                    break;
                case "vim":
                    OneShotCheckCooldown("event:/sfx/status/bom");
                    break;
                case "heal":
                    OneShotCheckCooldown("event:/sfx/status/heal");
                    break;
                case "max health up":
                    OneShotCheckCooldown("event:/sfx/status/heal");
                    break;
                case "damage up":
                    OneShotCheckCooldown("event:/sfx/status/power");
                    break;
                case "counter down":
                    OneShotCheckCooldown("event:/sfx/status/sun");
                    break;
                case "max counter down":
                    OneShotCheckCooldown("event:/sfx/status/sun");
                    break;
            }
        }
    }

    public void CardDraw(int amount)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(drawMulti))
        {
            Stop(drawMulti);
        }
        drawMulti = Play("event:/sfx/card/draw_multi");
    }

    public void CardDrawEnd()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(drawMulti))
        {
            SetParam(drawMulti, "draw_stop", 1f);
        }
    }

    public static void StatusIconChanged(StatusIcon icon, Stat previousValue, Stat newValue)
    {
        if (Transition.Running)
        {
            return;
        }
        switch (icon.type)
        {
            case "counter":
                if (newValue.current < previousValue.current)
                {
                    OneShot("event:/sfx/status_icon/counter_decrease");
                }
                else if (newValue.current > previousValue.current)
                {
                    OneShot("event:/sfx/status_icon/counter_increase");
                }
                break;
            case "snow":
                if (newValue.current < previousValue.current)
                {
                    OneShot("event:/sfx/status_icon/snow_decrease");
                }
                break;
            case "scrap":
                if (newValue.current < previousValue.current)
                {
                    OneShot("event:/sfx/status_icon/scrap_decrease");
                }
                break;
            case "shell":
                if (newValue.current < previousValue.current)
                {
                    OneShot("event:/sfx/status_icon/shell_decrease");
                }
                break;
        }
    }

    public static void DropGold(int amount, string source, Character owner, Vector3 position)
    {
        if (!(source == "Flee"))
        {
            int num = ((SceneManager.ActiveSceneName == "Battle") ? 1 : 0);
            OneShot("event:/sfx/inventory/bling_dropping", new Param("battle", num));
        }
    }

    public static void GoldFlyToBag(int amount, Character owner, Vector3 position)
    {
        OneShot("event:/sfx/inventory/bling_flying");
    }

    public static void CollectGold(int amount)
    {
        OneShot("event:/sfx/inventory/bling_collect");
    }

    public static void DeckpackOpen()
    {
        OneShot("event:/sfx/inventory/backpack_opening");
    }

    public static void DeckpackClose()
    {
        OneShot("event:/sfx/inventory/backpack_closing");
    }

    public void MapPathReveal(float totalTime)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        EventInstance mapPathReveal = Play("event:/sfx/map/path_showup");
        Debug.Log("> Playing path_showup");
        StartCoroutine(MapPathRevealRoutine(mapPathReveal, totalTime));
    }

    public IEnumerator MapPathRevealRoutine(EventInstance mapPathReveal, float totalTime)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        float time = 0f;
        while (time < totalTime && IsRunning(mapPathReveal))
        {
            time += Time.deltaTime;
            float num = time / totalTime;
            float pitch = pathRevealPitch.Evaluate(num);
            ((mapPathReveal)).setPitch(pitch);
            if (time >= totalTime)
            {
                Stop(mapPathReveal);
                break;
            }
            yield return (object)new WaitForFixedUpdate();
        }
    }

    public static void MapNodeReveal(MapNode node)
    {
        OneShot("event:/sfx/map/location_showup");
    }

    public static void MapNodeHover(MapNode node)
    {
        OneShot("event:/sfx/map/location_hover");
    }

    public static void MapNodeSelect(MapNode node)
    {
        if (node != null)
        {
            OneShot("event:/sfx/map/location_select");
            if (node.campaignNode.type.isBattle)
            {
                OneShot(node.campaignNode.type.isBoss ? "event:/sfx/map/location_select_battle_boss" : "event:/sfx/map/location_select_battle");
            }
        }
        else
        {
            OneShot("event:/sfx/ui/deny");
        }
    }

    public void ActionQueued(PlayAction action)
    {
        if (action is ActionReveal)
        {
            revealActionsInQueue++;
        }
    }

    public void ActionPerform(PlayAction action)
    {
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        if (action is ActionReveal && revealActionsInQueue > 1 && !IsRunning(flipMulti))
        {
            flipMulti = Play("event:/sfx/card/flip_multi");
        }
    }

    public void ActionFinished(PlayAction action)
    {
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        if (action is ActionReveal && --revealActionsInQueue <= 0)
        {
            SetParam(flipMulti, "flip_stop", 1f);
        }
    }

    public void TransitionStart(TransitionType transition)
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        if (transition is TransitionSnow)
        {
            transitionSnow = Play("event:/sfx/transition/snow");
        }
    }

    public void TransitionEnd(TransitionType transition)
    {
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        if (transition is TransitionSnow && IsRunning(transitionSnow))
        {
            SetParam(transitionSnow, "transition_end", 1f);
        }
    }

    public void GoldCounterStart(GoldDisplay display, float addAmount)
    {
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        GoldCounterStop();
        if (addAmount > 0f)
        {
            goldDisplay = display;
            goldCounter = Play("event:/sfx/inventory/bling_counter_up");
        }
        else if (addAmount < 0f)
        {
            goldDisplay = display;
            goldCounter = Play("event:/sfx/inventory/bling_counter_down");
        }
    }

    public void GoldCounterStop()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(goldCounter))
        {
            Stop(goldCounter);
        }
    }

    public void MuncherDrag()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        muncherFeed = Play("event:/sfx/location/muncher/feed");
    }

    public void MuncherDragEnd()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(muncherFeed))
        {
            Stop(muncherFeed);
        }
    }

    public void MuncherFeed(Entity entity)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(muncherFeed))
        {
            Stop(muncherFeed);
            OneShot("event:/sfx/location/muncher/eat");
        }
    }

    public static void BombardShoot(Entity entity)
    {
        OneShot("event:/sfx/specific/boss_shooting");
    }

    public static void BombardRocketFall(BombardRocket rocket)
    {
        OneShot("event:/sfx/specific/boss_rockets_flying");
    }

    public static void BombardRocketExplode(BombardRocket rocket)
    {
        OneShot("event:/sfx/specific/boss_rockets_impact");
    }

    public static void ButtonHover(ButtonType buttonType)
    {
        if (buttonType != ButtonType.Bell)
        {
            OneShot("event:/sfx/ui/menu_hover");
        }
        else
        {
            OneShot("event:/sfx/modifiers/bell_hovering");
        }
    }

    public static void ButtonPress(ButtonType buttonType)
    {
        switch (buttonType)
        {
            default:
                OneShot("event:/sfx/ui/menu_click");
                break;
            case ButtonType.Sub:
                OneShot("event:/sfx/ui/menu_click_sub");
                break;
            case ButtonType.Back:
                OneShot("event:/sfx/ui/menu_click_back");
                break;
        }
    }

    public void ProgressStart(float fill)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        townProgressionLoop = Loop("event:/sfx/town_progress/ramp");
        SetParam(townProgressionLoop, "townramp", fill);
    }

    public void ProgressUpdate(float fill)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning(townProgressionLoop))
        {
            SetParam(townProgressionLoop, "townramp", fill);
        }
    }

    public void ProgressStop()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        Stop(townProgressionLoop);
    }

    public static void ProgressDing()
    {
        OneShot("event:/sfx/town_progress/achieved");
    }

    public static void ProgressBlip()
    {
        OneShot("event:/sfx/town_progress/blip");
    }

    public static void TownUnlockPopUp(UnlockData unlockData)
    {
        OneShot("event:/sfx/town_progress/notification");
    }

    public static void UpgradeHover(UpgradeDisplay upgradeDisplay)
    {
        if (upgradeDisplay.data.type != CardUpgradeData.Type.Crown)
        {
            OneShot("event:/sfx/inventory/charm_hover");
        }
        else
        {
            OneShot("event:/sfx/inventory/crown_hover");
        }
    }

    public static void UpgradePickup(UpgradeDisplay upgradeDisplay)
    {
        if (upgradeDisplay.data.type != CardUpgradeData.Type.Crown)
        {
            OneShot("event:/sfx/inventory/charm_pickup");
        }
        else
        {
            OneShot("event:/sfx/inventory/crown_pickup");
        }
    }

    public static void UpgradeDrop(UpgradeDisplay upgradeDisplay)
    {
        if (upgradeDisplay.data.type != CardUpgradeData.Type.Crown)
        {
            OneShot("event:/sfx/inventory/charm_return");
        }
        else
        {
            OneShot("event:/sfx/inventory/crown_return");
        }
    }

    public static void UpgradeAssign(Entity entity, CardUpgradeData upgradeData)
    {
        if (upgradeData.type == CardUpgradeData.Type.Crown)
        {
            OneShot("event:/sfx/inventory/crown_assign");
        }
    }

    public static void ShopItemHover(ShopItem shopItem)
    {
        CrownHolderShop component = ((Component)shopItem).GetComponent<CrownHolderShop>();
        if (component != null && component.hasCrown && ((Behaviour)component).enabled)
        {
            OneShotCheckCooldown("event:/sfx/location/shop/crown_hover");
            return;
        }
        CharmMachine component2 = ((Component)shopItem).GetComponent<CharmMachine>();
        if (component2 != null && ((Behaviour)component2).enabled)
        {
            OneShotCheckCooldown("event:/sfx/location/shop/charm_hover");
        }
    }

    public static void AbilityTargetAdd(CardContainer container)
    {
        OneShot("event:/sfx/specific/boss_targets");
    }

    public static void EntityPing(GameObject obj)
    {
        OneShot("event:/sfx/card/ping");
    }

    public void StopAll(STOP_MODE stopMode = 1)
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        foreach (EventInstance item in running)
        {
            EventInstance current = item;
            ((current)).stop(stopMode);
            ((current)).release();
        }
        cooldowns.Clear();
    }
}
public class ShoveSystem : GameSystem
{
    public static readonly List<Entity> shovedFrom = new List<Entity>();

    public static Entity dragging;

    public static readonly int[] shoveDirs = new int[2] { -1, 1 };

    public static bool Active { get; set; }

    public static CardSlot Slot { get; set; }

    public static Vector3 Position => ((Component)Slot).transform.position - Vector3.Scale(dragging.offset.localPosition, dragging.transform.localScale);

    public static bool Fix { get; set; }

    public void OnEnable()
    {
        Events.OnEntityDrag += DragStart;
        Events.OnEntityRelease += DragEnd;
        Events.OnSlotHover += SlotHover;
        Events.OnSlotUnHover += SlotUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityDrag -= DragStart;
        Events.OnEntityRelease -= DragEnd;
        Events.OnSlotHover -= SlotHover;
        Events.OnSlotUnHover -= SlotUnHover;
    }

    public static void DragStart(Entity entity)
    {
        dragging = entity;
    }

    public static void DragEnd(Entity entity)
    {
        dragging = null;
        if (Active && !Fix)
        {
            ClearShove();
        }
    }

    public static void SlotHover(CardSlot slot)
    {
        if (Slot != null && Slot != slot)
        {
            ClearShove();
        }
    }

    public static void SlotUnHover(CardSlot slot)
    {
        if (Active && Slot != null && Slot == slot && !Fix)
        {
            ClearShove();
        }
    }

    public static bool CanShove(Entity shovee, Entity shover, out Dictionary<Entity, List<CardSlot>> shoveData)
    {
        shoveData = new Dictionary<Entity, List<CardSlot>>();
        if (!Events.CheckEntityShove(shovee))
        {
            return false;
        }
        List<int> list = IArrayExt.ToList<int>(shoveDirs);
        if (shover.positionPriority > shovee.positionPriority)
        {
            list.Remove(-1);
        }
        if (shovee.positionPriority > shover.positionPriority)
        {
            list.Remove(1);
        }
        bool flag = false;
        foreach (int item in list)
        {
            CardSlot[] array = FindSlots(shovee, item);
            if (array != null && array.Length != 0)
            {
                flag = CanShoveTo(shovee, shover, item, array, out shoveData);
                if (flag)
                {
                    break;
                }
            }
        }
        if (!flag && (shover == null || shover.data == null || shover.data.canShoveToOtherRow))
        {
            flag = CanShoveToOtherRow(shovee, shover, out shoveData);
        }
        return flag;
    }

    public static CardSlot[] FindSlots(Entity shovee, int dir)
    {
        bool flag = false;
        List<CardSlot> list = new List<CardSlot>();
        CardContainer[] containers = shovee.containers;
        for (int i = 0; i < containers.Length; i++)
        {
            if (!(containers[i] is CardSlotLane cardSlotLane))
            {
                flag = true;
                break;
            }
            int num = cardSlotLane.IndexOf(shovee) + dir;
            if (num < 0 || num >= cardSlotLane.max)
            {
                flag = true;
                break;
            }
            list.Add(cardSlotLane.slots[num]);
        }
        if (!flag)
        {
            return list.ToArray();
        }
        return null;
    }

    public static bool CanShoveTo(Entity shovee, Entity shover, int dir, CardSlot[] slots, out Dictionary<Entity, List<CardSlot>> shoveData)
    {
        shoveData = new Dictionary<Entity, List<CardSlot>>();
        int num = 1;
        Queue<KeyValuePair<Entity, CardSlot[]>> queue = new Queue<KeyValuePair<Entity, CardSlot[]>>();
        queue.Enqueue(new KeyValuePair<Entity, CardSlot[]>(shovee, slots));
        List<Entity> list = new List<Entity>();
        bool result = false;
        while (queue.Count > 0)
        {
            KeyValuePair<Entity, CardSlot[]> keyValuePair = queue.Dequeue();
            Entity key = keyValuePair.Key;
            list.Add(key);
            CardSlot[] value = keyValuePair.Value;
            if (value == null || value.Length == 0)
            {
                break;
            }
            List<CardSlot> list2 = new List<CardSlot>();
            CardSlot[] array = value;
            foreach (CardSlot cardSlot in array)
            {
                if (shoveData.ContainsKey(key))
                {
                    shoveData[key].Add(cardSlot);
                }
                else
                {
                    shoveData[key] = new List<CardSlot> { cardSlot };
                }
                Entity top = cardSlot.GetTop();
                if (top != null && top != shover)
                {
                    list2.Add(cardSlot);
                }
            }
            num--;
            foreach (CardSlot item in list2)
            {
                Entity blockingEntity = item.GetTop();
                if (!list.Contains(blockingEntity) && !queue.Any((KeyValuePair<Entity, CardSlot[]> p) => p.Key == blockingEntity))
                {
                    CardSlot[] value2 = FindSlots(blockingEntity, dir);
                    queue.Enqueue(new KeyValuePair<Entity, CardSlot[]>(blockingEntity, value2));
                    num++;
                }
            }
        }
        if (num <= 0)
        {
            result = true;
        }
        return result;
    }

    public static bool CanShoveToOtherRow(Entity shovee, Entity shover, out Dictionary<Entity, List<CardSlot>> shoveData)
    {
        shoveData = new Dictionary<Entity, List<CardSlot>>();
        if (shovee.containers.Length != 1)
        {
            return false;
        }
        if (!(shovee.containers[0] is CardSlotLane cardSlotLane))
        {
            return false;
        }
        int num = cardSlotLane.IndexOf(shovee);
        bool flag = false;
        foreach (CardContainer item in cardSlotLane.shoveTo)
        {
            if (!(item is CardSlotLane cardSlotLane2))
            {
                continue;
            }
            int num2 = cardSlotLane2.max - cardSlotLane2.Count;
            if (cardSlotLane2.Contains(shover))
            {
                num2++;
            }
            if (num2 <= 0)
            {
                continue;
            }
            int index = Mathf.Min(num, cardSlotLane2.max - 1);
            CardSlot cardSlot = cardSlotLane2.slots[index];
            int[] array = shoveDirs;
            foreach (int dir in array)
            {
                flag = CanShoveTo(shovee, shover, dir, new CardSlot[1] { cardSlot }, out shoveData);
                if (flag)
                {
                    break;
                }
            }
            if (flag)
            {
                break;
            }
        }
        return flag;
    }

    public static void ShowShove(CardSlot fromContainer, Dictionary<Entity, List<CardSlot>> shoveData)
    {
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_006f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_0094: Unknown result type (might be due to invalid IL or missing references)
        //IL_009e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a7: Unknown result type (might be due to invalid IL or missing references)
        Active = true;
        Slot = fromContainer;
        float time = 0.3f;
        LeanTweenType ease = LeanTweenType.easeOutQuart;
        foreach (KeyValuePair<Entity, List<CardSlot>> shoveDatum in shoveData)
        {
            Entity key = shoveDatum.Key;
            List<CardSlot> value = shoveDatum.Value;
            GameObject gameObject = ((Component)key).gameObject;
            LeanTween.cancel(gameObject);
            Vector3 val = Vector3.zero;
            foreach (CardSlot item in value)
            {
                val += ((Component)item).transform.position;
            }
            val /= (float)value.Count;
            LeanTween.move(gameObject, val, time).setEase(ease);
            shovedFrom.Add(key);
        }
    }

    public static IEnumerator DoShove(Dictionary<Entity, List<CardSlot>> shoveData, bool updatePositions = false)
    {
        foreach (KeyValuePair<Entity, List<CardSlot>> shoveDatum in shoveData)
        {
            shoveDatum.Key.RemoveFromContainers();
        }
        HashSet<CardContainer> hashSet = new HashSet<CardContainer>();
        foreach (KeyValuePair<Entity, List<CardSlot>> shoveDatum2 in shoveData)
        {
            Entity key = shoveDatum2.Key;
            foreach (CardSlot item in shoveDatum2.Value)
            {
                item.Add(key);
                hashSet.Add(item);
            }
        }
        if (updatePositions)
        {
            foreach (CardContainer item2 in hashSet)
            {
                item2.TweenChildPositions();
            }
        }
        Routine.Clump clump = new Routine.Clump();
        foreach (KeyValuePair<Entity, List<CardSlot>> shoveDatum3 in shoveData)
        {
            Events.InvokeEntityMove(shoveDatum3.Key);
            clump.Add(StatusEffectSystem.CardMoveEvent(shoveDatum3.Key));
        }
        yield return clump.WaitForEnd();
        Deactivate();
    }

    public static void ClearShove()
    {
        foreach (Entity item in shovedFrom)
        {
            foreach (CardContainer actualContainer in item.actualContainers)
            {
                actualContainer.TweenChildPosition(item);
            }
        }
        Deactivate();
    }

    public static void Deactivate()
    {
        shovedFrom.Clear();
        Slot = null;
        Fix = false;
        Active = false;
    }
}
public class SpecialEventsSystem : MonoBehaviour
{
    [Serializable]
    public struct Event
    {
        public CampaignNodeType nodeType;

        public UnlockData requiresUnlock;

        public string[] replaceNodeTypes;

        public int minTier;

        public Vector2Int perTier;

        public Vector2Int perRun;
    }

    [SerializeField]
    public Event[] events;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnPreCampaignPopulate += new UnityAction(PreCampaignPopulate);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnPreCampaignPopulate -= new UnityAction(PreCampaignPopulate);
    }

    public void PreCampaignPopulate()
    {
        List<List<CampaignNode>> tiers = CreateListOfNodes();
        Event[] array = events;
        foreach (Event specialEvent in array)
        {
            InsertSpecialEvent(tiers, specialEvent);
        }
    }

    public static void InsertSpecialEvent(List<List<CampaignNode>> tiers, Event specialEvent)
    {
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        if ((specialEvent.requiresUnlock) && Campaign.Data.GameMode.mainGameMode && !MetaprogressionSystem.IsUnlocked(specialEvent.requiresUnlock))
        {
            return;
        }
        int num = Vector2IntExt.Random(specialEvent.perRun);
        int num2 = 0;
        int[] array = new int[tiers.Count];
        do
        {
            foreach (List<CampaignNode> item in IEnumerableExt.InRandomOrder<List<CampaignNode>>((IEnumerable<List<CampaignNode>>)tiers))
            {
                int num3 = Vector2IntExt.Random(specialEvent.perTier);
                if (num3 > 0)
                {
                    foreach (CampaignNode item2 in item)
                    {
                        if (item2.tier < specialEvent.minTier || array[item2.tier] >= ((specialEvent.perTier)).y)
                        {
                            break;
                        }
                        if (IArrayExt.Contains<string>(specialEvent.replaceNodeTypes, (item2.type).name))
                        {
                            Debug.Log($"SpecialEventSystem → Replacing [{item2} ({(item2.type).name}) tier {item2.tier}] with ({(specialEvent.nodeType).name})");
                            item2.SetType(specialEvent.nodeType);
                            array[item2.tier]++;
                            num2++;
                            if (array[item2.tier] >= num3 || num2 >= num)
                            {
                                break;
                            }
                        }
                    }
                }
                if (num2 >= num)
                {
                    break;
                }
            }
        }
        while (num2 < ((specialEvent.perRun)).x);
    }

    public static List<List<CampaignNode>> CreateListOfNodes()
    {
        List<List<CampaignNode>> list = new List<List<CampaignNode>>();
        int num = 0;
        foreach (CampaignNode node in Campaign.instance.nodes)
        {
            if (node.tier >= 0)
            {
                num = Mathf.Max(num, node.tier + 1);
                while (list.Count <= node.tier)
                {
                    list.Add(new List<CampaignNode>());
                }
                int index = Random.Range(0, list[node.tier].Count - 1);
                list[node.tier].Insert(index, node);
            }
        }
        return list;
    }
}
public class SpeechBubbleSystem : GameSystem
{
    public delegate void NotifyCreate(SpeechBubbleData data);

    public static SpeechBubbleSystem instance;

    public SpeechBub bubblePrefab;

    public AnimationCurve wordToDurationCurve;

    public float durationFactor = 1f;

    public List<SpeechBubbleSpawn> spawnPoints;

    public List<SpeechBubbleData> queue;

    public SpeechBub current;

    public static event NotifyCreate OnCreate;

    public static void Create(SpeechBubbleData data)
    {
        SpeechBubbleSystem.OnCreate?.Invoke(data);
    }

    public void OnEnable()
    {
        instance = this;
        spawnPoints = new List<SpeechBubbleSpawn>();
        queue = new List<SpeechBubbleData>();
        OnCreate += QueueBubble;
    }

    public void OnDisable()
    {
        OnCreate -= QueueBubble;
        StopAllCoroutines();
    }

    public void Update()
    {
        if (queue.Count > 0 && (!(current) || current.durationFactor < 0.5f))
        {
            CreateBubble(queue[0]);
            queue.RemoveAt(0);
        }
    }

    public void QueueBubble(SpeechBubbleData data)
    {
        queue.Add(data);
    }

    public void CreateBubble(SpeechBubbleData data)
    {
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0091: Unknown result type (might be due to invalid IL or missing references)
        //IL_0096: Unknown result type (might be due to invalid IL or missing references)
        if (data.delay > 0f)
        {
            StartCoroutine(CreateBubbleAfter(data, data.delay));
        }
        else if (spawnPoints.Count > 0)
        {
            SpeechBubbleSpawn speechBubbleSpawn = null;
            data.SetDuration(GetDuration(data.text));
            if (!(data.target))
            {
                speechBubbleSpawn = IListExt.RandomItem<SpeechBubbleSpawn>((IList<SpeechBubbleSpawn>)spawnPoints);
            }
            else
            {
                Vector3 position = data.target.position;
                float num = float.MaxValue;
                foreach (SpeechBubbleSpawn spawnPoint in spawnPoints)
                {
                    float num2 = Vector3Ext.DistanceTo(((Component)spawnPoint).transform.position, position);
                    if (num2 < num)
                    {
                        num = num2;
                        speechBubbleSpawn = spawnPoint;
                    }
                }
            }
            if ((speechBubbleSpawn))
            {
                current = speechBubbleSpawn.Create(bubblePrefab, data);
            }
        }
        else
        {
            Debug.LogWarning("Speech Bubble could not be created: No anchor points in scene!");
        }
    }

    public IEnumerator CreateBubbleAfter(SpeechBubbleData data, float delay)
    {
        yield return (object)new WaitForSeconds(delay);
        data.delay = 0f;
        CreateBubble(data);
    }

    public static float GetDuration(string text)
    {
        string[] array = text.Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
        return instance.wordToDurationCurve.Evaluate((float)array.Length) * instance.durationFactor;
    }

    public void AddSpawnPoint(SpeechBubbleSpawn spawnPoint)
    {
        spawnPoints.Add(spawnPoint);
    }

    public void RemoveSpawnPoint(SpeechBubbleSpawn spawnPoint)
    {
        spawnPoints.Remove(spawnPoint);
    }
}
public class SpeechBubbleData
{
    public Transform target;

    public string targetName;

    public string text;

    public float delay;

    public float duration { get; set; }

    public SpeechBubbleData(Transform target, string targetName, string text, float delay = 0f)
    {
        this.target = target;
        this.targetName = targetName;
        this.text = text;
        this.delay = delay;
    }

    public void SetDuration(float duration)
    {
        this.duration = duration;
    }
}
public class Splatter : MonoBehaviour
{
    [SerializeField]
    public Sprite[] spriteOptions;

    [SerializeField]
    public Vector2 sizeRange = new Vector2(1.5f, 2f);

    [SerializeField]
    public Vector2 angleRange = new Vector2(0f, 360f);

    [SerializeField]
    public Image image;

    public bool fading { get; set; }

    public Sprite sprite
    {
        get
        {
            return image.sprite;
        }
        set
        {
            image.sprite = value;
        }
    }

    public Color color
    {
        get
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            return ((Graphic)image).color;
        }
        set
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            ((Graphic)image).color = value;
        }
    }

    public void Awake()
    {
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        image.sprite = spriteOptions[PettyRandom.Range(0, spriteOptions.Length - 1)];
        transform.localEulerAngles = new Vector3(0f, 0f, Vector2Ext.PettyRandom(angleRange));
        transform.localScale = Vector3.one * Vector2Ext.PettyRandom(sizeRange);
    }

    public void FadeOut()
    {
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        if (!fading)
        {
            LeanTween.cancel(gameObject);
            LeanTween.value(gameObject, ((Graphic)image).color.a, 0f, PettyRandom.Range(10f, 15f)).setOnUpdate(delegate (float a)
            {
                //IL_000c: Unknown result type (might be due to invalid IL or missing references)
                //IL_0021: Unknown result type (might be due to invalid IL or missing references)
                ((Graphic)image).color = ColorExt.With(((Graphic)image).color, -1f, -1f, -1f, a);
            }).setEase(LeanTweenType.easeInOutQuint)
                .setOnComplete((Action)delegate
                {
                    GameObjectExt.Destroy(gameObject);
                });
            fading = true;
        }
    }
}
public class SplatterParticle : MonoBehaviour
{
    public Splatter splatterPrefab;

    public bool canHitSource;

    public SplatterSurface source;

    [SerializeField]
    public Canvas canvas;

    [SerializeField]
    public Image image;

    [SerializeField]
    public Vector2 sizeRange = new Vector2(0.3f, 0.4f);

    public Vector3 velocity;

    public Vector3 gravity = new Vector3(0f, 0f, 1f);

    public Vector3 frictMult = new Vector3(0.99f, 0.99f, 0.99f);

    public bool isInBackground;

    [SerializeField]
    public float backgroundZThreshold = 1f;

    public Color color
    {
        get
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            return ((Graphic)image).color;
        }
        set
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            ((Graphic)image).color = value;
        }
    }

    public void Awake()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        transform.localScale = Vector3.one * Vector2Ext.PettyRandom(sizeRange);
    }

    public void Update()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a9: Unknown result type (might be due to invalid IL or missing references)
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d8: Unknown result type (might be due to invalid IL or missing references)
        Transform transform = transform;
        transform.position += velocity * Time.deltaTime;
        velocity += gravity * Time.deltaTime;
        velocity = Delta.Multiply(velocity, frictMult, Time.deltaTime);
        if (!isInBackground)
        {
            if (transform.position.z > backgroundZThreshold)
            {
                canvas.sortingLayerName = "Background";
                isInBackground = true;
                canHitSource = true;
            }
        }
        else if (transform.position.z < backgroundZThreshold)
        {
            canvas.sortingLayerName = "Default";
            isInBackground = true;
        }
        if (transform.position.z > 10f)
        {
            Object.Destroy(gameObject);
        }
    }

    public void SetSource(SplatterSurface source)
    {
        this.source = source;
    }

    public void OnTriggerEnter(Collider other)
    {
        SplatterSurface component = ((Component)other).gameObject.GetComponent<SplatterSurface>();
        if (component != null && (canHitSource || component != source))
        {
            component.Splat(this);
            GameObjectExt.Destroy(gameObject);
        }
    }
}
public class SplatterPersistenceSystem : GameSystem
{
    [Serializable]
    public class SplatterData
    {
        public Sprite sprite;

        public Color color;

        public Vector3 offset;

        public Vector3 scale;

        public float angle;

        public SplatterData()
        {
        }

        public SplatterData(Splatter splatter)
        {
            //IL_0014: Unknown result type (might be due to invalid IL or missing references)
            //IL_0019: Unknown result type (might be due to invalid IL or missing references)
            //IL_0027: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0033: Unknown result type (might be due to invalid IL or missing references)
            //IL_0038: Unknown result type (might be due to invalid IL or missing references)
            //IL_003f: Unknown result type (might be due to invalid IL or missing references)
            sprite = splatter.sprite;
            color = splatter.color;
            Transform transform = ((Component)splatter).transform;
            offset = transform.localPosition;
            scale = transform.localScale;
            angle = transform.localEulerAngles.z;
        }
    }

    [SerializeField]
    public int[] teamsToSave;

    [SerializeField]
    public Splatter basicSplatterPrefab;

    [SerializeField]
    [ReadOnly]
    public int savedCount;

    [SerializeField]
    [ReadOnly]
    public bool saveRequired;

    public Dictionary<ulong, SplatterData[]> storedSplatters;

    public void OnEnable()
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Expected O, but got Unknown
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Expected O, but got Unknown
        Events.OnEntityCreated += EntityCreated;
        Events.OnEntityDestroyed += EntityDestroyed;
        Events.OnCampaignSaved += new UnityAction(CheckSave);
        Events.OnCampaignLoaded += new UnityAction(Load);
        Events.OnCampaignFinal += new UnityAction(Clear);
    }

    public void OnDisable()
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Expected O, but got Unknown
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Expected O, but got Unknown
        Events.OnEntityCreated -= EntityCreated;
        Events.OnEntityDestroyed -= EntityDestroyed;
        Events.OnCampaignSaved -= new UnityAction(CheckSave);
        Events.OnCampaignLoaded -= new UnityAction(Load);
        Events.OnCampaignFinal -= new UnityAction(Clear);
    }

    public void EntityCreated(Entity entity)
    {
        if (storedSplatters != null && (entity.data) && storedSplatters.ContainsKey(entity.data.id) && (entity.splatterSurface))
        {
            SplatterData[] array = storedSplatters[entity.data.id];
            SplatterData[] array2 = array;
            foreach (SplatterData data in array2)
            {
                entity.splatterSurface.Load(data, basicSplatterPrefab);
            }
            Debug.Log($"Creating [{array.Length}] splatters on [{entity}]");
        }
    }

    public void EntityDestroyed(Entity entity)
    {
        if (!(entity.data != null) || !(entity.owner != null) || !IArrayExt.Contains<int>(teamsToSave, entity.owner.team) || (!entity.owner.data.inventory.deck.Contains(entity.data) && !entity.owner.data.inventory.reserve.Contains(entity.data)) || !(entity.splatterSurface != null))
        {
            return;
        }
        Splatter[] activeSplatters = entity.splatterSurface.GetActiveSplatters();
        if (activeSplatters != null && activeSplatters.Length > 0)
        {
            List<SplatterData> list = activeSplatters.Select((Splatter splatter) => new SplatterData(splatter)).ToList();
            if (storedSplatters == null)
            {
                storedSplatters = new Dictionary<ulong, SplatterData[]>();
            }
            if (storedSplatters.ContainsKey(entity.data.id))
            {
                storedSplatters[entity.data.id] = list.ToArray();
            }
            else
            {
                storedSplatters.Add(entity.data.id, list.ToArray());
                savedCount++;
            }
            saveRequired = true;
            Debug.Log($"Storing [{list.Count}] splatters on data for [{entity}]");
        }
    }

    public void CheckSave()
    {
        if (saveRequired && Campaign.Data.GameMode.doSave)
        {
            SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "splatter", storedSplatters);
            saveRequired = false;
        }
    }

    public void Load()
    {
        if (SaveSystem.CampaignDataExists(Campaign.Data.GameMode, "splatter"))
        {
            storedSplatters = SaveSystem.LoadCampaignData<Dictionary<ulong, SplatterData[]>>(Campaign.Data.GameMode, "splatter");
            savedCount = storedSplatters?.Count ?? 0;
        }
        else
        {
            Clear();
        }
    }

    public void Clear()
    {
        storedSplatters = null;
        savedCount = 0;
    }
}
public class SplatterSurface : MonoBehaviour, IPoolable
{
    public RectTransform splatterContainer;

    [SerializeField]
    public Vector2 splatterScaleRange = new Vector2(1f, 1f);

    [SerializeField]
    public Vector2 splatterAlphaRange = new Vector2(1f, 1f);

    [SerializeField]
    public bool limitSplatters;

    [SerializeField]
    [ShowIf("limitSplatters")]
    public int maxSplatters = 10;

    [SerializeField]
    public bool colorBlend;

    [SerializeField]
    [ShowIf("colorBlend")]
    public Vector2 colorBlendRange = new Vector2(0.2f, 0.4f);

    [SerializeField]
    [ShowIf("colorBlend")]
    public Color blend = Color.white;

    [SerializeField]
    public bool fadeSplatters;

    [SerializeField]
    [ShowIf("fadeSplatters")]
    public Color fadeToColour;

    [SerializeField]
    [ShowIf("fadeSplatters")]
    public float fadeToDelay;

    public readonly List<Splatter> splatters = new List<Splatter>();

    public void Splat(SplatterParticle particle)
    {
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_010c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0112: Unknown result type (might be due to invalid IL or missing references)
        //IL_011c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0121: Unknown result type (might be due to invalid IL or missing references)
        //IL_0123: Unknown result type (might be due to invalid IL or missing references)
        //IL_0129: Unknown result type (might be due to invalid IL or missing references)
        //IL_013e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0162: Unknown result type (might be due to invalid IL or missing references)
        //IL_016d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0177: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ad: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b9: Unknown result type (might be due to invalid IL or missing references)
        Splatter splatter = Object.Instantiate<Splatter>(particle.splatterPrefab, (Transform)(object)splatterContainer);
        Transform transform = ((Component)splatter).transform;
        splatters.Add(splatter);
        Color val = particle.color;
        if (colorBlend)
        {
            float num = Vector2Ext.PettyRandom(colorBlendRange);
            val = Color.Lerp(val, blend, num);
        }
        splatter.color = ColorExt.With(val, -1f, -1f, -1f, particle.color.a * Vector2Ext.PettyRandom(splatterAlphaRange));
        if (fadeSplatters)
        {
            Color from = splatter.color;
            Color to = fadeToColour;
            LeanTween.value(((Component)splatter).gameObject, 0f, 1f, PettyRandom.Range(10f, 15f)).setEase(LeanTweenType.easeInOutQuint).setDelay(fadeToDelay)
                .setOnUpdate(delegate (float a)
                {
                    //IL_0007: Unknown result type (might be due to invalid IL or missing references)
                    //IL_000d: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0013: Unknown result type (might be due to invalid IL or missing references)
                    splatter.color = Color.Lerp(from, to, a);
                });
        }
        Vector3 val2 = transform.localScale * Vector2Ext.PettyRandom(splatterScaleRange);
        transform.localScale = val2 * 0.5f;
        LeanTween.scale(((Component)splatter).gameObject, val2, PettyRandom.Range(0.12f, 0.18f)).setEase(LeanTweenType.easeOutBack);
        transform.position = ((Component)particle).transform.position;
        transform.localPosition = Vector3Ext.WithZ(transform.localPosition, 0f);
        if (limitSplatters)
        {
            int num2 = splatters.Count - maxSplatters;
            for (int i = 0; i < num2; i++)
            {
                splatters[0].FadeOut();
                splatters.RemoveAt(0);
            }
        }
    }

    public void Load(SplatterPersistenceSystem.SplatterData data, Splatter prefab)
    {
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        Splatter splatter = Object.Instantiate<Splatter>(prefab, (Transform)(object)splatterContainer);
        splatters.Add(splatter);
        splatter.sprite = data.sprite;
        splatter.color = data.color;
        Transform transform = ((Component)splatter).transform;
        transform.localPosition = data.offset;
        transform.localScale = data.scale;
        transform.localEulerAngles = new Vector3(0f, 0f, data.angle);
    }

    public Splatter[] GetActiveSplatters()
    {
        return splatters.Where((Splatter a) => !a.fading).ToArray();
    }

    public void OnGetFromPool()
    {
    }

    public void OnReturnToPool()
    {
        foreach (Splatter splatter in splatters)
        {
            Object.Destroy(((Component)splatter).gameObject);
        }
        splatters.Clear();
    }
}
public class SplatterSystem : GameSystem
{
    [SerializeField]
    [Range(0f, 2f)]
    public float spread = 1f;

    [SerializeField]
    public Vector2 speedRange = new Vector2(1f, 10f);

    [SerializeField]
    public Vector2 upSpeedRange = new Vector2(-1f, 0f);

    [SerializeField]
    [Range(0f, 2f)]
    public float bloodAmount = 1f;

    [SerializeField]
    [Range(1f, 10f)]
    public int maxPerHit = 6;

    [SerializeField]
    public Gradient rainbow;

    public static int BloodType;

    public static float BloodAmount;

    public void OnEnable()
    {
        Events.OnEntityHit += EntityHit;
        Events.OnSettingChanged += SettingChanged;
        BloodType = Settings.Load("Blood", 0);
        BloodAmount = Settings.Load("BloodAmount", 1f);
    }

    public void OnDisable()
    {
        Events.OnEntityHit -= EntityHit;
        Events.OnSettingChanged -= SettingChanged;
    }

    public static void SettingChanged(string key, object value)
    {
        if (!(key == "BloodAmount"))
        {
            if (key == "Blood" && value is int bloodType)
            {
                BloodType = bloodType;
            }
        }
        else if (value is float num)
        {
            BloodAmount = num;
        }
    }

    public void EntityHit(Hit hit)
    {
        //IL_00f0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00be: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c6: Unknown result type (might be due to invalid IL or missing references)
        //IL_014c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0151: Unknown result type (might be due to invalid IL or missing references)
        //IL_0153: Unknown result type (might be due to invalid IL or missing references)
        //IL_0165: Unknown result type (might be due to invalid IL or missing references)
        //IL_016f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0171: Unknown result type (might be due to invalid IL or missing references)
        //IL_017b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0180: Unknown result type (might be due to invalid IL or missing references)
        //IL_018b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0190: Unknown result type (might be due to invalid IL or missing references)
        //IL_0195: Unknown result type (might be due to invalid IL or missing references)
        //IL_0198: Unknown result type (might be due to invalid IL or missing references)
        //IL_019b: Unknown result type (might be due to invalid IL or missing references)
        //IL_01a5: Unknown result type (might be due to invalid IL or missing references)
        //IL_01aa: Unknown result type (might be due to invalid IL or missing references)
        if (!hit.Offensive || hit.nullified || !hit.BasicHit || !hit.countsAsHit || !(hit.target))
        {
            return;
        }
        BloodProfile bloodProfile = hit.target.data.bloodProfile;
        if ((bloodProfile))
        {
            int num = Mathf.RoundToInt((float)Mathf.Min(hit.damage, maxPerHit) * bloodAmount * bloodProfile.bleedFactor * BloodAmount);
            Vector3 val;
            Vector3 normalized;
            if ((hit.attacker) && (hit.target))
            {
                val = hit.target.transform.position - hit.attacker.transform.position;
                normalized = ((val)).normalized;
            }
            else
            {
                val = new Vector3(PettyRandom.Range(-1f, 1f), PettyRandom.Range(-1f, 1f), 0f);
                normalized = ((val)).normalized;
            }
            Vector3 val2 = normalized;
            Vector3 val3 = default(Vector3);
            for (int i = 0; i < num; i++)
            {
                SplatterParticle splatterParticle = Object.Instantiate<SplatterParticle>(bloodProfile.splatterParticlePrefab);
                ((val3))..ctor(PettyRandom.Range(-1f, 1f), PettyRandom.Range(-1.5f, 1.5f), 0f);
                ((Component)splatterParticle).transform.position = hit.target.transform.position + val3;
                splatterParticle.color = GetBloodColour(hit.target);
                Vector3 val4 = val2 * Vector2Ext.PettyRandom(speedRange) + PettyRandom.Vector3() * spread;
                splatterParticle.velocity = Vector3Ext.WithZ(val4, Vector2Ext.PettyRandom(upSpeedRange));
                splatterParticle.SetSource(((Component)hit.target).GetComponentInChildren<SplatterSurface>());
            }
        }
    }

    public Color GetBloodColour(Entity entity)
    {
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_009d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0097: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_009c: Unknown result type (might be due to invalid IL or missing references)
        if (BloodType == 1)
        {
            return rainbow.Evaluate(FloatExt.Mod(entity.data.random3.x, 1f));
        }
        return (!(entity.data.bloodProfile)) ? Color.white : (entity.data.bloodProfile.variableColor ? entity.data.bloodProfile.colorRange.Evaluate(FloatExt.Mod(entity.data.random3.x, 1f)) : entity.data.bloodProfile.color);
    }
}
public class StatsSystem : GameSystem
{
    public static StatsSystem instance;

    [SerializeField]
    public CampaignStats stats;

    public int goldThisBattle;

    public int sacrificedThisBattle;

    public bool kingMokoExists;

    public bool campaignEnded;

    public CampaignStats Stats => stats;

    public static CampaignStats Get()
    {
        return instance.Stats;
    }

    public static void Set(CampaignStats stats)
    {
        if (stats == null)
        {
            stats = new CampaignStats();
        }
        instance.stats = stats;
    }

    public void OnEnable()
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Expected O, but got Unknown
        //IL_00ea: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f4: Expected O, but got Unknown
        //IL_00fb: Unknown result type (might be due to invalid IL or missing references)
        //IL_0105: Expected O, but got Unknown
        //IL_0172: Unknown result type (might be due to invalid IL or missing references)
        //IL_017c: Expected O, but got Unknown
        instance = this;
        Events.OnCampaignEnd += CampaignEnd;
        Events.OnCampaignSaved += new UnityAction(CampaignSaved);
        Events.OnEntityHit += EntityHit;
        Events.OnEntityPostHit += PostEntityHit;
        Events.OnStatusEffectApplied += StatusApplied;
        Events.OnEntityKilled += EntityKilled;
        Events.OnEntityOffered += EntityOffered;
        Events.OnEntityChosen += EntityChosen;
        Events.OnEntityFlee += EntityFlee;
        Events.OnDiscard += EntityDiscarded;
        Events.OnEntitySummoned += EntitySummoned;
        Events.OnEntityTriggered += EntityTriggered;
        Events.OnCardInjured += CardInjured;
        Events.OnBattleStart += new UnityAction(BattleStart);
        Events.OnBattleEnd += new UnityAction(BattleEnd);
        Events.OnDropGold += DropGold;
        Events.OnSpendGold += SpendGold;
        Events.OnShopItemPurchase += ShopItemPurchase;
        Events.OnShopItemHaggled += ShopItemHaggled;
        Events.OnKillCombo += KillCombo;
        Events.OnRedrawBellHit += RedrawBellHit;
        Events.OnWaveDeployerEarlyDeploy += new UnityAction(WaveDeployerEarlyDeploy);
        Events.OnBattleTurnStart += BattleTurnStart;
        Events.OnRename += Rename;
        Events.OnMuncherFeed += MuncherFeed;
        Events.OnUpgradeGained += UpgradeGained;
        Events.OnUpgradeAssign += UpgradeAssigned;
    }

    public void OnDisable()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        //IL_00e4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ee: Expected O, but got Unknown
        //IL_00f5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ff: Expected O, but got Unknown
        //IL_016c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0176: Expected O, but got Unknown
        Events.OnCampaignEnd -= CampaignEnd;
        Events.OnCampaignSaved -= new UnityAction(CampaignSaved);
        Events.OnEntityHit -= EntityHit;
        Events.OnEntityPostHit -= PostEntityHit;
        Events.OnStatusEffectApplied -= StatusApplied;
        Events.OnEntityKilled -= EntityKilled;
        Events.OnEntityOffered -= EntityOffered;
        Events.OnEntityChosen -= EntityChosen;
        Events.OnEntityFlee -= EntityFlee;
        Events.OnDiscard -= EntityDiscarded;
        Events.OnEntitySummoned -= EntitySummoned;
        Events.OnEntityTriggered -= EntityTriggered;
        Events.OnCardInjured -= CardInjured;
        Events.OnBattleStart -= new UnityAction(BattleStart);
        Events.OnBattleEnd -= new UnityAction(BattleEnd);
        Events.OnDropGold -= DropGold;
        Events.OnSpendGold -= SpendGold;
        Events.OnShopItemPurchase -= ShopItemPurchase;
        Events.OnShopItemHaggled -= ShopItemHaggled;
        Events.OnKillCombo -= KillCombo;
        Events.OnRedrawBellHit -= RedrawBellHit;
        Events.OnWaveDeployerEarlyDeploy -= new UnityAction(WaveDeployerEarlyDeploy);
        Events.OnBattleTurnStart -= BattleTurnStart;
        Events.OnRename -= Rename;
        Events.OnMuncherFeed -= MuncherFeed;
        Events.OnUpgradeGained -= UpgradeGained;
        Events.OnUpgradeAssign -= UpgradeAssigned;
    }

    public void Update()
    {
        if (!campaignEnded)
        {
            stats.time += Time.deltaTime;
            if (stats.time >= 3600f)
            {
                stats.hours++;
                stats.time -= 3600f;
            }
        }
    }

    public void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
    {
        campaignEnded = true;
    }

    public void CampaignSaved()
    {
        if (Campaign.Data.GameMode.doSave)
        {
            SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "stats", stats);
        }
    }

    public void EntityHit(Hit hit)
    {
        bool flag = hit.target.owner == References.Player;
        if (!hit.Offensive)
        {
            return;
        }
        if (hit.owner == References.Player)
        {
            if (hit.damage > 0)
            {
                Stats.Add("damageDealt", hit.damageType, hit.damage);
                Stats.Max("highestDamageDealt", hit.damageType, hit.damage);
                if (flag)
                {
                    Stats.Add("friendlyDamageDealt", (hit.target.data).name, hit.damage);
                }
            }
            Stats.Add("cardsHit", (hit.target.data).name, 1);
        }
        if (flag)
        {
            Stats.Add("hitsTakenByCardType", (hit.target.data.cardType).name, 1);
            if (hit.damage > 0)
            {
                Stats.Add("damageTaken", hit.damageType, hit.damage);
            }
            if (hit.damageBlocked > 0)
            {
                Stats.Add("damageBlocked", hit.damageType, hit.damageBlocked);
            }
        }
    }

    public void PostEntityHit(Hit hit)
    {
        if (!hit.dodged && hit.damageDealt < 0 && hit.target.owner == References.Player && hit.owner == References.Player)
        {
            Stats.Add("amountHealedTo", (hit.target.data).name, -hit.damageDealt);
            if ((hit.attacker) && (hit.attacker.data))
            {
                Stats.Add("amountHealedFrom", (hit.attacker.data).name, -hit.damageDealt);
            }
            Stats.Max("highestHealth", hit.target.hp.current);
        }
    }

    public void StatusApplied(StatusEffectApply apply)
    {
        if (!(apply.applier))
        {
            return;
        }
        string text = ((apply.effectData) ? apply.effectData.type : null);
        if (!StringExt.IsNullOrWhitespace(text) && apply.applier.owner == References.Player)
        {
            Stats.Add("statusesApplied", text, apply.count);
            StatusEffectData statusEffectData = apply.target.FindStatus(apply.effectData);
            if ((statusEffectData))
            {
                Stats.Max("highestStatusEffect", text, statusEffectData.count);
            }
            string type = apply.effectData.type;
            if (type == "max health up" || type == "max health up only")
            {
                Stats.Max("highestHealth", apply.target.hp.current);
            }
        }
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        if (entity.owner == References.Player)
        {
            Stats.Add("friendliesDied", (entity.data).name, 1);
            if (DeathSystem.KilledByOwnTeam(entity))
            {
                Stats.Add("friendliesSacrificed", (entity.data).name, 1);
                sacrificedThisBattle++;
                Stats.Max("highestSacrificesInBattle", sacrificedThisBattle);
            }
            return;
        }
        Stats.Add("enemiesKilled", (entity.data).name, 1);
        Hit lastHit = entity.lastHit;
        if (lastHit == null)
        {
            return;
        }
        Entity attacker = lastHit.attacker;
        if (attacker == null)
        {
            return;
        }
        Character owner = attacker.owner;
        if (owner == null)
        {
            return;
        }
        CardData data = attacker.data;
        if (data == null)
        {
            return;
        }
        if ((entity.data).name == "FinalBoss")
        {
            Stats.Add("finalBossKills", (data).name, 1);
        }
        if (owner == References.Player)
        {
            Stats.Add("kills", (data).name, 1);
            Stats.Add("enemiesKilledByCardType", (data.cardType).name, 1);
            Stats.Add("enemiesKilledDamageType", entity.lastHit.damageType, 1);
            if (entity.lastHit.trigger != null)
            {
                Stats.Add("enemiesKilledTriggerType", entity.lastHit.trigger.type, 1);
            }
            if ((entity.data.cardType).name == "Boss")
            {
                Stats.Add("bossesKilled", (entity.data).name, 1);
            }
            if (entity.data.cardType.miniboss)
            {
                Stats.Add("minibossesKilledByCardType", (data.cardType).name, 1);
            }
            if ((entity.statusEffects.Find((StatusEffectData a) => a.type == "demonize")))
            {
                Stats.Add("demonizedEnemiesKilled", (data).name, 1);
            }
        }
    }

    public void EntityOffered(Entity entity)
    {
        Stats.Add("cardsOffered", (entity.data).name, 1);
    }

    public void EntityChosen(Entity entity)
    {
        Stats.Add("cardsChosen", (entity.data).name, 1);
        Stats.Add("cardTypesChosen", (entity.data.cardType).name, 1);
    }

    public void EntityFlee(Entity entity)
    {
        if (entity.owner != References.Player)
        {
            Stats.Add("enemiesEscaped", (entity.data).name, 1);
        }
    }

    public void EntityDiscarded(Entity entity)
    {
        if (entity.owner == References.Player)
        {
            Stats.Add("friendliesRecalled", (entity.data).name, 1);
        }
    }

    public void EntitySummoned(Entity entity, Entity summonedBy)
    {
        if (entity.data.cardType.unit)
        {
            Stats.Add("cardsSummoned", (entity.data).name, 1);
        }
    }

    public void EntityTriggered(ref Trigger trigger)
    {
        if (trigger.entity.owner == References.Player && !StringExt.IsNullOrWhitespace(trigger.type))
        {
            Stats.Add("totalTriggers", trigger.type, 1);
        }
        Stats.Add("cardsTriggered", (trigger.entity.data).name, 1);
    }

    public void CardInjured(CardData cardData)
    {
        Stats.Add("friendliesInjured", (cardData).name, 1);
    }

    public void BattleStart()
    {
        goldThisBattle = 0;
        sacrificedThisBattle = 0;
        List<Entity> cards = Battle.GetCards(References.Battle.enemy);
        kingMokoExists = (cards.FirstOrDefault((Entity a) => a.data.cardType.miniboss && (a.data).name == "MonkeyKing"));
    }

    public void BattleEnd()
    {
        string battleName = GetBattleName();
        if (References.Battle.winner == References.Player)
        {
            Stats.Add("battlesWon", battleName, 1);
            if (Battle.GetCardsOnBoard(References.Battle.player).Count == 1)
            {
                Stats.Add("winBattleWithOnlyLeaderRemaining", 1);
            }
            if (kingMokoExists && Stats.Get("cardsTriggered", "MonkeyKing", 0) > 0)
            {
                Stats.Add("winBattleSurviveKingMokoAttack", 1);
            }
            if (References.Player.handContainer.Count == 0 && References.Player.discardContainer.Count == 0 && References.Player.drawContainer.Count == 0)
            {
                Stats.Add("winBattleWithNoCardsInDeck", 1);
            }
        }
        else
        {
            Stats.Add("battlesLost", battleName, 1);
        }
        Stats.Max("highestGoldFromBattle", battleName, goldThisBattle);
    }

    public void DropGold(int amount, string source, Character owner, Vector3 position)
    {
        Stats.Add("goldGained", source, amount);
        goldThisBattle += amount;
    }

    public void SpendGold(int amount)
    {
        Stats.Add("goldSpent", amount);
    }

    public void ShopItemPurchase(ShopItem item)
    {
        if (item.priceFactor < 1f)
        {
            Stats.Add("discountsBought", 1);
        }
        string key = null;
        if (((Component)item).GetComponent<CharmMachine>() != null || ((Component)item).GetComponent<CardCharm>() != null)
        {
            key = "charm";
        }
        else if (((Component)item).GetComponent<CrownHolderShop>() != null)
        {
            key = "crown";
        }
        else if (((Component)item).GetComponent<Card>() != null)
        {
            key = "card";
        }
        int id = Campaign.FindCharacterNode(References.Player).id;
        if (Stats.Get("preShopId", -1) != id)
        {
            Stats.Set("preShopId", id);
            Stats.Delete("boughtInSingleShop");
            Stats.Set("boughtInSingleShop", key, 1);
        }
        else
        {
            Stats.Add("boughtInSingleShop", key, 1);
        }
        Stats.Add("shopItemsBought", key, 1);
    }

    public void ShopItemHaggled(ShopItem item)
    {
        Stats.Add("shopItemsHaggled", 1);
    }

    public void KillCombo(int combo)
    {
        Stats.Max("highestKillCombo", combo);
    }

    public void RedrawBellHit(RedrawBellSystem redrawBellSystem)
    {
        Stats.Add("redrawBellHits", 1);
    }

    public void WaveDeployerEarlyDeploy()
    {
        Stats.Add("enemyWaveBellHits", 1);
    }

    public void BattleTurnStart(int turnCount)
    {
        Stats.Add("turnsTaken", 1);
    }

    public void Rename(Entity entity, string newName)
    {
        Stats.Add("renames", newName, 1);
        Stats.Add("bestRename", newName, PettyRandom.Range(1, 1000));
    }

    public void MuncherFeed(Entity entity)
    {
        Stats.Add("cardsMunched", (entity.data).name, 1);
        if (entity.data.traits == null)
        {
            return;
        }
        foreach (CardData.TraitStacks trait in entity.data.traits)
        {
            if ((trait.data).name == "Consume")
            {
                Stats.Add("consumeCardsMunched", 1);
            }
        }
    }

    public void UpgradeGained(CardUpgradeData upgradeData)
    {
        switch (upgradeData.type)
        {
            case CardUpgradeData.Type.Charm:
                Stats.Add("charmsGained", (upgradeData).name, 1);
                break;
            case CardUpgradeData.Type.Crown:
                Stats.Add("crownsGained", (upgradeData).name, 1);
                break;
        }
    }

    public void UpgradeAssigned(Entity entity, CardUpgradeData upgradeData)
    {
        if (upgradeData.type == CardUpgradeData.Type.Charm)
        {
            Stats.Add("charmsAssigned", (upgradeData).name, 1);
            Stats.Add("charmsAssignedTo", (entity.data).name, 1);
        }
    }

    public static string GetBattleName()
    {
        if (Campaign.FindCharacterNode(References.Player).data.TryGetValue("battle", out var value) && value is string result)
        {
            return result;
        }
        return null;
    }
}
public class StormBellUnlockSystem : GameSystem
{
    public void OnEnable()
    {
        Events.OnCampaignEnd += CampaignEnd;
    }

    public void OnDisable()
    {
        Events.OnCampaignEnd -= CampaignEnd;
    }

    public void CampaignEnd(Campaign.Result result, CampaignStats stats, PlayerData playerData)
    {
        if (result != Campaign.Result.Win || !Campaign.Data.GameMode.mainGameMode)
        {
            return;
        }
        if (!SaveSystem.LoadProgressData("stormBellsUnlocked", defaultValue: false))
        {
            SaveSystem.SaveProgressData("stormBellsUnlocked", value: true);
        }
        List<string> list = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers");
        if (list == null)
        {
            list = new List<string>();
        }
        int currentStormPoints = StormBellManager.GetCurrentStormPoints(list);
        int num = SaveSystem.LoadProgressData("maxStormPoints", 5);
        if (currentStormPoints == num && num + 1 <= 10)
        {
            SaveSystem.SaveProgressData("maxStormPoints", num + 1);
            SaveSystem.SaveProgressData("maxStormPointIncrease", 1);
        }
        if (!SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "trueWin", defaultValue: false))
        {
            return;
        }
        List<string> list2 = SaveSystem.LoadProgressData<List<string>>("goldHardModeModifiers") ?? new List<string>();
        List<string> list3 = SaveSystem.LoadProgressData<List<string>>("goldHardModeModifiersNew") ?? new List<string>();
        bool flag = false;
        foreach (string item in list)
        {
            if (!list2.Contains(item))
            {
                list2.Add(item);
                list3.Add(item);
                flag = true;
            }
        }
        if (flag)
        {
            SaveSystem.SaveProgressData("goldHardModeModifiers", list2);
            SaveSystem.SaveProgressData("goldHardModeModifiersNew", list3);
        }
    }
}
public class DestroyTargetSystem : GameSystem
{
    [SerializeField]
    public Transform targetPrefab;

    [SerializeField]
    public Vector3 iconOffset;

    public Entity dragging;

    public Entity hover;

    public readonly Dictionary<Transform, Entity> targets = new Dictionary<Transform, Entity>();

    public readonly List<Transform> targetPool = new List<Transform>();

    public readonly HashSet<Entity> toIndicate = new HashSet<Entity>();

    public void OnEnable()
    {
        Events.OnEntityDrag += EntityDrag;
        Events.OnEntityRelease += EntityRelease;
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityDrag -= EntityDrag;
        Events.OnEntityRelease -= EntityRelease;
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
    }

    public void Start()
    {
        Events.OnSettingChanged += SettingChanged;
        if (Settings.Load("UnitTargets", 1) != 1)
        {
            enabled = false;
        }
    }

    public void OnDestroy()
    {
        Events.OnSettingChanged -= SettingChanged;
    }

    public void Update()
    {
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        foreach (KeyValuePair<Transform, Entity> target in targets)
        {
            Transform offset = target.Value.offset;
            Vector3 lossyScale = offset.lossyScale;
            target.Key.position = offset.position + Vector3.Scale(iconOffset, lossyScale);
            target.Key.localScale = lossyScale;
        }
    }

    public void EntityDrag(Entity entity)
    {
        dragging = entity;
        if ((hover))
        {
            HideTargets();
        }
    }

    public void EntityRelease(Entity entity)
    {
        if (dragging == entity)
        {
            dragging = null;
        }
    }

    public void EntityHover(Entity entity)
    {
        if (!(dragging))
        {
            if ((hover))
            {
                EntityUnHover(hover);
            }
            hover = entity;
            if (entity.inPlay)
            {
                ShowTargets(hover);
            }
        }
    }

    public void EntityUnHover(Entity entity)
    {
        if (hover == entity)
        {
            hover = null;
            HideTargets();
        }
    }

    public void SettingChanged(string key, object value)
    {
        if (key == "UnitTargets" && value is int num)
        {
            if (num == 0 && enabled)
            {
                enabled = false;
            }
            else if (num == 1 && !enabled)
            {
                enabled = true;
            }
        }
    }

    public void ShowTargets(Entity entity)
    {
        if (entity.silenced)
        {
            return;
        }
        foreach (StatusEffectData statusEffect in entity.statusEffects)
        {
            StatusEffectApplyX applyEffect = statusEffect as StatusEffectApplyX;
            if (applyEffect != null && !statusEffect.doesDamage)
            {
                if (CheckStatusEffectType(applyEffect))
                {
                    if ((applyEffect.applyToFlags & StatusEffectApplyX.ApplyToFlags.Hand) != 0)
                    {
                        CheckShowIconsForHand(applyEffect, toIndicate);
                    }
                    if ((applyEffect.applyToFlags & StatusEffectApplyX.ApplyToFlags.RightCardInHand) != 0)
                    {
                        CheckShowIconsForRightCardInHand(applyEffect, toIndicate);
                    }
                    continue;
                }
                StatusEffectData effectToApply = applyEffect.effectToApply;
                StatusEffectInstantDestroyCardsInHandAndApplyXForEach destroyAllEffect = effectToApply as StatusEffectInstantDestroyCardsInHandAndApplyXForEach;
                if (destroyAllEffect != null)
                {
                    HashSetExt.AddRange<Entity>(toIndicate, References.Player.handContainer.Where((Entity card) => card != applyEffect.target && destroyAllEffect.CheckConstraints(card)));
                }
            }
            else
            {
                if (!(statusEffect is StatusEffectRecycle statusEffectRecycle))
                {
                    continue;
                }
                int num = statusEffectRecycle.GetAmount();
                foreach (Entity item in References.Player.handContainer)
                {
                    if ((item.data).name == statusEffectRecycle.cardToRecycle)
                    {
                        toIndicate.Add(item);
                        if (--num <= 0)
                        {
                            break;
                        }
                    }
                }
            }
        }
        foreach (Entity item2 in toIndicate)
        {
            ShowIcon(item2);
        }
        toIndicate.Clear();
    }

    public static bool CheckStatusEffectType(StatusEffectApplyX applyEffect)
    {
        if (CheckApplyStatusEffectType(applyEffect.effectToApply))
        {
            return true;
        }
        if (applyEffect.effectToApply is StatusEffectInstantMultiple { effects: var effects })
        {
            for (int i = 0; i < effects.Length; i++)
            {
                if (CheckApplyStatusEffectType(effects[i]))
                {
                    return true;
                }
            }
        }
        return false;
    }

    public static bool CheckApplyStatusEffectType(StatusEffectData applyEffect)
    {
        if (!(applyEffect is StatusEffectInstantKill))
        {
            return applyEffect is StatusEffectInstantSacrifice;
        }
        return true;
    }

    public static void CheckShowIconsForHand(StatusEffectApplyX applyEffect, HashSet<Entity> toIndicate)
    {
        HashSetExt.AddRange<Entity>(toIndicate, References.Player.handContainer.Where((Entity card) => card != applyEffect.target && applyEffect.CheckConstraints(card)));
    }

    public static void CheckShowIconsForRightCardInHand(StatusEffectApplyX applyEffect, HashSet<Entity> toIndicate)
    {
        CardContainer handContainer = References.Player.handContainer;
        if (handContainer != null && handContainer.Count > 0 && applyEffect.CheckConstraints(References.Player.handContainer[0]))
        {
            toIndicate.Add(References.Player.handContainer[0]);
        }
    }

    public void HideTargets()
    {
        foreach (KeyValuePair<Transform, Entity> target in targets)
        {
            ((Component)target.Key).gameObject.SetActive(false);
            targetPool.Add(target.Key);
        }
        targets.Clear();
    }

    public void ShowIcon(Entity entity)
    {
        Transform key = PullIcon();
        targets.Add(key, entity);
    }

    public Transform PullIcon()
    {
        Transform val;
        if (targetPool.Count > 0)
        {
            val = targetPool[0];
            targetPool.RemoveAt(0);
        }
        else
        {
            val = Object.Instantiate<Transform>(targetPrefab, transform);
        }
        ((Component)val).gameObject.SetActive(true);
        return val;
    }
}
[RequireComponent(typeof(Bezier))]
public class TargetingArrow : TargetingDisplay
{
    [Serializable]
    public class ArrowHeadStyle
    {
        public string name;

        public GameObject gameObject;

        public Transform transform;

        public SpriteRenderer renderer;

        public bool directional;

        public Color headColor;

        public Gradient lineColor;
    }

    [SerializeField]
    public Transform head;

    [SerializeField]
    [Range(0f, 1f)]
    public float curviness = 0.5f;

    [SerializeField]
    [Range(0f, 1f)]
    public float arch;

    [SerializeField]
    public ArrowHeadStyle[] headStyles;

    [SerializeField]
    public string defaultStyleName = "Default";

    public Dictionary<string, ArrowHeadStyle> _headStyleLookup;

    public ArrowHeadStyle currentHeadStyle;

    public Bezier _bezier;

    public Dictionary<string, ArrowHeadStyle> headStyleLookup
    {
        get
        {
            if (_headStyleLookup == null)
            {
                _headStyleLookup = new Dictionary<string, ArrowHeadStyle>();
                ArrowHeadStyle[] array = headStyles;
                foreach (ArrowHeadStyle arrowHeadStyle in array)
                {
                    _headStyleLookup[arrowHeadStyle.name] = arrowHeadStyle;
                }
            }
            return _headStyleLookup;
        }
    }

    public Bezier bezier => _bezier ?? (_bezier = GetComponent<Bezier>());

    public override void UpdatePosition(Transform target)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        UpdatePosition(transform.position, target.position);
    }

    public override void UpdatePosition(Vector3 start, Vector3 end)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ba: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bf: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ce: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ec: Unknown result type (might be due to invalid IL or missing references)
        //IL_011a: Unknown result type (might be due to invalid IL or missing references)
        float num = Mathf.Lerp(start.y, end.y, curviness);
        Vector3 p = default(Vector3);
        ((p))..ctor(start.x, num, start.z - arch);
        bezier.UpdateCurve(start, p, end);
        if (!(head))
        {
            return;
        }
        head.position = bezier.GetPoint(bezier.pointCount - 1);
        ArrowHeadStyle arrowHeadStyle = currentHeadStyle;
        if (arrowHeadStyle == null || !arrowHeadStyle.directional)
        {
            return;
        }
        Transform transform = arrowHeadStyle.transform;
        if (transform != null && bezier.pointCount > 1)
        {
            Vector3 point = bezier.GetPoint(bezier.pointCount - 2);
            Vector3 val = transform.position - point;
            float num2 = Mathf.Atan(val.y / val.x) * 57.29578f;
            if (val.x < 0f)
            {
                num2 += 180f;
            }
            if (!float.IsNaN(num2))
            {
                transform.localEulerAngles = new Vector3(0f, 0f, num2);
            }
        }
    }

    public override void EntityHover(Entity entity)
    {
        SetStyle("Target");
    }

    public override void ContainerHover(CardContainer cardContainer, TargetingArrowSystem system)
    {
        if (cardContainer == system.target.owner.discardContainer && system.target.CanRecall())
        {
            system.snapToContainer = cardContainer;
            SetStyle("Discard");
        }
        else if (system.target.targetMode.TargetRow && system.target.CanPlayOn(cardContainer))
        {
            system.snapToContainer = cardContainer;
            SetStyle("TargetRow");
        }
    }

    public override void SlotHover(CardSlot slot, TargetingArrowSystem system)
    {
        if (system.target.data.playOnSlot && system.target.CanPlayOn(slot))
        {
            system.snapToContainer = slot;
            SetStyle("Target");
        }
    }

    public void SetStyle(string name)
    {
        //IL_00aa: Unknown result type (might be due to invalid IL or missing references)
        if ((currentHeadStyle?.gameObject))
        {
            currentHeadStyle.gameObject.SetActive(false);
        }
        currentHeadStyle = (headStyleLookup.ContainsKey(name) ? headStyleLookup[name] : headStyleLookup[defaultStyleName]);
        if ((currentHeadStyle?.gameObject))
        {
            currentHeadStyle.gameObject.SetActive(true);
        }
        if ((currentHeadStyle.renderer))
        {
            currentHeadStyle.renderer.color = currentHeadStyle.headColor;
        }
        bezier.lineRenderer.colorGradient = currentHeadStyle.lineColor;
    }

    public override void ResetStyle()
    {
        SetStyle(defaultStyleName);
    }
}
public class TargetingArrowHeadRow : MonoBehaviour
{
    [SerializeField]
    public TargetingArrowSystem targetArrowSystem;

    [SerializeField]
    public Transform[] targetTransforms;

    [SerializeField]
    public SpriteRenderer[] targets;

    [SerializeField]
    public Sprite canTarget;

    [SerializeField]
    public Sprite cannotTarget;

    public List<CardSlot> slots;

    public void OnEnable()
    {
        if (!(targetArrowSystem.snapToContainer is CardSlotLane cardSlotLane))
        {
            return;
        }
        slots = cardSlotLane.slots;
        if (targetArrowSystem.target.data.playOnSlot)
        {
            for (int i = 0; i < targets.Length && i < slots.Count; i++)
            {
                SpriteRenderer obj = targets[i];
                CardSlot container = slots[i];
                obj.sprite = (targetArrowSystem.target.CanPlayOn(container, ignoreRowCheck: true) ? canTarget : cannotTarget);
            }
        }
        else
        {
            for (int j = 0; j < targets.Length && j < slots.Count; j++)
            {
                SpriteRenderer obj2 = targets[j];
                CardSlot cardSlot = slots[j];
                obj2.sprite = ((!cardSlot.Empty && targetArrowSystem.target.CanPlayOn(cardSlot.GetTop(), ignoreRowCheck: true)) ? canTarget : cannotTarget);
            }
        }
    }

    public void LateUpdate()
    {
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        for (int i = 0; i < targetTransforms.Length && i < slots.Count; i++)
        {
            Transform obj = targetTransforms[i];
            CardSlot cardSlot = slots[i];
            obj.position = ((Transform)cardSlot.holder).position;
        }
    }
}
public class TargetingArrowSystem : GameSystem
{
    public TargetingDisplay offensiveArrow;

    public TargetingDisplay supportiveArrow;

    public TargetingDisplay targetMulti;

    public Entity target;

    public Entity hover;

    public CardContainer snapToContainer;

    public bool active;

    public Vector3 toPosition;

    [SerializeField]
    [Range(0f, 1f)]
    public float lerp = 0.4f;

    public TargetingDisplay currentArrow;

    public bool offensive;

    public Vector3 toPositionTarget
    {
        get
        {
            //IL_0018: Unknown result type (might be due to invalid IL or missing references)
            //IL_0046: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            if ((hover))
            {
                return hover.transform.position;
            }
            if ((snapToContainer))
            {
                return ((Component)snapToContainer).transform.position;
            }
            return ((Component)MonoBehaviourSingleton<Cursor3d>.instance).transform.position;
        }
    }

    public static bool CorrectType(Card.PlayType playType)
    {
        return playType == Card.PlayType.Play;
    }

    public void OnEnable()
    {
        Events.OnEntityDrag += EntityDrag;
        Events.OnEntityRelease += EntityRelease;
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
        Events.OnContainerHover += ContainerHover;
        Events.OnContainerUnHover += ContainerUnHover;
        Events.OnSlotHover += SlotHover;
        Events.OnSlotUnHover += SlotUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityDrag -= EntityDrag;
        Events.OnEntityRelease -= EntityRelease;
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
        Events.OnContainerHover -= ContainerHover;
        Events.OnContainerUnHover -= ContainerUnHover;
        Events.OnSlotHover -= SlotHover;
        Events.OnSlotUnHover -= SlotUnHover;
    }

    public void LateUpdate()
    {
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        if (!active && (target))
        {
            Show();
        }
        if (active && !(target))
        {
            Hide();
        }
        if (active)
        {
            UpdateArrow();
            toPosition = Delta.Lerp(toPosition, toPositionTarget, lerp, Time.deltaTime);
        }
    }

    public void UpdateArrow()
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        Vector3 position = target.transform.position;
        Vector3 end = toPosition;
        currentArrow.UpdatePosition(position, end);
    }

    public void Show()
    {
        //IL_0075: Unknown result type (might be due to invalid IL or missing references)
        //IL_007a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        active = true;
        currentArrow = ((!target.NeedsTarget) ? targetMulti : (offensive ? offensiveArrow : supportiveArrow));
        ((Component)currentArrow).gameObject.SetActive(true);
        currentArrow.ResetStyle();
        if (TouchInputModule.active)
        {
            toPosition = target.transform.position;
        }
        else
        {
            toPosition = toPositionTarget;
        }
        currentArrow.Show(this);
    }

    public void Hide()
    {
        active = false;
        ((Component)currentArrow).gameObject.SetActive(false);
        currentArrow.Hide();
    }

    public void EntityDrag(Entity entity)
    {
        if (entity.inPlay && (entity) && (entity.data) && CorrectType(entity.data.playType))
        {
            target = entity;
            offensive = target.IsOffensive();
        }
    }

    public void EntityRelease(Entity entity)
    {
        if (target == entity)
        {
            target = null;
        }
    }

    public void EntityHover(Entity entity)
    {
        if (active && (target) && !target.targetMode.TargetRow && !target.data.playOnSlot)
        {
            hover = entity;
            currentArrow.EntityHover(entity);
        }
    }

    public void EntityUnHover(Entity entity)
    {
        if (hover == entity)
        {
            hover = null;
            if (active && (currentArrow))
            {
                currentArrow.ResetStyle();
            }
        }
    }

    public void ContainerHover(CardContainer container)
    {
        if (active && target != null)
        {
            currentArrow.ContainerHover(container, this);
        }
    }

    public void ContainerUnHover(CardContainer container)
    {
        if (snapToContainer == container)
        {
            snapToContainer = null;
            if (active && (currentArrow))
            {
                currentArrow.ResetStyle();
            }
        }
    }

    public void SlotHover(CardSlot slot)
    {
        if (active && (target))
        {
            currentArrow.SlotHover(slot, this);
        }
    }

    public void SlotUnHover(CardSlot slot)
    {
        if (snapToContainer == slot)
        {
            snapToContainer = null;
            if (active && (currentArrow))
            {
                currentArrow.ResetStyle();
            }
        }
    }
}
public abstract class TargetingDisplay : MonoBehaviour
{
    public virtual void UpdatePosition(Transform target)
    {
    }

    public virtual void UpdatePosition(Vector3 start, Vector3 end)
    {
    }

    public virtual void Show(TargetingArrowSystem system)
    {
    }

    public virtual void Hide()
    {
    }

    public virtual void ResetStyle()
    {
    }

    public virtual void EntityHover(Entity entity)
    {
    }

    public virtual void ContainerHover(CardContainer cardContainer, TargetingArrowSystem system)
    {
    }

    public virtual void SlotHover(CardSlot slot, TargetingArrowSystem system)
    {
    }

    public TargetingDisplay()
    {
    }
}
public class TargetingMultiple : TargetingDisplay
{
    [SerializeField]
    public GameObject targetPrefab;

    public readonly List<GameObject> targets = new List<GameObject>();

    public Entity target;

    public Entity[] entitiesToHit;

    public bool showingTargets;

    public override void Show(TargetingArrowSystem system)
    {
        target = system.target;
        entitiesToHit = target.targetMode.GetTargets(target, null, null);
        Events.OnContainerHover += ContainerHover;
        Events.OnContainerUnHover += ContainerUnHover;
    }

    public override void Hide()
    {
        HideTargets();
        Events.OnContainerHover -= ContainerHover;
        Events.OnContainerUnHover -= ContainerUnHover;
    }

    public void ContainerHover(CardContainer cardContainer)
    {
        if ((cardContainer) && target.containers.Length != 0 && cardContainer == target.containers[0])
        {
            HideTargets();
        }
    }

    public void ContainerUnHover(CardContainer cardContainer)
    {
        if (!showingTargets && (target) && target.containers.Length != 0 && cardContainer == target.containers[0])
        {
            ShowTargets();
        }
    }

    public void ShowTargets()
    {
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        if (showingTargets)
        {
            return;
        }
        if (entitiesToHit != null)
        {
            Entity[] array = entitiesToHit;
            foreach (Entity entity in array)
            {
                GameObject item = Object.Instantiate<GameObject>(targetPrefab, entity.transform.position, Quaternion.identity, transform);
                targets.Add(item);
            }
        }
        showingTargets = true;
    }

    public void HideTargets()
    {
        if (!showingTargets)
        {
            return;
        }
        foreach (GameObject target in targets)
        {
            GameObjectExt.Destroy(target);
        }
        targets.Clear();
        showingTargets = false;
    }
}
public class UnitTarget : MonoBehaviour
{
    [SerializeField]
    public GameObject aimlessOverlay;

    [SerializeField]
    public GameObject frenzyUnderlay;

    public void SetAimless(bool aimless)
    {
        aimlessOverlay.SetActive(aimless);
    }

    public void SetFrenzy(bool frenzy)
    {
        frenzyUnderlay.SetActive(frenzy);
    }
}
public class UnitTargetSystem : GameSystem
{
    [SerializeField]
    public UnitTarget targetPrefab;

    public Entity dragging;

    public Entity hover;

    public readonly List<GameObject> targets = new List<GameObject>();

    public void OnEnable()
    {
        Events.OnEntityDrag += EntityDrag;
        Events.OnEntityRelease += EntityRelease;
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
    }

    public void OnDisable()
    {
        Events.OnEntityDrag -= EntityDrag;
        Events.OnEntityRelease -= EntityRelease;
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
    }

    public void Start()
    {
        Events.OnSettingChanged += SettingChanged;
        if (Settings.Load("UnitTargets", 1) != 1)
        {
            enabled = false;
        }
    }

    public void OnDestroy()
    {
        Events.OnSettingChanged -= SettingChanged;
    }

    public void EntityDrag(Entity entity)
    {
        dragging = entity;
        if ((hover))
        {
            HideTargets();
        }
    }

    public void EntityRelease(Entity entity)
    {
        if (dragging == entity)
        {
            dragging = null;
        }
    }

    public void EntityHover(Entity entity)
    {
        if (!(dragging))
        {
            if ((hover))
            {
                EntityUnHover(hover);
            }
            hover = entity;
            if (entity.inPlay && entity.counter.max > 0 && entity.HasAttackIcon() && Battle.IsOnBoard(hover))
            {
                ShowTargets(hover);
            }
        }
    }

    public void EntityUnHover(Entity entity)
    {
        if (hover == entity)
        {
            hover = null;
            HideTargets();
        }
    }

    public void SettingChanged(string key, object value)
    {
        if (key == "UnitTargets" && value is int num)
        {
            if (num == 0 && enabled)
            {
                enabled = false;
            }
            else if (num == 1 && !enabled)
            {
                enabled = true;
            }
        }
    }

    public void ShowTargets(Entity entity)
    {
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        Entity[] potentialTargets = entity.targetMode.GetPotentialTargets(entity, null, null);
        if (potentialTargets != null)
        {
            bool random = entity.targetMode.Random;
            StatusEffectData statusEffectData = entity.FindStatus("frenzy");
            bool frenzy = statusEffectData != null && statusEffectData.count > 0;
            Entity[] array = potentialTargets;
            foreach (Entity entity2 in array)
            {
                UnitTarget unitTarget = Object.Instantiate<UnitTarget>(targetPrefab, entity2.transform.position, Quaternion.identity, transform);
                unitTarget.SetAimless(random);
                unitTarget.SetFrenzy(frenzy);
                targets.Add(((Component)unitTarget).gameObject);
            }
        }
    }

    public void HideTargets()
    {
        foreach (GameObject target in targets)
        {
            GameObjectExt.Destroy(target);
        }
        targets.Clear();
    }
}
public class TimeScaleSystem : GameSystem
{
    public void OnEnable()
    {
        Events.OnTimeScaleChange += TimeScaleSet;
    }

    public void OnDisable()
    {
        Events.OnTimeScaleChange -= TimeScaleSet;
    }

    public void TimeScaleSet(float value)
    {
        Time.timeScale = value;
    }
}
public class DynamicReactionTutorialSystem : GameSystem
{
    public void OnEnable()
    {
        Events.OnCampaignGenerated += CampaignGenerated;
        if (SaveSystem.LoadProgressData("dynamicReactionTutorial", defaultValue: false) || (Campaign.Data.GameMode).name != "GameModeNormal")
        {
            enabled = false;
        }
    }

    public void OnDisable()
    {
        Events.OnCampaignGenerated -= CampaignGenerated;
    }

    public static Task CampaignGenerated()
    {
        CampaignNode campaignNode = References.Campaign.nodes.FirstOrDefault((CampaignNode a) => a.type.isBattle);
        if (campaignNode != null && campaignNode.data.TryGetValue("waves", out var value) && value is SaveCollection<BattleWaveManager.WaveData> { Count: > 0 } saveCollection)
        {
            BattleWaveManager.WaveData waveData = saveCollection[0];
            if (waveData != null)
            {
                string[] array = new string[1] { "Smackgoon" };
                string[] array2 = new string[5] { "Chungoon", "Grouchy", "Snoolf", "Snowbo", "NakedGnome" };
                bool flag = false;
                for (int i = 0; i < waveData.Count; i++)
                {
                    string cardName = waveData.GetCardName(i);
                    if (IArrayExt.Contains<string>(array, cardName))
                    {
                        flag = true;
                        break;
                    }
                }
                if (!flag)
                {
                    for (int j = 0; j < waveData.Count; j++)
                    {
                        string cardName2 = waveData.GetCardName(j);
                        if (IArrayExt.Contains<string>(array2, cardName2) && waveData is BattleWaveManager.WaveDataBasic waveDataBasic)
                        {
                            BattleWaveManager.Card card = waveDataBasic.Get(j);
                            card.cardName = IArrayExt.RandomItem<string>(array);
                            card.upgradeNames = null;
                            break;
                        }
                    }
                }
            }
        }
        return Task.CompletedTask;
    }
}
public class DynamicTutorialSystem : GameSystem
{
    [Serializable]
    public class Tutorial
    {
        public bool onlyShowOnce;

        public int turnsRequired;

        public int resetOffset = -50;

        public string saveString;

        public LocalizedString stringRef;

        public Prompt.Anchor promptAnchor;

        public Vector2 promptPosition;

        public float promptWidth;

        public Prompt.Emote.Type promptEmote;

        public int flipEmote = 1;

        public int current { get; set; }

        public bool currentBool { get; set; }

        public bool shown { get; set; }

        public bool actionDoneThisTurn { get; set; }

        public void ResetCount()
        {
            current = resetOffset;
            if (shown)
            {
                Hide();
            }
        }

        public void Load()
        {
            if (!onlyShowOnce)
            {
                current = SaveSystem.LoadProgressData(saveString, 0);
            }
        }

        public void Save()
        {
            if (!onlyShowOnce)
            {
                SaveSystem.SaveProgressData(saveString, current);
            }
        }

        public void CheckIncreaseCount()
        {
            if (!onlyShowOnce)
            {
                if (!actionDoneThisTurn)
                {
                    current++;
                }
                actionDoneThisTurn = false;
            }
        }

        public bool Check()
        {
            return current >= turnsRequired;
        }

        public void Show(params object[] args)
        {
            //IL_0022: Unknown result type (might be due to invalid IL or missing references)
            shown = true;
            PromptSystem.Create(promptAnchor, promptPosition, promptWidth, promptEmote);
            PromptSystem.Prompt.SetEmotePosition(Prompt.Emote.Position.Above, 0f, 0f, flipEmote);
            if (args.Length != 0)
            {
                PromptSystem.SetTextAction(() => string.Format(stringRef.GetLocalizedString(), args));
            }
            else
            {
                PromptSystem.SetTextAction(() => stringRef.GetLocalizedString());
            }
            current = 0;
        }

        public void Hide()
        {
            shown = false;
            PromptSystem.Hide();
        }
    }

    [SerializeField]
    public Tutorial redrawTutorial;

    [SerializeField]
    public Tutorial moveTutorial;

    [SerializeField]
    public Tutorial recallTutorial;

    [SerializeField]
    public Tutorial aimlessTutorial;

    [SerializeField]
    public Tutorial reactionTutorial;

    public Tutorial[] tutorials;

    public bool aimlessTutorialDone;

    public bool reactionTutorialDone;

    public Entity aimlessEnemy;

    public Entity reactionEnemy;

    public void OnEnable()
    {
        //IL_00d4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00de: Expected O, but got Unknown
        tutorials = new Tutorial[5] { redrawTutorial, moveTutorial, recallTutorial, aimlessTutorial, reactionTutorial };
        Tutorial[] array = tutorials;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].Load();
        }
        aimlessTutorialDone = SaveSystem.LoadProgressData("dynamicAimlessTutorial", defaultValue: false);
        reactionTutorialDone = SaveSystem.LoadProgressData("dynamicReactionTutorial", defaultValue: false);
        Events.OnEntityPlace += EntityPlace;
        Events.OnDiscard += Discard;
        Events.OnRedrawBellHit += RedrawBellHit;
        Events.OnBattleTurnStart += TurnStart;
        Events.OnBattleTurnEnd += TurnEnd;
        Events.OnCampaignSaved += new UnityAction(Save);
    }

    public void OnDisable()
    {
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Expected O, but got Unknown
        Events.OnEntityPlace -= EntityPlace;
        Events.OnDiscard -= Discard;
        Events.OnRedrawBellHit -= RedrawBellHit;
        Events.OnBattleTurnStart -= TurnStart;
        Events.OnBattleTurnEnd -= TurnEnd;
        Events.OnCampaignSaved -= new UnityAction(Save);
    }

    public void EntityPlace(Entity entity, CardContainer[] slots, bool freeMove)
    {
        if (freeMove && entity.owner.team == References.Player.team)
        {
            moveTutorial.actionDoneThisTurn = true;
            moveTutorial.ResetCount();
        }
    }

    public void Discard(Entity entity)
    {
        if (entity.data.hasHealth)
        {
            recallTutorial.actionDoneThisTurn = true;
            recallTutorial.ResetCount();
        }
    }

    public void RedrawBellHit(RedrawBellSystem redrawBellSystem)
    {
        if (!redrawBellSystem.IsCharged)
        {
            redrawTutorial.actionDoneThisTurn = true;
            redrawTutorial.ResetCount();
        }
    }

    public void TurnStart(int turnCount)
    {
        Tutorial[] array = tutorials;
        foreach (Tutorial tutorial in array)
        {
            if (tutorial.shown)
            {
                tutorial.Hide();
                break;
            }
        }
    }

    public void TurnEnd(int turnCount)
    {
        Tutorial[] array = tutorials;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].CheckIncreaseCount();
        }
        if (!References.Battle.ended && !CheckAimlessTutorial(turnCount) && !CheckReactionTutorial(turnCount) && !CheckMoveTutorial() && !CheckRedrawTutorial())
        {
            CheckRecallTutorial();
        }
    }

    public bool CheckAimlessTutorial(int turnCount)
    {
        if (aimlessTutorialDone)
        {
            return false;
        }
        if (turnCount == 0)
        {
            List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(References.Battle.enemy);
            aimlessEnemy = cardsOnBoard.FirstOrDefault((Entity a) => a.data.traits.Any((CardData.TraitStacks t) => (t.data).name == "Aimless"));
            return false;
        }
        if ((aimlessEnemy) && aimlessEnemy.IsAliveAndExists() && aimlessEnemy.counter.current == 1)
        {
            aimlessTutorial.Show(aimlessEnemy.data.title);
            SaveSystem.SaveProgressData("dynamicAimlessTutorial", value: true);
            aimlessTutorialDone = true;
            return true;
        }
        return false;
    }

    public bool CheckReactionTutorial(int turnCount)
    {
        if (reactionTutorialDone)
        {
            return false;
        }
        if (turnCount == 0)
        {
            List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(References.Battle.enemy);
            reactionEnemy = cardsOnBoard.FirstOrDefault((Entity a) => a.statusEffects.Any((StatusEffectData s) => s.isReaction));
            if ((reactionEnemy))
            {
                reactionTutorial.Show(reactionEnemy.data.title);
                SaveSystem.SaveProgressData("dynamicReactionTutorial", value: true);
                reactionTutorialDone = true;
                return true;
            }
        }
        return false;
    }

    public bool CheckRecallTutorial()
    {
        if (recallTutorial.Check())
        {
            foreach (Entity item in Battle.GetCardsOnBoard(References.Battle.player))
            {
                if (item.data.hasHealth && (float)item.hp.current <= (float)item.hp.max * 0.5f && item.CanRecall())
                {
                    recallTutorial.Show();
                    PromptSystem.Prompt.SetEmotePosition(Prompt.Emote.Position.Above, 2f);
                    return true;
                }
            }
        }
        return false;
    }

    public bool CheckRedrawTutorial()
    {
        if (redrawTutorial.Check() && References.Battle.turnCount == 0 && Battle.GetCardsOnBoard(References.Battle.player).Count == 1)
        {
            foreach (Entity item in References.Battle.player.handContainer)
            {
                if (item.data.counter > 0)
                {
                    return false;
                }
            }
            int num = References.Battle.player.handContainer.max - References.Battle.player.handContainer.Count;
            int count = References.Battle.player.drawContainer.Count;
            for (int i = 0; i < num; i++)
            {
                int num2 = count - 1 - i;
                if (num2 >= 0 && References.Battle.player.drawContainer[num2].data.counter > 0)
                {
                    return false;
                }
            }
            redrawTutorial.Show();
            PromptSystem.Prompt.SetEmotePosition(Prompt.Emote.Position.Above, 1.5f, 0f, 1f);
            return true;
        }
        return false;
    }

    public bool CheckMoveTutorial()
    {
        if (moveTutorial.Check())
        {
            bool flag = false;
            foreach (Entity item in Battle.GetCardsOnBoard(References.Battle.player))
            {
                if (item.statusEffects.All((StatusEffectData a) => (a).name != "Unmovable"))
                {
                    flag = true;
                    break;
                }
            }
            if (flag)
            {
                moveTutorial.Show();
                return true;
            }
        }
        return false;
    }

    public void Save()
    {
        Tutorial[] array = tutorials;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].Save();
        }
    }
}
public class DynamicWaveBellTutorialSystem : GameSystem
{
    public LocalizedString helpKey;

    public Prompt.Emote.Type emote = Prompt.Emote.Type.Explain;

    public LocalizedString buttonKey;

    public Sprite helpSprite;

    public void OnEnable()
    {
        Events.OnWaveDeployerPostCountDown += WaveDeployerCountDown;
        if (SaveSystem.LoadProgressData("dynamicWaveBellTutorial", defaultValue: false))
        {
            enabled = false;
        }
    }

    public void OnDisable()
    {
        Events.OnWaveDeployerPostCountDown -= WaveDeployerCountDown;
    }

    public void WaveDeployerCountDown(int counter)
    {
        if (counter > 0 && Battle.GetCardsOnBoard(References.Battle.enemy).Count == 0)
        {
            ShowHelp();
        }
    }

    public void ShowHelp()
    {
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Expected O, but got Unknown
        HelpPanelSystem.Show(helpKey);
        HelpPanelSystem.SetEmote(emote);
        HelpPanelSystem.SetImage(2f, 2f, helpSprite);
        HelpPanelSystem.SetBackButtonActive(active: false);
        HelpPanelSystem.AddButton(HelpPanelSystem.ButtonType.Positive, buttonKey, "Select", new UnityAction(End));
    }

    public void End()
    {
        SaveSystem.SaveProgressData("dynamicWaveBellTutorial", value: true);
        enabled = false;
    }
}
public abstract class TutorialBattleSystem : TutorialParentSystem
{
    public override void OnEnable()
    {
        base.OnEnable();
        Events.OnSceneChanged += SceneChanged;
        Events.OnBattlePhaseStart += BattlePhaseStart;
    }

    public override void OnDisable()
    {
        base.OnDisable();
        Events.OnSceneChanged -= SceneChanged;
        Events.OnBattlePhaseStart -= BattlePhaseStart;
        BattleEnd();
    }

    public void SceneChanged(Scene scene)
    {
        Object.Destroy(this);
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        if (phase == Battle.Phase.Init)
        {
            BattleStart();
        }
    }

    public virtual void BattleStart()
    {
    }

    public virtual void BattleEnd()
    {
    }

    public TutorialBattleSystem()
    {
    }
}
public class TutorialBattleSystem1 : TutorialBattleSystem
{
    public class PhasePlaceLeader : Phase
    {
        public override void OnEnable()
        {
            Events.OnEntityMove += EntityMove;
            new Routine(PromptAfter(2f));
        }

        public override void OnDisable()
        {
            Events.OnEntityMove -= EntityMove;
            PromptSystem.Hide();
        }

        public void EntityMove(Entity entity)
        {
            if (entity.owner == References.Player && entity.data.cardType.miniboss && Battle.IsOnBoard(entity))
            {
                base.enabled = false;
            }
        }

        public IEnumerator PromptAfter(float delay)
        {
            yield return (object)new WaitForSeconds(delay);
            if (base.enabled)
            {
                PromptSystem.Create(Prompt.Anchor.Top, 0f, -2f, 8.7f);
                PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_1.GetLocalizedString());
            }
        }
    }

    public class PhasePlaceCompanion : Phase
    {
        public readonly CardData target;

        public override float delay => 1f;

        public PhasePlaceCompanion(CardData target)
        {
            this.target = target;
        }

        public override void OnEnable()
        {
            Events.OnCheckAction += CheckAction;
            Events.OnBattleTurnStart += BattleTurnStart;
            PromptSystem.Create(Prompt.Anchor.TopLeft, 2f, -2f, 8f, Prompt.Emote.Type.Talk);
            PromptSystem.SetTextAction(() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_2.GetLocalizedString(), target.title));
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnBattleTurnStart -= BattleTurnStart;
            PromptSystem.Hide();
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (allow && !CorrectAction(action) && !Phase.FreeMoveAction(action) && !Phase.InspectAction(action))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public void BattleTurnStart(int turn)
        {
            base.enabled = false;
        }

        public bool CorrectAction(PlayAction action)
        {
            if (action is ActionMove actionMove && (actionMove.entity.data).name == (target).name && actionMove.toContainers.Length == 1)
            {
                return Battle.IsOnBoard(actionMove.toContainers[0].Group);
            }
            return false;
        }
    }

    public class PhaseUseItem : Phase
    {
        public override float delay => 1f;

        public override void OnEnable()
        {
            Events.OnCheckAction += CheckAction;
            Events.OnBattleTurnStart += BattleTurnStart;
            PromptSystem.Create(Prompt.Anchor.TopLeft, 1f, -2f, 6f, Prompt.Emote.Type.Point);
            PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_3.GetLocalizedString());
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnBattleTurnStart -= BattleTurnStart;
            PromptSystem.Hide();
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (allow && !CorrectAction(action) && !Phase.FreeMoveAction(action) && !Phase.InspectAction(action))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public void BattleTurnStart(int turn)
        {
            base.enabled = false;
        }

        public bool CorrectAction(PlayAction action)
        {
            if (action is ActionTriggerAgainst actionTriggerAgainst && (actionTriggerAgainst.entity.data).name == "Sword")
            {
                return (actionTriggerAgainst.target.data).name == "Pengoon";
            }
            return false;
        }
    }

    public class PhaseCounters : Phase
    {
        public override float delay => 1f;

        public override void OnEnable()
        {
            Events.OnBattleTurnStart += BattleTurnStart;
            PromptSystem.Create(Prompt.Anchor.Top, 0f, -1.5f, 9f, Prompt.Emote.Type.Explain);
            PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_4.GetLocalizedString());
        }

        public override void OnDisable()
        {
            Events.OnBattleTurnStart -= BattleTurnStart;
            PromptSystem.Hide();
        }

        public void BattleTurnStart(int turn)
        {
            base.enabled = false;
        }
    }

    public class PhaseEnemiesAttackFirst : Phase
    {
        public override float delay => 0f;

        public override void OnEnable()
        {
            Events.OnBattlePhaseStart += BattlePhaseStart;
            Events.OnBattleTurnStart += BattleTurnStart;
        }

        public override void OnDisable()
        {
            Events.OnBattlePhaseStart -= BattlePhaseStart;
            Events.OnBattleTurnStart -= BattleTurnStart;
            PromptSystem.Hide();
        }

        public static void BattlePhaseStart(Battle.Phase phase)
        {
            if (phase == Battle.Phase.Play)
            {
                PromptSystem.Create(Prompt.Anchor.TopRight, -3f, -3f, 4f, Prompt.Emote.Type.Scared);
                PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_41.GetLocalizedString());
            }
        }

        public void BattleTurnStart(int turn)
        {
            base.enabled = false;
        }
    }

    public class PhaseWaitForNewEnemies : Phase
    {
        public override void OnEnable()
        {
            Events.OnActionPerform += ActionPerform;
        }

        public override void OnDisable()
        {
            Events.OnActionPerform -= ActionPerform;
        }

        public void ActionPerform(PlayAction action)
        {
            if (action is ActionMove actionMove && actionMove.entity.owner == References.Battle.enemy)
            {
                base.enabled = false;
            }
        }
    }

    public class PhaseRedrawBell : Phase
    {
        public override float delay => 1f;

        public override void OnEnable()
        {
            Events.OnCheckAction += CheckAction;
            Events.OnActionPerform += ActionPerform;
            PromptSystem.Create(Prompt.Anchor.TopRight, -1f, -1.25f, 6f, Prompt.Emote.Type.Talk);
            PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_5.GetLocalizedString());
            RedrawBellSystem redrawBellSystem = Object.FindObjectOfType<RedrawBellSystem>();
            if ((redrawBellSystem))
            {
                redrawBellSystem.Enable();
                redrawBellSystem.BecomeInteractable();
            }
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnActionPerform -= ActionPerform;
            PromptSystem.Hide();
        }

        public static void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (allow && !CorrectAction(action) && !PlayCardAction(action) && !Phase.FreeMoveAction(action) && !Phase.InspectAction(action))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public void ActionPerform(PlayAction action)
        {
            if (CorrectAction(action))
            {
                base.enabled = false;
            }
        }

        public static bool CorrectAction(PlayAction action)
        {
            return action is ActionRedraw;
        }

        public static bool PlayCardAction(PlayAction action)
        {
            return action is ActionTrigger;
        }
    }

    public class PhaseRedrawBellPopUp : Phase
    {
        public TutorialSystem tutorialSystem;

        public override float delay => 1f;

        public override void OnEnable()
        {
            tutorialSystem = Object.FindObjectOfType<TutorialSystem>();
            Events.OnBattleTurnEnd += Show;
        }

        public override void OnDisable()
        {
            Events.OnBattleTurnEnd -= Show;
        }

        public void Show(int turn)
        {
            //IL_0058: Unknown result type (might be due to invalid IL or missing references)
            //IL_0062: Expected O, but got Unknown
            HelpPanelSystem.Show(tutorialSystem.redrawBellHelpKey);
            HelpPanelSystem.SetEmote(tutorialSystem.redrawBellHelpEmote);
            HelpPanelSystem.SetImage(1.5f, 1.5f, tutorialSystem.redrawBellHelpSprite);
            HelpPanelSystem.SetBackButtonActive(active: false);
            HelpPanelSystem.AddButton(HelpPanelSystem.ButtonType.Positive, tutorialSystem.redrawBellHelpButtonKey, "Select", new UnityAction(End));
        }

        public void End()
        {
            base.enabled = false;
        }
    }

    public class PhaseProtectLeader : Phase
    {
        public override float delay => 1f;

        public override void OnEnable()
        {
            Show();
        }

        public override void OnDisable()
        {
            PromptSystem.Hide();
        }

        public void Show()
        {
            PromptSystem.Create(Prompt.Anchor.Left, 1f, 1f, 4f);
            PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_6.GetLocalizedString());
            Events.OnBattleTurnStart += End;
        }

        public void End(int turn)
        {
            base.enabled = false;
            Events.OnBattleTurnStart -= End;
        }
    }

    public class PhaseWaveDeploy : Phase
    {
        public override float delay => 1f;

        public override void OnEnable()
        {
            Events.OnBattleTurnStart += BattleTurnStart;
            Object.FindObjectOfType<WaveDeploySystem>()?.Show();
            PromptSystem.Create(Prompt.Anchor.TopRight, -3f, -1.75f, 6f, Prompt.Emote.Type.Talk);
            PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_7.GetLocalizedString());
            PromptSystem.Prompt.SetEmotePosition(Prompt.Emote.Position.Above, 2f, 0f, 1f);
        }

        public override void OnDisable()
        {
            Events.OnBattleTurnStart -= BattleTurnStart;
            PromptSystem.Hide();
        }

        public void BattleTurnStart(int turn)
        {
            base.enabled = false;
        }
    }

    public class PhaseWaitForMiniboss : Phase
    {
        public override void OnEnable()
        {
            Events.OnActionPerform += ActionPerform;
        }

        public override void OnDisable()
        {
            Events.OnActionPerform -= ActionPerform;
        }

        public void ActionPerform(PlayAction action)
        {
            if (action is ActionMove actionMove && actionMove.entity.owner == References.Battle.enemy && actionMove.entity.data.cardType.miniboss)
            {
                base.enabled = false;
            }
        }
    }

    public class PhaseMiniboss : Phase
    {
        public override float delay => 1f;

        public override void OnEnable()
        {
            Events.OnEntityKilled += EntityKilled;
            new Routine(PromptAfterDelay(2f));
        }

        public override void OnDisable()
        {
            Events.OnEntityKilled -= EntityKilled;
            PromptSystem.Hide();
        }

        public void EntityKilled(Entity entity, DeathType deathType)
        {
            if (entity.owner == References.Battle.enemy && entity.data.cardType.miniboss)
            {
                base.enabled = false;
            }
        }

        public IEnumerator PromptAfterDelay(float delay)
        {
            yield return (object)new WaitForSeconds(delay);
            if (base.enabled)
            {
                PromptSystem.Create(Prompt.Anchor.TopLeft, 2f, -1.5f, 5f, Prompt.Emote.Type.Talk);
                PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle1_8.GetLocalizedString());
            }
        }
    }

    public static readonly string[] startingHand = new string[6] { "Sword", "SnowStick", "Sword", "Foxee", "Sword", "Sword" };

    public override void BattleStart()
    {
        Object.FindObjectOfType<BattleSaveSystem>()?.Disable();
        CardContainer cardContainer = References.Battle.rows[References.Battle.enemy][0];
        cardContainer.canBePlacedOn = false;
        ((Component)((Component)cardContainer).transform.parent).gameObject.SetActive(false);
        Object.FindObjectOfType<RedrawBellSystem>()?.Disable();
        WaveDeploySystem waveDeploySystem = Object.FindObjectOfType<WaveDeploySystem>();
        if (waveDeploySystem != null)
        {
            waveDeploySystem.Hide();
            waveDeploySystem.visible = false;
        }
        References.Player.OrderNextCards(startingHand);
        Entity entity = FindLastUnit();
        phases = new List<Phase>
        {
            new PhasePlaceLeader(),
            new PhasePlaceCompanion(entity.data),
            new PhaseUseItem(),
            new PhaseCounters(),
            new PhaseEnemiesAttackFirst(),
            new PhaseWaitForNewEnemies(),
            new PhaseRedrawBell(),
            new PhaseRedrawBellPopUp(),
            new PhaseProtectLeader(),
            new PhaseWaveDeploy(),
            new PhaseWaitForMiniboss(),
            new PhaseMiniboss()
        };
    }

    public static Entity FindLastUnit()
    {
        CardData chosenUnitData = References.PlayerData.inventory.deck.LastOrDefault((CardData a) => a.cardType.unit);
        return Battle.GetCards(References.Player).LastOrDefault((Entity a) => a.data.id == chosenUnitData.id);
    }

    public override void BattleEnd()
    {
        Object.FindObjectOfType<RedrawBellSystem>()?.Enable();
    }
}
public class TutorialBattleSystem2 : TutorialBattleSystem
{
    public class PhaseWaitForLeader : Phase
    {
        public override void OnEnable()
        {
            Events.OnEntityMove += EntityMove;
        }

        public override void OnDisable()
        {
            Events.OnEntityMove -= EntityMove;
        }

        public void EntityMove(Entity entity)
        {
            if (entity.owner == References.Player && entity.data.cardType.miniboss && Battle.IsOnBoard(entity))
            {
                base.enabled = false;
            }
        }
    }

    public class PhaseInspectEnemy : Phase
    {
        public Entity target;

        public override float delay => 0.2f;

        public override void OnEnable()
        {
            Events.OnCheckAction += CheckAction;
            Events.OnInspect += Inspect;
            Events.OnInspectEnd += InspectEnd;
            target = References.Battle.GetRow(References.Battle.enemy, 0).GetTop();
            PromptSystem.Create(Prompt.Anchor.TopLeft, 1.5f, -2f, 5f, Prompt.Emote.Type.Point);
            PromptSystem.SetTextAction(() => string.Format(MonoBehaviourSingleton<Cursor3d>.instance.usingMouse ? ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_1) : ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_1Gamepad), target.data.title));
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnInspect -= Inspect;
            Events.OnInspectEnd -= InspectEnd;
            PromptSystem.Hide();
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (allow && !CorrectAction(action) && !Phase.FreeMoveAction(action))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public void Inspect(Entity entity)
        {
            PromptSystem.Hide();
        }

        public void InspectEnd(Entity entity)
        {
            base.enabled = false;
        }

        public bool CorrectAction(PlayAction action)
        {
            if (action is ActionInspect actionInspect)
            {
                return actionInspect.entity == target;
            }
            return false;
        }
    }

    public class PhasePlaceCompanion : Phase
    {
        public readonly Entity target;

        public PhasePlaceCompanion(Entity target)
        {
            this.target = target;
        }

        public override void OnEnable()
        {
            Events.OnCheckAction += CheckAction;
            Events.OnBattleTurnStart += BattleTurnStart;
            new Routine(PromptAfter(1f));
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnBattleTurnStart -= BattleTurnStart;
            PromptSystem.Hide();
        }

        public IEnumerator PromptAfter(float delay)
        {
            yield return (object)new WaitForSeconds(delay);
            if (base.enabled)
            {
                PromptSystem.Create(Prompt.Anchor.TopLeft, 1.5f, -2f, 5f);
                PromptSystem.SetTextAction(() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_2.GetLocalizedString(), target.data.title));
            }
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (allow && !CorrectAction(action) && !Phase.FreeMoveAction(action) && !Phase.InspectAction(action))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public void BattleTurnStart(int turn)
        {
            base.enabled = false;
        }

        public bool CorrectAction(PlayAction action)
        {
            if (action is ActionMove actionMove && (actionMove.entity.data).name == (target.data).name && actionMove.toContainers.Length == 1 && Battle.IsOnBoard(actionMove.toContainers[0].Group))
            {
                return actionMove.toContainers[0].Group.Count == 0;
            }
            return false;
        }
    }

    public class PhaseWait : Phase
    {
        public int turns;

        public PhaseWait(int turns)
        {
            this.turns = turns;
        }

        public override void OnEnable()
        {
            Events.OnBattleTurnEnd += End;
        }

        public override void OnDisable()
        {
            Events.OnBattleTurnEnd -= End;
        }

        public void End(int turn)
        {
            if (--turns <= 0)
            {
                base.enabled = false;
            }
        }
    }

    public class PhaseWaitDisallowRecall : Phase
    {
        public int turns;

        public PhaseWaitDisallowRecall(int turns)
        {
            this.turns = turns;
        }

        public override void OnEnable()
        {
            Events.OnBattleTurnEnd += End;
            Events.OnCheckAction += CheckAction;
        }

        public override void OnDisable()
        {
            Events.OnBattleTurnEnd -= End;
            Events.OnCheckAction -= CheckAction;
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (IsRecallAction(action) || IsEarlyDeployAction(action))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public bool IsRecallAction(PlayAction action)
        {
            if (action is ActionMove actionMove && actionMove.toContainers.Length == 1)
            {
                return actionMove.toContainers[0] == References.Player.discardContainer;
            }
            return false;
        }

        public bool IsEarlyDeployAction(PlayAction action)
        {
            return action is ActionEarlyDeploy;
        }

        public void End(int turn)
        {
            if (--turns <= 0)
            {
                base.enabled = false;
            }
        }
    }

    public class PhaseMoveCompanionInFrontOfLeader : Phase
    {
        public Entity leader;

        public Entity target;

        public CardSlot leaderSlot;

        public CardSlot targetSlot;

        public PhaseMoveCompanionInFrontOfLeader(Entity target)
        {
            this.target = target;
        }

        public override void OnEnable()
        {
            Events.OnCheckAction += CheckAction;
            Events.OnActionPerform += ActionPerform;
            foreach (Entity item in Battle.GetCardsOnBoard(References.Player))
            {
                if (item.data.cardType.miniboss)
                {
                    leader = item;
                    break;
                }
            }
            CardSlotLane cardSlotLane = leader.containers[0] as CardSlotLane;
            int num = cardSlotLane.IndexOf(leader);
            leaderSlot = cardSlotLane.slots[num];
            int index = Mathf.Max(0, num - 1);
            targetSlot = cardSlotLane.slots[index];
            Debug.Log($"Leader is in [{leaderSlot}]");
            Debug.Log($"[{target.data.title}] SHOULD move to [{targetSlot}]");
            if (targetSlot.GetTop() == target)
            {
                base.enabled = false;
                Debug.Log($"[{target.data.title}] is already in [{targetSlot}]");
                Object.FindObjectOfType<TutorialBattleSystem2>()?.InsertPhase(new PhaseWait(1));
                return;
            }
            PromptSystem.Create(Prompt.Anchor.Right, -2f, 1f, 5f, Prompt.Emote.Type.Talk);
            PromptSystem.SetTextAction(() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_3.GetLocalizedString(), target.data.title));
            Object.FindObjectOfType<TutorialBattleSystem2>()?.InsertPhase(new PhaseFreeMove());
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnActionPerform -= ActionPerform;
            PromptSystem.Hide();
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (allow && !CorrectAction(action) && !Phase.InspectAction(action))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public void ActionPerform(PlayAction action)
        {
            if (CorrectAction(action))
            {
                base.enabled = false;
            }
        }

        public bool CorrectAction(PlayAction action)
        {
            if (action is ActionMove actionMove && (actionMove.entity.data).name == (target.data).name && actionMove.toContainers.Length == 1 && actionMove.toContainers[0] is CardSlot cardSlot)
            {
                return cardSlot == targetSlot;
            }
            return false;
        }
    }

    public class PhaseBarrage : Phase
    {
        public Entity unitToMove;

        public readonly Entity chosenUnit;

        public Entity barrageEnemy;

        public PlayAction correctAction;

        public PhaseBarrage(Entity chosenUnit)
        {
            this.chosenUnit = chosenUnit;
        }

        public override void OnEnable()
        {
            barrageEnemy = Battle.GetCardsOnBoard(References.Battle.enemy).FirstOrDefault((Entity a) => a.data.traits.Any((CardData.TraitStacks t) => (t.data).name == "Barrage"));
            if (!(barrageEnemy))
            {
                base.enabled = false;
            }
            else
            {
                int rowIndex = References.Battle.GetRowIndex(barrageEnemy.containers[0]);
                int rowIndex2 = References.Battle.GetRowIndex(chosenUnit.containers[0]);
                if (rowIndex != rowIndex2)
                {
                    PromptSystem.Create(Prompt.Anchor.Left, 0.1f, 1f, 5f, Prompt.Emote.Type.Point);
                    PromptSystem.SetTextAction(() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_41a.GetLocalizedString(), barrageEnemy.data.title, chosenUnit.data.title));
                    unitToMove = chosenUnit;
                }
                else
                {
                    PromptSystem.Create(Prompt.Anchor.Left, 0.1f, 1f, 5f, Prompt.Emote.Type.Point);
                    PromptSystem.SetTextAction(() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_41b.GetLocalizedString(), barrageEnemy.data.title, chosenUnit.data.title));
                    foreach (Entity item in Battle.GetCardsOnBoard(References.Player))
                    {
                        if (item.data.cardType.miniboss)
                        {
                            unitToMove = item;
                            break;
                        }
                    }
                }
            }
            Events.OnCheckAction += CheckAction;
            Events.OnActionPerform += ActionPerform;
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnActionPerform -= ActionPerform;
            PromptSystem.Hide();
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (CorrectAction(action))
            {
                correctAction = action;
                return;
            }
            allow = false;
            PromptSystem.Shake();
        }

        public void ActionPerform(PlayAction action)
        {
            if (correctAction != null && action == correctAction)
            {
                base.enabled = false;
            }
        }

        public bool CorrectAction(PlayAction action)
        {
            if (action is ActionMove actionMove && actionMove.entity == unitToMove && actionMove.toContainers.Length == 1)
            {
                CardContainer cardContainer = actionMove.toContainers[0];
                if (cardContainer != null && Battle.IsOnBoard(cardContainer.Group))
                {
                    return unitToMove.containers[0] != cardContainer.Group;
                }
            }
            return false;
        }
    }

    public class PhaseFreeMove : Phase
    {
        public override void OnEnable()
        {
            Events.OnCheckAction += CheckAction;
            Events.OnBattleTurnStart += HidePrompt;
            Events.OnBattleTurnEnd += End;
            PromptSystem.Create(Prompt.Anchor.Right, -2f, -1f, 5f, Prompt.Emote.Type.Point);
            PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_4.GetLocalizedString());
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnBattleTurnStart -= HidePrompt;
            Events.OnBattleTurnEnd -= End;
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (allow && IllegalAction(action))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public void HidePrompt(int value)
        {
            PromptSystem.Hide();
        }

        public void End(int value)
        {
            base.enabled = false;
        }

        public bool IllegalAction(PlayAction action)
        {
            if (Phase.FreeMoveAction(action))
            {
                return true;
            }
            if (action is ActionEarlyDeploy)
            {
                return true;
            }
            if (action is ActionMove actionMove && actionMove.toContainers.Length == 1 && actionMove.toContainers[0] == actionMove.entity.owner.discardContainer)
            {
                return true;
            }
            return false;
        }
    }

    public class PhaseRecallToHeal : Phase
    {
        public Entity target;

        public WaveDeploySystemOverflow disabledWaveDeploySystem;

        public PhaseRecallToHeal(Entity target)
        {
            this.target = target;
        }

        public override void OnEnable()
        {
            Events.OnCheckAction += CheckAction;
            Events.OnActionPerform += ActionPerform;
            PromptSystem.Create(Prompt.Anchor.Right, 0f, 1f, 5f);
            PromptSystem.SetTextAction(() => string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_5.GetLocalizedString(), target.data.title));
            disabledWaveDeploySystem = Object.FindObjectOfType<WaveDeploySystemOverflow>();
            if ((disabledWaveDeploySystem))
            {
                ((Behaviour)disabledWaveDeploySystem.navigationItem).enabled = false;
            }
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnActionPerform -= ActionPerform;
            PromptSystem.Hide();
            if ((disabledWaveDeploySystem))
            {
                ((Behaviour)disabledWaveDeploySystem.navigationItem).enabled = true;
            }
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (allow && !CorrectAction(action) && !Phase.FreeMoveAction(action) && !Phase.InspectAction(action) && !DiscardHealAction(action))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public void ActionPerform(PlayAction action)
        {
            if (CorrectAction(action))
            {
                base.enabled = false;
            }
        }

        public bool CorrectAction(PlayAction action)
        {
            if (action is ActionMove actionMove && (actionMove.entity.data).name == (target.data).name && actionMove.toContainers.Length == 1)
            {
                return actionMove.toContainers[0] == References.Player.discardContainer;
            }
            return false;
        }

        public static bool DiscardHealAction(PlayAction action)
        {
            return action is ActionDiscardEffect;
        }
    }

    public class PhaseRecallFree : Phase
    {
        public override void OnEnable()
        {
            Events.OnCheckAction += CheckAction;
            Events.OnBattleTurnStart += End;
            Events.OnBattleTurnEnd += End;
            MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_6.GetLocalizedString();
            PromptSystem.Create(Prompt.Anchor.Right, -2f, -1f, 5f, Prompt.Emote.Type.Happy);
            PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle2_6.GetLocalizedString());
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnBattleTurnStart -= End;
            Events.OnBattleTurnEnd -= End;
            PromptSystem.Hide();
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (action is ActionEarlyDeploy)
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public void End(int value)
        {
            base.enabled = false;
        }
    }

    public Entity chosenUnit;

    public override void BattleStart()
    {
        Object.FindObjectOfType<BattleSaveSystem>()?.Disable();
        chosenUnit = FindChosenUnit();
        string[] nextCardNames = new string[6]
        {
            "Sword",
            "PinkberryJuice",
            (chosenUnit.data).name,
            "Sword",
            "Sword",
            "Sword"
        };
        References.Player.OrderNextCards(nextCardNames);
        phases = new List<Phase>
        {
            new PhaseWaitForLeader(),
            new PhaseInspectEnemy(),
            new PhasePlaceCompanion(chosenUnit),
            new PhaseWaitDisallowRecall(2),
            new PhaseMoveCompanionInFrontOfLeader(chosenUnit),
            new PhaseBarrage(chosenUnit),
            new PhaseWaitDisallowRecall(1),
            new PhaseRecallToHeal(chosenUnit),
            new PhaseRecallFree()
        };
    }

    public void InsertPhase(Phase phase)
    {
        phases.Insert(0, phase);
    }

    public static Entity FindChosenUnit()
    {
        CardData chosenUnitData = References.PlayerData.inventory.deck.LastOrDefault((CardData a) => a.cardType.unit);
        return Battle.GetCards(References.Player).LastOrDefault((Entity a) => a.data.id == chosenUnitData.id);
    }
}
public class TutorialBattleSystem3 : TutorialBattleSystem
{
    public class PhaseWaitForLeader : Phase
    {
        public override void OnEnable()
        {
            Events.OnEntityMove += EntityMove;
        }

        public override void OnDisable()
        {
            Events.OnEntityMove -= EntityMove;
        }

        public void EntityMove(Entity entity)
        {
            if (entity.owner == References.Player && entity.data.cardType.miniboss && Battle.IsOnBoard(entity))
            {
                base.enabled = false;
            }
        }
    }

    public class PhasePlaceCompanion : Phase
    {
        public readonly Entity target;

        public PhasePlaceCompanion(Entity target)
        {
            this.target = target;
        }

        public override void OnEnable()
        {
            Events.OnCheckAction += CheckAction;
            Events.OnBattleTurnStart += BattleTurnStart;
            new Routine(PromptAfter(0.5f));
        }

        public override void OnDisable()
        {
            Events.OnCheckAction -= CheckAction;
            Events.OnBattleTurnStart -= BattleTurnStart;
            PromptSystem.Hide();
        }

        public IEnumerator PromptAfter(float delay)
        {
            yield return (object)new WaitForSeconds(delay);
            if (base.enabled)
            {
                PromptSystem.Create(Prompt.Anchor.Left, 0.1f, 2f, 5f);
                PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialBattle3_1.GetLocalizedString());
            }
        }

        public void CheckAction(ref PlayAction action, ref bool allow)
        {
            if (allow && !CorrectAction(action) && !Phase.FreeMoveAction(action) && !Phase.InspectAction(action))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }

        public void BattleTurnStart(int turn)
        {
            base.enabled = false;
        }

        public bool CorrectAction(PlayAction action)
        {
            if (action is ActionMove actionMove && (actionMove.entity.data).name == (target.data).name && actionMove.toContainers.Length == 1)
            {
                return Battle.IsOnBoard(actionMove.toContainers[0].Group);
            }
            return false;
        }
    }

    public Entity chosenUnit;

    public override void BattleStart()
    {
        Object.FindObjectOfType<BattleSaveSystem>()?.Disable();
        chosenUnit = FindChosenUnit();
        string[] nextCardNames = new string[6]
        {
            "SnowStick",
            "Sword",
            (chosenUnit.data).name,
            "SnowStick",
            "PinkberryJuice",
            "Sword"
        };
        References.Player.OrderNextCards(nextCardNames);
        phases = new List<Phase>
        {
            new PhaseWaitForLeader(),
            new PhasePlaceCompanion(chosenUnit)
        };
    }

    public static Entity FindChosenUnit()
    {
        CardData chosenUnitData = References.PlayerData.inventory.deck.OrderByDescending((CardData a) => a.hp).FirstOrDefault((CardData a) => !a.cardType.miniboss);
        return Battle.GetCards(References.Player).LastOrDefault((Entity a) => a.data.id == chosenUnitData.id);
    }
}
public class TutorialCharmSystem : TutorialParentSystem
{
    public class PhaseEquipCharm : Phase
    {
        public override void OnEnable()
        {
            Events.OnUpgradeAssign += UpgradeAssign;
            Routine.Create(PromptAfterDelay(1f));
        }

        public override void OnDisable()
        {
            PromptSystem.Hide();
            Events.OnUpgradeAssign -= UpgradeAssign;
        }

        public void UpgradeAssign(Entity entity, CardUpgradeData upgradeData)
        {
            if (upgradeData.type == CardUpgradeData.Type.Charm)
            {
                base.enabled = false;
            }
        }

        public IEnumerator PromptAfterDelay(float delay)
        {
            yield return (object)new WaitForSeconds(delay);
            if (base.enabled)
            {
                PromptSystem.SetSortingLayer("UI", 5);
                PromptSystem.Create(Prompt.Anchor.Left, 2f, 0.5f, 4f, Prompt.Emote.Type.Explain);
                PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialCharm1.GetLocalizedString());
                PromptSystem.Prompt.SetEmotePosition(Prompt.Emote.Position.Above, 1f, 0f, -1f);
                promptSystemNeedsReset = true;
            }
        }
    }

    public class PhaseCharmEquipped : Phase
    {
        public override void OnEnable()
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_0011: Expected O, but got Unknown
            Events.OnDeckpackClose += new UnityAction(DeckpackClose);
            Routine.Create(PromptAfterDelay(2f));
            Done();
        }

        public override void OnDisable()
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Expected O, but got Unknown
            PromptSystem.Hide();
            Events.OnDeckpackClose -= new UnityAction(DeckpackClose);
        }

        public void DeckpackClose()
        {
            base.enabled = false;
        }

        public IEnumerator PromptAfterDelay(float delay)
        {
            yield return (object)new WaitForSeconds(delay);
            if (base.enabled)
            {
                PromptSystem.SetSortingLayer("UI", 5);
                PromptSystem.Create(Prompt.Anchor.Left, 1f, 1f, 5f, Prompt.Emote.Type.Scared);
                PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialCharm2.GetLocalizedString());
                promptSystemNeedsReset = true;
            }
        }
    }

    public static bool promptSystemNeedsReset;

    public override void OnEnable()
    {
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Expected O, but got Unknown
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Expected O, but got Unknown
        if (SaveSystem.LoadProgressData("tutorialCharmDone", defaultValue: false))
        {
            Object.Destroy(this);
            return;
        }
        base.OnEnable();
        Events.OnDeckpackOpen += new UnityAction(DeckpackOpen);
        Events.OnDeckpackClose += new UnityAction(DeckpackClose);
    }

    public override void OnDisable()
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Expected O, but got Unknown
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Expected O, but got Unknown
        base.OnDisable();
        Events.OnDeckpackOpen -= new UnityAction(DeckpackOpen);
        Events.OnDeckpackClose -= new UnityAction(DeckpackClose);
        CheckPromptSystemReset();
    }

    public void DeckpackOpen()
    {
        if (References.PlayerData.inventory.upgrades.Count((CardUpgradeData a) => a.type == CardUpgradeData.Type.Charm) > 0)
        {
            phases = new List<Phase>
            {
                new PhaseEquipCharm(),
                new PhaseCharmEquipped()
            };
        }
    }

    public void DeckpackClose()
    {
        phases = null;
        if (currentPhase != null)
        {
            currentPhase.enabled = false;
        }
        currentPhase = null;
        delay = 0f;
        CheckPromptSystemReset();
        if (SaveSystem.LoadProgressData("tutorialCharmDone", defaultValue: false))
        {
            Object.Destroy(this);
        }
    }

    public static void CheckPromptSystemReset()
    {
        if (promptSystemNeedsReset)
        {
            PromptSystem.SetSortingLayer("Prompt", 0);
            promptSystemNeedsReset = false;
        }
    }

    public static void Done()
    {
        SaveSystem.SaveProgressData("tutorialCharmDone", value: true);
    }
}
public class TutorialCompanionSystem : GameSystem
{
    public EventRoutineCompanion companionEvent;

    public bool init;

    public bool waitForBreak = true;

    public bool waitForInspect;

    public bool inspectDone;

    public float promptDelay;

    public bool prompt2Show;

    public void OnEnable()
    {
        Events.OnCheckAction += CheckAction;
        Events.OnEventStart += EventStart;
        Events.OnInspect += Inspected;
        Events.OnActionPerform += ActionPerformed;
        Events.OnSceneChanged += SceneChanged;
    }

    public void OnDisable()
    {
        Events.OnCheckAction -= CheckAction;
        Events.OnEventStart -= EventStart;
        Events.OnInspect -= Inspected;
        Events.OnActionPerform -= ActionPerformed;
        Events.OnSceneChanged -= SceneChanged;
        PromptSystem.Hide();
    }

    public void Init(EventRoutineCompanion companionEvent)
    {
        init = true;
        this.companionEvent = companionEvent;
        waitForBreak = true;
        waitForInspect = false;
        inspectDone = false;
    }

    public void Update()
    {
        if (init && waitForBreak && companionEvent != null && companionEvent.broken)
        {
            waitForBreak = false;
            waitForInspect = true;
            promptDelay = 1f;
        }
        if (!(promptDelay > 0f))
        {
            return;
        }
        promptDelay -= Time.deltaTime;
        if (!(promptDelay <= 0f))
        {
            return;
        }
        PromptSystem.Create(Prompt.Anchor.TopLeft, 1f, -3f, 5f, Prompt.Emote.Type.Explain);
        PromptSystem.SetTextAction(delegate
        {
            if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
            {
                return ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialCompanion1Gamepad);
            }
            return (!TouchInputModule.active) ? ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialCompanion1) : ControllerButtonSystem.ProcessActionTags(MonoBehaviourSingleton<StringReference>.instance.tutorialCompanion1Touch);
        });
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
        if (!inspectDone)
        {
            if (!(action is ActionInspect))
            {
                allow = false;
                PromptSystem.Shake();
            }
        }
        else
        {
            if (!(action is ActionSelect actionSelect) || !(actionSelect.entity == null))
            {
                return;
            }
            allow = false;
            if (prompt2Show)
            {
                PromptSystem.Shake();
                return;
            }
            PromptSystem.Create(Prompt.Anchor.Left, 1f, 1f, 5f);
            PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialCompanion2.GetLocalizedString());
            prompt2Show = true;
        }
    }

    public void EventStart(CampaignNode node, EventRoutine @event)
    {
        if (@event is EventRoutineCompanion eventRoutineCompanion)
        {
            Init(eventRoutineCompanion);
        }
    }

    public void Inspected(Entity entity)
    {
        if (waitForInspect && !inspectDone)
        {
            inspectDone = true;
            PromptSystem.Hide();
        }
    }

    public void ActionPerformed(PlayAction action)
    {
        if (action is ActionSelect)
        {
            PromptSystem.Hide();
            prompt2Show = false;
        }
    }

    public void SceneChanged(Scene scene)
    {
        Object.Destroy(this);
    }
}
public class TutorialCrownSystem : TutorialParentSystem
{
    public static bool promptSystemNeedsReset;

    public bool deckpackOpen;

    public bool promptShown;

    public override void OnEnable()
    {
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Expected O, but got Unknown
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Expected O, but got Unknown
        if (SaveSystem.LoadProgressData("tutorialCrownDone", defaultValue: false))
        {
            Object.Destroy(this);
            return;
        }
        base.OnEnable();
        Events.OnDeckpackOpen += new UnityAction(DeckpackOpen);
        Events.OnDeckpackClose += new UnityAction(DeckpackClose);
        Events.OnUpgradeAssign += UpgradeAssign;
    }

    public override void OnDisable()
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Expected O, but got Unknown
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Expected O, but got Unknown
        base.OnDisable();
        Events.OnDeckpackOpen -= new UnityAction(DeckpackOpen);
        Events.OnDeckpackClose -= new UnityAction(DeckpackClose);
        Events.OnUpgradeAssign -= UpgradeAssign;
        HidePrompt();
    }

    public void DeckpackOpen()
    {
        deckpackOpen = true;
    }

    public void DeckpackClose()
    {
        deckpackOpen = false;
        HidePrompt();
    }

    public void UpgradeAssign(Entity entity, CardUpgradeData upgradeData)
    {
        if (deckpackOpen && upgradeData.type == CardUpgradeData.Type.Crown)
        {
            ShowPrompt();
            SaveSystem.SaveProgressData("tutorialCrownDone", value: true);
        }
    }

    public void ShowPrompt()
    {
        if (!promptShown)
        {
            PromptSystem.Hide();
            PromptSystem.SetSortingLayer("UI", 5);
            PromptSystem.Create(Prompt.Anchor.Left, 2f, 0.5f, 4f, Prompt.Emote.Type.Point);
            PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialCrown.GetLocalizedString());
            promptSystemNeedsReset = true;
            promptShown = true;
        }
    }

    public void HidePrompt()
    {
        if (promptShown)
        {
            PromptSystem.Hide();
            CheckPromptSystemReset();
        }
    }

    public static void CheckPromptSystemReset()
    {
        if (promptSystemNeedsReset)
        {
            PromptSystem.SetSortingLayer("Prompt", 0);
            promptSystemNeedsReset = false;
        }
    }
}
public class TutorialInjurySystem : TutorialParentSystem
{
    public bool promptShown;

    public override void OnEnable()
    {
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Expected O, but got Unknown
        if (SaveSystem.LoadProgressData("tutorialInjuryDone", defaultValue: false))
        {
            Object.Destroy(this);
            return;
        }
        base.OnEnable();
        Events.OnBattleEnd += new UnityAction(BattleEnd);
        Events.OnSceneChanged += SceneChanged;
    }

    public override void OnDisable()
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Expected O, but got Unknown
        base.OnDisable();
        Events.OnBattleEnd -= new UnityAction(BattleEnd);
        Events.OnSceneChanged -= SceneChanged;
    }

    public void SceneChanged(Scene scene)
    {
        if (promptShown)
        {
            PromptSystem.Hide();
            promptShown = false;
        }
        if (SaveSystem.LoadProgressData("tutorialInjuryDone", defaultValue: false))
        {
            Object.Destroy(this);
        }
    }

    public void BattleEnd()
    {
        if (References.Battle.winner == References.Battle.player)
        {
            CardData[] injuriesThisBattle = InjurySystem.GetInjuriesThisBattle();
            if (injuriesThisBattle.Length != 0)
            {
                StartCoroutine(Routine(injuriesThisBattle));
            }
        }
    }

    public IEnumerator Routine(CardData[] injuries)
    {
        yield return WaitForInjuriesPanel();
        PromptSystem.Create(Prompt.Anchor.Left, 0.5f, 0f, 5f, Prompt.Emote.Type.Sad);
        PromptSystem.SetTextAction(() => (injuries.Length != 1) ? MonoBehaviourSingleton<StringReference>.instance.tutorialInjuryMultiple.GetLocalizedString() : string.Format(MonoBehaviourSingleton<StringReference>.instance.tutorialInjury.GetLocalizedString(), injuries[0].title));
        promptShown = true;
        SaveSystem.SaveProgressData("tutorialInjuryDone", value: true);
    }

    public static IEnumerator WaitForInjuriesPanel()
    {
        yield return (object)new WaitUntil((Func<bool>)(() => SceneManager.IsLoaded("BattleWin")));
    }
}
public class TutorialItemSystem1 : GameSystem
{
    public string[] items;

    public void OnEnable()
    {
        Events.OnEventStart += EventStart;
    }

    public void OnDisable()
    {
        Events.OnEventStart -= EventStart;
    }

    public void SetItems(string[] items)
    {
        this.items = items;
    }

    public void EventStart(CampaignNode node, EventRoutine @event)
    {
        if (@event is ItemEventRoutine)
        {
            node.data["cards"] = new SaveCollection<string>(items);
        }
        Object.Destroy(this);
    }
}
public class TutorialItemSystem2 : GameSystem
{
    public bool init;

    public ItemEventRoutine itemEvent;

    public bool waitForOpen;

    public float promptDelay;

    public void OnEnable()
    {
        Events.OnEventStart += EventStart;
        Events.OnActionPerform += ActionPerformed;
        Events.OnSceneChanged += SceneChanged;
    }

    public void OnDisable()
    {
        Events.OnEventStart -= EventStart;
        Events.OnActionPerform -= ActionPerformed;
        Events.OnSceneChanged -= SceneChanged;
        PromptSystem.Hide();
    }

    public void Init(ItemEventRoutine itemEvent)
    {
        init = true;
        this.itemEvent = itemEvent;
        waitForOpen = true;
    }

    public void Update()
    {
        if (init && waitForOpen && (itemEvent) && itemEvent.IsOpen)
        {
            waitForOpen = false;
            promptDelay = 1.5f;
        }
        if (!(promptDelay > 0f))
        {
            return;
        }
        promptDelay -= Time.deltaTime;
        if (promptDelay <= 0f)
        {
            PromptSystem.Create(Prompt.Anchor.Left, 0.5f, 0.5f, 4f, Prompt.Emote.Type.Explain);
            PromptSystem.SetTextAction(() => MonoBehaviourSingleton<StringReference>.instance.tutorialItem.GetLocalizedString());
        }
    }

    public void EventStart(CampaignNode node, EventRoutine @event)
    {
        if (@event is ItemEventRoutine itemEventRoutine)
        {
            Init(itemEventRoutine);
        }
    }

    public static void ActionPerformed(PlayAction action)
    {
        if (action is ActionSelect)
        {
            PromptSystem.Hide();
        }
    }

    public void SceneChanged(Scene scene)
    {
        Object.Destroy(this);
    }
}
public class TutorialParentSystem : GameSystem
{
    public abstract class Phase
    {
        public bool _enabled;

        public bool enabled
        {
            get
            {
                return _enabled;
            }
            set
            {
                bool flag = _enabled;
                _enabled = value;
                if (_enabled)
                {
                    if (!flag)
                    {
                        OnEnable();
                    }
                }
                else if (flag)
                {
                    OnDisable();
                }
            }
        }

        public virtual float delay => 0f;

        public virtual void OnEnable()
        {
        }

        public virtual void OnDisable()
        {
        }

        public static bool FreeMoveAction(PlayAction action)
        {
            if (action is ActionMove actionMove && Battle.IsOnBoard(actionMove.entity))
            {
                return Battle.IsOnBoard(actionMove.toContainers);
            }
            return false;
        }

        public static bool InspectAction(PlayAction action)
        {
            return action is ActionInspect;
        }

        public Phase()
        {
        }
    }

    public float delay;

    public const float delayBetween = 0f;

    public Phase currentPhase;

    public List<Phase> phases;

    public virtual void OnEnable()
    {
    }

    public virtual void OnDisable()
    {
        if (currentPhase != null)
        {
            currentPhase.enabled = false;
            currentPhase = null;
        }
    }

    public virtual void Update()
    {
        if (delay > 0f)
        {
            delay -= Time.deltaTime;
        }
        else
        {
            if (phases == null || phases.Count <= 0)
            {
                return;
            }
            if (currentPhase == null)
            {
                currentPhase = phases[0];
                phases.RemoveAt(0);
                currentPhase.enabled = true;
            }
            else if (!currentPhase.enabled)
            {
                currentPhase = null;
                delay = 0f;
                if (phases.Count > 0)
                {
                    delay += phases[0].delay;
                }
            }
        }
    }
}
public class TutorialSystem : GameSystem
{
    [Serializable]
    public struct Data
    {
        public int battleNumber;

        public int eventNumber;
    }

    public LocalizedString redrawBellHelpKey;

    public Prompt.Emote.Type redrawBellHelpEmote = Prompt.Emote.Type.Explain;

    public LocalizedString redrawBellHelpButtonKey;

    public Sprite redrawBellHelpSprite;

    public Data data;

    public void OnEnable()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        Events.OnSceneChanged += SceneChanged;
        Events.OnCampaignSaved += new UnityAction(CampaignSaved);
        Events.OnCampaignLoaded += new UnityAction(CampaignLoaded);
    }

    public void OnDisable()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Expected O, but got Unknown
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Expected O, but got Unknown
        Events.OnSceneChanged -= SceneChanged;
        Events.OnCampaignSaved -= new UnityAction(CampaignSaved);
        Events.OnCampaignLoaded -= new UnityAction(CampaignLoaded);
    }

    public void SceneChanged(Scene scene)
    {
        string name = ((scene)).name;
        if (!(name == "Battle"))
        {
            if (name == "Event")
            {
                switch (data.eventNumber)
                {
                    case 0:
                        gameObject.AddComponent<TutorialCompanionSystem>();
                        break;
                    case 2:
                        gameObject.AddComponent<TutorialItemSystem2>();
                        break;
                }
                data.eventNumber++;
            }
            return;
        }
        switch (data.battleNumber)
        {
            case 0:
                gameObject.AddComponent<TutorialBattleSystem1>();
                SaveSystem.SaveProgressData("tutorialProgress", 1);
                Events.InvokeTutorialProgress(1);
                break;
            case 1:
                gameObject.AddComponent<TutorialBattleSystem2>();
                break;
            case 2:
                {
                    gameObject.AddComponent<TutorialBattleSystem3>();
                    DynamicTutorialSystem dynamicTutorialSystem = Object.FindObjectOfType<DynamicTutorialSystem>();
                    if (dynamicTutorialSystem != null)
                    {
                        ((Behaviour)dynamicTutorialSystem).enabled = true;
                    }
                    SaveSystem.SaveProgressData("tutorialProgress", 2);
                    Events.InvokeTutorialProgress(2);
                    break;
                }
        }
        data.battleNumber++;
    }

    public void CampaignSaved()
    {
        SaveSystem.SaveCampaignData(Campaign.Data.GameMode, "tutorialData", data);
    }

    public void CampaignLoaded()
    {
        data = SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "tutorialData", default(Data));
    }
}
public class WarningTutorialSystem : GameSystem
{
    [SerializeField]
    public LocalizedString promptStringRef;

    public bool promptShown;

    public void OnEnable()
    {
        Events.OnCheckAction += CheckAction;
        Events.OnActionPerform += ActionPerform;
    }

    public void OnDisable()
    {
        Events.OnCheckAction -= CheckAction;
        Events.OnActionPerform -= ActionPerform;
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
        if (promptShown || !(action is ActionTriggerAgainst actionTriggerAgainst) || !(actionTriggerAgainst.triggeredBy == References.Player.entity))
        {
            return;
        }
        GetDamageDetails(actionTriggerAgainst.entity, out var damage, out var instantKill);
        if (!(damage > 0 || instantKill))
        {
            return;
        }
        Entity entity = null;
        if ((actionTriggerAgainst.targetContainer))
        {
            entity = actionTriggerAgainst.targetContainer.FirstOrDefault((Entity a) => a.data.cardType.miniboss && a.owner == References.Player);
        }
        else if (actionTriggerAgainst.target.data.cardType.miniboss && actionTriggerAgainst.target.owner == References.Player)
        {
            entity = actionTriggerAgainst.target;
        }
        if (!(entity))
        {
            return;
        }
        if (instantKill)
        {
            allow = false;
            ShowPrompt(actionTriggerAgainst.entity);
        }
        else if (!(entity.FindStatus("block")))
        {
            int num = entity.hp.current;
            StatusEffectData statusEffectData = entity.FindStatus("shell");
            if ((statusEffectData))
            {
                num += statusEffectData.count;
            }
            if (num <= damage)
            {
                allow = false;
                ShowPrompt(actionTriggerAgainst.entity);
            }
        }
    }

    public static void GetDamageDetails(Entity entity, out int damage, out bool instantKill)
    {
        instantKill = false;
        damage = entity.damage.current + ((entity.tempDamage)).Value;
        foreach (CardData.StatusEffectStacks attackEffect in entity.attackEffects)
        {
            if (attackEffect.data is StatusEffectInstantSacrifice)
            {
                instantKill = true;
            }
        }
    }

    public void ActionPerform(PlayAction action)
    {
        if (promptShown)
        {
            HidePrompt();
        }
    }

    public void ShowPrompt(Entity attackingCard)
    {
        PromptSystem.Hide();
        PromptSystem.Create(Prompt.Anchor.Left, 0f, 1f, 3f, Prompt.Emote.Type.Scared);
        PromptSystem.SetTextAction(() => promptStringRef.GetLocalizedString(new object[1] { attackingCard.data.title }));
        PromptSystem.Shake();
        promptShown = true;
    }

    public void HidePrompt()
    {
        PromptSystem.Hide();
        promptShown = false;
    }
}
public class UnplayableCrownCardSystem : GameSystem
{
    [SerializeField]
    public LocalizedString promptKey;

    public bool active;

    public bool blocked;

    public bool promptShown;

    public int handCount;

    public const float timerMax = 0.5f;

    public float timer;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleStart += new UnityAction(BattleStart);
        Events.OnSceneChanged += SceneChanged;
        Events.OnBattleTurnEnd += BattleTurnEnd;
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleStart -= new UnityAction(BattleStart);
        Events.OnSceneChanged -= SceneChanged;
        Events.OnBattleTurnEnd -= BattleTurnEnd;
    }

    public void BattleStart()
    {
        if (!active)
        {
            Activate();
        }
    }

    public void SceneChanged(Scene scene)
    {
        if (active)
        {
            Deactivate();
        }
    }

    public void BattleTurnEnd(int turnCount)
    {
        if (active)
        {
            Deactivate();
        }
    }

    public void Activate()
    {
        active = true;
        handCount = References.Player.handContainer.Count;
        timer = 0.5f;
    }

    public void Update()
    {
        if (active && timer > 0f)
        {
            timer -= Time.deltaTime;
            if (timer <= 0f)
            {
                timer = 0.5f;
                Check();
            }
        }
    }

    public void Check()
    {
        int count = References.Player.handContainer.Count;
        if (count == handCount)
        {
            return;
        }
        handCount = count;
        if (handCount == 0)
        {
            Deactivate();
        }
        else
        {
            if (handCount <= 0)
            {
                return;
            }
            bool flag = blocked;
            blocked = CheckBlocked();
            if (blocked && !flag)
            {
                ShowPrompt();
                RedrawBellSystem redrawBellSystem = Object.FindObjectOfType<RedrawBellSystem>();
                if (redrawBellSystem != null)
                {
                    redrawBellSystem.Enable();
                    redrawBellSystem.BecomeInteractable();
                }
            }
            else if (flag && !blocked)
            {
                Deactivate();
            }
        }
    }

    public void Deactivate()
    {
        active = false;
        blocked = false;
        if (promptShown)
        {
            PromptSystem.Hide();
            promptShown = false;
        }
    }

    public static bool CheckBlocked()
    {
        int num = 0;
        CardContainer[] containers = Object.FindObjectsOfType<CardContainer>().ToArray();
        foreach (Entity item in References.Player.handContainer)
        {
            if (CardIsBlocked(item, containers))
            {
                num++;
            }
        }
        return num == References.Player.handContainer.Count;
    }

    public static bool CardIsBlocked(Entity card, CardContainer[] containers)
    {
        foreach (StatusEffectData statusEffect in card.statusEffects)
        {
            if (statusEffect is StatusEffectRecycle statusEffectRecycle)
            {
                if (!statusEffectRecycle.IsEnoughJunkInHand())
                {
                    return true;
                }
                break;
            }
        }
        if (!card.NeedsTarget)
        {
            return false;
        }
        foreach (CardContainer container in containers)
        {
            if (card.CanPlayOn(container))
            {
                return false;
            }
        }
        foreach (Entity card2 in References.Battle.cards)
        {
            if (((Behaviour)card2).enabled && card.CanPlayOn(card2))
            {
                return false;
            }
        }
        return true;
    }

    public void ShowPrompt()
    {
        PromptSystem.Create(Prompt.Anchor.Left, 1.5f, 2f, 5f, Prompt.Emote.Type.Scared);
        PromptSystem.SetTextAction(() => promptKey.GetLocalizedString());
        promptShown = true;
    }
}
public class VfxDeathSystem : GameSystem
{
    [SerializeField]
    public GameObject sacrificeFX;

    public void OnEnable()
    {
        Events.OnEntityKilled += EntityKilled;
    }

    public void OnDisable()
    {
        Events.OnEntityKilled -= EntityKilled;
    }

    public void EntityKilled(Entity entity, DeathType deathType)
    {
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        if (DeathSystem.KilledByOwnTeam(entity) && (sacrificeFX))
        {
            Transform transform = entity.transform;
            CreateEffect(sacrificeFX, transform.position, transform.lossyScale);
        }
    }

    public void CreateEffect(GameObject prefab, Vector3 position, Vector3 scale)
    {
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        if ((prefab))
        {
            Object.Instantiate<GameObject>(prefab, position, Quaternion.identity, transform).transform.localScale = scale;
        }
    }
}
public class VfxHitSystem : GameSystem
{
    [Serializable]
    public class Profile
    {
        public GameObject effectPrefab;
    }

    [Serializable]
    public class WithStatusProfile
    {
        public string statusType;

        public GameObject effectPrefab;

        public EventReference sfxEvent;
    }

    [SerializeField]
    public AnimationCurve profileCurve;

    [SerializeField]
    public Profile[] profiles;

    [SerializeField]
    public WithStatusProfile[] withStatusProfiles;

    public Profile GetProfile(int power)
    {
        return profiles[Mathf.Clamp(Mathf.RoundToInt(profileCurve.Evaluate((float)power)), 0, profiles.Length - 1)];
    }

    public static int GetHitPower(Hit hit)
    {
        return hit.damage + hit.damageBlocked + hit.extraOffensiveness;
    }

    public void OnEnable()
    {
        Events.OnEntityHit += EntityHit;
    }

    public void OnDisable()
    {
        Events.OnEntityHit -= EntityHit;
    }

    public void EntityHit(Hit hit)
    {
        if (hit.Offensive && hit.doAnimation && hit.countsAsHit && hit.BasicHit && GetHitPower(hit) > 0 && (hit.target))
        {
            TakeHit(hit);
        }
    }

    public void TakeHit(Hit hit)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_009b: Unknown result type (might be due to invalid IL or missing references)
        //IL_00da: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e6: Unknown result type (might be due to invalid IL or missing references)
        //IL_0100: Unknown result type (might be due to invalid IL or missing references)
        //IL_0105: Unknown result type (might be due to invalid IL or missing references)
        Vector3 position = hit.target.transform.position;
        Vector3 val = position;
        if ((hit.attacker))
        {
            Vector3 val2 = val - hit.attacker.transform.position;
            Vector3 normalized = ((val2)).normalized;
            val += normalized * -1f;
            val.z = hit.target.transform.position.z;
        }
        Profile profile = GetProfile(GetHitPower(hit));
        if ((profile.effectPrefab))
        {
            CreateEffect(profile.effectPrefab, val, hit.target.transform.lossyScale);
        }
        WithStatusProfile[] array = withStatusProfiles;
        foreach (WithStatusProfile withStatusProfile in array)
        {
            if ((hit.target.FindStatus(withStatusProfile.statusType)))
            {
                CreateEffect(withStatusProfile.effectPrefab, position, hit.target.transform.lossyScale);
                if (!((withStatusProfile.sfxEvent)).IsNull)
                {
                    SfxSystem.OneShot(withStatusProfile.sfxEvent);
                }
            }
        }
    }

    public void CreateEffect(GameObject prefab, Vector3 position, Vector3 scale)
    {
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        if ((prefab))
        {
            Object.Instantiate<GameObject>(prefab, position, Quaternion.identity, transform).transform.localScale = scale;
        }
    }
}
public class VfxStatusSystem : GameSystem
{
    [Serializable]
    public class Profile
    {
        public string type;

        public GameObject applyEffectPrefab;
    }

    [Serializable]
    public class DamageProfile
    {
        public string damageType;

        public GameObject damageEffectPrefab;
    }

    [SerializeField]
    public Profile[] profiles;

    [SerializeField]
    public DamageProfile[] damageProfiles;

    public Dictionary<string, Profile> profileLookup;

    public Dictionary<string, DamageProfile> damageProfileLookup;

    public void OnEnable()
    {
        Events.OnStatusEffectApplied += StatusApplied;
        Events.OnEntityHit += EntityHit;
        profileLookup = new Dictionary<string, Profile>();
        Profile[] array = profiles;
        foreach (Profile profile in array)
        {
            profileLookup[profile.type] = profile;
        }
        damageProfileLookup = new Dictionary<string, DamageProfile>();
        DamageProfile[] array2 = damageProfiles;
        foreach (DamageProfile damageProfile in array2)
        {
            damageProfileLookup[damageProfile.damageType] = damageProfile;
        }
    }

    public void OnDisable()
    {
        Events.OnStatusEffectApplied -= StatusApplied;
        Events.OnEntityHit -= EntityHit;
    }

    public void StatusApplied(StatusEffectApply apply)
    {
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0095: Unknown result type (might be due to invalid IL or missing references)
        if ((apply?.effectData) && apply.target.display.init && apply.target.startingEffectsApplied && !Transition.Running && profileLookup.ContainsKey(apply.effectData.type))
        {
            Profile profile = profileLookup[apply.effectData.type];
            if (profile != null && (profile.applyEffectPrefab))
            {
                Transform transform = apply.target.transform;
                CreateEffect(profile.applyEffectPrefab, transform.position, transform.lossyScale);
            }
        }
    }

    public void EntityHit(Hit hit)
    {
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        if (!hit.BasicHit && damageProfileLookup.ContainsKey(hit.damageType))
        {
            DamageProfile damageProfile = damageProfileLookup[hit.damageType];
            if (damageProfile != null && damageProfile.damageEffectPrefab != null)
            {
                CreateEffect(damageProfile.damageEffectPrefab, hit.target.transform.position, hit.target.transform.lossyScale);
            }
        }
    }

    public void CreateEffect(GameObject prefab, Vector3 position, Vector3 scale)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        Object.Instantiate<GameObject>(prefab, position, Quaternion.identity, transform).transform.localScale = scale;
    }
}
public class WaveDeploySystem : GameSystem
{
    public bool visible = true;

    [SerializeField]
    public Animator animator;

    [SerializeField]
    public WaveDeployerDots dotManager;

    [SerializeField]
    public TMP_Text counterText;

    [SerializeField]
    public GameObject group;

    [SerializeField]
    public UINavigationItem navigationItem;

    [Header("Settings")]
    [SerializeField]
    public int counterStart = -1;

    [SerializeField]
    public bool recallWhenUnsuccessful;

    [SerializeField]
    public int damageToOpponent;

    [SerializeField]
    public int damageIncreasePerTurn;

    [SerializeField]
    public float pauseAfterDeploy = 0.2f;

    public bool inBattle;

    public int damageToOpponentCurrent;

    public int currentWave;

    public BattleWaveManager waveManager;

    public int counter;

    public int counterMax;

    public bool reset;

    public bool deploySuccessful;

    public List<Entity> deployed;

    public static UINavigationItem nav;

    public void Awake()
    {
        group.SetActive(false);
        nav = navigationItem;
    }

    public void OnEnable()
    {
        Events.OnBattlePhaseStart += BattlePhaseStart;
        Events.OnSceneChanged += SceneChanged;
    }

    public void OnDisable()
    {
        Events.OnBattlePhaseStart -= BattlePhaseStart;
        Events.OnSceneChanged -= SceneChanged;
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        if (inBattle)
        {
            if (phase == Battle.Phase.Play && References.Battle.turnCount > 0)
            {
                ActionQueue.Add(new ActionSequence(CountDown())
                {
                    parallel = true
                });
            }
        }
        else if (phase == Battle.Phase.Init)
        {
            BattleStart();
        }
    }

    public void SceneChanged(Scene scene)
    {
        if (inBattle)
        {
            Hide();
            inBattle = false;
        }
    }

    public void BattleStart()
    {
        inBattle = true;
        damageToOpponentCurrent = damageToOpponent;
        currentWave = 0;
        waveManager = ((Component)References.Battle.enemy).GetComponent<BattleWaveManager>();
        counter = counterStart;
        reset = false;
        if (visible)
        {
            Show();
        }
        dotManager.Init(waveManager, currentWave);
        ActionQueue.Add(new ActionSequence(CountDown())
        {
            parallel = true
        });
    }

    public void Close()
    {
        animator.SetBool("Close", true);
    }

    public void Open()
    {
        animator.SetBool("Close", false);
    }

    public void Show()
    {
        visible = true;
        group.SetActive(true);
        animator.SetTrigger("Reveal");
        SfxSystem.OneShot("event:/sfx/inventory/wave_counter_showup");
    }

    public void Hide()
    {
        group.SetActive(false);
    }

    public IEnumerator CountDown()
    {
        if (currentWave >= waveManager.list.Count)
        {
            yield break;
        }
        bool earlyDeploy = CheckEarlyDeploy();
        if (visible)
        {
            Close();
            if (counter <= 1 || earlyDeploy)
            {
                SfxSystem.OneShot("event:/sfx/inventory/wave_counter_decrease_last");
            }
            else
            {
                SfxSystem.OneShot("event:/sfx/inventory/wave_counter_decrease");
            }
            yield return Sequences.Wait(0.1f);
        }
        if (earlyDeploy)
        {
            counter = 1;
        }
        if (reset)
        {
            reset = false;
        }
        else
        {
            SetCounter(Mathf.Clamp(counter - 1, 0, counterMax));
            if (counter <= 0)
            {
                yield return Activate();
            }
        }
        if (visible && counter > 0)
        {
            Open();
            if (counter == counterMax)
            {
                SfxSystem.OneShot("event:/sfx/inventory/wave_counter_refresh");
            }
        }
    }

    public void SetCounter(int value)
    {
        counter = value;
        counterText.text = value.ToString();
    }

    public void SetCounterMax(int value)
    {
        counterMax = value;
        SetCounter(value);
    }

    public bool CheckEarlyDeploy()
    {
        return Battle.GetCardsOnBoard(References.Battle.enemy).Count <= 0;
    }

    public IEnumerator Activate()
    {
        int thisWaveIndex = currentWave;
        int targetRow = Random.Range(0, Battle.instance.rowCount);
        yield return Sequences.Wait(0.2f);
        yield return TryDeploy(targetRow);
        if (deploySuccessful)
        {
            yield return RevealBoard();
            if (++currentWave < waveManager.list.Count)
            {
                BattleWaveManager.Wave wave = waveManager.list[currentWave];
                SetCounterMax(wave.counter);
            }
            damageToOpponentCurrent = damageToOpponent;
        }
        else
        {
            Routine.Clump clump = new Routine.Clump();
            if (recallWhenUnsuccessful)
            {
                yield return Sequences.Wait(0.33f);
                foreach (Entity item in deployed)
                {
                    clump.Add(Sequences.CardMove(item, new CardContainer[1] { References.Battle.enemy.reserveContainer }));
                }
                yield return clump.WaitForEnd();
            }
            else
            {
                yield return RevealBoard();
            }
            if (damageToOpponentCurrent > 0)
            {
                Entity entity = References.Player.entity;
                if (entity != null && entity.canBeHit)
                {
                    Hit hit = new Hit(References.Battle.enemy.entity, entity, damageToOpponentCurrent);
                    clump.Add(hit.Process());
                    clump.Add(Sequences.Wait(0.2f));
                }
            }
            yield return clump.WaitForEnd();
            damageToOpponentCurrent += damageIncreasePerTurn;
            SetCounter(1);
        }
        waveManager.list[thisWaveIndex].spawned = true;
        if (dotManager != null)
        {
            dotManager.UpdateDots(waveManager, thisWaveIndex);
        }
    }

    public IEnumerator TryDeploy(int rowIndex)
    {
        if (deployed == null)
        {
            deployed = new List<Entity>();
        }
        deployed.Clear();
        deploySuccessful = true;
        Entity[] array = waveManager.Peek();
        Entity[] array2 = array;
        foreach (Entity e in array2)
        {
            if (!(e != null) || !IArrayExt.Contains<CardContainer>(e.containers, e.owner.reserveContainer))
            {
                continue;
            }
            for (int j = 0; j < References.Battle.rowCount; j++)
            {
                rowIndex = (rowIndex + 1) % References.Battle.rowCount;
                if (References.Battle.CanDeploy(e, rowIndex, out var targetColumn))
                {
                    Deploy(e, rowIndex, targetColumn);
                    deployed.Add(e);
                    yield return ActionQueue.Wait(includeParallel: false);
                    break;
                }
            }
            if (!deployed.Contains(e))
            {
                deploySuccessful = false;
            }
        }
        if (deploySuccessful)
        {
            waveManager.Pull();
        }
    }

    public void Deploy(Entity entity, int targetRow, int targetColumn)
    {
        List<CardContainer> rows = Battle.instance.GetRows(entity.owner);
        List<CardContainer> list = new List<CardContainer>();
        for (int i = 0; i < entity.height; i++)
        {
            CardContainer item = rows[(targetRow + i) % rows.Count];
            list.Add(item);
        }
        entity.flipper.FlipUpInstant();
        ActionQueue.Add(new ActionMove(entity, list.ToArray())
        {
            insertPos = targetColumn,
            pauseAfter = pauseAfterDeploy
        });
    }

    public IEnumerator RevealBoard()
    {
        ActionQueue.Add(new ActionRevealAll(References.Battle.GetRows(References.Battle.enemy).ToArray()));
        yield return ActionQueue.Wait(includeParallel: false);
    }
}
public class WaveDeploySystemNoLimit : GameSystem
{
    [SerializeField]
    public GameObject blocker;

    [SerializeField]
    public GameObject icon;

    [SerializeField]
    public CanvasGroup group;

    [SerializeField]
    public TMP_Text numberElement;

    [Header("Settings")]
    [SerializeField]
    public int counterStart = -1;

    [SerializeField]
    public int counterMax = 3;

    [SerializeField]
    public int popUpCounterAt = 5;

    [SerializeField]
    public int bigIconAt = 3;

    [SerializeField]
    public Vector3 smallIconPos = new Vector3(0f, 3.4f, 0f);

    [SerializeField]
    public Vector3 smallIconScale = new Vector3(0.5f, 0.5f, 1f);

    [SerializeField]
    public float pauseAfterDeploy = 0.2f;

    [SerializeField]
    public bool countWhenXEnemies;

    [SerializeField]
    [ShowIf("countWhenXEnemies")]
    public int countWhenEnemiesRemaining = 1;

    [SerializeField]
    public bool needSpace = true;

    public bool inBattle;

    public int currentWave;

    public BattleWaveManager waveManager;

    public int counter;

    public bool reset;

    public bool deploySuccessful;

    public List<Entity> deployed;

    public void OnEnable()
    {
        Events.OnBattlePhaseStart += BattlePhaseStart;
        Events.OnSceneChanged += SceneChanged;
    }

    public void OnDisable()
    {
        Events.OnBattlePhaseStart -= BattlePhaseStart;
        Events.OnSceneChanged -= SceneChanged;
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        if (inBattle)
        {
            if (phase == Battle.Phase.Play && References.Battle.turnCount > 0)
            {
                ActionQueue.Add(new ActionSequence(CountDown())
                {
                    parallel = true
                });
            }
        }
        else if (phase == Battle.Phase.Init)
        {
            BattleStart();
        }
    }

    public void SceneChanged(Scene scene)
    {
        if (inBattle)
        {
            inBattle = false;
        }
    }

    public void BattleStart()
    {
        inBattle = true;
        currentWave = 0;
        waveManager = ((Component)References.Battle.enemy).GetComponent<BattleWaveManager>();
        counter = counterStart;
        reset = false;
        ActionQueue.Add(new ActionSequence(CountDown())
        {
            parallel = true
        });
    }

    public IEnumerator CountDown()
    {
        int enemyCount = GetEnemyCount();
        if ((countWhenXEnemies && enemyCount > countWhenEnemiesRemaining) || currentWave >= waveManager.list.Count)
        {
            yield break;
        }
        int num = References.Battle.GetRows(References.Battle.enemy).Cast<CardSlotLane>().SelectMany((CardSlotLane a) => a.slots)
            .Count((CardSlot a) => a.Empty);
        int count = waveManager.list[currentWave].units.Count;
        if (num >= count)
        {
            if (enemyCount <= 0)
            {
                counter = 0;
            }
            counter--;
            if (counter <= 0)
            {
                yield return Activate();
            }
            else if (counter <= popUpCounterAt)
            {
                new Routine(Pop());
            }
        }
    }

    public IEnumerator Pop()
    {
        numberElement.text = counter.ToString();
        ((Component)group).gameObject.SetActive(true);
        blocker.SetActive(true);
        group.alpha = 0f;
        icon.transform.localPosition = ((counter <= bigIconAt) ? Vector3.zero : smallIconPos);
        Vector3 val = ((counter <= bigIconAt) ? Vector3.one : smallIconScale);
        icon.transform.localScale = val * 1.5f;
        LeanTween.scale(icon, val, 1.5f).setEaseOutElastic();
        LeanTween.value(gameObject, 0f, 1f, 0.25f).setEaseLinear().setOnUpdate(delegate (float a)
        {
            group.alpha = a;
        });
        blocker.SetActive(false);
        yield return (object)new WaitForSeconds(1f);
        LeanTween.value(gameObject, 1f, 0f, 0.15f).setEaseLinear().setOnUpdate(delegate (float a)
        {
            group.alpha = a;
        })
            .setOnComplete((Action)delegate
            {
                ((Component)group).gameObject.SetActive(false);
            });
    }

    public IEnumerator Activate()
    {
        int thisWaveIndex = currentWave;
        int targetRow = Random.Range(0, Battle.instance.rowCount);
        yield return Sequences.Wait(0.2f);
        yield return TryDeploy(targetRow);
        if (deploySuccessful)
        {
            yield return RevealBoard();
            if (++currentWave < waveManager.list.Count)
            {
                counter = counterMax + 1;
            }
        }
        else
        {
            yield return RevealBoard();
            counter = 1;
        }
        waveManager.list[thisWaveIndex].spawned = true;
    }

    public IEnumerator TryDeploy(int rowIndex)
    {
        if (deployed == null)
        {
            deployed = new List<Entity>();
        }
        deployed.Clear();
        deploySuccessful = true;
        Entity[] array = waveManager.Peek();
        Entity[] array2 = array;
        foreach (Entity e in array2)
        {
            if (!(e != null) || !IArrayExt.Contains<CardContainer>(e.containers, e.owner.reserveContainer))
            {
                continue;
            }
            for (int j = 0; j < References.Battle.rowCount; j++)
            {
                rowIndex = (rowIndex + 1) % References.Battle.rowCount;
                if (References.Battle.CanDeploy(e, rowIndex, out var targetColumn))
                {
                    Deploy(e, rowIndex, targetColumn);
                    deployed.Add(e);
                    yield return ActionQueue.Wait(includeParallel: false);
                    break;
                }
            }
            if (!deployed.Contains(e))
            {
                deploySuccessful = false;
            }
        }
        if (deploySuccessful)
        {
            waveManager.Pull();
        }
    }

    public void Deploy(Entity entity, int targetRow, int targetColumn)
    {
        List<CardContainer> rows = Battle.instance.GetRows(entity.owner);
        List<CardContainer> list = new List<CardContainer>();
        for (int i = 0; i < entity.height; i++)
        {
            CardContainer item = rows[(targetRow + i) % rows.Count];
            list.Add(item);
        }
        entity.flipper.FlipUpInstant();
        ActionQueue.Add(new ActionMove(entity, list.ToArray())
        {
            insertPos = targetColumn,
            pauseAfter = pauseAfterDeploy
        });
    }

    public static IEnumerator RevealBoard()
    {
        ActionQueue.Add(new ActionRevealAll(References.Battle.GetRows(References.Battle.enemy).ToArray()));
        yield return ActionQueue.Wait(includeParallel: false);
    }

    public static int GetEnemyCount()
    {
        return Battle.GetCardsOnBoard(References.Battle.enemy).Count((Entity a) => !a.data.cardType.miniboss);
    }
}
public class WaveDeploySystemOverflow : GameSystem, ISaveable<BattleWaveData>
{
    public bool visible = true;

    [SerializeField]
    public Animator animator;

    [SerializeField]
    public TMP_Text counterText;

    [SerializeField]
    public GameObject group;

    public UINavigationItem navigationItem;

    [SerializeField]
    public CanvasGroup canvasGroup;

    [SerializeField]
    public Button button;

    [Header("Glow")]
    [SerializeField]
    public Image glow;

    [SerializeField]
    public Color glowColor = Color.black;

    [SerializeField]
    public Color glowImminentColor = Color.red;

    [Header("Deploy Early")]
    [SerializeField]
    public int deployEarlyReward;

    [SerializeField]
    public int deployEarlyRewardPerTurn = 5;

    [SerializeField]
    public bool autoEarlyDeploy = true;

    [SerializeField]
    public bool canCallEarly;

    [Header("Popup")]
    [SerializeField]
    public LocalizedString popupDesc;

    [SerializeField]
    public LocalizedString popupHitDesc;

    [SerializeField]
    public LocalizedString popupOverflowDesc;

    [SerializeField]
    public LocalizedString popupRewardDesc;

    [Header("Settings")]
    [SerializeField]
    public KeywordData popup;

    [SerializeField]
    public int counterStart = -1;

    [SerializeField]
    public float pauseAfterDeploy = 0.2f;

    public bool inBattle;

    public int currentWave;

    public int counter;

    public bool reset;

    public float fade = 1f;

    public float fadeTo;

    public float fadeAdd = 5f;

    public bool popped;

    public List<BattleWaveManager.Wave> waves;

    public List<Entity> deployedThisTurn;

    public List<ulong> deployed;

    public int overflowWaveIndex = -1;

    public void Awake()
    {
        group.SetActive(false);
        WaveDeploySystem.nav = navigationItem;
    }

    public void OnEnable()
    {
        Events.OnBattlePhaseStart += BattlePhaseStart;
        Events.OnSceneChanged += SceneChanged;
    }

    public void OnDisable()
    {
        Events.OnBattlePhaseStart -= BattlePhaseStart;
        Events.OnSceneChanged -= SceneChanged;
        StopAllCoroutines();
    }

    public void Update()
    {
        float num = fadeTo - fade;
        float num2 = fadeAdd * Time.deltaTime;
        if (Mathf.Abs(num) >= num2)
        {
            float num3 = Mathf.Clamp(num, 0f - num2, num2);
            fade += num3;
            if (Mathf.Abs(fadeTo - fade) <= num2)
            {
                fade = fadeTo;
            }
            canvasGroup.alpha = fade;
        }
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        if (inBattle)
        {
            if (phase != Battle.Phase.Play)
            {
                return;
            }
            if (References.Battle.turnCount == 0)
            {
                if (visible)
                {
                    Show();
                }
            }
            else
            {
                ActionQueue.Add(new ActionSequence(CountDown())
                {
                    parallel = true
                });
            }
        }
        else
        {
            switch (phase)
            {
                case Battle.Phase.Init:
                    BattleStart();
                    break;
                case Battle.Phase.Play:
                    inBattle = true;
                    break;
            }
        }
    }

    public void SceneChanged(Scene scene)
    {
        if (((scene)).name == "Battle")
        {
            Hide();
        }
        else if (inBattle)
        {
            Hide();
            BattleEnd();
        }
    }

    public void BattleStart()
    {
        inBattle = true;
        currentWave = 0;
        overflowWaveIndex = -1;
        BattleWaveManager component = ((Component)References.Battle.enemy).GetComponent<BattleWaveManager>();
        waves = new List<BattleWaveManager.Wave>(component.list);
        deployedThisTurn = new List<Entity>();
        deployed = new List<ulong>();
        counter = counterStart;
        reset = false;
        ActionQueue.Add(new ActionSequence(CountDown())
        {
            parallel = true
        });
    }

    public void BattleEnd()
    {
        inBattle = false;
        currentWave = 0;
        overflowWaveIndex = -1;
        waves = null;
        deployedThisTurn = null;
        deployed = null;
        counter = 0;
        reset = false;
    }

    public void AssignCardController(CardController controller)
    {
        GetComponentInChildren<ToggleBasedOnCardController>(true)?.AssignCardController(controller);
    }

    public void Close()
    {
        animator.SetBool("Close", true);
    }

    public void Open()
    {
        animator.SetBool("Close", false);
    }

    public void Show()
    {
        if (visible && currentWave < waves.Count)
        {
            group.SetActive(true);
            FadeIn();
            SfxSystem.OneShot("event:/sfx/inventory/wave_counter_showup");
            ((Selectable)button).interactable = canCallEarly;
        }
        AssignCardController(References.Battle.playerCardController);
    }

    public void Hide()
    {
        group.SetActive(false);
        FadeOut();
    }

    public void FadeIn()
    {
        fade = 0f;
        fadeTo = 1f;
        canvasGroup.blocksRaycasts = true;
    }

    public void FadeOut()
    {
        fadeTo = 0f;
        canvasGroup.blocksRaycasts = false;
    }

    public IEnumerator CountDown()
    {
        if (currentWave >= waves.Count)
        {
            yield break;
        }
        Events.InvokeWaveDeployerPreCountDown(counter);
        bool earlyDeploy = CheckEarlyDeploy();
        if (visible)
        {
            Close();
            if (counter <= 1 || earlyDeploy)
            {
                SfxSystem.OneShot("event:/sfx/inventory/wave_counter_decrease_last");
            }
            else
            {
                SfxSystem.OneShot("event:/sfx/inventory/wave_counter_decrease");
            }
            yield return Sequences.Wait(0.1f);
            if (!(this))
            {
                yield break;
            }
        }
        if (earlyDeploy && (References.Battle.turnCount == 0 || autoEarlyDeploy))
        {
            counter = 1;
        }
        if (reset)
        {
            reset = false;
        }
        else
        {
            SetCounter(Mathf.Max(counter - 1, 0));
            if (counter <= 0)
            {
                yield return Activate();
                if (!(this))
                {
                    yield break;
                }
            }
        }
        if (visible && counter > 0)
        {
            Open();
            if (counter == waves[currentWave].counter)
            {
                SfxSystem.OneShot("event:/sfx/inventory/wave_counter_refresh");
            }
        }
        Events.InvokeWaveDeployerPostCountDown(counter);
    }

    public void SetCounter(int value)
    {
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        counter = value;
        counterText.text = value.ToString();
        if (counter <= 1)
        {
            ((Graphic)glow).color = glowImminentColor;
        }
        else
        {
            ((Graphic)glow).color = glowColor;
        }
    }

    public static bool CheckEarlyDeploy()
    {
        return Battle.GetCardsOnBoard(References.Battle.enemy).Count <= 0;
    }

    public IEnumerator Activate()
    {
        int targetRow = Random.Range(0, Battle.instance.rowCount);
        FadeOut();
        yield return Sequences.Wait(0.2f);
        if (!(this))
        {
            yield break;
        }
        yield return TryDeploy(targetRow);
        if (!(this))
        {
            yield break;
        }
        if (deployedThisTurn.Count > 0)
        {
            yield return RevealBoard();
            if (!(this))
            {
                yield break;
            }
        }
        if (++currentWave < waves.Count)
        {
            SetCounter(waves[currentWave].counter);
            FadeIn();
        }
        else
        {
            Hide();
        }
    }

    public IEnumerator TryDeploy(int rowIndex)
    {
        deployedThisTurn.Clear();
        List<Entity> failedToDeploy = new List<Entity>();
        BattleWaveManager.Wave wave = waves[currentWave];
        foreach (CardData cardData2 in wave.units.Where((CardData cardData) => (cardData) && !deployed.Contains(cardData.id)))
        {
            Entity entity = References.Battle.cards.FirstOrDefault((Entity e) => e.data.id == cardData2.id);
            if (!(entity) || !IArrayExt.Contains<CardContainer>(entity.containers, entity.owner.reserveContainer))
            {
                continue;
            }
            bool thisDeployed = false;
            for (int i = 0; i < References.Battle.rowCount; i++)
            {
                rowIndex = (rowIndex + 1) % References.Battle.rowCount;
                if (References.Battle.CanDeploy(entity, rowIndex, out var targetColumn))
                {
                    thisDeployed = true;
                    Deploy(entity, rowIndex, targetColumn);
                    deployedThisTurn.Add(entity);
                    deployed.Add(cardData2.id);
                    yield return ActionQueue.Wait(includeParallel: false);
                    if ((this))
                    {
                        break;
                    }
                    yield break;
                }
            }
            if (!thisDeployed)
            {
                failedToDeploy.Add(entity);
            }
        }
        if (failedToDeploy.Count > 0)
        {
            Overflow(failedToDeploy);
        }
    }

    public void Deploy(Entity entity, int targetRow, int targetColumn)
    {
        List<CardContainer> rows = Battle.instance.GetRows(entity.owner);
        List<CardContainer> list = new List<CardContainer>();
        for (int i = 0; i < entity.height; i++)
        {
            CardContainer item = rows[(targetRow + i) % rows.Count];
            list.Add(item);
        }
        entity.flipper.FlipUpInstant();
        ActionQueue.Add(new ActionMove(entity, list.ToArray())
        {
            insertPos = targetColumn,
            pauseAfter = pauseAfterDeploy
        });
    }

    public static IEnumerator RevealBoard()
    {
        ActionQueue.Add(new ActionRevealAll(References.Battle.GetRows(References.Battle.enemy).ToArray()));
        yield return ActionQueue.Wait(includeParallel: false);
    }

    public void Overflow(IEnumerable<Entity> entities)
    {
        Debug.Log(("WaveSpawner → Overflowing [" + string.Join(", ", entities) + "]"));
        if (overflowWaveIndex <= currentWave)
        {
            CreateOverflowWave();
        }
        foreach (Entity entity in entities)
        {
            if (!TryToAddToOverflow(entity))
            {
                CreateOverflowWave();
                TryToAddToOverflow(entity);
            }
        }
    }

    public void CreateOverflowWave()
    {
        BattleWaveManager.Wave wave = waves[^1];
        BattleWaveManager.Wave item = new BattleWaveManager.Wave
        {
            units = new List<CardData>(),
            counter = wave.counter
        };
        waves.Add(item);
        overflowWaveIndex = waves.Count - 1;
        Debug.Log($"WaveSpawner → New Overflow Wave Created [index: {overflowWaveIndex}]");
    }

    public bool TryToAddToOverflow(Entity entity)
    {
        BattleWaveManager.Wave wave = waves[overflowWaveIndex];
        if (wave.units.Count < 6)
        {
            wave.units.Add(entity.data);
            Debug.Log($"WaveSpawner → [{(entity).name}] Added to Overflow Wave [index: {overflowWaveIndex}]");
            return true;
        }
        return false;
    }

    public void TryEarlyDeploy()
    {
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_00af: Unknown result type (might be due to invalid IL or missing references)
        int num = CountEmptySpacesOnBoard();
        BattleWaveManager.Wave wave = waves[currentWave];
        if (!canCallEarly)
        {
            return;
        }
        if (wave.units.Count <= num)
        {
            ActionEarlyDeploy action = new ActionEarlyDeploy(transform, EarlyDeploy())
            {
                parallel = true
            };
            if (Events.CheckAction(action))
            {
                ActionQueue.Add(action);
            }
            return;
        }
        SfxSystem.OneShot("event:/sfx/inventory/wave_counter_deny");
        Transform transform = transform;
        RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
        if (val != null)
        {
            val.anchoredPosition = new Vector2(-1f + FloatExt.WithRandomSign(0.25f, 0.5f), 2.5f);
            LeanTween.cancel(val);
            LeanTween.move(val, new Vector3(-1f, 2.5f, 0f), 1f).setEaseOutElastic();
        }
    }

    public IEnumerator EarlyDeploy()
    {
        InputSystem.Disable();
        Events.InvokeWaveDeployerEarlyDeploy();
        References.Battle.playerCardController.Disable();
        DropGold();
        counter = 1;
        yield return CountDown();
        References.Battle.playerCardController.Enable();
        InputSystem.Enable();
    }

    public void DropGold()
    {
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        int num = deployEarlyReward + deployEarlyRewardPerTurn * counter;
        if (num > 0)
        {
            Events.InvokeDropGold(num, "Wave Bell", References.Player, transform.position);
        }
    }

    public static int CountEmptySpacesOnBoard()
    {
        return References.Battle.GetRows(References.Battle.enemy).Sum((CardContainer a) => a.canBePlacedOn ? (a.max - a.Count) : 0);
    }

    public void Pop()
    {
        //IL_011d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0131: Expected O, but got Unknown
        if (popped || !(popup) || currentWave >= waves.Count)
        {
            return;
        }
        BattleWaveManager.Wave wave = waves[currentWave];
        int num = deployEarlyReward + deployEarlyRewardPerTurn * counter;
        string text = StringExt.Format(popupDesc.GetLocalizedString(), new object[2]
        {
            wave.units.Count,
            counter
        });
        int num2 = wave.units.Count - CountEmptySpacesOnBoard();
        if (num2 <= 0)
        {
            if (canCallEarly)
            {
                text = text + "\n\n" + popupHitDesc.GetLocalizedString();
                if (num > 0)
                {
                    text = text + "\n\n" + popupRewardDesc.GetLocalizedString(new object[1] { num });
                }
            }
        }
        else
        {
            text = text + "\n\n" + popupOverflowDesc.GetLocalizedString(new object[1] { num2 });
        }
        CardPopUp.AssignTo((RectTransform)transform, -1f, -0.25f);
        CardPopUp.AddPanel(popup, text);
        popped = true;
    }

    public void UnPop()
    {
        if (popped)
        {
            CardPopUp.RemovePanel((popup).name);
            popped = false;
        }
    }

    public BattleWaveData Save()
    {
        return new BattleWaveData
        {
            deployed = deployed,
            counter = counter,
            currentWave = currentWave,
            overflowWaveIndex = overflowWaveIndex,
            waves = waves.Select((BattleWaveManager.Wave a) => new BattleWaveData.Wave(a)).ToArray()
        };
    }

    public void Load(BattleWaveData data, IReadOnlyCollection<CardData> cards)
    {
        deployed = data.deployed;
        foreach (Entity item in References.Battle.enemy.reserveContainer)
        {
            int num = deployed.IndexOf(item.data.id);
            if (num >= 0)
            {
                deployed.RemoveAt(num);
            }
        }
        SetCounter(data.counter);
        currentWave = data.currentWave;
        overflowWaveIndex = data.overflowWaveIndex;
        waves = new List<BattleWaveManager.Wave>();
        BattleWaveData.Wave[] array = data.waves;
        foreach (BattleWaveData.Wave wave in array)
        {
            waves.Add(new BattleWaveManager.Wave
            {
                counter = wave.counter,
                isBossWave = wave.isBossWave,
                spawned = wave.spawned,
                units = wave.unitIds.Select((ulong a) => cards.FirstOrDefault((CardData b) => b.id == a)).ToList()
            });
        }
        if (currentWave < waves.Count)
        {
            Show();
        }
        deployedThisTurn = new List<Entity>();
    }
}
public class WorldSpaceCanvasFitScreenSystem : GameSystem
{
    public static WorldSpaceCanvasFitScreenSystem instance;

    public static bool exists;

    [Header("Screen Size")]
    [ReadOnly]
    public int screenWidth;

    [ReadOnly]
    public int screenHeight;

    [ReadOnly]
    public float aspectRatio;

    [Header("UI Size")]
    [ReadOnly]
    public Rect safeArea;

    public const float fixedHeight = 11.547f;

    public const float maxWidth = 26.943f;

    public const float minWidth = 17.32051f;

    public const float minAspect = 1.5f;

    public const float maxAspect = 2.3333333f;

    public static readonly List<WorldSpaceCanvasUpdater> canvases = new List<WorldSpaceCanvasUpdater>();

    public static readonly Vector3 camPosition = new Vector3(0f, 0f, -10f);

    public ScreenOrientation lastOrientation;

    public Rect lastSafeArea;

    public Camera cam { get; set; }

    public static float AspectRatio
    {
        get
        {
            if (!exists)
            {
                return 1.7777778f;
            }
            return Mathf.Min(2.3333333f, instance.aspectRatio);
        }
    }

    public void OnEnable()
    {
        instance = this;
        exists = true;
        Events.OnSceneChanged += SceneChanged;
        UpdateSize();
    }

    public void OnDisable()
    {
        Events.OnSceneChanged -= SceneChanged;
    }

    public void SceneChanged(Scene scene)
    {
        UpdateSize();
    }

    public void Update()
    {
        if (!(cam))
        {
            cam = Camera.main;
            if ((cam))
            {
                UpdateSize();
            }
        }
        else if (cam.scaledPixelWidth != screenWidth || cam.scaledPixelHeight != screenHeight)
        {
            UpdateSize();
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void UpdateSize()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0189: Unknown result type (might be due to invalid IL or missing references)
        //IL_018e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fc: Unknown result type (might be due to invalid IL or missing references)
        //IL_0101: Unknown result type (might be due to invalid IL or missing references)
        //IL_0109: Unknown result type (might be due to invalid IL or missing references)
        //IL_010e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0116: Unknown result type (might be due to invalid IL or missing references)
        //IL_011b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0123: Unknown result type (might be due to invalid IL or missing references)
        //IL_0128: Unknown result type (might be due to invalid IL or missing references)
        //IL_0192: Unknown result type (might be due to invalid IL or missing references)
        //IL_01e6: Unknown result type (might be due to invalid IL or missing references)
        //IL_01e7: Unknown result type (might be due to invalid IL or missing references)
        //IL_01f1: Unknown result type (might be due to invalid IL or missing references)
        lastOrientation = Screen.orientation;
        lastSafeArea = Screen.safeArea;
        Debug.Log($"[{this}] UPDATING ~World Space~ CANVAS SIZE");
        if (!(cam))
        {
            cam = Camera.main;
        }
        screenWidth = cam.scaledPixelWidth;
        screenHeight = cam.scaledPixelHeight;
        aspectRatio = cam.aspect;
        Debug.Log($"New Size: ({screenWidth}, {screenHeight}) Aspect: {aspectRatio}");
        int num = screenWidth;
        Rect val;
        Rect val2 = default(Rect);
        if (aspectRatio > 2.3333333f)
        {
            num = Mathf.RoundToInt((float)screenHeight * 2.3333333f);
            Debug.Log($"OVER MAX ASPECT RATIO. Actual Size: ({num}, {screenHeight}) Aspect: {(float)num / (float)screenHeight}");
            val = Screen.safeArea;
            float x = ((val)).x;
            val = Screen.safeArea;
            float y = ((val)).y;
            val = Screen.safeArea;
            float width = ((val)).width;
            val = Screen.safeArea;
            ((val2))..ctor(x, y, width, ((val)).height);
            if (((val2)).width / ((val2)).height > 2.3333333f)
            {
                float num2 = ((val2)).height * 2.3333333f;
                float num3 = ((val2)).width - num2;
                ((val2)).x = Mathf.Max(0f, ((val2)).x - num3);
                ((val2)).width = num2;
            }
        }
        else
        {
            val2 = Screen.safeArea;
        }
        val = default(Rect);
        ((val)).x = ((val2)).x / (float)num;
        ((val)).y = ((val2)).y / (float)screenHeight;
        ((val)).width = ((val2)).width / (float)num;
        ((val)).height = ((val2)).height / (float)screenHeight;
        safeArea = val;
        Debug.Log($"UI Safe Area: {val2}");
        foreach (WorldSpaceCanvasUpdater canvase in canvases)
        {
            canvase.UpdateSize();
        }
    }

    public static void Register(WorldSpaceCanvasUpdater canvas)
    {
        canvases.Add(canvas);
    }

    public static void Unregister(WorldSpaceCanvasUpdater canvas)
    {
        canvases.Remove(canvas);
    }
}
public class Talker : MonoBehaviour
{
    public struct Store
    {
        public string speechType;

        public float delay;

        public object[] inserts;

        public Store(string speechType, float delay, object[] inserts)
        {
            this.speechType = speechType;
            this.delay = delay;
            this.inserts = inserts;
        }
    }

    [Serializable]
    public struct Speech
    {
        public string type;

        public string[] poseOptions;

        public LocalizedString[] options;

        public EventReference sfxEvent;

        public List<LocalizedString> optionPool;

        public string Pull()
        {
            if (optionPool == null)
            {
                optionPool = new List<LocalizedString>();
            }
            if (optionPool.Count <= 0)
            {
                optionPool.AddRange(options);
            }
            int index = PettyRandom.Range(0, optionPool.Count - 1);
            LocalizedString obj = optionPool[index];
            optionPool.RemoveAt(index);
            return obj.GetLocalizedString();
        }
    }

    [SerializeField]
    public LocalizedString nameKey;

    [SerializeField]
    public Transform talkFrom;

    [SerializeField]
    public AvatarPoser poser;

    [SerializeField]
    public Speech[] speech;

    public readonly Dictionary<string, Speech> speechLookup = new Dictionary<string, Speech>();

    public readonly List<Store> stored = new List<Store>();

    public string GetName()
    {
        if (!((LocalizedReference)nameKey).IsEmpty)
        {
            return nameKey.GetLocalizedString();
        }
        return "";
    }

    public void Awake()
    {
        Speech[] array = speech;
        for (int i = 0; i < array.Length; i++)
        {
            Speech value = array[i];
            speechLookup[value.type] = value;
        }
    }

    public void OnEnable()
    {
        foreach (Store item in stored)
        {
            Say(item.speechType, item.delay, item.inserts);
        }
        stored.Clear();
    }

    public void OnDisable()
    {
        StopAllCoroutines();
    }

    public void Say(string speechType, float delay = 0f, params object[] inserts)
    {
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        if (!enabled || !gameObject.activeInHierarchy)
        {
            stored.Add(new Store(speechType, delay, inserts));
        }
        else
        {
            if (!Get(speechType, out var speech))
            {
                return;
            }
            string text = speech.Pull();
            EventReference? sfxEvent = speech.sfxEvent;
            if (inserts.Length != 0)
            {
                text = string.Format(text, inserts);
            }
            if (text.Contains('|'))
            {
                string[] array = text.Split('|');
                float num = 0f;
                string[] array2 = array;
                foreach (string text2 in array2)
                {
                    StartCoroutine(SayAfterDelay(text2, sfxEvent, delay + num));
                    if (speech.poseOptions.Length != 0 && (poser))
                    {
                        StartCoroutine(PoseAfterDelay(IArrayExt.RandomItem<string>(speech.poseOptions), delay + num));
                    }
                    num += Mathf.Max(1.25f, SpeechBubbleSystem.GetDuration(text2) * 0.5f);
                    sfxEvent = null;
                }
            }
            else
            {
                StartCoroutine(SayAfterDelay(text, sfxEvent, delay));
                if (speech.poseOptions.Length != 0 && (poser))
                {
                    StartCoroutine(PoseAfterDelay(IArrayExt.RandomItem<string>(speech.poseOptions), delay));
                }
            }
        }
    }

    public bool Get(string type, out Speech speech)
    {
        bool flag = speechLookup.TryGetValue(type, out speech);
        if (!flag)
        {
            Speech[] array = this.speech.Where((Speech a) => a.type == type).ToArray();
            if (array.Length != 0)
            {
                flag = true;
                speech = array[0];
            }
        }
        return flag;
    }

    public IEnumerator SayAfterDelay(string text, EventReference? sfxEvent, float delay = 0f)
    {
        if (delay > 0f)
        {
            yield return (object)new WaitForSeconds(delay);
        }
        if (sfxEvent.HasValue)
        {
            EventReference valueOrDefault = sfxEvent.GetValueOrDefault();
            if (!((valueOrDefault)).IsNull)
            {
                SfxSystem.OneShot(sfxEvent.Value);
            }
        }
        SpeechBubbleSystem.Create(new SpeechBubbleData(talkFrom, GetName(), text));
    }

    public IEnumerator PoseAfterDelay(string pose, float delay = 0f)
    {
        if (delay > 0f)
        {
            yield return (object)new WaitForSeconds(delay);
        }
        poser.Set(pose);
    }
}
public class TextContainer : MonoBehaviour
{
    public TextMeshProUGUI textAsset;

    public void SetText(string text)
    {
        ((TMP_Text)textAsset).text = text;
    }
}
public class TextImageDrawer : TMP_Text
{
    [SerializeField]
    public TextImageData data;

    public Image[] images;

    public Transform _transform;

    public Transform transform => _transform ?? (_transform = GetComponent<Transform>());

    public override string text
    {
        get
        {
            return base.m_text;
        }
        set
        {
            if (base.m_text != value)
            {
                base.m_text = value;
                DrawText();
            }
        }
    }

    public override Color color
    {
        get
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            return base.m_fontColor;
        }
        set
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            //IL_0002: Unknown result type (might be due to invalid IL or missing references)
            base.m_fontColor = value;
            SetColour();
        }
    }

    public override void Awake()
    {
        ((UIBehaviour)this).Awake();
        DrawText();
    }

    public void DrawText()
    {
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c8: Unknown result type (might be due to invalid IL or missing references)
        Clear();
        images = (Image[])(object)new Image[base.m_text.Length];
        for (int i = 0; i < base.m_text.Length; i++)
        {
            char value = base.m_text[i];
            if (data.TryGetSprite(value, out var result))
            {
                GameObject val = new GameObject(value.ToString());
                Image val2 = val.AddComponent<Image>();
                val2.sprite = result;
                ((Graphic)val2).color = base.m_fontColor;
                ((Graphic)val2).material = material;
                ((Graphic)val2).raycastTarget = raycastTarget;
                ((MaskableGraphic)val2).maskable = maskable;
                val2.preserveAspect = true;
                images[i] = val2;
                Transform val3 = val.transform;
                if (val3 != null)
                {
                    val3.SetParent(transform);
                    val3.localScale = Vector3.one;
                    val3.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
                }
            }
        }
    }

    public void SetColour()
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        Image[] array = images;
        for (int i = 0; i < array.Length; i++)
        {
            ((Graphic)array[i]).color = base.m_fontColor;
        }
    }

    public void Clear()
    {
        Image[] array = images;
        if (array == null || array.Length <= 0)
        {
            return;
        }
        array = images;
        foreach (Image val in array)
        {
            if ((val) && (((Component)val).gameObject))
            {
                Object.Destroy(((Component)val).gameObject);
            }
        }
    }
}
public class TiledImageMover : MonoBehaviourCacheTransform
{
    [SerializeField]
    public float moveX = 1f;

    [SerializeField]
    public float resetPosX = 0.5f;

    public void Update()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        Vector3 localPosition = base.transform.localPosition;
        float num = localPosition.x + moveX * Time.deltaTime;
        if (num >= resetPosX)
        {
            num -= resetPosX * 2f;
        }
        else if (num <= 0f - resetPosX)
        {
            num += resetPosX * 2f;
        }
        base.transform.localPosition = Vector3Ext.WithX(localPosition, num);
    }
}
public class ToggleBasedOnCardController : MonoBehaviour
{
    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public MonoBehaviour[] components;

    [SerializeField]
    public UnityEvent onEnable;

    [SerializeField]
    public UnityEvent onDisable;

    public void AssignCardController(CardController controller)
    {
        cardController = controller;
        if (((Behaviour)controller).enabled)
        {
            Enable();
        }
        else
        {
            Disable();
        }
    }

    public void OnEnable()
    {
        Events.OnCardControllerEnabled += CardControllerEnabled;
        Events.OnCardControllerDisabled += CardControllerDisabled;
    }

    public void OnDisable()
    {
        Events.OnCardControllerEnabled -= CardControllerEnabled;
        Events.OnCardControllerDisabled -= CardControllerDisabled;
    }

    public void CardControllerEnabled(CardController controller)
    {
        if (controller == cardController)
        {
            Enable();
        }
    }

    public void CardControllerDisabled(CardController controller)
    {
        if (controller == cardController)
        {
            Disable();
        }
    }

    public void Enable()
    {
        MonoBehaviour[] array = components;
        for (int i = 0; i < array.Length; i++)
        {
            ((Behaviour)array[i]).enabled = true;
        }
        UnityEvent obj = onEnable;
        if (obj != null)
        {
            obj.Invoke();
        }
    }

    public void Disable()
    {
        MonoBehaviour[] array = components;
        for (int i = 0; i < array.Length; i++)
        {
            ((Behaviour)array[i]).enabled = false;
        }
        UnityEvent obj = onDisable;
        if (obj != null)
        {
            obj.Invoke();
        }
    }
}
public class BalloonSequence : BuildingSequence
{
    [SerializeField]
    public RectTransform panel;

    [SerializeField]
    public TMP_Text title;

    [SerializeField]
    public TMP_Text date;

    [SerializeField]
    public LocalizedString titleKey;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public DeckDisplayGroup deckDisplayGroup;

    [SerializeField]
    public DailyGenerator dailyGenerator;

    [SerializeField]
    public GameMode gameMode;

    [SerializeField]
    public GameObject playButton;

    [SerializeField]
    public GameObject scoresButton;

    [SerializeField]
    public GameObject timer;

    [SerializeField]
    public HelpPanelShower noConnection;

    [SerializeField]
    public ModifierDisplay modifierDisplay;

    [SerializeField]
    public Scroller scroller;

    [SerializeField]
    public GameObject loadingIcon;

    [SerializeField]
    public HelpPanelShower firstTimeHelp;

    public int seed;

    public bool loading;

    public void OnDisable()
    {
        DailyFetcher.CancelFetch();
    }

    public override IEnumerator Sequence()
    {
        panel.anchoredPosition = new Vector2(-10f, 0f);
        playButton.SetActive(false);
        scoresButton.SetActive(false);
        loadingIcon.SetActive(true);
        yield return DailyFetcher.FetchDateTime();
        if (!DailyFetcher.fetched)
        {
            noConnection.Show();
            noConnection.AddButton(0, HelpPanelSystem.ButtonType.Positive, new UnityAction(Close));
            yield break;
        }
        loadingIcon.SetActive(false);
        panel.LeanMove(new Vector3(-0.7f, 0f), 1.2f).setFrom(new Vector3(-2.5f, 0f)).setEaseOutElastic();
        bool flag = DailyFetcher.CanPlay();
        playButton.SetActive(flag);
        timer.SetActive(!flag);
        scoresButton.SetActive(true);
        seed = DailyFetcher.GetSeed();
        string localizedString = titleKey.GetLocalizedString();
        title.text = localizedString;
        DateTime dateTime = DailyFetcher.GetDateTime();
        Debug.Log($"DailyFetcher → Daily Time: {dateTime}");
        LocaleIdentifier identifier = LocalizationSettings.SelectedLocale.Identifier;
        CultureInfo cultureInfo = ((identifier)).CultureInfo;
        date.text = dateTime.ToString("D", cultureInfo);
        yield return dailyGenerator.Run(seed, gameMode);
        List<GameModifierData> modifiers = Campaign.Data.Modifiers;
        if (modifiers != null && modifiers.Count > 0)
        {
            foreach (GameModifierData modifier in Campaign.Data.Modifiers)
            {
                modifierDisplay.CreateIcon(modifier);
            }
        }
        yield return CreateCards(References.PlayerData.inventory.deck);
        if (!SaveSystem.LoadProgressData("dailyRunHelpSeen", defaultValue: false))
        {
            firstTimeHelp.Show();
            SaveSystem.SaveProgressData("dailyRunHelpSeen", value: true);
        }
    }

    public IEnumerator CreateCards(IEnumerable<CardData> cardsToCreate)
    {
        List<Card> list = new List<Card>();
        Routine.Clump clump = new Routine.Clump();
        foreach (CardData item in cardsToCreate)
        {
            Card card = CardManager.Get(item, cardController, null, inPlay: false, isPlayerCard: true);
            list.Add(card);
            card.entity.flipper.FlipDownInstant();
            clump.Add(UpdateCardData(card));
        }
        foreach (Card item2 in list)
        {
            deckDisplayGroup.AddCard(item2);
        }
        yield return clump.WaitForEnd();
        yield return null;
        deckDisplayGroup.UpdatePositions();
        if ((scroller))
        {
            scroller.ScrollImmediate(10f);
        }
    }

    public static IEnumerator UpdateCardData(Card card)
    {
        yield return card.UpdateData();
        card.entity.flipper.FlipUp(force: true);
    }

    public void Continue()
    {
        if (enabled)
        {
            enabled = false;
            SaveSystem.SaveProgressData("dailyPlayed", DailyFetcher.GetDateTime().ToString());
            Campaign.Begin();
            new Routine(Transition.To("Campaign"));
        }
    }

    public new void Close()
    {
        Object.FindObjectOfType<BuildingDisplay>()?.End();
    }
}
public class BuildingCardUnlockSequence : BuildingSequenceWithUnlocks<BuildingCardUnlockSequence>
{
    [SerializeField]
    public CardController controller;

    [SerializeField]
    public Transform owner;

    [SerializeField]
    public CardUnlockSequence cardUnlockSequence;

    [SerializeField]
    public string metaprogressionKey = "companions";

    [SerializeField]
    public string firstGreetKey;

    public void Start()
    {
        _OnStart();
    }

    public override IEnumerator Sequence()
    {
        int num = Mathf.Min(locks.Length, building.type.unlocks.Length);
        for (int i = 0; i < num; i++)
        {
            if (building.type.unlocks[i].IsActive)
            {
                locks[i].SetActive(false);
            }
        }
        yield return CreateCards();
        if (building.HasUncheckedUnlocks)
        {
            foreach (string uncheckedUnlock in building.uncheckedUnlocks)
            {
                yield return Unlock(uncheckedUnlock);
            }
            Entity entity = cardSlots.LastOrDefault((CardContainer a) => !a.Empty)?.GetTop();
            if ((entity))
            {
                TalkerNewCard(entity.data);
            }
        }
        else if (!StringExt.IsNullOrEmpty(firstGreetKey) && !SaveSystem.LoadProgressData(firstGreetKey, defaultValue: false))
        {
            TalkerFirstGreet();
            SaveSystem.SaveProgressData(firstGreetKey, value: true);
        }
        else
        {
            TalkerGreet();
        }
        UnityEvent obj = onSetUpComplete;
        if (obj != null)
        {
            obj.Invoke();
        }
    }

    public IEnumerator Unlock(string unlockDataName)
    {
        int num = building.type.unlocks.Select((UnlockData a) => (a).name).ToList().IndexOf(unlockDataName);
        if (num < 0)
        {
            throw new IndexOutOfRangeException("[" + unlockDataName + "] does not exist in [" + (building).name + "] unlocks list!");
        }
        string assetName = MetaprogressionSystem.Get<List<string>>(metaprogressionKey)[num];
        List<string> list = SaveSystem.LoadProgressData(building.type.unlockedCheckedKey, new List<string>());
        list.Add(unlockDataName);
        SaveSystem.SaveProgressData(building.type.unlockedCheckedKey, list);
        CardData data = AddressableLoader.Get<CardData>("CardData", assetName);
        Card card = CardManager.Get(data, controller, null, inPlay: false, isPlayerCard: true);
        yield return card.UpdateData();
        CardContainer finalSlot = cardSlots.FirstOrDefault((CardContainer a) => a.Empty);
        yield return cardUnlockSequence.Run(card.entity, finalSlot);
        if ((finalSlot))
        {
            Image component = ((Component)finalSlot).GetComponent<Image>();
            if (component != null)
            {
                ((Behaviour)component).enabled = true;
            }
        }
    }

    public IEnumerator CreateCards()
    {
        List<Entity> cards = new List<Entity>();
        Routine.Clump clump = new Routine.Clump();
        int num = building.checkedUnlocks?.Count ?? 0;
        List<string> list = MetaprogressionSystem.Get<List<string>>(metaprogressionKey);
        for (int i = 0; i < num && i < list.Count; i++)
        {
            string assetName = list[i];
            Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", assetName), controller, null, inPlay: false, isPlayerCard: true);
            cards.Add(card.entity);
            clump.Add(card.UpdateData());
        }
        yield return clump.WaitForEnd();
        foreach (Entity item in cards)
        {
            CardContainer cardContainer = cardSlots.FirstOrDefault((CardContainer a) => a.Empty);
            if (cardContainer != null)
            {
                item.flipper.FlipUpInstant();
                ((Behaviour)item).enabled = true;
                cardContainer.Add(item);
                cardContainer.SetChildPositions();
                Image component = ((Component)cardContainer).GetComponent<Image>();
                if (component != null)
                {
                    ((Behaviour)component).enabled = false;
                }
                continue;
            }
            break;
        }
        UnityEvent obj = onSetUpComplete;
        if (obj != null)
        {
            obj.Invoke();
        }
    }
}
public class BuildingSequence : MonoBehaviour
{
    [ReadOnly]
    public Building building;

    [SerializeField]
    public Talker talker;

    [SerializeField]
    public EventReference enterSfxEvent;

    public virtual IEnumerator Sequence()
    {
        yield return null;
    }

    public void TalkerGreet()
    {
        TalkerSay("greet", PettyRandom.Range(0.25f, 0.5f));
    }

    public void TalkerFirstGreet()
    {
        TalkerSay("firstGreet", 0.5f);
    }

    public void TalkerNewCard(CardData cardData)
    {
        TalkerSay("new card", 0.5f, cardData.title);
    }

    public void TalkerSay(string speechType, float delay, params object[] inserts)
    {
        if ((talker))
        {
            talker.Say(speechType, delay, inserts);
        }
    }

    public void Play(Building building)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        if (!((enterSfxEvent)).IsNull)
        {
            SfxSystem.OneShot(enterSfxEvent);
        }
        this.building = building;
        StartCoroutine(Sequence());
    }

    public void Close()
    {
        StopAllCoroutines();
        Object.FindObjectOfType<BuildingDisplay>(true)?.End();
    }
}
public abstract class BuildingSequenceWithUnlocks<T> : BuildingSequence where T : BuildingSequenceWithUnlocks<T>
{
    [SerializeField]
    public GridLayoutGroup slotGrid;

    [SerializeField]
    public Transform challengeStonesParent;

    [SerializeField]
    public GameObject[] locks;

    [SerializeField]
    public CardContainer[] cardSlots;

    [SerializeField]
    public ChallengeStone[] challengeStones;

    [SerializeField]
    public UnityEvent onSetUpComplete;

    public static event RuntimeILReferenceBag.FastDelegateInvokers.Action<T> OnStart;

    public void AddChallengeStone(ChallengeData unlock)
    {
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        //IL_0082: Unknown result type (might be due to invalid IL or missing references)
        if ((unlock) && !(IArrayExt.ToList<ChallengeStone>(challengeStones).Find((ChallengeStone a) => a.challenge == unlock)))
        {
            GameObject val = ObjectExt.InstantiateKeepName<GameObject>(Addressables.LoadAssetAsync<GameObject>((object)"ChallengeStone").WaitForCompletion());
            val.transform.parent = ((Component)challengeStonesParent).transform;
            val.transform.localPosition = Vector3Ext.WithZ(val.transform.localPosition, 0f);
            ChallengeStone componentInChildren = val.GetComponentInChildren<ChallengeStone>();
            challengeStones = CollectionExtensions.AddToArray<ChallengeStone>(challengeStones, componentInChildren);
            componentInChildren.challenge = unlock;
            componentInChildren.OnEnable();
        }
    }

    public void AddSlot(ChallengeData unlock)
    {
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        if ((unlock) && !(IArrayExt.ToList<CardContainer>(cardSlots).Find(delegate (CardContainer a)
        {
            GameObject gameObject = ((Component)a).gameObject;
            return ((gameObject == null) ? null : gameObject.GetComponentInChildren<ChallengeDisplayCreator>()?.challenge) == unlock;
        })))
        {
            GameObject obj = ObjectExt.InstantiateKeepName<GameObject>(Addressables.LoadAssetAsync<GameObject>((object)"ProgressableCardStack").WaitForCompletion());
            obj.transform.parent = ((Component)slotGrid).transform;
            CardStack componentInChildren = obj.GetComponentInChildren<CardStack>();
            cardSlots = CollectionExtensions.AddToArray<CardContainer>(cardSlots, (CardContainer)componentInChildren);
            locks = CollectionExtensions.AddToArray<GameObject>(locks, ((Component)((Component)componentInChildren).gameObject.transform.GetChild(0)).gameObject);
            ChallengeDisplayCreator componentInChildren2 = obj.GetComponentInChildren<ChallengeDisplayCreator>();
            componentInChildren2.challenge = unlock;
            componentInChildren2.Check();
        }
    }

    public void _OnStart()
    {
        BuildingSequenceWithUnlocks<T>.OnStart?.Invoke(this as T);
    }

    public BuildingSequenceWithUnlocks()
    {
    }
}
public class ChallengeShrineSequence : BuildingSequenceWithUnlocks<ChallengeShrineSequence>
{
    public void Start()
    {
        _OnStart();
    }

    public void OnEnable()
    {
        List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
        Dictionary<string, string> dictionary = MetaprogressionSystem.Get<Dictionary<string, string>>("charms");
        for (int i = 0; i < challengeStones.Length; i++)
        {
            ChallengeStone challengeStone = challengeStones[i];
            if (unlockedList.Contains((challengeStone.challenge.reward).name))
            {
                string text = dictionary[(challengeStone.challenge.reward).name];
                CardUpgradeData upgradeData = AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", text);
                challengeStone.Open(upgradeData);
                CardDiscoverSystem.CheckDiscoverCharm(text);
            }
        }
    }
}
public class FrostoscopeSequence : MonoBehaviour
{
    [SerializeField]
    public EventReference enterSfxEvent;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardContainer[] cardHolders;

    [SerializeField]
    public CardContainer leaderCardHolder;

    [SerializeField]
    public Transform scene;

    [SerializeField]
    public BattleGenerationScriptFinalBoss generationScript;

    [SerializeField]
    public Vector2 cameraLimits;

    [SerializeField]
    public GameObject nothingHere;

    [SerializeField]
    public GameObject group;

    [SerializeField]
    public bool enableGroupAfterGeneration;

    [SerializeField]
    [ShowIf("enableGroupAfterGeneration")]
    public float delayBeforeEnableGroup = 0.25f;

    [SerializeField]
    public bool unloadSceneOnEnd;

    public Entity hover;

    public bool hovering;

    public bool generated;

    public void OnEnable()
    {
        Events.OnEntityHover += EntityHover;
        Events.OnEntityUnHover += EntityUnHover;
        cardController.Enable();
        StartCoroutine(Run());
        MusicSystem.FadePitchTo(0.25f, 0.2f);
    }

    public void OnDisable()
    {
        Events.OnEntityHover -= EntityHover;
        Events.OnEntityUnHover -= EntityUnHover;
        hover = null;
        hovering = false;
        cardController.Disable();
        StopAllCoroutines();
        generated = false;
        MusicSystem.FadePitchTo(1f, 0.2f);
    }

    public void EntityHover(Entity entity)
    {
        hover = entity;
        hovering = true;
    }

    public void EntityUnHover(Entity entity)
    {
        hover = null;
        hovering = false;
    }

    public void Update()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0075: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ae: Unknown result type (might be due to invalid IL or missing references)
        Vector3 localPosition = scene.localPosition;
        Vector3 val = -(hovering ? Vector3.Lerp(Vector3Ext.WithZ(hover.transform.position, 0f), Cursor3d.Position, 0.5f) : Cursor3d.Position);
        val.x = Mathf.Clamp(val.x, 0f - cameraLimits.x, cameraLimits.x);
        val.y = Mathf.Clamp(val.y, 0f - cameraLimits.y, cameraLimits.y);
        scene.localPosition = Delta.Lerp(localPosition, val, 0.025f, Time.deltaTime);
    }

    public IEnumerator Run()
    {
        if (enableGroupAfterGeneration)
        {
            Routine.Clump clump = new Routine.Clump();
            clump.Add(CreateCards(startFlipped: false));
            clump.Add(Sequences.Wait(delayBeforeEnableGroup));
            yield return clump.WaitForEnd();
            group.SetActive(true);
        }
        SfxSystem.OneShot(enterSfxEvent);
        if (!generated)
        {
            yield return CreateCards(startFlipped: true);
        }
    }

    public IEnumerator CreateCards(bool startFlipped)
    {
        generated = true;
        var (gameMode, seed) = GetGameModeAndSeed();
        if (!TryGetPreGeneratedBattle(gameMode, out var cards))
        {
            CardData[] cardList = generationScript.LoadCards(gameMode);
            generationScript.GetBaseEnemies(cardList, seed, out cards, out var _, out var _, out var _, out var _, out var _);
        }
        if (cards == null || cards.Count <= 0)
        {
            nothingHere.SetActive(true);
            yield break;
        }
        nothingHere.SetActive(false);
        Routine.Clump clump = new Routine.Clump();
        List<CardContainer> list = IArrayExt.ToList<CardContainer>(cardHolders);
        foreach (CardData item in cards)
        {
            if (item.cardType.miniboss)
            {
                clump.Add(CreateCard(item, leaderCardHolder, startFlipped));
                continue;
            }
            if (list.Count <= 0)
            {
                break;
            }
            clump.Add(CreateCard(item, list[0], startFlipped));
            list.RemoveAt(0);
        }
        yield return clump.WaitForEnd();
    }

    public static bool TryGetPreGeneratedBattle(GameMode gameMode, out List<CardData> cards)
    {
        cards = null;
        if (SaveSystem.LoadCampaignData(gameMode, "result", Campaign.Result.None) != 0)
        {
            return false;
        }
        CampaignNodeSaveData campaignNodeSaveData = SaveSystem.LoadCampaignData<CampaignSaveData>(gameMode, "data")?.nodes?.FirstOrDefault((CampaignNodeSaveData a) => a.typeName == "CampaignNodeFinalBoss");
        if (campaignNodeSaveData != null && campaignNodeSaveData.data.TryGetValue("waves", out var value) && value is SaveCollection<BattleWaveManager.WaveData>)
        {
            BattleWaveManager.WaveData[] collection = ((SaveCollection<BattleWaveManager.WaveData>)value).collection;
            if (collection != null)
            {
                cards = new List<CardData>();
                if (!campaignNodeSaveData.cleared)
                {
                    BattleWaveManager.WaveData[] array = collection;
                    foreach (BattleWaveManager.WaveData waveData in array)
                    {
                        if (!(waveData is BattleWaveManager.WaveDataFull { cardDatas: var cardDatas }))
                        {
                            for (int j = 0; j < waveData.Count; j++)
                            {
                                cards.Add(waveData.GetCardData(j));
                            }
                            continue;
                        }
                        foreach (CardSaveData cardSaveData in cardDatas)
                        {
                            cards.Add(cardSaveData.Load());
                        }
                    }
                }
                return true;
            }
        }
        return false;
    }

    public static (GameMode, int) GetGameModeAndSeed()
    {
        int num = -1;
        GameMode item;
        if ((References.Campaign) && Campaign.Data != null)
        {
            item = Campaign.Data.GameMode;
            num = Campaign.Data.Seed;
        }
        else
        {
            item = AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal");
            num = SaveSystem.LoadProgressData("nextSeed", -1);
            if (num == -1)
            {
                num = Random.Seed();
                SaveSystem.SaveProgressData("nextSeed", num);
            }
        }
        return (item, num);
    }

    public IEnumerator CreateCard(CardData cardData, CardContainer cardHolder, bool startFlipped)
    {
        Card card = CardManager.Get(cardData, cardController, null, inPlay: false, isPlayerCard: false);
        _ = card.transform;
        if (startFlipped)
        {
            card.entity.flipper.FlipDownInstant();
        }
        cardHolder.Add(card.entity);
        cardHolder.SetChildPositions();
        yield return card.UpdateData();
        if (startFlipped)
        {
            card.entity.flipper.FlipUp(force: true);
        }
    }

    public void End()
    {
        CardContainer[] array = cardHolders;
        foreach (CardContainer obj in array)
        {
            obj.DestroyAll();
            obj.Clear();
        }
        leaderCardHolder.DestroyAll();
        leaderCardHolder.Clear();
        gameObject.SetActive(false);
        if (unloadSceneOnEnd)
        {
            new Routine(SceneManager.Unload("NewFrostGuardian"));
        }
    }
}
public class IcebreakerHutSequence : BuildingSequence
{
    [SerializeField]
    public string metaprogressionKey = "events";

    [SerializeField]
    public ImageSprite[] nodes;

    [SerializeField]
    public ButtonAnimator[] buttons;

    [SerializeField]
    public ChallengeData[] challenges;

    [SerializeField]
    public ChallengeDisplayCreator challengeDisplayCreator;

    [SerializeField]
    public string firstGreetKey = "icebreakerFirstGreet";

    [SerializeField]
    public MapInspectSequence mapInspectSequence;

    [SerializeField]
    public EventReference denySfx;

    public readonly List<bool> unlocked = new List<bool>();

    public override IEnumerator Sequence()
    {
        if (building.HasUncheckedUnlocks)
        {
            foreach (string uncheckedUnlock in building.uncheckedUnlocks)
            {
                Unlock(uncheckedUnlock);
            }
            building.uncheckedUnlocks.Clear();
            TalkerSay("new event", 0.5f);
        }
        else if (!StringExt.IsNullOrEmpty(firstGreetKey) && !SaveSystem.LoadProgressData(firstGreetKey, defaultValue: false))
        {
            TalkerFirstGreet();
            SaveSystem.SaveProgressData(firstGreetKey, value: true);
        }
        else
        {
            TalkerGreet();
        }
        int num = building.checkedUnlocks?.Count ?? 0;
        SetUpMapNodes(num);
        SetCurrentChallenge(num);
        yield return null;
    }

    public void Unlock(string unlockDataName)
    {
        List<string> list = SaveSystem.LoadProgressData<List<string>>(base.building.type.unlockedCheckedKey, null);
        if (list == null)
        {
            list = new List<string>();
        }
        list.Add(unlockDataName);
        SaveSystem.SaveProgressData(base.building.type.unlockedCheckedKey, list);
        Building building = base.building;
        if (building.unlocks == null)
        {
            building.unlocks = new List<string>();
        }
        base.building.unlocks.Add(unlockDataName);
    }

    public void SetUpMapNodes(int unlocked)
    {
        List<string> list = MetaprogressionSystem.Get<List<string>>(metaprogressionKey);
        for (int i = 0; i < list.Count; i++)
        {
            this.unlocked.Add(i < unlocked);
        }
        for (int j = 0; j < unlocked && j < list.Count; j++)
        {
            string assetName = list[j];
            CampaignNodeType campaignNodeType = AddressableLoader.Get<CampaignNodeType>("CampaignNodeType", assetName);
            nodes[j].SetSprite(campaignNodeType.mapNodeSprite);
            buttons[j].interactable = true;
        }
    }

    public void SetCurrentChallenge(int unlocked)
    {
        if (unlocked < challenges.Length)
        {
            challengeDisplayCreator.challenge = challenges[unlocked];
            challengeDisplayCreator.Check();
        }
    }

    public void TryInspect(int mapNodeIndex)
    {
        if (unlocked[mapNodeIndex])
        {
            mapInspectSequence.Inspect(mapNodeIndex);
        }
        else
        {
            Deny(((Component)nodes[mapNodeIndex]).gameObject);
        }
    }

    public void Deny(GameObject obj)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        SfxSystem.OneShot(denySfx);
        LeanTween.cancel(obj);
        LeanTween.moveLocal(obj, Vector3.zero, 0.67f).setFrom(new Vector3(FloatExt.WithRandomSign(0.5f, 0.5f), 0f, 0f)).setEaseOutElastic();
    }
}
public class InventorHutSequence : BuildingSequenceWithUnlocks<InventorHutSequence>
{
    [SerializeField]
    public CardController controller;

    [SerializeField]
    public CardUnlockSequence cardUnlockSequence;

    [SerializeField]
    public string firstGreetKey = "inventorFirstGreet";

    public void Start()
    {
        _OnStart();
    }

    public override IEnumerator Sequence()
    {
        int num = Mathf.Min(locks.Length, building.type.unlocks.Length);
        for (int i = 0; i < num; i++)
        {
            if (building.type.unlocks[i].IsActive)
            {
                locks[i].SetActive(false);
            }
        }
        yield return CreateCards();
        if (building.HasUncheckedUnlocks)
        {
            foreach (string uncheckedUnlock in building.uncheckedUnlocks)
            {
                yield return Unlock(uncheckedUnlock);
            }
            Entity entity = cardSlots.LastOrDefault((CardContainer a) => !a.Empty)?.GetTop();
            if ((entity))
            {
                TalkerNewCard(entity.data);
            }
        }
        else if (!StringExt.IsNullOrEmpty(firstGreetKey) && !SaveSystem.LoadProgressData(firstGreetKey, defaultValue: false))
        {
            TalkerFirstGreet();
            SaveSystem.SaveProgressData(firstGreetKey, value: true);
        }
        else
        {
            TalkerGreet();
        }
        UnityEvent obj = onSetUpComplete;
        if (obj != null)
        {
            obj.Invoke();
        }
    }

    public IEnumerator Unlock(string unlockDataName)
    {
        int num = building.type.unlocks.Select((UnlockData a) => (a).name).ToList().IndexOf(unlockDataName);
        if (num < 0)
        {
            throw new IndexOutOfRangeException("[" + unlockDataName + "] does not exist in [" + (building).name + "] unlocks list!");
        }
        string assetName = MetaprogressionSystem.Get<List<string>>("items")[num];
        List<string> list = SaveSystem.LoadProgressData(building.type.unlockedCheckedKey, new List<string>());
        list.Add(unlockDataName);
        SaveSystem.SaveProgressData(building.type.unlockedCheckedKey, list);
        CardData data = AddressableLoader.Get<CardData>("CardData", assetName);
        Card card = CardManager.Get(data, controller, null, inPlay: false, isPlayerCard: true);
        yield return card.UpdateData();
        CardContainer finalSlot = cardSlots.FirstOrDefault((CardContainer a) => a.Empty);
        yield return cardUnlockSequence.Run(card.entity, finalSlot);
        if ((finalSlot))
        {
            Image component = ((Component)finalSlot).GetComponent<Image>();
            if (component != null)
            {
                ((Behaviour)component).enabled = true;
            }
        }
    }

    public IEnumerator CreateCards()
    {
        List<Entity> cards = new List<Entity>();
        Routine.Clump clump = new Routine.Clump();
        int num = building.checkedUnlocks?.Count ?? 0;
        List<string> list = MetaprogressionSystem.Get<List<string>>("items");
        for (int i = 0; i < num && i < list.Count; i++)
        {
            string assetName = list[i];
            Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", assetName), controller, null, inPlay: false, isPlayerCard: true);
            cards.Add(card.entity);
            clump.Add(card.UpdateData());
        }
        yield return clump.WaitForEnd();
        foreach (Entity item in cards)
        {
            CardContainer cardContainer = cardSlots.FirstOrDefault((CardContainer a) => a.Empty);
            if (cardContainer != null)
            {
                item.flipper.FlipUpInstant();
                ((Behaviour)item).enabled = true;
                cardContainer.Add(item);
                cardContainer.SetChildPositions();
                Image component = ((Component)cardContainer).GetComponent<Image>();
                if (component != null)
                {
                    ((Behaviour)component).enabled = false;
                }
                continue;
            }
            break;
        }
    }
}
public class PetHutSequence : BuildingSequenceWithUnlocks<PetHutSequence>
{
    [SerializeField]
    public Transform rowLayout;

    [SerializeField]
    public Transform rowPrefab;

    [SerializeField]
    public int cardsPerRow = 4;

    [SerializeField]
    public CardContainer slotPrefab;

    [SerializeField]
    public ChallengeDisplayCreator challengeDisplayPrefab;

    [SerializeField]
    public ChallengeData[] challenges;

    [SerializeField]
    public Transform challengeDisplayParent;

    [SerializeField]
    public CardController controller;

    [SerializeField]
    public CardUnlockSequence cardUnlockSequence;

    [SerializeField]
    public string firstGreetKey = "petHutFirstGreet";

    public Entity lastUnlockedCard;

    public void Start()
    {
        _OnStart();
        cardSlots = cardSlots.RemoveFromArray(delegate (CardContainer container)
        {
            ChallengeDisplayCreator componentInChildren = ((Component)((Component)container).transform.parent).gameObject.GetComponentInChildren<ChallengeDisplayCreator>();
            if (!(componentInChildren))
            {
                return true;
            }
            if (!(componentInChildren.challenge))
            {
                Object.Destroy(((Component)((Component)container).transform.parent).gameObject);
                return false;
            }
            return true;
        });
    }

    public override IEnumerator Sequence()
    {
        yield return CreateCards();
        for (int i = 0; i < cardSlots.Length; i++)
        {
            CardContainer cardContainer = cardSlots[i];
            Transform val = ((Component)cardContainer).transform.Find("Lock");
            if (val != null && (i == 0 || i >= building.type.unlocks.Length || !(building.type.unlocks[i]) || building.type.unlocks[i].IsActive))
            {
                ((Component)val).gameObject.SetActive(false);
            }
            if (challenges.Length > i)
            {
                ChallengeData challengeData = challenges[i];
                if (challengeData != null)
                {
                    ChallengeDisplayCreator challengeDisplayCreator = Object.Instantiate<ChallengeDisplayCreator>(challengeDisplayPrefab, challengeDisplayParent);
                    ((Component)challengeDisplayCreator).transform.position = ((Component)cardContainer).transform.position;
                    challengeDisplayCreator.challenge = challengeData;
                    challengeDisplayCreator.Check();
                }
            }
        }
        if (building.HasUncheckedUnlocks)
        {
            foreach (string uncheckedUnlock in building.uncheckedUnlocks)
            {
                yield return Unlock(uncheckedUnlock);
            }
            if ((lastUnlockedCard))
            {
                TalkerNewCard(lastUnlockedCard.data);
            }
        }
        else if (!StringExt.IsNullOrEmpty(firstGreetKey) && !SaveSystem.LoadProgressData(firstGreetKey, defaultValue: false))
        {
            TalkerFirstGreet();
            SaveSystem.SaveProgressData(firstGreetKey, value: true);
        }
        else
        {
            TalkerGreet();
        }
        UnityEvent obj = onSetUpComplete;
        if (obj != null)
        {
            obj.Invoke();
        }
    }

    public IEnumerator Unlock(string unlockDataName)
    {
        int num = 1 + building.type.unlocks.Select((UnlockData a) => (a).name).ToList().IndexOf(unlockDataName);
        if (num < 0)
        {
            throw new IndexOutOfRangeException("[" + unlockDataName + "] does not exist in [" + (building).name + "] unlocks list!");
        }
        string assetName = MetaprogressionSystem.GetAllPets()[num];
        List<string> list = SaveSystem.LoadProgressData(building.type.unlockedCheckedKey, new List<string>());
        list.Add(unlockDataName);
        SaveSystem.SaveProgressData(building.type.unlockedCheckedKey, list);
        CardData data = AddressableLoader.Get<CardData>("CardData", assetName);
        Card card = CardManager.Get(data, controller, null, inPlay: false, isPlayerCard: true);
        yield return card.UpdateData();
        lastUnlockedCard = card.entity;
        CardContainer finalSlot = cardSlots.FirstOrDefault((CardContainer a) => a.Empty);
        yield return cardUnlockSequence.Run(card.entity, finalSlot);
        if ((finalSlot))
        {
            Image component = ((Component)finalSlot).GetComponent<Image>();
            if (component != null)
            {
                ((Behaviour)component).enabled = true;
            }
        }
    }

    public IEnumerator CreateCards()
    {
        List<Entity> cards = new List<Entity>();
        Routine.Clump clump = new Routine.Clump();
        Dictionary<string, string> petDict = MetaprogressionSystem.GetPetDict();
        List<string> checkedUnlocks = building.checkedUnlocks;
        foreach (var (assetName, text3) in petDict)
        {
            if (text3 == null || (checkedUnlocks != null && checkedUnlocks.Contains(text3)))
            {
                Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", assetName), controller, null, inPlay: false, isPlayerCard: true);
                cards.Add(card.entity);
                clump.Add(card.UpdateData());
            }
            else
            {
                cards.Add(null);
            }
        }
        yield return clump.WaitForEnd();
        Transform parent = CreateRow();
        int num = 0;
        for (int i = 0; i < cards.Count; i++)
        {
            CardContainer cardContainer = CreateSlot(parent);
            cardSlots = CollectionExtensions.AddToArray<CardContainer>(cardSlots, cardContainer);
            if (++num >= cardsPerRow)
            {
                parent = CreateRow();
                num = 0;
            }
        }
        yield return null;
        for (int j = 0; j < cards.Count; j++)
        {
            Entity entity = cards[j];
            if ((entity))
            {
                CardContainer obj = cardSlots[j];
                entity.flipper.FlipUpInstant();
                ((Behaviour)entity).enabled = true;
                obj.Add(entity);
                obj.SetChildPositions();
                Image component = ((Component)obj).GetComponent<Image>();
                if (component != null)
                {
                    ((Behaviour)component).enabled = false;
                }
            }
        }
    }

    public CardContainer CreateSlot(Transform parent)
    {
        return Object.Instantiate<CardContainer>(slotPrefab, parent);
    }

    public Transform CreateRow()
    {
        Transform val = Object.Instantiate<Transform>(rowPrefab, rowLayout);
        val.SetSiblingIndex(Mathf.Max(0, val.parent.childCount - 2));
        return val;
    }
}
public class TribeHutSequence : BuildingSequence
{
    [SerializeField]
    public TribeFlagDisplay[] flags;

    public GameMode _gameMode;

    public GameMode gameMode => _gameMode ?? (_gameMode = AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal"));

    public override IEnumerator Sequence()
    {
        SetupFlags();
        yield return null;
    }

    public void SetupFlags()
    {
        int valueOrDefault = (1 + building.checkedUnlocks?.Count).GetValueOrDefault();
        int num = gameMode.classes.Length;
        for (int i = 0; i < flags.Length; i++)
        {
            if (i < num)
            {
                flags[i].SetAvailable();
                if (i < valueOrDefault)
                {
                    flags[i].SetUnlocked();
                }
            }
        }
    }
}
public class Building : MonoBehaviour
{
    [Serializable]
    public class Icon
    {
        public string name;

        public GameObject obj;
    }

    public BuildingType type;

    public bool canSelect = true;

    [SerializeField]
    public UnityEventGameObject onSelect;

    [SerializeField]
    public GameObject toBuild;

    [SerializeField]
    public GameObject underConstruction;

    [SerializeField]
    public GameObject fullyBuilt;

    [SerializeField]
    public Icon[] icons;

    [SerializeField]
    public UnityEvent onDataUpdated;

    public bool buildStarted;

    public bool built;

    public List<string> unlocks;

    public List<string> uncheckedUnlocks;

    public GameObject currentActiveIcon;

    public List<string> checkedUnlocks
    {
        get
        {
            if (unlocks == null)
            {
                return null;
            }
            if (uncheckedUnlocks == null)
            {
                return unlocks;
            }
            return unlocks.Except(uncheckedUnlocks).ToList();
        }
    }

    public bool HasUncheckedUnlocks
    {
        get
        {
            List<string> list = uncheckedUnlocks;
            if (list != null)
            {
                return list.Count > 0;
            }
            return false;
        }
    }

    public void CheckIfUnlocked()
    {
        List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
        buildStarted = type.started == null || MetaprogressionSystem.IsUnlocked(type.started, unlockedList);
        built = type.finished == null || MetaprogressionSystem.IsUnlocked(type.finished, unlockedList);
        if (!built && !buildStarted)
        {
            gameObject.SetActive(false);
            return;
        }
        gameObject.SetActive(true);
        RunUpdateEvent();
    }

    public void RunUpdateEvent()
    {
        UnityEvent obj = onDataUpdated;
        if (obj != null)
        {
            obj.Invoke();
        }
        if (built && type.unlocks != null && type.unlocks.Length != 0)
        {
            List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
            unlocks = type.unlocks.Select((UnlockData a) => (a).name).Intersect(unlockedList).ToList();
            if (unlocks.Count > 0 && !StringExt.IsNullOrWhitespace(type.unlockedCheckedKey))
            {
                List<string> list = SaveSystem.LoadProgressData<List<string>>(type.unlockedCheckedKey);
                uncheckedUnlocks = ((list == null) ? new List<string>(unlocks) : unlocks.Except(list).ToList());
                Debug.Log(string.Format("[{0}] has unchecked {1} unlocks [{2}]", name, uncheckedUnlocks.Count, string.Join(", ", uncheckedUnlocks)));
            }
        }
        UpdateSprite();
        SetSuitableIcon();
    }

    public bool Select()
    {
        try
        {
            if (canSelect && onSelect != null)
            {
                UnityEventGameObject unityEventGameObject = onSelect;
                Object persistentTarget = ((UnityEventBase)onSelect).GetPersistentTarget(0);
                ((UnityEvent<GameObject>)unityEventGameObject).Invoke((GameObject)(object)((persistentTarget is GameObject) ? persistentTarget : null));
                return true;
            }
        }
        catch (ArgumentOutOfRangeException)
        {
            return false;
        }
        return false;
    }

    public void UpdateSprite()
    {
        if ((toBuild))
        {
            toBuild.gameObject.SetActive(!buildStarted && !built);
        }
        if ((underConstruction))
        {
            underConstruction.gameObject.SetActive(buildStarted && !built);
        }
        if ((fullyBuilt))
        {
            fullyBuilt.gameObject.SetActive(built);
        }
    }

    public void SetSuitableIcon()
    {
        string icon = "";
        BuildingIconSetter[] components = GetComponents<BuildingIconSetter>();
        for (int i = 0; i < components.Length; i++)
        {
            icon = components[i].Get(this);
        }
        SetIcon(icon);
    }

    public void SetIcon(string name)
    {
        if ((currentActiveIcon))
        {
            currentActiveIcon.SetActive(false);
        }
        if (!StringExt.IsNullOrWhitespace(name))
        {
            Icon icon = icons.FirstOrDefault((Icon a) => a.name == name);
            if (icon != null)
            {
                currentActiveIcon = icon.obj;
                currentActiveIcon.SetActive(true);
            }
        }
    }

    public void Bloop()
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        transform.localScale = new Vector3(1.5f, 2f / 3f, 1f);
        LeanTween.cancel(gameObject);
        LeanTween.scale(gameObject, Vector3.one, 1.5f).setEase(LeanTweenType.easeOutElastic);
    }

    public void CreateDisplay(GameObject prefab)
    {
        Object.FindObjectOfType<BuildingDisplay>(true)?.Create(prefab, this);
    }
}
[RequireComponent(typeof(Building))]
public class BuildingBalloon : MonoBehaviour
{
    [SerializeField]
    public string gameModeName = "GameModeDaily";

    [SerializeField]
    public GameObject displayPrefab;

    public Building _building;

    public Building building => _building ?? (_building = GetComponent<Building>());

    public void Select()
    {
        GameMode gameMode = AddressableLoader.Get<GameMode>("GameMode", gameModeName);
        if (Campaign.CheckContinue(gameMode))
        {
            Campaign.Data = CampaignData.Load(gameMode);
            DailyFetcher.SetContinueDateTime();
            StartCoroutine(ContinueRoutine());
        }
        else
        {
            building.CreateDisplay(displayPrefab);
        }
    }

    public static IEnumerator ContinueRoutine()
    {
        yield return SceneManager.Load("ContinueRun", SceneType.Temporary);
        yield return SceneManager.WaitUntilUnloaded("ContinueRun");
    }
}
public class BuildingDisplay : MonoBehaviour
{
    [SerializeField]
    public UnityEvent onEnable;

    [SerializeField]
    public UnityEvent onDisable;

    [SerializeField]
    public int setSiblingIndex = 1;

    [SerializeField]
    public HelpPanelShower helpShower;

    public GameObject current;

    public void Create(GameObject prefab, Building building)
    {
        gameObject.SetActive(true);
        current = Object.Instantiate<GameObject>(prefab, transform);
        current.transform.SetSiblingIndex(setSiblingIndex);
        current.GetComponent<BuildingSequence>()?.Play(building);
        onEnable.Invoke();
        SetHelp(building.type);
    }

    public void SetHelp(BuildingType buildingType)
    {
        if (((LocalizedReference)buildingType.helpKey).IsEmpty)
        {
            ((Component)helpShower).gameObject.SetActive(false);
            return;
        }
        ((Component)helpShower).gameObject.SetActive(true);
        helpShower.SetKey(buildingType.helpKey, buildingType.helpEmoteType);
    }

    public void End()
    {
        current.GetComponent<BuildingSequence>()?.building?.RunUpdateEvent();
        GameObjectExt.Destroy(current);
        current = null;
        gameObject.SetActive(false);
        onDisable.Invoke();
    }
}
public abstract class BuildingIconSetter : MonoBehaviour
{
    public virtual string Get(Building building)
    {
        return "";
    }

    public BuildingIconSetter()
    {
    }
}
public class BuildingIconSetterDaily : BuildingIconSetter
{
    [SerializeField]
    public string gameModeName = "GameModeDaily";

    public GameMode _gameMode;

    public GameMode gameMode => _gameMode ?? (_gameMode = AddressableLoader.Get<GameMode>("GameMode", gameModeName));

    public override string Get(Building building)
    {
        string result = "";
        if (DailyFetcher.CanPlay())
        {
            result = "Unlock";
        }
        else if (Campaign.CheckContinue(gameMode))
        {
            result = "Unlock";
        }
        return result;
    }
}
public class BuildingIconSetterUnlocks : BuildingIconSetter
{
    public override string Get(Building building)
    {
        if (building.built)
        {
            if (!building.HasUncheckedUnlocks)
            {
                return "";
            }
            return "Unlock";
        }
        return "";
    }
}
[RequireComponent(typeof(Building))]
public class BuildingInteraction : MonoBehaviour
{
    [SerializeField]
    public GameObject[] outlines;

    public Building _building;

    public bool hover;

    public Building building => _building ?? (_building = GetComponent<Building>());

    public void Hover()
    {
        if (!hover)
        {
            Debug.Log(("[" + name + " Hover]"));
            hover = true;
            GameObject[] array = outlines;
            for (int i = 0; i < array.Length; i++)
            {
                array[i].SetActive(true);
            }
            HoverTween();
            building.SetIcon("Select");
            Events.InvokeButtonHover(ButtonType.Building);
        }
    }

    public void UnHover()
    {
        if (hover)
        {
            hover = false;
            Debug.Log(("[" + name + " UnHover]"));
            GameObject[] array = outlines;
            for (int i = 0; i < array.Length; i++)
            {
                array[i].SetActive(false);
            }
            UnHoverTween();
            building.SetSuitableIcon();
        }
    }

    public void Select(BaseEventData eventData)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        PointerEventData val = (PointerEventData)(object)((eventData is PointerEventData) ? eventData : null);
        if (val == null || (int)val.button == 0)
        {
            Town.SelectBuilding(building);
            Events.InvokeButtonPress(ButtonType.Building);
        }
    }

    public void HoverTween()
    {
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(gameObject);
        transform.localScale = new Vector3(0.99502486f, 0.99502486f, 1f);
        LeanTween.scale(gameObject, new Vector3(1.005f, 1.005f, 1f), 1.2f).setEaseOutElastic();
    }

    public void UnHoverTween()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(gameObject);
        LeanTween.scale(gameObject, Vector3.one, 0.1f).setEaseOutQuart();
    }
}
public class BuildingPlot : MonoBehaviour
{
    [SerializeField]
    public string sortingLayerName;

    [SerializeField]
    public int sortingOrder;

    public void Start()
    {
        Building componentInChildren = GetComponentInChildren<Building>(true);
        if (componentInChildren != null)
        {
            SpriteRenderer[] componentsInChildren = ((Component)componentInChildren).GetComponentsInChildren<SpriteRenderer>(true);
            foreach (SpriteRenderer obj in componentsInChildren)
            {
                ((Renderer)obj).sortingLayerName = sortingLayerName;
                ((Renderer)obj).sortingOrder = ((Renderer)obj).sortingOrder + sortingOrder;
            }
        }
        Image component = GetComponent<Image>();
        if (component != null)
        {
            ((Behaviour)component).enabled = false;
        }
    }
}
public class PetHutFlagSetter : MonoBehaviour
{
    [SerializeField]
    public SpriteRenderer flag;

    [SerializeField]
    public Sprite[] flagSprites;

    public void SetupFlag()
    {
        int num = Mathf.Clamp(SaveSystem.LoadProgressData("selectedPet", 0), 0, flagSprites.Length - 1);
        flag.sprite = flagSprites[num];
    }
}
public class Town : MonoBehaviourSingleton<Town>
{
    [SerializeField]
    public HelpPanelShower tutorialPrompt;

    [SerializeField]
    public EventReference denySfxEvent;

    public override void Awake()
    {
        base.Awake();
        CheckStartConstruction();
    }

    public IEnumerator Start()
    {
        Building[] array = Object.FindObjectsOfType<Building>(true);
        for (int i = 0; i < array.Length; i++)
        {
            array[i].CheckIfUnlocked();
        }
        if ((CardFramesSystem.instance) && CardFramesSystem.instance.AnyNewFrames())
        {
            yield return CardFramesSystem.instance.DisplayNewFrames();
        }
        if (NewFinalBossChecker.Check())
        {
            yield return NewFinalBossChecker.Run();
        }
        if (MetaprogressionSystem.AnyUnlocksReady())
        {
            yield return SceneManager.Load("TownUnlocks", SceneType.Temporary);
            yield return SceneManager.WaitUntilUnloaded("TownUnlocks");
        }
        CheckTutorialPrompt();
    }

    public static void SelectBuilding(Building building)
    {
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        if (building.built)
        {
            if (!building.Select())
            {
                Events.InvokeCameraAnimation("Shake");
                SfxSystem.OneShot(MonoBehaviourSingleton<Town>.instance.denySfxEvent);
            }
        }
        else
        {
            Events.InvokeCameraAnimation("Shake");
            SfxSystem.OneShot(MonoBehaviourSingleton<Town>.instance.denySfxEvent);
        }
    }

    public static void CheckStartConstruction()
    {
        List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
        List<string> list = MetaprogressionSystem.Get<List<string>>("buildings");
        List<UnlockData> list2 = new List<UnlockData>();
        foreach (string item in list)
        {
            if (!unlockedList.Contains(item))
            {
                UnlockData unlockData = AddressableLoader.Get<UnlockData>("UnlockData", item);
                IListExt.AddIfNotNull<UnlockData>((IList<UnlockData>)list2, unlockData);
            }
        }
        UnlockData unlockData2 = null;
        foreach (UnlockData item2 in list2)
        {
            if (item2.IsActive && MetaprogressionSystem.CheckUnlockRequirements(item2, unlockedList))
            {
                unlockData2 = item2;
                break;
            }
        }
        if ((unlockData2))
        {
            unlockedList.Add((unlockData2).name);
            SaveSystem.SaveProgressData("unlocked", unlockedList);
            MetaprogressionSystem.SetUnlocksReady((unlockData2).name);
        }
    }

    public void CheckTutorialPrompt()
    {
        if (!SaveSystem.LoadProgressData("tutorialTownDone", defaultValue: false))
        {
            tutorialPrompt.Show();
            SaveSystem.SaveProgressData("tutorialTownDone", value: true);
        }
    }
}
[RequireComponent(typeof(Building))]
public class TownHallFlagSetter : MonoBehaviour
{
    [SerializeField]
    public GameObject[] flags;

    public void SetupFlags()
    {
        GameMode gameMode = AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal");
        List<ClassData> lockedClasses = MetaprogressionSystem.GetLockedClasses();
        for (int i = 0; i < gameMode.classes.Length; i++)
        {
            ClassData item = gameMode.classes[i];
            bool active = !lockedClasses.Contains(item);
            if (flags.Length > i)
            {
                flags[i].SetActive(active);
            }
        }
    }
}
public class UnlockFrostoscope : MonoBehaviour
{
    public void Check(GameObject gameObject)
    {
        Building component = gameObject.GetComponent<Building>();
        if (component != null)
        {
            Check(component);
        }
    }

    public void Check(Building building)
    {
        List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
        UnlockData finished = building.type.finished;
        if (!MetaprogressionSystem.IsUnlocked(finished, unlockedList) && SaveSystem.LoadProgressData<CardSaveData[]>("finalBossDeck") != null)
        {
            unlockedList.Add((finished).name);
            SaveSystem.SaveProgressData("unlocked", unlockedList);
            MetaprogressionSystem.SetUnlocksReady((finished).name);
            building.CheckIfUnlocked();
        }
    }
}
public class UnlockReadyIcon : MonoBehaviour
{
    public void OnEnable()
    {
        Check();
    }

    public void Check()
    {
        Set(MetaprogressionSystem.AnyUnlocksReady());
    }

    public void Set(bool unlocksReady)
    {
        gameObject.SetActive(unlocksReady);
    }
}
public class EndTransition : MonoBehaviour
{
    [SerializeField]
    public bool destroyObject;

    public IEnumerator Start()
    {
        yield return (object)new WaitUntil((Func<bool>)(() => SceneManager.HasNoActiveJobs));
        Transition.End();
        if (destroyObject)
        {
            Object.Destroy(gameObject);
        }
        else
        {
            Object.Destroy(this);
        }
    }
}
public class StartTransition : MonoBehaviour
{
    public void GoTo(string sceneName)
    {
        if (enabled)
        {
            new Routine(Transition.To(sceneName));
            enabled = false;
        }
    }
}
public class Transition : MonoBehaviourSingleton<Transition>
{
    public static TransitionType current;

    [SerializeField]
    public TransitionType[] transitions;

    public static bool Running;

    public TransitionType prefab;

    public void OnEnable()
    {
        Events.OnSettingChanged += SettingChanged;
    }

    public void OnDisable()
    {
        Events.OnSettingChanged -= SettingChanged;
    }

    public void SettingChanged(string key, object value)
    {
        if (!(key != "TransitionType") && value is int transitionType)
        {
            SetTransitionType(transitionType);
        }
    }

    public void SetTransitionType(int index)
    {
        prefab = transitions[Mathf.Clamp(index, 0, transitions.Length - 1)];
    }

    public static TransitionType Begin()
    {
        if ((current))
        {
            if (Running)
            {
                return current;
            }
            Object.Destroy(((Component)current).gameObject);
        }
        if (!(MonoBehaviourSingleton<Transition>.instance.prefab))
        {
            MonoBehaviourSingleton<Transition>.instance.SetTransitionType(Settings.Load("TransitionType", 0));
        }
        current = Object.Instantiate<TransitionType>(MonoBehaviourSingleton<Transition>.instance.prefab, ((Component)MonoBehaviourSingleton<Transition>.instance).transform);
        ((MonoBehaviour)MonoBehaviourSingleton<Transition>.instance).StopAllCoroutines();
        ((MonoBehaviour)MonoBehaviourSingleton<Transition>.instance).StartCoroutine(current.In());
        Events.InvokeTransitionStart(current);
        Running = true;
        return current;
    }

    public static void End()
    {
        if ((current))
        {
            ((MonoBehaviour)MonoBehaviourSingleton<Transition>.instance).StopAllCoroutines();
            ((MonoBehaviour)MonoBehaviourSingleton<Transition>.instance).StartCoroutine(current.Out());
            Events.InvokeTransitionEnd(current);
            Running = false;
        }
    }

    public static IEnumerator WaitUntilDone(TransitionType transition)
    {
        if (transition == null)
        {
            transition = current;
        }
        yield return (object)new WaitUntil((Func<bool>)(() => !(transition) || !transition.IsRunning));
    }

    public static IEnumerator To(string newSceneKey)
    {
        TransitionType transition = Begin();
        yield return WaitUntilDone(transition);
        yield return Sequences.SceneChange(newSceneKey);
    }
}
public class TransitionClose : TransitionType
{
    [SerializeField]
    public Transform rotator;

    [SerializeField]
    public GameObject borderTop;

    [SerializeField]
    public GameObject borderBottom;

    [SerializeField]
    public CanvasGroup fade;

    [SerializeField]
    public Vector2 angleRange = new Vector2(0f, 40f);

    [Header("Tweens")]
    [SerializeField]
    public LeanTweenType easeIn = LeanTweenType.easeOutBounce;

    [SerializeField]
    public float easeInDur = 0.8f;

    [SerializeField]
    public LeanTweenType easeOut = LeanTweenType.easeInQuart;

    [SerializeField]
    public float easeOutDur = 0.5f;

    public Vector3 borderTopStartPos;

    public Vector3 borderBottomStartPos;

    public void Start()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        borderTopStartPos = borderTop.transform.localPosition;
        borderBottomStartPos = borderBottom.transform.localPosition;
    }

    public override IEnumerator In()
    {
        base.IsRunning = true;
        fade.blocksRaycasts = true;
        fade.alpha = 0.01f;
        TransformExt.SetLocalRotationZ(rotator, FloatExt.WithRandomSign(Vector2Ext.PettyRandom(angleRange), 0.5f));
        LeanTween.moveLocal(borderTop, Vector3.zero, easeInDur).setEase(easeIn);
        LeanTween.moveLocal(borderBottom, Vector3.zero, easeInDur).setEase(easeIn);
        yield return (object)new WaitForSeconds(easeInDur);
        base.IsRunning = false;
    }

    public override IEnumerator Out()
    {
        base.IsRunning = true;
        fade.blocksRaycasts = false;
        fade.alpha = 0f;
        LeanTween.moveLocal(borderTop, borderTopStartPos, easeOutDur).setEase(easeOut);
        LeanTween.moveLocal(borderBottom, borderBottomStartPos, easeOutDur).setEase(easeOut);
        yield return (object)new WaitForSeconds(easeOutDur);
        base.IsRunning = false;
        GameObjectExt.Destroy(gameObject);
    }
}
public class TransitionFade : TransitionType
{
    public CanvasGroup fade;

    [Header("Tweens")]
    public LeanTweenType easeIn = LeanTweenType.easeInQuint;

    public float easeInDur = 0.5f;

    public LeanTweenType easeOut = LeanTweenType.easeOutQuint;

    public float easeOutDur = 0.5f;

    public override IEnumerator In()
    {
        base.IsRunning = true;
        fade.blocksRaycasts = true;
        fade.LeanAlpha(1f, easeInDur).setEase(easeIn);
        yield return (object)new WaitForSeconds(easeInDur);
        base.IsRunning = false;
    }

    public override IEnumerator Out()
    {
        base.IsRunning = true;
        fade.blocksRaycasts = false;
        fade.LeanAlpha(0f, easeOutDur).setEase(easeOut);
        yield return (object)new WaitForSeconds(easeOutDur);
        base.IsRunning = false;
        GameObjectExt.Destroy(gameObject);
    }
}
public class TransitionSnow : TransitionType
{
    [SerializeField]
    public ParticleSystem inParticles;

    [SerializeField]
    public ParticleSystem outParticles;

    [Header("Fade Image")]
    [SerializeField]
    public CanvasGroup fade;

    [Header("Tweens")]
    [SerializeField]
    public LeanTweenType easeIn = LeanTweenType.easeInCubic;

    [SerializeField]
    public float easeInDur = 0.6f;

    [SerializeField]
    public LeanTweenType easeOut = LeanTweenType.easeOutCubic;

    [SerializeField]
    public float easeOutDur = 0.1f;

    [Button(/*Could not decode attribute arguments.*/)]
    public void SnowIn()
    {
        if (!base.IsRunning)
        {
            StopAllCoroutines();
            StartCoroutine(In());
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void SnowOut()
    {
        if (!base.IsRunning)
        {
            StopAllCoroutines();
            StartCoroutine(Out());
        }
    }

    public override IEnumerator In()
    {
        inParticles.Play();
        base.IsRunning = true;
        fade.blocksRaycasts = true;
        fade.LeanAlpha(1f, easeInDur).setEase(easeIn);
        yield return (object)new WaitForSeconds(easeInDur);
        base.IsRunning = false;
    }

    public override IEnumerator Out()
    {
        outParticles.Play();
        base.IsRunning = true;
        fade.blocksRaycasts = false;
        fade.LeanAlpha(0f, easeOutDur).setEase(easeOut);
        yield return (object)new WaitForSeconds(easeOutDur);
        base.IsRunning = false;
        yield return (object)new WaitUntil((Func<bool>)(() => !outParticles.isPlaying));
        GameObjectExt.Destroy(gameObject);
    }
}
public abstract class TransitionType : MonoBehaviour
{
    public bool IsRunning { get; set; }

    public virtual IEnumerator In()
    {
        return null;
    }

    public virtual IEnumerator Out()
    {
        return null;
    }

    public TransitionType()
    {
    }
}
public class TweenUI : MonoBehaviour
{
    public enum Property
    {
        Move,
        Rotate,
        Scale
    }

    [Serializable]
    public struct Tween
    {
        public Property property;

        public LeanTweenType ease;

        public AnimationCurve curve;

        public bool randomSigns;

        [Header("Duration")]
        public float duration;

        [Header("Delay")]
        public float delay;

        [Header("Values")]
        public Vector3 to;

        public bool hasFrom;

        public Vector3 from;

        public void Fire(GameObject target, bool ignoreTimeScale)
        {
            //IL_003b: Unknown result type (might be due to invalid IL or missing references)
            //IL_002f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0069: Unknown result type (might be due to invalid IL or missing references)
            //IL_005d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0097: Unknown result type (might be due to invalid IL or missing references)
            //IL_008b: Unknown result type (might be due to invalid IL or missing references)
            LTDescr lTDescr = null;
            switch (property)
            {
                case Property.Move:
                    if (hasFrom)
                    {
                        target.transform.localPosition = GetFrom();
                    }
                    lTDescr = LeanTween.moveLocal(target, to, duration);
                    break;
                case Property.Rotate:
                    if (hasFrom)
                    {
                        target.transform.localEulerAngles = GetFrom();
                    }
                    lTDescr = LeanTween.rotateLocal(target, to, duration);
                    break;
                case Property.Scale:
                    if (hasFrom)
                    {
                        target.transform.localScale = GetFrom();
                    }
                    lTDescr = LeanTween.scale(target, to, duration);
                    break;
            }
            if (ignoreTimeScale)
            {
                lTDescr.setIgnoreTimeScale(useUnScaledTime: true);
            }
            if (delay > 0f)
            {
                lTDescr?.setDelay(delay);
            }
            if (ease == LeanTweenType.animationCurve)
            {
                lTDescr?.setEase(curve);
            }
            else
            {
                lTDescr?.setEase(ease);
            }
        }

        public Vector3 GetFrom()
        {
            //IL_0010: Unknown result type (might be due to invalid IL or missing references)
            //IL_0063: Unknown result type (might be due to invalid IL or missing references)
            //IL_0009: Unknown result type (might be due to invalid IL or missing references)
            if (!randomSigns)
            {
                return from;
            }
            return Vector3Ext.With(from, (float?)FloatExt.WithRandomSign(from.x, 0.5f), (float?)FloatExt.WithRandomSign(from.y, 0.5f), (float?)FloatExt.WithRandomSign(from.z, 0.5f));
        }
    }

    [SerializeField]
    public GameObject target;

    [SerializeField]
    [HideIf("fireOnStart")]
    public bool fireOnEnable;

    [SerializeField]
    [HideIf("fireOnEnable")]
    public bool fireOnStart;

    [SerializeField]
    [HideIf("FireOnStart")]
    public bool enableOnFire;

    [SerializeField]
    public bool disableAfter;

    [SerializeField]
    public bool multi;

    [SerializeField]
    [HideIf("multi")]
    public Property property;

    [SerializeField]
    [HideIf("multi")]
    public LeanTweenType ease;

    [SerializeField]
    [HideIf("multi")]
    [ShowIf("IsAnimationCurve")]
    public AnimationCurve animationCurve;

    [SerializeField]
    [HideIf("multi")]
    public bool randomSigns;

    [Header("Duration")]
    [SerializeField]
    [HideIf("multi")]
    public bool randomDuration;

    [SerializeField]
    [HideIf("multiOrRandomDuration")]
    public float duration;

    [SerializeField]
    [HideIf("multi")]
    [ShowIf("randomDuration")]
    public Vector2 durationRange;

    [Header("Delay")]
    [SerializeField]
    [HideIf("multi")]
    public bool randomDelay;

    [SerializeField]
    [HideIf("multiOrRandomDelay")]
    public float delay;

    [SerializeField]
    [HideIf("multi")]
    [ShowIf("randomDelay")]
    public Vector2 delayRange;

    [Header("Values")]
    [SerializeField]
    [HideIf("multi")]
    public Vector3 to;

    [SerializeField]
    [HideIf("multi")]
    public bool hasFrom;

    [SerializeField]
    [HideIf("multi")]
    [ShowIf("hasFrom")]
    public Vector3 from;

    [SerializeField]
    [ShowIf("multi")]
    public Tween[] tweens;

    [SerializeField]
    public bool cancelOtherTweens = true;

    [SerializeField]
    public bool ignoreTimeScale;

    public bool multiOrRandomDuration
    {
        get
        {
            if (!multi)
            {
                return randomDuration;
            }
            return true;
        }
    }

    public bool multiOrRandomDelay
    {
        get
        {
            if (!multi)
            {
                return randomDelay;
            }
            return true;
        }
    }

    public bool IsAnimationCurve => ease == LeanTweenType.animationCurve;

    public bool FireOnStart
    {
        get
        {
            if (!fireOnEnable)
            {
                return fireOnStart;
            }
            return true;
        }
    }

    public void OnEnable()
    {
        if (fireOnEnable)
        {
            Fire();
        }
    }

    public void Start()
    {
        if (fireOnStart)
        {
            Fire();
        }
    }

    public void Fire()
    {
        //IL_0108: Unknown result type (might be due to invalid IL or missing references)
        //IL_0121: Unknown result type (might be due to invalid IL or missing references)
        //IL_0177: Unknown result type (might be due to invalid IL or missing references)
        //IL_0166: Unknown result type (might be due to invalid IL or missing references)
        //IL_01af: Unknown result type (might be due to invalid IL or missing references)
        //IL_019e: Unknown result type (might be due to invalid IL or missing references)
        //IL_01e7: Unknown result type (might be due to invalid IL or missing references)
        //IL_01d6: Unknown result type (might be due to invalid IL or missing references)
        if (enableOnFire && !FireOnStart)
        {
            target.gameObject.SetActive(true);
        }
        if (cancelOtherTweens)
        {
            LeanTween.cancel(target);
        }
        if (multi)
        {
            delay = 0f;
            duration = 0f;
            Tween[] array = tweens;
            for (int i = 0; i < array.Length; i++)
            {
                Tween tween = array[i];
                tween.Fire(target, ignoreTimeScale);
                delay = Mathf.Max(delay, tween.delay);
                duration = Mathf.Max(duration, tween.duration);
            }
            if (disableAfter)
            {
                LeanTween.value(target, 0f, 0f, delay + duration).setIgnoreTimeScale(ignoreTimeScale).setOnComplete((Action)delegate
                {
                    target.gameObject.SetActive(false);
                });
            }
            return;
        }
        if (randomDuration)
        {
            duration = Vector2Ext.PettyRandom(durationRange);
        }
        if (randomDelay)
        {
            delay = Vector2Ext.PettyRandom(delayRange);
        }
        LTDescr lTDescr = null;
        switch (property)
        {
            case Property.Move:
                if (hasFrom)
                {
                    target.transform.localPosition = GetFrom();
                }
                lTDescr = LeanTween.moveLocal(target, to, duration);
                break;
            case Property.Rotate:
                if (hasFrom)
                {
                    target.transform.localEulerAngles = GetFrom();
                }
                lTDescr = LeanTween.rotateLocal(target, to, duration);
                break;
            case Property.Scale:
                if (hasFrom)
                {
                    target.transform.localScale = GetFrom();
                }
                lTDescr = LeanTween.scale(target, to, duration);
                break;
        }
        if (lTDescr == null)
        {
            return;
        }
        if (ignoreTimeScale)
        {
            lTDescr.setIgnoreTimeScale(useUnScaledTime: true);
        }
        if (delay > 0f)
        {
            lTDescr.setDelay(delay);
        }
        if (IsAnimationCurve)
        {
            lTDescr.setEase(animationCurve);
        }
        else
        {
            lTDescr.setEase(ease);
        }
        if (disableAfter)
        {
            lTDescr.setOnComplete((Action)delegate
            {
                target.gameObject.SetActive(false);
            });
        }
    }

    public float GetDuration()
    {
        return delay + duration;
    }

    public Vector3 GetFrom()
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        if (!randomSigns)
        {
            return from;
        }
        return Vector3Ext.With(from, (float?)FloatExt.WithRandomSign(from.x, 0.5f), (float?)FloatExt.WithRandomSign(from.y, 0.5f), (float?)FloatExt.WithRandomSign(from.z, 0.5f));
    }
}
public class BattleLogButton : MonoBehaviour
{
    [SerializeField]
    public JournalTab battleLogTab;

    public void Awake()
    {
        Events.OnSceneChanged += SceneChanged;
        SetActive(value: false);
    }

    public void OnDestroy()
    {
        Events.OnSceneChanged -= SceneChanged;
    }

    public void SceneChanged(Scene scene)
    {
        SetActive(((scene)).name == "Battle");
    }

    public void SetActive(bool value)
    {
        gameObject.SetActive(value);
        if ((battleLogTab))
        {
            ((Component)battleLogTab).gameObject.SetActive(value);
        }
    }
}
public class BattleLogDisplay : MonoBehaviour
{
    [SerializeField]
    public BattleLogDisplayBuilder builder;

    [SerializeField]
    public ScrollRect scroll;

    [SerializeField]
    public GameObject loadingWidget;

    public bool promptScrollToBottom;

    public bool loadingWidgetActive;

    public void OnEnable()
    {
        CheckScrollToBottom();
        loadingWidget.SetActive(builder.running);
        loadingWidgetActive = loadingWidget.activeSelf;
    }

    public void Update()
    {
        CheckScrollToBottom();
        if (loadingWidgetActive && !builder.running)
        {
            loadingWidget.SetActive(false);
            loadingWidgetActive = false;
        }
    }

    public void CheckScrollToBottom()
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        if (promptScrollToBottom && !builder.running)
        {
            scroll.normalizedPosition = Vector2.zero;
            promptScrollToBottom = false;
        }
    }

    public void PromptScrollToBottom()
    {
        promptScrollToBottom = true;
    }
}
public class BattleLogDisplayBuilder : MonoBehaviour
{
    [Serializable]
    public struct EntryLookup
    {
        public BattleLogType type;

        public AssetReferenceGameObject entryPrefab;
    }

    [SerializeField]
    public BattleLogDisplay battleLogDisplay;

    [SerializeField]
    public Transform tempGroup;

    [SerializeField]
    public Transform finalGroup;

    [SerializeField]
    public AssetReferenceGameObject groupPrefabRef;

    [SerializeField]
    public EntryLookup[] entryTypes;

    public readonly Dictionary<BattleLogType, AssetReferenceGameObject> entryLookup = new Dictionary<BattleLogType, AssetReferenceGameObject>();

    public readonly List<Transform> progress = new List<Transform>();

    public BattleLogSystem battleLogSystem;

    public readonly CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();

    public CancellationToken cancellationToken;

    public int entries { get; set; }

    public bool running { get; set; }

    public void Awake()
    {
        this.entryLookup.Clear();
        EntryLookup[] array = entryTypes;
        for (int i = 0; i < array.Length; i++)
        {
            EntryLookup entryLookup = array[i];
            this.entryLookup[entryLookup.type] = entryLookup.entryPrefab;
        }
        cancellationToken = cancellationTokenSource.Token;
    }

    public async void OnEnable()
    {
        battleLogSystem = Object.FindObjectOfType<BattleLogSystem>();
        if (!(battleLogSystem))
        {
            entries = -1;
            return;
        }
        bool num = entries != battleLogSystem.list.Count;
        entries = battleLogSystem.list.Count;
        if (!num)
        {
            return;
        }
        battleLogDisplay.PromptScrollToBottom();
        if (running)
        {
            cancellationTokenSource.Cancel();
            while (running)
            {
                await Task.Yield();
            }
        }
        await Build();
    }

    public async Task Build()
    {
        running = true;
        TransformExt.DestroyAllChildren(finalGroup);
        await Populate();
        foreach (Transform item in progress)
        {
            if (!cancellationToken.IsCancellationRequested)
            {
                item.SetParent(finalGroup);
                continue;
            }
            break;
        }
        progress.Clear();
        TransformExt.DestroyAllChildren(tempGroup);
        running = false;
    }

    public async Task Populate()
    {
        if (cancellationToken.IsCancellationRequested)
        {
            return;
        }
        int num = 0;
        int count = battleLogSystem.list.Count;
        List<Task> list = new List<Task>();
        for (int i = 0; i < count; i++)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return;
            }
            BattleLog battleLog = battleLogSystem.list[i];
            if (i == 0 || battleLog.type == BattleLogType.Turn)
            {
                int num2 = battleLogSystem.list.FindIndex(i + 1, (BattleLog a) => a.type == BattleLogType.Turn);
                if (num2 == -1)
                {
                    num2 = count;
                }
                List<BattleLog> range = battleLogSystem.list.GetRange(i, num2 - i);
                i = num2 - 1;
                if (cancellationToken.IsCancellationRequested)
                {
                    return;
                }
                progress.Add(null);
                list.Add(CreateGroup(num++, range));
            }
        }
        await Task.WhenAll(list);
    }

    public async Task CreateGroup(int groupIndex, List<BattleLog> logs)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            return;
        }
        Transform val = await CreateGroup(tempGroup);
        progress[groupIndex] = val;
        List<Task<Transform>> tasks = new List<Task<Transform>>();
        foreach (BattleLog log in logs)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return;
            }
            tasks.Add(CreateEntry(log, val));
        }
        await Task.WhenAll(tasks);
        if (cancellationToken.IsCancellationRequested)
        {
            return;
        }
        for (int i = 0; i < tasks.Count; i++)
        {
            Transform result = tasks[i].Result;
            if ((result))
            {
                result.SetSiblingIndex(i + 1);
            }
        }
    }

    public async Task<Transform> CreateGroup(Transform parent)
    {
        return (await ((AssetReference)groupPrefabRef).InstantiateAsync(parent, false).Task).transform;
    }

    public async Task<Transform> CreateEntry(BattleLog log, Transform group)
    {
        AssetReferenceGameObject val = entryLookup[log.type];
        if (cancellationToken.IsCancellationRequested)
        {
            return null;
        }
        GameObject result = await ((AssetReference)val).InstantiateAsync(group, false).Task;
        await result.GetComponent<BattleLogEntry>().SetUp(log);
        return result.transform;
    }

    public void Cancel()
    {
        cancellationTokenSource.Cancel();
    }
}
public class BattleLogEntry : MonoBehaviour
{
    [SerializeField]
    public TMP_Text textElement;

    public const string colorFriendly = "5E849A";

    public const string colorEnemy = "804248";

    public const string colorNumber = "EE5D46";

    public async Task SetUp(BattleLog log)
    {
        string text = AddInserts(await log.textKey.GetLocalizedStringAsync().Task, log.args);
        text = FormatLogText(text);
        textElement.text = text;
    }

    public static string AddInserts(string text, object[] inserts)
    {
        if (inserts != null && inserts.Length != 0)
        {
            object[] array = new object[inserts.Length];
            for (int i = 0; i < inserts.Length; i++)
            {
                object obj = inserts[i];
                if (obj is BattleEntity entity)
                {
                    string entityName = GetEntityName(entity);
                    string text2 = (entity.friendly ? "5E849A" : "804248");
                    array[i] = "<#" + text2 + ">" + entityName + "</color>";
                }
                else
                {
                    array[i] = obj;
                }
            }
            text = string.Format(text, array);
        }
        return text;
    }

    public static string GetEntityName(BattleEntity entity)
    {
        string text = entity.forceTitle;
        if (StringExt.IsNullOrWhitespace(text))
        {
            text = entity.titleKey.GetLocalizedString();
        }
        return text;
    }

    public static string FormatLogText(string text)
    {
        int num = text.IndexOf('[');
        if (num >= 0)
        {
            int num2 = text.IndexOf(']');
            if (num2 >= num + 2)
            {
                string text2 = text.Substring(num + 1, num2 - num - 1);
                text = text.Remove(num, num2 - num + 1);
                text = text.Insert(num, "<#EE5D46>" + text2 + "</color>");
                text = FormatLogText(text);
            }
        }
        return text;
    }
}
public class BellRinger : MonoBehaviour
{
    public TweenUI[] ringTweens;

    public bool playRingSfx = true;

    [SerializeField]
    [ShowIf("playRingSfx")]
    public EventReference ringSfxEvent;

    [SerializeField]
    [ShowIf("playRingSfx")]
    public Vector2 ringSfxPitch = new Vector2(1f, 1f);

    public void Ring()
    {
        TweenUI[] array = ringTweens;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].Fire();
        }
        if (playRingSfx)
        {
            PlayRingSfx();
        }
    }

    public void PlayRingSfx()
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        if (!((ringSfxEvent)).IsNull)
        {
            EventInstance val = SfxSystem.OneShot(ringSfxEvent);
            ((val)).setPitch(Vector2Ext.PettyRandom(ringSfxPitch) * PettyRandom.Range(0.95f, 1.05f));
        }
    }
}
[RequireComponent(typeof(LineRenderer))]
public class Bezier : MonoBehaviour
{
    public LineRenderer lineRenderer;

    public int quality = 30;

    public int pointCount => lineRenderer.positionCount;

    public Vector3 GetPoint(int index)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        return lineRenderer.GetPosition(index);
    }

    public void Start()
    {
        if (lineRenderer == null)
        {
            lineRenderer = GetComponent<LineRenderer>();
        }
    }

    public void UpdateCurve(Vector3 p0, Vector3 p1, Vector3 p2)
    {
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        lineRenderer.positionCount = quality + 1;
        lineRenderer.SetPosition(0, p0);
        for (int i = 1; i <= quality; i++)
        {
            float t = (float)i / (float)quality;
            Vector3 val = Calculate(t, p0, p1, p2);
            lineRenderer.SetPosition(i, val);
        }
    }

    public void UpdateCurve(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
    {
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        lineRenderer.positionCount = quality + 1;
        lineRenderer.SetPosition(0, p0);
        for (int i = 1; i <= quality; i++)
        {
            float t = (float)i / (float)quality;
            Vector3 val = Calculate(t, p0, p1, p2, p3);
            lineRenderer.SetPosition(i, val);
        }
    }

    public Vector3 Calculate(float t, Vector3 p0, Vector3 p1, Vector3 p2)
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        float num = 1f - t;
        float num2 = num * num;
        float num3 = t * t;
        return num2 * p0 + 2f * num * t * p1 + num3 * p2;
    }

    public Vector3 Calculate(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        float num = 1f - t;
        float num2 = t * t;
        float num3 = num * num;
        float num4 = num3 * num;
        float num5 = num2 * t;
        return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
    }
}
public class BlessingSelect : MonoBehaviour
{
    [SerializeField]
    public InputAction inputAction;

    [SerializeField]
    public ImageSprite bellImage;

    [SerializeField]
    public ImageSprite dingerImage;

    [SerializeField]
    public LocalizeStringEvent titleString;

    [SerializeField]
    public LocalizeStringEvent descString;

    public void SetUp(BlessingData blessingData, GainBlessingSequence gainBlessingSequence)
    {
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Expected O, but got Unknown
        inputAction.action.AddListener((UnityAction)delegate
        {
            gainBlessingSequence.SelectBlessing(blessingData);
        });
        bellImage.SetSprite(blessingData.modifierToAdd.bellSprite);
        dingerImage.SetSprite(blessingData.modifierToAdd.dingerSprite);
        titleString.StringReference = blessingData.modifierToAdd.titleKey;
        descString.StringReference = blessingData.modifierToAdd.descriptionKey;
    }
}
public class BossRewardSelect : MonoBehaviourRect
{
    [SerializeField]
    public InputAction inputAction;

    [SerializeField]
    public KeywordData popUpKeyword;

    public string title;

    public string body;

    public string popUpName;

    public bool poppedUp;

    public static readonly Vector2 popUpOffset = new Vector2(1f, 0f);

    public virtual void SetUp(BossRewardData.Data rewardData, GainBlessingSequence2 gainBlessingSequence)
    {
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Expected O, but got Unknown
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Expected O, but got Unknown
        inputAction.action.AddListener((UnityAction)delegate
        {
            gainBlessingSequence.Select(rewardData);
        });
        inputAction.action.AddListener(new UnityAction(Destroy));
    }

    public void Pop()
    {
        if (!poppedUp)
        {
            CardPopUp.AssignTo(base.rectTransform, popUpOffset.x, popUpOffset.y);
            if ((popUpKeyword))
            {
                CardPopUp.AddPanel(popUpKeyword);
            }
            else
            {
                CardPopUp.AddPanel(popUpName, title, body);
            }
            poppedUp = true;
        }
    }

    public void UnPop()
    {
        if (poppedUp)
        {
            CardPopUp.RemovePanel((popUpKeyword) ? (popUpKeyword).name : popUpName);
            poppedUp = false;
        }
    }

    public void Destroy()
    {
        UnPop();
        Object.Destroy(gameObject);
    }
}
public class BossRewardSelectCharm : BossRewardSelect
{
    [SerializeField]
    public ImageSprite charmImage;

    public override void SetUp(BossRewardData.Data rewardData, GainBlessingSequence2 gainBlessingSequence)
    {
        base.SetUp(rewardData, gainBlessingSequence);
        if (rewardData is BossRewardDataRandomCharm.Data data)
        {
            CardUpgradeData upgrade = data.GetUpgrade();
            charmImage.SetSprite(upgrade.image);
            popUpName = (upgrade).name;
            title = upgrade.title;
            body = upgrade.text;
        }
    }
}
public class BossRewardSelectCrown : BossRewardSelect
{
    [SerializeField]
    public ImageSprite crownImage;

    public override void SetUp(BossRewardData.Data rewardData, GainBlessingSequence2 gainBlessingSequence)
    {
        base.SetUp(rewardData, gainBlessingSequence);
        if (rewardData is BossRewardDataCrown.Data data)
        {
            CardUpgradeData upgrade = data.GetUpgrade();
            crownImage.SetSprite(upgrade.image);
            popUpName = (upgrade).name;
            title = upgrade.title;
            body = upgrade.text;
        }
    }
}
public class BossRewardSelectModifier : BossRewardSelect
{
    [SerializeField]
    public ImageSprite bellImage;

    [SerializeField]
    public ImageSprite dingerImage;

    public override void SetUp(BossRewardData.Data rewardData, GainBlessingSequence2 gainBlessingSequence)
    {
        base.SetUp(rewardData, gainBlessingSequence);
        if (rewardData is BossRewardDataModifier.Data data)
        {
            GameModifierData modifier = data.GetModifier();
            bellImage.SetSprite(modifier.bellSprite);
            dingerImage.SetSprite(modifier.dingerSprite);
            popUpName = (modifier).name;
            title = modifier.titleKey.GetLocalizedString();
            body = modifier.descriptionKey.GetLocalizedString();
        }
    }
}
public class ButtonAnimator : MonoBehaviour
{
    [SerializeField]
    public ButtonType type;

    [InfoBox(/*Could not decode attribute arguments.*/)]
    [SerializeField]
    [Required(null)]
    public Selectable button;

    [SerializeField]
    public UINavigationItem nav;

    public bool hover;

    public bool press;

    public LTDescr tween;

    [Header("Text Colours")]
    public TMP_Text text;

    public Color textNormalColour = Color.white;

    [SerializeField]
    public bool textCopyBase = true;

    [HideIf("textCopyBase")]
    [SerializeField]
    public Color textHighlightColour = Color.white;

    [SerializeField]
    public bool strikeTextWhenDisabled;

    [ShowIf("strikeTextWhenDisabled")]
    [SerializeField]
    public Color textDisabledColour = Color.black;

    public Image image;

    public bool baseColourSet;

    public Color baseColour;

    public Color highlightColour = new Color(1f, 1f, 1f, 0.8f);

    public Color disabledColour = new Color(0.5f, 0.5f, 0.5f, 0.75f);

    [SerializeField]
    public bool setPressColour;

    [ShowIf("setPressColour")]
    [SerializeField]
    public Color pressColour;

    [Header("Tweens")]
    public TweenUI hoverTween;

    public TweenUI unHoverTween;

    public TweenUI pressTween;

    public TweenUI releaseTween;

    public bool interactable
    {
        get
        {
            return button.interactable;
        }
        set
        {
            if (value)
            {
                UnHighlight();
                if ((text) && strikeTextWhenDisabled)
                {
                    text.fontStyle = (FontStyles)0;
                }
            }
            else
            {
                Disable();
            }
            button.interactable = value;
            if ((nav))
            {
                ((Behaviour)nav).enabled = value;
            }
        }
    }

    public bool IsHoveredOrPressed
    {
        get
        {
            if (!hover)
            {
                return press;
            }
            return true;
        }
    }

    public void OnEnable()
    {
        hover = false;
        press = false;
        if (interactable)
        {
            UnHighlight();
            if (text != null && strikeTextWhenDisabled)
            {
                text.fontStyle = (FontStyles)0;
            }
        }
        else
        {
            Disable();
        }
    }

    public void OnDisable()
    {
        press = false;
        UnHoverInstant();
    }

    public virtual void Hover()
    {
        if (!hover && interactable)
        {
            hover = true;
            if (!press)
            {
                StopCurrentAnimation();
                hoverTween?.Fire();
                Events.InvokeButtonHover(type);
                Highlight();
            }
        }
    }

    public virtual void UnHover()
    {
        if (hover)
        {
            hover = false;
            if (!press)
            {
                StopCurrentAnimation();
                unHoverTween?.Fire();
                UnHighlight();
            }
        }
    }

    public void UnHoverInstant()
    {
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        if (hover)
        {
            hover = false;
            if (!press)
            {
                StopCurrentAnimation();
                transform.localScale = Vector3.one;
                UnHighlight();
            }
        }
    }

    public virtual void Press()
    {
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        if (press || !interactable)
        {
            return;
        }
        press = true;
        StopCurrentAnimation();
        pressTween?.Fire();
        Events.InvokeButtonPress(type);
        if (setPressColour)
        {
            if (image != null)
            {
                ((Graphic)image).color = pressColour;
            }
        }
        else
        {
            UnHighlight();
        }
    }

    public virtual void Release()
    {
        if (press)
        {
            press = false;
            StopCurrentAnimation();
            if (!hover)
            {
                releaseTween?.Fire();
            }
            else if (interactable)
            {
                hoverTween?.Fire();
                Highlight();
            }
            else
            {
                hover = false;
            }
            if (setPressColour && !hover)
            {
                UnHighlight();
            }
        }
    }

    public void StopCurrentAnimation()
    {
        LeanTween.cancel(gameObject);
    }

    public void CheckSetBaseColour()
    {
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        if (!baseColourSet)
        {
            baseColourSet = true;
            baseColour = ((Graphic)image).color;
        }
    }

    public void Highlight()
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        if (image != null)
        {
            CheckSetBaseColour();
            ((Graphic)image).color = highlightColour;
        }
        if (text != null)
        {
            ((Graphic)text).color = (textCopyBase ? baseColour : textHighlightColour);
        }
    }

    public void UnHighlight()
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        if (image != null)
        {
            CheckSetBaseColour();
            ((Graphic)image).color = baseColour;
        }
        if (text != null)
        {
            ((Graphic)text).color = textNormalColour;
        }
    }

    public void Disable()
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        if (hover)
        {
            UnHover();
        }
        if (image != null)
        {
            CheckSetBaseColour();
            ((Graphic)image).color = disabledColour;
        }
        if (text != null)
        {
            if (strikeTextWhenDisabled)
            {
                text.fontStyle = (FontStyles)64;
            }
            ((Graphic)text).color = (strikeTextWhenDisabled ? textDisabledColour : disabledColour);
        }
    }
}
[RequireComponent(typeof(CanvasGroup))]
public class CanvasGroupFader : MonoBehaviour
{
    public CanvasGroup _canvasGroup;

    [SerializeField]
    public float fadeOutTime = 0.5f;

    [SerializeField]
    public LeanTweenType fadeOutEase = LeanTweenType.easeInOutQuad;

    [SerializeField]
    public bool removeInteractable = true;

    [SerializeField]
    public bool removeBlocksRaycast = true;

    [SerializeField]
    public bool disableAfter;

    [Header("Fade Out After Delay")]
    [SerializeField]
    public bool fadeOutAfter;

    [SerializeField]
    [ShowIf("fadeOutAfter")]
    public bool afterEnable;

    [SerializeField]
    [ShowIf("fadeOutAfter")]
    public float delay;

    public CanvasGroup canvasGroup => _canvasGroup ?? (_canvasGroup = GetComponent<CanvasGroup>());

    public void OnEnable()
    {
        if (fadeOutAfter && afterEnable)
        {
            StartCoroutine(FadeOutAfter(delay));
        }
    }

    public void OnDisable()
    {
        StopAllCoroutines();
    }

    public IEnumerator FadeOutAfter(float delay)
    {
        yield return (object)new WaitForSeconds(delay);
        FadeOut();
    }

    public void FadeOut()
    {
        LeanTween.cancel(gameObject);
        LeanTween.alphaCanvas(canvasGroup, 0f, fadeOutTime).setEase(fadeOutEase);
        if (removeInteractable)
        {
            canvasGroup.interactable = false;
        }
        if (removeBlocksRaycast)
        {
            canvasGroup.blocksRaycasts = false;
        }
        if (disableAfter)
        {
            StartCoroutine(DisableAfter(fadeOutTime));
        }
    }

    public IEnumerator DisableAfter(float delay)
    {
        yield return (object)new WaitForSeconds(delay);
        gameObject.SetActive(false);
    }
}
public class CardPocketInteraction : MonoBehaviour
{
    [SerializeField]
    public UINavigationItem nav;

    [SerializeField]
    public GameObject root;

    [SerializeField]
    public UnityEvent onClick;

    [SerializeField]
    public UnityEvent onPress;

    [SerializeField]
    public UnityEvent onRelease;

    [SerializeField]
    public UnityEvent onHover;

    [SerializeField]
    public UnityEvent onUnHover;

    public bool interactable = true;

    [SerializeField]
    public bool defaultAnimations = true;

    public bool hover;

    public bool hovered;

    public bool press;

    public bool pressed;

    public bool IsInteractable
    {
        get
        {
            if (interactable)
            {
                if (!(nav == null))
                {
                    return ((Behaviour)nav).enabled;
                }
                return true;
            }
            return false;
        }
    }

    public void SetInteractable(bool value)
    {
        interactable = value;
    }

    public void Update()
    {
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ea: Unknown result type (might be due to invalid IL or missing references)
        //IL_01ab: Unknown result type (might be due to invalid IL or missing references)
        //IL_015e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0168: Unknown result type (might be due to invalid IL or missing references)
        if (hover)
        {
            if (!hovered)
            {
                hovered = true;
                if (defaultAnimations)
                {
                    LeanTween.cancel(root);
                    LeanTween.scale(root, Vector3.one * 1.1f, 0.2f).setEase(LeanTweenType.easeOutBack);
                }
                UnityEvent obj = onHover;
                if (obj != null)
                {
                    obj.Invoke();
                }
            }
        }
        else if (hovered)
        {
            hovered = false;
            if (defaultAnimations)
            {
                LeanTween.cancel(root);
                LeanTween.scale(root, Vector3.one, 0.1f).setEase(LeanTweenType.easeOutQuart);
            }
            UnityEvent obj2 = onUnHover;
            if (obj2 != null)
            {
                obj2.Invoke();
            }
        }
        if (press)
        {
            if (!pressed)
            {
                pressed = true;
                if (defaultAnimations)
                {
                    LeanTween.cancel(root);
                    LeanTween.scale(root, Vector3.one, 0.1f).setEase(LeanTweenType.easeOutQuart);
                }
                UnityEvent obj3 = onPress;
                if (obj3 != null)
                {
                    obj3.Invoke();
                }
            }
        }
        else if (pressed)
        {
            pressed = false;
            UnityEvent obj4 = onRelease;
            if (obj4 != null)
            {
                obj4.Invoke();
            }
            if (hover)
            {
                if (defaultAnimations)
                {
                    LeanTween.cancel(root);
                    LeanTween.scale(root, Vector3.one * 1.1f, 0.1f).setEase(LeanTweenType.easeOutQuart);
                }
                UnityEvent obj5 = onClick;
                if (obj5 != null)
                {
                    obj5.Invoke();
                }
            }
            else
            {
                if (defaultAnimations)
                {
                    LeanTween.cancel(root);
                    LeanTween.scale(root, Vector3.one, 0.1f).setEase(LeanTweenType.easeOutQuart);
                }
                if (MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem == nav)
                {
                    Hover();
                }
            }
        }
        if (!press)
        {
            if (hover && InputSystem.IsSelectPressed())
            {
                Press();
            }
        }
        else if (!InputSystem.IsSelectHeld())
        {
            Release();
        }
    }

    public void Hover()
    {
        hover = IsInteractable;
    }

    public void UnHover()
    {
        hover = false;
    }

    public void Press()
    {
        press = IsInteractable;
    }

    public void Release()
    {
        press = false;
    }
}
public class ChallengeEntry : MonoBehaviour
{
    [SerializeField]
    public LocalizeStringEvent text;

    [SerializeField]
    public TMP_Text progressText;

    [SerializeField]
    public LocalizeStringEvent rewardText;

    [SerializeField]
    public Image background;

    [SerializeField]
    public Image rewardIcon;

    public ChallengeData challenge;

    public void Assign(ChallengeData challenge, bool completed)
    {
        this.challenge = challenge;
        text.StringReference = challenge.textKey;
        if (completed && (rewardText))
        {
            rewardText.StringReference = challenge.rewardKey;
        }
        if ((rewardIcon))
        {
            rewardIcon.sprite = challenge.icon;
        }
    }

    public void SetProgress(int progress)
    {
        progressText.text = $"{progress}/{challenge.goal}";
    }

    public void SetText(string str)
    {
        TMP_Text component = ((Component)text).GetComponent<TMP_Text>();
        if (component != null)
        {
            component.text = StringExt.Format(str, new object[1] { challenge.listener.target });
        }
    }
}
public class ChallengeListDisplay : MonoBehaviour
{
    [SerializeField]
    public ChallengeListDisplayBuilder builder;

    [SerializeField]
    public GameObject loadingWidget;

    public bool loadingWidgetActive;

    public void OnEnable()
    {
        loadingWidget.SetActive(builder.running);
        loadingWidgetActive = loadingWidget.activeSelf;
    }

    public void Update()
    {
        if (loadingWidgetActive && !builder.running)
        {
            loadingWidget.SetActive(false);
            loadingWidgetActive = false;
        }
    }
}
public class ChallengeListDisplayBuilder : MonoBehaviour
{
    [SerializeField]
    public Transform tempGroup;

    [SerializeField]
    public Transform finalGroup;

    [SerializeField]
    public AssetReferenceGameObject inProgressPrefab;

    [SerializeField]
    public AssetReferenceGameObject completedPrefab;

    [SerializeField]
    public AssetReferenceGameObject lockedPrefab;

    public readonly CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();

    public CancellationToken cancellationToken;

    public Transform[] progress;

    public bool running { get; set; }

    public void Awake()
    {
        cancellationToken = cancellationTokenSource.Token;
    }

    public async void OnEnable()
    {
        if (running)
        {
            cancellationTokenSource.Cancel();
            while (running)
            {
                await Task.Yield();
            }
        }
        await Build();
    }

    public async Task Build()
    {
        running = true;
        GetChallengeLists(out var inProgressChallenges, out var completedChallenges, out var lockedChallenges, out var challengeProgress);
        TransformExt.DestroyAllChildren(finalGroup);
        int num = inProgressChallenges.Count + completedChallenges.Count + lockedChallenges.Count;
        progress = (Transform[])(object)new Transform[num];
        int challengeIndex = 0;
        foreach (ChallengeData challenge in inProgressChallenges)
        {
            if (!cancellationToken.IsCancellationRequested)
            {
                ChallengeProgress progressAmount = challengeProgress?.FirstOrDefault((ChallengeProgress a) => a.challengeName == (challenge).name);
                await CreateInProgressEntry(challengeIndex++, challenge, progressAmount);
                continue;
            }
            break;
        }
        foreach (ChallengeData item in completedChallenges)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                break;
            }
            await CreateCompletedEntry(challengeIndex++, item);
        }
        foreach (ChallengeData item2 in lockedChallenges)
        {
            _ = item2;
            if (cancellationToken.IsCancellationRequested)
            {
                break;
            }
            await CreateLockedEntry(challengeIndex++);
        }
        Transform[] array = progress;
        foreach (Transform val in array)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                break;
            }
            val.SetParent(finalGroup);
        }
        progress = null;
        TransformExt.DestroyAllChildren(tempGroup);
        running = false;
    }

    public void GetChallengeLists(out List<ChallengeData> inProgressChallenges, out List<ChallengeData> completedChallenges, out List<ChallengeData> lockedChallenges, out List<ChallengeProgress> challengeProgress)
    {
        IEnumerable<ChallengeData> allChallenges = ChallengeSystem.GetAllChallenges();
        ChallengeSystem challengeSystem = Object.FindObjectOfType<ChallengeSystem>();
        bool flag = challengeSystem != null;
        List<string> list = SaveSystem.LoadProgressData<List<string>>("completedChallenges");
        if (list == null)
        {
            list = new List<string>();
        }
        if (flag)
        {
            list.AddRange(challengeSystem.saveRequired.Select((ChallengeData a) => (a).name));
        }
        ChallengeProgressSystem challengeProgressSystem = Object.FindObjectOfType<ChallengeProgressSystem>();
        challengeProgress = ((challengeProgressSystem != null) ? challengeProgressSystem.progress : SaveSystem.LoadProgressData<List<ChallengeProgress>>("challengeProgress"));
        completedChallenges = new List<ChallengeData>();
        lockedChallenges = new List<ChallengeData>();
        inProgressChallenges = (flag ? challengeSystem.activeChallenges.Where((ChallengeData a) => !a.hidden).ToList() : new List<ChallengeData>());
        foreach (ChallengeData challenge in allChallenges)
        {
            if (list.Contains((challenge).name))
            {
                completedChallenges.Add(challenge);
                continue;
            }
            if (flag)
            {
                if (challenge.hidden || !(inProgressChallenges.FirstOrDefault((ChallengeData a) => (a).name == (challenge).name)))
                {
                    lockedChallenges.Add(challenge);
                }
                continue;
            }
            bool flag2 = !challenge.hidden;
            if (flag2)
            {
                ChallengeData[] requires = challenge.requires;
                foreach (ChallengeData challengeData in requires)
                {
                    if (!list.Contains((challengeData).name))
                    {
                        flag2 = false;
                        break;
                    }
                }
            }
            if (!flag2)
            {
                lockedChallenges.Add(challenge);
            }
            else
            {
                inProgressChallenges.Add(challenge);
            }
        }
    }

    public async Task CreateInProgressEntry(int challengeIndex, ChallengeData challengeData, ChallengeProgress progressAmount)
    {
        GameObject val = await ((AssetReference)inProgressPrefab).InstantiateAsync(tempGroup, false).Task;
        progress[challengeIndex] = val.transform;
        if (!cancellationToken.IsCancellationRequested)
        {
            ChallengeEntry component = val.GetComponent<ChallengeEntry>();
            if (component != null)
            {
                component.Assign(challengeData, completed: false);
                component.SetProgress(progressAmount?.currentValue ?? 0);
            }
        }
    }

    public async Task CreateCompletedEntry(int challengeIndex, ChallengeData challengeData)
    {
        GameObject val = await ((AssetReference)completedPrefab).InstantiateAsync(tempGroup, false).Task;
        progress[challengeIndex] = val.transform;
        if (!cancellationToken.IsCancellationRequested)
        {
            val.GetComponent<ChallengeEntry>()?.Assign(challengeData, completed: true);
        }
    }

    public async Task CreateLockedEntry(int challengeIndex)
    {
        GameObject val = await ((AssetReference)lockedPrefab).InstantiateAsync(tempGroup, false).Task;
        progress[challengeIndex] = val.transform;
    }
}
public class ChallengeProgressDisplay : MonoBehaviour
{
    public TMP_Text text;

    public TMP_Text progressText;

    public ImageSprite icon;

    public ImageSprite back;

    public Image fill;

    public Animator animator;

    public void Assign(ChallengeData challengeData)
    {
        text.text = string.Format(challengeData.text, challengeData.goal);
        icon.SetSprite(challengeData.icon);
    }

    public void SetRewardText(ChallengeData challengeData)
    {
        text.text = challengeData.rewardText;
    }

    public void SetFill(float current, int target)
    {
        fill.fillAmount = current / (float)target;
        int num = Mathf.RoundToInt(current);
        progressText.text = $"{num}/{target}";
    }

    public void SetRemainingText(ChallengeData challengeData, float current)
    {
        int num = Mathf.RoundToInt(current);
        text.text = string.Format(challengeData.text, challengeData.goal - num);
    }

    public void SetColor(Color color)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        ((Graphic)text).color = color;
        ((Graphic)progressText).color = color;
        ((Graphic)fill).color = color;
    }
}
public class ChallengeProgressSequence : MonoBehaviour
{
    [Serializable]
    public struct Profile
    {
        public float scale;

        public Color color;
    }

    [SerializeField]
    public ChallengeProgressDisplay progressPrefab;

    [SerializeField]
    public Profile[] profiles;

    [SerializeField]
    public Transform progressGroup;

    public readonly List<ChallengeProgressDisplay> panels = new List<ChallengeProgressDisplay>();

    public bool running { get; set; }

    public IEnumerator Start()
    {
        running = true;
        ChallengeProgressSystem challengeProgressSystem = Object.FindObjectOfType<ChallengeProgressSystem>();
        if (challengeProgressSystem != null)
        {
            List<ChallengeProgress> progress = challengeProgressSystem.progress;
            if (progress != null)
            {
                foreach (ChallengeProgress item in progress.Where((ChallengeProgress a) => a.currentValue > a.originalValue))
                {
                    yield return AddDisplay(item);
                    yield return (object)new WaitForSeconds(0.5f);
                }
            }
        }
        running = false;
    }

    public IEnumerator AddDisplay(ChallengeProgress progress)
    {
        ChallengeProgressDisplay panel = Object.Instantiate<ChallengeProgressDisplay>(progressPrefab, progressGroup);
        panels.Insert(0, panel);
        UpdatePanelPositions();
        ChallengeData challengeData = AddressableLoader.Get<ChallengeData>("ChallengeData", progress.challengeName);
        panel.Assign(challengeData);
        panel.SetFill(progress.originalValue, challengeData.goal);
        yield return (object)new WaitForSeconds(0.5f);
        int fillTo = Mathf.Min(challengeData.goal, progress.currentValue);
        float num = Mathf.Clamp((float)fillTo / (float)challengeData.goal, 0f, 1f) * 2f;
        num = Mathf.Lerp(num, 1f, 0.5f);
        Events.InvokeProgressStart((float)progress.originalValue / (float)challengeData.goal);
        panel.animator.SetBool("Increasing", true);
        LeanTween.value(((Component)panel).gameObject, (float)progress.originalValue, (float)fillTo, num).setEaseOutQuad().setOnUpdate(delegate (float a)
        {
            panel.SetFill(a, challengeData.goal);
            panel.SetRemainingText(challengeData, a);
        });
        yield return (object)new WaitForSeconds(num);
        panel.animator.SetBool("Increasing", false);
        Events.InvokeProgressStop();
        if (fillTo >= challengeData.goal)
        {
            Events.InvokeProgressDing();
            panel.animator.SetTrigger("Ping");
            panel.SetRewardText(challengeData);
            yield return (object)new WaitForSeconds(1.5f);
        }
    }

    public void UpdatePanelPositions()
    {
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_008b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0097: Unknown result type (might be due to invalid IL or missing references)
        float num = 0f;
        int num2 = 0;
        foreach (ChallengeProgressDisplay panel in panels)
        {
            Profile profile = profiles[Mathf.Min(num2, profiles.Length - 1)];
            panel.SetColor(profile.color);
            if (num2 > 0)
            {
                LeanTween.cancel(((Component)panel).gameObject);
                LeanTween.moveLocal(((Component)panel).gameObject, new Vector3(0f, num, 0f), 0.2f).setEase(LeanTweenType.easeOutQuint);
                LeanTween.scale(((Component)panel).gameObject, Vector3.one * profile.scale, 0.2f).setEase(LeanTweenType.easeOutQuint);
                ((Component)panel.icon).gameObject.SetActive(false);
                ((Component)panel.back).gameObject.SetActive(false);
                ((Component)panel.progressText).gameObject.SetActive(false);
            }
            num -= 1.3f * profile.scale;
            num2++;
        }
    }
}
public class SelectLeader : MonoBehaviour, IRerollable
{
    public class Character
    {
        public PlayerData data;

        public Entity entity;

        public Character(PlayerData data, Entity entity)
        {
            this.data = data;
            this.entity = entity;
        }

        public void Clear()
        {
            if ((entity))
            {
                entity.RemoveFromContainers();
                CardManager.ReturnToPool(entity);
                Object.Destroy(entity.data);
                Object.Destroy(data.inventory);
            }
            data = null;
        }

        public void AddLeaderToInventory()
        {
            Events.InvokeEntityChosen(entity);
            data.inventory.deck.Insert(0, entity.data);
        }
    }

    public class LeaderPool
    {
        public readonly ClassData classData;

        public readonly List<CardData> pool = new List<CardData>();

        public LeaderPool(ClassData classData)
        {
            this.classData = classData;
        }

        public CardData Pull()
        {
            if (pool.Count <= 0)
            {
                pool.AddRange(classData.leaders);
                IListExt.Shuffle<CardData>((IList<CardData>)pool);
            }
            CardData result = pool[0];
            pool.RemoveAt(0);
            return result;
        }
    }

    [SerializeField]
    public int options = 3;

    [SerializeField]
    public int differentTribes = 3;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardContainer leaderCardContainer;

    [SerializeField]
    public InspectNewUnitSequence selectionSequence;

    [SerializeField]
    public TitleSetter titleSetter;

    [Header("Tribe Flags")]
    [SerializeField]
    public Transform flagGroup;

    [SerializeField]
    public TribeFlagDisplay flagBase;

    [SerializeField]
    public Vector3 flagOffset = new Vector3(0f, -4f);

    [SerializeField]
    public TribeDisplaySequence tribeDisplay;

    public readonly List<GameObject> flags = new List<GameObject>();

    public List<Character> characters;

    public Dictionary<ClassData, LeaderPool> leaderPools;

    public int seed;

    public Character current { get; set; }

    public bool generating { get; set; }

    public bool running { get; set; }

    public void Run(List<ClassData> tribes)
    {
        running = true;
        titleSetter.Set();
        leaderPools = new Dictionary<ClassData, LeaderPool>();
        foreach (ClassData tribe in tribes)
        {
            leaderPools[tribe] = new LeaderPool(tribe);
        }
    }

    public void Hide()
    {
        gameObject.SetActive(false);
        running = false;
    }

    public void Return()
    {
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        running = true;
        gameObject.SetActive(true);
        LeanTween.cancel(gameObject);
        LeanTween.moveLocal(gameObject, Vector3.zero, 0.3f).setEaseOutQuint();
    }

    public void SetSeed(int seed)
    {
        this.seed = seed;
        Random.InitState(seed);
        Names.Reset();
    }

    public IEnumerator GenerateLeaders(bool useSeed)
    {
        if (useSeed)
        {
            Random.InitState(seed);
            Names.Reset();
        }
        generating = true;
        Clear();
        List<ClassData> availableTribes = leaderPools.Keys.ToList();
        IListExt.Shuffle<ClassData>((IList<ClassData>)availableTribes);
        List<ClassData> list = new List<ClassData>();
        for (int i = 0; i < Mathf.Min(options, differentTribes); i++)
        {
            list.Add(availableTribes[i % availableTribes.Count]);
        }
        while (list.Count < options)
        {
            list.Add(IListExt.RandomItem<ClassData>((IList<ClassData>)availableTribes));
        }
        if (list.Count > 1)
        {
            IListExt.Shuffle<ClassData>((IList<ClassData>)list);
        }
        List<Card> list2 = new List<Card>();
        for (int j = 0; j < options; j++)
        {
            list2.Add(CreateLeader(list[j]));
        }
        SetLeaderPositions();
        foreach (Card item in list2)
        {
            yield return item.UpdateData();
        }
        if (availableTribes.Count > 1)
        {
            foreach (Character c in characters)
            {
                Vector3 val = c.entity.transform.position + flagOffset;
                TribeFlagDisplay tribeFlagDisplay = Object.Instantiate<TribeFlagDisplay>(flagBase, val, Quaternion.identity, flagGroup);
                tribeFlagDisplay.SetFlagSprite(c.data.classData.flag);
                tribeFlagDisplay.AddPressAction((UnityAction)delegate
                {
                    tribeDisplay.Run((c.data.classData).name);
                });
                ((Component)tribeFlagDisplay).gameObject.SetActive(true);
                flags.Add(((Component)tribeFlagDisplay).gameObject);
            }
        }
        generating = false;
    }

    public Card CreateLeader(ClassData classData)
    {
        CardData data = leaderPools[classData].Pull().Clone();
        PlayerData data2 = new PlayerData(classData, classData.startingInventory.Clone());
        Card card = CardManager.Get(data, cardController, null, inPlay: false, isPlayerCard: true);
        leaderCardContainer.Add(card.entity);
        card.entity.flipper.FlipDownInstant();
        characters.Add(new Character(data2, card.entity));
        return card;
    }

    public void Clear()
    {
        if (characters == null)
        {
            characters = new List<Character>();
        }
        foreach (Character character in characters)
        {
            character.Clear();
        }
        current = null;
        characters.Clear();
        StopAllCoroutines();
        flags.DestroyAllAndClear();
    }

    public void SetLeaderPositions()
    {
        List<MonoBehaviour> list = new List<MonoBehaviour>();
        foreach (Character character in characters)
        {
            AngleWobbler[] componentsInChildren = ((Component)character.entity).GetComponentsInChildren<AngleWobbler>();
            foreach (AngleWobbler angleWobbler in componentsInChildren)
            {
                if (((Behaviour)angleWobbler).enabled)
                {
                    ((Behaviour)angleWobbler).enabled = false;
                    list.Add((MonoBehaviour)(object)angleWobbler);
                }
            }
        }
        leaderCardContainer.SetChildPositions();
        foreach (MonoBehaviour item in list)
        {
            ((Behaviour)item).enabled = true;
        }
    }

    public void FlipUpLeaders()
    {
        StartCoroutine(FlipUpRoutine());
    }

    public void FlipUpLeadersInstant()
    {
        foreach (Entity item in leaderCardContainer)
        {
            item.flipper.FlipUpInstant();
        }
    }

    public IEnumerator FlipUpRoutine()
    {
        foreach (Entity item in leaderCardContainer)
        {
            item.flipper.FlipUp(force: true);
            yield return Sequences.Wait(PettyRandom.Range(0f, 0.1f));
        }
    }

    public bool Reroll()
    {
        if (!generating)
        {
            InspectNewUnitSequence inspectNewUnitSequence = Object.FindObjectOfType<InspectNewUnitSequence>();
            if (!InspectSystem.IsActive() && (!(inspectNewUnitSequence) || !((Component)inspectNewUnitSequence).gameObject.activeSelf))
            {
                StartCoroutine(GenerateLeaders(useSeed: false));
                CardPopUp.Clear();
                return true;
            }
        }
        return false;
    }

    public void Select(Entity entity)
    {
        if (running)
        {
            Character character = characters.FirstOrDefault((Character a) => a.entity == entity);
            if (character != null)
            {
                Select(character);
                selectionSequence.SetUnit(entity);
                selectionSequence.Begin();
                ((Behaviour)cardController).enabled = false;
                cardController.UnHover();
            }
        }
    }

    public void Select(Character character)
    {
        current = character;
    }

    public void Cancel()
    {
        current = null;
        running = false;
        Clear();
    }
}
public class SelectStartingPet : MonoBehaviour, IRerollable
{
    [SerializeField]
    public SelectLeader leaderSelect;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardContainer leaderContainer;

    [SerializeField]
    public CardContainer group;

    [SerializeField]
    public InspectNewUnitSequence selectionSequence;

    [SerializeField]
    public GameObject text;

    [SerializeField]
    public Vector3 startPos = new Vector3(0f, -7f, 0f);

    [SerializeField]
    public GameObject winStreakDisplay;

    [SerializeField]
    public TitleSetter titleSetter;

    public string[] petData;

    public readonly List<Entity> pets = new List<Entity>();

    public Entity leader;

    public CardContainer leaderPreContainer;

    public int leaderPreContainerIndex;

    public bool CanRun
    {
        get
        {
            if (petData != null)
            {
                return petData.Length > 1;
            }
            return false;
        }
    }

    public bool running { get; set; }

    public int selectedPetIndex { get; set; } = -1;


    public IEnumerator SetUp()
    {
        if (!Campaign.Data.GameMode.takeStartingPet)
        {
            yield break;
        }
        petData = MetaprogressionSystem.GetUnlockedPets();
        Routine.Clump clump = new Routine.Clump();
        string[] array = petData;
        foreach (string text in array)
        {
            if (!StringExt.IsNullOrWhitespace(text))
            {
                clump.Add(CreateCard(text));
            }
        }
        yield return clump.WaitForEnd();
    }

    public IEnumerator CreateCard(string cardDataName)
    {
        Card card = CardManager.Get(AddressableLoader.Get<CardData>("CardData", cardDataName).Clone(), cardController, null, inPlay: false, isPlayerCard: true);
        group.Insert(0, card.entity);
        pets.Add(card.entity);
        card.transform.localScale = group.GetChildScale(card.entity);
        card.transform.localPosition = startPos;
        card.hover.SetHoverable(value: false);
        yield return card.UpdateData();
    }

    public void Run(Entity leader)
    {
        if (!running)
        {
            StartCoroutine(Routine(leader));
        }
    }

    public void Stop()
    {
        running = false;
    }

    public void Cancel()
    {
        //IL_00a7: Unknown result type (might be due to invalid IL or missing references)
        Stop();
        selectedPetIndex = -1;
        leader.RemoveFromContainers();
        leader.wobbler.WobbleRandom();
        leaderPreContainer.Insert(leaderPreContainerIndex, leader);
        leaderPreContainer.TweenChildPositions();
        if ((text))
        {
            text.SetActive(false);
        }
        foreach (Entity item in pets.OrderBy((Entity a) => Random.Range(0f, 1f)))
        {
            LeanTween.moveLocal(((Component)item).gameObject, startPos, 0.1f).setEaseInQuad().setDelay(Random.Range(0f, 0.1f));
            item.display.hover.SetHoverable(value: false);
        }
        winStreakDisplay.SetActive(true);
    }

    public IEnumerator Routine(Entity leader)
    {
        if (running)
        {
            yield break;
        }
        running = true;
        this.leader = leader;
        titleSetter.Set();
        winStreakDisplay.SetActive(false);
        leaderPreContainer = leader.actualContainers[0];
        leaderPreContainerIndex = leaderPreContainer.IndexOf(leader);
        leader.RemoveFromContainers();
        leader.wobbler.WobbleRandom();
        leaderContainer.Add(leader);
        leaderContainer.TweenChildPositions();
        leaderSelect.Hide();
        foreach (Entity item in pets.OrderBy((Entity a) => Random.Range(0f, 1f)))
        {
            group.TweenChildPosition(item);
            item.display.hover.SetHoverable(value: true);
            yield return (object)new WaitForSeconds(Random.Range(0f, 0.1f));
        }
        if ((text))
        {
            text.SetActive(true);
            text.transform.localScale = Vector3.zero;
            LeanTween.scale(text, Vector3.one, 1f).setEaseOutElastic();
        }
        yield return (object)new WaitUntil((Func<bool>)(() => !running));
    }

    public bool Reroll()
    {
        throw new NotImplementedException();
    }

    public void Select(Entity entity)
    {
        if (running)
        {
            int num = pets.IndexOf(entity);
            if (num >= 0)
            {
                selectedPetIndex = num;
                selectionSequence.SetUnit(entity);
                selectionSequence.Begin();
                ((Behaviour)cardController).enabled = false;
                cardController.UnHover();
            }
        }
    }

    public void Gain(PlayerData playerData)
    {
        if (selectedPetIndex < 0 && pets.Count > 0)
        {
            selectedPetIndex = 0;
        }
        Entity entity = ((selectedPetIndex >= 0) ? pets[selectedPetIndex] : null);
        if ((entity))
        {
            Events.InvokeEntityChosen(entity);
            playerData.inventory.deck.Insert(0, entity.data);
            MetaprogressionSystem.Set("selectedPet", selectedPetIndex);
        }
    }
}
public class SelectTribe : MonoBehaviour
{
    [SerializeField]
    public TribeFlagDisplay tribeFlagPrefab;

    [SerializeField]
    public Transform tribeFlagGroup;

    [SerializeField]
    public SelectLeader leaderSelection;

    [SerializeField]
    public Transform selectedFlagAnchor;

    [SerializeField]
    public TitleSetter titleSetter;

    [SerializeField]
    public ParticleSystem selectParticleSystem;

    public readonly List<TribeFlagDisplay> flags = new List<TribeFlagDisplay>();

    public readonly List<ClassData> tribes = new List<ClassData>();

    public void SetAvailableTribes(List<ClassData> tribes)
    {
        this.tribes.Clear();
        this.tribes.AddRange(tribes);
    }

    public void Run()
    {
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Expected O, but got Unknown
        titleSetter.Set();
        foreach (ClassData tribe in tribes)
        {
            TribeFlagDisplay flag = Object.Instantiate<TribeFlagDisplay>(tribeFlagPrefab, tribeFlagGroup);
            flag.SetAvailable();
            flag.SetUnlocked();
            flag.SetFlagSprite(tribe.flag);
            flag.AddPressAction((UnityAction)delegate
            {
                StartSelectRoutine(flag, tribe);
            });
            flags.Add(flag);
        }
        TransformExt.DestroyAllChildren(selectedFlagAnchor);
    }

    public void RevealAnimation()
    {
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0083: Unknown result type (might be due to invalid IL or missing references)
        //IL_009c: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b0: Unknown result type (might be due to invalid IL or missing references)
        foreach (TribeFlagDisplay flag in flags)
        {
            Transform transform = ((Component)flag.flagImage).transform;
            if (transform != null)
            {
                transform.localRotation = Quaternion.Euler(0f, 0f, PettyRandom.Range(-15f, -5f));
                LeanTween.cancel(((Component)transform).gameObject);
                LeanTween.rotateLocal(((Component)transform).gameObject, Vector3.zero, PettyRandom.Range(1f, 1.5f)).setEaseOutElastic();
                LeanTween.moveLocal(((Component)transform).gameObject, Vector3.zero, PettyRandom.Range(0.25f, 0.35f)).setFrom(Vector3.up * PettyRandom.Range(1f, 2f)).setEaseOutQuart();
            }
        }
    }

    public void StartSelectRoutine(TribeFlagDisplay flag, ClassData classData)
    {
        new Routine(SelectRoutine(flag, classData));
    }

    public IEnumerator SelectRoutine(TribeFlagDisplay flag, ClassData classData)
    {
        ((Component)selectParticleSystem).transform.position = Cursor3d.PositionWithZ;
        selectParticleSystem.Play();
        if (!((classData.selectSfxEvent)).IsNull)
        {
            SfxSystem.OneShot(classData.selectSfxEvent);
        }
        ((Component)flag).transform.SetParent(selectedFlagAnchor);
        TransformExt.DestroyAllChildren(tribeFlagGroup);
        flags.Clear();
        flag.ClearPressActions();
        flag.SetInteractable(interactable: false);
        tribes.Clear();
        tribes.Add(classData);
        ((Component)flag).transform.localPosition = Vector3.up * 3f;
        LeanTween.cancel(((Component)flag).gameObject);
        LeanTween.moveLocal(((Component)flag).gameObject, Vector3.zero, PettyRandom.Range(0.2f, 0.3f)).setEaseOutQuart();
        Transform transform = ((Component)flag.flagImage).transform;
        if (transform != null)
        {
            transform.localRotation = Quaternion.Euler(0f, 0f, PettyRandom.Range(10f, 15f));
            LeanTween.cancel(((Component)transform).gameObject);
            LeanTween.rotateLocal(((Component)transform).gameObject, Vector3.zero, PettyRandom.Range(1f, 1.5f)).setEaseOutElastic();
        }
        leaderSelection.Run(tribes);
        yield return leaderSelection.GenerateLeaders(useSeed: true);
        leaderSelection.FlipUpLeaders();
    }
}
public class CharacterSelectScreen : MonoBehaviour
{
    [SerializeField]
    public int options = 3;

    [SerializeField]
    public int differentTribes = 3;

    public List<Character> characters;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardContainer leaderCardContainer;

    [SerializeField]
    public GameObject backButton;

    [SerializeField]
    public SelectTribe tribeSelection;

    [SerializeField]
    public SelectLeader leaderSelection;

    [SerializeField]
    public SelectStartingPet petSelection;

    [SerializeField]
    public InspectNewUnitSequence selectionSequence;

    [Header("Title")]
    [SerializeField]
    public GameObject title;

    [SerializeField]
    public LocalizeStringEvent titleText;

    [SerializeField]
    public LocalizedString titleTribeKey;

    [SerializeField]
    public LocalizedString titleLeaderKey;

    [SerializeField]
    public LocalizedString titlePetKey;

    [SerializeField]
    public Image titleUnderline;

    [SerializeField]
    public Sprite underlineTribeSprite;

    [SerializeField]
    public Sprite underlineLeaderSprite;

    [SerializeField]
    public Sprite underlinePetSprite;

    [Header("Hard Mode Modifiers")]
    [SerializeField]
    public HardModeModifierDisplay modifierDisplay;

    [SerializeField]
    public UnlockModifierSequence modifierUnlockSequence;

    [Header("Tribe Flags")]
    [SerializeField]
    public Transform flagGroup;

    [SerializeField]
    public TribeFlagDisplay flagBase;

    [SerializeField]
    public Vector3 flagOffset = new Vector3(0f, -4f);

    [SerializeField]
    public TribeDisplaySequence tribeDisplay;

    public readonly List<GameObject> flags = new List<GameObject>();

    public int seed;

    public bool loadingToCampaign;

    public List<ClassData> unlockedClassesForThisGameMode;

    public const bool selectTribe = true;

    public void OnEnable()
    {
        loadingToCampaign = false;
    }

    public IEnumerator Start()
    {
        leaderSelection.SetSeed(Campaign.Data.Seed);
        List<ClassData> lockedClasses = MetaprogressionSystem.GetLockedClasses();
        Debug.Log(("Locked Classes: [" + string.Join(", ", lockedClasses) + "]"));
        unlockedClassesForThisGameMode = new List<ClassData>(Campaign.Data.GameMode.classes);
        IListExt.RemoveMany<ClassData>((IList<ClassData>)unlockedClassesForThisGameMode, (ICollection<ClassData>)lockedClasses);
        Debug.Log(("Available Classes For [" + (Campaign.Data.GameMode).name + "]: [" + string.Join(", ", unlockedClassesForThisGameMode) + "]"));
        if (unlockedClassesForThisGameMode.Count > 1)
        {
            tribeSelection.SetAvailableTribes(unlockedClassesForThisGameMode);
            tribeSelection.Run();
            title.SetActive(true);
            titleText.StringReference = titleTribeKey;
            titleUnderline.sprite = underlineTribeSprite;
        }
        else
        {
            leaderSelection.Run(unlockedClassesForThisGameMode);
            yield return leaderSelection.GenerateLeaders(useSeed: true);
            leaderSelection.FlipUpLeadersInstant();
            title.SetActive(true);
            titleText.StringReference = titleLeaderKey;
            titleUnderline.sprite = underlineLeaderSprite;
        }
        yield return Sequences.Wait(0.1f);
        yield return petSelection.SetUp();
        if (((Component)modifierDisplay).gameObject.activeSelf)
        {
            modifierDisplay.Populate();
        }
        backButton.gameObject.SetActive(Campaign.Data.GameMode.canGoBack);
        Transition.End();
        if (NewFinalBossChecker.Check())
        {
            cardController.Disable();
            yield return NewFinalBossChecker.Run();
            cardController.Enable();
        }
    }

    public void Continue()
    {
        if (leaderSelection.current == null || loadingToCampaign)
        {
            return;
        }
        if (petSelection.running)
        {
            petSelection.Stop();
        }
        if (petSelection.selectedPetIndex < 0 && petSelection.CanRun)
        {
            if (selectionSequence.IsRunning)
            {
                selectionSequence.UnsetUnit();
                selectionSequence.End();
                cardController.Enable();
            }
            petSelection.Run(leaderSelection.current.entity);
            SetTitlePet();
        }
        else
        {
            StartCoroutine(ContinueRoutine(leaderSelection.current));
        }
    }

    public IEnumerator ContinueRoutine(SelectLeader.Character selected)
    {
        loadingToCampaign = true;
        petSelection.Gain(leaderSelection.current.data);
        leaderSelection.current.AddLeaderToInventory();
        References.PlayerData = selected.data;
        yield return JournalAddNameSequence.LoadAndRun(leaderSelection.current.entity.data, unloadAfter: false);
        yield return Events.InvokeCampaignInit();
        Campaign.Begin();
        new Routine(Transition.To(Campaign.Data.GameMode.sceneAfterSelection));
    }

    public void SetTitleTribe()
    {
        title.SetActive(true);
        titleText.StringReference = titleTribeKey;
        titleUnderline.sprite = underlineTribeSprite;
    }

    public void SetTitleLeader()
    {
        title.SetActive(true);
        titleText.StringReference = titleLeaderKey;
        titleUnderline.sprite = underlineLeaderSprite;
    }

    public void SetTitlePet()
    {
        title.SetActive(false);
    }

    public void Back()
    {
        if (leaderSelection.running)
        {
            if (unlockedClassesForThisGameMode.Count > 1)
            {
                leaderSelection.Cancel();
                tribeSelection.SetAvailableTribes(unlockedClassesForThisGameMode);
                tribeSelection.Run();
                tribeSelection.RevealAnimation();
                SetTitleTribe();
            }
            else
            {
                ReturnToMenu();
            }
        }
        else if (petSelection.running)
        {
            petSelection.Cancel();
            leaderSelection.Return();
            SetTitleLeader();
        }
        else
        {
            ReturnToMenu();
        }
    }

    public void ReturnToMenu()
    {
        new Routine(Transition.To((SaveSystem.LoadProgressData("tutorialProgress", 0) == 0) ? "MainMenu" : "Town"));
    }
}
[RequireComponent(typeof(Graphic))]
public class ColourFader : MonoBehaviour
{
    [Serializable]
    public struct Colour
    {
        public string name;

        public Color colour;
    }

    public Graphic _graphic;

    [SerializeField]
    public Colour[] colours;

    [SerializeField]
    public float duration;

    public Color targetColour;

    public float fadeAmount;

    public float fadeDuration;

    public Graphic graphic => _graphic ?? (_graphic = GetComponent<Graphic>());

    public void FadeToColour(string name)
    {
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        Colour[] array = colours;
        for (int i = 0; i < array.Length; i++)
        {
            Colour colour = array[i];
            if (colour.name == name)
            {
                FadeToColour(colour.colour);
                break;
            }
        }
    }

    public void FadeToColour(Color colour)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        fadeAmount = 0f;
        fadeDuration = duration;
        targetColour = colour;
    }

    public void Update()
    {
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        if (fadeAmount < fadeDuration)
        {
            fadeAmount += Time.deltaTime * fadeDuration;
            graphic.color = Color.Lerp(graphic.color, targetColour, fadeAmount);
        }
    }
}
public class ContinueScreen : MonoBehaviour
{
    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardContainer cardContainer;

    [SerializeField]
    public ModifierDisplay modifierDisplay;

    [SerializeField]
    public TMP_Text titleText;

    [SerializeField]
    public TMP_Text dateText;

    [SerializeField]
    public TMP_Text progressText;

    [SerializeField]
    public Menu menu;

    [SerializeField]
    public GameObject backButton;

    [SerializeField]
    public GameObject continueButton;

    [SerializeField]
    public HelpPanelShower giveUpHelpShower;

    [SerializeField]
    public GameObject missingDataDisplay;

    public CampaignSaveData data;

    public bool closing;

    public IEnumerator Start()
    {
        bool flag = true;
        List<CardData> list = null;
        try
        {
            if (SaveSystem.CampaignExists(Campaign.Data.GameMode) && SaveSystem.CampaignDataExists(Campaign.Data.GameMode, "data"))
            {
                data = SaveSystem.LoadCampaignData<CampaignSaveData>(Campaign.Data.GameMode, "data");
                Events.InvokeCampaignLoaded();
                string text = SaveSystem.LoadCampaignData<string>(Campaign.Data.GameMode, "startDate");
                if (text != null)
                {
                    ((Component)dateText).gameObject.SetActive(true);
                    DateTime dateTime = DateTime.ParseExact(text, "dd/MM/yyyy", GameManager.CultureInfo);
                    LocaleIdentifier identifier = LocalizationSettings.SelectedLocale.Identifier;
                    CultureInfo cultureInfo = ((identifier)).CultureInfo;
                    dateText.text = dateTime.ToString("D", cultureInfo);
                }
                bool mainGameMode = Campaign.Data.GameMode.mainGameMode;
                string[] modifiers = data.modifiers;
                if (modifiers == null || modifiers.Length <= 0)
                {
                    ((Component)modifierDisplay).gameObject.SetActive(false);
                }
                else
                {
                    modifiers = data.modifiers;
                    foreach (string assetName in modifiers)
                    {
                        GameModifierData gameModifierData = AddressableLoader.Get<GameModifierData>("GameModifierData", assetName);
                        if (gameModifierData != null)
                        {
                            modifierDisplay.CreateIcon(gameModifierData, mainGameMode);
                        }
                    }
                }
                list = data.characters[data.playerId].inventoryData.deck.LoadList<CardData, CardSaveData>();
                continueButton.SetActive(true);
            }
        }
        catch (NullReferenceException ex)
        {
            flag = false;
            Debug.LogWarning(ex);
        }
        if (flag)
        {
            CheckMissingData(data);
            Routine.Clump clump = new Routine.Clump();
            List<Entity> cards = new List<Entity>();
            foreach (CardData item in list)
            {
                Card card = CardManager.Get(item, cardController, null, inPlay: false, isPlayerCard: true);
                ((Behaviour)card.hover).enabled = false;
                cards.Add(card.entity);
                clump.Add(card.UpdateData());
            }
            yield return clump.WaitForEnd();
            foreach (Entity item2 in cards)
            {
                ((Behaviour)item2.display.hover).enabled = true;
            }
            cards.Sort((Entity a, Entity b) => a.data.cardType.sortPriority.CompareTo(b.data.cardType.sortPriority));
            cardContainer.max = cards.Count;
            for (int num = cards.Count - 1; num >= 0; num--)
            {
                Entity entity = cards[num];
                cardContainer.Add(entity);
            }
            cardContainer.SetChildPositions();
            backButton.gameObject.SetActive(Campaign.Data.GameMode.canGoBack);
        }
        else
        {
            Debug.LogWarning("Failed to load campaign save...");
            SaveSystem.DeleteCampaign(Campaign.Data.GameMode);
            Events.InvokeCampaignDeleted();
            Campaign.Data = new CampaignData(Campaign.Data.GameMode);
            new Routine(Sequences.SceneChange(Campaign.Data.GameMode.startScene));
        }
    }

    public void Continue()
    {
        if (!closing)
        {
            closing = true;
            menu.GoTo("Campaign");
        }
    }

    public void PromptGiveUp()
    {
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Expected O, but got Unknown
        if (!closing)
        {
            giveUpHelpShower.Show();
            giveUpHelpShower.AddButton(0, HelpPanelSystem.ButtonType.Positive, new UnityAction(GiveUp));
            giveUpHelpShower.AddButton(1, HelpPanelSystem.ButtonType.Negative, null);
        }
    }

    public void GiveUp()
    {
        if (!closing)
        {
            closing = true;
            CampaignSaveData campaignSaveData = SaveSystem.LoadCampaignData<CampaignSaveData>(Campaign.Data.GameMode, "data");
            CharacterSaveData characterSaveData = campaignSaveData.characters[campaignSaveData.playerId];
            if (characterSaveData != null)
            {
                CampaignStats stats = SaveSystem.LoadCampaignData<CampaignStats>(Campaign.Data.GameMode, "stats");
                Events.InvokeCampaignEnd(Campaign.Result.Restart, stats, characterSaveData.LoadPlayerData());
            }
            SaveSystem.DeleteCampaign(Campaign.Data.GameMode);
            Events.InvokeCampaignDeleted();
            StartCoroutine(GiveUpSequence());
        }
    }

    public IEnumerator GiveUpSequence()
    {
        if (Settings.Load("showJournalNameOnEnd", defaultValue: false))
        {
            yield return JournalVoidNameSequence.LoadAndRun(unloadAfter: false);
        }
        else
        {
            JournalNameHistory.MostRecentNameKilled();
        }
        Campaign.Data = new CampaignData(Campaign.Data.GameMode);
        ForceClose();
    }

    public void Close()
    {
        if (!closing)
        {
            ForceClose();
        }
    }

    public void ForceClose()
    {
        closing = true;
        new Routine(SceneManager.Unload("ContinueRun"));
    }

    public void CheckMissingData(CampaignSaveData data)
    {
        if (HasMissingData(data))
        {
            continueButton.SetActive(false);
            missingDataDisplay.SetActive(true);
        }
    }

    public bool HasMissingData(CampaignSaveData data)
    {
        CharacterSaveData characterSaveData = data.characters[data.playerId];
        if (MissingCardSystem.HasMissingData(characterSaveData.inventoryData.deck) || MissingCardSystem.HasMissingData(characterSaveData.inventoryData.reserve))
        {
            return true;
        }
        CampaignNodeSaveData[] nodes = data.nodes;
        foreach (CampaignNodeSaveData campaignNodeSaveData in nodes)
        {
            if (!campaignNodeSaveData.cleared)
            {
                CampaignNode campaignNode = campaignNodeSaveData.Load();
                if (campaignNode.type.HasMissingData(campaignNode))
                {
                    return true;
                }
            }
        }
        return false;
    }
}
[RequireComponent(typeof(Image))]
public class ControllerButtonImage : MonoBehaviour
{
    [SerializeField]
    public bool deactivateIfNull = true;

    [SerializeField]
    public bool disableIfNull;

    public Image image;

    public string actionName { get; set; }

    public void OnEnable()
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Expected O, but got Unknown
        image = GetComponent<Image>();
        Events.OnButtonStyleChanged += new UnityAction(ButtonStyleChanged);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnButtonStyleChanged -= new UnityAction(ButtonStyleChanged);
    }

    public void Set(string actionName)
    {
        this.actionName = actionName;
        Sprite val = ControllerButtonSystem.Get(actionName);
        if (deactivateIfNull)
        {
            gameObject.SetActive((val));
        }
        if (disableIfNull)
        {
            ((Behaviour)image).enabled = (val);
        }
        if ((val))
        {
            image.sprite = val;
        }
    }

    public void ButtonStyleChanged()
    {
        if (!StringExt.IsNullOrWhitespace(actionName))
        {
            Set(actionName);
        }
    }
}
public class CurvedLinePoint : MonoBehaviour
{
    [HideInInspector]
    public bool showGizmo = true;

    [HideInInspector]
    public float gizmoSize = 0.1f;

    [HideInInspector]
    public Color gizmoColor = new Color(1f, 0f, 0f, 0.5f);

    public void OnDrawGizmos()
    {
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        if (showGizmo)
        {
            Gizmos.color = gizmoColor;
            Gizmos.DrawSphere(transform.position, gizmoSize);
        }
    }

    public void OnDrawGizmosSelected()
    {
        CurvedLineRenderer component = ((Component)transform.parent).GetComponent<CurvedLineRenderer>();
        if (component != null)
        {
            component.Update();
        }
    }
}
[RequireComponent(typeof(LineRenderer))]
public class CurvedLineRenderer : MonoBehaviour
{
    public float lineSegmentSize = 0.1f;

    public float lineWidth = 0.1f;

    public bool autoUpdate;

    public bool promptUpdate;

    [Header("Gizmos")]
    public bool showGizmos = true;

    public float gizmoSize = 0.1f;

    public Color gizmoColor = new Color(1f, 0f, 0f, 0.5f);

    public CurvedLinePoint[] linePoints = new CurvedLinePoint[0];

    public Vector3[] linePositions = (Vector3[])(object)new Vector3[0];

    public Vector3[] linePositionsOld = (Vector3[])(object)new Vector3[0];

    public void Update()
    {
        if (autoUpdate || promptUpdate)
        {
            UpdatePoints();
            promptUpdate = false;
        }
    }

    public void UpdatePoints()
    {
        GetPoints();
        SetPointsToLine();
    }

    public void GetPoints()
    {
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        linePoints = GetComponentsInChildren<CurvedLinePoint>();
        linePositions = (Vector3[])(object)new Vector3[linePoints.Length];
        for (int i = 0; i < linePoints.Length; i++)
        {
            linePositions[i] = ((Component)linePoints[i]).transform.localPosition;
        }
    }

    public void SetPointsToLine()
    {
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        if (linePositionsOld.Length != linePositions.Length)
        {
            linePositionsOld = (Vector3[])(object)new Vector3[linePositions.Length];
        }
        bool flag = false;
        for (int i = 0; i < linePositions.Length; i++)
        {
            if (linePositions[i] != linePositionsOld[i])
            {
                flag = true;
            }
        }
        if (flag)
        {
            LineRenderer component = GetComponent<LineRenderer>();
            Vector3[] array = LineSmoother.SmoothLine(linePositions, lineSegmentSize);
            component.positionCount = array.Length;
            component.SetPositions(array);
            component.startWidth = lineWidth;
            component.endWidth = lineWidth;
        }
    }

    public void OnDrawGizmosSelected()
    {
        Update();
    }

    public void OnDrawGizmos()
    {
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        if (linePoints.Length == 0)
        {
            GetPoints();
        }
        CurvedLinePoint[] array = linePoints;
        foreach (CurvedLinePoint obj in array)
        {
            obj.showGizmo = showGizmos;
            obj.gizmoSize = gizmoSize;
            obj.gizmoColor = gizmoColor;
        }
    }
}
public class LineSmoother : MonoBehaviour
{
    public static Vector3[] SmoothLine(Vector3[] inputPoints, float segmentSize)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Expected O, but got Unknown
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Expected O, but got Unknown
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Expected O, but got Unknown
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0083: Unknown result type (might be due to invalid IL or missing references)
        //IL_0088: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fe: Unknown result type (might be due to invalid IL or missing references)
        //IL_0114: Unknown result type (might be due to invalid IL or missing references)
        //IL_011e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0160: Unknown result type (might be due to invalid IL or missing references)
        AnimationCurve val = new AnimationCurve();
        AnimationCurve val2 = new AnimationCurve();
        AnimationCurve val3 = new AnimationCurve();
        Keyframe[] array = (Keyframe[])(object)new Keyframe[inputPoints.Length];
        Keyframe[] array2 = (Keyframe[])(object)new Keyframe[inputPoints.Length];
        Keyframe[] array3 = (Keyframe[])(object)new Keyframe[inputPoints.Length];
        for (int i = 0; i < inputPoints.Length; i++)
        {
            array[i] = new Keyframe((float)i, inputPoints[i].x);
            array2[i] = new Keyframe((float)i, inputPoints[i].y);
            array3[i] = new Keyframe((float)i, inputPoints[i].z);
        }
        val.keys = array;
        val2.keys = array2;
        val3.keys = array3;
        for (int j = 0; j < inputPoints.Length; j++)
        {
            val.SmoothTangents(j, 0f);
            val2.SmoothTangents(j, 0f);
            val3.SmoothTangents(j, 0f);
        }
        List<Vector3> list = new List<Vector3>();
        Vector3 item = default(Vector3);
        for (int k = 0; k < inputPoints.Length; k++)
        {
            list.Add(inputPoints[k]);
            if (k + 1 < inputPoints.Length)
            {
                int num = (int)(Vector3.Distance(inputPoints[k], inputPoints[k + 1]) / segmentSize);
                for (int l = 1; l < num; l++)
                {
                    float num2 = (float)l / (float)num + (float)k;
                    ((item))..ctor(val.Evaluate(num2), val2.Evaluate(num2), val3.Evaluate(num2));
                    list.Add(item);
                }
            }
        }
        return list.ToArray();
    }
}
public class DateTextSetter : MonoBehaviour
{
    [SerializeField]
    public TMP_Text textElement;

    public void OnEnable()
    {
        SetText(0);
    }

    public void SetText(int dayOffset)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        LocaleIdentifier identifier = LocalizationSettings.SelectedLocale.Identifier;
        CultureInfo cultureInfo = ((identifier)).CultureInfo;
        DateTime dateTime = DailyFetcher.GetDateTime().AddDays(dayOffset);
        textElement.text = dateTime.ToString("D", cultureInfo);
    }
}
public class DeckDisplayGroup : MonoBehaviour
{
    public TextMeshProUGUI titleElement;

    public CardContainerGrid[] grids;

    [SerializeField]
    public CardController cardController;

    public IEnumerator CreateCard(CardData data)
    {
        Card card = CardManager.Get(data, cardController, null, inPlay: false, isPlayerCard: true);
        AddCard(card);
        yield return card.UpdateData();
    }

    public CardContainerGrid GetGrid(Card card)
    {
        return GetGrid(card.entity.data);
    }

    public CardContainerGrid GetGrid(CardData cardData)
    {
        if (grids.Length <= 1 || !(cardData.cardType.tag == "Friendly"))
        {
            return grids[0];
        }
        return grids[1];
    }

    public void AddCard(Card card)
    {
        CardContainerGrid grid = GetGrid(card);
        grid.Add(card.entity);
        card.entity.owner = grid.owner;
    }

    public void InsertCard(int index, Card card)
    {
        CardContainerGrid grid = GetGrid(card);
        grid.Insert(index, card.entity);
        card.entity.owner = grid.owner;
    }

    public void RemoveCard(Card card)
    {
        GetGrid(card).Remove(card.entity);
    }

    public void UpdatePositions()
    {
        CardContainerGrid[] array = grids;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].SetChildPositions();
        }
    }

    public void Clear()
    {
        CardContainerGrid[] array = grids;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].DestroyAll();
        }
    }
}
public class Deckpack : MonoBehaviourSingleton<Deckpack>
{
    public Animator animator;

    [SerializeField]
    public Button button;

    public bool open;

    public static bool IsOpen => MonoBehaviourSingleton<Deckpack>.instance.open;

    public static void Open()
    {
        Events.InvokeDeckpackOpen();
        MonoBehaviourSingleton<Deckpack>.instance.animator.SetBool("Open", true);
        MonoBehaviourSingleton<Deckpack>.instance.open = true;
    }

    public static void Close()
    {
        Events.InvokeDeckpackClose();
        MonoBehaviourSingleton<Deckpack>.instance.animator.SetBool("Open", false);
        MonoBehaviourSingleton<Deckpack>.instance.open = false;
    }

    public void Ping()
    {
        animator.SetTrigger("Ping");
    }
}
public class DeckpackBlocker : MonoBehaviour
{
    public static uint open;

    public void OnEnable()
    {
        Block();
    }

    public void OnDisable()
    {
        Unblock();
    }

    public static void Block()
    {
        if (open++ == 0)
        {
            SetButtonsInteractable(interactable: false);
            InputSystem.reset = true;
        }
    }

    public static void Unblock()
    {
        if (--open == 0)
        {
            SetButtonsInteractable(interactable: true);
            InputSystem.reset = true;
        }
    }

    public static void SetButtonsInteractable(bool interactable)
    {
        GameObject[] array = GameObject.FindGameObjectsWithTag("Deckpack Interaction");
        for (int i = 0; i < array.Length; i++)
        {
            Selectable component = array[i].GetComponent<Selectable>();
            if (component != null)
            {
                component.interactable = interactable;
            }
        }
    }
}
public class EventPointerClick : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
    [SerializeField]
    public UnityEvent pointerClick;

    [SerializeField]
    public bool afterFrame;

    public void OnPointerClick(PointerEventData eventData)
    {
        if (afterFrame)
        {
            StartCoroutine(InvokeAfterFrame());
        }
        else
        {
            pointerClick.Invoke();
        }
    }

    public IEnumerator InvokeAfterFrame()
    {
        yield return (object)new WaitForEndOfFrame();
        pointerClick.Invoke();
    }
}
public class EventPointerDown : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
    [SerializeField]
    public UnityEvent pointerDown;

    [SerializeField]
    public bool afterFrame;

    public void OnPointerDown(PointerEventData eventData)
    {
        if (afterFrame)
        {
            StartCoroutine(InvokeAfterFrame());
        }
        else
        {
            pointerDown.Invoke();
        }
    }

    public IEnumerator InvokeAfterFrame()
    {
        yield return (object)new WaitForEndOfFrame();
        pointerDown.Invoke();
    }
}
public class EventPointerEnter : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler
{
    [SerializeField]
    public UnityEvent pointerEnter;

    [SerializeField]
    public bool afterFrame;

    public void OnPointerEnter(PointerEventData eventData)
    {
        if (afterFrame)
        {
            StartCoroutine(InvokeAfterFrame());
        }
        else
        {
            pointerEnter.Invoke();
        }
    }

    public IEnumerator InvokeAfterFrame()
    {
        yield return (object)new WaitForEndOfFrame();
        pointerEnter.Invoke();
    }
}
public class EventPointerExit : MonoBehaviour, IPointerExitHandler, IEventSystemHandler
{
    [SerializeField]
    public UnityEvent pointerExit;

    [SerializeField]
    public bool afterFrame;

    public void OnPointerExit(PointerEventData eventData)
    {
        if (afterFrame)
        {
            StartCoroutine(InvokeAfterFrame());
        }
        else
        {
            pointerExit.Invoke();
        }
    }

    public IEnumerator InvokeAfterFrame()
    {
        yield return (object)new WaitForEndOfFrame();
        pointerExit.Invoke();
    }
}
public class EventPointerUp : MonoBehaviour, IPointerUpHandler, IEventSystemHandler
{
    [SerializeField]
    public UnityEvent pointerUp;

    [SerializeField]
    public bool afterFrame;

    public void OnPointerUp(PointerEventData eventData)
    {
        if (afterFrame)
        {
            StartCoroutine(InvokeAfterFrame());
        }
        else
        {
            pointerUp.Invoke();
        }
    }

    public IEnumerator InvokeAfterFrame()
    {
        yield return (object)new WaitForEndOfFrame();
        pointerUp.Invoke();
    }
}
[RequireComponent(typeof(Graphic))]
public class Fader : MonoBehaviour
{
    public Graphic _graphic;

    [SerializeField]
    public Gradient gradient;

    [SerializeField]
    public bool startFadedIn;

    [SerializeField]
    public LeanTweenType ease = LeanTweenType.easeInOutQuad;

    [SerializeField]
    public float delay;

    [SerializeField]
    public float dur = 0.5f;

    [SerializeField]
    public bool onAwake;

    [SerializeField]
    public bool onEnable;

    [SerializeField]
    public bool loop;

    [SerializeField]
    public bool ignoreTimeScale;

    public float current;

    public Graphic graphic => _graphic ?? (_graphic = GetComponent<Graphic>());

    public void Awake()
    {
        Set(startFadedIn ? 1f : 0f);
        if (onAwake)
        {
            In();
        }
    }

    public void OnEnable()
    {
        if (onEnable)
        {
            Set(0f);
            In();
        }
    }

    public void Set(float value)
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        current = value;
        graphic.color = gradient.Evaluate(value);
    }

    public void In()
    {
        Tween(1f, dur, ease);
    }

    public void In(float dur)
    {
        Tween(1f, dur, ease);
    }

    public void In(float dur, LeanTweenType ease)
    {
        Tween(1f, dur, ease);
    }

    public void Out()
    {
        Tween(0f, dur, ease);
    }

    public void Out(float dur)
    {
        Tween(0f, dur, ease);
    }

    public void Out(float dur, LeanTweenType ease)
    {
        Tween(0f, dur, ease);
    }

    public void Tween(float to, float dur, LeanTweenType ease)
    {
        LeanTween.cancel(gameObject);
        LTDescr lTDescr = LeanTween.value(gameObject, current, to, dur).setDelay(delay).setEase(ease)
            .setOnUpdate(Set)
            .setIgnoreTimeScale(ignoreTimeScale);
        if (loop)
        {
            lTDescr.setLoopCount(-1);
        }
    }
}
public class Fitter : MonoBehaviourRect
{
    [SerializeField]
    public Fitter[] linkedFitters;

    public Vector2 padding;

    public bool widthFixed = true;

    [ShowIf("widthFixed")]
    public float fixedWidth = 2.4f;

    [HideIf("widthFixed")]
    public float minWidth = 2.4f;

    public bool heightFixed;

    [ShowIf("heightFixed")]
    public float fixedHeight = 0.5f;

    [HideIf("heightFixed")]
    public float minHeight = 0.5f;

    public void Fit(System.Action onComplete)
    {
        StartCoroutine(FitRoutine(onComplete));
    }

    public void SetSize(float w, float h)
    {
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        base.rectTransform.sizeDelta = new Vector2(w, h) + padding;
    }

    public virtual IEnumerator FitRoutine(System.Action onComplete)
    {
        float w = fixedWidth;
        float h = fixedHeight;
        if (!widthFixed && !heightFixed)
        {
            float num;
            float num2 = (num = ((Transform)base.rectTransform).localPosition.x);
            float num3;
            float num4 = (num3 = ((Transform)base.rectTransform).localPosition.y);
            foreach (RectTransform item in (Transform)base.rectTransform)
            {
                Vector2 val2 = item.sizeDelta * 0.5f;
                Vector3 localPosition = ((Transform)item).localPosition;
                num2 = Mathf.Min(num2, localPosition.x - val2.x);
                num4 = Mathf.Min(num4, localPosition.y - val2.y);
                num = Mathf.Max(num, localPosition.x + val2.x);
                num3 = Mathf.Max(num3, localPosition.y + val2.y);
            }
            w = num - num2;
            h = num3 - num4;
        }
        else
        {
            if (!widthFixed)
            {
                float num5;
                float num6 = (num5 = 0f);
                foreach (RectTransform item2 in (Transform)base.rectTransform)
                {
                    Vector2 val4 = item2.sizeDelta * 0.5f;
                    Vector3 localPosition2 = ((Transform)item2).localPosition;
                    num6 = Mathf.Min(num6, localPosition2.x - val4.x);
                    num5 = Mathf.Max(num5, localPosition2.x + val4.x);
                }
                w = Mathf.Max(minWidth, num5 - num6);
            }
            if (!heightFixed)
            {
                float num7;
                float num8 = (num7 = 0f);
                foreach (RectTransform item3 in (Transform)base.rectTransform)
                {
                    Vector2 val6 = item3.sizeDelta * 0.5f;
                    Vector3 localPosition3 = ((Transform)item3).localPosition;
                    num8 = Mathf.Min(num8, localPosition3.y - val6.y);
                    num7 = Mathf.Max(num7, localPosition3.y + val6.y);
                }
                h = Mathf.Max(minHeight, num7 - num8);
            }
        }
        SetSize(w, h);
        yield return UpdateLinkedFitters();
        onComplete?.Invoke();
    }

    public IEnumerator UpdateLinkedFitters()
    {
        Fitter[] array = linkedFitters;
        foreach (Fitter fitter in array)
        {
            yield return fitter.FitRoutine(null);
        }
    }
}
public class FlexibleGridLayout : LayoutGroup
{
    public enum FitType
    {
        Uniform,
        Width,
        Height,
        FixedRows,
        FixedColumns
    }

    public FitType fitType;

    public int rows;

    public int columns;

    public Vector2 cellSize;

    public Vector2 spacing;

    public bool autoSizeX;

    public bool autoSizeY;

    public override void CalculateLayoutInputHorizontal()
    {
        //IL_00cb: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e5: Unknown result type (might be due to invalid IL or missing references)
        CalculateLayoutInputHorizontal();
        autoSizeX = false;
        autoSizeY = false;
        if (fitType == FitType.Width || fitType == FitType.Height || fitType == FitType.Uniform)
        {
            autoSizeX = true;
            autoSizeY = true;
            float num = Mathf.Sqrt((float)transform.childCount);
            rows = Mathf.CeilToInt(num);
            columns = Mathf.CeilToInt(num);
        }
        switch (fitType)
        {
            case FitType.Width:
            case FitType.FixedColumns:
                rows = Mathf.CeilToInt((float)(transform.childCount / columns));
                break;
            case FitType.Height:
            case FitType.FixedRows:
                columns = Mathf.CeilToInt((float)(transform.childCount / rows));
                break;
        }
        Rect rect = rectTransform.rect;
        float width = ((rect)).width;
        rect = rectTransform.rect;
        float height = ((rect)).height;
        if (autoSizeX)
        {
            cellSize.x = width / (float)columns - spacing.x / (float)columns * (float)(columns - 1) - (float)(padding.left / columns) - (float)(padding.right / columns);
        }
        if (autoSizeY)
        {
            cellSize.y = height / (float)rows - spacing.y / (float)rows * (float)(columns - 1) - (float)(padding.top / rows) - (float)(padding.bottom / rows);
        }
        for (int i = 0; i < rectChildren.Count; i++)
        {
            int num2 = i / columns;
            int num3 = i % columns;
            RectTransform val = rectChildren[i];
            float num4 = cellSize.x * (float)num3 + spacing.x * (float)num3 + (float)padding.left;
            float num5 = cellSize.y * (float)num2 + spacing.y * (float)num2 + (float)padding.top;
            SetChildAlongAxis(val, 0, num4, cellSize.x);
            SetChildAlongAxis(val, 1, num5, cellSize.y);
        }
    }

    public override void CalculateLayoutInputVertical()
    {
    }

    public override void SetLayoutHorizontal()
    {
    }

    public override void SetLayoutVertical()
    {
    }
}
[RequireComponent(typeof(TMP_Text))]
public class FontSetter : MonoBehaviour
{
    public TMP_Text _textElement;

    public bool registered;

    public TMP_Text textElement => _textElement ?? (_textElement = GetComponent<TMP_Text>());

    public void OnEnable()
    {
        FontSetterSystem.Register(this);
        registered = true;
    }

    public void OnDisable()
    {
        if (registered)
        {
            FontSetterSystem.Unregister(this);
            registered = false;
        }
    }

    public void SetFont(TMP_FontAsset font)
    {
        textElement.font = font;
    }
}
public class GameUpdateDisplayer : MonoBehaviour
{
    [Serializable]
    public struct Update
    {
        public string buildNumber;

        public LocalizedString titleRef;

        public LocalizedString bodyRef;

        public float panelHeight;
    }

    [SerializeField]
    public GameObject display;

    [SerializeField]
    public SmoothScrollRect scrollRect;

    [SerializeField]
    public LocalizeStringEvent titleEvent;

    [SerializeField]
    public LocalizeStringEvent bodyEvent;

    [SerializeField]
    public Update[] updates;

    [Header("Beta Version")]
    [SerializeField]
    public Update beta;

    public void OnEnable()
    {
        display.SetActive(false);
        Events.OnSceneChanged += SceneChanged;
    }

    public void OnDisable()
    {
        Events.OnSceneChanged -= SceneChanged;
    }

    public void SceneChanged(Scene scene)
    {
        if (((scene)).name == "MainMenu")
        {
            Check();
        }
    }

    public void Check()
    {
        VersionCompatibility.GetVersions();
        foreach (Update item in updates.Reverse())
        {
            if (VersionCompatibility.currentVersion == item.buildNumber && int.TryParse(VersionCompatibility.currentVersion, out var result))
            {
                if (int.TryParse(VersionCompatibility.previousVersion, out var result2) && result2 > 0 && result2 < result)
                {
                    StartCoroutine(ShowRoutine(item));
                }
                else
                {
                    Hide();
                }
                return;
            }
        }
        Hide();
    }

    public IEnumerator ShowRoutine(Update update)
    {
        display.SetActive(true);
        titleEvent.StringReference = update.titleRef;
        bodyEvent.StringReference = update.bodyRef;
        Transform transform = ((Component)scrollRect).transform;
        RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
        if (val != null)
        {
            val.sizeDelta = Vector2Ext.WithY(val.sizeDelta, update.panelHeight);
        }
        yield return (object)new WaitForSeconds(0.35f);
        scrollRect.ScrollToTop();
    }

    public void Hide()
    {
        display.SetActive(false);
        gameObject.SetActive(false);
    }
}
[RequireComponent(typeof(GridLayoutGroup))]
public class GridLayoutBasedOnAspect : MonoBehaviour
{
    public GridLayoutGroup _layoutGroup;

    [SerializeField]
    public AnimationCurve curve;

    [SerializeField]
    public bool setSpacing;

    [SerializeField]
    [ShowIf("setSpacing")]
    public Vector2 minSpacing;

    [SerializeField]
    [ShowIf("setSpacing")]
    public Vector2 maxSpacing;

    [SerializeField]
    public bool autoLinkToParent;

    public GridLayoutGroup layoutGroup => _layoutGroup ?? (_layoutGroup = GetComponent<GridLayoutGroup>());

    public void Awake()
    {
        if (autoLinkToParent)
        {
            WorldSpaceCanvasFitScreen componentInParent = ((Component)transform).GetComponentInParent<WorldSpaceCanvasFitScreen>();
            if ((componentInParent))
            {
                componentInParent.onUpdate.AddListener((UnityAction<RectTransform>)UpdateLayout);
                UpdateLayout(componentInParent.rectTransform);
            }
        }
    }

    public void UpdateLayout(RectTransform canvas)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        Vector2 sizeDelta = canvas.sizeDelta;
        float num = sizeDelta.x / sizeDelta.y;
        float num2 = curve.Evaluate(num);
        if (setSpacing)
        {
            layoutGroup.spacing = minSpacing + (maxSpacing - minSpacing) * num2;
        }
    }
}
[RequireComponent(typeof(TMP_Text))]
public class HackedTextEffect : MonoBehaviour
{
    public TMP_Text _tmp;

    public char[] extraChars;

    public string[] extraCharColourHexes;

    public Vector2 delayBetweenRoutines = new Vector2(1f, 2f);

    public TMP_Text tmp => _tmp ?? (_tmp = GetComponent<TMP_Text>());

    public void SetText(string text)
    {
        StopAllCoroutines();
        StartRoutine(text);
    }

    public void StartRoutine(string text)
    {
        StartCoroutine(Routine(text));
    }

    public void OnDisable()
    {
        StopAllCoroutines();
    }

    public IEnumerator Routine(string text)
    {
        yield return Appear(text);
        while (true)
        {
            yield return (object)new WaitForSeconds(Vector2Ext.Random(delayBetweenRoutines));
            yield return Random.Choose<IEnumerator>(new IEnumerator[7]
            {
                LoopChars(text),
                AddCharsRandom(text),
                AppendChars(text),
                AddChar(text),
                ReplaceChar(text),
                ColourChar(text),
                Appear(text)
            });
        }
    }

    public IEnumerator Appear(string text)
    {
        for (int i = 1; i < text.Length; i++)
        {
            char c = Random.Choose<char>(new char[2]
            {
                IArrayExt.RandomItem<char>(extraChars),
                text[Mathf.Max(0, i - 1)]
            });
            tmp.text = text.Remove(i, 1).Insert(i, $"<#{IArrayExt.RandomItem<string>(extraCharColourHexes)}>{c}</color>");
            tmp.maxVisibleCharacters = i + 1;
            yield return (object)new WaitForSeconds(0.05f);
        }
        tmp.text = text;
        tmp.maxVisibleCharacters = 1000;
        yield return (object)new WaitForSeconds(1f);
    }

    public IEnumerator LoopChars(string text)
    {
        int count = Random.Choose<int>(new int[2]
        {
            text.Length,
            Random.Range(0, text.Length)
        });
        for (int i = 0; i < count; i++)
        {
            char c = Random.Choose<char>(new char[2]
            {
                IArrayExt.RandomItem<char>(extraChars),
                text[i]
            });
            tmp.text = text.Remove(i, 1).Insert(i, $"<#{IArrayExt.RandomItem<string>(extraCharColourHexes)}>{c}</color>");
            yield return (object)new WaitForSeconds(PettyRandom.Range(0.025f, 0.05f));
            tmp.text = text;
            yield return (object)new WaitForSeconds(PettyRandom.Range(0.025f, 0.05f));
        }
    }

    public IEnumerator AddCharsRandom(string text)
    {
        int count = PettyRandom.Range(5, 15);
        for (int i = 0; i < count; i++)
        {
            int num = text.RandomIndex();
            char c = Random.Choose<char>(new char[2]
            {
                IArrayExt.RandomItem<char>(extraChars),
                text[num]
            });
            tmp.text = text.Remove(num, 1).Insert(num, $"<#{IArrayExt.RandomItem<string>(extraCharColourHexes)}>{c}</color>");
            yield return (object)new WaitForSeconds(PettyRandom.Range(0.05f, 0.1f));
            tmp.text = text;
            yield return (object)new WaitForSeconds(0.1f);
        }
    }

    public IEnumerator AppendChars(string text)
    {
        int count = PettyRandom.Range(1, 3);
        char finalChar = text[^1];
        for (int i = 0; i < count; i++)
        {
            tmp.text += $"<#{IArrayExt.RandomItem<string>(extraCharColourHexes)}>{finalChar}</color>";
            yield return (object)new WaitForSeconds(PettyRandom.Range(0.1f, 0.2f));
        }
        yield return (object)new WaitForSeconds(0.3f);
        tmp.text = text;
    }

    public IEnumerator AddChar(string text)
    {
        int index = text.RandomIndex();
        char c = Random.Choose<char>(new char[2]
        {
            IArrayExt.RandomItem<char>(extraChars),
            text[index]
        });
        int count = Random.Choose<int>(new int[3] { 1, 2, 2 });
        for (int i = 0; i < count; i++)
        {
            tmp.text = tmp.text.Insert(index, $"<#{IArrayExt.RandomItem<string>(extraCharColourHexes)}>{c}</color>");
            yield return (object)new WaitForSeconds(PettyRandom.Range(1f, 2f));
        }
        tmp.text = text;
    }

    public IEnumerator ReplaceChar(string text)
    {
        int index = text.RandomIndex();
        char c = IArrayExt.RandomItem<char>(extraChars);
        tmp.text = text.Remove(index, 1).Insert(index, $"<#{IArrayExt.RandomItem<string>(extraCharColourHexes)}>{c}</color>");
        yield return (object)new WaitForSeconds(PettyRandom.Range(1f, 2f));
        tmp.text = text.Remove(index, 1).Insert(index, " ");
        yield return (object)new WaitForSeconds(1f);
    }

    public IEnumerator ColourChar(string text)
    {
        int index = text.RandomIndex();
        char c = text[index];
        string col = IArrayExt.RandomItem<string>(extraCharColourHexes);
        tmp.text = text.Remove(index, 1).Insert(index, $"<#{col}>{c}</color>");
        yield return (object)new WaitForSeconds(PettyRandom.Range(2f, 3f));
        int count = Random.Range(6, 10) * Random.Choose<int>(new int[6] { 1, 1, 1, 1, 1, 3 });
        for (int i = 0; i < count; i++)
        {
            tmp.text = text.Remove(index, 1).Insert(index, $"<#{col}>{IArrayExt.RandomItem<char>(extraChars)}</color>");
            yield return (object)new WaitForSeconds(PettyRandom.Range(0.025f, 0.05f));
        }
        yield return (object)new WaitForSeconds(1f);
        tmp.text = text;
    }
}
[RequireComponent(typeof(Image))]
public class HotKeyDisplay : MonoBehaviour
{
    public Image _image;

    [SerializeField]
    public string actionName;

    public Image image => _image ?? (_image = GetComponent<Image>());

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnButtonStyleChanged += new UnityAction(Refresh);
        Refresh();
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnButtonStyleChanged -= new UnityAction(Refresh);
    }

    public void Refresh()
    {
        if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            ((Behaviour)image).enabled = false;
            return;
        }
        JoystickButtonStyle.ElementButton element = ControllerButtonSystem.GetElement(RewiredControllerManager.GetPlayerController(0), actionName);
        ((Behaviour)image).enabled = element?.hasSprite ?? false;
        if (((Behaviour)image).enabled)
        {
            image.sprite = element.buttonSprite;
        }
    }

    public void SetActionName(string value)
    {
        actionName = value;
        Refresh();
    }
}
public class ImageCutout : ImageSprite
{
    public override Material materialForRendering
    {
        get
        {
            //IL_0015: Unknown result type (might be due to invalid IL or missing references)
            //IL_001a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0027: Expected O, but got Unknown
            if (!maskable)
            {
                return materialForRendering;
            }
            Material val = new Material(materialForRendering);
            val.SetInt("_StencilComp", 6);
            return val;
        }
    }
}
[RequireComponent(typeof(Image))]
public class ImageDropShadow : MonoBehaviourRect
{
    [SerializeField]
    public Vector2 offset = new Vector2(0.1f, -0.1f);

    [SerializeField]
    public Material shadowMaterial;

    [SerializeField]
    public Color shadowColor;

    public Image caster;

    public Image shadow;

    public RectTransform casterTransform;

    public RectTransform shadowTransform;

    public IEnumerator Start()
    {
        caster = GetComponent<Image>();
        casterTransform = base.rectTransform;
        shadowTransform = new GameObject("ImageDropShadow", new Type[1] { typeof(RectTransform) }).GetComponent<RectTransform>();
        ((Transform)shadowTransform).SetParent(((Transform)casterTransform).parent);
        ((Transform)shadowTransform).SetSiblingIndex(((Transform)casterTransform).GetSiblingIndex());
        yield return null;
        ((Transform)shadowTransform).localScale = Vector3.one;
        ((Transform)shadowTransform).localEulerAngles = Vector3.zero;
        shadow = ((Component)shadowTransform).gameObject.AddComponent<Image>();
        ((Graphic)shadow).raycastTarget = false;
        ((Graphic)shadow).material = shadowMaterial;
        shadow.sprite = caster.sprite;
        ((Graphic)shadow).color = shadowColor;
    }

    public void LateUpdate()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        shadowTransform.sizeDelta = casterTransform.sizeDelta;
        shadowTransform.anchoredPosition = casterTransform.anchoredPosition + offset;
        ((Transform)shadowTransform).rotation = ((Transform)casterTransform).rotation;
    }
}
public class ImageSprite : Image
{
    [SerializeField]
    public bool copySpriteSize = true;

    [SerializeField]
    public bool copySpritePivot = true;

    public void SetSprite(Sprite sprite)
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        ((Image)this).sprite = sprite;
        if ((sprite))
        {
            Rect rect = sprite.rect;
            Vector2 size = ((rect)).size;
            if (copySpritePivot)
            {
                Vector3 anchoredPosition3D = rectTransform.anchoredPosition3D;
                rectTransform.pivot = sprite.pivot / size;
                rectTransform.anchoredPosition3D = anchoredPosition3D;
            }
            if (copySpriteSize)
            {
                rectTransform.sizeDelta = size / sprite.pixelsPerUnit;
            }
        }
    }
}
[RequireComponent(typeof(TMP_InputField))]
public class InputFieldKeepFocus : MonoBehaviour
{
    public TMP_InputField _i;

    public PointerEventData _e;

    public bool focused;

    public TMP_InputField i => _i ?? (_i = GetComponent<TMP_InputField>());

    public PointerEventData e
    {
        get
        {
            //IL_0010: Unknown result type (might be due to invalid IL or missing references)
            //IL_0015: Unknown result type (might be due to invalid IL or missing references)
            //IL_0017: Expected O, but got Unknown
            //IL_001c: Expected O, but got Unknown
            PointerEventData obj = _e;
            if (obj == null)
            {
                PointerEventData val = new PointerEventData(EventSystem.current);
                PointerEventData val2 = val;
                _e = val;
                obj = val2;
            }
            return obj;
        }
    }

    public void Update()
    {
        if (!focused)
        {
            if (!i.isFocused)
            {
                Debug.Log(("[" + name + "] is not focused! Attempting to select"));
                i.OnPointerClick(e);
            }
            if (i.isFocused)
            {
                focused = true;
            }
        }
    }

    public void OnDisable()
    {
        focused = false;
    }
}
[ExecuteInEditMode]
public class Journal : MonoBehaviour
{
    [SerializeField]
    public JournalTab openOnEnable;

    [SerializeField]
    public Transform leftPageGroup;

    [SerializeField]
    public Transform rightPageGroup;

    [SerializeField]
    public Image page;

    [SerializeField]
    public EventReference closeSfxRef;

    public void OnEnable()
    {
        if (Application.isPlaying)
        {
            if ((openOnEnable))
            {
                openOnEnable.Select();
            }
            SfxSystem.OneShot("event:/sfx/ui/journal_open");
        }
    }

    public void OnDisable()
    {
        if ((openOnEnable))
        {
            openOnEnable.Select();
        }
    }

    public void PagedOpened(JournalPage page)
    {
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        if (!(((Component)page).transform.parent == leftPageGroup))
        {
            return;
        }
        foreach (Transform item in rightPageGroup)
        {
            JournalPage component = ((Component)item).GetComponent<JournalPage>();
            if (component != null && ((Component)component).gameObject.activeSelf)
            {
                component.Close();
            }
        }
    }

    public void SetPageImage(Sprite sprite)
    {
        page.sprite = sprite;
    }

    public void Close()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        SfxSystem.OneShot(closeSfxRef);
    }
}
public class JournalCard : MonoBehaviour
{
    [SerializeField]
    public TMP_Text nameText;

    [SerializeField]
    public Image background;

    [SerializeField]
    public Image image;

    [SerializeField]
    public Button button;

    [SerializeField]
    public Material discoveredMaterial;

    [SerializeField]
    public Image frame;

    [SerializeField]
    public Sprite[] frames;

    public CardData cardData;

    public bool discovered;

    public void SetCardArt(CardData cardData, float scale)
    {
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        this.cardData = cardData;
        background.sprite = cardData.backgroundSprite;
        image.sprite = cardData.mainSprite;
        ((Component)background).transform.localScale = Vector3.one * scale;
        ((Component)image).transform.localScale = Vector3.one * scale;
        CreatedByLookup.TryGetCreatedByRoot((cardData).name, out var rootCardDataName);
        int frameLevel = CardFramesSystem.GetFrameLevel(rootCardDataName);
        frame.sprite = frames[frameLevel];
    }

    public void CheckDiscovered(List<string> discoveredCards, JournalCardManager manager)
    {
        if (!discovered && discoveredCards.Contains((cardData).name))
        {
            SetDiscovered(cardData.title, manager);
        }
    }

    public void SetDiscovered(string title, JournalCardManager manager)
    {
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Expected O, but got Unknown
        discovered = true;
        nameText.text = title;
        ((Behaviour)background).enabled = true;
        ((Graphic)image).material = discoveredMaterial;
        ((Graphic)image).color = Color.white;
        ((UnityEvent)button.onClick).AddListener((UnityAction)delegate
        {
            manager.Select(cardData);
        });
    }
}
public class JournalCardDisplay : MonoBehaviour
{
    [Serializable]
    public struct PositionProfile
    {
        public RectTransform[] transforms;

        public Vector3[] anchoredPositions;

        public void Set()
        {
            //IL_0013: Unknown result type (might be due to invalid IL or missing references)
            //IL_0018: Unknown result type (might be due to invalid IL or missing references)
            for (int i = 0; i < transforms.Length; i++)
            {
                transforms[i].anchoredPosition = (anchoredPositions[i]);
            }
        }
    }

    [SerializeField]
    public CardInspector inspector;

    [SerializeField]
    public PositionProfile normalPositionProfile;

    [SerializeField]
    public PositionProfile bigPositionProfile;

    [Header("Card Info Elements")]
    [SerializeField]
    public TMP_Text nameText;

    [SerializeField]
    public ImageSprite typeIcon;

    [SerializeField]
    public TMP_Text typeText;

    public CanvasGroup _canvasGroup;

    public Card current;

    public readonly Vector3 from = new Vector3(0.75f, 0.75f, 0.75f);

    public CanvasGroup canvasGroup => _canvasGroup ?? (_canvasGroup = GameObjectExt.GetOrAdd<CanvasGroup>(gameObject));

    public void OnDisable()
    {
        if ((current))
        {
            nameText.text = "";
            ((Behaviour)typeIcon).enabled = false;
            typeText.text = "";
            inspector.ClearPopups();
            CardManager.ReturnToPoolNextFrame(current);
            current = null;
        }
    }

    public void Display(CardData cardData)
    {
        if ((current))
        {
            if ((current.entity.data) && (cardData) && (current.entity.data).name == (cardData).name)
            {
                return;
            }
            CardManager.ReturnToPool(current);
        }
        current = CardManager.Get(cardData, null, null, inPlay: false, isPlayerCard: true);
        current.transform.SetParent(transform);
        if (current.entity.height == 2)
        {
            bigPositionProfile.Set();
        }
        else
        {
            normalPositionProfile.Set();
        }
        StopAllCoroutines();
        StartCoroutine(UpdateCard(current));
    }

    public IEnumerator UpdateCard(Card card)
    {
        yield return card.UpdateData();
        nameText.text = card.entity.data.title;
        ((Behaviour)typeIcon).enabled = true;
        typeIcon.SetSprite(card.entity.data.cardType.icon);
        typeText.text = card.entity.data.cardType.title;
        card.transform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
        card.transform.localScale = Vector3.one;
        inspector.ClearPopups();
        inspector.CreatePopups(card.entity);
        LeanTween.cancel(gameObject);
        transform.localScale = from;
        LeanTween.scale(gameObject, Vector3.one, 0.2f).setEaseOutBack().setIgnoreTimeScale(useUnScaledTime: true);
        canvasGroup.alpha = 0f;
        LeanTween.alphaCanvas(canvasGroup, 1f, 0.2f).setEaseOutBack().setIgnoreTimeScale(useUnScaledTime: true);
    }
}
public class JournalCardManager : MonoBehaviour
{
    [SerializeField]
    public JournalCardManagerPopulator populator;

    [SerializeField]
    public string[] categoryNames = new string[3] { "Friendly", "Item", "Clunker" };

    [SerializeField]
    public JournalCard cardPrefab;

    [SerializeField]
    public Transform content;

    [SerializeField]
    public Scroller scroller;

    [SerializeField]
    public JournalCardDisplay cardDisplay;

    [SerializeField]
    public Button[] tabs;

    [SerializeField]
    public GameObject[] tabSelected;

    [SerializeField]
    public RewiredHotKeyController hotKeyTabLeft;

    [SerializeField]
    public RewiredHotKeyController hotKeyTabRight;

    [SerializeField]
    public EventReference selectCardSfxEvent;

    public List<string> discovered;

    public int currentCategory;

    public readonly List<AsyncOperationHandle<CardData>> handles = new List<AsyncOperationHandle<CardData>>();

    public readonly List<JournalCard> cardIcons = new List<JournalCard>();

    public Locale locale;

    public static readonly Dictionary<string, float> scaleOverride = new Dictionary<string, float> { { "FinalBoss2", 1.3f } };

    public bool requiresRebuild;

    public bool subbed;

    public void OnEnable()
    {
        if (!subbed)
        {
            Events.OnModLoaded += ModToggled;
            Events.OnModUnloaded += ModToggled;
            subbed = true;
        }
        if (requiresRebuild)
        {
            if (!populator.populated)
            {
                populator.Populate();
            }
            CreateCards(currentCategory);
            requiresRebuild = false;
            StartCoroutine(ScrollToTop());
            return;
        }
        discovered = SaveSystem.LoadProgressData<List<string>>("cardsDiscovered");
        if (discovered != null)
        {
            foreach (JournalCard cardIcon in cardIcons)
            {
                cardIcon.CheckDiscovered(discovered, this);
            }
        }
        else
        {
            discovered = new List<string>();
        }
        if (locale != null && locale != LocalizationSettings.SelectedLocale)
        {
            locale = LocalizationSettings.SelectedLocale;
            CreateCards(currentCategory);
        }
    }

    public void ModToggled(WildfrostMod mod)
    {
        requiresRebuild = true;
    }

    public void Start()
    {
        CreateCards(0);
        locale = LocalizationSettings.SelectedLocale;
    }

    public void CreateCards(string categoryName)
    {
        for (int i = 0; i < categoryNames.Length; i++)
        {
            if (categoryNames[i] == categoryName)
            {
                if (i != currentCategory)
                {
                    CreateCards(i);
                }
                break;
            }
        }
    }

    public void CreateCards(int categoryIndex)
    {
        currentCategory = categoryIndex;
        TransformExt.DestroyAllChildren(content);
        cardIcons.Clear();
        foreach (KeyValuePair<string, CardData> item in LoadCardData(populator.GetCategory(categoryNames[categoryIndex])))
        {
            item.Deconstruct(out var key, out var value);
            string title = key;
            CardData cardData = value;
            JournalCard journalCard = Object.Instantiate<JournalCard>(cardPrefab, content);
            cardIcons.Add(journalCard);
            float value2;
            float scale = (scaleOverride.TryGetValue((cardData).name, out value2) ? value2 : 1f);
            journalCard.SetCardArt(cardData, scale);
            if (discovered.Contains((cardData).name))
            {
                journalCard.SetDiscovered(title, this);
            }
        }
        StartCoroutine(ScrollToTop());
    }

    public static List<KeyValuePair<string, CardData>> LoadCardData(JournalCardManagerPopulator.Category category)
    {
        List<KeyValuePair<string, CardData>> list = new List<KeyValuePair<string, CardData>>();
        foreach (string cardName in category.cardNames)
        {
            CardData cardData = AddressableLoader.Get<CardData>("CardData", cardName);
            list.Add(new KeyValuePair<string, CardData>(cardData.title, cardData));
        }
        return list.OrderBy((KeyValuePair<string, CardData> a) => a.Key).ToList();
    }

    public IEnumerator ScrollToTop()
    {
        yield return (object)new WaitForEndOfFrame();
        scroller.ScrollImmediate(100f);
    }

    public void Select(CardData cardData)
    {
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        cardDisplay.Display(cardData);
        SfxSystem.OneShot(selectCardSfxEvent);
    }

    public void SelectTab(int index)
    {
        CreateCards(index);
        GameObject[] array = tabSelected;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].SetActive(false);
        }
        tabSelected[index].SetActive(true);
    }

    public void NextTab()
    {
        currentCategory++;
        if (currentCategory >= categoryNames.Length)
        {
            currentCategory -= categoryNames.Length;
        }
        SelectTab(currentCategory);
    }

    public void PreviousTab()
    {
        currentCategory--;
        if (currentCategory < 0)
        {
            currentCategory += categoryNames.Length;
        }
        SelectTab(currentCategory);
    }
}
public class JournalCardManagerPopulator : MonoBehaviour
{
    [Serializable]
    public class Category
    {
        public string name;

        public bool enemy;

        public string[] cardTypes;

        public List<string> cardNames;

        public bool CheckAdd(CardData cardData, bool enemy)
        {
            if (this.enemy == enemy && IArrayExt.Contains<string>(cardTypes, (cardData.cardType).name))
            {
                cardNames.Add((cardData).name);
                return true;
            }
            return false;
        }
    }

    [SerializeField]
    public Category[] categories;

    public bool subbed;

    public bool populated { get; set; }

    public void OnEnable()
    {
        if (!subbed)
        {
            Events.OnModLoaded += ModToggled;
            Events.OnModUnloaded += ModToggled;
            subbed = true;
        }
        if (!populated)
        {
            Populate();
        }
    }

    public void ModToggled(WildfrostMod mod)
    {
        if (populated)
        {
            Clear();
        }
    }

    public void Clear()
    {
        Category[] array = categories;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].cardNames.Clear();
        }
        populated = false;
    }

    public void Populate()
    {
        populated = true;
        StopWatch.Start();
        List<string> usedCards = new List<string>();
        List<string> playerCards = new List<string>();
        List<string> list = new List<string>();
        ClassData[] classes = References.Classes;
        foreach (ClassData classData in classes)
        {
            foreach (CardData item in classData.startingInventory.deck)
            {
                StoreAsPlayerCard(item);
            }
            foreach (CardData item2 in classData.startingInventory.reserve)
            {
                StoreAsPlayerCard(item2);
            }
            RewardPool[] rewardPools = classData.rewardPools;
            foreach (RewardPool rewardPool in rewardPools)
            {
                if (list.Contains((rewardPool).name))
                {
                    continue;
                }
                list.Add((rewardPool).name);
                foreach (DataFile item3 in rewardPool.list)
                {
                    if (item3 is CardData cardData2)
                    {
                        StoreAsPlayerCard(cardData2);
                    }
                }
            }
        }
        foreach (CardData item4 in AddressableLoader.GetGroup<CardData>("CardData"))
        {
            if (!(item4.mainSprite == null) && !((item4.mainSprite).name == "Nothing"))
            {
                string name = (item4.cardType).name;
                if ((!(name == "Boss") && !(name == "BossSmall")) || !((item4).name != "FinalBoss2"))
                {
                    name = (item4.cardType).name;
                    bool flag = name == "Friendly" || name == "Item" || playerCards.Contains((item4).name);
                    ProcessCard(item4, !flag);
                }
            }
        }
        foreach (BattleData item5 in AddressableLoader.GetGroup<BattleData>("BattleData"))
        {
            BattleWavePoolData[] pools = item5.pools;
            for (int i = 0; i < pools.Length; i++)
            {
                BattleWavePoolData.Wave[] waves = pools[i].waves;
                for (int j = 0; j < waves.Length; j++)
                {
                    foreach (CardData unit in waves[j].units)
                    {
                        if ((unit) && unit.cardType.miniboss)
                        {
                            string name = (unit.cardType).name;
                            if (name == "Boss" || name == "BossSmall")
                            {
                                ProcessCard(unit, enemy: true);
                            }
                        }
                    }
                }
            }
        }
        Debug.Log($"Journal Card Manager Population Done! ({StopWatch.Stop()}ms)");
        void ProcessCard(CardData cardData, bool enemy)
        {
            if (!usedCards.Contains((cardData).name))
            {
                usedCards.Add((cardData).name);
                Category[] array = categories;
                for (int k = 0; k < array.Length && !array[k].CheckAdd(cardData, enemy); k++)
                {
                }
            }
        }
        void StoreAsPlayerCard(CardData cardData)
        {
            if (!(cardData) || playerCards.Contains((cardData).name))
            {
                return;
            }
            playerCards.Add((cardData).name);
            foreach (string createdByThi in CreatedByLookup.GetCreatedByThis((cardData).name))
            {
                playerCards.Add(createdByThi);
            }
        }
    }

    public Category GetCategory(string name)
    {
        Category[] array = categories;
        foreach (Category category in array)
        {
            if (category.name == name)
            {
                return category;
            }
        }
        return null;
    }
}
public class JournalCharm : MonoBehaviourRect
{
    public Vector2 popUpOffset = new Vector2(1f, 0f);

    [SerializeField]
    public Image image;

    [SerializeField]
    public Material discoveredMaterial;

    public CardUpgradeData upgradeData;

    public bool discovered;

    public bool hover;

    public void OnDisable()
    {
        UnHover();
    }

    public void Assign(CardUpgradeData upgradeData)
    {
        this.upgradeData = upgradeData;
        image.sprite = this.upgradeData.image;
    }

    public void CheckDiscovered(List<string> discoveredCharms)
    {
        if (!discovered && discoveredCharms.Contains((upgradeData).name))
        {
            SetDiscovered();
        }
    }

    public void SetDiscovered()
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        discovered = true;
        ((Graphic)image).material = discoveredMaterial;
        ((Graphic)image).color = Color.white;
    }

    public void Hover()
    {
        if (discovered)
        {
            hover = true;
            CardPopUp.AssignTo(base.rectTransform, popUpOffset.x, popUpOffset.y);
            CardPopUp.AddPanel((upgradeData).name, upgradeData.title, upgradeData.text);
        }
    }

    public void UnHover()
    {
        if (discovered && hover)
        {
            hover = false;
            CardPopUp.RemovePanel((upgradeData).name);
        }
    }
}
public class JournalCharmManager : MonoBehaviour
{
    [SerializeField]
    public JournalCharm charmPrefab;

    [SerializeField]
    public Transform content;

    [SerializeField]
    public SmoothScrollRect scrollRect;

    public List<string> discovered;

    public readonly List<JournalCharm> charmIcons = new List<JournalCharm>();

    public Locale locale;

    public void OnEnable()
    {
        discovered = SaveSystem.LoadProgressData<List<string>>("charmsDiscovered");
        if (discovered != null)
        {
            foreach (JournalCharm charmIcon in charmIcons)
            {
                charmIcon.CheckDiscovered(discovered);
            }
        }
        else
        {
            discovered = new List<string>();
        }
        CardPopUp.SetCanvasLayer("PauseMenu", 1);
        CardPopUp.SetIgnoreTimeScale(ignore: true);
        if (locale == null || locale != LocalizationSettings.SelectedLocale)
        {
            locale = LocalizationSettings.SelectedLocale;
            CreateCharms();
        }
    }

    public void OnDisable()
    {
        CardPopUp.Reset();
    }

    public void CreateCharms()
    {
        TransformExt.DestroyAllChildren(content);
        charmIcons.Clear();
        foreach (KeyValuePair<string, CardUpgradeData> item in LoadCharmData())
        {
            JournalCharm journalCharm = Object.Instantiate<JournalCharm>(charmPrefab, content);
            charmIcons.Add(journalCharm);
            journalCharm.Assign(item.Value);
            if (discovered.Contains((item.Value).name))
            {
                journalCharm.SetDiscovered();
            }
        }
        scrollRect.ScrollToTop();
    }

    public static List<KeyValuePair<string, CardUpgradeData>> LoadCharmData()
    {
        return (from a in (from a in AddressableLoader.GetGroup<CardUpgradeData>("CardUpgradeData")
                           where a.type == CardUpgradeData.Type.Charm && a.tier >= -2
                           select a).ToDictionary((CardUpgradeData a) => a.title, (CardUpgradeData a) => a)
                orderby a.Value.tier >= 0 descending, a.Key
                select a).ToList();
    }
}
public class JournalIconGroup : MonoBehaviour
{
    [SerializeField]
    public List<ButtonAnimator> buttons;

    [SerializeField]
    public Image[] icons;

    [SerializeField]
    public Color baseColour = Color.white;

    [SerializeField]
    public Color highlightColour = Color.white;

    public ButtonAnimator currentHover;

    public Image highlightedIcon;

    public void Awake()
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        Image[] array = icons;
        for (int i = 0; i < array.Length; i++)
        {
            ((Graphic)array[i]).color = baseColour;
        }
    }

    public void Update()
    {
        if (currentHover == null)
        {
            ButtonAnimator buttonAnimator = buttons.FirstOrDefault((ButtonAnimator a) => a.IsHoveredOrPressed);
            if (buttonAnimator != null)
            {
                currentHover = buttonAnimator;
                Changed();
            }
        }
        else if (!currentHover.IsHoveredOrPressed)
        {
            currentHover = null;
            Changed();
        }
    }

    public void Changed()
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        if (highlightedIcon != null)
        {
            ((Graphic)highlightedIcon).color = baseColour;
        }
        if (currentHover != null)
        {
            int num = buttons.IndexOf(currentHover);
            highlightedIcon = icons[num];
            ((Graphic)highlightedIcon).color = highlightColour;
        }
    }
}
public class JournalTab : MonoBehaviour
{
    [SerializeField]
    public ButtonType type = ButtonType.Sub;

    [SerializeField]
    public GameObject tweenTarget;

    [SerializeField]
    public Image image;

    [SerializeField]
    public UINavigationItem nav;

    [SerializeField]
    public bool selected;

    [SerializeField]
    public GameObject selectedGroup;

    [SerializeField]
    public GameObject unselectedGroup;

    [SerializeField]
    public UnityEvent onSelect;

    [SerializeField]
    public Transform[] unselectGroups;

    [Header("Colours")]
    [SerializeField]
    public Color baseColour;

    [SerializeField]
    public Color highlightColour;

    [SerializeField]
    public Color pressColour;

    [SerializeField]
    public Color disabledColour;

    public bool _interactable = true;

    public bool hover;

    public bool press;

    public bool interactable
    {
        get
        {
            return _interactable;
        }
        set
        {
            if (value)
            {
                SetUnHighlighted();
            }
            else
            {
                SetDisabled();
            }
            _interactable = value;
            if (nav != null)
            {
                ((Behaviour)nav).enabled = value;
            }
        }
    }

    public void OnEnable()
    {
        SetSelected();
    }

    public void Hover()
    {
        if (!hover && interactable)
        {
            hover = true;
            if (!press)
            {
                HoverTween();
                SetHighlighted();
                Events.InvokeButtonHover(type);
            }
        }
    }

    public void UnHover()
    {
        if (hover)
        {
            hover = false;
            if (!press)
            {
                UnHoverTween();
                SetUnHighlighted();
            }
        }
    }

    public void Press()
    {
        if (!press && interactable)
        {
            press = true;
            PressTween();
            SetPressed();
            Events.InvokeButtonPress(type);
        }
    }

    public void Release()
    {
        if (press)
        {
            press = false;
            if (hover)
            {
                SfxSystem.OneShot("event:/sfx/ui/journal_click");
                Select();
                SetHighlighted();
                HoverTween();
            }
            else
            {
                SetUnHighlighted();
                ReleaseTween();
            }
        }
    }

    public void Select()
    {
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        Transform[] array = unselectGroups;
        for (int i = 0; i < array.Length; i++)
        {
            foreach (Transform item in array[i])
            {
                JournalTab component = ((Component)item).GetComponent<JournalTab>();
                if (component != null && component.selected)
                {
                    component.Deselect();
                }
            }
        }
        selected = true;
        SetSelected();
        UnityEvent obj = onSelect;
        if (obj != null)
        {
            obj.Invoke();
        }
    }

    public void Deselect()
    {
        selected = false;
        SetSelected();
    }

    public void HoverTween()
    {
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(tweenTarget);
        LeanTween.scale(tweenTarget, new Vector3(1.05f, 1.05f, 1f), 0.2f).setIgnoreTimeScale(useUnScaledTime: true).setEaseOutBack();
    }

    public void UnHoverTween()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(tweenTarget);
        LeanTween.scale(tweenTarget, Vector3.one, 0.05f).setIgnoreTimeScale(useUnScaledTime: true);
    }

    public void PressTween()
    {
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(tweenTarget);
        LeanTween.scale(tweenTarget, new Vector3(0.95f, 0.95f, 1f), 0.05f).setIgnoreTimeScale(useUnScaledTime: true);
    }

    public void ReleaseTween()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(tweenTarget);
        LeanTween.scale(tweenTarget, Vector3.one, 0.05f).setIgnoreTimeScale(useUnScaledTime: true);
    }

    public void SetHighlighted()
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        if (image != null)
        {
            ((Graphic)image).color = highlightColour;
        }
    }

    public void SetUnHighlighted()
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        if (image != null)
        {
            ((Graphic)image).color = baseColour;
        }
    }

    public void SetPressed()
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        if (image != null)
        {
            ((Graphic)image).color = pressColour;
        }
    }

    public void SetDisabled()
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        if (image != null)
        {
            ((Graphic)image).color = disabledColour;
        }
    }

    public void SetSelected()
    {
        selectedGroup.SetActive(selected);
        unselectedGroup.SetActive(!selected);
    }
}
public class LeaderNameHistoryDisplay : MonoBehaviour
{
    [SerializeField]
    public LeaderNameHistoryEntry namePrefab;

    public void OnEnable()
    {
        Populate();
    }

    public void OnDisable()
    {
        TransformExt.DestroyAllChildren(transform);
    }

    public void Populate()
    {
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        List<JournalNameHistory.Name> list = SaveSystem.LoadProgressData<List<JournalNameHistory.Name>>("leaderNameHistory");
        if (list == null)
        {
            return;
        }
        Transform transform = transform;
        foreach (JournalNameHistory.Name item in list)
        {
            LeaderNameHistoryEntry leaderNameHistoryEntry = Object.Instantiate<LeaderNameHistoryEntry>(namePrefab, transform);
            ((Component)leaderNameHistoryEntry).transform.localPosition = (item.position);
            leaderNameHistoryEntry.Assign(item);
        }
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void AddName()
    {
        if (PettyRandom.Range(0f, 1f) > 0.25f)
        {
            JournalNameHistory.MostRecentNameKilled();
        }
        else
        {
            JournalNameHistory.MostRecentNameMissing();
        }
        JournalNameHistory.FadePrevious();
        JournalNameHistory.AddName(Names.Pull("SnowdwellerMale"));
        Repopulate();
    }

    public void Repopulate()
    {
        TransformExt.DestroyAllChildren(transform);
        Populate();
    }
}
public class LeaderNameHistoryEntry : MonoBehaviour
{
    [SerializeField]
    public Transform offset;

    [SerializeField]
    public TMP_Text textElement;

    [SerializeField]
    public AnimationCurve scaleCurve;

    [SerializeField]
    public Gradient colour;

    [SerializeField]
    public Gradient missingColour;

    public void Assign(JournalNameHistory.Name name)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cf: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b2: Unknown result type (might be due to invalid IL or missing references)
        offset.localPosition = (name.offset);
        offset.localEulerAngles = Vector2Ext.WithZ(Vector2.zero, name.angle);
        offset.localScale = Vector3.one * scaleCurve.Evaluate(name.opacity);
        textElement.text = name.text;
        if (name.killed)
        {
            textElement.fontStyle = (FontStyles)64;
        }
        if (name.missing)
        {
            TMP_Text obj = textElement;
            obj.text += " ?";
            ((Graphic)textElement).color = missingColour.Evaluate(name.opacity);
        }
        else
        {
            ((Graphic)textElement).color = colour.Evaluate(name.opacity);
        }
    }
}
public class LorePage : MonoBehaviour
{
    public LorePageManager manager;

    public JournalPageData pageData;

    [SerializeField]
    public GameObject lockedDisplay;

    [SerializeField]
    public GameObject unlockedDisplay;

    [SerializeField]
    public GameObject newDisplay;

    public Button button;

    public Canvas canvas;

    public bool isUnlocked;

    public bool isNew;

    [SerializeField]
    public TweenUI denyTween;

    [SerializeField]
    public TweenUI newTween;

    public void Awake()
    {
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        ((Component)button).transform.localEulerAngles = new Vector3(0f, 0f, PettyRandom.Range(-1f, 1f) * 2f);
    }

    public void SetUnlocked(JournalPageData pageData, bool value)
    {
        this.pageData = pageData;
        isUnlocked = value;
        ((Selectable)button).interactable = value;
        lockedDisplay.SetActive(!value);
        unlockedDisplay.SetActive(value);
    }

    public void SetNew(bool value)
    {
        isNew = value;
        newDisplay.SetActive(value);
        if (value)
        {
            newTween.Fire();
        }
    }

    public void Select()
    {
        if (isUnlocked)
        {
            manager.Select(this);
            return;
        }
        denyTween.Fire();
        SfxSystem.OneShot("event:/sfx/ui/deny");
    }
}
public class LorePageManager : MonoBehaviour
{
    [SerializeField]
    public GameObject focusLayer;

    [SerializeField]
    public Transform focusLayerPageHolder;

    [SerializeField]
    public AssetReferenceT<JournalPageData>[] pages;

    [SerializeField]
    public AddressableReleaser assetReleaser;

    [SerializeField]
    public EventReference selectSfxEvent;

    [SerializeField]
    public EventReference deselectSfxEvent;

    [SerializeField]
    public EventReference newSfxEvent;

    [SerializeField]
    public SfxLoop newLoop;

    public readonly List<GameObject> pageObjects = new List<GameObject>();

    public LorePage current;

    public Canvas focus;

    public bool focusLayerActive;

    public List<string> inspected;

    public int newCount;

    public void OnEnable()
    {
        inspected = SaveSystem.LoadProgressData<List<string>>("lorePagesInspected");
        if (inspected == null)
        {
            inspected = new List<string>();
        }
        Populate();
    }

    public void OnDisable()
    {
        foreach (GameObject pageObject in pageObjects)
        {
            GameObjectExt.Destroy(pageObject);
        }
        pageObjects.Clear();
        DisableFocusLayer();
    }

    public void Populate()
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fe: Unknown result type (might be due to invalid IL or missing references)
        newCount = 0;
        List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
        AssetReferenceT<JournalPageData>[] array = pages;
        for (int i = 0; i < array.Length; i++)
        {
            AsyncOperationHandle<JournalPageData> val = array[i].LoadAssetAsync();
            JournalPageData journalPageData = val.WaitForCompletion();
            AsyncOperationHandle<GameObject> val2 = ((AssetReference)journalPageData.prefabRef).InstantiateAsync(transform, false);
            LorePage component = val2.WaitForCompletion().GetComponent<LorePage>();
            component.manager = this;
            pageObjects.Add(((Component)component).gameObject);
            if (unlockedList.Contains((journalPageData.unlock).name))
            {
                bool flag = !inspected.Contains((journalPageData.unlock).name);
                component.SetUnlocked(journalPageData, value: true);
                component.SetNew(flag);
                if (flag)
                {
                    newCount++;
                }
            }
            assetReleaser.Add(AsyncOperationHandle<GameObject>.op_Implicit(val2));
            assetReleaser.Add(AsyncOperationHandle<JournalPageData>.op_Implicit(val));
        }
        if (newCount > 0)
        {
            SfxSystem.OneShot(newSfxEvent);
            newLoop.Play();
        }
    }

    public void Select(LorePage lorePage)
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f6: Unknown result type (might be due to invalid IL or missing references)
        //IL_011c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0142: Unknown result type (might be due to invalid IL or missing references)
        if (focusLayerActive || !lorePage.isUnlocked)
        {
            return;
        }
        current = lorePage;
        focus = lorePage.canvas;
        SfxSystem.OneShot(selectSfxEvent);
        if (lorePage.isNew)
        {
            lorePage.SetNew(value: false);
            inspected.Add((lorePage.pageData.unlock).name);
            SaveSystem.SaveProgressData("lorePagesInspected", inspected);
            if (--newCount <= 0)
            {
                newLoop.Stop();
            }
        }
        focusLayerActive = true;
        focusLayer.SetActive(true);
        focus.overrideSorting = true;
        focus.sortingLayerName = "PauseMenu";
        focus.sortingOrder = 11;
        ((Component)focus).transform.SetParent(focusLayerPageHolder);
        LeanTween.cancel(((Component)focus).gameObject);
        LeanTween.moveLocal(((Component)focus).gameObject, Vector3.zero, 0.3f).setEaseOutQuint().setIgnoreTimeScale(useUnScaledTime: true);
        LeanTween.scale(((Component)focus).gameObject, Vector3.one, 0.3f).setEaseOutQuint().setIgnoreTimeScale(useUnScaledTime: true);
        LeanTween.rotateLocal(((Component)focus).gameObject, Vector3.zero, 0.6f).setEaseOutBack().setIgnoreTimeScale(useUnScaledTime: true);
    }

    public void DisableFocusLayer()
    {
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
        if (focusLayerActive)
        {
            SfxSystem.OneShot(deselectSfxEvent);
            focus.overrideSorting = false;
            focus.sortingOrder = 1;
            ((Component)focus).transform.SetParent(((Component)current.button).transform);
            LeanTween.cancel(((Component)focus).gameObject);
            LeanTween.moveLocal(((Component)focus).gameObject, Vector3.zero, 0.1f).setEaseOutQuad().setIgnoreTimeScale(useUnScaledTime: true);
            LeanTween.scale(((Component)focus).gameObject, Vector3.one, 0.1f).setEaseOutQuad().setIgnoreTimeScale(useUnScaledTime: true);
            LeanTween.rotateLocal(((Component)focus).gameObject, Vector3.zero, 0.1f).setEaseOutQuad().setIgnoreTimeScale(useUnScaledTime: true);
            focusLayerActive = false;
            focusLayer.SetActive(false);
            current = null;
            focus = null;
        }
    }
}
public class OverallStatsDisplay : MonoBehaviour
{
    [SerializeField]
    public GameStatData[] stats;

    [SerializeField]
    public int statsPerGroup = 20;

    [SerializeField]
    public TMP_Text[] nameGroups;

    [SerializeField]
    public TMP_Text[] valueGroups;

    [SerializeField]
    public float lineHeight = 0.34f;

    public static readonly Dictionary<string, bool> localesCentred = new Dictionary<string, bool>
    {
        { "en", false },
        { "zh-Hans", true },
        { "zh-Hant", true },
        { "ko", true },
        { "ja", true }
    };

    public static bool centred;

    public void OnEnable()
    {
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        Dictionary<string, bool> dictionary = localesCentred;
        LocaleIdentifier identifier = LocalizationSettings.SelectedLocale.Identifier;
        dictionary.TryGetValue(((identifier)).Code, out centred);
        Clear();
        Populate();
    }

    public void Populate()
    {
        StopWatch.Start();
        CampaignStats campaignStats = OverallStatsSystem.Get().Clone();
        List<string> list = new List<string> { "GameModeNormal", "GameModeDaily", "GameModeTutorial" };
        GameMode gameMode = null;
        if (Campaign.Data != null && (References.Campaign) && References.Campaign.result == Campaign.Result.None)
        {
            list.Remove((Campaign.Data.GameMode).name);
            OverallStatsSystem.Combine(campaignStats, StatsSystem.Get());
            gameMode = Campaign.Data.GameMode;
        }
        foreach (string item in list)
        {
            if (gameMode != null && item == (gameMode).name)
            {
                continue;
            }
            GameMode gameMode2 = AddressableLoader.Get<GameMode>("GameMode", item);
            if (SaveSystem.CampaignExists(gameMode2) && Campaign.CheckContinue(gameMode2))
            {
                CampaignStats campaignStats2 = SaveSystem.LoadCampaignData<CampaignStats>(gameMode2, "stats");
                if (campaignStats2 != null)
                {
                    OverallStatsSystem.Combine(campaignStats, campaignStats2);
                }
            }
        }
        int num = 0;
        int num2 = 0;
        TMP_Text val = nameGroups[num2];
        TMP_Text val2 = valueGroups[num2];
        GameStatData[] array = stats;
        foreach (GameStatData gameStatData in array)
        {
            if (!(gameStatData))
            {
                TMP_Text obj = val;
                obj.text += "<br>";
                if (!centred)
                {
                    TMP_Text obj2 = val2;
                    obj2.text += "<br>";
                }
            }
            else
            {
                string localizedString = gameStatData.stringKey.GetLocalizedString();
                localizedString = StringExt.Format(localizedString, new object[1] { centred ? ("<#fff>" + gameStatData.GetStringValue(campaignStats, gameStatData.GetValue(campaignStats)) + "</color><br>") : "<br>" });
                TMP_Text obj3 = val;
                obj3.text += localizedString;
                if (!centred)
                {
                    TMP_Text obj4 = val2;
                    obj4.text = obj4.text + gameStatData.GetStringValue(campaignStats, gameStatData.GetValue(campaignStats)) + "<br>";
                }
            }
            if (++num > statsPerGroup)
            {
                num = 0;
                if (++num2 >= nameGroups.Length)
                {
                    break;
                }
                val = nameGroups[num2];
                val2 = valueGroups[num2];
            }
        }
        Debug.Log($"OverallStatsDisplay → Populated ({StopWatch.Stop()}ms)");
    }

    public void Clear()
    {
        TMP_Text[] array = nameGroups;
        foreach (TMP_Text val in array)
        {
            val.text = $"<line-height={lineHeight}>";
            if (centred)
            {
                val.text += "<align=center>";
            }
        }
        array = valueGroups;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].text = $"<line-height={lineHeight}>";
        }
    }
}
[ExecuteInEditMode]
public class JournalPage : MonoBehaviour
{
    [SerializeField]
    public Journal journal;

    [SerializeField]
    public Sprite pageSprite;

    [SerializeField]
    public JournalPage alsoOpen;

    public void Open()
    {
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        if (gameObject.activeSelf)
        {
            return;
        }
        foreach (Transform item in transform.parent)
        {
            ((Component)item).gameObject.SetActive(false);
        }
        gameObject.SetActive(true);
        journal.PagedOpened(this);
        if ((pageSprite))
        {
            journal.SetPageImage(pageSprite);
        }
        if (alsoOpen != null)
        {
            alsoOpen.Open();
        }
    }

    public void Close()
    {
        gameObject.SetActive(false);
    }
}
public class JournalPageMenu : JournalPage
{
}
public class LargeUIScaler : WorldSpaceCanvasUpdater
{
    [SerializeField]
    public bool setScale = true;

    [SerializeField]
    [ShowIf("setScale")]
    [FormerlySerializedAs("scaleMinV")]
    public Vector3 scaleMin = Vector3.one;

    [SerializeField]
    [ShowIf("setScale")]
    [FormerlySerializedAs("scaleMaxV")]
    public Vector3 scaleMax = Vector3.one;

    [SerializeField]
    public bool setPosition;

    [SerializeField]
    [ShowIf("setPosition")]
    public Vector3 positionMin;

    [SerializeField]
    [ShowIf("setPosition")]
    public Vector3 positionMax;

    [SerializeField]
    public AnimationCurve aspectRatioInfluence;

    public override void UpdateSize()
    {
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        if (setScale || setPosition)
        {
            float num = 0f;
            if (aspectRatioInfluence.length > 0)
            {
                num *= aspectRatioInfluence.Evaluate(WorldSpaceCanvasFitScreenSystem.AspectRatio);
            }
            if (setScale)
            {
                ((Transform)base.rectTransform).localScale = Vector3.Lerp(scaleMin, scaleMax, num);
            }
            if (setPosition)
            {
                base.rectTransform.anchoredPosition3D = Vector3.Lerp(positionMin, positionMax, num);
            }
        }
    }
}
public class LargeUIScaleUpdater : MonoBehaviour
{
    [SerializeField]
    public Vector3 scaleMin = Vector3.one;

    [SerializeField]
    public Vector3 scaleMax = Vector3.one;

    [SerializeField]
    public Vector3 positionMin;

    [SerializeField]
    public Vector3 positionMax;

    public Transform _transform;

    public Transform t => _transform ?? (_transform = transform);

    public void PromptUpdate()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        t.localScale = Vector3.Lerp(scaleMin, scaleMax, 0f);
        t.localPosition = Vector3.Lerp(positionMin, positionMax, 0f);
    }
}
public class LayoutFixer : MonoBehaviourRect
{
    public enum Prompt
    {
        None,
        All,
        Horizontal,
        Vertical
    }

    [SerializeField]
    public bool unlimitedDepth = true;

    [SerializeField]
    [HideIf("unlimitedDepth")]
    public int depth;

    public Prompt prompt;

    public void Update()
    {
        if (prompt != 0)
        {
            switch (prompt)
            {
                case Prompt.All:
                    DoAll();
                    break;
                case Prompt.Horizontal:
                    DoHorizontal();
                    break;
                case Prompt.Vertical:
                    DoVertical();
                    break;
            }
            prompt = Prompt.None;
        }
    }

    public void Fix()
    {
        prompt = Prompt.All;
    }

    public void FixHorizontal()
    {
        prompt = Prompt.Horizontal;
    }

    public void FixVertical()
    {
        prompt = Prompt.Vertical;
    }

    public void DoAll()
    {
        if (unlimitedDepth)
        {
            RectTransformExt.FixLayoutGroups(base.rectTransform);
        }
        else
        {
            RectTransformExt.FixLayoutGroups(base.rectTransform, depth);
        }
    }

    public void DoHorizontal()
    {
        StopAllCoroutines();
        StartCoroutine(FixHorizontalRoutine());
    }

    public void DoVertical()
    {
        StopAllCoroutines();
        StartCoroutine(FixVerticalRoutine());
    }

    public IEnumerator FixHorizontalRoutine()
    {
        if (depth <= 0 && !unlimitedDepth)
        {
            ContentSizeFitter fitter = GetComponent<ContentSizeFitter>();
            if (fitter != null)
            {
                FitMode pre = fitter.horizontalFit;
                fitter.horizontalFit = (FitMode)0;
                yield return null;
                fitter.horizontalFit = pre;
            }
        }
        else
        {
            RectTransformExt.DisableContentFitters(base.rectTransform);
            yield return null;
            RectTransformExt.EnableContentFitters(base.rectTransform);
        }
    }

    public IEnumerator FixVerticalRoutine()
    {
        if (depth <= 0 && !unlimitedDepth)
        {
            ContentSizeFitter fitter = GetComponent<ContentSizeFitter>();
            if (fitter != null)
            {
                FitMode pre = fitter.verticalFit;
                fitter.verticalFit = (FitMode)0;
                yield return null;
                fitter.verticalFit = pre;
            }
        }
        else
        {
            RectTransformExt.DisableContentFitters(base.rectTransform);
            yield return null;
            RectTransformExt.EnableContentFitters(base.rectTransform);
        }
    }
}
[ExecuteInEditMode]
public class LayoutLink : MonoBehaviourRect
{
    [FormerlySerializedAs("layoutTransform")]
    public RectTransform link;

    public float lerp = 0.1f;

    public bool setPositionOnEnable = true;

    public Vector3 offset;

    [Header("Link to layout element to update layout element size")]
    public LayoutElement layoutElement;

    [ShowIf("HasLayoutElement")]
    public bool setLayoutWidth;

    [ShowIf("HasLayoutElement")]
    public bool setLayoutHeight;

    public bool HasLayoutElement => layoutElement != null;

    public void OnEnable()
    {
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        if (setPositionOnEnable && link != null)
        {
            ((Transform)base.rectTransform).position = ((Transform)link).position + offset;
        }
    }

    public void LateUpdate()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        ((Transform)base.rectTransform).position = Delta.Lerp(((Transform)base.rectTransform).position, ((Transform)link).position + offset, lerp, Time.deltaTime);
    }

    public void Update()
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        if (HasLayoutElement)
        {
            Vector2 sizeDelta = base.rectTransform.sizeDelta;
            if (setLayoutWidth)
            {
                layoutElement.preferredWidth = sizeDelta.x;
            }
            if (setLayoutHeight)
            {
                layoutElement.preferredHeight = sizeDelta.y;
            }
        }
    }
}
public class LeaderboardsEntry : MonoBehaviour
{
    [SerializeField]
    public Color playerBgColor;

    [SerializeField]
    public Graphic background;

    [SerializeField]
    public TMP_Text nameText;

    [SerializeField]
    public TMP_Text rankText;

    [SerializeField]
    public TMP_Text scoreText;

    [SerializeField]
    public TMP_Text timeText;

    public void Set(bool isPlayer, string name, int rank, object score, string timeString)
    {
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        if (isPlayer)
        {
            background.color = playerBgColor;
        }
        nameText.text = name;
        rankText.text = $"#{rank}";
        scoreText.text = score.ToString();
        timeText.text = timeString;
    }
}
public class LeaderboardsPanel : MonoBehaviour
{
    [SerializeField]
    public GameObject loading;

    [SerializeField]
    public GameObject noEntries;

    [SerializeField]
    public GameObject noConnection;

    [SerializeField]
    public GameObject tooManyRequests;

    [SerializeField]
    public Transform entriesGroup;

    [SerializeField]
    public DateTextSetter dateTextSetter;

    [SerializeField]
    public LeaderboardsFetcher fetcher;

    [SerializeField]
    public LeaderboardsEntry entryPrefab;

    [SerializeField]
    public bool fetchEveryTime = true;

    [SerializeField]
    public int entriesPerPage = 10;

    [SerializeField]
    public LeaderboardsFetcher.Type type;

    [Header("Buttons")]
    [SerializeField]
    public ButtonAnimator globalButton;

    [SerializeField]
    public ButtonAnimator friendsButton;

    [SerializeField]
    public ButtonAnimator playerRankButton;

    [SerializeField]
    public ButtonAnimator nextPageButton;

    [SerializeField]
    public ButtonAnimator prePageButton;

    [SerializeField]
    public ButtonAnimator nextDayButton;

    [SerializeField]
    public ButtonAnimator preDayButton;

    public int page;

    public int dayOffset;

    public int playerRankPage;

    public const int maxDayOffset = 100;

    public int maxPage = 9999;

    public bool fetched;

    public bool fetch
    {
        get
        {
            if (fetched)
            {
                return fetchEveryTime;
            }
            return true;
        }
    }

    public void OnEnable()
    {
        page = 0;
        dayOffset = 0;
        nextDayButton.interactable = false;
        if (fetch)
        {
            Clear();
            StartCoroutine(Fetch(aroundPlayer: true));
        }
    }

    public void OnDisable()
    {
        StopAllCoroutines();
    }

    public void Clear()
    {
        noEntries.SetActive(false);
        noConnection.SetActive(false);
        tooManyRequests.SetActive(false);
        TransformExt.DestroyAllChildren(entriesGroup);
        prePageButton.interactable = false;
        nextPageButton.interactable = false;
    }

    public IEnumerator Fetch(bool aroundPlayer)
    {
        yield break;
    }

    public void Populate(IReadOnlyCollection<LeaderboardEntry> entries)
    {
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0052: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        bool flag = entries != null && entries.Count > 0;
        noEntries.SetActive(!flag);
        if (!flag)
        {
            return;
        }
        foreach (LeaderboardEntry entry in entries)
        {
            LeaderboardsEntry leaderboardsEntry = Object.Instantiate<LeaderboardsEntry>(entryPrefab, entriesGroup);
            Friend user = entry.User;
            bool isMe = ((user)).IsMe;
            user = entry.User;
            leaderboardsEntry.Set(isMe, ((user)).Name, entry.GlobalRank, entry.Score, SecondsToTimeString(entry.Details[0]));
        }
    }

    public void PreviousDay()
    {
        if (dayOffset < 100)
        {
            SetDayOffset(dayOffset + 1);
            Refetch(aroundPlayer: true);
        }
    }

    public void NextDay()
    {
        if (dayOffset > 0)
        {
            SetDayOffset(dayOffset - 1);
            Refetch(aroundPlayer: true);
        }
    }

    public void SetDayOffset(int value)
    {
        dayOffset = value;
        dateTextSetter.SetText(-dayOffset);
        fetcher.ResetPlayerRank();
        maxPage = 0;
        type = LeaderboardsFetcher.Type.Global;
        SetPage(0);
        playerRankButton.interactable = false;
        preDayButton.interactable = dayOffset < 100;
        nextDayButton.interactable = dayOffset > 0;
    }

    public void NextPage()
    {
        if (page < maxPage)
        {
            SetPage(page + 1);
            Refetch(aroundPlayer: false);
        }
    }

    public void PreviousPage()
    {
        if (page > 0)
        {
            SetPage(page - 1);
            Refetch(aroundPlayer: false);
        }
    }

    public void SetPage(int value)
    {
        page = value;
        nextPageButton.interactable = page < maxPage;
        prePageButton.interactable = page > 0;
    }

    public void Global()
    {
        if (type != 0 || page > 0)
        {
            type = LeaderboardsFetcher.Type.Global;
            SetPage(0);
            Refetch(aroundPlayer: false);
        }
    }

    public void Friends()
    {
        if (type != LeaderboardsFetcher.Type.Friends)
        {
            type = LeaderboardsFetcher.Type.Friends;
            SetPage(0);
            Refetch(aroundPlayer: false);
        }
    }

    public void JumpToPlayer()
    {
        if (fetcher.playerHasRank && page != playerRankPage)
        {
            type = LeaderboardsFetcher.Type.Global;
            SetPage(playerRankPage);
            Refetch(aroundPlayer: false);
        }
    }

    public void Refetch(bool aroundPlayer)
    {
        Clear();
        StopAllCoroutines();
        StartCoroutine(Fetch(aroundPlayer));
    }

    public static string SecondsToTimeString(int seconds)
    {
        float num = (float)seconds / 60f / 60f;
        int num2 = Mathf.FloorToInt(num);
        int num3 = Mathf.FloorToInt((num - (float)num2) * 60f);
        if (num2 <= 0)
        {
            return $"{num3}m";
        }
        return $"{num2}h {num3}m";
    }
}
public class MainMenu : Menu
{
    public GameObject playButton;

    public GameObject continueButton;

    public GameObject modsButton;

    public bool skipTutorial = true;

    public bool tutorial
    {
        get
        {
            if (!skipTutorial)
            {
                return SaveSystem.LoadProgressData("tutorialProgress", 0) == 0;
            }
            return false;
        }
    }

    public void Start()
    {
        modsButton.SetActive(true);
        skipTutorial = false;
    }

    public void Play()
    {
        if (tutorial)
        {
            StartGame("GameModeTutorial");
        }
        else
        {
            GoToTown();
        }
    }

    public void Credits()
    {
        if (active)
        {
            StartCoroutine(CreditsRoutine());
        }
    }

    public IEnumerator CreditsRoutine()
    {
        active = false;
        yield return SceneManager.Load("Credits", SceneType.Temporary);
        yield return SceneManager.WaitUntilUnloaded("Credits");
        active = true;
    }

    public void Settings()
    {
        Object.FindObjectOfType<PauseMenu>(true)?.Settings();
    }
}
public class Menu : MonoBehaviour
{
    [SerializeField]
    public HelpPanelShower retryTutorialHelp;

    public bool active = true;

    public void GoTo(string sceneName)
    {
        if (active)
        {
            new Routine(Transition.To(sceneName));
            active = false;
        }
    }

    public void StartGameOrContinue()
    {
        StartGameOrContinue("GameModeNormal");
    }

    public void StartGameOrContinue(string gameModeName, bool skipTutorial = false)
    {
        //IL_0083: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Expected O, but got Unknown
        //IL_009c: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a6: Expected O, but got Unknown
        GameMode gameMode = AddressableLoader.Get<GameMode>("GameMode", "GameModeTutorial");
        if (Campaign.CheckContinue(gameMode))
        {
            Campaign.Data = CampaignData.Load(gameMode);
            new Routine(SceneManager.Load("ContinueRun", SceneType.Temporary));
        }
        else if (!skipTutorial && SaveSystem.LoadProgressData("tutorialProgress", 0) <= 1 && (retryTutorialHelp))
        {
            retryTutorialHelp.Show();
            retryTutorialHelp.AddButton(0, HelpPanelSystem.ButtonType.Positive, (UnityAction)delegate
            {
                StartGame("GameModeTutorial");
            });
            retryTutorialHelp.AddButton(1, HelpPanelSystem.ButtonType.Negative, (UnityAction)delegate
            {
                SaveSystem.SaveProgressData("tutorialProgress", 2);
                Events.InvokeTutorialSkip();
                StartGameOrContinue(gameModeName, skipTutorial: true);
            });
        }
        else
        {
            GameMode gameMode2 = AddressableLoader.Get<GameMode>("GameMode", gameModeName);
            if (Campaign.CheckContinue(gameMode2))
            {
                Campaign.Data = CampaignData.Load(gameMode2);
                new Routine(SceneManager.Load("ContinueRun", SceneType.Temporary));
            }
            else
            {
                StartGame(gameMode2);
            }
        }
    }

    public void StartGame()
    {
        StartGame("GameModeNormal");
    }

    public void StartGame(string gameModeName)
    {
        GameMode gameMode = AddressableLoader.Get<GameMode>("GameMode", gameModeName);
        StartGame(gameMode);
    }

    public void StartGame(GameMode gameMode)
    {
        SaveSystem.DeleteCampaign(gameMode);
        Events.InvokeCampaignDeleted();
        Campaign.Data = new CampaignData(gameMode);
        GoTo(gameMode.startScene);
    }

    public void GoToTown()
    {
        GoTo("Town");
    }

    public void ExitGame()
    {
        if (active)
        {
            GameManager.Quit();
        }
    }

    public virtual void Open()
    {
        gameObject.SetActive(true);
        active = true;
    }

    public void Close()
    {
        gameObject.SetActive(false);
        active = false;
    }

    public void Toggle()
    {
        if (gameObject.activeSelf)
        {
            Close();
        }
        else
        {
            Open();
        }
    }
}
public class PauseMenu : Menu
{
    [SerializeField]
    public ButtonAnimator backToMenuButton;

    [SerializeField]
    public ButtonAnimator quickRestartButton;

    [SerializeField]
    public bool freezeTimeScale = true;

    [SerializeField]
    public JournalTab battleLogTab;

    [SerializeField]
    public JournalTab settingsTab;

    [SerializeField]
    public JournalTab lorePageTab;

    public static int blocked;

    [SerializeField]
    public bool doButtonLogic = true;

    public void OnEnable()
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        if (doButtonLogic)
        {
            Scene val = SceneManager.GetActive();
            switch (((val)).name)
            {
                case "MainMenu":
                    backToMenuButton.interactable = false;
                    quickRestartButton.interactable = false;
                    break;
                case "CharacterSelect":
                case "ContinueRun":
                case "Town":
                case "Cards":
                    backToMenuButton.interactable = true;
                    quickRestartButton.interactable = false;
                    break;
                default:
                    backToMenuButton.interactable = true;
                    quickRestartButton.interactable = Campaign.Data != null && Campaign.Data.GameMode.canRestart;
                    break;
            }
        }
        GameManager.paused = true;
        if (freezeTimeScale)
        {
            Time.timeScale = 0f;
        }
    }

    public void OnDisable()
    {
        GameManager.paused = false;
        if (freezeTimeScale)
        {
            Time.timeScale = 1f;
        }
    }

    public void GoToMainMenu()
    {
        if (active)
        {
            ((MonoBehaviour)MonoBehaviourSingleton<Transition>.instance).StartCoroutine(SceneManager.Unload("Mods"));
            ((MonoBehaviour)MonoBehaviourSingleton<Transition>.instance).StartCoroutine(SceneManager.Load("MainMenu", SceneType.Active));
        }
    }

    public void BackToMainMenu()
    {
        if (active)
        {
            if ((References.Campaign) && !Campaign.Data.GameMode.doSave)
            {
                References.Campaign.End(Campaign.Result.None);
                JournalNameHistory.MostRecentNameKilled();
            }
            new Routine(Sequences.EndCampaign("MainMenu"));
            active = false;
            Events.InvokeBackToMainMenu();
        }
    }

    public void QuickRestart()
    {
        if (active)
        {
            if ((References.Campaign))
            {
                References.Campaign.End(Campaign.Result.Restart);
                JournalNameHistory.MostRecentNameKilled();
            }
            Campaign.Data = new CampaignData(Campaign.Data.GameMode);
            new Routine(Sequences.EndCampaign("CharacterSelect"));
            active = false;
        }
    }

    public void BattleLog()
    {
        if (!gameObject.activeSelf)
        {
            Open();
            battleLogTab.Select();
        }
    }

    public void Settings()
    {
        if (!gameObject.activeSelf)
        {
            Open();
            settingsTab.Select();
        }
    }

    public void OpenLorePages()
    {
        if (!gameObject.activeSelf)
        {
            Open();
            lorePageTab.Select();
        }
    }

    public override void Open()
    {
        if (blocked <= 0)
        {
            base.Open();
        }
    }

    public static void Block()
    {
        blocked++;
        PauseMenu[] array = Object.FindObjectsOfType<PauseMenu>();
        for (int i = 0; i < array.Length; i++)
        {
            array[i].Close();
        }
    }

    public static void Unblock()
    {
        blocked--;
    }
}
public class MetaprogressSequence : MonoBehaviour
{
    [SerializeField]
    public Animator animator;

    [SerializeField]
    public GameObject tweener;

    [SerializeField]
    public float startDelay = 1f;

    [SerializeField]
    public float endDelay = 0.5f;

    [SerializeField]
    public Image progressImage;

    [SerializeField]
    public Vector2 randomizeProgress = new Vector2(0.9f, 1.1f);

    [SerializeField]
    public GainUnlockSequence gainUnlockSequence;

    [SerializeField]
    public ParticleSystem particleSystem;

    public float targetFillAmount;

    public const float progressPerParticle = 0.02f;

    public bool running { get; set; }

    public IEnumerator Start()
    {
        yield return Sequence();
    }

    public IEnumerator Sequence(float? amount = null)
    {
        running = true;
        yield return AddressableLoader.LoadGroup("UnlockData");
        List<string> alreadyUnlocked = MetaprogressionSystem.GetUnlockedList();
        List<UnlockData> remainingUnlocks = MetaprogressionSystem.GetRemainingUnlocks(alreadyUnlocked);
        Debug.Log(string.Format("{0} Remaining Unlocks: {1}", remainingUnlocks.Count, string.Join(", ", remainingUnlocks)));
        RemoveIneligibleUnlocks(remainingUnlocks, alreadyUnlocked);
        Debug.Log(string.Format("{0} Eligible Unlocks: {1}", remainingUnlocks.Count, string.Join(", ", remainingUnlocks)));
        Progression townProgress = SaveSystem.LoadProgressData("townProgress", new Progression(0f, 1f, 0f));
        progressImage.fillAmount = ((remainingUnlocks.Count > 0) ? townProgress.ProgressToNextUnlock() : 1f);
        if (remainingUnlocks.Count > 0)
        {
            yield return (object)new WaitForSeconds(startDelay);
            float num = StatsSystem.Get().Count("battlesWon");
            float num2 = 7f;
            float num3;
            if (!amount.HasValue)
            {
                num3 = ((num > 0f) ? (Mathf.Round((num + 1f) / num2 * 3f * 3f) / 3f * 2f) : 0f);
            }
            else
            {
                float valueOrDefault = amount.GetValueOrDefault();
                num3 = valueOrDefault;
            }
            float num4 = num3 * Vector2Ext.Random(randomizeProgress);
            List<float> list = new List<float>();
            List<UnlockData> getUnlocks = new List<UnlockData>();
            float num5 = num4;
            while (remainingUnlocks.Count > 0)
            {
                float num6 = townProgress.required - townProgress.current;
                float num7 = Mathf.Min(num5, num6);
                num5 -= num7;
                townProgress.current += num7;
                list.Add(townProgress.ProgressToNextUnlock());
                if (!townProgress.RequirementMet())
                {
                    break;
                }
                townProgress.SetNextRequirement();
                UnlockData unlock = GetUnlock(remainingUnlocks);
                if (unlock != null)
                {
                    getUnlocks.Add(unlock);
                    alreadyUnlocked.Add((unlock).name);
                    MetaprogressionSystem.SetUnlocksReady((unlock).name);
                    Debug.Log($"Unlocking {unlock}");
                }
            }
            SaveSystem.SaveProgressData("townProgress", townProgress);
            SaveSystem.SaveProgressData("unlocked", alreadyUnlocked);
            Debug.Log(("Progressing: " + string.Join(", ", list)));
            foreach (float item in list)
            {
                float progressToAdd = (targetFillAmount = item) - progressImage.fillAmount;
                if (progressToAdd > 0f)
                {
                    Events.InvokeProgressStart(progressImage.fillAmount);
                }
                int particles = Mathf.CeilToInt(progressToAdd / 0.02f);
                if (particles > 0)
                {
                    animator.SetBool("Increasing", true);
                    while (particles > 0)
                    {
                        particleSystem.Emit(1);
                        yield return (object)new WaitForSeconds(Random.Range(0.02f, 0.03f));
                        particles--;
                    }
                }
                yield return (object)new WaitUntil((Func<bool>)(() => !(particleSystem) || particleSystem.particleCount <= 0));
                Fill(targetFillAmount);
                animator.SetBool("Increasing", false);
                if (progressToAdd > 0f)
                {
                    Events.InvokeProgressStop();
                }
                if (getUnlocks.Count > 0)
                {
                    Events.InvokeProgressDing();
                    Ping();
                    getUnlocks.RemoveAt(0);
                    yield return (object)new WaitForSeconds(1.5f);
                    if (getUnlocks.Count > 0 || remainingUnlocks.Count > 0)
                    {
                        progressImage.fillAmount = 0f;
                    }
                }
            }
        }
        yield return (object)new WaitForSeconds(endDelay);
        running = false;
    }

    public static UnlockData GetUnlock(IList<UnlockData> orderedList)
    {
        if (orderedList == null || orderedList.Count <= 0)
        {
            return null;
        }
        List<int> list = new List<int> { 0 };
        float lowPriority = orderedList[0].lowPriority;
        int count = orderedList.Count;
        for (int i = 1; i < count; i++)
        {
            if (orderedList[i].lowPriority <= lowPriority)
            {
                list.Add(i);
            }
        }
        int index = IListExt.RandomItem<int>((IList<int>)list);
        UnlockData result = orderedList[index];
        orderedList.RemoveAt(index);
        return result;
    }

    public static void RemoveIneligibleUnlocks(IList<UnlockData> remainingUnlocks, ICollection<string> alreadyUnlocked)
    {
        for (int num = remainingUnlocks.Count - 1; num >= 0; num--)
        {
            if (!MetaprogressionSystem.CheckUnlockRequirements(remainingUnlocks[num], alreadyUnlocked))
            {
                remainingUnlocks.RemoveAt(num);
            }
        }
    }

    public void OnParticleCollision(GameObject other)
    {
        if (!(other != ((Component)particleSystem).gameObject))
        {
            float amount = ((Math.Abs(progressImage.fillAmount - targetFillAmount) < 0.02f) ? targetFillAmount : (progressImage.fillAmount + 0.02f));
            Fill(amount);
            Blip();
            Events.InvokeProgressBlip();
        }
    }

    public void Fill(float amount)
    {
        progressImage.fillAmount = amount;
        Events.InvokeProgressUpdate(amount);
    }

    public void Blip()
    {
        animator.SetTrigger("Blip");
    }

    public void Ping()
    {
        animator.SetTrigger("Ping");
    }
}
public class HardModeModifierDisplay : ModifierDisplay
{
    [SerializeField]
    public GameObject background;

    public GameModifierData[] modifiers;

    public List<string> active;

    public void Populate()
    {
        //IL_00c5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cf: Expected O, but got Unknown
        int num = SaveSystem.LoadProgressData("hardModeModifiersUnlocked", 0);
        background.SetActive(num > 0);
        active = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers");
        if (active == null)
        {
            active = new List<string>();
        }
        for (int i = 0; i < num && i < modifiers.Length; i++)
        {
            GameModifierData modifier = modifiers[i];
            ModifierIcon modifierIcon = CreateIcon(modifier);
            if (active.Contains((modifier).name))
            {
                ModifierSystem.AddModifier(Campaign.Data, modifier);
            }
            else
            {
                ((Component)modifierIcon).GetComponent<ModifierToggle>()?.Toggle();
            }
            InputAction componentInChildren = ((Component)modifierIcon).GetComponentInChildren<InputAction>();
            if (componentInChildren != null)
            {
                componentInChildren.action.AddListener((UnityAction)delegate
                {
                    Toggle(modifier);
                });
            }
        }
    }

    public void Toggle(GameModifierData modifier)
    {
        if (active.Contains((modifier).name))
        {
            active.Remove((modifier).name);
            ModifierSystem.RemoveModifier(Campaign.Data, modifier);
        }
        else
        {
            active.Add((modifier).name);
            ModifierSystem.AddModifier(Campaign.Data, modifier);
        }
        SaveSystem.SaveProgressData("activeHardModeModifiers", active);
    }
}
public class ModifierDisplay : MonoBehaviour
{
    [SerializeField]
    public ModifierIcon iconPrefab;

    [SerializeField]
    public ModifierIconMultiple stormLevelIconPrefab;

    [SerializeField]
    public Vector2 popUpOffset;

    public readonly List<ModifierIcon> icons = new List<ModifierIcon>();

    public ModifierIconMultiple stormLevelIcon;

    public int modifierCount { get; set; }

    public ModifierIcon CreateIcon(GameModifierData data, bool combineStormBells = true)
    {
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        if (combineStormBells && (data.linkedStormBell) && (stormLevelIconPrefab))
        {
            return AddToStormLevelIcon(data);
        }
        modifierCount++;
        if (!data.visible)
        {
            return null;
        }
        ModifierIcon modifierIcon = Object.Instantiate<ModifierIcon>(iconPrefab, transform);
        modifierIcon.Set(data, popUpOffset);
        icons.Add(modifierIcon);
        return modifierIcon;
    }

    public void ClearIcons()
    {
        for (int num = icons.Count - 1; num >= 0; num--)
        {
            ModifierIcon modifierIcon = icons[num];
            if ((modifierIcon))
            {
                GameObjectExt.Destroy(((Component)modifierIcon).gameObject);
            }
        }
        modifierCount = 0;
        stormLevelIcon = null;
    }

    public ModifierIcon AddToStormLevelIcon(GameModifierData modifier)
    {
        if (!(stormLevelIcon))
        {
            CreateStormLevelIcon(modifier);
        }
        else
        {
            modifierCount++;
            stormLevelIcon.Add(modifier);
        }
        return stormLevelIcon;
    }

    public ModifierIcon CreateStormLevelIcon(GameModifierData firstModifier)
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        modifierCount++;
        stormLevelIcon = Object.Instantiate<ModifierIconMultiple>(stormLevelIconPrefab, transform);
        stormLevelIcon.Set(firstModifier, popUpOffset);
        icons.Add(stormLevelIcon);
        return stormLevelIcon;
    }
}
public class ModifierDisplayCurrent : ModifierDisplay
{
    [SerializeField]
    public GameObject navController;

    public void OnEnable()
    {
        CreateIcons();
    }

    public void CreateIcons()
    {
        if (!(this))
        {
            return;
        }
        ClearIcons();
        bool mainGameMode = Campaign.Data.GameMode.mainGameMode;
        CampaignData data = Campaign.Data;
        if (data != null)
        {
            List<GameModifierData> modifiers = data.Modifiers;
            if (modifiers != null)
            {
                foreach (GameModifierData item in modifiers)
                {
                    CreateIcon(item, mainGameMode);
                }
            }
        }
        if ((navController))
        {
            navController.SetActive(base.modifierCount > 0);
        }
    }

    public void Update()
    {
        CampaignData data = Campaign.Data;
        int num;
        if (data != null)
        {
            List<GameModifierData> modifiers = data.Modifiers;
            if (modifiers != null)
            {
                num = modifiers.Count;
                goto IL_001c;
            }
        }
        num = 0;
        goto IL_001c;
    IL_001c:
        if (num != base.modifierCount)
        {
            CreateIcons();
        }
    }
}
public class ModifierIcon : MonoBehaviourRect
{
    [SerializeField]
    public LayoutElement layoutElement;

    [SerializeField]
    public RectTransform bellHolder;

    public ImageSprite bellImage;

    [SerializeField]
    public ImageSprite dingerImage;

    [SerializeField]
    public GameObject activeIcon;

    [SerializeField]
    public GameObject inactiveIcon;

    [SerializeField]
    public TweenUI[] dingTweens;

    public bool playDingSfx = true;

    public string title;

    public string body;

    [SerializeField]
    public GameModifierData modifier;

    public string popUpName;

    [SerializeField]
    public bool dontPop;

    public bool poppedUp;

    public Vector2 popUpOffset;

    public virtual void Set(GameModifierData modifier, Vector2 popUpOffset)
    {
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        this.modifier = modifier;
        this.popUpOffset = popUpOffset;
        if ((dingerImage))
        {
            dingerImage.SetSprite(this.modifier.dingerSprite);
        }
        if ((bellImage))
        {
            bellImage.SetSprite(modifier.bellSprite);
            float num = (Mathf.Max(1f, ((Graphic)bellImage).rectTransform.sizeDelta.y) - 1f) * 0.5f;
            bellHolder.anchoredPosition = new Vector2(0f, num);
            if ((layoutElement))
            {
                layoutElement.preferredHeight = 1f + num;
            }
        }
        popUpName = (modifier).name;
        title = modifier.titleKey.GetLocalizedString();
        body = modifier.descriptionKey.GetLocalizedString();
    }

    public void SetText(string title, string body)
    {
        this.title = title;
        this.body = body;
    }

    public void AddText(string toBody)
    {
        body += toBody;
    }

    public virtual void Pop()
    {
        if (!dontPop && !poppedUp)
        {
            CardPopUp.AssignTo(base.rectTransform, popUpOffset.x, popUpOffset.y);
            CardPopUp.AddPanel(popUpName, title, body);
            poppedUp = true;
        }
    }

    public virtual void UnPop()
    {
        if (!dontPop && poppedUp)
        {
            CardPopUp.RemovePanel(popUpName);
            poppedUp = false;
        }
    }

    public void OnDisable()
    {
        UnPop();
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void Ding()
    {
        TweenUI[] array = dingTweens;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].Fire();
        }
        if (playDingSfx)
        {
            modifier.PlayRingSfx();
        }
    }
}
public class ModifierIconMultiple : ModifierIcon
{
    [SerializeField]
    public TMP_Text stormLevelText;

    [SerializeField]
    public Transform juiceLevel;

    [SerializeField]
    public Vector2 juiceLevelRange = new Vector2(-0.9f, 0f);

    public readonly List<GameModifierData> modifiers = new List<GameModifierData>();

    public int _stormLevel;

    public int stormLevel
    {
        get
        {
            return _stormLevel;
        }
        set
        {
            //IL_0087: Unknown result type (might be due to invalid IL or missing references)
            //IL_008d: Unknown result type (might be due to invalid IL or missing references)
            _stormLevel = value;
            if ((stormLevelText))
            {
                stormLevelText.text = _stormLevel.ToString();
            }
            if ((juiceLevel))
            {
                float num = Mathf.Clamp((float)_stormLevel / 10f, 0f, 1f);
                float num2 = Mathf.Lerp(juiceLevelRange.x, juiceLevelRange.y, num);
                ((Component)juiceLevel).transform.localPosition = Vector3Ext.WithY(((Component)juiceLevel).transform.localPosition, num2);
            }
        }
    }

    public override void Set(GameModifierData modifier, Vector2 popUpOffset)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        base.Set(modifier, popUpOffset);
        modifiers.Add(modifier);
        if ((modifier.linkedStormBell))
        {
            stormLevel = modifier.linkedStormBell.stormPoints;
        }
        else
        {
            stormLevel = 0;
        }
    }

    public void Add(GameModifierData modifier)
    {
        modifiers.Add(modifier);
        if ((modifier.linkedStormBell))
        {
            stormLevel += modifier.linkedStormBell.stormPoints;
        }
    }

    public void Clear()
    {
        stormLevel = 0;
        modifiers.Clear();
    }

    public override void Pop()
    {
        if (poppedUp)
        {
            return;
        }
        CardPopUp.AssignTo(base.rectTransform, popUpOffset.x, popUpOffset.y);
        foreach (GameModifierData modifier in modifiers)
        {
            CardPopUp.AddPanel((modifier).name, modifier.titleKey.GetLocalizedString(), modifier.descriptionKey.GetLocalizedString());
        }
        poppedUp = true;
    }

    public override void UnPop()
    {
        if (!poppedUp)
        {
            return;
        }
        foreach (GameModifierData modifier in modifiers)
        {
            CardPopUp.RemovePanel((modifier).name);
        }
        poppedUp = false;
    }
}
public class ModifierIconSpecialBorder : MonoBehaviour
{
    [SerializeField]
    public Image border;

    [SerializeField]
    public Sprite specialBorder;

    public void SetSpecialBorder()
    {
        border.sprite = specialBorder;
    }
}
public class ModifierToggle : MonoBehaviour
{
    [SerializeField]
    public bool active = true;

    public bool canToggle = true;

    [SerializeField]
    [HideIf("canToggle")]
    public bool stillRing;

    public UnityEvent onToggle;

    [SerializeField]
    public Animator animator;

    public bool IsActive => active;

    public void OnEnable()
    {
        UpdateAnimator();
    }

    public void UpdateAnimator()
    {
        if ((animator) && ((Behaviour)animator).isActiveAndEnabled)
        {
            animator.SetBool("Active", active);
            animator.SetBool("CanToggle", canToggle);
        }
    }

    public void Toggle()
    {
        if (canToggle)
        {
            SetActive(!active);
            UnityEvent obj = onToggle;
            if (obj != null)
            {
                obj.Invoke();
            }
        }
        else if (stillRing)
        {
            GetComponent<ModifierIcon>()?.Ding();
        }
    }

    public void SetActive(bool value)
    {
        active = value;
        UpdateArt();
    }

    public void UpdateArt()
    {
        if (active)
        {
            GetComponent<ModifierIcon>()?.Ding();
        }
        UpdateAnimator();
    }
}
public class StormBellDifficulty : MonoBehaviour
{
    [Serializable]
    public struct Level
    {
        public int threshold;

        public LocalizedString name;

        public Color colour;
    }

    [SerializeField]
    public bool setOnAwake = true;

    [SerializeField]
    public LocalizeStringEvent locEvent;

    [SerializeField]
    public TMP_Text text;

    [SerializeField]
    public Level[] levels;

    public int _points;

    public int points
    {
        get
        {
            return _points;
        }
        set
        {
            _points = value;
            locEvent.RefreshString();
        }
    }

    public void UpdateText(string text)
    {
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        Level[] array = levels;
        for (int i = 0; i < array.Length; i++)
        {
            Level level = array[i];
            if (points >= level.threshold)
            {
                this.text.text = StringExt.Format(text, new object[1] { level.name.GetLocalizedString() });
                ((Graphic)this.text).color = level.colour;
                break;
            }
        }
    }

    public void Awake()
    {
        if (!setOnAwake)
        {
            return;
        }
        int num = 0;
        List<string> list = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers");
        HardModeModifierData[] hardModeModifiers = MonoBehaviourSingleton<References>.instance.hardModeModifiers;
        foreach (HardModeModifierData hardModeModifierData in hardModeModifiers)
        {
            if (list.Contains((hardModeModifierData).name))
            {
                num += hardModeModifierData.stormPoints;
            }
        }
        points = num;
    }
}
public class StormBellManager : MonoBehaviour
{
    public const int TrueFinalBossPointThreshold = 10;

    public const int PointLimit = 10;

    public const int MaxPointStart = 5;

    public const int MaxPointIncrease = 1;

    [SerializeField]
    public GameObject openButton;

    [SerializeField]
    public Transform[] bellGroups;

    [SerializeField]
    public ModifierIcon bellPrefab;

    [SerializeField]
    public ModifierIconMultiple[] stormBellDisplays;

    [SerializeField]
    public GameObject stormBellUnlockDisplay;

    [SerializeField]
    public Animator animator;

    [SerializeField]
    public GameObject overcranker;

    [SerializeField]
    public GameObject pointLimitDisplay;

    [SerializeField]
    public GameObject overcrankDisplay;

    [SerializeField]
    public GameObject overcrankUnlockDisplay;

    [SerializeField]
    public ColourFader backgroundFader;

    [SerializeField]
    public LocalizedString stormStrengthAddString;

    [SerializeField]
    public GameObject additionalButtons;

    [Header("Smoke")]
    [SerializeField]
    public ParticleSystem normalSmoke;

    [SerializeField]
    public ParticleSystem overcrankSmoke;

    [Header("Storm Strength Increase Popup")]
    [SerializeField]
    public GameObject stormLimitAdd;

    [SerializeField]
    public LocalizedString stormLimitAddString;

    [SerializeField]
    public LocalizedString goldFramesRemainingString;

    [SerializeField]
    public TMP_Text stormLimitAddText;

    [Header("SFX")]
    [SerializeField]
    public EventReference stormBellActivateSfx;

    [SerializeField]
    public EventReference stormBellActivate10Sfx;

    [SerializeField]
    public EventReference stormBellRandomizeSfx;

    [SerializeField]
    public EventReference stormBellClearSfx;

    public List<string> activeNames;

    public List<string> golden;

    public List<string> newGolden;

    public List<HardModeModifierData> active;

    public readonly Dictionary<ModifierIcon, HardModeModifierData> modifierIcons = new Dictionary<ModifierIcon, HardModeModifierData>();

    public bool unlocked;

    public int points;

    public int maxPoints;

    public bool overcrank;

    public string stormStrengthAddText;

    public EventInstance bellActivateSfxInstance;

    public EventInstance bellActivate10SfxInstance;

    public EventInstance bellRandomizeSfxInstance;

    public void Awake()
    {
        overcrank = SaveSystem.LoadProgressData("stormPointOvercrank", defaultValue: false);
        maxPoints = Mathf.Min(SaveSystem.LoadProgressData("maxStormPoints", 5), 10);
        unlocked = SaveSystem.LoadProgressData("stormBellsUnlocked", defaultValue: false);
        if (!unlocked && SaveSystem.LoadProgressData("hardModeModifiersUnlocked", 0) > 0)
        {
            unlocked = true;
            SaveSystem.SaveProgressData("stormBellsUnlocked", value: true);
        }
        if (!unlocked)
        {
            openButton.SetActive(false);
            return;
        }
        golden = SaveSystem.LoadProgressData<List<string>>("goldHardModeModifiers") ?? new List<string>();
        newGolden = SaveSystem.LoadProgressData<List<string>>("goldHardModeModifiersNew");
        if (!SaveSystem.LoadProgressData("stormBellsUnlockedScreenShown", defaultValue: false))
        {
            stormBellUnlockDisplay.SetActive(true);
            SaveSystem.SaveProgressData("stormBellsUnlockedScreenShown", value: true);
        }
        List<string> list = newGolden;
        if (list != null && list.Count > 0)
        {
            int num = MonoBehaviourSingleton<References>.instance.hardModeModifiers.Count((HardModeModifierData a) => golden.Contains((a).name));
            if (num > 0)
            {
                stormLimitAdd.SetActive(true);
                stormLimitAddText.text = goldFramesRemainingString.GetLocalizedString(new object[1] { num });
            }
        }
        int num2 = SaveSystem.LoadProgressData("maxStormPointIncrease", 0);
        if (num2 > 0)
        {
            stormLimitAdd.SetActive(true);
            stormLimitAddText.text = stormLimitAddString.GetLocalizedString(new object[1] { num2 });
            SaveSystem.SaveProgressData("maxStormPointIncrease", 0);
        }
        activeNames = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers") ?? new List<string>();
        bool flag = false;
        for (int num3 = activeNames.Count - 1; num3 >= 0; num3--)
        {
            string bellName = activeNames[num3];
            if (MonoBehaviourSingleton<References>.instance.hardModeModifiers.All((HardModeModifierData a) => (a).name != bellName))
            {
                activeNames.RemoveAt(num3);
                flag = true;
            }
        }
        if (active == null)
        {
            active = new List<HardModeModifierData>();
        }
        HardModeModifierData[] hardModeModifiers = MonoBehaviourSingleton<References>.instance.hardModeModifiers;
        foreach (HardModeModifierData hardModeModifierData in hardModeModifiers)
        {
            if (activeNames.Contains((hardModeModifierData).name))
            {
                active.Add(hardModeModifierData);
            }
        }
        if (!overcrank)
        {
            int num4 = 0;
            for (int num5 = active.Count - 1; num5 >= 0; num5--)
            {
                HardModeModifierData hardModeModifierData2 = active[num5];
                if (num4 + hardModeModifierData2.stormPoints > maxPoints)
                {
                    active.RemoveAt(num5);
                    activeNames.Remove((hardModeModifierData2).name);
                    flag = true;
                }
                else
                {
                    num4 += hardModeModifierData2.stormPoints;
                }
            }
        }
        if (flag)
        {
            SaveSystem.SaveProgressData("activeHardModeModifiers", activeNames);
        }
        stormStrengthAddText = stormStrengthAddString.GetLocalizedString();
        ModifierIcon modifierIcon = null;
        for (int j = 0; j < MonoBehaviourSingleton<References>.instance.hardModeModifiers.Length; j++)
        {
            HardModeModifierData modifier = MonoBehaviourSingleton<References>.instance.hardModeModifiers[j];
            ModifierIcon modifierIcon2 = CreateBell(modifier, j);
            if (modifierIcon != null && j != 5 && j != 10)
            {
                ConnectBellInputLeft(modifierIcon2, modifierIcon);
                ConnectBellInputRight(modifierIcon, modifierIcon2);
            }
            modifierIcon = modifierIcon2;
        }
        UpdateBells();
        if (overcrank)
        {
            foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon3 in modifierIcons)
            {
                ((Component)modifierIcon3.Key).GetComponent<ModifierToggle>().canToggle = false;
            }
        }
        if (overcrank)
        {
            overcrankSmoke.Play();
        }
        else if (points >= 10)
        {
            normalSmoke.Play();
        }
        additionalButtons.SetActive(!overcrank);
        pointLimitDisplay.SetActive(!overcrank);
        overcrankDisplay.SetActive(overcrank);
        overcranker.SetActive(!MonoBehaviourSingleton<References>.instance.hardModeModifiers.Select((HardModeModifierData a) => (a).name).Except(golden).Any());
        if (overcranker.activeSelf && !SaveSystem.LoadProgressData("overcrankUnlockedScreenShown", defaultValue: false))
        {
            overcrankUnlockDisplay.SetActive(true);
            SaveSystem.SaveProgressData("overcrankUnlockedScreenShown", value: true);
        }
        SetGlobalStormBellCountParam();
    }

    public void OnEnable()
    {
        UpdatePointsDisplays();
    }

    public void CheckStartGoldFrameRoutine()
    {
        foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in modifierIcons)
        {
            if (golden.Contains((modifierIcon.Value).name) && (newGolden == null || !newGolden.Contains((modifierIcon.Value).name)))
            {
                Animator component = ((Component)modifierIcon.Key).GetComponent<Animator>();
                if (component != null)
                {
                    component.SetBool("Gold", true);
                }
            }
        }
        List<string> list = newGolden;
        if (list != null && list.Count > 0)
        {
            string[] modifierNames = newGolden.ToArray();
            newGolden = null;
            SaveSystem.DeleteProgressData("goldHardModeModifiersNew");
            StartCoroutine(GoldFrameRoutine(modifierNames));
        }
    }

    public void UpdateBells()
    {
        foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in modifierIcons)
        {
            ModifierToggle component = ((Component)modifierIcon.Key).GetComponent<ModifierToggle>();
            if (component != null && !component.IsActive)
            {
                component.canToggle = maxPoints - points - modifierIcon.Value.stormPoints >= 0;
                component.UpdateArt();
            }
        }
    }

    public ModifierIcon CreateBell(HardModeModifierData modifier, int index)
    {
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ec: Expected O, but got Unknown
        ModifierIcon modifierIcon = Object.Instantiate<ModifierIcon>(bellPrefab, bellGroups[index % bellGroups.Length]);
        modifierIcon.Set(modifier.modifierData, Vector2.left);
        modifierIcon.AddText(StringExt.Format(stormStrengthAddText, new object[1] { modifier.stormPoints }));
        ModifierToggle component = ((Component)modifierIcon).GetComponent<ModifierToggle>();
        if (activeNames.Contains((modifier).name))
        {
            points += modifier.stormPoints;
            ModifierSystem.AddModifier(Campaign.Data, modifier.modifierData);
        }
        else if ((component))
        {
            component.Toggle();
        }
        if ((component))
        {
            component.onToggle.AddListener((UnityAction)delegate
            {
                Toggle(modifier);
            });
        }
        modifierIcons.Add(modifierIcon, modifier);
        return modifierIcon;
    }

    public static void ConnectBellInputLeft(ModifierIcon from, ModifierIcon to)
    {
        UINavigationItem component = ((Component)from).GetComponent<UINavigationItem>();
        if (component != null)
        {
            UINavigationItem component2 = ((Component)to).GetComponent<UINavigationItem>();
            if (component2 != null)
            {
                component.overrideInputs = true;
                component.inputLeft = component2;
            }
        }
    }

    public static void ConnectBellInputRight(ModifierIcon from, ModifierIcon to)
    {
        UINavigationItem component = ((Component)from).GetComponent<UINavigationItem>();
        if (component != null)
        {
            UINavigationItem component2 = ((Component)to).GetComponent<UINavigationItem>();
            if (component2 != null)
            {
                component.overrideInputs = true;
                component.inputRight = component2;
            }
        }
    }

    public void Toggle(HardModeModifierData modifier)
    {
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        //IL_007c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0082: Unknown result type (might be due to invalid IL or missing references)
        //IL_00be: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c8: Unknown result type (might be due to invalid IL or missing references)
        int num = points;
        ToggleEffect(modifier);
        UpdatePointsDisplays();
        UpdateBells();
        SaveSystem.SaveProgressData("activeHardModeModifiers", activeNames);
        animator.SetBool("Angry", points >= 10);
        animator.SetTrigger("Blip");
        SetGlobalStormBellCountParam();
        if (activeNames.Contains((modifier).name))
        {
            bellActivateSfxInstance = SfxSystem.OneShot(stormBellActivateSfx);
            SfxSystem.SetParam(bellActivateSfxInstance, "count", activeNames.Count);
        }
        if (num < 10 && points >= 10)
        {
            backgroundFader.FadeToColour("Purple");
            bellActivate10SfxInstance = SfxSystem.OneShot(stormBellActivate10Sfx);
            normalSmoke.Play();
        }
        else if (num >= 10 && points < 10)
        {
            backgroundFader.FadeToColour("Normal");
            normalSmoke.Stop();
        }
    }

    public void SetGlobalStormBellCountParam()
    {
        int num = ((points >= 10) ? Mathf.Max(10, active.Count) : active.Count);
        SfxSystem.SetGlobalParam("stormbell_count", num);
    }

    public void ToggleEffect(HardModeModifierData modifier)
    {
        if (activeNames.Contains((modifier).name))
        {
            activeNames.Remove((modifier).name);
            active.Remove(modifier);
            points -= modifier.stormPoints;
            ModifierSystem.RemoveModifier(Campaign.Data, modifier.modifierData);
        }
        else
        {
            activeNames.Add((modifier).name);
            active.Add(modifier);
            points += modifier.stormPoints;
            ModifierSystem.AddModifier(Campaign.Data, modifier.modifierData);
        }
    }

    public void ForceEnableAllBells()
    {
        foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in modifierIcons)
        {
            if (!activeNames.Contains((modifierIcon.Value).name))
            {
                ToggleEffect(modifierIcon.Value);
                modifierIcon.Key.Ding();
                ((Component)modifierIcon.Key).GetComponent<ModifierToggle>().SetActive(value: true);
            }
        }
        UpdatePointsDisplays();
        UpdateBells();
        foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon2 in modifierIcons)
        {
            ((Component)modifierIcon2.Key).GetComponent<ModifierToggle>().canToggle = false;
        }
        SaveSystem.SaveProgressData("activeHardModeModifiers", activeNames);
        animator.SetBool("Angry", points >= 10);
        animator.SetTrigger("Blip");
    }

    public void DisableForcedBells()
    {
        List<string> list = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiersBeforeOvercrank") ?? new List<string>();
        foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in modifierIcons)
        {
            if (!list.Contains((modifierIcon.Value).name))
            {
                ToggleEffect(modifierIcon.Value);
                ((Component)modifierIcon.Key).GetComponent<ModifierToggle>().SetActive(value: false);
            }
        }
        UpdatePointsDisplays();
        UpdateBells();
        foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon2 in modifierIcons)
        {
            ((Component)modifierIcon2.Key).GetComponent<ModifierToggle>().canToggle = activeNames.Contains((modifierIcon2.Value).name) || points + modifierIcon2.Value.stormPoints <= maxPoints;
        }
        SaveSystem.SaveProgressData("activeHardModeModifiers", activeNames);
        animator.SetBool("Angry", points >= 10);
        animator.SetTrigger("Blip");
    }

    public void UpdatePointsDisplays()
    {
        ModifierIconMultiple[] array = stormBellDisplays;
        foreach (ModifierIconMultiple modifierIconMultiple in array)
        {
            modifierIconMultiple.Clear();
            if (active == null)
            {
                continue;
            }
            foreach (HardModeModifierData item in active)
            {
                if ((item))
                {
                    modifierIconMultiple.Add(item.modifierData);
                }
            }
        }
    }

    public static List<string> GetActiveStormBells()
    {
        return SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers");
    }

    public static int GetCurrentStormPoints(List<string> active)
    {
        int num = 0;
        if (active != null)
        {
            HardModeModifierData[] hardModeModifiers = MonoBehaviourSingleton<References>.instance.hardModeModifiers;
            foreach (HardModeModifierData hardModeModifierData in hardModeModifiers)
            {
                if (active.Contains((hardModeModifierData).name))
                {
                    num += hardModeModifierData.stormPoints;
                }
            }
        }
        return num;
    }

    public void UpdateAnimator()
    {
        animator.SetBool("Angry", points >= 10);
        animator.SetBool("Overcrank", overcrank);
        backgroundFader.FadeToColour(overcrank ? "Red" : ((points >= 10) ? "Purple" : "Normal"));
        if (overcrank)
        {
            overcrankSmoke.Play();
            normalSmoke.Stop();
            return;
        }
        overcrankSmoke.Stop();
        if (points >= 10)
        {
            normalSmoke.Play();
        }
        else
        {
            normalSmoke.Stop();
        }
    }

    public void ToggleOvercrank()
    {
        overcrank = !overcrank;
        animator.SetBool("Overcrank", overcrank);
        SaveSystem.SaveProgressData("stormPointOvercrank", overcrank);
        if (overcrank)
        {
            SaveSystem.SaveProgressData("activeHardModeModifiersBeforeOvercrank", activeNames);
            ForceEnableAllBells();
            backgroundFader.FadeToColour("Red");
            SfxSystem.OneShot("event:/sfx/town/stormbell_overcrank");
            overcrankSmoke.Play();
            normalSmoke.Stop();
        }
        else
        {
            DisableForcedBells();
            backgroundFader.FadeToColour((points >= 10) ? "Purple" : "Normal");
            SfxSystem.OneShot("event:/sfx/town/stormbell_overcrank_deactivate");
            overcrankSmoke.Stop();
            if (points >= 10)
            {
                normalSmoke.Play();
            }
            else
            {
                normalSmoke.Stop();
            }
        }
        pointLimitDisplay.SetActive(!overcrank);
        overcrankDisplay.SetActive(overcrank);
        additionalButtons.SetActive(!overcrank);
        SetGlobalStormBellCountParam();
    }

    public static bool TrueFinalBossPointThresholdReached()
    {
        return GetCurrentStormPoints(GetActiveStormBells()) >= 10;
    }

    public IEnumerator GoldFrameRoutine(string[] modifierNames)
    {
        foreach (string modifierName in modifierNames)
        {
            KeyValuePair<ModifierIcon, HardModeModifierData> keyValuePair = modifierIcons.FirstOrDefault((KeyValuePair<ModifierIcon, HardModeModifierData> p) => (p.Value).name == modifierName);
            if ((keyValuePair.Key))
            {
                Animator component = ((Component)keyValuePair.Key).GetComponent<Animator>();
                if (component != null)
                {
                    component.SetBool("Gold", true);
                    component.SetBool("BecomeGold", true);
                    yield return (object)new WaitForSeconds(0.15f);
                }
            }
        }
    }

    public void Randomize()
    {
        //IL_011a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0127: Unknown result type (might be due to invalid IL or missing references)
        //IL_012c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0131: Unknown result type (might be due to invalid IL or missing references)
        Clear();
        int num = 0;
        List<HardModeModifierData> list = new List<HardModeModifierData>();
        while (num != maxPoints)
        {
            list.Clear();
            num = 0;
            List<HardModeModifierData> list2 = IArrayExt.ToList<HardModeModifierData>(MonoBehaviourSingleton<References>.instance.hardModeModifiers);
            while (num < maxPoints && list2.Count > 0)
            {
                HardModeModifierData hardModeModifierData = IListExt.TakeRandom<HardModeModifierData>((IList<HardModeModifierData>)list2);
                if (num + hardModeModifierData.stormPoints <= maxPoints)
                {
                    list.Add(hardModeModifierData);
                    num += hardModeModifierData.stormPoints;
                }
            }
        }
        foreach (HardModeModifierData modifier in list)
        {
            ToggleEffect(modifier);
            ModifierIcon key = modifierIcons.FirstOrDefault((KeyValuePair<ModifierIcon, HardModeModifierData> p) => p.Value == modifier).Key;
            if ((key))
            {
                key.Ding();
                ((Component)key).GetComponent<ModifierToggle>().SetActive(value: true);
            }
        }
        SaveSystem.SaveProgressData("activeHardModeModifiers", activeNames);
        UpdatePointsDisplays();
        UpdateBells();
        UpdateAnimator();
        SetGlobalStormBellCountParam();
        SfxSystem.Stop(bellRandomizeSfxInstance);
        bellRandomizeSfxInstance = SfxSystem.OneShot(stormBellRandomizeSfx);
    }

    public void Clear()
    {
        foreach (KeyValuePair<ModifierIcon, HardModeModifierData> modifierIcon in modifierIcons)
        {
            if (activeNames.Contains((modifierIcon.Value).name))
            {
                ((Component)modifierIcon.Key).GetComponent<ModifierToggle>().Toggle();
            }
        }
    }

    public void ClearAndPlaySfx()
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        if (active.Count > 0)
        {
            SfxSystem.OneShot(stormBellClearSfx);
            SfxSystem.Stop(bellRandomizeSfxInstance);
            SfxSystem.Stop(bellActivateSfxInstance);
            SfxSystem.Stop(bellActivate10SfxInstance);
            Clear();
        }
    }
}
public class StormBellPointLimit : MonoBehaviour
{
    [SerializeField]
    public bool setOnAwake = true;

    [SerializeField]
    public TMP_Text text;

    public int _pointLimit;

    public int pointLimit
    {
        get
        {
            return _pointLimit;
        }
        set
        {
            _pointLimit = value;
            text.text = value.ToString();
        }
    }

    public void Awake()
    {
        if (setOnAwake)
        {
            int num = SaveSystem.LoadProgressData("maxStormPoints", 5);
            pointLimit = Mathf.Min(num, 10);
        }
    }
}
public class StormBellPoints : MonoBehaviour
{
    [SerializeField]
    public bool setOnAwake = true;

    [SerializeField]
    public LocalizeStringEvent locEvent;

    [SerializeField]
    public TMP_Text text;

    public int _points;

    public int points
    {
        get
        {
            return _points;
        }
        set
        {
            _points = value;
            locEvent.RefreshString();
        }
    }

    public void UpdateText(string text)
    {
        this.text.text = StringExt.Format(text, new object[1] { points });
    }

    public void Awake()
    {
        if (!setOnAwake)
        {
            return;
        }
        int num = 0;
        List<string> list = SaveSystem.LoadProgressData<List<string>>("activeHardModeModifiers");
        HardModeModifierData[] hardModeModifiers = MonoBehaviourSingleton<References>.instance.hardModeModifiers;
        foreach (HardModeModifierData hardModeModifierData in hardModeModifiers)
        {
            if (list.Contains((hardModeModifierData).name))
            {
                num += hardModeModifierData.stormPoints;
            }
        }
        points = num;
    }
}
public class NameTag : MonoBehaviour
{
    [SerializeField]
    public NameTagStyle[] styles;

    public NameTagStyle currentStyle;

    public readonly Dictionary<string, NameTagStyle> styleDictionary = new Dictionary<string, NameTagStyle>();

    public void Awake()
    {
        NameTagStyle[] array = styles;
        foreach (NameTagStyle nameTagStyle in array)
        {
            styleDictionary[(nameTagStyle).name] = nameTagStyle;
        }
        array = styles;
        foreach (NameTagStyle nameTagStyle2 in array)
        {
            if (((Component)nameTagStyle2).gameObject.activeSelf)
            {
                currentStyle = nameTagStyle2;
                break;
            }
        }
    }

    public void SetStyle(string styleName)
    {
        NameTagStyle nameTagStyle = styleDictionary[styleName];
        if (nameTagStyle != currentStyle)
        {
            ((Component)currentStyle).gameObject.SetActive(false);
            ((Component)nameTagStyle).gameObject.SetActive(true);
            currentStyle = nameTagStyle;
        }
    }
}
public class NameTagStyle : MonoBehaviour
{
    public TextMeshProUGUI textElement;
}
public class ParticleSystemCreator : MonoBehaviour
{
    [SerializeField]
    public ParticleSystem prefab;

    public void Create()
    {
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        ((Component)Object.Instantiate<ParticleSystem>(prefab, transform)).transform.localPosition = Vector3.zero;
    }
}
public class PauseMenuBlocker : MonoBehaviour
{
    public void OnEnable()
    {
        PauseMenu.Block();
    }

    public void OnDisable()
    {
        PauseMenu.Unblock();
    }
}
public class PositionBasedOnAspect : MonoBehaviourRect
{
    [SerializeField]
    public AnimationCurve curve;

    [SerializeField]
    public Vector3 maxPosition;

    [SerializeField]
    public Vector3 minPosition;

    public void UpdatePosition(RectTransform canvas)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        Vector2 sizeDelta = canvas.sizeDelta;
        float num = sizeDelta.x / sizeDelta.y;
        float num2 = curve.Evaluate(num);
        base.rectTransform.anchoredPosition3D = minPosition + (maxPosition - minPosition) * num2;
    }
}
public class ScaleBasedOnAspect : MonoBehaviour
{
    [SerializeField]
    public AnimationCurve curve;

    [SerializeField]
    public Vector3 maxScale;

    [SerializeField]
    public Vector3 minScale;

    [SerializeField]
    public bool autoLinkToParent;

    public void Awake()
    {
        if (autoLinkToParent)
        {
            WorldSpaceCanvasFitScreen componentInParent = ((Component)transform).GetComponentInParent<WorldSpaceCanvasFitScreen>();
            if ((componentInParent))
            {
                componentInParent.onUpdate.AddListener((UnityAction<RectTransform>)UpdateScale);
                UpdateScale(componentInParent.rectTransform);
            }
        }
    }

    public void UpdateScale(RectTransform canvas)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        Vector2 sizeDelta = canvas.sizeDelta;
        float num = sizeDelta.x / sizeDelta.y;
        float num2 = curve.Evaluate(num);
        transform.localScale = minScale + (maxScale - minScale) * num2;
    }
}
public class ScoreSequence : MonoBehaviour
{
    [SerializeField]
    public TMP_Text timeText;

    [SerializeField]
    public TMP_Text timeScoreText;

    [SerializeField]
    public TMP_Text battlesText;

    [SerializeField]
    public TMP_Text battlesScoreText;

    [SerializeField]
    public TMP_Text goldText;

    [SerializeField]
    public TMP_Text goldScoreText;

    [SerializeField]
    public TMP_Text totalScoreText;

    [SerializeField]
    public TMP_Text globalRankText;

    [SerializeField]
    public LocalizedString totalStringRef;

    [SerializeField]
    public LocalizedString submittingStringRef;

    [SerializeField]
    public LocalizedString failedToSubmitStringRef;

    [SerializeField]
    public LocalizedString globalRankStringRef;

    [Header("SFX")]
    [SerializeField]
    public EventReference countSfx;

    [SerializeField]
    public EventReference countFinishSfx;

    [SerializeField]
    public EventReference countFinishFirstSfx;

    public bool running { get; set; }

    public IEnumerator Start()
    {
        yield return Sequence();
    }

    public void OnDisable()
    {
        StopAllCoroutines();
    }

    public IEnumerator Sequence()
    {
        running = true;
        ((Component)totalScoreText).gameObject.SetActive(false);
        ((Component)globalRankText).gameObject.SetActive(false);
        int submittedTime = ScoreSubmitSystem.SubmittedTime;
        int gold = ScoreSubmitSystem.SubmittedGold;
        int battlesWon = ScoreSubmitSystem.SubmittedBattlesWon;
        timeText.text = TimeSpan.FromSeconds(submittedTime).ToString();
        battlesText.text = battlesWon.ToString();
        goldText.text = gold.ToString();
        timeScoreText.text = "";
        battlesScoreText.text = "";
        goldScoreText.text = "";
        int scoreFromTime = ScoreSubmitSystem.GetScoreFromTime(References.Campaign.result == Campaign.Result.Win, submittedTime);
        Debug.Log($"Time Taken: {timeText.text} = {scoreFromTime} points");
        yield return CountScoreUp(timeScoreText, "+{0}", "<#f40>{0}", scoreFromTime);
        int scoreFromBattlesWon = ScoreSubmitSystem.GetScoreFromBattlesWon(battlesWon);
        Debug.Log($"Battles Won: {battlesText.text} = {scoreFromBattlesWon} points");
        yield return CountScoreUp(battlesScoreText, "+{0}", "<#f40>{0}", scoreFromBattlesWon);
        int scoreFromGold = ScoreSubmitSystem.GetScoreFromGold(gold);
        Debug.Log($"Blings: {goldText.text} = {scoreFromGold} points");
        yield return CountScoreUp(goldScoreText, "+{0}", "<#f40>{0}", scoreFromGold);
        ((Component)totalScoreText).gameObject.SetActive(true);
        int submittedScore = ScoreSubmitSystem.SubmittedScore;
        Debug.Log($"Final Score: {submittedScore}");
        string localizedString = totalStringRef.GetLocalizedString();
        string positiveFormat = string.Format(localizedString, "<#ff0>{0}");
        string negativeFormat = string.Format(localizedString, "<#f40>{0}");
        yield return CountScoreUp(totalScoreText, positiveFormat, negativeFormat, submittedScore);
        if (!((countFinishSfx)).IsNull)
        {
            SfxSystem.OneShot(countFinishSfx);
        }
        LeaderboardUpdate? result = ScoreSubmitSystem.result;
        if (result.HasValue && result.GetValueOrDefault().Changed)
        {
            int newGlobalRank = ScoreSubmitSystem.result.Value.NewGlobalRank;
            if (newGlobalRank > 0)
            {
                Debug.Log($"Global Rank: {newGlobalRank}");
                ((Component)globalRankText).gameObject.SetActive(true);
                globalRankText.text = string.Format(globalRankStringRef.GetLocalizedString(), newGlobalRank);
                if (newGlobalRank == 1 && !((countFinishFirstSfx)).IsNull)
                {
                    SfxSystem.OneShot(countFinishFirstSfx);
                }
            }
        }
        running = false;
    }

    public IEnumerator SetSubmitScoreText()
    {
        ((Component)globalRankText).gameObject.SetActive(true);
        if (ScoreSubmitSystem.status == ScoreSubmitSystem.Status.Submitting)
        {
            string text = submittingStringRef.GetLocalizedString();
            globalRankText.text = text;
            float t = 1f;
            string dots = "";
            yield return null;
            while (ScoreSubmitSystem.status == ScoreSubmitSystem.Status.Submitting)
            {
                t -= Time.deltaTime;
                if (t <= 0f)
                {
                    t += 1f;
                    dots = ((dots.Length < 3) ? (dots + ".") : "");
                    globalRankText.text = text + dots;
                }
                yield return null;
            }
        }
        switch (ScoreSubmitSystem.status)
        {
            case ScoreSubmitSystem.Status.Failed:
                globalRankText.text = failedToSubmitStringRef.GetLocalizedString();
                break;
            case ScoreSubmitSystem.Status.Success:
                if (ScoreSubmitSystem.playerRank.HasValue)
                {
                    int value = ScoreSubmitSystem.playerRank.Value;
                    Debug.Log($"Global Rank: {value}");
                    globalRankText.text = string.Format(globalRankStringRef.GetLocalizedString(), value);
                    if (value == 1 && !((countFinishFirstSfx)).IsNull)
                    {
                        SfxSystem.OneShot(countFinishFirstSfx);
                    }
                }
                else
                {
                    ((Component)globalRankText).gameObject.SetActive(false);
                }
                break;
        }
    }

    public IEnumerator CountScoreUp(TMP_Text element, string positiveFormat, string negativeFormat, int toScore, int fromScore = 0)
    {
        int v = fromScore;
        element.text = Format(positiveFormat, negativeFormat, fromScore);
        float time = Mathf.Clamp((float)toScore / 100f, 1f, 3f);
        float t = 0f;
        yield return null;
        while (t < time)
        {
            t += Time.deltaTime;
            int num = fromScore + Mathf.RoundToInt(Mathf.Min(1f, t / time) * (float)(toScore - fromScore));
            element.text = Format(positiveFormat, negativeFormat, num);
            if (v != num && !((countSfx)).IsNull)
            {
                SfxSystem.OneShot(countSfx);
            }
            v = num;
            yield return null;
        }
    }

    public static string Format(string positive, string negative, int value)
    {
        if (value < 0)
        {
            return string.Format(negative, value);
        }
        return string.Format(positive, value);
    }
}
public class Scroller : MonoBehaviourRect
{
    [SerializeField]
    public UINavigationLayer navLayer;

    public bool interactable = true;

    public float scrollSpeed = 0.2f;

    public float scrollAmount = 1f;

    public bool horizontal;

    public RectTransform bounds;

    [Range(0f, 1f)]
    public float boundsHardness = 0.2f;

    public UnityEvent onScroll;

    public UnityEvent<float> afterScroll;

    public Vector2 targetPos;

    public Vector2 preTargetPos;

    [SerializeField]
    public bool hasStartScroll;

    [SerializeField]
    [ShowIf("hasStartScroll")]
    [Range(0f, 1f)]
    public float startScroll;

    [SerializeField]
    public bool ignoreTimeScale;

    [Header("Scroll Knob")]
    [SerializeField]
    public RectTransform scrollKnob;

    [SerializeField]
    public RectTransform scrollKnobBounds;

    public float boundsDelay;

    public static float boundsDelayMax;

    public bool checkBounds;

    public float DeltaTime
    {
        get
        {
            if (!ignoreTimeScale)
            {
                return Time.deltaTime;
            }
            return Time.unscaledDeltaTime;
        }
    }

    public float s
    {
        get
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_000f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0020: Unknown result type (might be due to invalid IL or missing references)
            //IL_0025: Unknown result type (might be due to invalid IL or missing references)
            //IL_0028: Unknown result type (might be due to invalid IL or missing references)
            Rect rect = base.rectTransform.rect;
            float relevant = GetRelevant(((rect)).size);
            rect = bounds.rect;
            return relevant - GetRelevant(((rect)).size);
        }
    }

    public float TargetPos
    {
        get
        {
            if (!horizontal)
            {
                return targetPos.y;
            }
            return targetPos.x;
        }
        set
        {
            if (horizontal)
            {
                targetPos.x = value;
            }
            else
            {
                targetPos.y = value;
            }
        }
    }

    public float ScrollAmount
    {
        get
        {
            return (s * 0.5f - TargetPos) / s;
        }
        set
        {
            TargetPos = (0f - s) * 0.5f + value * s;
        }
    }

    public void Awake()
    {
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        if (!(bounds))
        {
            Transform transform = ((Component)transform.parent).transform;
            RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
            if (val != null)
            {
                bounds = val;
            }
        }
        if (navLayer == null)
        {
            navLayer = this.FindComponentInParents<UINavigationLayer>(transform);
        }
        UpdateScrollKnob();
        boundsDelay = boundsDelayMax;
        InvokeAfterScroll();
        preTargetPos = targetPos;
    }

    public T FindComponentInParents<T>(Transform parent) where T : Component
    {
        while (true)
        {
            T component = ((Component)parent).GetComponent<T>();
            if (component != null)
            {
                return component;
            }
            if (parent.parent == null)
            {
                break;
            }
            parent = parent.parent;
        }
        return default(T);
    }

    public void OnEnable()
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        if (hasStartScroll)
        {
            ScrollTo(startScroll);
            base.rectTransform.anchoredPosition = targetPos;
        }
    }

    public bool CheckNavigationLayer()
    {
        if ((navLayer))
        {
            return UINavigationSystem.ActiveNavigationLayer == navLayer;
        }
        return true;
    }

    public void Update()
    {
        //IL_009b: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00af: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ce: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        if (interactable && CheckNavigationLayer())
        {
            float num = 0f;
            if (MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
            {
                num = (horizontal ? (0f - Input.mouseScrollDelta.y) : Input.mouseScrollDelta.y);
            }
            if (num != 0f)
            {
                Scroll(num * scrollAmount);
            }
        }
        if (boundsDelay > 0f)
        {
            boundsDelay -= DeltaTime;
        }
        else if (checkBounds && (bounds))
        {
            CheckBounds();
        }
        Vector2 anchoredPosition = base.rectTransform.anchoredPosition;
        if (anchoredPosition != targetPos)
        {
            anchoredPosition = Delta.Lerp(anchoredPosition, targetPos, scrollSpeed, DeltaTime);
            base.rectTransform.anchoredPosition = anchoredPosition;
        }
    }

    public void LateUpdate()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        if (preTargetPos != targetPos)
        {
            InvokeAfterScroll();
            preTargetPos = targetPos;
        }
    }

    public void InvokeAfterScroll()
    {
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        if (afterScroll != null && (bounds))
        {
            float num = s;
            float num2 = num * 0.5f;
            float num3 = 1f - (TargetPos + num2 - GetRelevant((((Transform)bounds).localPosition))) / num;
            afterScroll.Invoke(num3);
        }
    }

    public void Scroll(float amount)
    {
        TargetPos -= amount;
        UnityEvent obj = onScroll;
        if (obj != null)
        {
            obj.Invoke();
        }
        UpdateScrollKnob();
        checkBounds = true;
    }

    public void ScrollImmediate(float amount)
    {
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        TargetPos -= amount;
        UnityEvent obj = onScroll;
        if (obj != null)
        {
            obj.Invoke();
        }
        CheckBounds();
        base.rectTransform.anchoredPosition = targetPos;
        UpdateScrollKnob();
    }

    public void ScrollTo(float position)
    {
        ScrollAmount = position;
        UnityEvent obj = onScroll;
        if (obj != null)
        {
            obj.Invoke();
        }
        UpdateScrollKnob();
    }

    public void ScrollTo(Vector2 targetPos)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        this.targetPos = targetPos;
        UnityEvent obj = onScroll;
        if (obj != null)
        {
            obj.Invoke();
        }
        UpdateScrollKnob();
        checkBounds = true;
    }

    public void CheckBounds()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        //IL_0083: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bf: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00dd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fd: Unknown result type (might be due to invalid IL or missing references)
        //IL_0102: Unknown result type (might be due to invalid IL or missing references)
        //IL_0110: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f8: Unknown result type (might be due to invalid IL or missing references)
        //IL_0115: Unknown result type (might be due to invalid IL or missing references)
        Rect rect = bounds.rect;
        Vector2 vector = ((rect)).size * 0.5f;
        Vector2 anchoredPosition = bounds.anchoredPosition;
        float num = GetRelevant(anchoredPosition) - GetRelevant(vector);
        float num2 = GetRelevant(anchoredPosition) + GetRelevant(vector);
        rect = base.rectTransform.rect;
        Vector2 vector2 = ((rect)).size * 0.5f;
        float num3 = TargetPos - GetRelevant(vector2);
        float num4 = TargetPos + GetRelevant(vector2);
        bool flag = num3 >= num;
        bool flag2 = num4 <= num2;
        Vector2 vector3 = targetPos;
        if (flag || flag2)
        {
            vector3 = ((flag && flag2) ? SetRelevant(vector3, 0f) : ((!flag) ? AddRelevant(vector3, num2 - num4) : AddRelevant(vector3, num - num3)));
            targetPos = ((boundsHardness < 1f) ? Delta.Lerp(targetPos, vector3, boundsHardness, DeltaTime) : vector3);
        }
        else
        {
            checkBounds = false;
        }
    }

    public float GetRelevant(Vector2 vector2)
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        if (!horizontal)
        {
            return vector2.y;
        }
        return vector2.x;
    }

    public Vector2 SetRelevant(Vector2 vector2, float value)
    {
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        if (horizontal)
        {
            vector2.x = value;
        }
        else
        {
            vector2.y = value;
        }
        return vector2;
    }

    public Vector2 AddRelevant(Vector2 vector2, float value)
    {
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        if (horizontal)
        {
            vector2.x += value;
        }
        else
        {
            vector2.y += value;
        }
        return vector2;
    }

    public void UpdateScrollKnob()
    {
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        //IL_007a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0092: Unknown result type (might be due to invalid IL or missing references)
        //IL_0099: Unknown result type (might be due to invalid IL or missing references)
        //IL_009a: Unknown result type (might be due to invalid IL or missing references)
        if ((scrollKnob) && (scrollKnobBounds))
        {
            Rect rect = scrollKnobBounds.rect;
            float relevant = GetRelevant(((rect)).size);
            float num = (0f - relevant) * 0.5f + relevant * Mathf.Clamp(ScrollAmount, 0f, 1f);
            LeanTween.cancel(scrollKnob);
            Vector2 val = (horizontal ? Vector2Ext.WithX(scrollKnob.anchoredPosition, num) : Vector2Ext.WithY(scrollKnob.anchoredPosition, num));
            LeanTween.move(scrollKnob, (val), 0.2f).setEase(LeanTweenType.easeOutQuart);
        }
    }

    public void SetInteractable(bool value)
    {
        interactable = value;
    }

    public bool ContentLargerThanBounds()
    {
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        if (!horizontal)
        {
            return base.rectTransform.sizeDelta.y > bounds.sizeDelta.y;
        }
        return base.rectTransform.sizeDelta.x > bounds.sizeDelta.x;
    }
}
public class ScrollerScrollTo : MonoBehaviour
{
    [SerializeField]
    public Scroller scroller;

    [SerializeField]
    [Range(0f, 1f)]
    public float scrollTo = 1f;

    [SerializeField]
    public bool onAwake;

    [SerializeField]
    public bool onEnable = true;

    [SerializeField]
    public float delay;

    [SerializeField]
    public bool instant;

    public void Awake()
    {
        if (onAwake)
        {
            StartCoroutine(Sequence());
        }
    }

    public void OnEnable()
    {
        if (onEnable)
        {
            StartCoroutine(Sequence());
        }
    }

    public void Run()
    {
        StartCoroutine(Sequence());
    }

    public IEnumerator Sequence()
    {
        if (delay > 0f)
        {
            yield return (object)new WaitForSeconds(delay);
        }
        scroller.ScrollTo(scrollTo);
        if (instant)
        {
            scroller.rectTransform.anchoredPosition = scroller.targetPos;
        }
    }
}
public class ScrollKnob : MonoBehaviourRect
{
    [SerializeField]
    public RectTransform bounds;

    [SerializeField]
    public bool horizontal;

    public Vector2 targetPosition;

    public void Update()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        base.rectTransform.anchoredPosition = Delta.Lerp(base.rectTransform.anchoredPosition, targetPosition, 0.33f, Time.deltaTime);
    }

    public void SetPosition(Vector2 position)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        SetPosition(GetRelevantAxis(position));
    }

    public void SetPosition(float normalizedPosition)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        Rect rect = bounds.rect;
        float relevantAxis = GetRelevantAxis(((rect)).size);
        float num = (0f - relevantAxis) * 0.5f + relevantAxis * Mathf.Clamp(normalizedPosition, 0f, 1f);
        if (horizontal)
        {
            targetPosition.x = num;
        }
        else
        {
            targetPosition.y = num;
        }
    }

    public float GetRelevantAxis(Vector2 vector2)
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        if (!horizontal)
        {
            return vector2.y;
        }
        return vector2.x;
    }
}
[RequireComponent(typeof(ScrollRect))]
public class ScrollRectAuto : MonoBehaviour, IDragHandler, IEventSystemHandler, IScrollHandler
{
    public ScrollRect _scrollRect;

    [SerializeField]
    public float activateTime = 1f;

    [SerializeField]
    public float scrollSpeed = 1f;

    [SerializeField]
    public float acceleration = 1f;

    [SerializeField]
    public bool disableAtBottom = true;

    [SerializeField]
    public bool disableOnDrag = true;

    [SerializeField]
    public bool disableOnMouseScroll = true;

    [SerializeField]
    public bool reactivate = true;

    [SerializeField]
    [ShowIf("reactivate")]
    public float reactivateTime = 1f;

    [SerializeField]
    public UnityEvent onReachBottom;

    public float scrollSpeedCurrent;

    public static readonly Vector2 scroll = new Vector2(0f, 1f);

    public bool active = true;

    public float reactivateTimer;

    public ScrollRect scrollRect => _scrollRect ?? (_scrollRect = GetComponent<ScrollRect>());

    public void Update()
    {
        //IL_00a3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00be: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ce: Unknown result type (might be due to invalid IL or missing references)
        if (!(scrollRect.content))
        {
            return;
        }
        if (activateTime > 0f)
        {
            activateTime -= Time.deltaTime;
            return;
        }
        if (!active)
        {
            if (reactivateTimer > 0f)
            {
                reactivateTimer -= Time.deltaTime;
                if (reactivateTimer <= 0f)
                {
                    active = true;
                }
            }
            return;
        }
        scrollSpeedCurrent = Delta.Lerp(scrollSpeedCurrent, scrollSpeed, acceleration, Time.deltaTime);
        RectTransform content = scrollRect.content;
        content.anchoredPosition += scroll * (scrollSpeedCurrent * Time.deltaTime);
        if (scrollRect.normalizedPosition.y <= 0f)
        {
            UnityEvent obj = onReachBottom;
            if (obj != null)
            {
                obj.Invoke();
            }
            if (disableAtBottom)
            {
                Stop();
                reactivateTimer = 0f;
            }
        }
    }

    public void OnDrag(PointerEventData eventData)
    {
        if (disableOnDrag)
        {
            Stop();
        }
    }

    public void OnScroll(PointerEventData eventData)
    {
        if (disableOnMouseScroll)
        {
            Stop();
        }
    }

    public void Stop()
    {
        active = false;
        if (reactivate)
        {
            reactivateTimer = reactivateTime;
        }
        scrollSpeedCurrent = 0f;
    }
}
public class ScrollToNavigation : MonoBehaviour
{
    [SerializeField]
    public Scroller scroller;

    [SerializeField]
    public SmoothScrollRect scrollRect;

    public bool HasScroller => (scroller);

    public bool HasScrollRect => (scrollRect);

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnUINavigation += new UnityAction(Navigation);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnUINavigation -= new UnityAction(Navigation);
    }

    public void Navigation()
    {
        if (!MonoBehaviourSingleton<Cursor3d>.instance.usingMouse)
        {
            UINavigationItem currentNavigationItem = MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem;
            if (HasScroller && scroller.ContentLargerThanBounds())
            {
                TryScrollScroller(((Component)currentNavigationItem).transform);
            }
            else if (HasScrollRect)
            {
                TryScrollScrollRect(((Component)currentNavigationItem).transform);
            }
        }
    }

    public void TryScrollScroller(Transform target)
    {
        if (target.IsChildOf(((Component)scroller).transform))
        {
            if (scroller.horizontal)
            {
                ScrollScrollerHorizontal(target);
            }
            else
            {
                ScrollScrollerVertical(target);
            }
        }
    }

    public void ScrollScrollerVertical(Transform target)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        float num = ((Component)scroller).transform.position.y - target.position.y;
        scroller.ScrollTo(Vector2Ext.WithY(scroller.targetPos, num));
    }

    public void ScrollScrollerHorizontal(Transform target)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        float num = ((Component)scroller).transform.position.x - target.position.x;
        scroller.ScrollTo(Vector2Ext.WithX(scroller.targetPos, num));
    }

    public void TryScrollScrollRect(Transform target)
    {
        if (target.IsChildOf(((Component)scrollRect).transform))
        {
            if (((ScrollRect)scrollRect).horizontal)
            {
                ScrollScrollRectHorizontal(target);
            }
            else
            {
                ScrollScrollRectVertical(target);
            }
        }
    }

    public void ScrollScrollRectVertical(Transform target)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        float num = target.position.y - ((Transform)((ScrollRect)scrollRect).content).position.y;
        Rect rect = ((ScrollRect)scrollRect).viewport.rect;
        float num2 = 0f - (num + ((rect)).size.y * 0.5f);
        scrollRect.ScrollTo(Vector2Ext.WithY(((ScrollRect)scrollRect).content.anchoredPosition, num2));
    }

    public void ScrollScrollRectHorizontal(Transform target)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        float num = target.position.x - ((Transform)((ScrollRect)scrollRect).content).position.x;
        Rect rect = ((ScrollRect)scrollRect).viewport.rect;
        float num2 = 0f - (num + ((rect)).size.x * 0.5f);
        scrollRect.ScrollTo(Vector2Ext.WithX(((ScrollRect)scrollRect).content.anchoredPosition, num2));
    }
}
public class OptionSetter : MonoBehaviour
{
    [SerializeField]
    public GameObject[] options;

    public bool init;

    public void Start()
    {
        if (!init)
        {
            TMP_Dropdown component = GetComponent<TMP_Dropdown>();
            if (component != null)
            {
                Set(component.value);
            }
        }
    }

    public void Set(int index)
    {
        for (int i = 0; i < options.Length; i++)
        {
            options[i].SetActive(i == index);
        }
        if (!init)
        {
            init = true;
        }
    }
}
public class SetLanguage : MonoBehaviour
{
    [SerializeField]
    public TMP_Dropdown dropdown;

    [SerializeField]
    public Setting<int> setting;

    public bool init;

    public IEnumerator Start()
    {
        yield return LocalizationSettings.InitializationOperation;
        dropdown.options = ((IEnumerable<Locale>)LocalizationSettings.AvailableLocales.Locales).Select((Func<Locale, OptionData>)((Locale locale) => new OptionData((locale).name))).ToList();
        init = true;
        OnEnable();
    }

    public void OnEnable()
    {
        if (init && setting != null)
        {
            int value = LocalizationSettings.AvailableLocales.Locales.IndexOf(LocalizationSettings.SelectedLocale);
            setting.SetValue(value);
        }
    }

    public void Set(int value)
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        Locale val = LocalizationSettings.AvailableLocales.Locales[value];
        LocaleIdentifier identifier = val.Identifier;
        Settings.Save("Language", ((identifier)).Code);
        LocalizationSettings.SelectedLocale = LocalizationSettings.AvailableLocales.Locales[value];
    }
}
public class SetSettingFloat : MonoBehaviour
{
    [SerializeField]
    public Setting<float> setting;

    [SerializeField]
    public string key = "ScreenShake";

    [SerializeField]
    public float defaultValue = 1f;

    public void OnEnable()
    {
        if (setting != null)
        {
            setting.SetValue(Settings.Load(key, defaultValue));
        }
    }

    public void Set(float value)
    {
        Settings.Save(key, value);
    }
}
public class SetSettingInt : MonoBehaviour
{
    [SerializeField]
    public Setting<int> setting;

    [SerializeField]
    public string key = "Language";

    [SerializeField]
    public int defaultValue;

    public string Key => key;

    public void OnEnable()
    {
        if (setting != null)
        {
            setting.SetValue(Settings.Load(key, defaultValue));
        }
    }

    public void Set(int value)
    {
        Settings.Save(key, value);
    }
}
public abstract class Setting<T> : MonoBehaviour
{
    public virtual void SetValue(T value)
    {
    }

    public Setting()
    {
    }
}
public class SettingOptions : Setting<int>
{
    [SerializeField]
    public TMP_Dropdown dropdown;

    [SerializeField]
    public GameObject tweener;

    [SerializeField]
    public AnimationCurve tweenCurve;

    [SerializeField]
    public float tweenDur = 0.33f;

    [SerializeField]
    public UnityEvent<int> onValueChanged;

    public override void SetValue(int value)
    {
        if (value < 0)
        {
            value += dropdown.options.Count;
        }
        value %= dropdown.options.Count;
        dropdown.value = value;
    }

    public void Add(float single)
    {
        if (single > 0f)
        {
            Increase();
        }
        else if (single < 0f)
        {
            Decrease();
        }
    }

    public void Increase()
    {
        SetValue(dropdown.value + 1);
        Tween(1);
        onValueChanged?.Invoke(dropdown.value);
    }

    public void Decrease()
    {
        SetValue(dropdown.value - 1);
        Tween(-1);
        onValueChanged?.Invoke(dropdown.value);
    }

    public void Tween(int dir)
    {
        LeanTween.cancel(tweener);
        LeanTween.moveLocalX(tweener, 0.1f * (float)dir, tweenDur).setFrom(0f).setEase(tweenCurve)
            .setIgnoreTimeScale(useUnScaledTime: true);
    }
}
public class SettingSlider : Setting<float>
{
    [SerializeField]
    public Slider slider;

    public override void SetValue(float value)
    {
        slider.value = value;
    }
}
public class SetVolume : MonoBehaviour
{
    [SerializeField]
    public string busName = "Master";

    [SerializeField]
    public Setting<float> setting;

    public void OnEnable()
    {
        if (setting != null)
        {
            setting.SetValue(AudioSettingsSystem.GetVolume(busName));
        }
    }

    public void Set(float value)
    {
        AudioSettingsSystem.Volume(busName, value);
    }
}
public class SmoothScrollRect : ScrollRect
{
    [SerializeField]
    public float speed = 1f;

    public const float smoothScrollTime = 0.1f;

    public const LeanTweenType smoothScrollEase = LeanTweenType.easeOutQuart;

    public LTDescr tween;

    public override void OnScroll(PointerEventData data)
    {
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        if (isActiveAndEnabled)
        {
            Vector2 normalizedPosition = ((ScrollRect)this).normalizedPosition;
            if (tween != null)
            {
                LeanTween.cancel(tween.uniqueId);
            }
            ((ScrollRect)this).OnScroll(data);
            Vector2 to = Vector2Ext.Clamp(((ScrollRect)this).normalizedPosition, Vector2.zero, Vector2.one);
            ((ScrollRect)this).normalizedPosition = normalizedPosition;
            tween = LeanTween.value(gameObject, normalizedPosition, to, ((ScrollRect)this).scrollSensitivity * 0.1f).setEase(LeanTweenType.easeOutQuart).setOnUpdateVector2(delegate (Vector2 a)
            {
                //IL_0001: Unknown result type (might be due to invalid IL or missing references)
                ((ScrollRect)this).normalizedPosition = a;
            });
            tween.setIgnoreTimeScale(useUnScaledTime: true);
        }
    }

    public void ScrollTo(Vector2 targetPosition)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        Vector2 normalizedPosition = ((ScrollRect)this).normalizedPosition;
        if (tween != null)
        {
            LeanTween.cancel(tween.uniqueId);
        }
        ((ScrollRect)this).content.anchoredPosition = targetPosition;
        Vector2 to = Vector2Ext.Clamp(((ScrollRect)this).normalizedPosition, Vector2.zero, Vector2.one);
        ((ScrollRect)this).normalizedPosition = normalizedPosition;
        tween = LeanTween.value(gameObject, normalizedPosition, to, ((ScrollRect)this).scrollSensitivity * 0.1f / speed).setEase(LeanTweenType.easeOutQuart).setOnUpdateVector2(delegate (Vector2 a)
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            ((ScrollRect)this).normalizedPosition = a;
        });
        tween.setIgnoreTimeScale(useUnScaledTime: true);
    }

    public void SetContent(GameObject comp)
    {
        RectTransform component = comp.GetComponent<RectTransform>();
        if (component != null)
        {
            ((ScrollRect)this).content = component;
        }
    }

    public void SetContent(RectTransform rectTransform)
    {
        ((ScrollRect)this).content = rectTransform;
    }

    public void ScrollToTop()
    {
        ((ScrollRect)this).verticalNormalizedPosition = 1f;
    }

    public void ScrollToTopAfterFrame()
    {
        StartCoroutine(ScrollToTopAfterFrameRoutine());
    }

    public IEnumerator ScrollToTopAfterFrameRoutine()
    {
        yield return (object)new WaitForEndOfFrame();
        ScrollToTop();
    }
}
[RequireComponent(typeof(HorizontalOrVerticalLayoutGroup))]
public class SpacingBasedOnAspect : MonoBehaviour
{
    [SerializeField]
    public AnimationCurve curve;

    [SerializeField]
    public float maxSpacing;

    [SerializeField]
    public float minSpacing;

    public HorizontalOrVerticalLayoutGroup _layout;

    public HorizontalOrVerticalLayoutGroup layout => _layout ?? (_layout = GetComponent<HorizontalOrVerticalLayoutGroup>());

    public void UpdatePosition(RectTransform canvas)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        Vector2 sizeDelta = canvas.sizeDelta;
        float num = sizeDelta.x / sizeDelta.y;
        float num2 = curve.Evaluate(num);
        layout.spacing = minSpacing + (maxSpacing - minSpacing) * num2;
    }
}
[RequireComponent(typeof(Image))]
public class Sparkle : MonoBehaviourRect
{
    public Vector2 moveSpeed = new Vector2(0.1f, -1f);

    public Vector2 moveSway = new Vector2(0.6f, 0.3f);

    public Vector2 moveSwayTime = new Vector2(0.62f, 0.49f);

    public Vector3 rotation = new Vector3(0f, 0f, 0f);

    public float time;

    public Image _image;

    public float _size;

    public Image image
    {
        get
        {
            if (_image == null)
            {
                _image = GetComponent<Image>();
            }
            return _image;
        }
    }

    public float size
    {
        get
        {
            return _size;
        }
        set
        {
            //IL_0019: Unknown result type (might be due to invalid IL or missing references)
            _size = value;
            base.rectTransform.sizeDelta = new Vector2(_size, _size);
        }
    }

    public Color color
    {
        get
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            return ((Graphic)image).color;
        }
        set
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            ((Graphic)image).color = value;
        }
    }

    public Sprite sprite
    {
        get
        {
            return image.sprite;
        }
        set
        {
            image.sprite = value;
        }
    }

    public void Start()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(gameObject);
        LeanTween.scale(gameObject, Vector3.one * 0.5f, Random.Range(1.5f, 1.75f)).setEase(LeanTweenType.easeInOutSine).setLoopPingPong();
    }

    public void Update()
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Unknown result type (might be due to invalid IL or missing references)
        //IL_007d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0082: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0094: Unknown result type (might be due to invalid IL or missing references)
        //IL_0095: Unknown result type (might be due to invalid IL or missing references)
        time += Time.deltaTime;
        Vector2 val = moveSway * moveSwayTime * Mathf.Sin(time);
        Vector2 val2 = (moveSpeed + val) * size * Time.deltaTime;
        transform.localPosition = Vector3Ext.Add(transform.localPosition, val2);
        Vector3 val3 = rotation * Time.deltaTime;
        transform.localEulerAngles = Vector3Ext.Add(transform.localEulerAngles, val3);
    }
}
public class SparkleSpawner : MonoBehaviourRect
{
    public int sparkleCount;

    public Sprite sparkleSprite;

    public Queue<Sparkle> pool = new Queue<Sparkle>();

    public List<Transform> activeSparkles = new List<Transform>();

    public Vector2 sizeRange = new Vector2(0.25f, 0.75f);

    public Color colour = Color.white;

    public Vector2 spawnTimeRange = new Vector2(0.75f, 1f);

    public float timer;

    public void Update()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0075: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ab: Unknown result type (might be due to invalid IL or missing references)
        Rect rect = base.rectTransform.rect;
        float y = ((rect)).position.y;
        for (int num = activeSparkles.Count - 1; num >= 0; num--)
        {
            Transform val = activeSparkles[num];
            Vector3 localPosition = val.localPosition;
            if (localPosition.y < y)
            {
                pool.Enqueue(((Component)val).GetComponent<Sparkle>());
                ((Component)val).gameObject.SetActive(false);
                activeSparkles.Remove(val);
            }
            else
            {
                val.localPosition = localPosition;
            }
        }
        timer -= Time.deltaTime;
        if (timer <= 0f)
        {
            NewSparkle();
            timer = Vector2Ext.PettyRandom(spawnTimeRange);
        }
    }

    public void NewSparkle()
    {
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        //IL_009d: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00df: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f1: Unknown result type (might be due to invalid IL or missing references)
        //IL_0125: Unknown result type (might be due to invalid IL or missing references)
        Sparkle sparkle;
        if (pool.Count <= 0)
        {
            sparkle = new GameObject($"Sparkle {sparkleCount++}").AddComponent<Sparkle>();
            sparkle.sprite = sparkleSprite;
            ((Component)sparkle).transform.SetParent(transform);
        }
        else
        {
            sparkle = pool.Dequeue();
            ((Component)sparkle).gameObject.SetActive(true);
        }
        float num = Vector2Ext.PettyRandom(sizeRange);
        float num2 = Mathf.Min(1f, num * 2f) * 0.5f;
        Rect rect = base.rectTransform.rect;
        Vector3 localPosition = Vector2Ext.WithZ(((rect)).position + new Vector2(Random.Range(0f, ((rect)).width), ((rect)).height), 0f);
        RectTransform component = ((Component)sparkle).GetComponent<RectTransform>();
        ((Transform)component).localPosition = localPosition;
        ((Transform)component).localEulerAngles = Vector3.zero;
        ((Transform)component).localScale = Vector3.one;
        sparkle.size = num;
        sparkle.color = new Color(colour.r, colour.g, colour.b, num2);
        activeSparkles.Add(((Component)sparkle).transform);
    }
}
public class SpeechBubble : MonoBehaviour
{
    [SerializeField]
    public TMP_Text textElement;

    public void SetSize(float size)
    {
        textElement.fontSize = size;
    }

    public void SetTextColour(Color color)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        ((Graphic)textElement).color = color;
    }

    public void SetTextSpriteAsset(TMP_SpriteAsset spriteAsset)
    {
        textElement.spriteAsset = spriteAsset;
    }

    public void SetText(string text)
    {
        textElement.text = text;
    }
}
public class StatDisplay : MonoBehaviour
{
    [SerializeField]
    public TMP_Text textElement;

    [SerializeField]
    public LocalizeStringEvent localizeStringEvent;

    public string statValue;

    public void Assign(GameStatData statData, string stringValue)
    {
        statValue = stringValue;
        localizeStringEvent.StringReference = statData.stringKey;
    }

    public void SetText(string text)
    {
        textElement.text = text.Replace("{0}", "<#fff>" + statValue);
    }
}
public class StatNumberDisplay : MonoBehaviour
{
    [SerializeField]
    public bool disableIfZero = true;

    [SerializeField]
    public string statName = "damageDealt";

    [SerializeField]
    public string statKey = "basic";

    [SerializeField]
    public TMP_Text text;

    public void OnEnable()
    {
        int num = OverallStatsSystem.Get().Get(statName, statKey, 0);
        if (disableIfZero && num <= 0)
        {
            gameObject.SetActive(false);
        }
        else
        {
            text.text = num.ToString();
        }
    }
}
public class StatsPanel : MonoBehaviour
{
    public struct Stat
    {
        public readonly GameStatData statData;

        public readonly float value;

        public readonly string stringValue;

        public readonly float priority;

        public Stat(GameStatData statData, CampaignStats runStats)
        {
            this.statData = statData;
            value = statData.GetValue(runStats);
            stringValue = statData.GetStringValue(runStats, value);
            priority = statData.GetPriority(value);
        }
    }

    [SerializeField]
    public TMP_Text titleElement;

    [SerializeField]
    public TMP_Text subtitleElement;

    [SerializeField]
    public Transform statsGroup;

    [SerializeField]
    public StatDisplay statPrefab;

    [SerializeField]
    public int maxStats = 6;

    [SerializeField]
    public GameStatData[] stats;

    public void Awake()
    {
        CardData leaderData = References.LeaderData;
        titleElement.text = leaderData.title;
        ((Component)subtitleElement).gameObject.SetActive(false);
        CampaignStats runStats = StatsSystem.Get();
        IListExt.Shuffle<GameStatData>((IList<GameStatData>)stats);
        foreach (Stat item in from s in (from s in stats
                                         select new Stat(s, runStats) into s
                                         where s.value > 0f
                                         orderby Random.Range(0f, s.priority) descending
                                         select s).Take(maxStats)
                              orderby s.statData.displayOrder descending
                              select s)
        {
            StatDisplay statDisplay = Object.Instantiate<StatDisplay>(statPrefab, statsGroup);
            ((Component)statDisplay).gameObject.SetActive(true);
            statDisplay.Assign(item.statData, item.stringValue);
        }
    }
}
public class StatsPanelSplatters : MonoBehaviour
{
    public struct Profile
    {
        public readonly Vector2 anchorMin;

        public readonly Vector2 anchorMax;

        public readonly Vector2 moveRange;

        public Profile(float minX, float minY, float maxX, float maxY, float moveX, float moveY)
        {
            //IL_0003: Unknown result type (might be due to invalid IL or missing references)
            //IL_0008: Unknown result type (might be due to invalid IL or missing references)
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            //IL_0020: Unknown result type (might be due to invalid IL or missing references)
            //IL_0025: Unknown result type (might be due to invalid IL or missing references)
            anchorMin = new Vector2(minX, minY);
            anchorMax = new Vector2(maxX, maxY);
            moveRange = new Vector2(moveX, moveY);
        }
    }

    [SerializeField]
    public Sprite[] splatterSprites;

    [SerializeField]
    public ImageSprite[] splatters;

    public static readonly Profile[] profiles = new Profile[8]
    {
        new Profile(1f, 1f, 1f, 1f, 0f, -2f),
        new Profile(1f, 0.5f, 1f, 0.5f, 0f, -2f),
        new Profile(1f, 0f, 1f, 0f, -2f, 0f),
        new Profile(0f, 1f, 0f, 1f, 2f, 0f),
        new Profile(0f, 0.5f, 0f, 0.5f, 0f, 2f),
        new Profile(0f, 0f, 0f, 0f, 0f, 2f),
        new Profile(0.5f, 1f, 0.5f, 1f, 2f, 0f),
        new Profile(0.5f, 0f, 0.5f, 0f, -2f, 0f)
    };

    public readonly List<Sprite> spritePool = new List<Sprite>();

    public readonly List<Profile> profilePool = new List<Profile>();

    public void OnEnable()
    {
        //IL_00ba: Unknown result type (might be due to invalid IL or missing references)
        List<Color> list = new List<Color>();
        SplatterPersistenceSystem splatterPersistenceSystem = Object.FindObjectOfType<SplatterPersistenceSystem>();
        if (splatterPersistenceSystem.storedSplatters != null && splatterPersistenceSystem.storedSplatters.Count > 0)
        {
            foreach (SplatterPersistenceSystem.SplatterData[] value in splatterPersistenceSystem.storedSplatters.Values)
            {
                list.AddRange(value.Select((SplatterPersistenceSystem.SplatterData a) => a.color));
            }
        }
        int num = Mathf.Min(splatters.Length, list.Count);
        for (int i = 0; i < num; i++)
        {
            ImageSprite image = splatters[i];
            Profile profile = PullProfile();
            Sprite sprite = PullSprite();
            Set(image, profile, sprite, IListExt.RandomItem<Color>((IList<Color>)list));
        }
    }

    public Profile PullProfile()
    {
        if (profilePool.Count <= 0)
        {
            profilePool.AddRange(profiles);
        }
        return IListExt.TakeRandom<Profile>((IList<Profile>)profilePool);
    }

    public Sprite PullSprite()
    {
        if (spritePool.Count <= 0)
        {
            spritePool.AddRange(splatterSprites);
        }
        return IListExt.TakeRandom<Sprite>((IList<Sprite>)spritePool);
    }

    public static void Set(ImageSprite image, Profile profile, Sprite sprite, Color color)
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        ((Component)image).gameObject.SetActive(true);
        image.SetSprite(sprite);
        ((Graphic)image).color = color;
        Transform transform = ((Component)image).transform;
        RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
        if (val != null)
        {
            val.anchorMax = profile.anchorMax;
            val.anchorMin = profile.anchorMin;
            val.anchoredPosition = new Vector2(Random.Range(0f, profile.moveRange.x), Random.Range(0f, profile.moveRange.y));
            ((Transform)val).localEulerAngles = new Vector3(0f, 0f, Random.Range(0f, 360f));
        }
    }
}
[RequireComponent(typeof(TMP_Text))]
public class TextFitter : MonoBehaviourRect
{
    public TMP_Text _textElement;

    [SerializeField]
    public LayoutElement layoutElement;

    [SerializeField]
    public RectTransform[] transforms;

    [SerializeField]
    public bool fitWidth = true;

    [SerializeField]
    [ShowIf("fitWidth")]
    public float minWidth = 3f;

    [SerializeField]
    [ShowIf("fitWidth")]
    public float maxWidth = 5f;

    [SerializeField]
    public bool fitHeight = true;

    [SerializeField]
    [ShowIf("fitHeight")]
    public float minHeight = 1f;

    [SerializeField]
    [ShowIf("fitHeight")]
    public float maxHeight = 1f;

    public TMP_Text textElement => _textElement ?? (_textElement = GetComponent<TMP_Text>());

    public void SetText(string text)
    {
        textElement.text = text;
        Fit();
    }

    public void Fit()
    {
        StopAllCoroutines();
        if (fitWidth)
        {
            StartCoroutine(FitRoutine());
        }
    }

    public IEnumerator FitRoutine()
    {
        yield return (object)new WaitForEndOfFrame();
        Vector4 margin = textElement.margin;
        Bounds textBounds = textElement.textBounds;
        Vector3 size = ((textBounds)).size;
        Vector2 sizeDelta = base.rectTransform.sizeDelta;
        float num = (fitWidth ? Mathf.Clamp(size.x + margin.x + margin.z, minWidth, maxWidth) : sizeDelta.x);
        float num2 = (fitHeight ? Mathf.Clamp(size.y + margin.y + margin.w, minHeight, maxHeight) : sizeDelta.y);
        Vector2 sizeDelta2 = Vector2Ext.With(sizeDelta, (float?)num, (float?)num2);
        base.rectTransform.sizeDelta = sizeDelta2;
        if ((layoutElement))
        {
            if (fitWidth)
            {
                layoutElement.preferredWidth = num;
            }
            if (fitHeight)
            {
                layoutElement.preferredHeight = num2;
            }
        }
        RectTransform[] array = transforms;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].sizeDelta = sizeDelta2;
        }
    }
}
[RequireComponent(typeof(TMP_Text))]
public class TextMeshFitter : MonoBehaviour
{
    public TMP_Text _textElement;

    public RectTransform _rectTransform;

    [SerializeField]
    public SpriteRenderer parentSprite;

    [SerializeField]
    public bool autoUpdate = true;

    [SerializeField]
    public Vector2 minSize;

    public bool dirty = true;

    public string text
    {
        get
        {
            return textElement.text;
        }
        set
        {
            textElement.text = value;
            dirty = true;
        }
    }

    public TMP_Text textElement => _textElement ?? (_textElement = GetComponent<TMP_Text>());

    public RectTransform rectTransform => _rectTransform ?? (_rectTransform = (RectTransform)/*isinst with value type is only supported in some contexts*/);

    public void Update()
    {
        if (dirty || (autoUpdate && textElement.havePropertiesChanged))
        {
            Run();
            dirty = false;
        }
    }

    public void Run()
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        //IL_007e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bf: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00de: Unknown result type (might be due to invalid IL or missing references)
        TMP_LineInfo[] lineInfo = textElement.textInfo.lineInfo;
        float num = 0f;
        float num2 = 0f;
        TMP_LineInfo[] array = lineInfo;
        foreach (TMP_LineInfo val in array)
        {
            if (val.characterCount > 0)
            {
                num = Mathf.Max(num, val.length);
                num2 += val.lineHeight;
            }
        }
        Vector4 margin = textElement.margin;
        num += margin.x + margin.z;
        num2 += margin.y + margin.w;
        num = Mathf.Max(minSize.x, num);
        num2 = Mathf.Max(minSize.y, num2);
        if (parentSprite != null)
        {
            Vector3 localScale = ((Transform)rectTransform).localScale;
            parentSprite.size = new Vector2(num * localScale.x, num2 * localScale.y);
        }
        rectTransform.sizeDelta = new Vector2(num, num2);
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void ForceUpdate()
    {
        Run();
    }
}
public class TextProcessor : MonoBehaviour
{
    [SerializeField]
    public TMP_Text textElement;

    public void SetText(string input)
    {
        textElement.text = Text.Process(input);
    }
}
[RequireComponent(typeof(TextMeshProUGUI))]
public class TextSwitcher : MonoBehaviour
{
    public bool useExistingTextAsFirst = true;

    public float switchTime = 1f;

    public List<string> texts;

    public int i;

    public float t;

    public TextMeshProUGUI tmp;

    public void Awake()
    {
        tmp = GetComponent<TextMeshProUGUI>();
        if (useExistingTextAsFirst)
        {
            texts.Insert(0, ((TMP_Text)tmp).text);
        }
        t = switchTime;
    }

    public void Update()
    {
        t -= Time.deltaTime;
        while (t <= 0f)
        {
            i = (i + 1) % texts.Count;
            ((TMP_Text)tmp).text = texts[i];
            t += switchTime;
        }
    }
}
public class TextTypewrite : MonoBehaviour
{
    [SerializeField]
    public TMP_Text textElement;

    public const float startDelay = 0.25f;

    public const float defaultPause = 0.05f;

    public static readonly Dictionary<char, float> lookup = new Dictionary<char, float>
    {
        { ' ', 0.005f },
        { ',', 0.4f },
        { '，', 0.4f },
        { '.', 0.15f },
        { '…', 0.4f }
    };

    public IEnumerator Write()
    {
        textElement.maxVisibleCharacters = 0;
        yield return (object)new WaitForSeconds(0.25f);
        int total = textElement.textInfo.characterCount;
        for (int i = 0; i < total; i++)
        {
            textElement.maxVisibleCharacters = i + 1;
            char character = textElement.textInfo.characterInfo[i].character;
            float num = (lookup.ContainsKey(character) ? lookup[character] : 0.05f);
            yield return (object)new WaitForSeconds(num);
        }
    }
}
public class TitleSetter : MonoBehaviour
{
    [SerializeField]
    public GameObject gameObject;

    [SerializeField]
    public LocalizeStringEvent text;

    [SerializeField]
    public Image underline;

    [SerializeField]
    public bool setActive = true;

    [SerializeField]
    [ShowIf("setActive")]
    public LocalizedString setKey;

    [SerializeField]
    [ShowIf("setActive")]
    public Sprite setUnderlineSprite;

    public void Set()
    {
        gameObject.SetActive(setActive);
        if (setActive)
        {
            text.StringReference = setKey;
            underline.sprite = setUnderlineSprite;
        }
    }
}
public class ToggleSprite : MonoBehaviour
{
    [SerializeField]
    public Image image;

    [SerializeField]
    public Sprite onSprite;

    [SerializeField]
    public Sprite offSprite;

    public void Set(bool value)
    {
        image.sprite = (value ? onSprite : offSprite);
    }
}
public class CardPopUpPanel : Tooltip
{
    [Header("Text")]
    [SerializeField]
    public float titleSize = 0.3f;

    [SerializeField]
    public float iconSize = 0.275f;

    [SerializeField]
    public float bodySize = 0.25f;

    [SerializeField]
    public float noteSize = 0.21f;

    [SerializeField]
    public TextMeshProUGUI textElement;

    [SerializeField]
    public Fitter fitter;

    public static readonly Color defaultTitleColor = new Color(1f, 0.7921569f, 0.3411765f, 1f);

    public static readonly Color defaultBodyColor = Color.white;

    public static readonly Color defaultNoteColor = new Color(0.65f, 0.65f, 0.65f);

    public string titleText;

    public string bodyText;

    public string noteText;

    public string text => ((TMP_Text)textElement).text;

    public void Set(string iconName, string iconTintHex, string title, Color titleColour, string body, Color bodyColour, Sprite panelSprite, Color panelColor)
    {
        //IL_0004: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        SetRoutine(iconName, iconTintHex, title, titleColour, body, bodyColour, "", Color.white, panelSprite, panelColor);
    }

    public void Set(string iconName, string iconTintHex, string title, Color titleColour, string body, Color bodyColour)
    {
        //IL_0004: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        SetRoutine(iconName, iconTintHex, title, titleColour, body, bodyColour, "", Color.white, defaultPanelSprite, defaultPanelColor);
    }

    public void Set(string title, string body)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        Set(title, defaultTitleColor, body, defaultBodyColor);
    }

    public void Set(string title, Color titleColour, string body, Color bodyColour)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        SetRoutine("", "", title, titleColour, body, bodyColour, "", Color.white, defaultPanelSprite, defaultPanelColor);
    }

    public void Set(string text, Color textColour)
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        SetRoutine("", "", "", Color.white, text, textColour, "", Color.white, defaultPanelSprite, defaultPanelColor);
    }

    public void Set(KeywordData keyword, string forceBody = null)
    {
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        string title = (keyword.HasTitle ? keyword.title : "");
        string body = forceBody ?? keyword.body;
        SetRoutine(keyword.iconName, keyword.iconTintHex, title, keyword.titleColour, body, keyword.bodyColour, keyword.note, keyword.noteColour, keyword.panelSprite, keyword.panelColor);
    }

    public void SetRoutine(string iconName, string iconTintHex, string title, Color titleColour, string body, Color bodyColour, string note, Color noteColour, Sprite panelSprite, Color panelColor)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_007f: Unknown result type (might be due to invalid IL or missing references)
        SetTitle(title, titleColour, iconName, iconTintHex);
        SetBody(body, bodyColour);
        SetNote(note, noteColour);
        BuildTextElement();
        panel.sprite = ((panelSprite) ? panelSprite : defaultPanelSprite);
        ((Graphic)panel).color = ((panelSprite) ? panelColor : defaultPanelColor);
        if ((fitter))
        {
            LeanTween.cancel(gameObject);
            transform.localScale = Vector3.one;
            canvasGroup.alpha = 0f;
            fitter.Fit(base.Ping);
        }
        else
        {
            Ping();
        }
    }

    public void SetTitle(string title, Color titleColour, string iconName, string iconTintHex)
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        titleText = "";
        if (!StringExt.IsNullOrWhitespace(title))
        {
            string arg = ColorExt.ToHexRGBA(titleColour);
            titleText += $"<size={titleSize}><#{arg}>{Text.Process(title)}";
        }
        if (!StringExt.IsNullOrWhitespace(iconName))
        {
            if (!StringExt.IsNullOrWhitespace(iconTintHex))
            {
                titleText += $"<size={iconSize}><sprite name=\"{iconName}\" color=#{iconTintHex}></size>";
            }
            else
            {
                titleText += $"<size={iconSize}><sprite name=\"{iconName}\"></size>";
            }
        }
    }

    public void AddToTitle(string text, bool newline = true)
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        if (StringExt.IsNullOrWhitespace(titleText))
        {
            SetTitle(text, defaultTitleColor, "", "");
            return;
        }
        if (newline)
        {
            titleText += "\n";
        }
        titleText += Text.Process(text);
    }

    public void SetBody(string body, Color bodyColour)
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        bodyText = "";
        if (!StringExt.IsNullOrWhitespace(body))
        {
            string arg = ColorExt.ToHexRGBA(bodyColour);
            bodyText = $"<size={bodySize}><#{arg}>{Text.Process(body)}";
        }
    }

    public void AddToBody(string text, bool newline = true)
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        if (StringExt.IsNullOrWhitespace(bodyText))
        {
            SetBody(text, defaultBodyColor);
            return;
        }
        if (newline)
        {
            bodyText += "\n";
        }
        bodyText += Text.Process(text);
    }

    public void SetNote(string note, Color noteColour)
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        noteText = "";
        if (!StringExt.IsNullOrWhitespace(note))
        {
            string arg = ColorExt.ToHexRGBA(noteColour);
            noteText = $"<size={noteSize}><#{arg}>{note}";
        }
    }

    public void AddToNote(string text, bool newline = true)
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        if (StringExt.IsNullOrWhitespace(noteText))
        {
            SetNote(text, defaultNoteColor);
            return;
        }
        if (newline)
        {
            noteText += "\n";
        }
        noteText += text;
    }

    public void BuildTextElement()
    {
        string text = titleText;
        if (!StringExt.IsNullOrWhitespace(bodyText))
        {
            if (!StringExt.IsNullOrWhitespace(text))
            {
                text += "<line-height=96%>\n</line-height>";
            }
            text += bodyText;
        }
        if (!StringExt.IsNullOrWhitespace(noteText))
        {
            if (!StringExt.IsNullOrWhitespace(text))
            {
                text += "<line-height=96%>\n</line-height>";
            }
            text += noteText;
        }
        ((TMP_Text)textElement).text = text;
    }
}
public class CardTooltip : Tooltip
{
    [Header("Card Elements")]
    [SerializeField]
    public TMP_Text titleElement;

    [SerializeField]
    public TMP_Text descElement;

    [SerializeField]
    public Image cardArt;

    [SerializeField]
    public Image textBox;

    [SerializeField]
    public Image nameTag;

    [SerializeField]
    public Transform healthIconGroup;

    [SerializeField]
    public Transform damageIconGroup;

    [SerializeField]
    public Transform counterIconGroup;

    [SerializeField]
    public Transform crownIconGroup;

    public readonly Dictionary<string, Transform> iconGroups = new Dictionary<string, Transform>();

    public HashSet<KeywordData> keywords;

    public void Awake()
    {
        if (healthIconGroup != null)
        {
            iconGroups["health"] = healthIconGroup;
        }
        if (damageIconGroup != null)
        {
            iconGroups["damage"] = damageIconGroup;
        }
        if (counterIconGroup != null)
        {
            iconGroups["counter"] = counterIconGroup;
        }
        if (crownIconGroup != null)
        {
            iconGroups["crown"] = crownIconGroup;
        }
    }

    public void Set(CardData data)
    {
        TransformExt.DestroyAllChildren(healthIconGroup);
        TransformExt.DestroyAllChildren(damageIconGroup);
        TransformExt.DestroyAllChildren(counterIconGroup);
        TransformExt.DestroyAllChildren(crownIconGroup);
        cardArt.sprite = data.mainSprite;
        textBox.sprite = data.cardType.textBoxSprite;
        nameTag.sprite = data.cardType.nameTagSprite;
        titleElement.text = data.title;
        string description = Card.GetDescription(data);
        keywords = Text.GetKeywords(description);
        string text = Text.Process(description, 0, 1f, data.cardType.descriptionColours);
        if (StringExt.IsNullOrWhitespace(text))
        {
            LocalizedString flavourKey = data.flavourKey;
            if (flavourKey != null && !((LocalizedReference)flavourKey).IsEmpty)
            {
                string localizedString = data.flavourKey.GetLocalizedString();
                text = "<i><color=#" + data.cardType.descriptionColours.flavourColour + ">" + localizedString;
            }
        }
        descElement.text = text;
        if (data.hasHealth)
        {
            CreateIcon("health", "health", data.hp);
        }
        if (data.hasAttack)
        {
            CreateIcon("damage", "damage", data.damage);
        }
        if (data.counter > 0)
        {
            CreateIcon("counter", "counter", data.counter);
        }
        CardData.StatusEffectStacks[] startWithEffects = data.startWithEffects;
        foreach (CardData.StatusEffectStacks statusEffectStacks in startWithEffects)
        {
            if (statusEffectStacks.data.visible && !StringExt.IsNullOrWhitespace(statusEffectStacks.data.iconGroupName))
            {
                CreateIcon(statusEffectStacks.data.type, statusEffectStacks.data.iconGroupName, statusEffectStacks.count);
            }
        }
        Ping();
    }

    public void CreateIcon(string type, string iconGroupName, int value)
    {
        CardManager.NewStatusIcon(type, iconGroups[iconGroupName]).SetValue(new Stat(value), doPing: false);
    }
}
public abstract class Tooltip : MonoBehaviour
{
    public bool animate = true;

    public bool ignoreTimeScale;

    public readonly HashSet<Tooltip> children = new HashSet<Tooltip>();

    [SerializeField]
    public CanvasGroup canvasGroup;

    [Header("Panel")]
    [SerializeField]
    public Image panel;

    [SerializeField]
    public Sprite defaultPanelSprite;

    [SerializeField]
    public Color defaultPanelColor;

    [Header("Animation")]
    [SerializeField]
    public Vector3 scaleFrom = Vector3.zero;

    [SerializeField]
    public AnimationCurve scaleCurve;

    [SerializeField]
    public float scaleDur = 0.5f;

    [SerializeField]
    public float fadeFrom;

    [SerializeField]
    public AnimationCurve fadeCurve;

    [SerializeField]
    public float fadeDur = 0.2f;

    public void Ping()
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        if (animate)
        {
            LeanTween.cancel(gameObject);
            transform.localScale = scaleFrom;
            LeanTween.scale(gameObject, Vector3.one, scaleDur).setEase(scaleCurve).setIgnoreTimeScale(ignoreTimeScale);
            canvasGroup.alpha = fadeFrom;
            canvasGroup.LeanAlpha(1f, fadeDur).setEase(fadeCurve).setIgnoreTimeScale(ignoreTimeScale);
        }
    }

    public Tooltip()
    {
    }//IL_0013: Unknown result type (might be due to invalid IL or missing references)
     //IL_0018: Unknown result type (might be due to invalid IL or missing references)

}
public class TouchScroller : MonoBehaviour
{
    [SerializeField]
    public Scroller scroller;

    [SerializeField]
    public bool horizontal;

    [SerializeField]
    public bool vertical = true;

    [SerializeField]
    public float sensitivity = 0.0215f;

    [SerializeField]
    public float inertia = 0.15f;

    public float vx;

    public float vy;

    public const float threshold = 0.01f;

    public void Update()
    {
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0168: Unknown result type (might be due to invalid IL or missing references)
        //IL_018a: Unknown result type (might be due to invalid IL or missing references)
        if (!TouchInputModule.active || (!horizontal && !vertical) || !scroller.interactable || !scroller.CheckNavigationLayer() || scroller.DeltaTime <= 0f)
        {
            vx = 0f;
            vy = 0f;
            return;
        }
        Vector2 anchoredPosition = scroller.rectTransform.anchoredPosition;
        bool flag = false;
        if (horizontal)
        {
            float num = (scroller.interactable ? (TouchInputModule.ScrollX * sensitivity) : 0f);
            if (TouchInputModule.touching)
            {
                if (Mathf.Abs(num) > 0.01f)
                {
                    anchoredPosition.x += num;
                    vx = num;
                    flag = true;
                }
            }
            else if (Mathf.Abs(vx) > 0.01f)
            {
                anchoredPosition.x += vx;
                flag = true;
            }
        }
        if (vertical)
        {
            float num2 = (scroller.interactable ? (TouchInputModule.ScrollY * sensitivity) : 0f);
            if (TouchInputModule.touching)
            {
                if (Mathf.Abs(num2) > 0.01f)
                {
                    anchoredPosition.y += num2;
                    vy = num2;
                    flag = true;
                }
            }
            else if (Mathf.Abs(vy) > 0.01f)
            {
                anchoredPosition.y += vy;
                flag = true;
            }
        }
        if (flag)
        {
            scroller.ScrollTo(anchoredPosition);
            scroller.CheckBounds();
            scroller.rectTransform.anchoredPosition = scroller.targetPos;
        }
        if (horizontal)
        {
            vx = Delta.Lerp(vx, 0f, inertia, scroller.DeltaTime);
        }
        if (vertical)
        {
            vy = Delta.Lerp(vy, 0f, inertia, scroller.DeltaTime);
        }
    }
}
public class TribeFlagDisplay : MonoBehaviour
{
    public Image flagImage;

    [SerializeField]
    public Sprite flagSprite;

    [SerializeField]
    public GameObject locked;

    [SerializeField]
    public ButtonAnimator button;

    [SerializeField]
    public InputAction inputAction;

    public void SetFlagSprite(Sprite sprite)
    {
        flagSprite = sprite;
        flagImage.sprite = sprite;
    }

    public void AddPressAction(UnityAction action)
    {
        inputAction.action.AddListener(action);
    }

    public void ClearPressActions()
    {
        ((UnityEventBase)inputAction.action).RemoveAllListeners();
    }

    public void SetInteractable(bool interactable)
    {
        button.interactable = interactable;
    }

    public void SetUnlocked()
    {
        flagImage.sprite = flagSprite;
        button.interactable = true;
    }

    public void SetAvailable()
    {
        locked.SetActive(false);
    }
}
public class TurnOrderButton : MonoBehaviour
{
    [SerializeField]
    public ButtonAnimator button;

    [SerializeField]
    public Image image;

    [SerializeField]
    public Sprite openSprite;

    [SerializeField]
    public Sprite closedSprite;

    [SerializeField]
    public ParticleSystem particleSystem;

    public void Awake()
    {
        Events.OnSceneChanged += SceneChanged;
        SetActive(value: false);
    }

    public void OnDestroy()
    {
        Events.OnSceneChanged -= SceneChanged;
    }

    public void OnEnable()
    {
        Events.OnCardControllerEnabled += CardControllerEnabled;
        Events.OnCardControllerDisabled += CardControllerDisabled;
    }

    public void OnDisable()
    {
        Events.OnCardControllerEnabled -= CardControllerEnabled;
        Events.OnCardControllerDisabled -= CardControllerDisabled;
    }

    public void CardControllerEnabled(CardController controller)
    {
        if ((References.Battle) && controller == References.Battle.playerCardController)
        {
            button.interactable = true;
        }
    }

    public void CardControllerDisabled(CardController controller)
    {
        if ((References.Battle) && controller == References.Battle.playerCardController)
        {
            button.interactable = false;
        }
    }

    public void SceneChanged(Scene scene)
    {
        SetActive(((scene)).name == "Battle");
    }

    public void SetActive(bool value)
    {
        gameObject.SetActive(value);
        button.interactable = value;
        CloseEye();
        button.interactable = false;
    }

    public void Select()
    {
        if (ActionQueue.Empty && (!(References.Battle) || !(References.Battle.playerCardController.dragging)))
        {
            Object.FindObjectOfType<TurnOrderDisplay>()?.Toggle();
        }
    }

    public void OpenEye()
    {
        image.sprite = openSprite;
        particleSystem.Play();
    }

    public void CloseEye()
    {
        image.sprite = closedSprite;
        particleSystem.Stop();
    }
}
public class TurnOrderDisplay : MonoBehaviour
{
    [SerializeField]
    public Transform group;

    [SerializeField]
    public TurnOrderNumber prefab;

    [SerializeField]
    public CanvasGroup vignette;

    [SerializeField]
    public float musicPitch = 0.9f;

    public bool active;

    public readonly List<TurnOrderNumber> numbers = new List<TurnOrderNumber>();

    public void Toggle()
    {
        if (active)
        {
            Clear();
        }
        else
        {
            Display();
        }
    }

    public void Display()
    {
        //IL_00e2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ec: Expected O, but got Unknown
        if (active)
        {
            return;
        }
        int num = 1;
        foreach (Entity item in Battle.GetCardsOnBoard(References.Battle.enemy))
        {
            if (item.data.counter > 0)
            {
                CreateNumber(item, num++);
            }
        }
        foreach (Entity item2 in Battle.GetCardsOnBoard(References.Battle.player))
        {
            if (item2.data.counter > 0)
            {
                CreateNumber(item2, num++);
            }
        }
        active = true;
        Events.OnEntitySelect += EntitySelect;
        Events.OnRedrawBellHit += RedrawBellHit;
        Events.OnDeckpackOpen += new UnityAction(DeckpackOpen);
        Events.OnInspect += Inspect;
        OpenEye();
        ((Component)vignette).gameObject.SetActive(true);
        vignette.alpha = 0f;
        LeanTween.cancel(((Component)vignette).gameObject);
        LeanTween.alphaCanvas(vignette, 1f, 1f).setEaseOutQuart();
        Object.FindObjectOfType<BattleMusicSystem>()?.FadePitchTo(musicPitch);
    }

    public void Clear()
    {
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Expected O, but got Unknown
        if (!active)
        {
            return;
        }
        foreach (TurnOrderNumber number in numbers)
        {
            if ((number))
            {
                GameObjectExt.Destroy(((Component)number).gameObject);
            }
        }
        numbers.Clear();
        active = false;
        Events.OnEntitySelect -= EntitySelect;
        Events.OnRedrawBellHit -= RedrawBellHit;
        Events.OnDeckpackOpen -= new UnityAction(DeckpackOpen);
        Events.OnInspect -= Inspect;
        CloseEye();
        if ((vignette))
        {
            ((Component)vignette).gameObject.SetActive(false);
        }
        Object.FindObjectOfType<BattleMusicSystem>()?.FadePitchTo(1f);
    }

    public static void OpenEye()
    {
        Object.FindObjectOfType<TurnOrderButton>()?.OpenEye();
    }

    public static void CloseEye()
    {
        Object.FindObjectOfType<TurnOrderButton>()?.CloseEye();
    }

    public void CreateNumber(Entity entity, int number)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        Vector3 containerWorldPosition = entity.GetContainerWorldPosition();
        TurnOrderNumber turnOrderNumber = Object.Instantiate<TurnOrderNumber>(prefab, containerWorldPosition, Quaternion.identity, group);
        turnOrderNumber.Set(entity, number);
        numbers.Add(turnOrderNumber);
    }

    public void EntitySelect(Entity entity)
    {
        Clear();
    }

    public void RedrawBellHit(RedrawBellSystem redrawBell)
    {
        Clear();
    }

    public void DeckpackOpen()
    {
        Clear();
    }

    public void Inspect(Entity entity)
    {
        Clear();
    }
}
public class TurnOrderNumber : MonoBehaviour
{
    [SerializeField]
    public Image glow;

    [SerializeField]
    public Color imminentGlowColour = Color.red;

    [SerializeField]
    public Image image;

    [SerializeField]
    public Sprite imminentSprite;

    [SerializeField]
    public TMP_Text textElement;

    public void Set(Entity entity, int number)
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        textElement.text = number.ToString();
        if (entity.counter.current <= 1 && !entity.IsSnowed)
        {
            ((Graphic)glow).color = imminentGlowColour;
            image.sprite = imminentSprite;
        }
    }
}
public class TurnOrderOverlay : MonoBehaviour
{
    [SerializeField]
    public GameObject overlay;

    [SerializeField]
    public GameObject button;

    [SerializeField]
    public TMP_Text numberPrefab;

    public List<TMP_Text> numbers;

    public void OnEnable()
    {
        Events.OnBattlePhaseStart += BattlePhaseStart;
    }

    public void OnDisable()
    {
        Events.OnBattlePhaseStart -= BattlePhaseStart;
    }

    public void BattlePhaseStart(Battle.Phase phase)
    {
        switch (phase)
        {
            case Battle.Phase.Battle:
            case Battle.Phase.End:
                button.SetActive(false);
                break;
            case Battle.Phase.Play:
                button.SetActive(true);
                break;
        }
    }

    public void Toggle()
    {
        if (overlay.activeSelf)
        {
            Deactivate();
        }
        else
        {
            Activate();
        }
    }

    public void Activate()
    {
        //IL_0059: Unknown result type (might be due to invalid IL or missing references)
        overlay.SetActive(true);
        HashSet<Entity> allUnits = Battle.GetAllUnits();
        int num = 1;
        if (numbers == null)
        {
            numbers = new List<TMP_Text>();
        }
        foreach (Entity item in allUnits)
        {
            TMP_Text val = Object.Instantiate<TMP_Text>(numberPrefab, overlay.transform);
            val.transform.localPosition = item.transform.position;
            val.text = num.ToString();
            ((Component)val).gameObject.SetActive(true);
            numbers.Add(val);
            num++;
        }
    }

    public void Deactivate()
    {
        foreach (TMP_Text number in numbers)
        {
            GameObjectExt.Destroy(((Component)number).gameObject);
        }
        numbers = null;
        overlay.SetActive(false);
    }
}
public class AssignCharmSequence : UISequence
{
    [SerializeField]
    public Image background;

    [SerializeField]
    public float backgroundAlpha = 0.67f;

    [SerializeField]
    public Transform cardHolder;

    [SerializeField]
    public float cardScale = 1f;

    [SerializeField]
    public ParticleSystem glows;

    [SerializeField]
    public ParticleSystem ding;

    [SerializeField]
    public Animator animator;

    public Entity target;

    public CardUpgradeData upgradeData;

    public float fade;

    public static float fadeInDur = 0.5f;

    public static float fadeOutDur = 0.25f;

    public Transform previousParent;

    public int previousChildIndex;

    public Vector3 previousPosition;

    public void Assign(Entity target, CardUpgradeData upgradeData)
    {
        this.target = target;
        this.upgradeData = upgradeData;
    }

    public void Focus()
    {
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_006f: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ac: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d9: Unknown result type (might be due to invalid IL or missing references)
        target.ForceUnHover();
        previousParent = target.transform.parent;
        previousChildIndex = target.transform.GetSiblingIndex();
        previousPosition = target.transform.localPosition;
        target.transform.SetParent(cardHolder, true);
        LeanTween.moveLocal(((Component)target).gameObject, Vector3.zero, 0.5f).setEase(LeanTweenType.easeOutQuart);
        target.wobbler?.WobbleRandom();
        LeanTween.scale(((Component)target).gameObject, Vector3.one * cardScale, 0.67f).setEase(LeanTweenType.easeOutBack);
        LeanTween.rotateLocal(((Component)target).gameObject, Vector3.zero, 1f).setEase(LeanTweenType.easeOutBack);
    }

    public void Unfocus()
    {
        if ((target) && target.StillExists())
        {
            target.transform.parent = previousParent;
            target.transform.SetSiblingIndex(previousChildIndex);
            target.TweenToContainer();
            target.wobbler?.WobbleRandom();
        }
    }

    public override IEnumerator Run()
    {
        gameObject.SetActive(true);
        yield return Sequences.Wait(startDelay);
        BackgroundFade(backgroundAlpha, fadeInDur);
        Focus();
        animator.SetTrigger("Assign");
        SfxSystem.OneShot("event:/sfx/inventory/charm_assign");
        yield return (object)new WaitForSeconds(3f);
        BackgroundFade(0f, fadeOutDur);
        yield return (object)new WaitForSeconds(fadeOutDur * 0.5f);
        Unfocus();
        yield return (object)new WaitForSeconds(fadeOutDur * 0.5f);
        gameObject.SetActive(false);
    }

    public void BackgroundFade(float alpha, float dur)
    {
        LeanTween.cancel(((Component)background).gameObject);
        LeanTween.value(((Component)background).gameObject, fade, alpha, dur).setEase(LeanTweenType.easeOutQuad).setOnUpdate(delegate (float a)
        {
            //IL_0013: Unknown result type (might be due to invalid IL or missing references)
            //IL_0019: Unknown result type (might be due to invalid IL or missing references)
            fade = a;
            ((Graphic)background).color = ColorExt.WithAlpha(((Graphic)background).color, a);
        });
    }

    public void Rumble()
    {
        Events.InvokeScreenRumble(0f, 1f, 0f, 1f, 0.5f, 0.25f);
    }

    public void AssignCharm()
    {
        new Routine(upgradeData.Assign(target));
    }

    public void StartGlow()
    {
        glows.Play();
    }

    public void Ding()
    {
        ding.Play();
    }
}
public class BattleVictorySequence : MonoBehaviour
{
    public CanvasGroup fade;

    public float fadeTime = 0.5f;

    public Transform rewardContainer;

    public CardContainer injuredContainer;

    public RectTransform injuredPanel;

    [SerializeField]
    public float startDelay;

    [SerializeField]
    public GameObject winLayout;

    [SerializeField]
    public GameObject injuriesLayout;

    [SerializeField]
    public GameObject[] disableGapsForInjuries;

    [SerializeField]
    public GameObject continueLayout;

    public bool active;

    public IEnumerator Run()
    {
        active = true;
        yield return (object)new WaitForSeconds(startDelay);
        winLayout.SetActive(true);
        yield return (object)new WaitForSeconds(0.75f);
        yield return RevealInjuries();
        continueLayout.SetActive(true);
        yield return (object)new WaitUntil((Func<bool>)(() => !active));
    }

    public IEnumerator RevealInjuries()
    {
        CardData[] injuriesThisBattle = InjurySystem.GetInjuriesThisBattle();
        if (injuriesThisBattle != null && injuriesThisBattle.Length > 0)
        {
            SfxSystem.OneShot("event:/sfx/ui/injuries_showup");
            injuredContainer.SetSize(injuriesThisBattle.Length, 0.6f);
            CardData[] array = injuriesThisBattle;
            for (int i = 0; i < array.Length; i++)
            {
                Card card = CardManager.Get(array[i], null, null, inPlay: false, isPlayerCard: true);
                injuredContainer.Add(card.entity);
                yield return card.UpdateData();
            }
            injuredPanel.sizeDelta = ((Component)injuredContainer).GetComponent<RectTransform>().sizeDelta + new Vector2(6f, 1.5f);
            injuredContainer.SetChildPositions();
            GameObject[] array2 = disableGapsForInjuries;
            for (int j = 0; j < array2.Length; j++)
            {
                array2[j].SetActive(false);
            }
            injuriesLayout.SetActive(true);
            yield return (object)new WaitForSeconds(0.75f);
        }
    }

    public bool CharacterDeckpackOpen(Character character)
    {
        bool result = false;
        if (character.entity?.display != null && character.entity.display is CharacterDisplay characterDisplay)
        {
            result = characterDisplay.IsDeckpackOpen;
        }
        return result;
    }

    public void End()
    {
        active = false;
    }
}
public class CardFramesUnlockedSequence : MonoBehaviour
{
    [SerializeField]
    public LocalizedString chiseledFrameUnlocked;

    [SerializeField]
    public LocalizedString chiseledFramesUnlocked;

    [SerializeField]
    public LocalizedString goldFrameUnlocked;

    [SerializeField]
    public LocalizedString goldFramesUnlocked;

    [SerializeField]
    public TMP_Text text;

    [SerializeField]
    public CardHand container1;

    [SerializeField]
    public CardHand container2;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public GameObject group;

    [Header("Dynamic Positioning Based")]
    [SerializeField]
    public AnimationCurve angleAddBasedOnCount;

    [SerializeField]
    public AnimationCurve zPositionBasedOnCount;

    public const int splitTo2ndContainerThreshold = 3;

    public const float cardScale = 0.67f;

    public IEnumerator Run(int level, string[] cards)
    {
        text.text = StringExt.Format(((level != 1) ? ((cards.Length > 1) ? goldFramesUnlocked : goldFrameUnlocked) : ((cards.Length > 1) ? chiseledFramesUnlocked : chiseledFrameUnlocked)).GetLocalizedString(), new object[1] { cards.Length });
        yield return CreateCards(cards);
    }

    public IEnumerator CreateCards(string[] cards)
    {
        SetScaleAndPosition(cards.Length);
        Routine.Clump clump = new Routine.Clump();
        int num = ((cards.Length > 3) ? Mathf.CeilToInt((float)cards.Length / 2f) : cards.Length);
        container1.SetSize(num, 0.67f);
        container2.SetSize(cards.Length - num, 0.67f);
        for (int i = 0; i < cards.Length; i++)
        {
            string assetName = cards[i];
            CardHand cardContainer = ((i < num) ? container1 : container2);
            CardData cardData = AddressableLoader.Get<CardData>("CardData", assetName);
            if (cardData != null)
            {
                clump.Add(CreateCard(cardData, cardContainer, startFlipped: false));
            }
        }
        yield return clump.WaitForEnd();
        group.SetActive(true);
        container1.SetChildPositions();
        container2.SetChildPositions();
    }

    public void SetScaleAndPosition(int numberOfCards)
    {
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0076: Unknown result type (might be due to invalid IL or missing references)
        //IL_009a: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a4: Unknown result type (might be due to invalid IL or missing references)
        float fanCircleAngleAdd = angleAddBasedOnCount.Evaluate((float)numberOfCards);
        float num = zPositionBasedOnCount.Evaluate((float)numberOfCards);
        container1.fanCircleAngleAdd = fanCircleAngleAdd;
        container2.fanCircleAngleAdd = fanCircleAngleAdd;
        ((Component)container1).transform.localPosition = Vector3Ext.WithZ(((Component)container1).transform.localPosition, num);
        ((Component)container2).transform.localPosition = Vector3Ext.WithZ(((Component)container2).transform.localPosition, num);
        if (numberOfCards <= 3)
        {
            ((Component)container1).transform.localPosition = Vector3Ext.WithY(((Component)container1).transform.localPosition, 0f);
        }
    }

    public IEnumerator CreateCard(CardData cardData, CardContainer cardContainer, bool startFlipped)
    {
        Card card = CardManager.Get(cardData, cardController, null, inPlay: false, isPlayerCard: true);
        if (startFlipped)
        {
            card.entity.flipper.FlipDownInstant();
        }
        cardContainer.Add(card.entity);
        yield return card.UpdateData();
        if (startFlipped)
        {
            card.entity.flipper.FlipUp(force: true);
        }
    }

    public void End()
    {
        container1.DestroyAll();
        container2.DestroyAll();
        gameObject.SetActive(false);
        new Routine(SceneManager.Unload("CardFramesUnlocked"));
    }
}
public class CardPocketSequence : UISequence
{
    public class Card
    {
        public readonly Entity entity;

        public CardContainer[] preContainers;

        public CardController preController;

        public bool preInPlay;

        public bool preEnabled;

        public Card(Entity entity)
        {
            this.entity = entity;
        }

        public void Reset()
        {
            entity.inPlay = preInPlay;
            ((Behaviour)entity).enabled = preEnabled;
        }

        public void Take()
        {
            preContainers = entity.containers;
            preController = entity.display?.hover?.controller;
            preInPlay = entity.inPlay;
            preEnabled = ((Behaviour)entity).enabled;
            entity.RemoveFromContainers();
            entity.inPlay = false;
        }

        public void Return()
        {
            entity.RemoveFromContainers();
            ((Behaviour)entity).enabled = preEnabled;
            CardContainer[] array = preContainers;
            for (int i = 0; i < array.Length; i++)
            {
                array[i].Add(entity);
            }
            CardHover cardHover = entity.display?.hover;
            if (cardHover != null)
            {
                cardHover.controller = preController;
            }
            entity.inPlay = preInPlay;
        }

        public void ReturnTween()
        {
            entity.TweenToContainer();
        }

        public override string ToString()
        {
            return (entity).name;
        }
    }

    [Header("Custom Values")]
    public CardController cardController;

    public Image background;

    public CardContainer container;

    [SerializeField]
    public Vector2 shuffleDelay = new Vector2(0.01f, 0.02f);

    [SerializeField]
    public GameObject backButton;

    [Header("Initial card position/rotation offset")]
    [SerializeField]
    public Vector3 randomOffset;

    [SerializeField]
    public Vector3 randomRotation;

    public readonly List<Card> cards = new List<Card>();

    public void AddCards(CardContainer from)
    {
        foreach (Entity item in from)
        {
            cards.Add(new Card(item));
        }
        foreach (Card item2 in cards.OrderBy((Card _) => PettyRandom.Range(0f, 1f)))
        {
            item2.Take();
            CardHover cardHover = item2.entity.display?.hover;
            if (cardHover != null)
            {
                cardHover.controller = cardController;
            }
            container.Add(item2.entity);
        }
    }

    public IEnumerator ReturnCards()
    {
        foreach (Card card in cards)
        {
            card.Return();
            card.ReturnTween();
        }
        cards.Clear();
        yield break;
    }

    public override IEnumerator Run()
    {
        ((Behaviour)cardController).enabled = false;
        gameObject.SetActive(true);
        Routine.Clump clump = new Routine.Clump();
        foreach (Entity item in container.OrderBy((Entity _) => PettyRandom.Range(0f, 1f)))
        {
            clump.Add(MoveCard(item));
            yield return Sequences.Wait(Vector2Ext.PettyRandom(shuffleDelay));
        }
        backButton.SetActive(true);
        yield return clump.WaitForEnd();
        ((Behaviour)cardController).enabled = true;
        yield return (object)new WaitUntil((Func<bool>)(() => promptEnd));
        promptEnd = false;
        cardController.UnHover();
        backButton.SetActive(false);
        ((Behaviour)cardController).enabled = false;
        foreach (Card card in cards)
        {
            card.Reset();
        }
        yield return ReturnCards();
        gameObject.SetActive(false);
    }

    public IEnumerator MoveCard(Entity entity)
    {
        Move(entity, includeRandomness: true);
        yield return Sequences.Wait(PettyRandom.Range(0.01f, 0.3f));
        entity.flipper.FlipUp();
        ((Behaviour)entity).enabled = true;
    }

    public void FixPosition(Entity entity)
    {
        Move(entity, includeRandomness: false);
    }

    public void Move(Entity entity, bool includeRandomness)
    {
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bb: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e8: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_006b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0075: Unknown result type (might be due to invalid IL or missing references)
        if (entity.transform.parent == container.holder)
        {
            Vector3 val = container.GetChildPosition(entity);
            Vector3 val2 = container.GetChildRotation(entity);
            Vector3 childScale = container.GetChildScale(entity);
            if (includeRandomness)
            {
                Vector3 val3 = PettyRandom.Vector3();
                val += Vector3.Scale(val3, randomOffset);
                val2 += Vector3.Scale(val3, randomRotation);
            }
            LeanTween.cancel(((Component)entity).gameObject);
            LeanTween.moveLocal(((Component)entity).gameObject, val, Vector2Ext.PettyRandom(container.movementDurRand)).setEase(container.movementEase);
            LeanTween.rotateLocal(((Component)entity).gameObject, val2, Vector2Ext.PettyRandom(container.movementDurRand)).setEase(container.movementEase);
            LeanTween.scale(((Component)entity).gameObject, childScale, Vector2Ext.PettyRandom(container.scaleDurRand)).setEase(container.scaleEase);
        }
    }

    public void OpenFrom(Transform transform)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        SfxSystem.OneShot((transform.position.x > 0f) ? "event:/sfx/inventory/deck_opening_right" : "event:/sfx/inventory/deck_opening_left");
    }
}
public class CardUnlockSequence : MonoBehaviour
{
    [SerializeField]
    public Transform cardHolder;

    [SerializeField]
    public float duration = 2f;

    [SerializeField]
    public string waitForPress = "Select";

    [SerializeField]
    public ParticleSystem burstParticleSystem;

    [SerializeField]
    public LocalizedString titleKey;

    [SerializeField]
    public LocalizedString promptKey;

    public IEnumerator Run(Entity card, CardContainer endContainer)
    {
        Events.InvokeEntityShowUnlocked(card);
        gameObject.SetActive(true);
        CinemaBarSystem.In();
        CinemaBarSystem.Top.SetPrompt(titleKey.GetLocalizedString(), "");
        CinemaBarSystem.Bottom.SetPrompt(promptKey.GetLocalizedString(), "Select");
        CinemaBarSystem.SetSortingLayer("UI2");
        Transform transform = card.transform;
        transform.SetParent(cardHolder);
        transform.localPosition = Vector3.zero;
        burstParticleSystem.Play();
        transform.localScale = new Vector3(2f, 0f, 1f);
        LeanTween.scale(((Component)transform).gameObject, Vector3.one, 1.5f).setEase(LeanTweenType.easeOutElastic);
        yield return (object)new WaitForSeconds(duration);
        if (!StringExt.IsNullOrWhitespace(waitForPress))
        {
            yield return (object)new WaitUntil((Func<bool>)(() => InputSystem.IsButtonPressed(waitForPress)));
        }
        CinemaBarSystem.Clear();
        CinemaBarSystem.Out();
        if (endContainer != null)
        {
            endContainer.Add(card);
            endContainer.TweenChildPositions();
        }
        gameObject.SetActive(false);
    }
}
public class ChooseNewCardSequence : UISequence
{
    public Character owner;

    public RectTransform background;

    public float cardFlipDelay = 0.5f;

    public float cardFlipPauseBetween = 0.25f;

    [SerializeField]
    public GameObject cardGroupLayout;

    [SerializeField]
    public GameObject skipButtonLayout;

    public CardController cardController;

    public CardContainer cardContainer;

    public CardSelector cardSelector;

    [SerializeField]
    public Button skipButton;

    [SerializeField]
    public bool canSkip;

    [SerializeField]
    public int skipGold = 20;

    [SerializeField]
    public TweenUI endTween;

    public override IEnumerator Run()
    {
        cardGroupLayout.SetActive(false);
        if ((skipButtonLayout))
        {
            skipButtonLayout.SetActive(false);
        }
        if ((background))
        {
            ((Component)background).gameObject.SetActive(false);
        }
        yield return Sequences.Wait(startDelay);
        gameObject.SetActive(true);
        if ((background))
        {
            ((Component)background).gameObject.SetActive(true);
            ((Transform)background).localScale = Vector3.zero;
            yield return null;
            background.LeanScale(Vector3.one, 1f).setEase(LeanTweenType.easeOutElastic);
            yield return Sequences.Wait(0.25f);
        }
        cardGroupLayout.SetActive(true);
        if (canSkip && (skipButtonLayout))
        {
            skipButtonLayout.SetActive(true);
        }
        yield return Sequences.Wait(cardFlipDelay);
        if ((cardContainer))
        {
            int dir = Random.Sign();
            int cardCount = cardContainer.Count;
            for (int i = 0; i < cardCount; i++)
            {
                cardContainer[(dir == 1) ? i : (cardCount - 1 - i)].flipper.FlipUp();
                yield return Sequences.Wait(cardFlipPauseBetween);
            }
        }
        while (!promptEnd)
        {
            yield return null;
        }
        cardController.Disable();
        if ((skipButton))
        {
            ((Selectable)skipButton).interactable = false;
        }
        if ((background))
        {
            background.LeanScale(Vector3.zero, tweenOutDur).setEase(LeanTweenType.easeInBack);
        }
        if ((endTween))
        {
            endTween.Fire();
            yield return (object)new WaitForSeconds(endTween.GetDuration());
        }
        foreach (Entity item in cardContainer)
        {
            if ((item) && (((Component)item).gameObject))
            {
                CardManager.ReturnToPool(item);
            }
        }
        yield return SceneManager.WaitUntilUnloaded("CardCombine");
        gameObject.SetActive(false);
    }

    public void Skip()
    {
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        if (skipGold > 0 && (owner?.data?.inventory))
        {
            Events.InvokeDropGold(skipGold, "SkipReward", owner, ((Component)skipButton).transform.position);
        }
        cardController.Disable();
        End();
        ((Selectable)skipButton).interactable = false;
    }

    public void TakeFirstCard()
    {
        if (!promptEnd)
        {
            cardSelector.TakeFirstCard(cardContainer);
            cardController.Disable();
        }
    }
}
public class ChooseSequence : UISequence
{
    public RectTransform background;

    public override IEnumerator Run()
    {
        UIAnchors anchors = GetComponent<UIAnchors>();
        UIAnchors.AnchorPoint[] list = anchors.list;
        foreach (UIAnchors.AnchorPoint obj in list)
        {
            obj.Deactivate();
            obj.SetUp();
        }
        ((Component)background).gameObject.SetActive(false);
        yield return Sequences.Wait(startDelay);
        gameObject.SetActive(true);
        ((Component)background).gameObject.SetActive(true);
        ((Transform)background).localScale = Vector3.zero;
        yield return null;
        background.LeanScale(Vector3.one, 1f).setEase(LeanTweenType.easeOutElastic);
        yield return Sequences.Wait(0.25f);
        int c = anchors.Count;
        for (int i = 0; i < c; i++)
        {
            anchors.Activate(i);
            yield return null;
            StartCoroutine(anchors.Reveal(i));
        }
        StartCoroutine(anchors.UpdatePositions());
        while (!promptEnd)
        {
            yield return null;
        }
        background.LeanScale(Vector3.zero, tweenOutDur).setEase(LeanTweenType.easeInBack);
        for (int k = 0; k < c; k++)
        {
            float delay = PettyRandom.Range(0f, delayBetween);
            StartCoroutine(anchors.UnReveal(k, delay));
        }
        yield return Sequences.Wait(tweenInDur + delayBetween);
        gameObject.SetActive(false);
    }
}
public class CombineCardSequence : MonoBehaviour
{
    [SerializeField]
    public Fader fader;

    [SerializeField]
    public Graphic flash;

    [SerializeField]
    public AnimationCurve flashCurve;

    [SerializeField]
    public AnimationCurve bounceCurve;

    [SerializeField]
    public Transform group;

    [SerializeField]
    public Transform pointPrefab;

    [SerializeField]
    public ParticleSystem ps;

    [SerializeField]
    public LocalizedString titleKey;

    [SerializeField]
    public LocalizedString continueKey;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public ParticleSystem hitPs;

    [SerializeField]
    public GameObject combinedFx;

    [SerializeField]
    public Transform finalEntityParent;

    public readonly List<Transform> points = new List<Transform>();

    public const float cardScale = 0.8f;

    public const float finalCardScale = 1f;

    public IEnumerator Run(string[] cardsToCombine, string resultingCard)
    {
        CardData[] array = new CardData[cardsToCombine.Length];
        CardData cardDataClone = AddressableLoader.GetCardDataClone(resultingCard);
        for (int i = 0; i < cardsToCombine.Length; i++)
        {
            string cardName = cardsToCombine[i];
            CardData cardData = References.PlayerData.inventory.deck.FirstOrDefault((CardData a) => (a).name == cardName);
            if ((cardData))
            {
                array[i] = cardData;
            }
        }
        yield return Run(array, cardDataClone);
    }

    public IEnumerator Run(CardData[] cards, CardData finalCard)
    {
        CinemaBarSystem.State cinemaBarState = new CinemaBarSystem.State();
        PauseMenu.Block();
        CinemaBarSystem.SetSortingLayer("UI2", 100);
        CinemaBarSystem.In();
        Entity[] entities = CreateEntities(cards);
        Entity finalEntity = CreateFinalEntity(finalCard);
        Routine.Clump clump = new Routine.Clump();
        Entity[] array = entities;
        foreach (Entity entity in array)
        {
            clump.Add(entity.display.UpdateData());
        }
        clump.Add(finalEntity.display.UpdateData());
        clump.Add(Sequences.Wait(0.5f));
        yield return clump.WaitForEnd();
        array = entities;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].transform.localScale = Vector3.one * 0.8f;
        }
        array = entities;
        foreach (Entity entity2 in array)
        {
            References.PlayerData.inventory.deck.Remove(entity2.data);
        }
        References.PlayerData.inventory.deck.Add(finalEntity.data);
        fader.In();
        Vector3 val = Vector3.zero;
        array = entities;
        foreach (Entity entity3 in array)
        {
            val += entity3.transform.position;
        }
        val /= (float)entities.Length;
        group.position = val;
        array = entities;
        foreach (Entity entity4 in array)
        {
            Transform val2 = Object.Instantiate<Transform>(pointPrefab, entity4.transform.position, Quaternion.identity, group);
            ((Component)val2).gameObject.SetActive(true);
            entity4.transform.SetParent(val2);
            points.Add(val2);
            LeanTween.alphaCanvas(((Card)entity4.display).canvasGroup, 1f, 0.4f).setEaseInQuad();
        }
        Vector3 localPosition;
        foreach (Transform point in points)
        {
            localPosition = point.localPosition;
            LeanTween.moveLocal(to: ((localPosition)).normalized, gameObject: ((Component)point).gameObject, time: 0.4f).setEaseInQuart();
        }
        yield return (object)new WaitForSeconds(0.4f);
        Flash(0.5f);
        Events.InvokeScreenShake(1f, 0f);
        array = entities;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].wobbler.WobbleRandom();
        }
        hitPs.Play();
        foreach (Transform point2 in points)
        {
            localPosition = point2.localPosition;
            LeanTween.moveLocal(to: ((localPosition)).normalized * 3f, gameObject: ((Component)point2).gameObject, time: 1f).setEase(bounceCurve);
        }
        LeanTween.moveLocal(((Component)group).gameObject, new Vector3(0f, 0f, -2f), 1f).setEaseInOutQuad();
        LeanTween.rotateZ(((Component)group).gameObject, PettyRandom.Range(160f, 180f), 1f).setOnUpdateVector3(delegate
        {
            //IL_001a: Unknown result type (might be due to invalid IL or missing references)
            foreach (Transform point3 in points)
            {
                ((Component)point3).transform.eulerAngles = Vector3.zero;
            }
        }).setEaseInOutQuad();
        yield return (object)new WaitForSeconds(1f);
        Flash();
        Events.InvokeScreenShake(1f, 0f);
        if ((ps))
        {
            ps.Play();
        }
        combinedFx.SetActive(true);
        finalEntity.transform.position = Vector3.zero;
        array = entities;
        for (int i = 0; i < array.Length; i++)
        {
            CardManager.ReturnToPool(array[i]);
        }
        ((Component)group).transform.localRotation = Quaternion.identity;
        finalEntity.curveAnimator.Ping();
        finalEntity.wobbler.WobbleRandom();
        CinemaBarSystem.Top.SetScript(titleKey.GetLocalizedString());
        CinemaBarSystem.Bottom.SetPrompt(continueKey.GetLocalizedString(), "Select");
        while (!InputSystem.IsButtonPressed("Select"))
        {
            yield return null;
        }
        cinemaBarState.Restore();
        CinemaBarSystem.SetSortingLayer("CinemaBars");
        GameObjectExt.Destroy(((Component)fader).gameObject);
        cardSelector.character = References.Player;
        cardSelector.MoveCardToDeck(finalEntity);
        PauseMenu.Unblock();
    }

    public Entity[] CreateEntities(CardData[] cardDatas)
    {
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        //IL_007b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_0085: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a1: Unknown result type (might be due to invalid IL or missing references)
        Entity[] array = new Entity[cardDatas.Length];
        float num = ((PettyRandom.value > 0.5f) ? PettyRandom.Range(-45f, 45f) : PettyRandom.Range(135f, 225f));
        float num2 = 360f / (float)cardDatas.Length;
        for (int i = 0; i < cardDatas.Length; i++)
        {
            Card card = CardManager.Get(cardDatas[i], null, null, inPlay: false, isPlayerCard: true);
            array[i] = card.entity;
            Vector2 val = Lengthdir.ToVector2(10f, num * ((float)Math.PI / 180f)) + PettyRandom.Vector2() * 1f;
            card.transform.position = (val);
            card.transform.localScale = Vector3.zero;
            card.transform.SetParent(group);
            card.canvasGroup.alpha = 0f;
            num += num2;
        }
        return array;
    }

    public Entity CreateFinalEntity(CardData cardData)
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        Card card = CardManager.Get(cardData, null, null, inPlay: false, isPlayerCard: true);
        card.transform.localScale = Vector3.one * 1f;
        card.transform.SetParent(finalEntityParent);
        return card.entity;
    }

    public void Flash(float intensity = 1f, float duration = 0.15f)
    {
        GameObject gameObject = ((Component)flash).gameObject;
        gameObject.SetActive(true);
        LeanTween.cancel(gameObject);
        LeanTween.value(gameObject, 0f, intensity, duration).setEase(flashCurve).setOnUpdate(delegate (float a)
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0021: Unknown result type (might be due to invalid IL or missing references)
            flash.color = ColorExt.With(flash.color, -1f, -1f, -1f, a);
        })
            .setOnComplete((Action)delegate
            {
                ((Component)flash).gameObject.SetActive(false);
            });
    }
}
public class CompanionLimitSequence : UISequence
{
    [SerializeField]
    public LocalizedString textKey;

    [SerializeField]
    public string overColourHex = "f66";

    [SerializeField]
    public string underColourHex = "fff";

    [SerializeField]
    public TMP_Text title;

    public Character owner;

    public CardController controller;

    public GameObject background;

    public GameObject container;

    public CardContainer activeContainer;

    public CardContainer reserveContainer;

    public Transform continueButtonHolder;

    public Button continueButton;

    public override IEnumerator Run()
    {
        ((Selectable)continueButton).interactable = true;
        Routine.Clump clump = new Routine.Clump();
        foreach (CardData item in owner.data.inventory.deck)
        {
            if ((item.cardType).name == "Friendly")
            {
                clump.Add(CreateCard(activeContainer, item));
            }
        }
        foreach (CardData item2 in owner.data.inventory.reserve)
        {
            if ((item2.cardType).name == "Friendly")
            {
                clump.Add(CreateCard(reserveContainer, item2));
            }
        }
        clump.Add(Sequences.Wait(startDelay));
        yield return clump.WaitForEnd();
        SetPositions();
        Resolve();
        background.transform.localScale = new Vector3(0.1f, 0.1f, 1f);
        container.transform.localScale = Vector3.one * 0.5f;
        gameObject.SetActive(true);
        LeanTween.cancel(background);
        LeanTween.scale(background, Vector3.one, tweenInDur).setEase(tweenInEase);
        LeanTween.cancel(container);
        LeanTween.scale(container, Vector3.one, tweenInDur).setEase(tweenInEase);
        yield return Sequences.Wait(tweenInDur);
        yield return (object)new WaitUntil((Func<bool>)(() => promptEnd));
        promptEnd = false;
        LeanTween.cancel(background);
        LeanTween.scale(background, Vector3.zero, tweenOutDur).setEase(tweenOutEase);
        LeanTween.cancel(container);
        LeanTween.scale(container, Vector3.zero, tweenOutDur).setEase(tweenOutEase);
        yield return Sequences.Wait(tweenOutDur);
        DestroyCards(activeContainer);
        DestroyCards(reserveContainer);
        gameObject.SetActive(false);
    }

    public IEnumerator CreateCard(CardContainer container, CardData data)
    {
        Card card = CardManager.Get(data, controller, owner, inPlay: false, isPlayerCard: true);
        container.Add(card.entity);
        container.SetSize(container.Count, 0.67f);
        yield return card.UpdateData();
    }

    public void Move(Entity entity)
    {
        if (entity.InContainerGroup(activeContainer))
        {
            MoveToReserve(entity);
        }
        else if (entity.InContainerGroup(reserveContainer))
        {
            MoveToDeck(entity);
        }
    }

    public void MoveToDeck(Entity entity)
    {
        if (!entity.InContainerGroup(activeContainer))
        {
            entity.RemoveFromContainers();
            activeContainer.Add(entity);
        }
        if (!owner.data.inventory.deck.Contains(entity.data))
        {
            owner.data.inventory.reserve.Remove(entity.data);
            owner.data.inventory.deck.Add(entity.data);
        }
        Resolve();
        UpdatePositions();
    }

    public void MoveToReserve(Entity entity)
    {
        if (!entity.InContainerGroup(reserveContainer))
        {
            entity.RemoveFromContainers();
            reserveContainer.Add(entity);
        }
        if (!owner.data.inventory.reserve.Contains(entity.data))
        {
            owner.data.inventory.deck.Remove(entity.data);
            owner.data.inventory.reserve.Add(entity.data);
        }
        Resolve();
        UpdatePositions();
    }

    public void Toggle()
    {
        if (!gameObject.activeSelf)
        {
            Begin();
        }
        else
        {
            Continue();
        }
    }

    public void Continue()
    {
        promptEnd = true;
        ((Selectable)continueButton).interactable = false;
    }

    public void Resolve()
    {
        int count = activeContainer.Count;
        bool flag = count > owner.data.companionLimit;
        string localizedString = textKey.GetLocalizedString();
        title.text = string.Format(localizedString, count, owner.data.companionLimit, flag ? overColourHex : underColourHex);
        ((Component)continueButtonHolder).gameObject.SetActive(!flag);
    }

    public void SetPositions()
    {
        activeContainer.SetSize(activeContainer.Count, 0.67f);
        reserveContainer.SetSize(reserveContainer.Count, 0.67f);
        activeContainer.SetChildPositions();
        reserveContainer.SetChildPositions();
    }

    public void UpdatePositions()
    {
        activeContainer.SetSize(activeContainer.Count, 0.67f);
        reserveContainer.SetSize(reserveContainer.Count, 0.67f);
        activeContainer.TweenChildPositions();
        reserveContainer.TweenChildPositions();
    }

    public static void DestroyCards(CardContainer container)
    {
        foreach (Entity item in container)
        {
            CardManager.ReturnToPool(item);
        }
        container.Clear();
    }
}
public class CompanionRecoverSequence : UISequence
{
    public Character owner;

    [SerializeField]
    public TweenUI revealTween;

    [SerializeField]
    public TweenUI hideTween;

    [SerializeField]
    public CardContainer container;

    [SerializeField]
    public CardController controller;

    [SerializeField]
    public Button continueButton;

    [SerializeField]
    [Range(0f, 1f)]
    public float cardScale = 0.75f;

    public void OnEnable()
    {
        ((Selectable)continueButton).interactable = true;
        controller.Enable();
    }

    public void OnDisable()
    {
        Clear();
    }

    public IEnumerator CreateCards(IEnumerable<CardData> cards)
    {
        Routine.Clump clump = new Routine.Clump();
        foreach (CardData card in cards)
        {
            clump.Add(CreateCard(card));
        }
        yield return clump.WaitForEnd();
    }

    public IEnumerator CreateCard(CardData data)
    {
        Card card = CardManager.Get(data, controller, owner, inPlay: false, isPlayerCard: true);
        container.Add(card.entity);
        container.max = container.Count;
        yield return card.UpdateData();
    }

    public void Clear()
    {
        foreach (Entity item in container)
        {
            CardManager.ReturnToPool(item);
        }
        container.Clear();
    }

    public CardData[] FindRecoveries()
    {
        List<CardData> list = new List<CardData>();
        foreach (CardData item in owner.data.inventory.deck.Where(IsInjured))
        {
            list.Add(item);
        }
        foreach (CardData item2 in owner.data.inventory.reserve.Where(IsInjured))
        {
            list.Add(item2);
        }
        Debug.Log(("Injured companions: [" + string.Join(", ", list) + "]"));
        CardData[] injuriesThisBattle = InjurySystem.GetInjuriesThisBattle();
        if (injuriesThisBattle.Length != 0)
        {
            IListExt.RemoveMany<CardData>((IList<CardData>)list, (ICollection<CardData>)injuriesThisBattle);
            object[] values = injuriesThisBattle;
            Debug.Log(("[" + string.Join(", ", values) + "] cannot recover since they died last battle!"));
        }
        return list.ToArray();
    }

    public static bool IsInjured(CardData card)
    {
        if (card.injuries != null)
        {
            return card.injuries.Count > 0;
        }
        return false;
    }

    public override IEnumerator Run()
    {
        CardData[] array = FindRecoveries();
        if (array.Length != 0)
        {
            Clear();
            RemoveInjuries(array);
            Routine.Clump clump = new Routine.Clump();
            yield return CreateCards(array);
            clump.Add(Sequences.Wait(startDelay));
            yield return clump.WaitForEnd();
            container.SetChildPositions();
            gameObject.SetActive(true);
            yield return Sequences.Wait(revealTween.GetDuration());
            yield return (object)new WaitUntil((Func<bool>)(() => promptEnd));
            hideTween.Fire();
            promptEnd = false;
        }
    }

    public static void RemoveInjuries(IEnumerable<CardData> targets)
    {
        foreach (CardData target in targets)
        {
            target.injuries.Clear();
        }
    }
}
public class DeckDisplaySequence : UISequence
{
    public Character owner;

    public Transform background;

    public RectTransform container;

    public DeckDisplayGroup activeCardsGroup;

    public DeckDisplayGroup reserveCardsGroup;

    [SerializeField]
    public CardCharmHolder charmHolder;

    [SerializeField]
    public CrownHolder crownHolder;

    [SerializeField]
    public CardCharmDragHandler charmDragHandler;

    [SerializeField]
    public RectTransform borderLeft;

    [SerializeField]
    public RectTransform borderRight;

    [SerializeField]
    public ScrollRect scrollRect;

    [SerializeField]
    public CardController cardController;

    public override IEnumerator Run()
    {
        yield return Sequences.Wait(startDelay);
        ((Transform)container).localScale = Vector3.one;
        StopWatch.Start();
        Routine.Clump clump = new Routine.Clump();
        activeCardsGroup.Clear();
        foreach (CardData item in owner.data.inventory.deck)
        {
            clump.Add(activeCardsGroup.CreateCard(item));
        }
        yield return clump.WaitForEnd();
        activeCardsGroup.UpdatePositions();
        reserveCardsGroup.Clear();
        foreach (CardData item2 in owner.data.inventory.reserve)
        {
            clump.Add(reserveCardsGroup.CreateCard(item2));
        }
        yield return clump.WaitForEnd();
        reserveCardsGroup.UpdatePositions();
        charmHolder.Clear();
        crownHolder.Clear();
        foreach (CardUpgradeData upgrade in owner.data.inventory.upgrades)
        {
            switch (upgrade.type)
            {
                case CardUpgradeData.Type.Charm:
                    charmHolder.Create(upgrade);
                    break;
                case CardUpgradeData.Type.Crown:
                    crownHolder.Create(upgrade);
                    break;
            }
        }
        charmHolder.SetPositions();
        crownHolder.SetPositions();
        Debug.Log($"DECK CARDS CREATED ({StopWatch.Stop()}ms)");
        ((Component)background).transform.localScale = Vector3.one;
        ((Component)container).transform.localScale = Vector3.one * 0.5f;
        gameObject.SetActive(true);
        cardController.Enable();
        yield return FixLayoutsRoutine();
        LeanTween.cancel(((Component)background).gameObject);
        LeanTween.scale(((Component)background).gameObject, new Vector3(60f, 60f, 1f), 1.5f).setEase(tweenInEase);
        LeanTween.cancel(((Component)container).gameObject);
        LeanTween.scale(((Component)container).gameObject, Vector3.one, tweenInDur).setEase(tweenInEase);
        float time = 0.5f;
        LeanTweenType ease = LeanTweenType.easeOutBack;
        float delay = 0.1f;
        float borderFrom = 4f;
        LeanTween.cancel(borderLeft);
        borderLeft.anchoredPosition3D = new Vector3(0f - borderFrom, 0f, 0f);
        LeanTween.move(borderLeft, new Vector3(-0.7f, 0f, 0f), time).setEase(ease).setDelay(delay);
        LeanTween.cancel(borderRight);
        borderRight.anchoredPosition3D = new Vector3(borderFrom, 0f, 0f);
        LeanTween.move(borderRight, new Vector3(0.7f, 0f, 0f), time).setEase(ease).setDelay(delay);
        yield return null;
        scrollRect.normalizedPosition = new Vector2(0.5f, 1f);
        yield return (object)new WaitUntil((Func<bool>)(() => promptEnd));
        promptEnd = false;
        cardController.Disable();
        if (charmDragHandler.IsDragging)
        {
            charmDragHandler.CancelDrag();
        }
        CardCharmInteraction[] componentsInChildren = ((Component)charmHolder).GetComponentsInChildren<CardCharmInteraction>();
        foreach (CardCharmInteraction obj in componentsInChildren)
        {
            obj.UnHover();
            obj.canHover = false;
        }
        componentsInChildren = ((Component)crownHolder).GetComponentsInChildren<CardCharmInteraction>();
        foreach (CardCharmInteraction obj2 in componentsInChildren)
        {
            obj2.UnHover();
            obj2.canHover = false;
        }
        NavigationState.Start(new NavigationStateWait(disableInput: true));
        LeanTween.cancel(((Component)background).gameObject);
        LeanTween.scale(((Component)background).gameObject, Vector3.zero, tweenOutDur).setEase(tweenOutEase);
        LeanTween.cancel(((Component)container).gameObject);
        LeanTween.scale(((Component)container).gameObject, Vector3.zero, tweenOutDur).setEase(tweenOutEase);
        LeanTween.cancel(borderLeft);
        LeanTween.move(borderLeft, new Vector3(0f - borderFrom, 0f, 0f), tweenOutDur).setEase(tweenOutEase);
        LeanTween.cancel(borderRight);
        LeanTween.move(borderRight, new Vector3(borderFrom, 0f, 0f), tweenOutDur).setEase(tweenOutEase);
        yield return Sequences.Wait(tweenOutDur);
        activeCardsGroup.Clear();
        reserveCardsGroup.Clear();
        charmHolder.Clear();
        crownHolder.Clear();
        NavigationState.BackToPreviousState();
        gameObject.SetActive(false);
    }

    public IEnumerator FixLayoutsRoutine()
    {
        yield return RectTransformExt.FixLayoutGroup((RectTransform)((Component)activeCardsGroup).transform.parent);
    }

    public IEnumerator FixLayoutsRoutinePreserveScroll()
    {
        Vector2 scrollPos = scrollRect.normalizedPosition;
        yield return FixLayoutsRoutine();
        yield return null;
        scrollRect.normalizedPosition = scrollPos;
    }

    public void UpdatePositions()
    {
        CardContainerGrid[] grids = activeCardsGroup.grids;
        for (int i = 0; i < grids.Length; i++)
        {
            grids[i].TweenChildPositions();
        }
        grids = reserveCardsGroup.grids;
        for (int i = 0; i < grids.Length; i++)
        {
            grids[i].TweenChildPositions();
        }
        StartCoroutine(FixLayoutsRoutinePreserveScroll());
    }
}
public class DeckSelectSequence : UISequence
{
    [SerializeField]
    public UnityEvent onEnable;

    [SerializeField]
    public UnityEvent onDisable;

    [Header("Custom Values")]
    [SerializeField]
    public Transform cardHolder;

    [SerializeField]
    public CanvasGroup fade;

    [SerializeField]
    public float fadeInTime = 0.1f;

    [SerializeField]
    public float fadeOutTime = 0.1f;

    [SerializeField]
    public CardSelector cardSelector;

    [SerializeField]
    public RenameCompanionSequence renameSequence;

    [SerializeField]
    public CrownHolder crownHolder;

    [Header("Buttons")]
    [SerializeField]
    public GameObject buttonGroup;

    [SerializeField]
    public TweenUI buttonShowTween;

    [SerializeField]
    public TweenUI buttonHideTween;

    [SerializeField]
    public GameObject renameButton;

    [SerializeField]
    public GameObject takeCrownButton;

    [SerializeField]
    public GameObject moveDownButton;

    [SerializeField]
    public Button moveDownButtonButton;

    [SerializeField]
    public GameObject moveUpButton;

    [SerializeField]
    public Button moveUpButtonButton;

    [Header("Movement")]
    [SerializeField]
    public float entityScale = 0.75f;

    [SerializeField]
    public float moveWobble = 1.5f;

    [SerializeField]
    public AnimationCurve moveCurve;

    [SerializeField]
    public float moveDur = 0.5f;

    public Entity entity;

    public Transform entityPreParent;

    public bool promptRename;

    public void SetEntity(Entity entity, bool canRename = true)
    {
        this.entity = entity;
        renameButton.SetActive((entity) && canRename);
        takeCrownButton.SetActive((entity) && EntityHasRemovableCrown(entity.data) && entity.data.cardType.canTakeCrown && (!(References.Battle) || References.Battle.ended));
        moveDownButton.SetActive(false);
        moveUpButton.SetActive(false);
    }

    public static bool EntityHasRemovableCrown(CardData cardData)
    {
        CardUpgradeData crown = cardData.GetCrown();
        if ((crown))
        {
            return crown.canBeRemoved;
        }
        return false;
    }

    public void AddMoveDown(UnityAction callback)
    {
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Expected O, but got Unknown
        moveDownButton.SetActive(true);
        ((UnityEventBase)moveDownButtonButton.onClick).RemoveAllListeners();
        ((UnityEvent)moveDownButtonButton.onClick).AddListener(callback);
        ((UnityEvent)moveDownButtonButton.onClick).AddListener((UnityAction)delegate
        {
            End();
            entity = null;
        });
    }

    public void AddMoveUp(UnityAction callback)
    {
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Expected O, but got Unknown
        moveUpButton.SetActive(true);
        ((UnityEventBase)moveUpButtonButton.onClick).RemoveAllListeners();
        ((UnityEvent)moveUpButtonButton.onClick).AddListener(callback);
        ((UnityEvent)moveUpButtonButton.onClick).AddListener((UnityAction)delegate
        {
            End();
            entity = null;
        });
    }

    public void Rename()
    {
        promptRename = true;
    }

    public void TakeCrown()
    {
        CardUpgradeData crown = entity.data.GetCrown();
        if (crown != null)
        {
            entity.data.RemoveCrown();
            if (entity.display is Card { crownHolder: CrownHolder crownHolder })
            {
                crownHolder.Remove(crown);
            }
            References.PlayerData.inventory.upgrades.Add(crown);
            this.crownHolder.Create(crown);
            this.crownHolder.SetPositions();
        }
    }

    public override void End()
    {
        promptEnd = true;
    }

    public override IEnumerator Run()
    {
        UnityEvent obj = onEnable;
        if (obj != null)
        {
            obj.Invoke();
        }
        buttonGroup.SetActive(false);
        yield return Sequences.Wait(startDelay);
        gameObject.SetActive(true);
        if (moveWobble != 0f)
        {
            entity.wobbler?.WobbleRandom(moveWobble);
        }
        entityPreParent = entity.transform.parent;
        entity.transform.SetParent(cardHolder, true);
        LeanTween.cancel(((Component)entity).gameObject);
        LeanTween.moveLocal(((Component)entity).gameObject, Vector3.zero, moveDur).setEase(moveCurve);
        LeanTween.rotateLocal(((Component)entity).gameObject, Vector3.zero, moveDur).setEase(moveCurve);
        LeanTween.scale(((Component)entity).gameObject, Vector3.one * entityScale, moveDur).setEase(moveCurve);
        Events.InvokeEntityFocus(entity);
        ((Component)fade).gameObject.SetActive(true);
        fade.alpha = 0f;
        fade.LeanAlpha(1f, fadeInTime);
        fade.blocksRaycasts = true;
        buttonGroup.SetActive(true);
        buttonShowTween?.Fire();
        bool protectEnd = true;
        int protectEndCount = 5;
        while (!promptEnd || protectEnd)
        {
            if (promptRename)
            {
                renameSequence.SetUnit(entity);
                yield return renameSequence.Run();
                promptRename = false;
            }
            yield return null;
            if (protectEnd)
            {
                promptEnd = false;
                protectEndCount--;
                if (protectEndCount <= 0)
                {
                    protectEnd = false;
                }
            }
        }
        promptEnd = false;
        if (entity != null)
        {
            entity.transform.SetParent(entityPreParent, true);
            CardContainer[] containers = entity.containers;
            for (int i = 0; i < containers.Length; i++)
            {
                containers[i].TweenChildPositions();
            }
            if (moveWobble != 0f)
            {
                entity.wobbler?.WobbleRandom(moveWobble);
            }
        }
        fade.LeanAlpha(0f, fadeOutTime);
        fade.blocksRaycasts = false;
        UnityEvent obj2 = onDisable;
        if (obj2 != null)
        {
            obj2.Invoke();
        }
        gameObject.SetActive(false);
    }
}
public class DefeatSequence : MonoBehaviour
{
    [SerializeField]
    public EventReference music;

    [SerializeField]
    public float startDelay;

    [SerializeField]
    public GameObject restartButton;

    [SerializeField]
    public GameObject scoresButton;

    [SerializeField]
    public GameObject defeatLayout;

    [SerializeField]
    public GameObject winLayout;

    [SerializeField]
    public GameObject vanquishedLayout;

    [SerializeField]
    public GameObject statsLayout;

    [SerializeField]
    public GameObject leaderDisplayLayout;

    [SerializeField]
    public GameObject challengeLayout;

    [SerializeField]
    public GameObject progressLayout;

    [SerializeField]
    public GameObject scoresLayout;

    [SerializeField]
    public GameObject buttonsLayout;

    [SerializeField]
    public LayoutLink[] titlePanels;

    [SerializeField]
    public ChallengeProgressSequence challengeSequence;

    [SerializeField]
    public MetaprogressSequence progressSequence;

    [SerializeField]
    public ScoreSequence scoreSequence;

    [SerializeField]
    public string endCreditsScene = "CreditsEnd";

    [SerializeField]
    public WinMusic winMusic;

    [Header("Temporary win help panel")]
    [SerializeField]
    public HelpPanelShower gameWinHelp;

    [SerializeField]
    public ParticleSystem gameWinPS;

    public bool active;

    public IEnumerator Start()
    {
        bool flag = References.Battle.winner == References.Battle.player;
        if (!flag)
        {
            MusicSystem.StartMusic(music);
        }
        active = true;
        restartButton.SetActive(!flag && Campaign.Data.GameMode.canRestart);
        scoresButton.SetActive(Campaign.Data.GameMode.submitScore);
        yield return Routine();
    }

    public IEnumerator Routine()
    {
        yield return (object)new WaitForSeconds(startDelay);
        LayoutLink[] array = titlePanels;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].offset = new Vector3(0f, 0f, -4f);
        }
        if (References.Battle.winner == References.Battle.player)
        {
            if (SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "trueWin", defaultValue: false))
            {
                yield return SceneManager.Load(endCreditsScene, SceneType.Temporary);
                yield return SceneManager.WaitUntilUnloaded(endCreditsScene);
            }
            winMusic.Play();
            gameWinPS.Play();
            if (SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "trueWin", defaultValue: false))
            {
                vanquishedLayout.SetActive(true);
            }
            else
            {
                winLayout.SetActive(true);
            }
        }
        else
        {
            defeatLayout.SetActive(true);
        }
        yield return (object)new WaitForSeconds(1f);
        array = titlePanels;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].offset = Vector3.zero;
        }
        if (Campaign.Data.GameMode.showStats)
        {
            statsLayout.SetActive(true);
            leaderDisplayLayout.SetActive(true);
        }
        ChallengeProgressSystem challengeProgressSystem = Object.FindObjectOfType<ChallengeProgressSystem>();
        if (challengeProgressSystem != null && challengeProgressSystem.progress != null && challengeProgressSystem.progress.Count((ChallengeProgress a) => a.currentValue > a.originalValue) > 0)
        {
            challengeLayout.SetActive(true);
            yield return (object)new WaitForSeconds(1f);
            yield return (object)new WaitUntil((Func<bool>)(() => !challengeSequence.running));
        }
        Routine.Clump clump = new Routine.Clump();
        if (Campaign.Data.GameMode.submitScore)
        {
            scoresLayout.SetActive(true);
            yield return (object)new WaitForSeconds(1f);
            clump.Add((IEnumerator)new WaitUntil((Func<bool>)(() => !scoreSequence.running)));
        }
        yield return clump.WaitForEnd();
        buttonsLayout.SetActive(true);
    }

    public void GoTo(string sceneName)
    {
        if (active)
        {
            active = false;
            new Routine(Sequences.EndCampaign(sceneName));
        }
    }

    public void QuickRestart()
    {
        if (active)
        {
            Campaign.Data = new CampaignData(Campaign.Data.GameMode);
            new Routine(Sequences.EndCampaign("CharacterSelect"));
            active = false;
        }
    }

    public void Exit()
    {
        if (active)
        {
            active = false;
            if (References.Campaign != null)
            {
                References.Campaign.Final();
            }
            GameManager.Quit();
        }
    }
}
public class DemoEndSequence : MonoBehaviour
{
    [SerializeField]
    public GameObject[] pages;

    [SerializeField]
    public Image[] pageBlips;

    [SerializeField]
    public Sprite blipActive;

    [SerializeField]
    public Sprite blipInactive;

    [SerializeField]
    public OpenURL openURL;

    [SerializeField]
    public TweenUI nextPageTween;

    [SerializeField]
    public TweenUI previousPageTween;

    public int currentPage;

    public bool active = true;

    public void Awake()
    {
        for (int i = 0; i < transform.childCount; i++)
        {
            if (((Component)transform.GetChild(i)).gameObject.activeSelf)
            {
                currentPage = i;
                break;
            }
        }
        if ((MonoBehaviourSingleton<Deckpack>.instance) && Deckpack.IsOpen)
        {
            Deckpack.Close();
        }
    }

    public void NextPage()
    {
        if (active)
        {
            ClosePage(currentPage);
            currentPage++;
            if (currentPage >= pages.Length)
            {
                currentPage = 0;
            }
            OpenPage(currentPage);
            nextPageTween.Fire();
        }
    }

    public void PreviousPage()
    {
        if (active)
        {
            ClosePage(currentPage);
            currentPage--;
            if (currentPage < 0)
            {
                currentPage = pages.Length - 1;
            }
            OpenPage(currentPage);
            previousPageTween.Fire();
        }
    }

    public void Wishlist()
    {
        if (active)
        {
            openURL.Open();
        }
    }

    public void Close()
    {
        if (active)
        {
            active = false;
            new Routine(SceneManager.Unload("DemoEnd"));
        }
    }

    public void OpenPage(int number)
    {
        pages[number].SetActive(true);
        pageBlips[number].sprite = blipActive;
    }

    public void ClosePage(int number)
    {
        pages[currentPage].SetActive(false);
        pageBlips[currentPage].sprite = blipInactive;
    }
}
public class GainBlessingSequence : UISequence
{
    [SerializeField]
    public AssetReferenceGameObject blessingPrefab;

    [SerializeField]
    public Transform blessingGroup;

    [SerializeField]
    public int options = 3;

    [SerializeField]
    public BlessingData[] blessingPool;

    [SerializeField]
    public LocalizedString titleKey;

    [SerializeField]
    public EventReference selectSfxEvent;

    public readonly List<BlessingData> blessings = new List<BlessingData>();

    public override IEnumerator Run()
    {
        List<BlessingData> list = GetBlessings();
        if (list.Count > 0)
        {
            CinemaBarSystem.In();
            CinemaBarSystem.Top.SetPrompt(titleKey.GetLocalizedString(), "Select");
            yield return CreateBlessings(list);
            while (!promptEnd)
            {
                yield return null;
            }
            CinemaBarSystem.Out();
        }
    }

    public List<BlessingData> GetBlessings()
    {
        List<BlessingData> list = new List<BlessingData>();
        BlessingData[] array = blessingPool;
        foreach (BlessingData blessingData in array)
        {
            bool flag = false;
            if (Campaign.Data.Modifiers != null)
            {
                foreach (GameModifierData modifier in Campaign.Data.Modifiers)
                {
                    if (IArrayExt.Contains<GameModifierData>(blessingData.modifierToAdd.blockedBy, modifier))
                    {
                        flag = true;
                        break;
                    }
                }
            }
            if (!flag)
            {
                list.Add(blessingData);
                if (list.Count >= options)
                {
                    break;
                }
            }
        }
        return list;
    }

    public IEnumerator CreateBlessings(IEnumerable<BlessingData> blessingsToCreate)
    {
        foreach (BlessingData item in blessingsToCreate)
        {
            yield return CreateBlessing(item);
        }
    }

    public IEnumerator CreateBlessing(BlessingData blessingData)
    {
        AsyncOperationHandle<GameObject> handle = ((AssetReference)blessingPrefab).InstantiateAsync(blessingGroup, false);
        yield return handle;
        handle.Result.GetComponent<BlessingSelect>().SetUp(blessingData, this);
    }

    public void SelectBlessing(BlessingData blessingData)
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        if (!promptEnd)
        {
            blessingData.Select();
            promptEnd = true;
            SfxSystem.OneShot(selectSfxEvent);
        }
    }
}
[Serializable]
public class BlessingData
{
    public GameModifierData modifierToAdd;

    public void Select()
    {
        ModifierSystem.AddModifier(Campaign.Data, modifierToAdd);
        Routine.Clump clump = new Routine.Clump();
        Script[] startScripts = modifierToAdd.startScripts;
        foreach (Script script in startScripts)
        {
            clump.Add(script.Run());
        }
        startScripts = modifierToAdd.setupScripts;
        foreach (Script script2 in startScripts)
        {
            clump.Add(script2.Run());
        }
        string[] systemsToAdd = modifierToAdd.systemsToAdd;
        foreach (string text in systemsToAdd)
        {
            Debug.Log($"[{modifierToAdd}] adding system: {text}");
            GameObjectExt.AddComponentByName(((Component)Campaign.instance).gameObject, text);
        }
    }
}
public class GainBlessingSequence2 : UISequence
{
    [Serializable]
    public struct SelectPrefab
    {
        public BossRewardData.Type bossRewardType;

        public BossRewardSelect prefab;
    }

    [SerializeField]
    public Transform rewardGroup;

    [SerializeField]
    public LocalizedString titleKey;

    [SerializeField]
    public LocalizedString chooseKey;

    [SerializeField]
    public EventReference selectSfxEvent;

    [SerializeField]
    public Animator animator;

    [SerializeField]
    public ParticleSystem buildUpPS;

    [SerializeField]
    public ParticleSystem explodePS;

    [SerializeField]
    public HandleSpinner handleSpinner;

    [SerializeField]
    public GameObject openTrigger;

    [SerializeField]
    public GameObject closedEye;

    [SerializeField]
    public GameObject openEye;

    [Header("Prefabs")]
    [SerializeField]
    public SelectPrefab[] selectPrefabs;

    [Header("Positioning")]
    [SerializeField]
    public float spacing = 2.5f;

    [SerializeField]
    public float randX = 0.1f;

    [SerializeField]
    public float randY = 1f;

    [Header("SFX")]
    [SerializeField]
    public EventReference appearSfxEvent;

    [SerializeField]
    public EventReference openSfxEvent;

    public CampaignNodeTypeBoss.RewardData rewardData;

    public bool canOpen;

    public bool open;

    public int taken;

    public override IEnumerator Run()
    {
        CampaignNode campaignNode = Campaign.FindCharacterNode(References.Player);
        rewardData = DictionaryExt.Get<CampaignNodeTypeBoss.RewardData>(campaignNode.data, "rewards");
        List<BossRewardData.Data> rewardsToCreate = rewardData.rewards;
        if (rewardsToCreate != null && rewardsToCreate.Count > 0)
        {
            SfxSystem.OneShot(appearSfxEvent);
            CinemaBarSystem.In();
            UpdateCinemaBarPrompt();
            canOpen = true;
            while (!open)
            {
                yield return null;
            }
            UpdateCinemaBarPrompt();
            CreateRewards(rewardsToCreate);
            while (!promptEnd)
            {
                yield return null;
            }
            CinemaBarSystem.Out();
        }
    }

    public void StartOpen()
    {
        if (!open && canOpen)
        {
            canOpen = false;
            openTrigger.SetActive(false);
            StartCoroutine(OpenRoutine());
        }
    }

    public IEnumerator OpenRoutine()
    {
        CinemaBarSystem.Top.RemovePrompt();
        SfxSystem.OneShot(openSfxEvent);
        closedEye.SetActive(false);
        openEye.SetActive(true);
        animator.SetBool("Open", true);
        handleSpinner.Spin();
        Events.InvokeScreenRumble(0f, 0.5f, 0f, 0.05f, 0.25f, 0.05f);
        yield return (object)new WaitForSeconds(0.75f);
        handleSpinner.Stop();
        yield return (object)new WaitForSeconds(0.25f);
        Events.InvokeScreenRumble(0f, 1f, 0f, 0.5f, 0.5f, 0.1f);
        buildUpPS.Play();
        yield return (object)new WaitForSeconds(1f);
        Events.InvokeScreenShake(1.5f, 0f);
        explodePS.Play();
        open = true;
        GameObjectExt.Destroy(((Component)animator).gameObject);
    }

    public void UpdateCinemaBarPrompt()
    {
        string text = (open ? StringExt.Format(chooseKey.GetLocalizedString(), new object[1] { rewardData.canTake - taken }) : titleKey.GetLocalizedString());
        CinemaBarSystem.Top.SetPrompt(text, "Select");
    }

    public void CreateRewards(List<BossRewardData.Data> rewardsToCreate)
    {
        Random.InitState(Campaign.FindCharacterNode(References.Player).seed);
        float num = (0f - spacing) * (float)(rewardsToCreate.Count - 1) * 0.5f;
        int num2 = PettyRandom.Choose<int>(new int[2] { 1, -1 });
        foreach (BossRewardData.Data item in rewardsToCreate)
        {
            CreateReward(item, num, 0f, num2);
            num += spacing;
            if (PettyRandom.Range(0f, 1f) > 0.2f)
            {
                num2 *= -1;
            }
        }
    }

    public void CreateReward(BossRewardData.Data reward, float startX, float startY, float ySign)
    {
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        BossRewardSelect bossRewardSelect = Object.Instantiate<BossRewardSelect>(selectPrefabs.FirstOrDefault((SelectPrefab a) => a.bossRewardType == reward.type).prefab, rewardGroup);
        float num = startX + PettyRandom.Range(0f - randX, randX);
        float num2 = startY + PettyRandom.Range(0f, randY) * ySign;
        ((Component)bossRewardSelect).transform.localPosition = PettyRandom.Vector3();
        LeanTween.moveLocal(((Component)bossRewardSelect).gameObject, new Vector3(num, num2), PettyRandom.Range(1f, 2f)).setEaseOutElastic();
        bossRewardSelect.SetUp(reward, this);
    }

    public void Select(BossRewardData.Data reward)
    {
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        if (!promptEnd)
        {
            reward.Select();
            if (++taken >= rewardData.canTake)
            {
                promptEnd = true;
            }
            else
            {
                UpdateCinemaBarPrompt();
            }
            SfxSystem.OneShot(selectSfxEvent);
        }
    }
}
public class GainCharmSequence : UISequence
{
    [Header("Custom Values")]
    [SerializeField]
    public CardUpgradeData charmData;

    [SerializeField]
    public CardCharm charmPrefab;

    [SerializeField]
    public float charmScale = 2f;

    [SerializeField]
    public Vector2 charmPopUpOffset = new Vector2(1f, 0f);

    [SerializeField]
    public Transform charmHolder;

    [SerializeField]
    public CanvasGroup fade;

    [SerializeField]
    public float fadeInTime = 0.2f;

    [SerializeField]
    public float fadeOutTime = 0.2f;

    [SerializeField]
    public TweenUI[] startTweens;

    [SerializeField]
    public TweenUI[] endTweens;

    [SerializeField]
    public Character character;

    [SerializeField]
    public TMP_Text title;

    public CardCharmInteraction charmInteraction;

    public void SetCharm(CardUpgradeData charmData)
    {
        this.charmData = charmData;
    }

    public void SetCharacter(Character character)
    {
        this.character = character;
    }

    public void SetTitle(string text)
    {
        title.text = "<size=0.5><#A9AAD4>" + text + "</size></color>\n" + charmData.title;
    }

    public override IEnumerator Run()
    {
        character.data.inventory.upgrades.Add(charmData);
        Events.InvokeUpgradeGained(charmData);
        Campaign.PromptSave();
        ((Component)fade).gameObject.SetActive(false);
        TransformExt.DestroyAllChildren(charmHolder);
        yield return Sequences.Wait(startDelay);
        gameObject.SetActive(true);
        ((Component)fade).gameObject.SetActive(true);
        fade.alpha = 0f;
        fade.LeanAlpha(1f, fadeInTime);
        fade.blocksRaycasts = true;
        float num = 0f;
        TweenUI[] array = startTweens;
        foreach (TweenUI tweenUI in array)
        {
            tweenUI.Fire();
            num = Mathf.Max(num, tweenUI.GetDuration());
        }
        CardCharm cardCharm = Object.Instantiate<CardCharm>(charmPrefab, charmHolder);
        cardCharm.holder = charmHolder;
        ((Component)cardCharm).transform.localScale = Vector3.one * charmScale;
        cardCharm.SetData(charmData);
        charmInteraction = ((Component)cardCharm).GetComponent<CardCharmInteraction>();
        if ((charmInteraction))
        {
            charmInteraction.popUpOffset = charmPopUpOffset;
            charmInteraction.PopUpDescription();
        }
        while (!promptEnd)
        {
            yield return null;
        }
        promptEnd = false;
        charmInteraction.HideDescription();
        fade.LeanAlpha(0f, fadeOutTime);
        fade.blocksRaycasts = false;
        SfxSystem.OneShot("event:/sfx/ui/message_closing");
        float num2 = fadeOutTime;
        array = endTweens;
        foreach (TweenUI tweenUI2 in array)
        {
            tweenUI2.Fire();
            num2 = Mathf.Max(num2, tweenUI2.GetDuration());
        }
        yield return Sequences.Wait(num2);
        gameObject.SetActive(false);
        yield return WaitForInventoryClose();
    }

    public void CharacterOpenInventory()
    {
        if (character.entity.display is CharacterDisplay characterDisplay)
        {
            characterDisplay.OpenInventory();
        }
    }

    public static IEnumerator WaitForInventoryClose()
    {
        while (Deckpack.IsOpen)
        {
            yield return null;
        }
    }
}
public class GainCompanionSequence : UISequence
{
    public Entity target;

    public void SetTarget(Entity target)
    {
        this.target = target;
    }

    public override IEnumerator Run()
    {
        yield return null;
    }
}
public class GainCrownSequence : UISequence
{
    [Header("Custom Values")]
    [SerializeField]
    public CanvasGroup fade;

    [SerializeField]
    public float fadeInTime = 0.2f;

    [SerializeField]
    public float fadeOutTime = 0.2f;

    [SerializeField]
    public TweenUI[] startTweens;

    [SerializeField]
    public TweenUI[] endTweens;

    [SerializeField]
    public Image crownImage;

    [SerializeField]
    public CardUpgradeData defaultCrownData;

    public CardUpgradeData crownData;

    public void SetData(CardUpgradeData crownData)
    {
        this.crownData = crownData;
    }

    public override IEnumerator Run()
    {
        if (!(crownData))
        {
            crownData = defaultCrownData.Clone();
        }
        crownImage.sprite = crownData.image;
        References.PlayerData.inventory.upgrades.Add(crownData);
        Events.InvokeUpgradeGained(crownData);
        ((Component)fade).gameObject.SetActive(false);
        yield return Sequences.Wait(startDelay);
        gameObject.SetActive(true);
        ((Component)fade).gameObject.SetActive(true);
        fade.alpha = 0f;
        fade.LeanAlpha(1f, fadeInTime);
        fade.blocksRaycasts = true;
        float num = 0f;
        TweenUI[] array = startTweens;
        foreach (TweenUI tweenUI in array)
        {
            tweenUI.Fire();
            num = Mathf.Max(num, tweenUI.GetDuration());
        }
        while (!promptEnd)
        {
            yield return null;
        }
        promptEnd = false;
        fade.LeanAlpha(0f, fadeOutTime);
        fade.blocksRaycasts = false;
        SfxSystem.OneShot("event:/sfx/ui/message_closing");
        float num2 = fadeOutTime;
        array = endTweens;
        foreach (TweenUI tweenUI2 in array)
        {
            tweenUI2.Fire();
            num2 = Mathf.Max(num2, tweenUI2.GetDuration());
        }
        yield return Sequences.Wait(num2);
        gameObject.SetActive(false);
    }

    public void CharacterOpenInventory()
    {
        if (References.Player.entity.display is CharacterDisplay characterDisplay)
        {
            characterDisplay.OpenInventory();
        }
    }
}
public class GainNegativeCharmSequence : MonoBehaviour
{
    [SerializeField]
    public GameObject holderGroup;

    [SerializeField]
    public CardCharmHolder[] holders;

    [SerializeField]
    public CardCharmHolder activeCharmHolder;

    [SerializeField]
    public GameObject cardGridGroup;

    [SerializeField]
    public DeckDisplayGroup deckDisplayGroup;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardUpgradeData[] charmOptions;

    [SerializeField]
    public CinemaBarShower cinemaBarShower;

    [SerializeField]
    public Fader backgroundFader;

    public bool charmChosen;

    public bool promptEnd;

    public IEnumerator Run()
    {
        CampaignNode campaignNode = Campaign.FindCharacterNode(References.Player);
        State state = Random.state;
        Random.InitState(campaignNode.seed);
        CreateUpgrades();
        Random.state = state;
        yield return (object)new WaitUntil((Func<bool>)(() => promptEnd));
        cinemaBarShower.Hide();
        backgroundFader.Out(0.25f);
        yield return (object)new WaitForSeconds(0.5f);
    }

    public void CreateUpgrades()
    {
        List<CardUpgradeData> list = new List<CardUpgradeData>(charmOptions);
        IListExt.Shuffle<CardUpgradeData>((IList<CardUpgradeData>)list);
        int num = holders.Length;
        foreach (CardUpgradeData item in list)
        {
            if (UpgradeCanBeAssignedToSomethingInDeck(item))
            {
                CreateUpgrade(item.Clone());
                if (--num <= 0)
                {
                    break;
                }
            }
        }
    }

    public bool UpgradeCanBeAssignedToSomethingInDeck(CardUpgradeData upgradeData)
    {
        foreach (CardData item in References.PlayerData.inventory.deck)
        {
            if (upgradeData.CanAssign(item))
            {
                return true;
            }
        }
        return false;
    }

    public void CreateUpgrade(CardUpgradeData upgradeDataClone)
    {
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        CardCharmHolder cardCharmHolder = holders.FirstOrDefault((CardCharmHolder a) => ((Component)a).transform.childCount == 0);
        if ((cardCharmHolder))
        {
            UpgradeDisplay upgrade = cardCharmHolder.Create(upgradeDataClone);
            CardCharmInteraction component = ((Component)upgrade).GetComponent<CardCharmInteraction>();
            component.popUpOffset = new Vector2(0.8f, -0.25f);
            component.onDrag.AddListener((UnityAction<UpgradeDisplay>)delegate
            {
                Take(upgrade);
            });
        }
    }

    public void Take(UpgradeDisplay upgrade)
    {
        if (!charmChosen)
        {
            charmChosen = true;
            activeCharmHolder.Create(upgrade.data);
            holderGroup.SetActive(false);
            StartCoroutine(OpenCardGrid(upgrade.data));
        }
    }

    public IEnumerator OpenCardGrid(CardUpgradeData upgradeData)
    {
        cardGridGroup.SetActive(true);
        Routine.Clump clump = new Routine.Clump();
        foreach (CardData item in References.PlayerData.inventory.deck)
        {
            if (upgradeData.CanAssign(item))
            {
                clump.Add(CreateCard(item));
            }
        }
        yield return clump.WaitForEnd();
        deckDisplayGroup.UpdatePositions();
        yield return RectTransformExt.FixLayoutGroup((RectTransform)((Component)deckDisplayGroup).transform.parent);
        yield return FlipCardsUp();
    }

    public void HideCardGrid()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(cardGridGroup);
        LeanTween.scale(cardGridGroup, Vector3.zero, 0.33f).setEaseInBack();
    }

    public IEnumerator FlipCardsUp()
    {
        foreach (Entity item in deckDisplayGroup.grids[0])
        {
            item.flipper.FlipUp(force: true);
            yield return (object)new WaitForSeconds(PettyRandom.Range(0f, 0.1f));
        }
    }

    public IEnumerator CreateCard(CardData cardData)
    {
        Card card = CardManager.Get(cardData, cardController, References.Player, inPlay: false, isPlayerCard: true);
        deckDisplayGroup.AddCard(card);
        card.entity.flipper.FlipDownInstant();
        yield return card.UpdateData();
    }

    public void End()
    {
        promptEnd = true;
    }
}
public class GainUnlockSequence : MonoBehaviour
{
    public TMP_Text titleElement;

    public TMP_Text descriptionElement;

    [Header("Displays")]
    [SerializeField]
    public GameObject constructionDisplay;

    [SerializeField]
    public GameObject petHutDisplay;

    [SerializeField]
    public GameObject inventorDisplay;

    [SerializeField]
    public GameObject icebreakerDisplay;

    [SerializeField]
    public GameObject tribeHallDisplay;

    [SerializeField]
    public GameObject hotSpringDisplay;

    [SerializeField]
    public GameObject frostoscopeDisplay;

    [SerializeField]
    public GameObject challengeShrineDisplay;

    [SerializeField]
    public GameObject newItemIcon;

    public GameObject display;

    public void SetUp(UnlockData unlockData)
    {
        SetTitle(unlockData);
        SetDisplay(unlockData);
        SetDescription(unlockData);
        gameObject.SetActive(true);
    }

    public void SetTitle(UnlockData unlockData)
    {
        string text = string.Empty;
        if (unlockData.relatedBuilding != null && unlockData.relatedBuilding.titleKey != null)
        {
            text = text + "<size=7.5>" + unlockData.relatedBuilding.titleKey.GetLocalizedString() + "</size>";
        }
        if (unlockData.unlockTitle != null)
        {
            if (!StringExt.IsNullOrWhitespace(text))
            {
                text += "\n";
            }
            text = text + "<#C3967F>" + unlockData.unlockTitle.GetLocalizedString();
        }
        titleElement.text = text;
    }

    public void SetDisplay(UnlockData unlockData)
    {
        newItemIcon.SetActive(unlockData.type == UnlockData.Type.Item || unlockData.type == UnlockData.Type.Pet || unlockData.type == UnlockData.Type.Tribe);
        if (display != null)
        {
            display.SetActive(false);
        }
        if (unlockData.type == UnlockData.Type.BuildingStarted)
        {
            SetDisplay(constructionDisplay);
            return;
        }
        switch ((unlockData.relatedBuilding).name)
        {
            case "PetHut":
                SetDisplay(petHutDisplay);
                break;
            case "TribeHut":
                SetDisplay(tribeHallDisplay);
                break;
            case "Icebreakers":
                SetDisplay(icebreakerDisplay);
                break;
            case "InventorHut":
                SetDisplay(inventorDisplay);
                break;
            case "HotSpring":
                SetDisplay(hotSpringDisplay);
                break;
            case "Frostoscope":
                SetDisplay(frostoscopeDisplay);
                break;
            case "ChallengeShrine":
                SetDisplay(challengeShrineDisplay);
                break;
        }
    }

    public void SetDisplay(GameObject type)
    {
        display = type;
        display.SetActive(true);
    }

    public void SetDescription(UnlockData unlockData)
    {
        LocalizedString unlockDesc = unlockData.unlockDesc;
        if (unlockDesc != null && !((LocalizedReference)unlockDesc).IsEmpty)
        {
            string localizedString = unlockData.unlockDesc.GetLocalizedString();
            descriptionElement.text = localizedString;
        }
        else
        {
            descriptionElement.text = "";
        }
    }

    public void Close()
    {
        gameObject.SetActive(false);
    }
}
public class InspectNewUnitSequence : UISequence
{
    [Header("Custom Values")]
    public bool takeCard;

    public Transform cardHolder;

    [SerializeField]
    public SpeechBubble speechBubble;

    [SerializeField]
    public LocalizedString[] defaultGreetMessages;

    [SerializeField]
    public Color nameHighlightColour;

    [SerializeField]
    public Color nameTextColour;

    public Entity unit;

    public string greeting;

    public Transform unitPreParent;

    public Vector3 unitPrePosition;

    public Vector3 unitPreRotation;

    public Vector3 unitPreScale;

    [SerializeField]
    public float unitMoveWobble = 1.5f;

    [SerializeField]
    public AnimationCurve unitMoveCurve;

    [SerializeField]
    public float unitMoveDur = 0.33f;

    public CardSelector cardSelector;

    [SerializeField]
    public RenameCompanionSequence renameSequence;

    public bool destroyOnEnd;

    public void SetUnit(Entity unit)
    {
        SetUnit(unit, updateGreeting: true);
    }

    public void SetUnit(Entity unit, bool updateGreeting)
    {
        this.unit = unit;
        if (updateGreeting && speechBubble != null)
        {
            int num = unit.data.greetMessages.Length;
            greeting = ((num > 0) ? IArrayExt.RandomItem<string>(unit.data.greetMessages) : IArrayExt.RandomItem<LocalizedString>(defaultGreetMessages).GetLocalizedString());
        }
        UpdateUnit();
    }

    public void UpdateUnit()
    {
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_008b: Unknown result type (might be due to invalid IL or missing references)
        if (!(speechBubble == null))
        {
            string text = unit.data.title;
            if (nameTextColour.a > 0f)
            {
                text = "<color=#" + ColorExt.ToHexRGBA(nameTextColour) + ">" + text + "</color>";
            }
            if (nameHighlightColour.a > 0f)
            {
                text = "<mark=#" + ColorExt.ToHexRGBA(nameHighlightColour) + ">" + text + "</mark>";
            }
            string text2 = greeting.Replace("<name>", text);
            speechBubble.SetText(text2);
        }
    }

    public void UnsetUnit()
    {
        unit = null;
    }

    public override IEnumerator Run()
    {
        UIAnchors anchors = GetComponent<UIAnchors>();
        UIAnchors.AnchorPoint[] list = anchors.list;
        foreach (UIAnchors.AnchorPoint obj in list)
        {
            obj.Deactivate();
            obj.SetUp();
        }
        yield return Sequences.Wait(startDelay);
        Events.InvokeInspectNewCard(unit);
        Events.InvokeEntityFocus(unit);
        if (gameObject.activeSelf)
        {
            GetComponent<UINavigationLayer>().OnEnable();
        }
        gameObject.SetActive(true);
        if (unitMoveWobble != 0f && unit.wobbler != null)
        {
            unit.wobbler.WobbleRandom(unitMoveWobble);
        }
        Transform transform = unit.transform;
        unitPreParent = transform.parent;
        unitPrePosition = transform.localPosition;
        unitPreRotation = transform.localEulerAngles;
        unitPreScale = transform.localScale;
        transform.SetParent(cardHolder, true);
        LeanTween.cancel(((Component)unit).gameObject);
        LeanTween.moveLocal(((Component)unit).gameObject, Vector3.zero, unitMoveDur).setEase(unitMoveCurve);
        LeanTween.rotateLocal(((Component)unit).gameObject, Vector3.zero, unitMoveDur).setEase(unitMoveCurve);
        LeanTween.scale(((Component)unit).gameObject, Vector3.one, unitMoveDur).setEase(unitMoveCurve);
        int c = anchors.Count;
        for (int i = 0; i < c; i++)
        {
            anchors.Activate(i);
            yield return null;
            StartCoroutine(anchors.Reveal(i));
            yield return Sequences.Wait(delayBetween);
        }
        StartCoroutine(anchors.UpdatePositions());
        while (!promptEnd)
        {
            yield return null;
        }
        promptEnd = false;
        MonoBehaviourSingleton<UINavigationSystem>.instance.RemoveActiveLayer();
        if (!takeCard && unit != null)
        {
            unit.transform.SetParent(unitPreParent, true);
            LeanTween.cancel(((Component)unit).gameObject);
            LeanTween.moveLocal(((Component)unit).gameObject, unitPrePosition, unitMoveDur).setEase(unitMoveCurve);
            LeanTween.rotateLocal(((Component)unit).gameObject, unitPreRotation, unitMoveDur).setEase(unitMoveCurve);
            LeanTween.scale(((Component)unit).gameObject, unitPreScale, unitMoveDur).setEase(unitMoveCurve);
            if (unitMoveWobble != 0f && unit.wobbler != null)
            {
                unit.wobbler.WobbleRandom(unitMoveWobble);
            }
        }
        if (destroyOnEnd)
        {
            GameObjectExt.Destroy(gameObject);
        }
        else
        {
            gameObject.SetActive(false);
        }
    }

    public void TakeCard()
    {
        if (!takeCard)
        {
            End();
            if (unit != null)
            {
                takeCard = true;
                cardSelector.TakeCard(unit);
            }
        }
    }

    public void StartRename()
    {
        if (!takeCard)
        {
            renameSequence.SetUnit(unit);
            renameSequence.Begin();
        }
    }
}
public class IntroSequence : MonoBehaviour
{
    [SerializeField]
    public string nextScene;

    [SerializeField]
    public Animator animator;

    [SerializeField]
    public LocalizedString[] textKeys;

    public int textCurrent;

    public GameObject current;

    public void Start()
    {
        if (GameManager.Ready)
        {
            Transition.End();
            StartSequence();
        }
    }

    public void OnDisable()
    {
        CinemaBarSystem.Clear();
        CinemaBarSystem.OutInstant();
    }

    public void StartSequence()
    {
        CinemaBarSystem.InInstant();
        CinemaBarSystem.Clear();
        animator.SetTrigger("Play");
    }

    public void EndSequence()
    {
        new Routine(Transition.To(nextScene));
    }

    public void NextText()
    {
        CinemaBarSystem.SetScript(textKeys[textCurrent++].GetLocalizedString(), typewriterAnimation: true);
    }
}
public class JournalAddNameSequence : MonoBehaviour
{
    [SerializeField]
    public LeaderNameHistoryDisplay display;

    [SerializeField]
    public TweenUI endTween;

    [SerializeField]
    public EventReference sfxEvent;

    public static IEnumerator LoadAndRun(CardData leader, bool unloadAfter)
    {
        InputSystem.Disable();
        yield return SceneManager.Load("JournalNameHistory", SceneType.Temporary);
        JournalAddNameSequence addNameSequence = Object.FindObjectOfType<JournalAddNameSequence>();
        yield return addNameSequence.Run(leader);
        if (unloadAfter)
        {
            new Routine(addNameSequence.End());
        }
        InputSystem.Enable();
    }

    public IEnumerator Run(CardData leader)
    {
        yield return (object)new WaitForSecondsRealtime(0.5f);
        JournalNameHistory.FadePrevious();
        JournalNameHistory.AddName(leader.title);
        display.Repopulate();
        SfxSystem.OneShot(sfxEvent);
        yield return (object)new WaitForSecondsRealtime(1f);
    }

    public IEnumerator End()
    {
        endTween.Fire();
        yield return (object)new WaitForSecondsRealtime(endTween.GetDuration());
        new Routine(SceneManager.Unload("JournalNameHistory"));
    }
}
public class JournalVoidNameSequence : MonoBehaviour
{
    [SerializeField]
    public LeaderNameHistoryDisplay display;

    [SerializeField]
    public TweenUI endTween;

    public static IEnumerator LoadAndRun(bool unloadAfter)
    {
        yield return SceneManager.Load("JournalNameHistory", SceneType.Temporary);
        JournalVoidNameSequence voidNameSequence = Object.FindObjectOfType<JournalVoidNameSequence>();
        yield return voidNameSequence.PlayerKilled();
        if (unloadAfter)
        {
            yield return voidNameSequence.End();
        }
    }

    public IEnumerator PlayerKilled()
    {
        yield return (object)new WaitForSecondsRealtime(0.5f);
        JournalNameHistory.MostRecentNameKilled();
        display.Repopulate();
        yield return (object)new WaitForSecondsRealtime(1f);
    }

    public IEnumerator End()
    {
        endTween.Fire();
        yield return (object)new WaitForSecondsRealtime(endTween.GetDuration());
        new Routine(SceneManager.Unload("JournalNameHistory"));
    }
}
public class MapInspectSequence : MonoBehaviour
{
    [Serializable]
    public struct Profile
    {
        public LocalizedString titleKey;

        public LocalizedString descKey;

        public Sprite icon;
    }

    [SerializeField]
    public LocalizeStringEvent title;

    [SerializeField]
    public LocalizeStringEvent desc;

    [SerializeField]
    public Image image;

    [SerializeField]
    public Profile[] profiles;

    public void Inspect(int index)
    {
        Inspect(profiles[index]);
    }

    public void Inspect(Profile profile)
    {
        Inspect(profile.titleKey, profile.descKey, profile.icon);
    }

    public void Inspect(LocalizedString titleKey, LocalizedString descKey, Sprite icon)
    {
        title.StringReference = titleKey;
        desc.StringReference = descKey;
        image.sprite = icon;
        gameObject.SetActive(true);
    }
}
public class ModifyCardSequence : MonoBehaviour
{
    [SerializeField]
    public CardContainer cardContainer;

    [SerializeField]
    public LocalizedString titleStringRef;

    [SerializeField]
    public LocalizedString continueStringRef;

    [SerializeField]
    public TweenUI endTween;

    public bool canEnd;

    public bool end;

    public IEnumerator Run(CardData cardToModify, CardScript modifyScript)
    {
        int hp = cardToModify.hp;
        modifyScript.Run(cardToModify);
        int healthLost = hp - cardToModify.hp;
        Events.InvokeScreenRumble(0f, 0.2f, 0f, 0.25f, 0.25f, 0.1f);
        Card card = CardManager.Get(cardToModify, null, References.Player, inPlay: false, isPlayerCard: true);
        card.entity.flipper.FlipDownInstant();
        cardContainer.Add(card.entity);
        yield return card.UpdateData();
        card.transform.localPosition = Vector3.down;
        card.entity.wobbler.WobbleRandom();
        cardContainer.TweenChildPositions();
        CinemaBarSystem.In();
        CinemaBarSystem.Top.SetScript(StringExt.Format(titleStringRef.GetLocalizedString(), new object[2] { cardToModify.title, healthLost }));
        CinemaBarSystem.Bottom.SetPrompt(continueStringRef.GetLocalizedString(), "Select");
        yield return (object)new WaitForSeconds(0.2f);
        card.entity.flipper.FlipUp();
        canEnd = true;
        yield return (object)new WaitUntil((Func<bool>)(() => end));
        CinemaBarSystem.Clear();
        CinemaBarSystem.Out();
        if ((endTween))
        {
            endTween.Fire();
            yield return (object)new WaitForSeconds(endTween.GetDuration());
        }
    }

    public void Continue()
    {
        if (canEnd)
        {
            end = true;
        }
    }
}
public class OpenCharmBlockSequence : UISequence
{
    [Header("Custom Values")]
    [SerializeField]
    public CardUpgradeData charmData;

    [SerializeField]
    public Transform charmBlockHolder;

    [SerializeField]
    public GainCharmSequence gainCharmSequence;

    [SerializeField]
    public Character character;

    [SerializeField]
    public Animator animator;

    [SerializeField]
    public float animationDuration = 2f;

    [SerializeField]
    public ParticleSystem buildupParticleSystem;

    [SerializeField]
    public ParticleSystem explodeParticleSystem;

    public void SetCharm(CardUpgradeData charmData, Transform charmBlock)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        this.charmData = charmData;
        charmBlockHolder.SetPositionAndRotation(charmBlock.position, charmBlock.rotation);
    }

    public void SetCharacter(Character character)
    {
        this.character = character;
    }

    public override IEnumerator Run()
    {
        yield return Sequences.Wait(startDelay);
        gameObject.SetActive(true);
        gainCharmSequence.SetCharm(charmData);
        gainCharmSequence.SetCharacter(character);
        animator.SetBool("BackgroundFade", true);
        Events.InvokeScreenRumble(0.1f, 0f, 0f, 0.1f, 0f, 0f);
        LeanTween.moveLocal(((Component)charmBlockHolder).gameObject, Vector3.zero, 1f).setEase(LeanTweenType.easeOutBack);
        LeanTween.rotateLocal(((Component)charmBlockHolder).gameObject, Vector3.zero, 1.5f).setEase(LeanTweenType.easeOutElastic);
        yield return Sequences.Wait(0.4f);
        animator.SetTrigger("Open");
        SfxSystem.OneShot("event:/sfx/inventory/charm_claim");
        Events.InvokeScreenRumble(0f, 2f, 0.25f, 0.75f, 0.5f, 0.25f);
        yield return Sequences.Wait(animationDuration);
        Events.InvokeScreenShake(5f, 0f);
        Routine.Clump clump = new Routine.Clump();
        clump.Add(gainCharmSequence.Run());
        clump.Add(FadeOutBackground(0.25f));
        yield return clump.WaitForEnd();
        gameObject.SetActive(false);
    }

    public IEnumerator FadeOutBackground(float delay = 0f)
    {
        yield return Sequences.Wait(delay);
        animator.SetBool("BackgroundFade", false);
        yield return Sequences.Wait(0.5f);
    }

    public void PlayBuildUpParticleSystem()
    {
        buildupParticleSystem.Play();
    }

    public void PlayExplodeParticleSystem()
    {
        explodeParticleSystem.Play();
    }
}
public class RenameCompanionSequence : UISequence
{
    [Header("Custom Values")]
    [SerializeField]
    public Transform cardHolder;

    [SerializeField]
    public TMP_InputField inputField;

    public Entity unit;

    public Transform unitPreParent;

    public Vector3 unitPrePosition;

    public Vector3 unitPreRotation;

    public Vector3 unitPreScale;

    [SerializeField]
    public float unitMoveWobble = 1.5f;

    [SerializeField]
    public AnimationCurve unitMoveCurve;

    [SerializeField]
    public float unitMoveDur = 0.33f;

    public bool endImmediate;

    public void OnEnable()
    {
        SteamUtils.OnGamepadTextInputDismissed += GamepadTextInputDismissed;
    }

    public void OnDisable()
    {
        SteamUtils.OnGamepadTextInputDismissed -= GamepadTextInputDismissed;
    }

    public void GamepadTextInputDismissed(bool success)
    {
        if (success)
        {
            inputField.text = SteamUtils.GetEnteredGamepadText();
            Confirm();
        }
        else
        {
            Cancel();
        }
    }

    public void SetUnit(Entity unit)
    {
        this.unit = unit;
        Graphic placeholder = inputField.placeholder;
        TMP_Text val = (TMP_Text)(object)((placeholder is TMP_Text) ? placeholder : null);
        if (val != null)
        {
            val.text = unit.data.title;
        }
    }

    public override IEnumerator Run()
    {
        endImmediate = false;
        inputField.text = "";
        UIAnchors anchors = GetComponent<UIAnchors>();
        UIAnchors.AnchorPoint[] list = anchors.list;
        foreach (UIAnchors.AnchorPoint obj in list)
        {
            obj.Deactivate();
            obj.SetUp();
        }
        yield return Sequences.Wait(startDelay);
        gameObject.SetActive(true);
        if (unitMoveWobble != 0f && unit.wobbler != null)
        {
            unit.wobbler.WobbleRandom(unitMoveWobble);
        }
        Transform transform = unit.transform;
        unitPreParent = transform.parent;
        unitPrePosition = transform.localPosition;
        unitPreRotation = transform.localEulerAngles;
        unitPreScale = transform.localScale;
        unit.transform.SetParent(cardHolder, true);
        LeanTween.cancel(((Component)unit).gameObject);
        LeanTween.moveLocal(((Component)unit).gameObject, Vector3.zero, unitMoveDur).setEase(unitMoveCurve);
        LeanTween.rotateLocal(((Component)unit).gameObject, Vector3.zero, unitMoveDur).setEase(unitMoveCurve);
        LeanTween.scale(((Component)unit).gameObject, Vector3.one, unitMoveDur).setEase(unitMoveCurve);
        SfxSystem.OneShot("event:/sfx/ui/card_renaming_open");
        int c = anchors.Count;
        for (int i = 0; i < c; i++)
        {
            anchors.Activate(i);
            yield return null;
            StartCoroutine(anchors.Reveal(i));
            yield return Sequences.Wait(delayBetween);
        }
        StartCoroutine(anchors.UpdatePositions());
        if (SteamManager.init)
        {
            SteamUtils.ShowGamepadTextInput((GamepadTextInputMode)0, (GamepadTextInputLineMode)0, "", 20, unit.data.title);
        }
        while (!promptEnd)
        {
            yield return null;
        }
        promptEnd = false;
        if (!endImmediate && unit != null)
        {
            unit.transform.SetParent(unitPreParent, true);
            LeanTween.cancel(((Component)unit).gameObject);
            LeanTween.moveLocal(((Component)unit).gameObject, unitPrePosition, unitMoveDur).setEase(unitMoveCurve);
            LeanTween.rotateLocal(((Component)unit).gameObject, unitPreRotation, unitMoveDur).setEase(unitMoveCurve);
            LeanTween.scale(((Component)unit).gameObject, unitPreScale, unitMoveDur).setEase(unitMoveCurve);
        }
        gameObject.SetActive(false);
    }

    public void Confirm()
    {
        if (!StringExt.IsNullOrWhitespace(inputField.text))
        {
            Entity entity = unit;
            string newName = inputField.text;
            if (Events.CheckRename(ref entity, ref newName))
            {
                SfxSystem.OneShot("event:/sfx/ui/card_renaming_accept");
                entity.data.forceTitle = newName;
                if (entity.display is Card card)
                {
                    card.SetName(entity.data.title);
                }
                Events.InvokeRename(entity, newName);
            }
        }
        End();
    }

    public void Cancel()
    {
        End();
    }

    public void EndImmediate()
    {
        endImmediate = true;
        End();
    }
}
public class RunMultipleSequences : MonoBehaviour
{
    [SerializeField]
    public UISequence[] sequences;

    [SerializeField]
    public bool unloadSceneAfter = true;

    public IEnumerator Start()
    {
        UISequence[] array = sequences;
        foreach (UISequence sequence in array)
        {
            ((Component)sequence).gameObject.SetActive(true);
            yield return sequence.Run();
            ((Component)sequence).gameObject.SetActive(false);
        }
        if (unloadSceneAfter)
        {
            Scene scene = gameObject.scene;
            new Routine(SceneManager.Unload(((scene)).name));
        }
    }
}
public class SplashScreenSequence : MonoBehaviour
{
    [Serializable]
    public struct Phase
    {
        public GameObject gameObject;

        public float canSkipTime;

        public float autoSkipTime;

        public EventReference sfxEvent;
    }

    [SerializeField]
    public Phase[] phases;

    public int phase;

    public EventInstance sfxInstance;

    public IEnumerator Run()
    {
        PauseMenu.Block();
        while (phase < phases.Length)
        {
            phases[phase].gameObject.SetActive(true);
            if (!((phases[phase].sfxEvent)).IsNull)
            {
                sfxInstance = SfxSystem.OneShot(phases[phase].sfxEvent);
            }
            float time = 0f;
            while (time < phases[phase].autoSkipTime)
            {
                yield return null;
                time += Time.deltaTime;
                if (time > phases[phase].canSkipTime && InputSystem.Enabled && AnyButtonPressed())
                {
                    break;
                }
            }
            phase++;
            if (((sfxInstance)).isValid())
            {
                ((sfxInstance)).stop((STOP_MODE)0);
            }
        }
        PauseMenu.Unblock();
    }

    public static bool AnyButtonPressed()
    {
        if (!Input.anyKeyDown && !Input.GetMouseButtonDown(0))
        {
            return InputSystem.IsSelectPressed();
        }
        return true;
    }
}
public class TokenRewardSequence : UISequence
{
    public class Target
    {
        public Entity entity;

        public CardContainer[] previousActualContainers;

        public CardController previousController;

        public Target(Entity entity, CardController controller)
        {
            this.entity = entity;
            previousActualContainers = new CardContainer[1] { entity.owner.drawContainer };
            Card component = ((Component)entity).GetComponent<Card>();
            previousController = component.hover.controller;
            component.hover.controller = controller;
        }

        public void MoveTo(params CardContainer[] containers)
        {
            entity.RemoveFromContainers();
            for (int i = 0; i < containers.Length; i++)
            {
                containers[i].Add(entity);
            }
        }

        public void Return()
        {
            MoveTo(previousActualContainers);
            CardContainer[] array = previousActualContainers;
            for (int i = 0; i < array.Length; i++)
            {
                array[i].TweenChildPositions();
            }
            ((Component)entity).GetComponent<Card>().hover.controller = previousController;
        }

        public override string ToString()
        {
            if (!(entity == null))
            {
                return (entity).name;
            }
            return "NULL";
        }
    }

    [SerializeField]
    public CanvasGroup canvasGroup;

    [SerializeField]
    public RectTransform titleTransform;

    [SerializeField]
    public Vector3 titleToPosition;

    [SerializeField]
    public TweenUI revealTween;

    [SerializeField]
    public TweenUI hideTween;

    [SerializeField]
    public CardContainer cardHolder;

    [SerializeField]
    public Button skipButton;

    [SerializeField]
    public int goldGainFromSkip = 10;

    [SerializeField]
    public CardController cardController;

    [SerializeField]
    public CardCharmDragHandler tokenDragHandler;

    [SerializeField]
    public RectTransform tokenSlotGroup;

    [SerializeField]
    public CardCharmHolder tokenSlotPrefab;

    [SerializeField]
    public CardUpgradeData[] tokenData;

    public List<Target> targets;

    public override IEnumerator Run()
    {
        Character player = References.Player;
        List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(player);
        if (targets == null)
        {
            targets = new List<Target>();
        }
        foreach (Entity item in cardsOnBoard)
        {
            CardData data = item.data;
            object obj;
            if (data == null)
            {
                obj = null;
            }
            else
            {
                CardType cardType = data.cardType;
                obj = ((cardType != null) ? (cardType).name : null);
            }
            if ((string?)obj == "Friendly")
            {
                targets.Add(new Target(item, cardController));
            }
        }
        Debug.Log(string.Format("{0} Targets: [{1}]", this, string.Join(", ", targets)));
        if (targets.Count <= 0)
        {
            yield break;
        }
        cardController.owner = player;
        LeanTween.moveLocal(((Component)titleTransform).gameObject, titleToPosition, 0.75f).setEase(LeanTweenType.easeOutBack);
        yield return Sequences.Wait(0.33f);
        gameObject.SetActive(true);
        revealTween.Fire();
        ((Component)tokenDragHandler).gameObject.SetActive(true);
        CardUpgradeData[] array = tokenData;
        foreach (CardUpgradeData obj2 in array)
        {
            CardCharmHolder cardCharmHolder = Object.Instantiate<CardCharmHolder>(tokenSlotPrefab, (Transform)(object)tokenSlotGroup);
            ((Component)cardCharmHolder).gameObject.SetActive(true);
            CardUpgradeData upgradeData = obj2.Clone();
            UpgradeDisplay token = cardCharmHolder.Create(upgradeData);
            CardCharmInteraction component = ((Component)token).GetComponent<CardCharmInteraction>();
            component.canHover = true;
            component.canDrag = true;
            component.onDrag.AddListener((UnityAction<UpgradeDisplay>)delegate
            {
                tokenDragHandler.Drag(token);
            });
        }
        ((Component)cardHolder).gameObject.SetActive(true);
        cardHolder.SetSize(targets.Count, cardHolder.CardScale);
        foreach (Target target2 in targets)
        {
            target2.MoveTo(cardHolder);
            target2.entity.wobbler?.WobbleRandom();
            cardHolder.TweenChildPositions();
            target2.entity.DrawOrder = 0;
            yield return Sequences.Wait(0.2f);
        }
        yield return Sequences.Wait(0.15f);
        for (int j = targets.Count - 1; j >= 0; j--)
        {
            Target target = targets[j];
            target.entity.curveAnimator.Ping();
            CoroutineManager.Start(target.entity.Reset());
            yield return Sequences.Wait(0.2f);
        }
        ((Component)skipButton).gameObject.SetActive(true);
        yield return (object)new WaitUntil((Func<bool>)(() => promptEnd));
        ((Component)skipButton).gameObject.SetActive(false);
        for (int j = targets.Count - 1; j >= 0; j--)
        {
            targets[j].Return();
            yield return Sequences.Wait(0.167f);
        }
        targets = null;
        ((Component)cardHolder).gameObject.SetActive(false);
        ((Component)tokenDragHandler).gameObject.SetActive(false);
        hideTween.Fire();
        yield return Sequences.Wait(hideTween.GetDuration());
        gameObject.SetActive(false);
    }

    public void TokenAssigned()
    {
        StartCoroutine(TokenAssignedRoutine());
    }

    public IEnumerator TokenAssignedRoutine()
    {
        yield return Sequences.Wait(0.1f);
        End();
        ((Selectable)skipButton).interactable = false;
    }

    public void Skip()
    {
        References.Player.GainGold(goldGainFromSkip);
        End();
        ((Selectable)skipButton).interactable = false;
    }
}
public class TownUnlockSequence : MonoBehaviour
{
    [SerializeField]
    public GainUnlockSequence unlockSequence;

    [SerializeField]
    public Fader fader;

    [SerializeField]
    public float pauseBeforeUnlock = 0.1f;

    [SerializeField]
    public float pauseAfterUnlock = 0.1f;

    public const float fadeOutDur = 0.1f;

    public IEnumerator Start()
    {
        yield return AddressableLoader.LoadGroup("UnlockData");
        List<UnlockData> unlocks = AddressableLoader.GetGroup<UnlockData>("UnlockData");
        List<string> unlocksToGain = SaveSystem.LoadProgressData("townNew", new List<string>());
        foreach (string unlockName in unlocksToGain)
        {
            UnlockData unlockData = unlocks.FirstOrDefault((UnlockData a) => (a).name == unlockName);
            if (unlockData != null)
            {
                yield return (object)new WaitForSeconds(pauseBeforeUnlock);
                Events.InvokeTownUnlock(unlockData);
                unlockSequence.SetUp(unlockData);
                yield return (object)new WaitUntil((Func<bool>)(() => !((Component)unlockSequence).gameObject.activeSelf));
                yield return (object)new WaitForSeconds(pauseAfterUnlock);
            }
        }
        unlocksToGain.Clear();
        SaveSystem.SaveProgressData("townNew", unlocksToGain);
        fader.Out(0.1f, LeanTweenType.linear);
        yield return (object)new WaitForSeconds(0.1f);
        new Routine(SceneManager.Unload("TownUnlocks"));
    }
}
public class TribeDisplaySequence : MonoBehaviour
{
    [SerializeField]
    public string[] tribeNames;

    [SerializeField]
    public GameObject[] displays;

    public void Run(string className)
    {
        for (int i = 0; i < tribeNames.Length; i++)
        {
            if (tribeNames[i] == className)
            {
                Run(i);
            }
        }
    }

    public void Run(int classIndex)
    {
        for (int i = 0; i < displays.Length; i++)
        {
            displays[i].gameObject.SetActive(i == classIndex);
        }
        gameObject.SetActive(true);
    }
}
public class UISequence : MonoBehaviour
{
    public bool promptEnd;

    public float startDelay = 0.25f;

    public float delayBetween = 0.2f;

    [Header("Tween In")]
    public float tweenInDur = 0.75f;

    public LeanTweenType tweenInEase = LeanTweenType.easeOutBack;

    [Header("Tween Out")]
    public float tweenOutDur = 0.25f;

    public LeanTweenType tweenOutEase = LeanTweenType.easeInBack;

    public Routine routine;

    public bool IsRunning => routine?.IsRunning ?? false;

    public void Begin()
    {
        if (IsRunning)
        {
            routine.Stop();
        }
        routine = new Routine(Run());
    }

    public virtual void End()
    {
        promptEnd = true;
    }

    public void EndIfRunning()
    {
        if (IsRunning)
        {
            End();
        }
    }

    public virtual IEnumerator Run()
    {
        return null;
    }
}
public class UnlockModifierSequence : MonoBehaviour
{
    [SerializeField]
    public ModifierIcon icon;

    public void Run(GameModifierData modifierData)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        icon.Set(modifierData, Vector2.zero);
        gameObject.SetActive(true);
    }
}
public class UIAnchor : MonoBehaviour
{
    public float revealDur = 0.75f;

    public float hideDur = 0.25f;

    [Header("Rotation")]
    public Vector3 angleStart = new Vector3(45f, 90f, 0f);

    public bool angleRandomSign = true;

    public LeanTweenType angleTweenEase = LeanTweenType.easeOutBack;

    [Header("Rotation Hide")]
    public Vector3 angleHide = new Vector3(45f, 90f, 0f);

    public bool angleHideRandomSign = true;

    public LeanTweenType angleHideTweenEase = LeanTweenType.easeInBack;

    [Header("Scale")]
    public Vector3 scaleStart = Vector3.one;

    public LeanTweenType scaleTweenEase = LeanTweenType.easeInQuart;

    [Header("Scale Hide")]
    public Vector3 scaleHide = Vector3.zero;

    public LeanTweenType scaleHideTweenEase = LeanTweenType.easeInBack;

    [Header("Wobble?")]
    public float wobbleAmount = 2f;

    [Header("Fade In?")]
    public bool doFadeIn = true;

    public float fadeInDur = 0.25f;

    public bool doFadeOut = true;

    public float fadeOutDur = 0.25f;

    public void SetUp()
    {
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        if (angleRandomSign)
        {
            transform.localEulerAngles = new Vector3(FloatExt.WithRandomSign(angleStart.x, 0.5f), FloatExt.WithRandomSign(angleStart.y, 0.5f), FloatExt.WithRandomSign(angleStart.z, 0.5f));
        }
        else
        {
            transform.localEulerAngles = angleStart;
        }
        transform.localScale = scaleStart;
        if (doFadeIn)
        {
            CanvasGroup component = GetComponent<CanvasGroup>();
            if (component != null)
            {
                component.alpha = 0f;
            }
        }
    }

    public void Reveal()
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ff: Unknown result type (might be due to invalid IL or missing references)
        //IL_010a: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(gameObject);
        Vector3 zero = Vector3.zero;
        if (transform.localEulerAngles != zero)
        {
            LeanTween.rotateLocal(gameObject, zero, revealDur).setEase(angleTweenEase);
        }
        Vector3 one = Vector3.one;
        if (transform.localScale != one)
        {
            LeanTween.scale(gameObject, one, revealDur).setEase(scaleTweenEase);
        }
        if (doFadeIn && fadeInDur > 0f)
        {
            CanvasGroup component = GetComponent<CanvasGroup>();
            if (component != null)
            {
                component.LeanAlpha(1f, fadeInDur).setEase(LeanTweenType.linear);
            }
        }
        if (wobbleAmount > 0f)
        {
            Vector3 val = -(transform.localEulerAngles / 90f) * wobbleAmount;
            ((Component)transform).GetComponentInChildren<Wobbler>()?.Wobble(new Vector3(val.y, val.x, 0f));
        }
    }

    public void UnReveal(float delay = 0f)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(gameObject);
        Vector3 val = angleHide;
        if (transform.localEulerAngles != val)
        {
            LeanTween.rotateLocal(gameObject, val, hideDur).setDelay(delay).setEase(angleHideTweenEase);
        }
        Vector3 val2 = scaleHide;
        if (transform.localScale != val2)
        {
            LeanTween.scale(gameObject, val2, hideDur).setDelay(delay).setEase(scaleHideTweenEase);
        }
        if (doFadeOut && fadeOutDur > 0f)
        {
            CanvasGroup component = GetComponent<CanvasGroup>();
            if (component != null)
            {
                component.LeanAlpha(0f, fadeOutDur).setDelay(delay).setEase(LeanTweenType.linear);
            }
        }
    }
}
public class UIAnchors : MonoBehaviour
{
    [Serializable]
    public class AnchorPoint
    {
        public UIAnchor target;

        public RectTransform anchor;

        public void Activate()
        {
            ((Component)target).gameObject.SetActive(true);
            ((Component)anchor).gameObject.SetActive(true);
        }

        public void Deactivate()
        {
            ((Component)target).gameObject.SetActive(false);
            ((Component)anchor).gameObject.SetActive(false);
        }

        public void SetUp()
        {
            target.SetUp();
        }

        public IEnumerator Move(float dur = 0.75f, LeanTweenType ease = LeanTweenType.easeOutBack)
        {
            LeanTween.move(((Component)target).gameObject, ((Transform)anchor).position, dur).setEase(ease);
            Vector3 movement = ((Transform)anchor).position - ((Component)target).transform.position;
            ((Component)target).GetComponentInChildren<Wobbler>()?.Wobble(movement);
            yield return Sequences.Wait(dur);
        }
    }

    public AnchorPoint[] list;

    public int Count => list.Length;

    public void Activate(int anchorIndex)
    {
        list[anchorIndex].Activate();
    }

    public void Deactivate(int anchorIndex)
    {
        list[anchorIndex].Deactivate();
    }

    public IEnumerator Reveal(int anchorIndex)
    {
        AnchorPoint obj = list[anchorIndex];
        UIAnchor target = obj.target;
        _ = obj.anchor;
        target.Reveal();
        yield return Sequences.Wait(target.revealDur);
    }

    public IEnumerator UnReveal(int anchorIndex, float delay = 0f)
    {
        UIAnchor target = list[anchorIndex].target;
        target.UnReveal(delay);
        yield return Sequences.Wait(target.hideDur + delay);
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void PromptUpdate()
    {
        StartCoroutine(UpdatePositions());
    }

    [Button(/*Could not decode attribute arguments.*/)]
    public void SetPositions()
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        AnchorPoint[] array = list;
        foreach (AnchorPoint anchorPoint in array)
        {
            ((Component)anchorPoint.target).transform.position = ((Component)anchorPoint.anchor).transform.position;
        }
    }

    public IEnumerator UpdatePositions()
    {
        List<Routine> routines = new List<Routine>();
        AnchorPoint[] array = list;
        foreach (AnchorPoint anchorPoint in array)
        {
            if (((Component)anchorPoint.target).gameObject.activeSelf)
            {
                routines.Add(new Routine(anchorPoint.Move()));
            }
        }
        bool routinesDone = false;
        while (!routinesDone)
        {
            routinesDone = true;
            foreach (Routine item in routines)
            {
                if (item != null && item.IsRunning)
                {
                    routinesDone = false;
                    break;
                }
            }
            yield return null;
        }
    }
}
[RequireComponent(typeof(TMP_Text))]
public class VersionNumber : MonoBehaviour
{
    [SerializeField]
    public bool showProfile;

    [SerializeField]
    public bool showVersion = true;

    public TMP_Text _t;

    public TMP_Text textElement => _t ?? (_t = GetComponent<TMP_Text>());

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnSaveSystemProfileChanged += new UnityAction(UpdateText);
        Events.OnModLoaded += ModStateChanged;
        Events.OnModUnloaded += ModStateChanged;
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnSaveSystemProfileChanged -= new UnityAction(UpdateText);
        Events.OnModLoaded -= ModStateChanged;
        Events.OnModUnloaded -= ModStateChanged;
    }

    public void Start()
    {
        UpdateText();
    }

    public void ModStateChanged(WildfrostMod mod)
    {
        UpdateText();
    }

    public void UpdateText()
    {
        string text = "";
        if (SaveSystem.Enabled && showProfile)
        {
            if (!StringExt.IsNullOrWhitespace(text))
            {
                text += "\n";
            }
            text = text + "Profile: " + SaveSystem.Profile;
        }
        if (showVersion)
        {
            if (!StringExt.IsNullOrWhitespace(text))
            {
                text += "\n";
            }
            text += string.Format(Config.data.versionFormat, Config.data.versionNotation);
        }
        WildfrostMod[] array = Bootstrap.Mods.Where((WildfrostMod a) => a.HasLoaded).ToArray();
        if (array.Length != 0)
        {
            text += "<#ff3><size=0.3>";
            WildfrostMod[] array2 = array;
            foreach (WildfrostMod wildfrostMod in array2)
            {
                text = text + "\n" + wildfrostMod.Title;
            }
        }
        textElement.text = text;
    }
}
public class WorldSpaceCanvasFitScreen : WorldSpaceCanvasUpdater
{
    [ReadOnly]
    public float width;

    [ReadOnly]
    public float height;

    [SerializeField]
    public float scale = 1f;

    [SerializeField]
    public AnimationCurve largeScaleCurve;

    [SerializeField]
    public Vector2 padding;

    public UnityEvent<RectTransform> onUpdate;

    public override void UpdateSize()
    {
        //IL_010b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0122: Unknown result type (might be due to invalid IL or missing references)
        if (!WorldSpaceCanvasFitScreenSystem.exists)
        {
            return;
        }
        if (WorldSpaceCanvasFitScreenSystem.instance.cam.orthographic)
        {
            height = WorldSpaceCanvasFitScreenSystem.instance.cam.orthographicSize * 2f;
            width = height * WorldSpaceCanvasFitScreenSystem.instance.aspectRatio;
        }
        else
        {
            height = 11.547f;
            width = height * WorldSpaceCanvasFitScreenSystem.instance.aspectRatio;
        }
        float num;
        if (width < 17.32051f)
        {
            num = width / 17.32051f * scale;
            width = 17.32051f;
            height = width / 1.5f;
        }
        else
        {
            if (width > 26.943f)
            {
                width = 26.943f;
            }
            AnimationCurve val = largeScaleCurve;
            if (val != null)
            {
                _ = val.length;
                _ = 0;
            }
            num = scale;
        }
        base.rectTransform.sizeDelta = new Vector2(width - padding.x, height - padding.y);
        ((Transform)base.rectTransform).localScale = new Vector3(num, num, 1f);
        onUpdate?.Invoke(base.rectTransform);
    }
}
public class WorldSpaceCanvasSafeArea : WorldSpaceCanvasUpdater
{
    [SerializeField]
    public RectTransform parent;

    [SerializeField]
    public bool considerX = true;

    [SerializeField]
    public bool considerY;

    public bool waitForParent;

    public void LateUpdate()
    {
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_0120: Unknown result type (might be due to invalid IL or missing references)
        //IL_0129: Unknown result type (might be due to invalid IL or missing references)
        //IL_0177: Unknown result type (might be due to invalid IL or missing references)
        //IL_017c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0144: Unknown result type (might be due to invalid IL or missing references)
        //IL_01eb: Unknown result type (might be due to invalid IL or missing references)
        //IL_01f3: Unknown result type (might be due to invalid IL or missing references)
        //IL_01fc: Unknown result type (might be due to invalid IL or missing references)
        //IL_020c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0214: Unknown result type (might be due to invalid IL or missing references)
        //IL_021c: Unknown result type (might be due to invalid IL or missing references)
        //IL_018e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0193: Unknown result type (might be due to invalid IL or missing references)
        //IL_01a5: Unknown result type (might be due to invalid IL or missing references)
        //IL_01ad: Unknown result type (might be due to invalid IL or missing references)
        //IL_01b5: Unknown result type (might be due to invalid IL or missing references)
        //IL_01c5: Unknown result type (might be due to invalid IL or missing references)
        //IL_01cf: Unknown result type (might be due to invalid IL or missing references)
        //IL_01d9: Unknown result type (might be due to invalid IL or missing references)
        if (waitForParent && ((Component)parent).gameObject.activeSelf && WorldSpaceCanvasFitScreenSystem.exists)
        {
            Vector2 sizeDelta = parent.sizeDelta;
            float num = (considerX ? ((WorldSpaceCanvasFitScreenSystem.instance.safeArea)).x : 0f);
            float num2 = (considerY ? ((WorldSpaceCanvasFitScreenSystem.instance.safeArea)).y : 0f);
            float num3 = (considerX ? ((WorldSpaceCanvasFitScreenSystem.instance.safeArea)).width : 1f);
            float num4 = (considerY ? ((WorldSpaceCanvasFitScreenSystem.instance.safeArea)).height : 1f);
            float num5 = (considerX ? (1f - ((WorldSpaceCanvasFitScreenSystem.instance.safeArea)).width - ((WorldSpaceCanvasFitScreenSystem.instance.safeArea)).x) : 0f);
            float num6 = (considerY ? (1f - ((WorldSpaceCanvasFitScreenSystem.instance.safeArea)).height - ((WorldSpaceCanvasFitScreenSystem.instance.safeArea)).y) : 0f);
            float num7 = num3 * sizeDelta.x;
            float num8 = num4 * sizeDelta.y;
            if (num7 / num8 < 1.5f)
            {
                float num9 = num8 * 1.5f / sizeDelta.x;
                float num10 = num9 - num3;
                num = Mathf.Max(0f, num - num10);
                num5 = Mathf.Max(0f, num5 - num10);
                num3 = num9;
            }
            if (base.rectTransform.anchorMin == Vector2.zero && base.rectTransform.anchorMax == Vector2.one)
            {
                base.rectTransform.offsetMin = new Vector2(sizeDelta.x * num, sizeDelta.y * num2);
                base.rectTransform.offsetMax = new Vector2(sizeDelta.x * (0f - num5), sizeDelta.y * (0f - num6));
            }
            else
            {
                base.rectTransform.sizeDelta = new Vector2(sizeDelta.x * num3, sizeDelta.y * num4);
                base.rectTransform.anchoredPosition = new Vector2(sizeDelta.x * num, sizeDelta.y * num2);
            }
            waitForParent = false;
        }
    }

    public override void UpdateSize()
    {
        waitForParent = true;
    }
}
public class WorldSpaceCanvasScaler : WorldSpaceCanvasUpdater
{
    [SerializeField]
    public bool invert;

    [Header("Position")]
    [SerializeField]
    public bool scalePositionX;

    [SerializeField]
    [ShowIf("scalePositionX")]
    public float basePositionX;

    [SerializeField]
    public bool scalePositionY;

    [SerializeField]
    [ShowIf("scalePositionY")]
    public float basePositionY;

    [SerializeField]
    public bool scalePositionZ;

    [SerializeField]
    [ShowIf("scalePositionZ")]
    public float basePositionZ;

    [Header("Scale")]
    [SerializeField]
    public bool scaleX = true;

    [SerializeField]
    [ShowIf("scaleX")]
    public float baseScaleX = 1f;

    [SerializeField]
    public bool scaleY = true;

    [SerializeField]
    [ShowIf("scaleY")]
    public float baseScaleY = 1f;

    [SerializeField]
    public bool scaleZ;

    [SerializeField]
    [ShowIf("scaleZ")]
    public float baseScaleZ = 1f;

    public override void UpdateSize()
    {
        if (WorldSpaceCanvasFitScreenSystem.exists)
        {
            float num = 11.547f * WorldSpaceCanvasFitScreenSystem.instance.aspectRatio;
            float num2 = ((num < 17.32051f) ? (num / 17.32051f) : 1f);
            if (scalePositionX || scalePositionY || scalePositionZ)
            {
                SetPosition(num2);
            }
            if (scaleX || scaleY || scaleZ)
            {
                SetScale(num2);
            }
        }
    }

    public void SetPosition(float scale)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        Vector3 anchoredPosition3D = base.rectTransform.anchoredPosition3D;
        if (scalePositionX)
        {
            anchoredPosition3D.x = (invert ? (basePositionX / scale) : (basePositionX * scale));
        }
        if (scalePositionY)
        {
            anchoredPosition3D.y = (invert ? (basePositionY / scale) : (basePositionY * scale));
        }
        if (scalePositionZ)
        {
            anchoredPosition3D.z = (invert ? (basePositionZ / scale) : (basePositionZ * scale));
        }
        base.rectTransform.anchoredPosition3D = anchoredPosition3D;
    }

    public void SetScale(float scale)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        Vector3 localScale = ((Transform)base.rectTransform).localScale;
        if (scaleX)
        {
            localScale.x = (invert ? (baseScaleX / scale) : (baseScaleX * scale));
        }
        if (scaleY)
        {
            localScale.y = (invert ? (baseScaleY / scale) : (baseScaleY * scale));
        }
        if (scaleZ)
        {
            localScale.z = (invert ? (baseScaleZ / scale) : (baseScaleZ * scale));
        }
        ((Transform)base.rectTransform).localScale = localScale;
    }
}
public abstract class WorldSpaceCanvasUpdater : MonoBehaviourRect
{
    public void OnEnable()
    {
        WorldSpaceCanvasFitScreenSystem.Register(this);
        UpdateSize();
    }

    public void OnDisable()
    {
        WorldSpaceCanvasFitScreenSystem.Unregister(this);
    }

    public virtual void UpdateSize()
    {
    }

    public WorldSpaceCanvasUpdater()
    {
    }
}
public class VersionCompatibility : MonoBehaviour
{
    public readonly struct Profile
    {
        public readonly string name;

        public readonly int versionFrom;

        public readonly int versionTo;

        public readonly int incompatibleWithFrom;

        public readonly int incompatibleWithTo;

        public readonly System.Action action;

        public Profile(string name, string version, string incompatibleWith, System.Action action)
        {
            this.name = name;
            ProcessVersionString(version, out versionFrom, out versionTo);
            ProcessVersionString(incompatibleWith, out incompatibleWithFrom, out incompatibleWithTo);
            this.action = action;
        }

        public static void ProcessVersionString(string @in, out int lower, out int higher)
        {
            string[] array = @in.Split(new char[1] { '-' }, StringSplitOptions.RemoveEmptyEntries);
            if (array.Length == 2)
            {
                int.TryParse(array[0], out lower);
                int.TryParse(array[1], out higher);
            }
            else
            {
                int.TryParse(@in.Replace("+", ""), out lower);
                higher = (@in.EndsWith("+") ? 99999 : lower);
            }
        }

        public static bool InRange(int x, int a, int b)
        {
            if (a <= x)
            {
                return x <= b;
            }
            return false;
        }

        public void Check(string currentVersion, string previousVersion)
        {
            if (int.TryParse(previousVersion, out var result) && InRange(result, incompatibleWithFrom, incompatibleWithTo) && int.TryParse(currentVersion, out var result2) && InRange(result2, versionFrom, versionTo))
            {
                Debug.Log(("Version [" + currentVersion + "] incompatible with [" + previousVersion + "] running [" + name + "] Script"));
                action();
            }
        }
    }

    public static bool versionsGot;

    public static string previousVersion;

    public static string currentVersion;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnGameStart += new UnityAction(GameStart);
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnGameStart -= new UnityAction(GameStart);
    }

    public static void GetVersions()
    {
        if (!versionsGot)
        {
            currentVersion = Config.data.version;
            previousVersion = SaveSystem.LoadProgressData("version", "0");
        }
    }

    public static void GameStart()
    {
        GetVersions();
        if (currentVersion != previousVersion)
        {
            Debug.Log(("Checking Version Compatibility [" + previousVersion + "] → [" + currentVersion + "]"));
            foreach (Profile item in new List<Profile>
            {
                new Profile("Reset Progress", "63+", "0-62", ResetProgress),
                new Profile("Reset Town Progress", "88+", "0-87", ResetTownProgress),
                new Profile("Delete Campaign Save", "135+", "0-134", DeleteCampaignSave),
                new Profile("Reset Progress", "153+", "0-152", DeleteDefaultProfile),
                new Profile("Create Beta Profile", "175", "0-174", CreateBetaProfile),
                new Profile("Copy Beta Profile", "177+", "175-176", CopyBetaProfile),
                new Profile("Copy Beta Profile", "187+", "179-186", CopyBetaProfile)
            })
            {
                item.Check(currentVersion, previousVersion);
            }
            SaveSystem.SaveProgressData("version", currentVersion);
        }
        ProgressSaveData progressSaveData = SaveSystem.LoadProgressData<ProgressSaveData>("progress");
        if (progressSaveData != null)
        {
            Debug.Log("VersionCompatibility → Converting ProgressSaveData");
            ConvertProgressSaveData(progressSaveData);
        }
    }

    public static void CreateBetaProfile()
    {
        string folderName = SaveSystem.folderName;
        string text = SaveSystem.profileFolder + "/Beta";
        ES3.CopyDirectory(folderName, text, SaveSystem.settings, SaveSystem.settings);
    }

    public static void CopyBetaProfile()
    {
        if (ES3.DirectoryExists(SaveSystem.profileFolder + "/Beta") && ES3.FileExists(SaveSystem.profileFolder + "/Beta/Save.sav") && SaveSystem.gotSaveTimestamp)
        {
            DateTime timestamp = ES3.GetTimestamp(SaveSystem.profileFolder + "/Beta/Save.sav", SaveSystem.settings);
            if (timestamp > SaveSystem.saveTimestamp)
            {
                Debug.Log($"Beta Save Timestamp: {timestamp}, Default: {SaveSystem.saveTimestamp}, Copying Beta Save to Default");
                CopyFileFromBetaProfile("Save.sav");
                CopyFileFromBetaProfile("Stats.sav");
                CopyFileFromBetaProfile("Campaign.sav");
                CopyFileFromBetaProfile("CampaignDaily.sav");
                CopyFileFromBetaProfile("CampaignTutorial.sav");
                CopyFileFromBetaProfile("History.sav");
            }
            else
            {
                Debug.Log($"Beta Save Timestamp: {timestamp}, Default: {SaveSystem.saveTimestamp}, Default is more recent, deleting Beta profile");
            }
            ES3.DeleteDirectory(SaveSystem.profileFolder + "/Beta");
        }
    }

    public static void CopyFileFromBetaProfile(string fileName)
    {
        CopyFileData(SaveSystem.profileFolder + "/Beta/" + fileName, SaveSystem.folderName + "/" + fileName, SaveSystem.settings);
    }

    public static void CopyFileData(string fromPath, string toPath, ES3Settings settings)
    {
        if (ES3.FileExists(fromPath, settings))
        {
            ES3.SaveRaw(ES3.LoadRawString(fromPath, settings), toPath, settings);
        }
    }

    public static void DeleteDefaultProfile()
    {
        SaveSystem.DeleteProfile("Default");
    }

    public static void ResetProgress()
    {
        if (SaveSystem.ProgressExists())
        {
            ProgressSaveData progressSaveData = SaveSystem.LoadProgressData<ProgressSaveData>("progress");
            SaveSystem.DeleteProgress();
            if (progressSaveData != null)
            {
                SaveSystem.SaveProgressData("progress", progressSaveData);
            }
        }
    }

    public static void ResetTownProgress()
    {
        if (SaveSystem.ProgressExists())
        {
            SaveSystem.DeleteProgressData("townProgress");
            SaveSystem.DeleteProgressData("unlocked");
            SaveSystem.DeleteProgressData("townNew");
            SaveSystem.DeleteProgressData("finalBoss");
            SaveSystem.DeleteProgressData("finalBossEnemies");
            SaveSystem.DeleteProgressData("petHutUnlocks");
            SaveSystem.DeleteProgressData("inventorHutUnlocks");
            SaveSystem.DeleteProgressData("hotSpringUnlocks");
            SaveSystem.DeleteProgressData("completedChallenges");
            SaveSystem.DeleteProgressData("challengeProgress");
        }
    }

    public static void ConvertProgressSaveData(ProgressSaveData data)
    {
        SaveSystem.SaveProgressData("nextSeed", data.nextSeed);
        SaveSystem.SaveProgressData("tutorialProgress", data.tutorialProgress);
        SaveSystem.SaveProgressData("tutorialCharmDone", data.tutorialCharmDone);
        SaveSystem.SaveProgressData("tutorialInjuryDone", data.tutorialInjuryDone);
        SaveSystem.DeleteProgressData("progress");
    }

    public static void DeleteCampaignSave()
    {
        SaveSystem.DeleteCampaign(AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal"));
    }
}
public class WaveDeployerDots : MonoBehaviour
{
    [SerializeField]
    public float fanRadius = 0.5f;

    [SerializeField]
    public float startAngle = -90f;

    [SerializeField]
    public float arcMax = 90f;

    [SerializeField]
    public float arcGap = 20f;

    public List<WaveDot> dots;

    [SerializeField]
    public Transform dotContainer;

    [SerializeField]
    public WaveDot dotPrefab;

    [SerializeField]
    public WaveDot bigDotPrefab;

    public void Init(BattleWaveManager waveManager, int currentWaveIndex)
    {
        foreach (WaveDot dot in dots)
        {
            GameObjectExt.Destroy(((Component)dot).gameObject);
        }
        dots = new List<WaveDot>();
        foreach (BattleWaveManager.Wave item in waveManager.list)
        {
            WaveDot waveDot = Object.Instantiate<WaveDot>(item.isBossWave ? bigDotPrefab : dotPrefab, dotContainer);
            ((Component)waveDot).gameObject.SetActive(true);
            dots.Add(waveDot);
        }
        SetPositions();
        UpdateDots(waveManager, currentWaveIndex);
    }

    public void UpdateDots(BattleWaveManager waveManager, int currentWaveIndex)
    {
        for (int i = 0; i < dots.Count; i++)
        {
            if (waveManager.list[i].spawned && currentWaveIndex != i)
            {
                dots[i].TurnOff();
            }
        }
    }

    public void SetPositions()
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        for (int i = 0; i < dots.Count; i++)
        {
            ((Component)dots[i]).transform.localPosition = GetPosition(i);
        }
    }

    public Vector3 GetPosition(int index)
    {
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        float radians = (GetAngle(index) + startAngle) * ((float)Math.PI / 180f);
        return (Lengthdir.ToVector2(fanRadius, radians));
    }

    public float GetAngle(int index)
    {
        float angleAdd = GetAngleAdd();
        return (0f - angleAdd) * (float)(dots.Count - 1) * 0.5f + angleAdd * (float)index;
    }

    public float GetAngleAdd()
    {
        int num = dots.Count - 1;
        return Mathf.Min((float)num * arcGap, arcMax) / (float)num;
    }
}
public class WaveDot : MonoBehaviour
{
    [SerializeField]
    public Image onImage;

    [SerializeField]
    public Image offImage;

    public void TurnOn()
    {
        ((Behaviour)onImage).enabled = true;
        ((Behaviour)offImage).enabled = false;
    }

    public void TurnOff()
    {
        ((Behaviour)onImage).enabled = false;
        ((Behaviour)offImage).enabled = true;
    }
}
public class WhenDisabled : MonoBehaviour
{
    [SerializeField]
    public UnityEvent action;

    public void OnDisable()
    {
        UnityEvent obj = action;
        if (obj != null)
        {
            obj.Invoke();
        }
    }
}
public class WhenEnabled : MonoBehaviour
{
    [SerializeField]
    public UnityEvent action;

    public void OnEnable()
    {
        UnityEvent obj = action;
        if (obj != null)
        {
            obj.Invoke();
        }
    }
}
public class WinMusic : MonoBehaviour
{
    [SerializeField]
    public bool playOnStart = true;

    [SerializeField]
    public EventReference musicEvent;

    public EventInstance current;

    public void OnEnable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBackToMainMenu += new UnityAction(BackToMainMenu);
        Events.OnSceneChanged += SceneChanged;
    }

    public void OnDisable()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBackToMainMenu -= new UnityAction(BackToMainMenu);
        Events.OnSceneChanged -= SceneChanged;
    }

    public void Start()
    {
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        if (playOnStart && !(References.Battle.winner != References.Battle.player))
        {
            StartMusic(musicEvent.Guid);
        }
    }

    public void BackToMainMenu()
    {
        SetEndParam();
    }

    public void SceneChanged(Scene scene)
    {
        SetEndParam();
    }

    public void Play()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        StartMusic(musicEvent.Guid);
    }

    public void StartMusic(GUID eventGUID)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Expected O, but got Unknown
        try
        {
            current = RuntimeManager.CreateInstance(eventGUID);
            ((current)).start();
        }
        catch (EventNotFoundException val)
        {
            Debug.LogWarning(val);
        }
    }

    public void SetEndParam()
    {
        SetParam("final_win", 1f);
    }

    public void SetParam(string name, float value)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        if (IsRunning())
        {
            ((current)).setParameterByName(name, value, false);
        }
    }

    public bool IsRunning()
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Invalid comparison between Unknown and I4
        if (((current)).isValid())
        {
            PLAYBACK_STATE val = default(PLAYBACK_STATE);
            ((current)).getPlaybackState(ref val);
            if ((int)val != 2)
            {
                return true;
            }
        }
        return false;
    }
}
public class WispAnimator : MonoBehaviourCacheTransform
{
    public float knockback = 8f;

    public float gravitate = 5f;

    public float maxSpeed = 2f;

    public ParticleSystem smokeFx;

    public SpriteRenderer sprite;

    public SpriteRenderer faceSprite;

    public ParticleSystem pingPS;

    public Vector3 velocity = Vector3.zero;

    public Transform target;

    public void KnockBackFrom(Vector3 from)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3Ext.WithZ(base.transform.position - from, 0f);
        Vector3 normalized = ((val)).normalized;
        velocity = normalized * knockback;
    }

    public void SetTarget(Transform target)
    {
        this.target = target;
    }

    public bool TargetExists()
    {
        return (target);
    }

    public void JumpToTarget()
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        pingPS.Play();
        LeanTween.move(gameObject, target.position, 1f).setEaseInBack();
    }

    public void FadeToColour(Color color, float delay, float duration)
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Expected O, but got Unknown
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        Color color2 = sprite.color;
        Gradient val = new Gradient();
        val.alphaKeys = (GradientAlphaKey[])(object)new GradientAlphaKey[1]
        {
            new GradientAlphaKey(1f, 0f)
        };
        val.colorKeys = (GradientColorKey[])(object)new GradientColorKey[2]
        {
            new GradientColorKey(color2, 0f),
            new GradientColorKey(color, 1f)
        };
        Gradient gradient = val;
        LeanTween.value(gameObject, 0f, 1f, duration).setDelay(delay).setOnUpdate(delegate (float a)
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0018: Unknown result type (might be due to invalid IL or missing references)
            //IL_0029: Unknown result type (might be due to invalid IL or missing references)
            //IL_002e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0031: Unknown result type (might be due to invalid IL or missing references)
            //IL_0032: Unknown result type (might be due to invalid IL or missing references)
            Color val2 = gradient.Evaluate(a);
            sprite.color = val2;
            MainModule main = smokeFx.main;
            ((main)).startColor = MinMaxGradient.op_Implicit(val2);
        });
    }

    public void SetSortingLayer(string layerName, int orderInLayer)
    {
        ((Component)smokeFx).GetComponent<Renderer>().sortingLayerName = layerName;
        ((Component)smokeFx).GetComponent<Renderer>().sortingOrder = orderInLayer;
        ((Renderer)sprite).sortingLayerName = layerName;
        ((Renderer)sprite).sortingOrder = orderInLayer + 1;
        ((Renderer)faceSprite).sortingLayerName = layerName;
        ((Renderer)faceSprite).sortingOrder = orderInLayer + 2;
    }

    public void Update()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_007c: Unknown result type (might be due to invalid IL or missing references)
        //IL_007f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        //IL_0091: Unknown result type (might be due to invalid IL or missing references)
        //IL_0096: Unknown result type (might be due to invalid IL or missing references)
        Transform obj = base.transform;
        obj.position += velocity * Time.deltaTime;
        Vector3 val;
        if (maxSpeed == 0f)
        {
            val = Vector3.zero;
        }
        else if (!(target))
        {
            val = Vector3.zero;
        }
        else
        {
            Vector3 val2 = target.position - base.transform.position;
            val = ((val2)).normalized * maxSpeed;
        }
        Vector3 val3 = val;
        velocity = Vector3.MoveTowards(velocity, val3, gravitate * Time.deltaTime);
    }
}
public class Wobbler : MonoBehaviourCacheTransform, IPoolable
{
    public Vector3 rotationInfluence = new Vector3(10f, 10f, 2f);

    public Vector3 rotationMax = new Vector3(50f, 50f, 50f);

    public Vector3 rotationDamping = new Vector3(0.91f, 0.93f, 0.94f);

    public Vector3 rotationAcc = new Vector3(1f, 0.8f, 0.7f);

    public Vector3 rotation;

    public Vector3 rotationVelocity;

    public void Update()
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0076: Unknown result type (might be due to invalid IL or missing references)
        rotationVelocity -= Vector3.Scale(rotation, rotationAcc) * Time.deltaTime;
        rotationVelocity = Delta.Multiply(rotationVelocity, rotationDamping, Time.deltaTime);
        rotation += rotationVelocity * (200f * Time.deltaTime);
        base.transform.localEulerAngles = rotation;
    }

    public void Wobble(Vector3 movement)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3.Scale(new Vector3(movement.y, 0f - movement.x, 0f - movement.x), rotationInfluence);
        rotation = Vector3Ext.Clamp(rotation + val, -rotationMax, rotationMax);
    }

    public void WobbleRandom(float wobbleFactor = 1f)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        Wobble((PettyRandom.Vector2() * wobbleFactor));
    }

    public void OnGetFromPool()
    {
    }

    public void OnReturnToPool()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        rotation = Vector3.zero;
        rotationVelocity = Vector3.zero;
        base.transform.localScale = Vector3.one;
    }
}
public static class CharacterExt
{
    public static void OrderNextCards(this Character character, string[] nextCardNames)
    {
        CardContainer drawContainer = character.drawContainer;
        List<Entity> list = new List<Entity>();
        foreach (string cardName in nextCardNames)
        {
            Entity entity = drawContainer.FirstOrDefault((Entity a) => (a).name == cardName);
            if (entity != null)
            {
                list.Insert(0, entity);
                drawContainer.Remove(entity);
            }
        }
        foreach (Entity item in list)
        {
            drawContainer.Add(item);
        }
        drawContainer.TweenChildPositions();
    }
}
public static class DictionaryExt
{
    public static T[] GetSaveCollection<T>(this Dictionary<string, object> dict, string key)
    {
        return ((SaveCollection<T>)dict[key]).collection;
    }
}
public static class EntityExt
{
    public static Vector3 GetContainerWorldPosition(this Entity entity)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3.zero;
        if (entity.actualContainers.Count > 0)
        {
            foreach (CardContainer actualContainer in entity.actualContainers)
            {
                val += ((Transform)actualContainer.holder).position + actualContainer.GetChildPosition(entity);
            }
            val /= (float)entity.actualContainers.Count;
        }
        return val;
    }

    public static Vector3 GetContainerLocalPosition(this Entity entity)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_009a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0077: Unknown result type (might be due to invalid IL or missing references)
        //IL_007c: Unknown result type (might be due to invalid IL or missing references)
        //IL_007d: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0094: Unknown result type (might be due to invalid IL or missing references)
        //IL_0099: Unknown result type (might be due to invalid IL or missing references)
        Vector3 result = Vector3.zero;
        if (entity.actualContainers.Count > 0)
        {
            Vector3 val = Vector3.zero;
            foreach (CardContainer actualContainer in entity.actualContainers)
            {
                val += ((Transform)actualContainer.holder).position + actualContainer.GetChildPosition(entity);
            }
            val /= (float)entity.actualContainers.Count;
            result = val - ((Transform)entity.actualContainers[0].holder).position;
        }
        return result;
    }

    public static Vector3 GetContainerWorldRotation(this Entity entity)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0081: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_0076: Unknown result type (might be due to invalid IL or missing references)
        //IL_007b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3.zero;
        if (entity.actualContainers.Count > 0)
        {
            foreach (CardContainer actualContainer in entity.actualContainers)
            {
                val += actualContainer.GetChildRotation(entity);
            }
            val /= (float)entity.actualContainers.Count;
            val += ((Transform)entity.actualContainers[0].holder).eulerAngles;
        }
        return val;
    }

    public static Vector3 GetContainerLocalRotation(this Entity entity)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3.zero;
        if (entity.actualContainers.Count > 0)
        {
            foreach (CardContainer actualContainer in entity.actualContainers)
            {
                val += actualContainer.GetChildRotation(entity);
            }
            val /= (float)entity.actualContainers.Count;
        }
        return val;
    }

    public static Vector3 GetContainerScale(this Entity entity)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = Vector3.zero;
        if (entity.actualContainers.Count > 0)
        {
            foreach (CardContainer actualContainer in entity.actualContainers)
            {
                val += actualContainer.GetChildScale(entity);
            }
            val /= (float)entity.actualContainers.Count;
        }
        return val;
    }

    public static void TweenToContainer(this Entity entity)
    {
        //IL_0159: Unknown result type (might be due to invalid IL or missing references)
        //IL_015e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0162: Unknown result type (might be due to invalid IL or missing references)
        //IL_0167: Unknown result type (might be due to invalid IL or missing references)
        //IL_016b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0170: Unknown result type (might be due to invalid IL or missing references)
        //IL_0183: Unknown result type (might be due to invalid IL or missing references)
        //IL_0186: Unknown result type (might be due to invalid IL or missing references)
        //IL_01a7: Unknown result type (might be due to invalid IL or missing references)
        //IL_01aa: Unknown result type (might be due to invalid IL or missing references)
        //IL_01cb: Unknown result type (might be due to invalid IL or missing references)
        //IL_01ce: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0052: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        //IL_006f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_0081: Unknown result type (might be due to invalid IL or missing references)
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        //IL_008b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ab: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ae: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bc: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ce: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00da: Unknown result type (might be due to invalid IL or missing references)
        //IL_00df: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f4: Unknown result type (might be due to invalid IL or missing references)
        //IL_0115: Unknown result type (might be due to invalid IL or missing references)
        //IL_0117: Unknown result type (might be due to invalid IL or missing references)
        //IL_0138: Unknown result type (might be due to invalid IL or missing references)
        //IL_013b: Unknown result type (might be due to invalid IL or missing references)
        int count = entity.actualContainers.Count;
        if (count <= 0)
        {
            return;
        }
        CardContainer cardContainer = entity.actualContainers[0];
        if (count > 1)
        {
            Vector3 val = Vector3.zero;
            Vector3 val2 = Vector3.zero;
            Vector3 val3 = Vector3.zero;
            foreach (CardContainer actualContainer in entity.actualContainers)
            {
                val += actualContainer.GetChildScale(entity);
                val2 += actualContainer.GetChildRotation(entity);
                val3 += ((Transform)actualContainer.holder).position + actualContainer.GetChildPosition(entity);
            }
            val /= (float)count;
            val2 /= (float)count;
            val3 /= (float)count;
            Vector3 to = ((Transform)cardContainer.holder).InverseTransformPoint(val3) * -1f;
            LeanTween.cancel(((Component)entity).gameObject);
            LeanTween.scale(((Component)entity).gameObject, val, Vector2Ext.PettyRandom(cardContainer.scaleDurRand)).setEase(cardContainer.scaleEase);
            LeanTween.rotateLocal(((Component)entity).gameObject, val2, Vector2Ext.PettyRandom(cardContainer.movementDurRand)).setEase(cardContainer.movementEase);
            LeanTween.moveLocal(((Component)entity).gameObject, to, Vector2Ext.PettyRandom(cardContainer.movementDurRand)).setEase(cardContainer.movementEase);
        }
        else
        {
            Vector3 childScale = cardContainer.GetChildScale(entity);
            Vector3 childRotation = cardContainer.GetChildRotation(entity);
            Vector3 childPosition = cardContainer.GetChildPosition(entity);
            LeanTween.cancel(((Component)entity).gameObject);
            LeanTween.scale(((Component)entity).gameObject, childScale, Vector2Ext.PettyRandom(cardContainer.scaleDurRand)).setEase(cardContainer.scaleEase);
            LeanTween.rotateLocal(((Component)entity).gameObject, childRotation, Vector2Ext.PettyRandom(cardContainer.movementDurRand)).setEase(cardContainer.movementEase);
            LeanTween.moveLocal(((Component)entity).gameObject, childPosition, Vector2Ext.PettyRandom(cardContainer.movementDurRand)).setEase(cardContainer.movementEase);
        }
    }

    public static void ForceUnHover(this Entity entity)
    {
        EntityDisplay display = entity.display;
        if (display is Card)
        {
            CardHover hover = display.hover;
            if (hover != null)
            {
                hover.OnPointerExit(null);
                hover.ForceUnHover();
            }
        }
    }

    public static bool IsOffensive(this Entity entity)
    {
        bool flag = entity.HasAttackIcon() || entity.data.original.damage > 0;
        if (!flag && entity.attackEffects.Any((CardData.StatusEffectStacks s) => s.data.offensive))
        {
            flag = true;
        }
        if (!flag && entity.statusEffects.Any((StatusEffectData s) => s.makesOffensive))
        {
            flag = true;
        }
        return flag;
    }

    public static bool CanRecall(this Entity entity)
    {
        if (entity.data.cardType.canRecall && entity.blockRecall <= 0 && (References.Battle))
        {
            return Battle.IsOnBoard(entity);
        }
        return false;
    }

    public static bool StillExists(this Entity entity)
    {
        if ((entity))
        {
            return !entity.inCardPool;
        }
        return false;
    }

    public static bool IsAliveAndExists(this Entity entity)
    {
        if ((entity) && !entity.inCardPool)
        {
            return entity.alive;
        }
        return false;
    }

    public static bool HasAnyCharms(this Entity entity)
    {
        if (entity.data.upgrades != null)
        {
            return entity.data.upgrades.Any((CardUpgradeData a) => a.type == CardUpgradeData.Type.Charm);
        }
        return false;
    }

    public static void ResetWhenHealthLostEffects(this Entity target)
    {
        foreach (StatusEffectData statusEffect in target.statusEffects)
        {
            if (statusEffect is StatusEffectApplyXWhenHealthLost statusEffectApplyXWhenHealthLost)
            {
                statusEffectApplyXWhenHealthLost.currentHealth = target.hp.current;
            }
        }
    }

    public static HashSet<KeywordData> GetHiddenKeywords(this Entity entity)
    {
        HashSet<KeywordData> hashSet = new HashSet<KeywordData>();
        foreach (CardData.StatusEffectStacks attackEffect in entity.attackEffects)
        {
            KeywordData[] hiddenKeywords = attackEffect.data.hiddenKeywords;
            foreach (KeywordData item in hiddenKeywords)
            {
                hashSet.Add(item);
            }
        }
        foreach (StatusEffectData statusEffect in entity.statusEffects)
        {
            KeywordData[] hiddenKeywords = statusEffect.hiddenKeywords;
            foreach (KeywordData item2 in hiddenKeywords)
            {
                hashSet.Add(item2);
            }
        }
        return hashSet;
    }

    public static bool HasAttackIcon(this Entity entity)
    {
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        if (entity.damage.max <= 0 && !(entity.damage.current + entity.tempDamage > 0))
        {
            if ((entity.data))
            {
                return entity.data.hasAttack;
            }
            return false;
        }
        return true;
    }
}
public static class IListExt
{
    public static SaveCollection<string> ToSaveCollectionOfNames<T>(this IList<T> list) where T : Object
    {
        return new SaveCollection<string>(IListExt.ToArrayOfNames<T>((IEnumerable<T>)list));
    }

    public static void DestroyAllAndClear(this IList<GameObject> list)
    {
        foreach (GameObject item in list)
        {
            GameObjectExt.Destroy(item);
        }
        list.Clear();
    }
}
public static class ILoadableExt
{
    public static T[] LoadArray<T, TSaveData>(this TSaveData[] data) where TSaveData : ILoadable<T>
    {
        return data.LoadList<T, TSaveData>().ToArray();
    }

    public static List<T> LoadList<T, TSaveData>(this TSaveData[] data) where TSaveData : ILoadable<T>
    {
        List<T> list = new List<T>();
        for (int i = 0; i < data.Length; i++)
        {
            TSaveData val = data[i];
            IListExt.AddIfNotNull<T>((IList<T>)list, val.Load());
        }
        return list;
    }
}
public static class ISaveableExt
{
    public static D[] SaveArray<S, D>(this IEnumerable<S> list) where S : ISaveable<D>
    {
        return list.Select((S a) => a.Save()).ToArray();
    }

    public static D[] SaveArray<S, D>(this S[] array) where S : ISaveable<D>
    {
        return array.Select((S a) => a.Save()).ToArray();
    }
}
[Serializable]
public class UnityEventInt : UnityEvent<int>
{
}
[Serializable]
public class UnityEventIntInt : UnityEvent<int, int>
{
}
[Serializable]
public class UnityEventStatStat : UnityEvent<Stat, Stat>
{
}
[Serializable]
public class UnityEventEntity : UnityEvent<Entity>
{
}
[Serializable]
public class UnityEventGameObject : UnityEvent<GameObject>
{
}
public enum ButtonType
{
    Normal,
    Sub,
    Back,
    Building,
    Bell
}
public enum DeathType
{
    Normal,
    Sacrifice,
    Consume,
    Eaten
}
public enum SceneType
{
    Persistent,
    Active,
    Temporary
}
public class AddressableGroup<T> : IEnumerable<T>, IEnumerable, IDisposable where T : Object
{
    public readonly List<AsyncOperationHandle<T>> handles;

    public bool subbed;

    public AddressableGroup(params AssetReferenceT<T>[] assetRefs)
    {
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        handles = new List<AsyncOperationHandle<T>>();
        foreach (AssetReferenceT<T> val in assetRefs)
        {
            handles.Add(val.LoadAssetAsync());
        }
    }

    public void WaitForCompletion()
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        foreach (AsyncOperationHandle<T> handle in handles)
        {
            handle.WaitForCompletion();
        }
    }

    public void Dispose()
    {
        Release();
        if (subbed)
        {
            Events.OnSceneChanged -= SceneChanged;
        }
    }

    public void DisposeOnSceneChange()
    {
        Events.OnSceneChanged += SceneChanged;
        subbed = true;
    }

    public void SceneChanged(Scene scene)
    {
        Dispose();
    }

    public void Release()
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        foreach (AsyncOperationHandle<T> handle in handles)
        {
            Addressables.Release<T>(handle);
        }
    }

    public IEnumerator<T> GetEnumerator()
    {
        return handles.Select(delegate (AsyncOperationHandle<T> a)
        {
            a.WaitForCompletion();
            return a.Result;
        }).GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return handles.GetEnumerator();
    }
}
[Serializable]
public class CampaignData
{
    public GameMode GameMode { get; set; }

    public List<GameModifierData> Modifiers { get; set; }

    public string GameVersion { get; set; }

    public int Seed { get; set; } = -1;


    public CampaignData()
    {
    }

    public CampaignData(string gameModeName, int seed = -1)
    {
        if (AddressableLoader.TryGet<GameMode>("GameMode", gameModeName, out var result))
        {
            Init(result, seed);
        }
        else
        {
            Init(AddressableLoader.Get<GameMode>("GameMode", "GameModeNormal"), seed);
        }
    }

    public CampaignData(GameMode gameMode, int seed = -1)
    {
        Init(gameMode, seed);
    }

    public static CampaignData Load(GameMode gameMode)
    {
        CampaignData obj = new CampaignData
        {
            GameMode = gameMode,
            GameVersion = SaveSystem.LoadCampaignData<string>(gameMode, "gameVersion"),
            Seed = SaveSystem.LoadCampaignData(gameMode, "seed", 0)
        };
        Debug.Log(obj);
        return obj;
    }

    public void Init(GameMode gameMode, int seed = -1)
    {
        GameMode = gameMode;
        GameVersion = Config.data.version;
        if (seed >= 0)
        {
            Seed = seed;
        }
        else if (!StringExt.IsNullOrWhitespace(gameMode.seed))
        {
            Seed = StringExt.ToSeed(gameMode.seed);
        }
        else
        {
            Seed = SaveSystem.LoadProgressData("nextSeed", -1);
            if (Seed <= 0)
            {
                Seed = Random.Seed();
                SaveSystem.SaveProgressData("nextSeed", Seed);
            }
        }
        Debug.Log(this);
        Events.InvokeCampaignDataCreated(this);
    }

    public override string ToString()
    {
        return $"CampaignData (GameMode: {(GameMode).name}, GameVersion: {GameVersion}, Seed: {Seed})";
    }
}
[Serializable]
public class CampaignNode : ISaveable<CampaignNodeSaveData>
{
    [Serializable]
    public class Connection
    {
        public int otherId;

        public float direction;
    }

    public string name = "Salty Spicelands";

    public int id;

    public int seed;

    public Vector2 position;

    public int tier;

    public int positionIndex;

    public int areaIndex;

    public List<Connection> connections;

    public List<int> characters;

    public bool revealed;

    public bool cleared;

    public float radius;

    public bool glow;

    public bool finalNode;

    public Dictionary<string, object> data;

    public int connectedTo;

    public int pathId = -1;

    public int dataLinkedTo = -1;

    public List<int> linkedToThis;

    public CampaignNodeType type { get; set; }

    public void CopyData(CampaignNode otherNode)
    {
        data = otherNode.data.ToDictionary((KeyValuePair<string, object> entry) => entry.Key, CloneDataValue);
    }

    public object CloneDataValue(KeyValuePair<string, object> pair)
    {
        if (pair.Value is ICloneable cloneable)
        {
            return cloneable.Clone();
        }
        return pair.Value;
    }

    public CampaignNode()
    {
    }

    public CampaignNode(CampaignNodeType type, float x, float y, int tier, int positionIndex, int areaIndex, float radius)
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        SetType(type);
        position = new Vector2(x, y);
        this.tier = tier;
        this.positionIndex = positionIndex;
        this.areaIndex = areaIndex;
        this.radius = radius;
        seed = Random.Seed();
        connections = new List<Connection>();
        characters = new List<int>();
        finalNode = type.finalNode;
        if (!type.canEnter)
        {
            cleared = true;
        }
    }

    public virtual IEnumerator SetUp()
    {
        return null;
    }

    public virtual IEnumerator Run()
    {
        return null;
    }

    public void ConnectTo(CampaignNode other)
    {
        other.connectedTo++;
        Connection connection = new Connection
        {
            otherId = other.id
        };
        if (connections.Count == 0)
        {
            connection.direction = 1f;
        }
        else
        {
            float direction = connections[0].direction;
            connection.direction = direction * -1f;
        }
        connections.Insert(0, connection);
    }

    public bool CanReceiveCharacter(Character character)
    {
        return character.GetCompanionCount() <= character.data.companionLimit;
    }

    public void SetType(CampaignNodeType type)
    {
        this.type = type;
        name = type.zoneName;
        revealed = type.startRevealed;
    }

    public string GetDesc()
    {
        string text = "";
        List<string> list = new List<string>();
        foreach (int character in characters)
        {
            List<RewardData> list2 = ((Component)Campaign.GetCharacter(character)).GetComponent<BattleRewards>()?.rewards;
            if (list2 == null)
            {
                continue;
            }
            foreach (RewardData item in list2)
            {
                list.Add(item.title);
            }
        }
        if (list.Count > 0)
        {
            string text2 = "#BABABA";
            if (list.Count == 1)
            {
                text = "<color=" + text2 + ">Reward:</color>\n" + list[0];
            }
            else
            {
                text = "<color=" + text2 + ">Rewards:</color>";
                foreach (string item2 in list)
                {
                    text = text + "\n" + item2;
                }
            }
        }
        return text;
    }

    public void SetCleared()
    {
        if (!cleared)
        {
            cleared = true;
            Campaign.PromptSave();
        }
    }

    public CampaignNodeSaveData Save()
    {
        return new CampaignNodeSaveData(this);
    }
}
[Serializable]
public class CampaignStats
{
    public float time;

    public int hours;

    public Dictionary<string, Dictionary<string, int>> add;

    public Dictionary<string, Dictionary<string, int>> max;

    public void Add(string stat, int value)
    {
        Change(stat, value, ref add, Add);
    }

    public void Add(string stat, string key, int value)
    {
        Change(stat, key, value, ref add, Add);
    }

    public void Max(string stat, int value)
    {
        Change(stat, value, ref max, Max);
    }

    public void Max(string stat, string key, int value)
    {
        Change(stat, key, value, ref max, Max);
    }

    public void Min(string stat, int value)
    {
        Change(stat, value, ref max, Min);
    }

    public void Min(string stat, string key, int value)
    {
        Change(stat, key, value, ref max, Min);
    }

    public void Change(string stat, int value, ref Dictionary<string, Dictionary<string, int>> values, Func<int, int, int> action)
    {
        Change(stat, "", value, ref values, action);
    }

    public void Change(string stat, string key, int value, ref Dictionary<string, Dictionary<string, int>> values, Func<int, int, int> action)
    {
        int num = 0;
        int num2 = 0;
        if (values == null)
        {
            values = new Dictionary<string, Dictionary<string, int>>();
        }
        Dictionary<string, int> dictionary;
        if (!values.ContainsKey(stat))
        {
            dictionary = new Dictionary<string, int>();
            values[stat] = dictionary;
        }
        else
        {
            Dictionary<string, int> dictionary2 = values[stat];
            if (dictionary2 != null)
            {
                dictionary = dictionary2;
            }
            else
            {
                dictionary = new Dictionary<string, int>();
                values[stat] = dictionary;
            }
        }
        if (dictionary.ContainsKey(key))
        {
            num = dictionary[key];
            num2 = action(num, value);
        }
        else
        {
            num2 = value;
        }
        dictionary[key] = num2;
        if (num != num2)
        {
            Events.InvokeStatChanged(stat, key, num, num2);
        }
    }

    public int Add(int value, int add)
    {
        return value + add;
    }

    public int Max(int value, int max)
    {
        return Mathf.Max(value, max);
    }

    public int Min(int value, int min)
    {
        return Mathf.Min(value, min);
    }

    public Dictionary<string, int> Get(string stat, Dictionary<string, Dictionary<string, int>> source)
    {
        if (source != null && source.ContainsKey(stat))
        {
            Dictionary<string, int> dictionary = source[stat];
            if (dictionary != null)
            {
                return dictionary;
            }
        }
        return null;
    }

    public Dictionary<string, int> Get(string stat)
    {
        return Get(stat, add);
    }

    public int Get(string stat, int defaultValue)
    {
        Dictionary<string, int> dictionary = Get(stat, add);
        if (dictionary == null || !dictionary.ContainsKey(""))
        {
            return defaultValue;
        }
        return dictionary[""];
    }

    public int Get(string stat, string key, int defaultValue)
    {
        Dictionary<string, int> dictionary = Get(stat, add);
        if (dictionary == null || !dictionary.ContainsKey(key))
        {
            return defaultValue;
        }
        return dictionary[key];
    }

    public int Best(string stat, int defaultValue)
    {
        return Get(stat, max)?.Values.Prepend(0).Max() ?? defaultValue;
    }

    public int Best(string stat, string key, int defaultValue)
    {
        Dictionary<string, int> dictionary = Get(stat, max);
        if (dictionary == null || !dictionary.ContainsKey(key))
        {
            return defaultValue;
        }
        return dictionary[key];
    }

    public int Count(string stat)
    {
        return Get(stat, add)?.Values.Sum() ?? 0;
    }

    public void Set(string stat, int value)
    {
        Set(add, stat, "", value);
    }

    public void Set(string stat, string key, int value)
    {
        Set(add, stat, key, value);
    }

    public void SetBest(string stat, int value)
    {
        Set(max, stat, "", value);
    }

    public void SetBest(string stat, string key, int value)
    {
        Set(max, stat, key, value);
    }

    public void Set(Dictionary<string, Dictionary<string, int>> dict, string stat, string key, int value)
    {
        if (!dict.ContainsKey(stat))
        {
            dict[stat] = new Dictionary<string, int> { { key, value } };
        }
        else
        {
            dict[stat][key] = value;
        }
    }

    public void Delete(string stat)
    {
        add.Remove(stat);
    }

    public void DeleteBest(string stat)
    {
        max.Remove(stat);
    }

    public CampaignStats Clone()
    {
        CampaignStats campaignStats = new CampaignStats
        {
            time = time,
            hours = hours
        };
        if (add != null)
        {
            campaignStats.add = add.ToDictionary((KeyValuePair<string, Dictionary<string, int>> a) => a.Key, (KeyValuePair<string, Dictionary<string, int>> a) => a.Value.ToDictionary((KeyValuePair<string, int> b) => b.Key, (KeyValuePair<string, int> b) => b.Value));
        }
        if (max != null)
        {
            campaignStats.max = max.ToDictionary((KeyValuePair<string, Dictionary<string, int>> a) => a.Key, (KeyValuePair<string, Dictionary<string, int>> a) => a.Value.ToDictionary((KeyValuePair<string, int> b) => b.Key, (KeyValuePair<string, int> b) => b.Value));
        }
        return campaignStats;
    }
}
[Serializable]
public class CardDataList : IList<CardData>, ICollection<CardData>, IEnumerable<CardData>, IEnumerable
{
    [SerializeField]
    public List<CardData> list = new List<CardData>();

    public int Count => list.Count;

    public bool IsReadOnly => false;

    public CardData this[int index]
    {
        get
        {
            return list[index];
        }
        set
        {
            list[index] = value;
        }
    }

    public IEnumerator<CardData> GetEnumerator()
    {
        return list.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return list.GetEnumerator();
    }

    public void Add(CardData item)
    {
        list.Add(item);
    }

    public void Clear()
    {
        list.Clear();
    }

    public bool Contains(CardData item)
    {
        if (!(item))
        {
            return false;
        }
        foreach (CardData item2 in list)
        {
            if (item2.id == item.id)
            {
                return true;
            }
        }
        return false;
    }

    public void CopyTo(CardData[] array, int arrayIndex)
    {
        list.CopyTo(array, arrayIndex);
    }

    public bool Remove(CardData item)
    {
        int num = IndexOf(item);
        if (num >= 0)
        {
            list.RemoveAt(num);
            return true;
        }
        return false;
    }

    public int IndexOf(CardData item)
    {
        if (!(item))
        {
            return -1;
        }
        for (int i = 0; i < list.Count; i++)
        {
            if (list[i].id == item.id)
            {
                return i;
            }
        }
        return -1;
    }

    public void Insert(int index, CardData item)
    {
        list.Insert(index, item);
    }

    public void RemoveAt(int index)
    {
        list.RemoveAt(index);
    }

    public void Sort()
    {
        list.Sort();
    }

    public void Sort(Comparison<CardData> comparison)
    {
        list.Sort(comparison);
    }

    public void Sort(IComparer<CardData> comparer)
    {
        list.Sort(comparer);
    }

    public void Sort(int index, int count, IComparer<CardData> comparer)
    {
        list.Sort(index, count, comparer);
    }

    public List<CardData> FindAll(Predicate<CardData> predicate)
    {
        return list.FindAll(predicate);
    }
}
[Serializable]
public class ChallengeProgress
{
    public string challengeName;

    public int currentValue;

    public int originalValue;

    public ChallengeProgress()
    {
    }

    public ChallengeProgress(string challengeName, int value)
    {
        this.challengeName = challengeName;
        currentValue = value;
        originalValue = value;
    }
}
[Serializable]
public class CharacterData
{
    public string title;

    public string race;

    public string gender;

    [Header("Part Indices")]
    public int headIndex;

    public int bodyIndex;

    public int weapon1Index;

    public int weapon2Index;

    public int eyesIndex;

    public int mouthIndex;

    public int noseIndex;

    public int eyebrowIndex;

    public int earIndex;

    public int hairBackIndex;

    public int hairTopIndex;

    public int beardIndex;

    public int markingsIndex;

    public int clothingColorIndex;

    public int hairColorIndex;

    public int eyeColorIndex;

    public int skinColorIndex;

    public int markingsColorIndex;

    [Header("Scale")]
    public Vector2 bodyScale = Vector2.one;

    public Vector2 headScale = Vector2.one;

    public Vector2 eyeScale = Vector2.one;

    public Vector2 eyebrowScale = Vector2.one;

    public Vector2 noseScale = Vector2.one;

    public Vector2 mouthScale = Vector2.one;

    public Vector2 earScale = Vector2.one;

    public Vector2 hairScale = Vector2.one;

    public void Randomize(CharacterType type, bool lockTitle = false, bool lockBody = false, bool lockHead = false, bool lockEyes = false, bool lockEyebrows = false, bool lockMouth = false, bool lockNose = false, bool lockEars = false, bool lockHair = false, bool lockHairBack = false, bool lockBeard = false, bool lockHairColour = false, bool lockEyeColour = false, bool lockSkinColour = false, bool lockClothingColour = false, bool lockWeapon = false, bool lockMarkings = false, bool lockMarkingsColour = false)
    {
        if (!lockTitle)
        {
            title = Names.Pull(race, gender);
        }
        SetRandomPrefab(lockBody, type, "Body", ref bodyIndex);
        SetRandomPrefab(lockHead, type, "Head", ref headIndex);
        SetRandomPrefab(lockWeapon, type, "Weapon1", ref weapon1Index);
        SetRandomPrefab(lockWeapon, type, "Weapon2", ref weapon2Index);
        SetRandomPrefab(lockEyes, type, "Eyes", ref eyesIndex);
        SetRandomSprite(lockEyebrows, type, "Eyebrows", ref eyebrowIndex);
        SetRandomSprite(lockMouth, type, "Mouth", ref mouthIndex);
        SetRandomSprite(lockNose, type, "Nose", ref noseIndex);
        SetRandomSprite(lockEars, type, "Ears", ref earIndex);
        SetRandomSprite(lockHair, type, "HairTop", ref hairTopIndex);
        SetRandomSprite(lockHairBack, type, "HairBack", ref hairBackIndex);
        SetRandomSprite(lockBeard, type, "Beard", ref beardIndex);
        SetRandomSprite(lockMarkings, type, "Markings", ref markingsIndex);
        SetRandomColorSet(lockHairColour, type, "HairColour", ref hairColorIndex);
        SetRandomColorSet(lockEyeColour, type, "EyeColour", ref eyeColorIndex);
        SetRandomColorSet(lockSkinColour, type, "SkinColour", ref skinColorIndex);
        SetRandomColorSet(lockClothingColour, type, "ClothingColour", ref clothingColorIndex);
        SetRandomColorSet(lockMarkingsColour, type, "MarkingColour", ref markingsColorIndex);
        SetScale(locked: false, type, "Body", ref bodyScale);
        SetScale(locked: false, type, "Head", ref headScale);
        SetScale(locked: false, type, "Eyes", ref eyeScale);
        SetScale(locked: false, type, "Mouth", ref mouthScale);
        SetScale(locked: false, type, "Nose", ref noseScale);
        SetScale(locked: false, type, "Eyebrows", ref eyebrowScale);
        SetScale(locked: false, type, "Ears", ref earScale);
        SetScale(locked: false, type, "Hair", ref hairScale);
    }

    public void SetRandomPrefab(bool locked, CharacterType type, string name, ref int index)
    {
        if (!locked)
        {
            CharacterType.PrefabGroup prefabGroup = type.prefabs.FirstOrDefault((CharacterType.PrefabGroup a) => a.name == name);
            if (prefabGroup != null)
            {
                index = prefabGroup.collection.RandomIndex();
            }
        }
    }

    public void SetRandomSprite(bool locked, CharacterType type, string name, ref int index)
    {
        if (!locked)
        {
            CharacterType.SpriteGroup spriteGroup = type.sprites.FirstOrDefault((CharacterType.SpriteGroup a) => a.name == name);
            if (spriteGroup != null)
            {
                index = spriteGroup.collection.RandomIndex();
            }
        }
    }

    public void SetRandomColorSet(bool locked, CharacterType type, string name, ref int index)
    {
        if (!locked)
        {
            CharacterType.ColorSetGroup colorSetGroup = type.colorSets.FirstOrDefault((CharacterType.ColorSetGroup a) => a.name == name);
            if (colorSetGroup != null)
            {
                index = colorSetGroup.collection.RandomIndex();
            }
        }
    }

    public void SetScale(bool locked, CharacterType type, string name, ref Vector2 scale)
    {
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        if (!locked)
        {
            CharacterType.ScaleRange scaleRange = type.scales.FirstOrDefault((CharacterType.ScaleRange a) => a.name == name);
            if (scaleRange != null)
            {
                scale = scaleRange.Convert();
            }
        }
    }
}
[Serializable]
public struct CurveProfile
{
    public AnimationCurve curve;

    public float duration;
}
public class FreezableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
{
    public readonly List<T> currentList = new List<T>();

    public readonly List<T> nextList = new List<T>();

    public int freezeCount;

    public bool updateRequired;

    public bool sortRequired;

    public bool autoSort;

    public IComparer<T> autoSortComparer;

    public T this[int index]
    {
        get
        {
            return currentList[index];
        }
        set
        {
            nextList[index] = value;
        }
    }

    public int Count => currentList.Count;

    public bool IsReadOnly => false;

    public FreezableList()
    {
    }

    public FreezableList(bool autoSort)
    {
        this.autoSort = autoSort;
    }

    public FreezableList(bool autoSort, IComparer<T> autoSortComparer)
    {
        this.autoSort = autoSort;
        this.autoSortComparer = autoSortComparer;
    }

    public void Add(T item)
    {
        int count = nextList.Count;
        int index = count;
        if (autoSort)
        {
            for (int i = 0; i < count; i++)
            {
                if (autoSortComparer.Compare(item, nextList[i]) <= 0)
                {
                    index = i;
                    break;
                }
            }
        }
        nextList.Insert(index, item);
        if (freezeCount <= 0)
        {
            currentList.Insert(index, item);
            return;
        }
        updateRequired = true;
        if (!autoSort)
        {
            sortRequired = true;
        }
    }

    public void Insert(int index, T item)
    {
        throw new NotImplementedException();
    }

    public bool Remove(T item)
    {
        bool result = nextList.Remove(item);
        if (freezeCount <= 0)
        {
            currentList.Remove(item);
            return result;
        }
        updateRequired = true;
        return result;
    }

    public void RemoveAt(int index)
    {
        nextList.RemoveAt(index);
        if (freezeCount <= 0)
        {
            currentList.RemoveAt(index);
        }
        else
        {
            updateRequired = true;
        }
    }

    public void Clear()
    {
        nextList.Clear();
        if (freezeCount <= 0)
        {
            currentList.Clear();
        }
        else
        {
            updateRequired = true;
        }
    }

    public bool Contains(T item)
    {
        return currentList.Contains(item);
    }

    public void CopyTo(T[] array, int arrayIndex)
    {
        currentList.CopyTo(array, arrayIndex);
    }

    public int IndexOf(T item)
    {
        return currentList.IndexOf(item);
    }

    public IEnumerator<T> GetEnumerator()
    {
        return currentList.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return currentList.GetEnumerator();
    }

    public T[] ToArray()
    {
        return nextList.ToArray();
    }

    public List<T> ToList()
    {
        return new List<T>(nextList);
    }

    public void Freeze()
    {
        freezeCount++;
    }

    public void Thaw()
    {
        freezeCount--;
        if (freezeCount <= 0)
        {
            if (updateRequired && sortRequired && autoSort)
            {
                Sort(nextList, autoSortComparer);
                sortRequired = false;
            }
            TryUpdate();
            if (autoSort && sortRequired)
            {
                TrySort(autoSortComparer);
            }
        }
    }

    public void TryUpdate()
    {
        if (updateRequired)
        {
            currentList.Clear();
            currentList.AddRange(nextList);
            updateRequired = false;
        }
    }

    public void TrySort(IComparer<T> comparer)
    {
        if (sortRequired)
        {
            Sort(currentList, comparer);
            nextList.Clear();
            nextList.AddRange(currentList);
            sortRequired = false;
        }
    }

    public static void Sort(List<T> list, IComparer<T> comparer)
    {
        T[] collection = list.OrderBy((T a) => a, comparer).ToArray();
        list.Clear();
        list.AddRange(collection);
    }
}
public class Hit
{
    public Entity attacker;

    public Character owner;

    public readonly Entity target;

    public string damageType = "basic";

    public Trigger trigger;

    public int damage;

    public int damageBlocked;

    public int counterReduction;

    public float screenShake = 1f;

    public bool countsAsHit = true;

    public bool canBeNullified = true;

    public bool nullified;

    public List<CardData.StatusEffectStacks> statusEffects;

    public bool doAnimation = true;

    public bool canRetaliate = true;

    public bool dodged;

    public int extraOffensiveness;

    public int damageDealt { get; set; }

    public bool Offensive { get; set; }

    public bool Supportive
    {
        get
        {
            if (damage < 0)
            {
                return true;
            }
            if (statusEffects != null)
            {
                foreach (CardData.StatusEffectStacks statusEffect in statusEffects)
                {
                    if (!statusEffect.data.offensive)
                    {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    public bool BasicHit => damageType == "basic";

    public int GetOffensiveness()
    {
        int num = Mathf.Max(0, damage) + damageBlocked + extraOffensiveness;
        if (statusEffects != null)
        {
            foreach (CardData.StatusEffectStacks statusEffect in statusEffects)
            {
                if (statusEffect.data.offensive)
                {
                    num += statusEffect.count;
                }
            }
        }
        return num;
    }

    public int GetSupportiveness()
    {
        int num = Mathf.Max(0, -damage);
        if (statusEffects != null)
        {
            foreach (CardData.StatusEffectStacks statusEffect in statusEffects)
            {
                if (!statusEffect.data.offensive)
                {
                    num += statusEffect.count;
                }
            }
        }
        return num;
    }

    public Hit(Entity attacker, Entity target)
    {
        this.attacker = attacker;
        if ((attacker))
        {
            owner = attacker.owner;
            damage = Mathf.Max(0, attacker.damage.current + ((attacker.tempDamage)).Value);
            countsAsHit = attacker.HasAttackIcon();
            if (countsAsHit)
            {
                Offensive = attacker.IsOffensive();
            }
        }
        this.target = target;
    }

    public Hit(Entity attacker, Entity target, int damage)
    {
        this.attacker = attacker;
        if ((attacker))
        {
            owner = attacker.owner;
        }
        this.target = target;
        this.damage = damage;
        Offensive = damage > 0;
    }

    public void AddAttackerStatuses()
    {
        if (!(attacker.data) || attacker.attackEffects == null || attacker.silenced)
        {
            return;
        }
        foreach (CardData.StatusEffectStacks attackEffect in attacker.attackEffects)
        {
            int num = CalculateAttackEffectAmount(attackEffect.data, attackEffect.count);
            if (num > 0)
            {
                AddStatusEffect(attackEffect.data, num);
            }
        }
    }

    public int CalculateAttackEffectAmount(StatusEffectData data, int statusEffectStacks)
    {
        if (!attacker.silenced)
        {
            if (!data.stackable)
            {
                return statusEffectStacks;
            }
            return Mathf.Max(0, Mathf.RoundToInt((float)(statusEffectStacks + attacker.effectBonus) * attacker.effectFactor));
        }
        return 0;
    }

    public void AddStatusEffect(CardData.StatusEffectStacks statusEffect)
    {
        if (statusEffects == null)
        {
            statusEffects = new List<CardData.StatusEffectStacks>();
        }
        statusEffects.Add(statusEffect);
        if (!Offensive && countsAsHit && statusEffect.data.offensive)
        {
            Offensive = true;
        }
    }

    public void AddStatusEffect(StatusEffectData statusEffectData, int count)
    {
        AddStatusEffect(new CardData.StatusEffectStacks
        {
            data = statusEffectData,
            count = count
        });
    }

    public IEnumerator Process()
    {
        if (!(target))
        {
            yield break;
        }
        if (countsAsHit)
        {
            target.lastHit = this;
        }
        if (countsAsHit)
        {
            yield return StatusEffectSystem.HitEvent(this);
        }
        if (!dodged)
        {
            Events.InvokeEntityHit(this);
            if (!nullified)
            {
                if (damage != 0)
                {
                    damageDealt = damage;
                    int num = target.hp.current - damage;
                    if (num > target.hp.max)
                    {
                        damageDealt += num - target.hp.max;
                        num = target.hp.max;
                    }
                    target.hp.current = num;
                }
                target.counter.current = Mathf.Max(target.counter.current - counterReduction, 0);
            }
            Routine.Clump clump = new Routine.Clump();
            if (!nullified)
            {
                List<CardData.StatusEffectStacks> list = statusEffects;
                if (list != null && list.Count > 0)
                {
                    foreach (CardData.StatusEffectStacks statusEffect in statusEffects)
                    {
                        clump.Add(StatusEffectSystem.Apply(target, attacker, statusEffect.data, statusEffect.count));
                    }
                }
            }
            target.PromptUpdate();
            if (clump.Count > 0)
            {
                yield return clump.WaitForEnd();
            }
        }
        else
        {
            Events.InvokeEntityDodge(this);
        }
        Events.InvokeEntityPostHit(this);
        if (countsAsHit)
        {
            yield return StatusEffectSystem.PostHitEvent(this);
        }
        yield return Sequences.Null();
    }

    public void FlagAsOffensive()
    {
        Offensive = true;
    }
}
public interface ICardDestroyed
{
    void Final();
}
public interface IPointerAfterExitHandler
{
    void OnPointerAfterExit(PointerEventData eventData);
}
public interface IPoolable
{
    void OnGetFromPool();

    void OnReturnToPool();
}
public interface IRemoveWhenPooled
{
}
public interface IRerollable
{
    bool Reroll();
}
[Serializable]
public class PlayerData
{
    public ClassData classData;

    [Header("Stats")]
    public int handSize = 6;

    public int redrawBell = 4;

    public int companionLimit = 3;

    public float enemyGoldFactor = 1f;

    public float comboGoldFactor = 1f;

    [Header("Inventory")]
    public Inventory inventory;

    public PlayerData(ClassData classData, Inventory inventory)
    {
        this.classData = classData;
        this.inventory = inventory;
    }
}
[Serializable]
public class Progression
{
    public float current;

    public float previousRequired;

    public float required = 1f;

    [SerializeField]
    public float randomness = 0.1f;

    [SerializeField]
    public float minProgressAdd = 2f;

    [SerializeField]
    public float maxProgressAdd = 4f;

    public Progression()
    {
    }

    public Progression(float startAmount, float startRequirement, float randomness)
    {
        current = startAmount;
        previousRequired = 0f;
        required = startRequirement;
        this.randomness = randomness;
    }

    public bool Add(float amount)
    {
        if (RequirementMet())
        {
            return false;
        }
        current += amount + Random.Range(0f - randomness, randomness);
        return true;
    }

    public bool RequirementMet()
    {
        return current >= required;
    }

    public void SetNextRequirement()
    {
        previousRequired = required;
        required += Mathf.Clamp(required, minProgressAdd, maxProgressAdd);
    }

    public float ProgressToNextUnlock()
    {
        return (current - previousRequired) / (required - previousRequired);
    }
}
[Serializable]
public class BattleEntityData
{
    public CardSaveData cardSaveData;

    public int height;

    public int damage;

    public int damageMax;

    public int hp;

    public int hpMax;

    public int counter;

    public int counterMax;

    public int uses;

    public int usesMax;

    public bool flipped;

    public StatusEffectSaveData[] attackEffects;

    public BattleEntityData()
    {
    }

    public BattleEntityData(Entity entity)
    {
        cardSaveData = entity.data.Save();
        height = entity.height;
        damage = entity.damage.current;
        damageMax = entity.damage.max;
        hp = entity.hp.current;
        hpMax = entity.hp.max;
        counter = entity.counter.current;
        counterMax = entity.counter.max;
        uses = entity.uses.current;
        usesMax = entity.uses.max;
        flipped = !((Behaviour)entity).enabled;
        attackEffects = entity.attackEffects.Select((CardData.StatusEffectStacks a) => a.Save()).ToArray();
    }
}
[Serializable]
public class BattleMusicSaveData
{
    public int intensity;

    public bool bossEntered;

    public int bossPhase;
}
[Serializable]
public class BattleSaveData
{
    [Serializable]
    public class ContainerGroup
    {
        public Container[] containers;

        public ContainerGroup()
        {
        }

        public ContainerGroup(IEnumerable<CardContainer> containers)
        {
            this.containers = containers.Select((CardContainer a) => new Container(a)).ToArray();
        }
    }

    [Serializable]
    public class Container
    {
        public BattleEntityData[] cards;

        public Container()
        {
        }

        public Container(CardContainer container)
        {
            if (container is CardSlotLane cardSlotLane)
            {
                cards = cardSlotLane.slots.Select(delegate (CardSlot a)
                {
                    Entity top = a.GetTop();
                    return (top == null) ? null : new BattleEntityData(top);
                }).ToArray();
            }
            else
            {
                cards = container.Select((Entity a) => new BattleEntityData(a)).ToArray();
            }
        }
    }

    [Serializable]
    public class Status
    {
        public string name;

        public int count;

        public ulong targetId;

        public bool hasApplier;

        public ulong applierId;

        public Status()
        {
        }

        public Status(StatusEffectData data)
        {
            name = (data).name;
            count = data.count - data.temporary;
            targetId = data.target.data.id;
            hasApplier = (data.applier);
            if (hasApplier)
            {
                applierId = data.applier.data.id;
            }
        }
    }

    public int campaignNodeId;

    public int turnCount;

    public int redrawBellCount;

    public ContainerGroup playerRows;

    public ContainerGroup enemyRows;

    public Container playerHand;

    public Container playerDraw;

    public Container playerDiscard;

    public Container playerReserve;

    public Container enemyReserve;

    public Status[] statuses;

    public BattleEntityData[] destroyed;

    public BattleWaveData enemyWaves;

    public BattleMusicSaveData battleMusicState;

    public Dictionary<string, object> storeStatusData = new Dictionary<string, object>();

    public int gold;

    public bool HasMissingCardData()
    {
        List<Container> list = new List<Container>();
        list.AddRange(playerRows.containers);
        list.AddRange(enemyRows.containers);
        list.Add(playerReserve);
        list.Add(enemyReserve);
        list.Add(playerDraw);
        list.Add(playerDiscard);
        list.Add(playerHand);
        foreach (Container item in list)
        {
            BattleEntityData[] cards = item.cards;
            foreach (BattleEntityData battleEntityData in cards)
            {
                if (battleEntityData != null && (battleEntityData.cardSaveData == null || MissingCardSystem.IsMissing(battleEntityData.cardSaveData.name)))
                {
                    Debug.LogError("BattleSaveData has missing CardData");
                    return true;
                }
            }
        }
        return false;
    }
}
[Serializable]
public class BattleWaveData
{
    [Serializable]
    public class Wave
    {
        public int counter;

        public ulong[] unitIds;

        public bool isBossWave;

        public bool spawned;

        public Wave()
        {
        }

        public Wave(BattleWaveManager.Wave wave)
        {
            counter = wave.counter;
            unitIds = (from a in wave.units
                       where (a)
                       select a.id).ToArray();
            isBossWave = wave.isBossWave;
            spawned = wave.spawned;
        }
    }

    public List<ulong> deployed;

    public int counter;

    public int counterMax;

    public int currentWave;

    public int overflowWaveIndex;

    public Wave[] waves;
}
[Serializable]
public class CampaignNodeSaveData : ILoadable<CampaignNode>
{
    public string name;

    public int id;

    public string typeName;

    public int seed;

    public Vector2 position;

    public int tier;

    public int positionIndex;

    public int areaIndex;

    public List<CampaignNode.Connection> connections;

    public List<int> characters;

    public bool revealed;

    public bool cleared;

    public bool glow;

    public bool finalNode;

    public Dictionary<string, object> data;

    public CampaignNodeSaveData()
    {
    }

    public CampaignNodeSaveData(CampaignNode node)
    {
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        name = node.name;
        id = node.id;
        typeName = (node.type).name;
        seed = node.seed;
        position = node.position;
        tier = node.tier;
        positionIndex = node.positionIndex;
        areaIndex = node.areaIndex;
        connections = node.connections;
        characters = node.characters;
        revealed = node.revealed;
        cleared = node.cleared;
        glow = node.glow;
        finalNode = node.finalNode;
        data = node.data;
    }

    public CampaignNode Load()
    {
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        CampaignNodeType type = AddressableLoader.Get<CampaignNodeType>("CampaignNodeType", typeName);
        CampaignNode campaignNode = new CampaignNode();
        campaignNode.SetType(type);
        campaignNode.name = name;
        campaignNode.id = id;
        campaignNode.position = position;
        campaignNode.tier = tier;
        campaignNode.positionIndex = positionIndex;
        campaignNode.areaIndex = areaIndex;
        campaignNode.seed = seed;
        campaignNode.connections = connections;
        campaignNode.characters = characters;
        campaignNode.revealed = revealed;
        campaignNode.cleared = cleared;
        campaignNode.glow = glow;
        campaignNode.finalNode = finalNode;
        campaignNode.data = data;
        return campaignNode;
    }
}
[Serializable]
public class CampaignSaveData
{
    public CharacterSaveData[] characters;

    public CampaignNodeSaveData[] nodes;

    public int playerId;

    public string[] modifiers;

    public CampaignSaveData()
    {
    }

    public CampaignSaveData(Campaign campaign)
    {
        characters = campaign.characters.SaveArray<Character, CharacterSaveData>();
        nodes = campaign.nodes.SaveArray<CampaignNode, CampaignNodeSaveData>();
        playerId = Campaign.GetCharacterId(References.Player);
        modifiers = ((Campaign.Data.Modifiers != null) ? Campaign.Data.Modifiers.Select((GameModifierData a) => (a).name).ToArray() : null);
    }

    public List<CampaignNode> LoadNodes()
    {
        List<CampaignNode> list = new List<CampaignNode>();
        CampaignNodeSaveData[] array = nodes;
        foreach (CampaignNodeSaveData campaignNodeSaveData in array)
        {
            list.Add(campaignNodeSaveData.Load());
        }
        return list;
    }
}
[Serializable]
public class CardSaveData : ILoadable<CardData>
{
    public ulong id;

    public string name;

    public string title;

    public int hp;

    public int damage;

    public int counter;

    public Vector3 random3;

    public CardUpgradeSaveData[] upgrades;

    public StatusEffectSaveData[] attackEffects;

    public StatusEffectSaveData[] startWithEffects;

    public TraitSaveData[] traits;

    public StatusEffectSaveData[] injuries;

    public Dictionary<string, object> customData;

    public CardSaveData()
    {
    }

    public CardSaveData(CardData cardData)
    {
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        id = cardData.id;
        name = (cardData).name;
        title = cardData.forceTitle;
        hp = cardData.hp;
        damage = cardData.damage;
        counter = cardData.counter;
        random3 = cardData.random3;
        upgrades = cardData.upgrades.SaveArray<CardUpgradeData, CardUpgradeSaveData>();
        attackEffects = cardData.attackEffects.SaveArray<CardData.StatusEffectStacks, StatusEffectSaveData>();
        startWithEffects = cardData.startWithEffects.SaveArray<CardData.StatusEffectStacks, StatusEffectSaveData>();
        traits = cardData.traits.SaveArray<CardData.TraitStacks, TraitSaveData>();
        injuries = cardData.injuries.SaveArray<CardData.StatusEffectStacks, StatusEffectSaveData>();
        customData = cardData.customData;
        if ((cardData.original) && cardData.cardType != cardData.original.cardType)
        {
            customData ??= new Dictionary<string, object>();
            customData["OverrideCardType"] = (cardData.cardType).name;
        }
    }

    public CardData Peek()
    {
        return AddressableLoader.Get<CardData>("CardData", name);
    }

    public CardData Load()
    {
        return Load(keepId: true);
    }

    public CardData Load(bool keepId)
    {
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        CardData cardData = AddressableLoader.Get<CardData>("CardData", name);
        bool num = !(cardData);
        CardData cardData2 = ((!num) ? (keepId ? cardData.Clone(random3, id, runCreateScripts: false) : cardData.Clone(random3, runCreateScripts: false)) : (keepId ? MissingCardSystem.GetCloneWithId(name, random3, id) : MissingCardSystem.GetClone(name)));
        cardData2.customData = customData;
        cardData2.attackEffects = attackEffects.LoadArray<CardData.StatusEffectStacks, StatusEffectSaveData>();
        cardData2.startWithEffects = startWithEffects.LoadArray<CardData.StatusEffectStacks, StatusEffectSaveData>();
        cardData2.traits = traits.LoadList<CardData.TraitStacks, TraitSaveData>();
        cardData2.injuries = injuries.LoadList<CardData.StatusEffectStacks, StatusEffectSaveData>();
        if (!num)
        {
            cardData2.forceTitle = title;
        }
        cardData2.hp = hp;
        cardData2.damage = damage;
        cardData2.counter = counter;
        if (cardData2.customData != null && cardData2.customData.ContainsKey("OverrideCardType"))
        {
            cardData2.cardType = AddressableLoader.Get<CardType>("CardType", DictionaryExt.Get<string>(cardData2.customData, "OverrideCardType"));
        }
        CardUpgradeSaveData[] array = upgrades;
        if (array != null && array.Length > 0)
        {
            cardData2.upgrades = upgrades.LoadList<CardUpgradeData, CardUpgradeSaveData>();
            if (cardData2.upgrades.Any((CardUpgradeData a) => a.becomesTargetedCard))
            {
                cardData2.hasAttack = true;
                if (cardData2.playType == Card.PlayType.None)
                {
                    cardData2.playType = Card.PlayType.Play;
                }
                cardData2.needsTarget = true;
            }
        }
        return cardData2;
    }
}
[Serializable]
public class CardUpgradeSaveData : ILoadable<CardUpgradeData>
{
    public string name;

    public CardUpgradeSaveData()
    {
    }

    public CardUpgradeSaveData(string name)
    {
        this.name = name;
    }

    public CardUpgradeData Load()
    {
        return AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", name)?.Clone();
    }
}
[Serializable]
public class CharacterSaveData : ILoadable<Character>
{
    public string name;

    public string title;

    public int team;

    public ClassSaveData classData;

    public InventorySaveData inventoryData;

    [Header("Stats")]
    public int handSize = 6;

    public int redrawBell = 4;

    public int companionLimit = 3;

    public float enemyGoldFactor = 1f;

    public float comboGoldFactor = 1f;

    public CharacterSaveData()
    {
    }

    public CharacterSaveData(Character character)
    {
        name = (character).name;
        title = character.title;
        team = character.team;
        classData = character.data.classData.Save();
        inventoryData = character.data.inventory.Save();
        handSize = character.data.handSize;
        redrawBell = character.data.redrawBell;
        companionLimit = character.data.companionLimit;
        enemyGoldFactor = character.data.enemyGoldFactor;
        comboGoldFactor = character.data.comboGoldFactor;
    }

    public Character Load()
    {
        PlayerData playerData = LoadPlayerData();
        playerData.handSize = handSize;
        playerData.redrawBell = redrawBell;
        playerData.companionLimit = companionLimit;
        playerData.enemyGoldFactor = enemyGoldFactor;
        playerData.comboGoldFactor = comboGoldFactor;
        Character character = Object.Instantiate<Character>(playerData.classData.characterPrefab);
        (character).name = name;
        character.title = title;
        character.team = team;
        character.Assign(playerData);
        return character;
    }

    public PlayerData LoadPlayerData()
    {
        return new PlayerData(classData.Load(), inventoryData.Load());
    }
}
[Serializable]
public class ClassSaveData : ILoadable<ClassData>
{
    public string name;

    public ClassSaveData()
    {
    }

    public ClassSaveData(string name)
    {
        this.name = name;
    }

    public ClassData Load()
    {
        return AddressableLoader.Get<ClassData>("ClassData", name);
    }
}
public interface ILoadable<T>
{
    T Load();
}
[Serializable]
public class InventorySaveData : ILoadable<Inventory>
{
    public CardSaveData[] deck;

    public CardSaveData[] reserve;

    public CardUpgradeSaveData[] upgrades;

    public int gold;

    public InventorySaveData()
    {
    }

    public InventorySaveData(CardSaveData[] deck, CardSaveData[] reserve, CardUpgradeSaveData[] upgrades, int gold)
    {
        this.deck = deck;
        this.reserve = reserve;
        this.upgrades = upgrades;
        this.gold = gold;
    }

    public Inventory Load()
    {
        //IL_0092: Unknown result type (might be due to invalid IL or missing references)
        //IL_0097: Unknown result type (might be due to invalid IL or missing references)
        Inventory inventory = ScriptableObject.CreateInstance<Inventory>();
        CardSaveData[] array = deck;
        foreach (CardSaveData cardSaveData in array)
        {
            inventory.deck.Add(cardSaveData.Load());
        }
        array = reserve;
        foreach (CardSaveData cardSaveData2 in array)
        {
            inventory.reserve.Add(cardSaveData2.Load());
        }
        CardUpgradeSaveData[] array2 = upgrades;
        foreach (CardUpgradeSaveData cardUpgradeSaveData in array2)
        {
            inventory.upgrades.Add(cardUpgradeSaveData.Load());
        }
        inventory.gold = new SafeInt(gold);
        return inventory;
    }
}
public interface ISaveable<T>
{
    T Save();
}
[Serializable]
public class ProgressSaveData
{
    public int nextSeed;

    public int tutorialProgress;

    public bool tutorialCharmDone;

    public bool tutorialInjuryDone;

    public CardSaveData[] finalBossEnemies;

    public static ProgressSaveData Default()
    {
        return new ProgressSaveData
        {
            nextSeed = Random.Seed()
        };
    }
}
public class RunHistory
{
    public string gameModeName;

    public Campaign.Result result;

    public CampaignStats stats;

    public ClassSaveData tribe;

    public InventorySaveData inventory;

    public RunHistory()
    {
    }

    public RunHistory(GameMode gameMode, Campaign.Result result, CampaignStats stats, PlayerData playerData)
    {
        gameModeName = (gameMode).name;
        this.result = result;
        this.stats = stats;
        tribe = playerData.classData.Save();
        inventory = playerData.inventory.Save();
    }
}
[Serializable]
public struct SaveCollection<T> : ICloneable
{
    public T[] collection;

    public int Count => collection.Length;

    public T this[int index]
    {
        get
        {
            return collection[index];
        }
        set
        {
            collection[index] = value;
        }
    }

    public SaveCollection(T[] collection)
    {
        this.collection = collection;
    }

    public SaveCollection(List<T> collection)
    {
        this.collection = collection.ToArray();
    }

    public SaveCollection(T item)
    {
        collection = new T[1] { item };
    }

    public void Add(T item)
    {
        List<T> list = IArrayExt.ToList<T>(collection);
        list.Add(item);
        collection = list.ToArray();
    }

    public void Remove(int index)
    {
        List<T> list = IArrayExt.ToList<T>(collection);
        list.RemoveAt(index);
        collection = list.ToArray();
    }

    public object Clone()
    {
        SaveCollection<T> saveCollection = default(SaveCollection<T>);
        saveCollection.collection = collection.ToArray();
        return saveCollection;
    }
}
[Serializable]
public class SaveData
{
    public StatsSaveData stats;

    public CampaignSaveData[] runHistory;
}
[Serializable]
public class StatsSaveData
{
    public float playTime;

    public int gamesPlayed;

    public int wins;

    public int trueWins;

    public int cardsPlayed;

    [Header("Combat")]
    public int kills;

    public int bossesKilled;

    public int damageDealt;

    public int damageTaken;

    public int highestDamageHit;

    public int battlesWon;

    public int goldGained;

    public int goldSpent;

    public float quickestBattleWin;

    [Header("Score")]
    public int bestScore;

    public float bestTime;
}
[Serializable]
public class StatusEffectSaveData : ILoadable<CardData.StatusEffectStacks>
{
    public string name;

    public int count;

    public CardData.StatusEffectStacks Load()
    {
        StatusEffectData statusEffectData = AddressableLoader.Get<StatusEffectData>("StatusEffectData", name);
        if (!(statusEffectData))
        {
            return null;
        }
        return new CardData.StatusEffectStacks
        {
            data = statusEffectData,
            count = count
        };
    }
}
[Serializable]
public class TraitSaveData : ILoadable<CardData.TraitStacks>
{
    public string name;

    public int count;

    public CardData.TraitStacks Load()
    {
        TraitData traitData = AddressableLoader.Get<TraitData>("TraitData", name);
        if (!(traitData))
        {
            return null;
        }
        return new CardData.TraitStacks
        {
            data = traitData,
            count = count
        };
    }
}
[Serializable]
public struct Stat
{
    public static readonly Stat Default = new Stat(1, 0);

    [SerializeField]
    public SafeInt safeCurrent;

    [SerializeField]
    public SafeInt safeMax;

    public int current
    {
        get
        {
            return ((safeCurrent)).Value;
        }
        set
        {
            //IL_0002: Unknown result type (might be due to invalid IL or missing references)
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            safeCurrent = new SafeInt(value);
        }
    }

    public int max
    {
        get
        {
            return ((safeMax)).Value;
        }
        set
        {
            //IL_0002: Unknown result type (might be due to invalid IL or missing references)
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            safeMax = new SafeInt(value);
        }
    }

    public Stat(int value)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        safeCurrent = new SafeInt(value);
        safeMax = new SafeInt(value);
    }

    public Stat(int current, int max)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        safeCurrent = new SafeInt(current);
        safeMax = new SafeInt(max);
    }

    public void Max()
    {
        ((safeCurrent)).Value = ((safeMax)).Value;
    }

    public static Stat operator +(Stat a, int b)
    {
        return new Stat(((a.safeCurrent)).Value + b, ((a.safeMax)).Value);
    }

    public static Stat operator -(Stat a, int b)
    {
        return new Stat(((a.safeCurrent)).Value - b, ((a.safeMax)).Value);
    }

    public static Stat operator *(Stat a, int b)
    {
        return new Stat(((a.safeCurrent)).Value * b, ((a.safeMax)).Value);
    }

    public static Stat operator +(Stat a, SafeInt b)
    {
        return new Stat(((a.safeCurrent)).Value + ((b)).Value, ((a.safeMax)).Value);
    }

    public static Stat operator -(Stat a, SafeInt b)
    {
        return new Stat(((a.safeCurrent)).Value - ((b)).Value, ((a.safeMax)).Value);
    }

    public static Stat operator *(Stat a, SafeInt b)
    {
        return new Stat(((a.safeCurrent)).Value * ((b)).Value, ((a.safeMax)).Value);
    }

    public static bool operator ==(Stat a, int b)
    {
        return ((a.safeCurrent)).Value == b;
    }

    public static bool operator !=(Stat a, int b)
    {
        return ((a.safeCurrent)).Value != b;
    }

    public static bool operator >(Stat a, int b)
    {
        return ((a.safeCurrent)).Value > b;
    }

    public static bool operator >=(Stat a, int b)
    {
        return ((a.safeCurrent)).Value >= b;
    }

    public static bool operator <(Stat a, int b)
    {
        return ((a.safeCurrent)).Value < b;
    }

    public static bool operator <=(Stat a, int b)
    {
        return ((a.safeCurrent)).Value <= b;
    }

    public static bool operator ==(int a, Stat b)
    {
        return a == ((b.safeCurrent)).Value;
    }

    public static bool operator !=(int a, Stat b)
    {
        return a != ((b.safeCurrent)).Value;
    }

    public static bool operator >(int a, Stat b)
    {
        return a > ((b.safeCurrent)).Value;
    }

    public static bool operator >=(int a, Stat b)
    {
        return a >= ((b.safeCurrent)).Value;
    }

    public static bool operator <(int a, Stat b)
    {
        return a < ((b.safeCurrent)).Value;
    }

    public static bool operator <=(int a, Stat b)
    {
        return a <= ((b.safeCurrent)).Value;
    }

    public override string ToString()
    {
        return $"{((safeCurrent)).Value}/{((safeMax)).Value}";
    }

    public override bool Equals(object obj)
    {
        if (obj is int num)
        {
            return ((safeCurrent)).Value == num;
        }
        return base.Equals(obj);
    }

    public override int GetHashCode()
    {
        return base.GetHashCode();
    }
}
public class StatusEffectApply
{
    public Entity applier;

    public Entity target;

    public StatusEffectData effectData;

    public int count;

    public StatusEffectApply(Entity applier, Entity target, StatusEffectData effectData, int count)
    {
        this.applier = applier;
        this.target = target;
        this.effectData = effectData;
        this.count = count;
    }
}
public class Trigger
{
    public Entity entity;

    public Entity triggeredBy;

    public Entity[] targets;

    public bool nullified;

    public Hit[] hits;

    public bool countsAsTrigger = true;

    public string type = "basic";

    public bool triggerAgainst;

    public Entity triggerAgainstTarget;

    public CardContainer triggerAgainstContainer;

    public Trigger(Entity entity, Entity triggeredBy, string type, Entity[] targets)
    {
        this.entity = entity;
        this.triggeredBy = triggeredBy;
        this.type = type;
        this.targets = targets;
    }

    public IEnumerator Process()
    {
        string attackerString = (this.entity).name;
        string targetsString = ((targets == null || targets.Length == 0) ? "null" : "");
        if (targets != null)
        {
            for (int i = 0; i < targets.Length; i++)
            {
                if (i > 0)
                {
                    targetsString += ", ";
                }
                Entity entity = targets[i];
                targetsString += ((entity) ? (entity).name : "null");
            }
        }
        Debug.Log(("CardPlayAgainst [" + attackerString + " vs " + targetsString + "]"));
        yield return PreProcess();
        if (this.entity.IsAliveAndExists())
        {
            if (hits.Length != 0)
            {
                yield return Animate();
            }
            yield return ProcessHits();
            yield return PostProcess();
        }
        Debug.Log(("CardPlayAgainst [" + attackerString + " vs " + targetsString + "] DONE"));
    }

    public virtual IEnumerator PreProcess()
    {
        yield return StatusEffectSystem.PreCardPlayedEvent(entity, targets);
        if (!entity.IsAliveAndExists())
        {
            yield break;
        }
        if (hits == null)
        {
            Trigger trigger = this;
            Entity[] array = targets;
            trigger.hits = new Hit[(array != null) ? array.Length : 0];
            if (targets != null)
            {
                for (int i = 0; i < targets.Length; i++)
                {
                    Hit hit = new Hit(entity, targets[i]);
                    hit.AddAttackerStatuses();
                    hit.trigger = this;
                    hits[i] = hit;
                }
            }
        }
        Hit[] array2 = hits;
        foreach (Hit hit2 in array2)
        {
            yield return StatusEffectSystem.PreAttackEvent(hit2);
        }
    }

    public virtual IEnumerator Animate()
    {
        if (entity.HasAttackIcon())
        {
            CardAnimation cardAnimation = AssetLoader.Lookup<CardAnimation>("CardAnimations", "Punch");
            yield return cardAnimation.Routine(this);
        }
        else
        {
            CardAnimation cardAnimation2 = AssetLoader.Lookup<CardAnimation>("CardAnimations", "Supportive");
            yield return cardAnimation2.Routine(this);
        }
    }

    public virtual IEnumerator ProcessHits()
    {
        List<Entity> list = new List<Entity>();
        Routine.Clump clump = new Routine.Clump();
        Hit[] array = hits;
        foreach (Hit hit in array)
        {
            clump.Add(ProcessHit(hit));
            list.Add(hit.target);
        }
        yield return clump.WaitForEnd();
    }

    public virtual IEnumerator PostProcess()
    {
        if (countsAsTrigger)
        {
            yield return StatusEffectSystem.CardPlayedEvent(entity, hits.Select((Hit hit) => hit.target).ToArray());
        }
    }

    public static IEnumerator ProcessHit(Hit hit)
    {
        yield return hit.Process();
        yield return StatusEffectSystem.PostAttackEvent(hit);
    }

    public static CardContainer GetTargetRow(Entity attacker, Entity target)
    {
        CardContainer cardContainer = null;
        int[] rowIndices = GetRowIndices(attacker);
        int[] rowIndices2 = GetRowIndices(target);
        if (rowIndices == null || rowIndices2 == null)
        {
            return null;
        }
        foreach (int item in rowIndices.Intersect(rowIndices2))
        {
            cardContainer = References.Battle.GetRow(target.owner, item);
        }
        if (!(cardContainer))
        {
            cardContainer = ((target.containers.Length != 0) ? target.containers[0] : ((target.preContainers.Length != 0) ? target.preContainers[0] : null));
        }
        return cardContainer;
    }

    public static int[] GetRowIndices(Entity entity)
    {
        if (!entity.alive || !Battle.IsOnBoard(entity.containers))
        {
            if (!Battle.IsOnBoard(entity.preContainers))
            {
                return null;
            }
            return References.Battle.GetRowIndices(entity.preContainers);
        }
        return References.Battle.GetRowIndices(entity);
    }
}
[Serializable]
public struct Tween
{
    public LeanTweenType ease;

    public float dur;

    public bool hasFrom;

    public float scaleFrom;

    public float scaleTo;

    public void Run(GameObject gameObject)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        LeanTween.cancel(gameObject);
        LeanTween.scale(gameObject, Vector3.one * scaleTo, dur).setEase(ease).setFrom(hasFrom ? (Vector3.one * scaleFrom) : gameObject.transform.localScale);
    }
}
[Serializable]
public struct TweenProfile
{
    public LeanTweenType ease;

    public float duration;
}
[CreateAssetMenu(menuName = "Area", fileName = "Area")]
public class AreaData : ScriptableObject
{
    public EventReference battleMusicEvent;

    public EventReference minibossMusicEvent;

    public EventReference bossMusicEvent;

    public EventReference ambienceEvent;

    public AssetReferenceGameObject battleBackgroundPrefabRef;

    public Sprite battleBaseSprite;
}
[CreateAssetMenu(fileName = "BattleData", menuName = "Battle")]
public class BattleData : DataFile
{
    public string title;

    public float pointFactor = 1f;

    public int waveCounter = 4;

    public BattleWavePoolData[] pools;

    public CardData[] bonusUnitPool;

    public Vector2Int bonusUnitRange;

    public CardData[] goldGiverPool;

    public int goldGivers = 1;

    public BattleGenerationScript generationScript;

    public Script setUpScript;

    public Sprite sprite;

    public LocalizedString nameRef;
}
[CreateAssetMenu(fileName = "Battle Wave Pool Data", menuName = "Battle Wave Pool")]
public class BattleWavePoolData : ScriptableObject
{
    [Serializable]
    public struct Wave
    {
        public List<CardData> units;

        public int value;

        public int positionPriority;

        public bool fixedOrder;

        public int maxSize;

        public bool CanAddTo()
        {
            if (maxSize > 0)
            {
                return units.Count < maxSize;
            }
            return true;
        }
    }

    [Range(1f, 5f)]
    public int weight = 1;

    public int forcePulls;

    public int maxPulls = 999;

    public Wave[] waves;

    public int pullCount;

    public List<Wave> workingList;

    public bool CanPull()
    {
        return pullCount < maxPulls;
    }

    public bool MustPull()
    {
        return pullCount < forcePulls;
    }

    public Wave Pull()
    {
        if (workingList == null)
        {
            workingList = new List<Wave>();
        }
        if (workingList.Count <= 0)
        {
            workingList.AddRange(waves);
        }
        if (workingList.Count > 0)
        {
            int index = IListExt.RandomIndex<Wave>((IList<Wave>)workingList);
            Wave result = workingList[index];
            workingList.RemoveAt(index);
            pullCount++;
            return result;
        }
        throw new Exception("BattleWavePoolData \"waves\" list is empty!");
    }

    public void Reset()
    {
        pullCount = 0;
        workingList = null;
    }
}
public abstract class BattleGenerationScript : ScriptableObject
{
    public class WaveList
    {
        public List<BattleWavePoolData.Wave> list;

        public int value;

        public int targetValue;

        public int Count => list.Count;

        public WaveList(int targetValue)
        {
            this.targetValue = targetValue;
        }

        public void Add(BattleWavePoolData.Wave wave)
        {
            if (list == null)
            {
                list = new List<BattleWavePoolData.Wave>();
            }
            if (!wave.fixedOrder)
            {
                IListExt.Shuffle<CardData>((IList<CardData>)wave.units);
            }
            int num = list.Count;
            int positionPriority = wave.positionPriority;
            for (int i = 0; i < list.Count; i++)
            {
                int positionPriority2 = list[i].positionPriority;
                if (positionPriority2 < positionPriority)
                {
                    continue;
                }
                num = i;
                if (positionPriority2 != positionPriority)
                {
                    break;
                }
                for (int j = i + 1; j < list.Count; j++)
                {
                    if (list[j].positionPriority > positionPriority)
                    {
                        num = RandomInclusive.Range(num, j);
                        break;
                    }
                }
                break;
            }
            list.Insert(num, wave);
            value += wave.value;
        }

        public void RemoveAt(int index)
        {
            list.RemoveAt(index);
        }

        public BattleWavePoolData.Wave GetWave(int waveIndex)
        {
            return list[waveIndex];
        }

        public void AddUnit(int waveIndex, CardData unit)
        {
            GetWave(waveIndex).units.Add(unit);
        }

        public bool Satisfied()
        {
            return value >= targetValue;
        }
    }

    public virtual SaveCollection<BattleWaveManager.WaveData> Run(BattleData battleData, int points)
    {
        return default(SaveCollection<BattleWaveManager.WaveData>);
    }

    public void AddGoldGivers(WaveList waves, BattleData battleData)
    {
        if (battleData.goldGivers <= 0 || battleData.goldGiverPool.Length == 0)
        {
            return;
        }
        List<int> list = new List<int>();
        for (int i = 1; i < waves.Count - 1; i++)
        {
            list.Add(i);
        }
        for (int j = 0; j < battleData.goldGivers; j++)
        {
            if (list.Count <= 0)
            {
                break;
            }
            int num = IListExt.RandomItem<int>((IList<int>)list);
            list.Remove(num);
            waves.AddUnit(num, IArrayExt.RandomItem<CardData>(battleData.goldGiverPool));
        }
    }

    public void AddBonusUnits(WaveList waves, BattleData battleData)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        int num = Vector2IntExt.Random(battleData.bonusUnitRange);
        if (num <= 0 || battleData.bonusUnitPool.Length == 0)
        {
            return;
        }
        List<int> list = new List<int>();
        for (int i = 0; i < waves.Count; i++)
        {
            if (waves.GetWave(i).CanAddTo())
            {
                list.Add(i);
            }
        }
        for (int j = 0; j < num; j++)
        {
            if (list.Count <= 0)
            {
                break;
            }
            int num2 = IListExt.RandomItem<int>((IList<int>)list);
            list.Remove(num2);
            waves.AddUnit(num2, IArrayExt.RandomItem<CardData>(battleData.bonusUnitPool));
        }
    }

    public BattleGenerationScript()
    {
    }
}
[CreateAssetMenu(fileName = "FinalBossBattleGenerator", menuName = "Battle Generation Scripts/Final Boss")]
public class BattleGenerationScriptFinalBoss : BattleGenerationScript
{
    [SerializeField]
    public FinalBossGenerationSettings settings;

    [SerializeField]
    public CardType leaderCardType;

    [SerializeField]
    public CardType enemyCardType;

    [Header("Waves")]
    [SerializeField]
    public int waveCount = 3;

    [SerializeField]
    public int leaderWave;

    [SerializeField]
    public int bossWave = 3;

    [SerializeField]
    public int[] waveMaxSize = new int[3] { 6, 6, 6 };

    [SerializeField]
    public bool insertBossAtFront;

    [SerializeField]
    public bool insertLeaderAtFront;

    [Header("Boss")]
    [SerializeField]
    public CardData[] bossOptions;

    [SerializeField]
    public StatusEffectData[] leaderNextPhase;

    [Header("Default Deck")]
    [SerializeField]
    public CardData[] defaultLeaderOptions;

    [SerializeField]
    public bool processDefaultLeader;

    [SerializeField]
    public CardData[] defaultDeck;

    public CardData[] LoadCards(GameMode gameMode)
    {
        if (!gameMode.mainGameMode)
        {
            return null;
        }
        return SaveSystem.LoadProgressData<CardSaveData[]>("finalBossDeck", null)?.LoadArray<CardData, CardSaveData>()?.Where((CardData a) => !MissingCardSystem.IsMissing(a)).ToArray();
    }

    public void GetBaseEnemies(CardData[] cardList, int seed, out List<CardData> enemiesCloned, out bool hasStoredCards, out bool hasLeader, out CardData leaderCloned, out bool hasBoss, out CardData bossCloned)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_02a2: Unknown result type (might be due to invalid IL or missing references)
        State state = Random.state;
        Random.InitState(seed);
        int num = waveMaxSize.Sum();
        leaderCloned = null;
        hasLeader = false;
        hasStoredCards = cardList != null;
        if (!hasStoredCards)
        {
            enemiesCloned = new List<CardData>();
            foreach (CardData item in IEnumerableExt.InRandomOrder<CardData>((IEnumerable<CardData>)defaultDeck))
            {
                enemiesCloned.Add(item.Clone());
                if (enemiesCloned.Count >= num)
                {
                    break;
                }
            }
        }
        else
        {
            List<CardData> list = cardList.Where(delegate (CardData a)
            {
                string name = (a.cardType).name;
                return name == "Friendly" || name == "Enemy" || name == "Leader";
            }).ToList();
            settings.ReplaceCards(list);
            enemiesCloned = new List<CardData>(list.Select((CardData a) => a.Clone(a.random3, runCreateScripts: false)));
            IListExt.Shuffle<CardData>((IList<CardData>)enemiesCloned);
            leaderCloned = enemiesCloned.FirstOrDefault((CardData a) => (a.cardType).name == "Leader");
            if ((leaderCloned))
            {
                hasLeader = true;
                leaderCloned.cardType = leaderCardType;
            }
            settings.Process(leaderCloned, enemiesCloned);
            foreach (CardData item2 in enemiesCloned)
            {
                item2.SetCustomData("eyes", "frost");
            }
        }
        foreach (CardData item3 in enemiesCloned.Where((CardData a) => (a.cardType).name == "Friendly"))
        {
            item3.cardType = enemyCardType;
        }
        if (!hasLeader && defaultLeaderOptions.Length != 0)
        {
            hasLeader = true;
            leaderCloned = IArrayExt.RandomItem<CardData>(defaultLeaderOptions).Clone();
            leaderCloned.cardType = leaderCardType;
            enemiesCloned.Insert(0, leaderCloned);
            if (processDefaultLeader)
            {
                settings.Process(leaderCloned, new List<CardData> { leaderCloned });
            }
        }
        hasBoss = bossOptions.Length != 0;
        bossCloned = null;
        if (hasBoss)
        {
            bossCloned = IArrayExt.RandomItem<CardData>(bossOptions).Clone();
            enemiesCloned.Insert(0, bossCloned);
        }
        int num2 = num + (hasLeader ? 1 : 0) - enemiesCloned.Count;
        if ((num2 > 0) & hasStoredCards)
        {
            enemiesCloned.AddRange(settings.GenerateBonusEnemies(num2, cardList, defaultDeck));
        }
        Random.state = state;
    }

    public override SaveCollection<BattleWaveManager.WaveData> Run(BattleData battleData, int points)
    {
        Debug.Log($"Creating FINAL BOSS WAVES for [{battleData}]");
        CardData[] cardList = LoadCards(Campaign.Data.GameMode);
        GetBaseEnemies(cardList, Campaign.Data.Seed, out var enemiesCloned, out var _, out var hasLeader, out var leaderCloned, out var hasBoss, out var bossCloned);
        if (hasLeader)
        {
            enemiesCloned.Remove(leaderCloned);
        }
        if (hasBoss)
        {
            enemiesCloned.Remove(bossCloned);
        }
        if (hasLeader && leaderNextPhase.Length != 0)
        {
            leaderCloned.startWithEffects = CardData.StatusEffectStacks.Stack(leaderCloned.startWithEffects, new CardData.StatusEffectStacks[1]
            {
                new CardData.StatusEffectStacks(IArrayExt.RandomItem<StatusEffectData>(leaderNextPhase), 1)
            });
        }
        WaveList waveList = new WaveList(Mathf.RoundToInt((float)points * battleData.pointFactor));
        for (int i = 0; i < waveCount; i++)
        {
            waveList.Add(new BattleWavePoolData.Wave
            {
                units = new List<CardData>(),
                maxSize = waveMaxSize[i],
                positionPriority = i
            });
        }
        int num = 0;
        foreach (CardData item in enemiesCloned)
        {
            bool flag = false;
            for (int j = 0; j < waveCount; j++)
            {
                BattleWavePoolData.Wave wave = waveList.GetWave(j % waveCount);
                if (wave.maxSize > 0 && wave.CanAddTo())
                {
                    flag = true;
                    wave.units.Add(item);
                    break;
                }
                num++;
            }
            num++;
            if (!flag)
            {
                break;
            }
        }
        if (hasLeader)
        {
            List<CardData> units = waveList.GetWave(leaderWave).units;
            if (insertLeaderAtFront)
            {
                units.Insert(0, leaderCloned);
            }
            else
            {
                units.Add(leaderCloned);
            }
        }
        if (hasBoss)
        {
            List<CardData> units2 = waveList.GetWave(bossWave).units;
            if (insertBossAtFront)
            {
                units2.Insert(0, bossCloned);
            }
            else
            {
                units2.Add(bossCloned);
            }
        }
        for (int num2 = waveCount - 1; num2 >= 0; num2--)
        {
            if (waveList.GetWave(num2).units.Count <= 0)
            {
                waveList.RemoveAt(num2);
            }
        }
        AddGoldGivers(waveList, battleData);
        AddBonusUnits(waveList, battleData);
        List<BattleWaveManager.WaveData> list = new List<BattleWaveManager.WaveData>();
        int count = waveList.Count;
        for (int k = 0; k < count; k++)
        {
            BattleWaveManager.WaveDataFull waveDataFull = new BattleWaveManager.WaveDataFull
            {
                counter = battleData.waveCounter
            };
            BattleWavePoolData.Wave wave2 = waveList.GetWave(k);
            List<CardSaveData> list2 = new List<CardSaveData>();
            foreach (CardData unit in wave2.units)
            {
                list2.Add(unit.Save());
                if (!waveDataFull.isBossWave && unit.cardType.miniboss)
                {
                    waveDataFull.isBossWave = true;
                }
            }
            waveDataFull.cardDatas = list2.ToArray();
            list.Add(waveDataFull);
        }
        foreach (CardData item2 in enemiesCloned)
        {
            Object.Destroy(item2);
        }
        if ((leaderCloned))
        {
            Object.Destroy(leaderCloned);
        }
        if ((bossCloned))
        {
            Object.Destroy(bossCloned);
        }
        return new SaveCollection<BattleWaveManager.WaveData>(list);
    }
}
[CreateAssetMenu(fileName = "WaveBattleGenerator", menuName = "Battle Generation Scripts/Waves")]
public class BattleGenerationScriptWaves : BattleGenerationScript
{
    public override SaveCollection<BattleWaveManager.WaveData> Run(BattleData battleData, int points)
    {
        Debug.Log($"Creating Waves for [{battleData}]");
        List<BattleWavePoolData> list = new List<BattleWavePoolData>();
        int num = Mathf.RoundToInt((float)points * battleData.pointFactor);
        Debug.Log($"Points: {num}");
        WaveList waveList = new WaveList(num);
        BattleWavePoolData[] pools = battleData.pools;
        for (int i = 0; i < pools.Length; i++)
        {
            BattleWavePoolData battleWavePoolData = Object.Instantiate<BattleWavePoolData>(pools[i]);
            while (battleWavePoolData.MustPull() && battleWavePoolData.CanPull())
            {
                waveList.Add(battleWavePoolData.Pull());
            }
            for (int j = 0; j < battleWavePoolData.weight; j++)
            {
                list.Add(battleWavePoolData);
            }
        }
        while (!waveList.Satisfied() && list.Count > 0)
        {
            BattleWavePoolData battleWavePoolData2 = IListExt.RandomItem<BattleWavePoolData>((IList<BattleWavePoolData>)list);
            if (battleWavePoolData2 != null && battleWavePoolData2.CanPull())
            {
                waveList.Add(battleWavePoolData2.Pull());
                continue;
            }
            list.Remove(battleWavePoolData2);
            Object.Destroy(battleWavePoolData2);
        }
        for (int num2 = list.Count - 1; num2 >= 0; num2--)
        {
            Object.Destroy(list[num2]);
            list.RemoveAt(num2);
        }
        AddGoldGivers(waveList, battleData);
        AddBonusUnits(waveList, battleData);
        List<BattleWaveManager.WaveData> list2 = new List<BattleWaveManager.WaveData>();
        int count = waveList.Count;
        for (int k = 0; k < count; k++)
        {
            BattleWaveManager.WaveDataBasic waveDataBasic = new BattleWaveManager.WaveDataBasic
            {
                counter = battleData.waveCounter
            };
            BattleWavePoolData.Wave wave = waveList.GetWave(k);
            List<string> list3 = new List<string>();
            foreach (CardData unit in wave.units)
            {
                list3.Add((unit).name);
                if (!waveDataBasic.isBossWave && unit.cardType.miniboss)
                {
                    waveDataBasic.isBossWave = true;
                }
            }
            waveDataBasic.cards = list3.Select((string a) => new BattleWaveManager.Card(a)).ToArray();
            list2.Add(waveDataBasic);
        }
        return new SaveCollection<BattleWaveManager.WaveData>(list2);
    }
}
[CreateAssetMenu(menuName = "Battle Lock Data", fileName = "Battle Lock Data")]
public class BattleLockData : ScriptableObject
{
    public string battleName;

    public ChallengeData linkToChallenge;

    public bool IsLocked()
    {
        bool flag = !(SaveSystem.LoadProgressData<List<string>>("completedChallenges", null) ?? new List<string>()).Contains((linkToChallenge).name);
        if (flag)
        {
            Debug.Log(("Battle [" + battleName + "] is locked! Requires [" + (linkToChallenge).name + "]"));
        }
        return flag;
    }
}
[CreateAssetMenu(fileName = "Blood Profile", menuName = "Blood Profile")]
public class BloodProfile : ScriptableObject
{
    public bool variableColor;

    [HideIf("variableColor")]
    public Color color;

    [ShowIf("variableColor")]
    public Gradient colorRange;

    [Range(0f, 2f)]
    public float bleedFactor = 1f;

    public SplatterParticle splatterParticlePrefab;
}
public abstract class BossRewardData : DataFile
{
    public enum Type
    {
        Modifier,
        Charm,
        Crown
    }

    [Serializable]
    public abstract class Data
    {
        public Type type;

        public abstract void Select();

        public Data()
        {
        }
    }

    public abstract Data Pull();

    public BossRewardData()
    {
    }
}
[CreateAssetMenu(menuName = "Boss Rewards/Crown", fileName = "Crown")]
public class BossRewardDataCrown : BossRewardData
{
    [Serializable]
    public new class Data : BossRewardData.Data
    {
        public string upgradeDataName;

        public CardUpgradeData GetUpgrade()
        {
            return AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", StringExt.IsNullOrWhitespace(upgradeDataName) ? "Crown" : upgradeDataName);
        }

        public override void Select()
        {
            CardUpgradeData cardUpgradeData = GetUpgrade().Clone();
            References.PlayerData.inventory.upgrades.Add(cardUpgradeData);
            Events.InvokeUpgradeGained(cardUpgradeData);
        }
    }

    public override BossRewardData.Data Pull()
    {
        return new Data
        {
            type = Type.Crown
        };
    }
}
[CreateAssetMenu(menuName = "Boss Rewards/Modifier", fileName = "Modifier")]
public class BossRewardDataModifier : BossRewardData
{
    [Serializable]
    public new class Data : BossRewardData.Data
    {
        public string modifierName;

        public GameModifierData GetModifier()
        {
            return AddressableLoader.Get<GameModifierData>("GameModifierData", modifierName);
        }

        public override void Select()
        {
            GameModifierData modifier = GetModifier();
            ModifierSystem.AddModifier(Campaign.Data, modifier);
            Routine.Clump clump = new Routine.Clump();
            Script[] startScripts = modifier.startScripts;
            foreach (Script script in startScripts)
            {
                clump.Add(script.Run());
            }
            startScripts = modifier.setupScripts;
            foreach (Script script2 in startScripts)
            {
                clump.Add(script2.Run());
            }
            string[] systemsToAdd = modifier.systemsToAdd;
            foreach (string text in systemsToAdd)
            {
                Debug.Log($"[{modifier}] adding system: {text}");
                GameObjectExt.AddComponentByName(((Component)Campaign.instance).gameObject, text);
            }
        }
    }

    public override BossRewardData.Data Pull()
    {
        string name = (((Component)References.Player).GetComponent<CharacterRewards>().Pull<GameModifierData>(this, "Modifiers")).name;
        return new Data
        {
            type = Type.Modifier,
            modifierName = name
        };
    }
}
[CreateAssetMenu(menuName = "Boss Rewards/Random Charm", fileName = "Random Charm")]
public class BossRewardDataRandomCharm : BossRewardData
{
    [Serializable]
    public new class Data : BossRewardData.Data
    {
        public string upgradeName;

        public CardUpgradeData GetUpgrade()
        {
            return AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", upgradeName);
        }

        public override void Select()
        {
            CardUpgradeData cardUpgradeData = GetUpgrade().Clone();
            References.PlayerData.inventory.upgrades.Add(cardUpgradeData);
            Events.InvokeUpgradeGained(cardUpgradeData);
        }
    }

    [SerializeField]
    public int minTier = 1;

    public override BossRewardData.Data Pull()
    {
        string name = (((Component)References.Player).GetComponent<CharacterRewards>().Pull<CardUpgradeData>(this, "Charms", 1, allowDuplicates: false, CheckTier)[0]).name;
        return new Data
        {
            type = Type.Charm,
            upgradeName = name
        };
    }

    public bool CheckTier(DataFile dataFile)
    {
        if (dataFile is CardUpgradeData cardUpgradeData)
        {
            return cardUpgradeData.tier >= minTier;
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Boss Reward Pool", fileName = "Boss Reward Pool")]
public class BossRewardPool : ScriptableObject
{
    public int areaIndex;

    public int canTake = 2;

    public BossRewardData[] bossRewards;
}
[CreateAssetMenu(fileName = "CampaignGenerator", menuName = "Campaign/Generator")]
public class CampaignGenerator : ScriptableObject
{
    public class Line
    {
        public float x1;

        public float y1;

        public float x2;

        public float y2;

        public Line(float x1, float y1, float x2, float y2)
        {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        }
    }

    public class Node
    {
        public class Connection
        {
            public Node node;

            public Color color = Color.gray;

            public Connection(Node node)
            {
                //IL_0001: Unknown result type (might be due to invalid IL or missing references)
                //IL_0006: Unknown result type (might be due to invalid IL or missing references)
                this.node = node;
            }

            public override string ToString()
            {
                return $"Connection to {node}";
            }
        }

        public float x;

        public float y;

        public float r;

        public int tier;

        public int positionIndex;

        public string type;

        public Color color = Color.white;

        public CampaignNode campaignNode;

        public int areaIndex;

        public readonly List<Connection> connections = new List<Connection>();

        public int connectionCount;

        public bool interactable = true;

        public Node(float x, float y, float r, int tier, int positionIndex, int areaIndex, string type)
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            this.x = x;
            this.y = y;
            this.r = r;
            this.tier = tier;
            this.positionIndex = positionIndex;
            this.areaIndex = areaIndex;
            this.type = type;
        }

        public void Connect(Node other)
        {
            connections.Add(new Connection(other));
            connectionCount++;
            other.connectionCount++;
        }

        public override string ToString()
        {
            return $"Node ({x}, {y})";
        }
    }

    [SerializeField]
    public string seed;

    [SerializeField]
    public Vector2 nodeSizeRange = new Vector2(1.8f, 2f);

    [SerializeField]
    public float nodeCreationRand = 1.5f;

    [SerializeField]
    public Vector2 nodeSpacing = new Vector2(3.2f, 2f);

    [SerializeField]
    public Vector2 battleDistanceRange = new Vector2(13f, 14f);

    [SerializeField]
    public Vector2 mapDirection = new Vector2(0.67f, 0.33f);

    [SerializeField]
    public TextAsset[] presets;

    [SerializeField]
    public bool instant = true;

    [SerializeField]
    public bool restart;

    [SerializeField]
    public bool restartOnError = true;

    public virtual IEnumerator Generate(Campaign campaign)
    {
        SetSeed();
        Debug.Log($"[{this}] GENERATING");
        StopWatch.Start();
        campaign.nodes.Clear();
        Dictionary<string, CampaignNodeType> nodeDict = new Dictionary<string, CampaignNodeType>();
        foreach (CampaignNodeType item in AddressableLoader.GetGroup<CampaignNodeType>("CampaignNodeType"))
        {
            if (!StringExt.IsNullOrWhitespace(item.letter))
            {
                nodeDict[item.letter] = item;
            }
        }
        List<Node> nodes = new List<Node>();
        int attempt = 0;
        while (true)
        {
            Task<bool> task = TryGenerate(campaign, attempt, nodes, nodeDict);
            yield return (object)new WaitUntil((Func<bool>)(() => task.IsCompleted));
            bool error = task.Result;
            attempt++;
            if (!error)
            {
                break;
            }
            Debug.Log("Generation failed!");
            nodes.Clear();
            yield return (object)new WaitUntil((Func<bool>)(() => restart || (error && restartOnError)));
            restart = false;
        }
        Debug.Log($"DONE! ({StopWatch.Stop()}ms) [{attempt} attempts]");
        foreach (Node item2 in nodes.OrderByDescending((Node a) => a.interactable))
        {
            CampaignNodeType type = nodeDict[item2.type];
            item2.campaignNode = new CampaignNode(type, item2.x, item2.y, item2.tier, item2.positionIndex, item2.areaIndex, item2.r);
            campaign.nodes.Add(item2.campaignNode);
            item2.campaignNode.id = campaign.nodes.Count - 1;
        }
        foreach (Node item3 in nodes)
        {
            foreach (Node.Connection connection2 in item3.connections)
            {
                item3.campaignNode.ConnectTo(connection2.node.campaignNode);
            }
        }
        Stack<CampaignNode> stack = new Stack<CampaignNode>();
        List<int> list = new List<int>();
        stack.Push(campaign.nodes[0]);
        while (stack.Count > 0)
        {
            CampaignNode campaignNode = stack.Pop();
            list.Add(campaignNode.id);
            bool flag = campaignNode.connections.Count > 1;
            for (int i = 0; i < campaignNode.connections.Count; i++)
            {
                CampaignNode.Connection connection = campaignNode.connections[i];
                if (!list.Contains(connection.otherId))
                {
                    CampaignNode node = Campaign.GetNode(connection.otherId);
                    bool flag2 = node.connectedTo > 1;
                    node.pathId = (flag2 ? (-1) : (flag ? i : campaignNode.pathId));
                    stack.Push(node);
                }
            }
        }
    }

    public async Task<bool> TryGenerate(Campaign campaign, int attempt, List<Node> nodes, IReadOnlyDictionary<string, CampaignNodeType> nodeDict)
    {
        Debug.Log($"Attempt #{attempt + 1}");
        campaign.preset = ChoosePreset();
        string[] lines = GetPresetLines(campaign.preset);
        Events.InvokeCampaignLoadPreset(ref lines);
        int campaignLength = GetCampaignLength(lines);
        campaign.battleTiers = lines[2];
        List<int> list = new List<int>();
        string battleTiers = campaign.battleTiers;
        for (int i = 0; i < battleTiers.Length; i++)
        {
            int item = int.Parse(battleTiers[i].ToString());
            list.Add(item);
        }
        string text = lines[3];
        int num = 0;
        float num2 = 0f;
        List<Node> list2 = new List<Node>();
        for (int j = 0; j < campaignLength; j++)
        {
            string text2 = text[j].ToString();
            int.TryParse(text2, out var result);
            List<string> list3 = new List<string>();
            for (int k = 0; k <= 1; k++)
            {
                string text3 = lines[k][j].ToString();
                if (!StringExt.IsNullOrWhitespace(text3))
                {
                    list3.Add(text3);
                }
            }
            if (result != num)
            {
                CampaignNodeType type = nodeDict["area" + text2];
                float y = nodeSpacing.y * FloatExt.WithRandomSign(0.25f, 0.5f);
                Node node = CreateNode(num2 - nodeSpacing.x * 0.5f, y, type, list[j], j, result);
                nodes.Add(node);
                node.interactable = false;
            }
            num = result;
            float num3 = (float)(-(list3.Count - 1)) * nodeSpacing.y * 0.5f;
            List<Node> list4 = new List<Node>();
            foreach (string item3 in list3)
            {
                CampaignNodeType type2 = nodeDict[item3];
                Node item2 = CreateNode(num2, num3, type2, list[j], j, result);
                nodes.Add(item2);
                list4.Add(item2);
                num3 += nodeSpacing.y;
            }
            CampaignNodeType type3 = nodeDict[text2];
            for (int l = 0; l < 2; l++)
            {
                Node node2 = CreateNode(num2, nodeSpacing.y * Random.Range(-0.5f, 0.5f), type3, -1, 0, result);
                nodes.Add(node2);
                node2.interactable = false;
            }
            num2 += nodeSpacing.x;
            if (list2.Count > 0)
            {
                int num4 = Mathf.Max(list4.Count, list2.Count);
                for (int m = 0; m < num4; m++)
                {
                    Node other = list4[m % list4.Count];
                    list2[m % list2.Count].Connect(other);
                }
            }
            list2 = list4;
        }
        Events.InvokeCampaignNodesCreated(ref nodes, nodeSpacing);
        await Task.Run(delegate
        {
            ShuffleNodes(nodes);
        });
        bool flag = false;
        foreach (Node node3 in nodes)
        {
            if (!node3.interactable)
            {
                continue;
            }
            foreach (Node.Connection connection in node3.connections)
            {
                Line line = new Line(node3.x, node3.y, connection.node.x, connection.node.y);
                foreach (Node node4 in nodes)
                {
                    if (node4 != node3 && node4 != connection.node && node4.interactable && ((node4.x > node3.x && node4.x < connection.node.x) || (node4.x > connection.node.x && node4.x < node3.x)) && ((node4.y > node3.y && node4.y < connection.node.y) || (node4.y > connection.node.y && node4.y < node3.y)) && LineIntersectsCircle(line, node4.x, node4.y, node4.r))
                    {
                        Debug.Log($"Error: [{connection}] INTERSECTS [{node4}]");
                        connection.color = Color.yellow;
                        node4.color = Color.red;
                        flag = true;
                        break;
                    }
                }
                if (flag)
                {
                    break;
                }
            }
            if (flag)
            {
                break;
            }
        }
        return flag;
    }

    public void SetSeed()
    {
        if (!StringExt.IsNullOrWhitespace(seed))
        {
            Random.InitState(StringExt.ToSeed(seed));
        }
    }

    public TextAsset ChoosePreset()
    {
        if (presets.Length != 0)
        {
            return IArrayExt.RandomItem<TextAsset>(presets);
        }
        throw new Exception("Campaign Generation Error: No Presets Found!");
    }

    public static string[] GetPresetLines(TextAsset preset)
    {
        string[] array = Regex.Split(preset.text, "\r\n|\n|\r");
        if (array.Length > 1)
        {
            int num = array.Length;
            string[] array2 = new string[num];
            for (int i = 0; i < num; i++)
            {
                array2[i] = array[i];
            }
            return array2;
        }
        throw new Exception("Campaign Generation Error: Preset [" + (preset).name + "] Must Contain AT LEAST 2 lines (1st for nodes, last for battle tiers)");
    }

    public static int GetCampaignLength(string[] lines)
    {
        int length = lines[0].Length;
        for (int i = 1; i < lines.Length; i++)
        {
            if (lines[i].Length != length)
            {
                throw new Exception("Campaign Generation Error: Preset line length mismatch — all lines in the preset file must be the same length");
            }
        }
        return length;
    }

    public Node CreateNode(float x, float y, CampaignNodeType type, int tier, int positionIndex, int areaIndex, float r = 1f)
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        Vector2 val = new Vector2(Random.Range(-1f, 1f), Random.Range(-1f, 1f));
        Vector2 val2 = ((val)).normalized * Random.Range(0f, nodeCreationRand);
        x += val2.x;
        y += val2.y;
        return new Node(x, y, Vector2Ext.Random(nodeSizeRange) * type.size * r, tier, positionIndex, areaIndex, type.letter);
    }

    public static void ShuffleNodes(List<Node> nodes)
    {
        //IL_007d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        //IL_008c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0095: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00be: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d3: Unknown result type (might be due to invalid IL or missing references)
        //IL_016e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0178: Unknown result type (might be due to invalid IL or missing references)
        //IL_017f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0184: Unknown result type (might be due to invalid IL or missing references)
        //IL_018d: Unknown result type (might be due to invalid IL or missing references)
        //IL_01a1: Unknown result type (might be due to invalid IL or missing references)
        //IL_01bb: Unknown result type (might be due to invalid IL or missing references)
        //IL_01d5: Unknown result type (might be due to invalid IL or missing references)
        bool flag = true;
        int num = 10000;
        Vector2 val = default(Vector2);
        Vector2 val3 = default(Vector2);
        while (flag && num > 0)
        {
            flag = false;
            foreach (Node node in nodes)
            {
                foreach (Node node2 in nodes)
                {
                    if (node != node2)
                    {
                        ((val))..ctor(node.x - node2.x, node.y - node2.y);
                        if (((val)).magnitude < node.r + node2.r)
                        {
                            Vector2 val2 = ((val)).normalized * 0.01f;
                            node.x += val2.x;
                            node.y += val2.y;
                            node2.x -= val2.x;
                            node2.y -= val2.y;
                            flag = true;
                        }
                    }
                }
                foreach (Node.Connection connection in node.connections)
                {
                    ((val3))..ctor(node.x - connection.node.x, node.y - connection.node.y);
                    float num2 = ((val3)).magnitude - (node.r + connection.node.r);
                    if (num2 > 0f)
                    {
                        Vector2 val4 = ((val3)).normalized * 0.001f * num2;
                        node.x -= val4.x;
                        node.y -= val4.y;
                        connection.node.x += val4.x;
                        connection.node.y += val4.y;
                    }
                }
            }
            num--;
        }
    }

    public static void ShuffleNodes(List<CampaignNode> nodes)
    {
        //IL_0091: Unknown result type (might be due to invalid IL or missing references)
        //IL_009b: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00af: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00dc: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f3: Unknown result type (might be due to invalid IL or missing references)
        //IL_01b7: Unknown result type (might be due to invalid IL or missing references)
        //IL_01c4: Unknown result type (might be due to invalid IL or missing references)
        //IL_01c9: Unknown result type (might be due to invalid IL or missing references)
        //IL_01d8: Unknown result type (might be due to invalid IL or missing references)
        //IL_01ee: Unknown result type (might be due to invalid IL or missing references)
        //IL_0205: Unknown result type (might be due to invalid IL or missing references)
        //IL_021c: Unknown result type (might be due to invalid IL or missing references)
        bool flag = true;
        int num = 10000;
        Vector2 val = default(Vector2);
        Vector2 val3 = default(Vector2);
        while (flag && num > 0)
        {
            flag = false;
            foreach (CampaignNode node in nodes)
            {
                foreach (CampaignNode node2 in nodes)
                {
                    if (node != node2)
                    {
                        ((val))..ctor(node.position.x - node2.position.x, node.position.y - node2.position.y);
                        if (((val)).magnitude < node.radius + node2.radius)
                        {
                            Vector2 val2 = ((val)).normalized * 0.01f;
                            node.position.x += val2.x;
                            node.position.y += val2.y;
                            node2.position.x -= val2.x;
                            node2.position.y -= val2.y;
                            flag = true;
                        }
                    }
                }
                foreach (CampaignNode.Connection c in node.connections)
                {
                    CampaignNode campaignNode = nodes.FirstOrDefault((CampaignNode a) => a.id == c.otherId);
                    if (campaignNode != null)
                    {
                        ((val3))..ctor(node.position.x - campaignNode.position.x, node.position.y - campaignNode.position.y);
                        float num2 = ((val3)).magnitude - (node.radius + campaignNode.radius);
                        if (num2 > 0f)
                        {
                            Vector2 val4 = ((val3)).normalized * (0.001f * num2);
                            node.position.x -= val4.x;
                            node.position.y -= val4.y;
                            campaignNode.position.x += val4.x;
                            campaignNode.position.y += val4.y;
                        }
                    }
                }
            }
            num--;
        }
    }

    public static bool LineIntersectsCircle(Line line, float cx, float cy, float r)
    {
        float num = line.x1 - cx;
        float num2 = line.x2 - cx;
        float num3 = line.y1 - cy;
        float num4 = line.y2 - cy;
        float num5 = num2 - num;
        float num6 = num4 - num3;
        float num7 = num5 * num5 + num6 * num6;
        float num8 = num * num4 - num2 * num3;
        return r * r * num7 > num8 * num8;
    }
}
[CreateAssetMenu(fileName = "CampaignNodeType", menuName = "Campaign/Node Type/Basic")]
public class CampaignNodeType : DataFile
{
    public string letter;

    public string zoneName;

    public bool mustClear;

    public bool canSkip;

    public bool canEnter;

    public bool isBattle;

    public bool isBoss;

    public bool modifierReward;

    public bool interactable;

    public bool startRevealed;

    public bool finalNode;

    public MapNode mapNodePrefab;

    public Sprite mapNodeSprite;

    public float size = 1f;

    public bool canLink;

    public virtual IEnumerator SetUp(CampaignNode node)
    {
        return null;
    }

    public virtual IEnumerator Run(CampaignNode node)
    {
        return null;
    }

    public virtual bool HasMissingData(CampaignNode node)
    {
        return false;
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeBattle", menuName = "Campaign/Node Type/Battle")]
public class CampaignNodeTypeBattle : CampaignNodeType
{
    public EventReference overrideMusic;

    public bool overrideBackground;

    [ShowIf("overrideBackground")]
    public AssetReferenceGameObject background;

    [SerializeField]
    public bool hasRewards;

    public override IEnumerator SetUp(CampaignNode node)
    {
        if (hasRewards)
        {
            CampaignNodeTypeBoss.GetRewards(node);
        }
        yield break;
    }

    public override IEnumerator Run(CampaignNode node)
    {
        yield return Transition.To("Battle");
        BattleSetUp battleSetUp = Object.FindObjectOfType<BattleSetUp>();
        if ((battleSetUp))
        {
            yield return battleSetUp.Run();
        }
        BattleSaveSystem battleSaveSystem = Object.FindObjectOfType<BattleSaveSystem>();
        object value;
        if (battleSaveSystem != null && battleSaveSystem.TryLoadBattleState(node))
        {
            yield return battleSaveSystem.LoadRoutine();
        }
        else if (node.data.TryGetValue("battle", out value) && value is string assetName)
        {
            BattleData battleData = AddressableLoader.Get<BattleData>("BattleData", assetName);
            if (battleData != null && (battleData.setUpScript))
            {
                yield return battleData.setUpScript.Run();
            }
        }
        Transition.End();
        if ((battleSetUp))
        {
            yield return battleSetUp.StartAnimation();
        }
        yield return References.Battle.Run();
        if (Campaign.CheckVictory())
        {
            yield return Transition.WaitUntilDone(Transition.Begin());
            yield return BattleEnd(node);
            new Routine(Sequences.EndCampaign("MainMenu"));
            yield break;
        }
        yield return Transition.WaitUntilDone(Transition.Begin());
        yield return BattleEnd(node);
        yield return Sequences.SceneChange("MapNew");
        Transition.End();
        Events.InvokePostBattle(node);
        yield return ActionQueue.Wait();
        yield return CheckRecovery();
        yield return MapNew.CheckCompanionLimit();
    }

    public static IEnumerator BattleEnd(CampaignNode node)
    {
        Character player = Battle.instance.player;
        if ((player.handContainer))
        {
            player.handContainer.Clear();
        }
        if ((player.reserveContainer))
        {
            player.reserveContainer.Clear();
        }
        if ((player.drawContainer))
        {
            player.drawContainer.Clear();
        }
        if ((player.discardContainer))
        {
            player.discardContainer.Clear();
        }
        List<Entity> cards = References.Battle.cards;
        Debug.Log($"BattleEnd → Destroying [{cards.Count}] Cards!");
        for (int num = cards.Count - 1; num >= 0; num--)
        {
            CardManager.ReturnToPool(cards[num]);
        }
        yield return StatusEffectSystem.Clear();
        if (player.entity.alive && player.data.inventory.reserve != null)
        {
            node.SetCleared();
            if (player.entity.display is CharacterDisplay characterDisplay)
            {
                yield return characterDisplay.handOverlay.Hide();
            }
        }
    }

    public static IEnumerator CheckRecovery()
    {
        if (References.Player.entity.display is CharacterDisplay characterDisplay)
        {
            yield return characterDisplay.deckDisplay.companionRecoverSequence.Run();
        }
    }

    public override bool HasMissingData(CampaignNode node)
    {
        if (node.data.TryGetValue("battle", out var value) && value is string assetName)
        {
            BattleData battleData = AddressableLoader.Get<BattleData>("BattleData", assetName);
            if (battleData != null && (battleData.setUpScript))
            {
                BattleWaveManager.WaveData[] saveCollection = node.data.GetSaveCollection<BattleWaveManager.WaveData>("waves");
                if (saveCollection == null)
                {
                    return true;
                }
                BattleWaveManager.WaveData[] array = saveCollection;
                foreach (BattleWaveManager.WaveData waveData in array)
                {
                    for (int j = 0; j < waveData.Count; j++)
                    {
                        if (waveData.PeekCardData(j) == null)
                        {
                            return true;
                        }
                    }
                }
                return false;
            }
        }
        return true;
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeBoss", menuName = "Campaign/Node Type/Boss")]
public class CampaignNodeTypeBoss : CampaignNodeTypeBattle
{
    [Serializable]
    public class RewardData
    {
        public List<BossRewardData.Data> rewards;

        public int canTake;
    }

    public static void GetRewards(CampaignNode node)
    {
        BossRewardPool bossRewardPool = MonoBehaviourSingleton<References>.instance.bossRewardPools.FirstOrDefault((BossRewardPool a) => a.areaIndex == node.areaIndex);
        if ((bossRewardPool))
        {
            List<BossRewardData.Data> rewards = GetRewards(bossRewardPool);
            CampaignNode campaignNode = node;
            if (campaignNode.data == null)
            {
                campaignNode.data = new Dictionary<string, object>();
            }
            node.data.Add("rewards", new RewardData
            {
                rewards = rewards,
                canTake = bossRewardPool.canTake
            });
        }
    }

    public static List<BossRewardData.Data> GetRewards(BossRewardPool pool)
    {
        List<BossRewardData.Data> list = new List<BossRewardData.Data>();
        Random.InitState(Campaign.FindCharacterNode(References.Player).seed);
        foreach (BossRewardData item2 in IEnumerableExt.InRandomOrder<BossRewardData>((IEnumerable<BossRewardData>)pool.bossRewards))
        {
            BossRewardData.Data item = item2.Pull();
            list.Add(item);
        }
        return list;
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeCharm", menuName = "Campaign/Node Type/Charm")]
public class CampaignNodeTypeCharm : CampaignNodeTypeEvent
{
    [SerializeField]
    public CardUpgradeData force;

    public override IEnumerator SetUp(CampaignNode node)
    {
        yield return null;
        CharacterRewards component = ((Component)References.Player).GetComponent<CharacterRewards>();
        CardUpgradeData cardUpgradeData;
        if ((force))
        {
            cardUpgradeData = force;
            component.PullOut("Charms", cardUpgradeData);
        }
        else
        {
            cardUpgradeData = component.Pull<CardUpgradeData>(node, "Charms");
        }
        node.data = new Dictionary<string, object>
        {
            { "open", false },
            {
                "charm",
                (cardUpgradeData).name
            }
        };
    }

    public override bool HasMissingData(CampaignNode node)
    {
        if (node.data.TryGetValue("charm", out var value) && value is string assetName)
        {
            return AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", assetName) == null;
        }
        return true;
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        EventRoutineCharm eventRoutineCharm = Object.FindObjectOfType<EventRoutineCharm>();
        eventRoutineCharm.node = node;
        yield return eventRoutineCharm.Populate();
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeCharmShop", menuName = "Campaign/Node Type/Charm Shop")]
public class CampaignNodeTypeCharmShop : CampaignNodeTypeEvent
{
    [Serializable]
    public class UpgradedCard
    {
        public CardData cardData;

        public CardUpgradeData[] upgrades;

        public int price;

        public float priceFactor;
    }

    [SerializeField]
    public int cardChoices = 1;

    [SerializeField]
    public UpgradedCard[] forceCards;

    [SerializeField]
    public int choices = 3;

    [SerializeField]
    public CardUpgradeData[] force;

    [SerializeField]
    public Vector2Int priceRange = new Vector2Int(20, 80);

    [SerializeField]
    public int priceOffset = -5;

    public override IEnumerator SetUp(CampaignNode node)
    {
        yield return null;
        CharacterRewards component = ((Component)References.Player).GetComponent<CharacterRewards>();
        List<EventRoutineCharmShop.UpgradedCard> list = new List<EventRoutineCharmShop.UpgradedCard>();
        UpgradedCard[] array = forceCards;
        if (array != null && array.Length > 0)
        {
            array = forceCards;
            foreach (UpgradedCard upgradedCard in array)
            {
                list.Add(new EventRoutineCharmShop.UpgradedCard
                {
                    cardDataName = (upgradedCard.cardData).name,
                    upgradeNames = upgradedCard.upgrades.Select((CardUpgradeData a) => (a).name).ToArray(),
                    price = upgradedCard.price,
                    priceFactor = upgradedCard.priceFactor
                });
                component.PullOut("Items", upgradedCard.cardData);
            }
        }
        int num = cardChoices - list.Count;
        for (int j = 0; j < num; j++)
        {
            CardData card = component.Pull<CardData>(node, "Items");
            int itemCount = 1;
            if (Random.Range(0f, 1f) < 0.01f)
            {
                itemCount = 2;
            }
            CardUpgradeData[] array2 = component.Pull<CardUpgradeData>(node, "Charms", itemCount, allowDuplicates: false, (DataFile a) => a is CardUpgradeData cardUpgradeData3 && cardUpgradeData3.CanAssign(card));
            float num2 = (float)card.value * Random.Range(0.8f, 1.2f) + (float)(array2.Length * Random.Range(10, 20)) + (float)priceOffset;
            EventRoutineCharmShop.UpgradedCard upgradedCard2 = new EventRoutineCharmShop.UpgradedCard
            {
                cardDataName = (card).name,
                price = Mathf.RoundToInt(num2),
                priceFactor = 1f
            };
            if (array2.Length != 0)
            {
                upgradedCard2.upgradeNames = array2.Select((CardUpgradeData a) => (a).name).ToArray();
            }
            list.Add(upgradedCard2);
        }
        List<EventRoutineCharmShop.CharmShopItemData> list2 = new List<EventRoutineCharmShop.CharmShopItemData>();
        CardUpgradeData[] array3 = force;
        if (array3 != null && array3.Length > 0)
        {
            array3 = force;
            foreach (CardUpgradeData cardUpgradeData in array3)
            {
                list2.Add(new EventRoutineCharmShop.CharmShopItemData((cardUpgradeData).name, GetPrice(cardUpgradeData)));
            }
            component.PullOut("Charms", force);
        }
        int num3 = choices - list2.Count;
        for (int k = 0; k < num3; k++)
        {
            CardUpgradeData cardUpgradeData2 = component.Pull<CardUpgradeData>(node, "Charms");
            list2.Add(new EventRoutineCharmShop.CharmShopItemData((cardUpgradeData2).name, GetPrice(cardUpgradeData2)));
        }
        node.data = new Dictionary<string, object> {
        {
            "data",
            new EventRoutineCharmShop.Data
            {
                cards = list,
                items = list2
            }
        } };
    }

    public override bool HasMissingData(CampaignNode node)
    {
        EventRoutineCharmShop.Data data = DictionaryExt.Get<EventRoutineCharmShop.Data>(node.data, "data");
        foreach (EventRoutineCharmShop.UpgradedCard card in data.cards)
        {
            if (MissingCardSystem.IsMissing(card.cardDataName))
            {
                return true;
            }
        }
        foreach (EventRoutineCharmShop.CharmShopItemData item in data.items)
        {
            if (AddressableLoader.Get<CardUpgradeData>("CardUpgradeData", item.upgradeDataName) == null)
            {
                return true;
            }
        }
        return false;
    }

    public int GetPrice(CardUpgradeData upgradeData)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return Vector2IntExt.Random(priceRange) + upgradeData.tier * 10 + priceOffset;
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        EventRoutineCharmShop eventRoutineCharmShop = Object.FindObjectOfType<EventRoutineCharmShop>();
        eventRoutineCharmShop.node = node;
        yield return eventRoutineCharmShop.Populate();
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeClunkShop", menuName = "Campaign/Node Type/Clunk Shop")]
public class CampaignNodeTypeClunkShop : CampaignNodeTypeEvent
{
    [Header("Stock")]
    [SerializeField]
    public int itemCount = 3;

    [SerializeField]
    public int charmCount = 3;

    [SerializeField]
    public CardUpgradeData[] charmPool;

    [Header("Prices")]
    [SerializeField]
    [MinMaxSlider(0f, 2f)]
    public Vector2 priceFactorRange = new Vector2(0.8f, 1.2f);

    [SerializeField]
    public int discounts = 1;

    [SerializeField]
    public float discountFactor = 0.5f;

    [SerializeField]
    public Vector2Int charmPriceRange = new Vector2Int(60, 80);

    public override IEnumerator SetUp(CampaignNode node)
    {
        yield return null;
        CharacterRewards component = ((Component)References.Player).GetComponent<CharacterRewards>();
        EventRoutineClunkShop.Data data = new EventRoutineClunkShop.Data();
        CardData[] obj = component.Pull<CardData>(match: (DataFile a) => a is CardData cardData2 && (cardData2.cardType).name == "Clunker", pulledBy: node, poolName: "Items", itemCount: itemCount, allowDuplicates: false);
        data.cards = new List<EventRoutineClunkShop.CardItem>();
        CardData[] array = obj;
        foreach (CardData cardData in array)
        {
            data.cards.Add(new EventRoutineClunkShop.CardItem(cardData));
        }
        List<CardUpgradeData> list = new List<CardUpgradeData>(charmPool);
        IListExt.Shuffle<CardUpgradeData>((IList<CardUpgradeData>)list);
        data.charms = new List<EventRoutineClunkShop.CharmItem>();
        for (int j = 0; j < charmCount; j++)
        {
            CardUpgradeData cardUpgradeData = ((list.Count > 0) ? list[0] : null);
            if (cardUpgradeData == null)
            {
                break;
            }
            list.RemoveAt(0);
            data.charms.Add(new EventRoutineClunkShop.CharmItem((cardUpgradeData).name, Vector2IntExt.Random(charmPriceRange)));
        }
        if (discounts > 0)
        {
            List<EventRoutineClunkShop.Item> list2 = new List<EventRoutineClunkShop.Item>();
            list2.AddRange(data.cards);
            list2.AddRange(data.charms);
            IListExt.Shuffle<EventRoutineClunkShop.Item>((IList<EventRoutineClunkShop.Item>)list2);
            for (int k = 0; k < discounts; k++)
            {
                EventRoutineClunkShop.Item item = ((list2.Count > 0) ? list2[0] : null);
                if (item == null)
                {
                    break;
                }
                list2.RemoveAt(0);
                item.priceFactor = discountFactor;
            }
        }
        node.data = new Dictionary<string, object> { { "shopData", data } };
    }

    public override bool HasMissingData(CampaignNode node)
    {
        foreach (EventRoutineClunkShop.CardItem card in DictionaryExt.Get<EventRoutineClunkShop.Data>(node.data, "shopData").cards)
        {
            if (MissingCardSystem.IsMissing(card.dataName))
            {
                return true;
            }
        }
        return false;
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        EventRoutineClunkShop eventRoutineClunkShop = Object.FindObjectOfType<EventRoutineClunkShop>();
        eventRoutineClunkShop.node = node;
        yield return eventRoutineClunkShop.Populate();
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeCompanion", menuName = "Campaign/Node Type/Companion")]
public class CampaignNodeTypeCompanion : CampaignNodeTypeEvent
{
    [SerializeField]
    public int choices = 3;

    [SerializeField]
    public List<CardData> force;

    public override IEnumerator SetUp(CampaignNode node)
    {
        yield return null;
        CharacterRewards component = ((Component)References.Player).GetComponent<CharacterRewards>();
        List<CardData> list = IListExt.Clone<CardData>((IEnumerable<CardData>)force);
        if (list.Count > 0)
        {
            component.PullOut("Units", list);
        }
        int itemCount = choices - list.Count;
        list.AddRange(component.Pull<CardData>(node, "Units", itemCount));
        node.data = new Dictionary<string, object>
        {
            { "damage", 0 },
            {
                "cards",
                ((IList<CardData>)list).ToSaveCollectionOfNames<CardData>()
            }
        };
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        EventRoutineCompanion eventRoutineCompanion = Object.FindObjectOfType<EventRoutineCompanion>();
        eventRoutineCompanion.node = node;
        yield return eventRoutineCompanion.Populate();
    }

    public override bool HasMissingData(CampaignNode node)
    {
        return MissingCardSystem.HasMissingData(node.data.GetSaveCollection<string>("cards"));
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeCopyItem", menuName = "Campaign/Node Type/Copy Item")]
public class CampaignNodeTypeCopyItem : CampaignNodeTypeEvent
{
    [SerializeField]
    public int canCopy = 1;

    public override IEnumerator SetUp(CampaignNode node)
    {
        node.data = new Dictionary<string, object>
        {
            { "canCopy", canCopy },
            { "enterCount", 0 }
        };
        yield return null;
    }

    public override bool HasMissingData(CampaignNode node)
    {
        return false;
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        EventRoutineCopyItem eventRoutineCopyItem = Object.FindObjectOfType<EventRoutineCopyItem>();
        eventRoutineCopyItem.node = node;
        yield return eventRoutineCopyItem.Populate();
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeCurseItems", menuName = "Campaign/Node Type/Curse Items")]
public class CampaignNodeTypeCurseItems : CampaignNodeTypeEvent
{
    [SerializeField]
    public int choices = 3;

    [SerializeField]
    public int curseCards = 2;

    [SerializeField]
    public List<CardData> force;

    [SerializeField]
    public CardData[] cursePool;

    [SerializeField]
    public CardData[] extraCards;

    [SerializeField]
    public CardData[] illegalCards;

    public override IEnumerator SetUp(CampaignNode node)
    {
        yield return null;
        Campaign campaign = Object.FindObjectOfType<Campaign>();
        CharacterRewards characterRewards = ((Component)campaign).GetComponent<CharacterRewards>();
        if (!(characterRewards))
        {
            characterRewards = ((Component)campaign).gameObject.AddComponent<CharacterRewards>();
            List<ClassData> group = AddressableLoader.GetGroup<ClassData>("ClassData");
            HashSet<RewardPool> hashSet = new HashSet<RewardPool>();
            foreach (ClassData item2 in group)
            {
                RewardPool[] rewardPools = item2.rewardPools;
                foreach (RewardPool rewardPool in rewardPools)
                {
                    if (rewardPool.type == "Items")
                    {
                        hashSet.Add(rewardPool);
                    }
                }
            }
            foreach (RewardPool item3 in hashSet)
            {
                characterRewards.Add(item3);
            }
            characterRewards.PullOut("Items", illegalCards);
            characterRewards.Add("Items", extraCards);
            characterRewards.RemoveLockedCards();
        }
        List<CardData> list = IListExt.Clone<CardData>((IEnumerable<CardData>)force);
        if (list.Count > 0)
        {
            characterRewards.PullOut("Items", list);
        }
        int itemCount = choices - list.Count;
        list.AddRange(characterRewards.Pull<CardData>(node, "Items", itemCount));
        List<CardData> list2 = new List<CardData>();
        for (int j = 0; j < choices; j++)
        {
            CardData item = ((j < curseCards) ? IArrayExt.RandomItem<CardData>(cursePool) : null);
            list2.Insert(IListExt.RandomIndex<CardData>((IList<CardData>)list2), item);
        }
        node.data = new Dictionary<string, object>
        {
            {
                "cards",
                ToSaveCollectionOfNames((IEnumerable<Object>)list)
            },
            {
                "curses",
                ToSaveCollectionOfNames((IEnumerable<Object>)list2)
            },
            { "analyticsEventSent", false }
        };
    }

    public override bool HasMissingData(CampaignNode node)
    {
        string[] saveCollection = node.data.GetSaveCollection<string>("cards");
        string[] saveCollection2 = node.data.GetSaveCollection<string>("curses");
        if (!MissingCardSystem.HasMissingData(saveCollection))
        {
            return MissingCardSystem.HasMissingData(saveCollection2.Where((string a) => a != null));
        }
        return true;
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        EventRoutineCurseItems eventRoutineCurseItems = Object.FindObjectOfType<EventRoutineCurseItems>();
        eventRoutineCurseItems.node = node;
        yield return eventRoutineCurseItems.Populate();
    }

    public static SaveCollection<string> ToSaveCollectionOfNames(IEnumerable<Object> list)
    {
        string[] collection = list.Select((Object a) => (!Object.op_Implicit(a)) ? null : a.name).ToArray();
        return new SaveCollection<string>(collection);
    }
}
public abstract class CampaignNodeTypeEvent : CampaignNodeType
{
    [SerializeField]
    public AssetReferenceGameObject routinePrefabRef;

    public override IEnumerator Run(CampaignNode node)
    {
        yield return Transition.To("Event");
        AsyncOperationHandle<GameObject> task = ((AssetReference)routinePrefabRef).InstantiateAsync(EventManager.EventRoutineHolder, false);
        yield return (object)new WaitUntil((Func<bool>)(() => task.IsDone));
        EventRoutine eventRoutine = task.Result.GetComponent<EventRoutine>();
        task.Result.AddComponent<AddressableReleaser>().Add(AsyncOperationHandle<GameObject>.op_Implicit(task));
        Events.InvokeEventStart(node, eventRoutine);
        yield return Populate(node);
        Events.InvokeEventPopulated(eventRoutine);
        Transition.End();
        yield return eventRoutine.Run();
        yield return Transition.To("MapNew");
        Transition.End();
        yield return MapNew.CheckCompanionLimit();
    }

    public virtual IEnumerator Populate(CampaignNode node)
    {
        return null;
    }

    public CampaignNodeTypeEvent()
    {
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeGnomeShop", menuName = "Campaign/Node Type/Gnome Shop")]
public class CampaignNodeTypeGnomeShop : CampaignNodeTypeEvent
{
    [SerializeField]
    public int poolSize = 10;

    [SerializeField]
    public int rerollPrice = 10;

    [SerializeField]
    public int rerollPriceAdd = 5;

    public override IEnumerator SetUp(CampaignNode node)
    {
        CardData[] fromOriginalList = ((Component)References.Player).GetComponent<CharacterRewards>().GetFromOriginalList<CardData>(node, "Items", poolSize, allowDuplicates: false);
        EventRoutineGnomeShop.Data value = new EventRoutineGnomeShop.Data
        {
            pool = fromOriginalList.Select((CardData a) => (a).name).ToArray(),
            price = rerollPrice,
            priceAdd = rerollPriceAdd
        };
        node.data = new Dictionary<string, object> { { "data", value } };
        yield break;
    }

    public override bool HasMissingData(CampaignNode node)
    {
        return false;
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        EventRoutineGnomeShop eventRoutineGnomeShop = Object.FindObjectOfType<EventRoutineGnomeShop>();
        eventRoutineGnomeShop.node = node;
        yield return eventRoutineGnomeShop.Populate();
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeGold", menuName = "Campaign/Node Type/Gold")]
public class CampaignNodeTypeGold : CampaignNodeType
{
    [SerializeField]
    public Vector2Int amountRange = new Vector2Int(40, 80);

    [SerializeField]
    public float pauseAfter = 1.5f;

    public override IEnumerator SetUp(CampaignNode node)
    {
        node.data = new Dictionary<string, object> {
        {
            "amount",
            Vector2IntExt.Random(amountRange)
        } };
        yield return null;
    }

    public override IEnumerator Run(CampaignNode node)
    {
        Character player = References.Player;
        Vector3 position = Vector3.zero;
        MapNew mapNew = Object.FindObjectOfType<MapNew>();
        if (mapNew != null)
        {
            MapNode mapNode = mapNew.FindNode(node);
            if (mapNode != null)
            {
                position = ((Component)mapNode).transform.position;
            }
        }
        if ((player) && (player.data?.inventory))
        {
            Events.InvokeDropGold(DictionaryExt.Get<int>(node.data, "amount"), "GoldCave", player, position);
        }
        node.data["amount"] = 0;
        node.SetCleared();
        yield return Sequences.Wait(pauseAfter);
        References.Map.Continue();
    }

    public override bool HasMissingData(CampaignNode node)
    {
        return false;
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeInjuredCompanion", menuName = "Campaign/Node Type/Injured Companion")]
public class CampaignNodeTypeInjuredCompanion : CampaignNodeTypeEvent
{
    public override IEnumerator SetUp(CampaignNode node)
    {
        RunHistory mostRecentRun = InjuredCompanionEventSystem.GetMostRecentRun();
        if (mostRecentRun != null)
        {
            List<CardSaveData> eligibleCompanions = InjuredCompanionEventSystem.GetEligibleCompanions(mostRecentRun);
            if (eligibleCompanions.Count > 0)
            {
                CardSaveData cardSaveData = IListExt.RandomItem<CardSaveData>((IList<CardSaveData>)eligibleCompanions);
                CharacterRewards component = ((Component)References.Player).GetComponent<CharacterRewards>();
                CardData item = AddressableLoader.Get<CardData>("CardData", cardSaveData.name);
                component.PullOut("Units", item);
                node.data = new Dictionary<string, object> { { "cardSaveData", cardSaveData } };
            }
        }
        yield return null;
    }

    public override bool HasMissingData(CampaignNode node)
    {
        return false;
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        EventRoutineInjuredCompanion eventRoutineInjuredCompanion = Object.FindObjectOfType<EventRoutineInjuredCompanion>();
        eventRoutineInjuredCompanion.node = node;
        yield return eventRoutineInjuredCompanion.Populate();
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeItem", menuName = "Campaign/Node Type/Item")]
public class CampaignNodeTypeItem : CampaignNodeTypeEvent
{
    [SerializeField]
    public int choices = 3;

    [SerializeField]
    public List<CardData> force;

    public override IEnumerator SetUp(CampaignNode node)
    {
        yield return null;
        CharacterRewards component = ((Component)References.Player).GetComponent<CharacterRewards>();
        List<CardData> list = IListExt.Clone<CardData>((IEnumerable<CardData>)force);
        if (list.Count > 0)
        {
            component.PullOut("Items", list);
        }
        int itemCount = choices - list.Count;
        list.AddRange(component.Pull<CardData>(node, "Items", itemCount));
        node.data = new Dictionary<string, object>
        {
            { "open", false },
            {
                "cards",
                ((IList<CardData>)list).ToSaveCollectionOfNames<CardData>()
            }
        };
    }

    public override bool HasMissingData(CampaignNode node)
    {
        return MissingCardSystem.HasMissingData(node.data.GetSaveCollection<string>("cards"));
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        ItemEventRoutine itemEventRoutine = Object.FindObjectOfType<ItemEventRoutine>();
        itemEventRoutine.node = node;
        yield return itemEventRoutine.Populate();
    }
}
[CreateAssetMenu(fileName = "CampaignNodeJournalPage", menuName = "Campaign/Node Type/Journal Page")]
public class CampaignNodeTypeJournalPage : CampaignNodeType
{
    [SerializeField]
    public UnlockData unlock;

    public override IEnumerator Run(CampaignNode node)
    {
        List<string> unlockedList = MetaprogressionSystem.GetUnlockedList();
        if (!unlockedList.Contains((unlock).name))
        {
            unlockedList.Add((unlock).name);
            SaveSystem.SaveProgressData("unlocked", unlockedList);
        }
        node.SetCleared();
        PauseMenu pauseMenu = Object.FindObjectOfType<PauseMenu>(true);
        if (pauseMenu != null)
        {
            pauseMenu.OpenLorePages();
            yield return (object)new WaitUntil((Func<bool>)(() => !((Component)pauseMenu).gameObject.activeSelf));
        }
        References.Map.Continue();
    }

    public override bool HasMissingData(CampaignNode node)
    {
        return false;
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeMuncher", menuName = "Campaign/Node Type/Muncher")]
public class CampaignNodeTypeMuncher : CampaignNodeTypeEvent
{
    [SerializeField]
    public int canEat = 2;

    public override IEnumerator SetUp(CampaignNode node)
    {
        node.data = new Dictionary<string, object>
        {
            { "canEat", canEat },
            { "enterCount", 0 },
            { "openCount", 0 },
            { "thankCount", 0 }
        };
        yield return null;
    }

    public override bool HasMissingData(CampaignNode node)
    {
        return false;
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        EventRoutineMuncher eventRoutineMuncher = Object.FindObjectOfType<EventRoutineMuncher>();
        eventRoutineMuncher.node = node;
        yield return eventRoutineMuncher.Populate();
    }
}
[CreateAssetMenu(fileName = "CampaignNodeTypeShop", menuName = "Campaign/Node Type/Shop")]
public class CampaignNodeTypeShop : CampaignNodeTypeEvent
{
    [Serializable]
    public struct Stock
    {
        public AnimationCurve companions;

        public bool companionsCanDiscount;

        public AnimationCurve items;

        public bool itemsCanDiscount;

        public AnimationCurve consumables;

        public bool consumablesCanDiscount;

        public AnimationCurve charms;

        public int companionCount => Mathf.RoundToInt(companions.Evaluate(Random.value));

        public int itemCount => Mathf.RoundToInt(items.Evaluate(Random.value));

        public int consumableCount => Mathf.RoundToInt(consumables.Evaluate(Random.value));

        public int charmCount => Mathf.RoundToInt(charms.Evaluate(Random.value));
    }

    [SerializeField]
    public Stock stock;

    [Header("Prices")]
    [SerializeField]
    [MinMaxSlider(0f, 2f)]
    public Vector2 priceFactorRange = new Vector2(0.8f, 1.2f);

    [SerializeField]
    public int discounts = 1;

    [SerializeField]
    public float discountFactor = 0.5f;

    [SerializeField]
    public int charmPrice = 50;

    [SerializeField]
    public int charmPriceAdd = 20;

    [SerializeField]
    public int crownPrice = 80;

    [SerializeField]
    public int crownPriceAdd = 30;

    [SerializeField]
    public int priceOffset = -5;

    public override IEnumerator SetUp(CampaignNode node)
    {
        yield return null;
        CharacterRewards component = ((Component)References.Player).GetComponent<CharacterRewards>();
        Dictionary<string, DataFile[]> obj = new Dictionary<string, DataFile[]>
        {
            ["Companions"] = component.Pull<DataFile>(node, "Units", stock.companionCount),
            ["Items"] = component.Pull<DataFile>(match: (DataFile a) => a is CardData cardData3 && (cardData3.cardType).name == "Item" && !cardData3.traits.Exists((CardData.TraitStacks b) => (b.data).name == "Consume"), pulledBy: node, poolName: "Items", itemCount: stock.itemCount, allowDuplicates: false),
            ["Consumables"] = component.Pull<DataFile>(match: (DataFile a) => a is CardData cardData2 && (cardData2.cardType).name == "Item" && cardData2.traits.Exists((CardData.TraitStacks b) => (b.data).name == "Consume"), pulledBy: node, poolName: "Items", itemCount: stock.consumableCount, allowDuplicates: false)
        };
        ShopRoutine.Data data = new ShopRoutine.Data
        {
            charmPrice = charmPrice,
            charmPriceAdd = charmPriceAdd,
            crownPrice = crownPrice,
            crownPriceAdd = crownPriceAdd
        };
        foreach (KeyValuePair<string, DataFile[]> item2 in obj)
        {
            item2.Deconstruct(out var key, out var value);
            string category = key;
            DataFile[] array = value;
            if (array == null)
            {
                continue;
            }
            value = array;
            for (int i = 0; i < value.Length; i++)
            {
                if (value[i] is CardData cardData)
                {
                    ShopRoutine.Item item = new ShopRoutine.Item(category, cardData, priceOffset, Vector2Ext.Random(priceFactorRange));
                    data.items.Add(item);
                }
            }
        }
        CardUpgradeData[] array2 = component.Pull<CardUpgradeData>(node, "Charms", stock.charmCount);
        foreach (CardUpgradeData cardUpgradeData in array2)
        {
            data.charms.Add((cardUpgradeData).name);
        }
        List<ShopRoutine.Item> list = new List<ShopRoutine.Item>();
        foreach (ShopRoutine.Item item3 in data.items)
        {
            if (item3.category == "Companions" && stock.companionsCanDiscount)
            {
                list.Add(item3);
            }
            else if (item3.category == "Items" && stock.itemsCanDiscount)
            {
                list.Add(item3);
            }
            else if (item3.category == "Consumables" && stock.consumablesCanDiscount)
            {
                list.Add(item3);
            }
        }
        for (int j = 0; j < discounts; j++)
        {
            if (list.Count > 0)
            {
                int index = IListExt.RandomIndex<ShopRoutine.Item>((IList<ShopRoutine.Item>)list);
                list[index].priceFactor = discountFactor;
                list.RemoveAt(index);
            }
        }
        node.data = new Dictionary<string, object> { { "shopData", data } };
    }

    public override IEnumerator Populate(CampaignNode node)
    {
        ShopRoutine shopRoutine = Object.FindObjectOfType<ShopRoutine>();
        shopRoutine.node = node;
        yield return shopRoutine.Populate();
    }

    public override bool HasMissingData(CampaignNode node)
    {
        foreach (ShopRoutine.Item item in DictionaryExt.Get<ShopRoutine.Data>(node.data, "shopData").items)
        {
            if (MissingCardSystem.IsMissing(item.cardDataName))
            {
                return true;
            }
        }
        return false;
    }
}
[CreateAssetMenu(fileName = "CampaignPopulator", menuName = "Campaign/Populator")]
public class CampaignPopulator : ScriptableObject
{
    public class Tier
    {
        public int number;

        public List<CampaignNode> nodes = new List<CampaignNode>();

        public List<BattleData> battles = new List<BattleData>();

        public List<CampaignNodeType> rewards = new List<CampaignNodeType>();

        public CampaignTier campaignTier;

        public Tier(int number, CampaignTier campaignTier)
        {
            this.number = number;
            this.campaignTier = campaignTier;
        }

        public BattleData PullBattle(CampaignPopulator campaignPopulator)
        {
            if (battles.Count <= 0)
            {
                BattleData[] battlePool = campaignTier.battlePool;
                foreach (BattleData battleData in battlePool)
                {
                    if (!campaignPopulator.BattleIsLocked((battleData).name))
                    {
                        battles.Add(battleData);
                    }
                }
            }
            BattleData battleData2 = IListExt.RandomItem<BattleData>((IList<BattleData>)battles);
            battles.Remove(battleData2);
            return battleData2;
        }

        public int GetBattlePoints()
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            return Vector2IntExt.Random(campaignTier.pointRange);
        }

        public CampaignNodeType PullReward()
        {
            if (rewards.Count <= 0)
            {
                rewards.AddRange(campaignTier.rewardPool);
            }
            CampaignNodeType campaignNodeType = IListExt.RandomItem<CampaignNodeType>((IList<CampaignNodeType>)rewards);
            rewards.Remove(campaignNodeType);
            return campaignNodeType;
        }
    }

    [SerializeField]
    public bool removeLockedCards = true;

    [SerializeField]
    public CampaignTier[] tiers;

    [SerializeField]
    public int playerStartNodeId;

    [SerializeField]
    public BattleLockData[] battleLockers;

    public void LoadCharacters(Campaign campaign, CharacterSaveData[] data)
    {
        for (int i = 0; i < data.Length; i++)
        {
            Character character = data[i].Load();
            ((Component)character).transform.SetParent(campaign.characterContainer);
            campaign.characters.Add(character);
        }
    }

    public IEnumerator Populate(Campaign campaign)
    {
        Debug.Log($"[{this}] POPULATING");
        StopWatch.Start();
        TransformExt.DestroyAllChildren(campaign.characterContainer);
        Character character = Object.Instantiate<Character>(References.PlayerData.classData.characterPrefab, campaign.characterContainer);
        (character).name = "Player (" + character.title + ")";
        campaign.characters.Add(character);
        campaign.nodes[playerStartNodeId].characters.Add(campaign.characters.Count - 1);
        for (int i = 0; i < playerStartNodeId; i++)
        {
            CampaignNode campaignNode = campaign.nodes[i];
            if (campaignNode.type.interactable)
            {
                campaignNode.revealed = true;
                campaignNode.SetCleared();
            }
        }
        References.Player = character;
        character.Assign(References.PlayerData);
        CharacterRewards component = ((Component)character).GetComponent<CharacterRewards>();
        if (component != null)
        {
            component.Populate(character.data.classData);
            if (removeLockedCards)
            {
                component.RemoveLockedCards();
            }
            component.RemoveCardsFromStartingDeck();
            if (Campaign.Data.GameMode.mainGameMode)
            {
                component.RemoveCompanionsInFinalBossBattle();
            }
        }
        CharacterDisplay.FindAndAssign(character);
        List<int> list = new List<int>();
        string battleTiers = campaign.battleTiers;
        for (int j = 0; j < battleTiers.Length; j++)
        {
            int item = int.Parse(battleTiers[j].ToString());
            list.Add(item);
        }
        List<Tier> list2 = new List<Tier>();
        foreach (CampaignNode node in campaign.nodes)
        {
            int tierNumber = list[node.positionIndex];
            Tier tier = list2.Find((Tier a) => a.number == tierNumber);
            if (tier == null)
            {
                tier = new Tier(tierNumber, tiers[tierNumber]);
                tier.nodes.Add(node);
                list2.Add(tier);
            }
            else
            {
                tier.nodes.Add(node);
            }
        }
        foreach (Tier item2 in list2)
        {
            foreach (CampaignNode node2 in item2.nodes)
            {
                if (node2.type.isBattle)
                {
                    BattleData battleData = item2.PullBattle(this);
                    int battlePoints = item2.GetBattlePoints();
                    node2.data = new Dictionary<string, object>
                    {
                        ["battle"] = (battleData).name,
                        ["waves"] = battleData.generationScript.Run(battleData, battlePoints)
                    };
                }
                else if ((node2.type).name == "CampaignNodeReward")
                {
                    node2.SetType(item2.PullReward());
                }
            }
        }
        Dictionary<CampaignNode, CampaignNode> links = LinkNodes(list2);
        Routine.Clump clump = new Routine.Clump();
        foreach (CampaignNode node3 in campaign.nodes)
        {
            if (!links.ContainsKey(node3))
            {
                clump.Add(node3.type.SetUp(node3));
            }
        }
        yield return clump.WaitForEnd();
        foreach (KeyValuePair<CampaignNode, CampaignNode> item3 in links)
        {
            item3.Key.CopyData(item3.Value);
        }
        Debug.Log($"DONE ({StopWatch.Stop()}ms)");
        yield return null;
    }

    public bool BattleIsLocked(string battleName)
    {
        return battleLockers.FirstOrDefault((BattleLockData a) => a.battleName == battleName)?.IsLocked() ?? false;
    }

    public static Dictionary<CampaignNode, CampaignNode> LinkNodes(List<Tier> currentTiers)
    {
        Dictionary<CampaignNode, CampaignNode> links = new Dictionary<CampaignNode, CampaignNode>();
        foreach (Tier currentTier in currentTiers)
        {
            foreach (CampaignNode node in currentTier.nodes)
            {
                if (!node.type.canLink || links.ContainsKey(node) || links.ContainsValue(node) || node.pathId < 0)
                {
                    continue;
                }
                CampaignNode campaignNode = (from a in currentTier.nodes
                                             where !links.ContainsKey(a) && !links.ContainsValue(a) && a.type.canLink && a.id != node.id && a.pathId != node.pathId && a.pathId >= 0 && (a.type).name == (node.type).name
                                             orderby a.id
                                             select a).FirstOrDefault();
                if (campaignNode != null)
                {
                    node.dataLinkedTo = campaignNode.id;
                    CampaignNode campaignNode2 = campaignNode;
                    if (campaignNode2.linkedToThis == null)
                    {
                        campaignNode2.linkedToThis = new List<int>();
                    }
                    campaignNode.linkedToThis.Add(node.id);
                    links.Add(node, campaignNode);
                }
            }
        }
        return links;
    }
}
[CreateAssetMenu(fileName = "Campaign Tier", menuName = "Campaign/Tier")]
public class CampaignTier : ScriptableObject
{
    public Vector2Int pointRange;

    public BattleData[] battlePool;

    public CampaignNodeType[] rewardPool;
}
public abstract class CardAnimation : ScriptableObject
{
    public virtual IEnumerator Routine(object data, float startDelay = 0f)
    {
        return null;
    }

    public CardAnimation()
    {
    }
}
[CreateAssetMenu(fileName = "BombardRocket", menuName = "Card Animation/Bombard Rocket")]
public class CardAnimationBombardRocket : CardAnimation
{
    [Header("Rocket")]
    [SerializeField]
    public BombardRocket rocketPrefab;

    [SerializeField]
    public float rocketDuration = 0.67f;

    [SerializeField]
    public Vector3 startPosOffset = new Vector3(0f, 10f, 0f);

    [SerializeField]
    public Vector3 endPosOffset = new Vector3(0f, 0.1f, 0f);

    [SerializeField]
    public AnimationCurve rocketMoveCurve;

    public override IEnumerator Routine(object data, float startDelay = 0f)
    {
        if (data is Vector3 val)
        {
            Vector3 to = val + endPosOffset;
            Vector3 val2 = val + startPosOffset;
            BombardRocket rocket = Object.Instantiate<BombardRocket>(rocketPrefab, val2, Quaternion.identity);
            LeanTween.move(((Component)rocket).gameObject, to, rocketDuration).setEase(rocketMoveCurve);
            Events.InvokeBombardRocketFall(rocket);
            yield return (object)new WaitForSeconds(rocketDuration);
            Events.InvokeBombardRocketExplode(rocket);
            rocket.Explode();
        }
    }
}
[CreateAssetMenu(fileName = "BombardRocketShoot", menuName = "Card Animation/Bombard Rocket Shoot")]
public class CardAnimationBombardRocketShoot : CardAnimation
{
    [Header("Shoot Particles")]
    [SerializeField]
    public ParticleSystem shootFxPrefab;

    [SerializeField]
    public Vector3 shootAngle = new Vector3(0f, 0f, 135f);

    [SerializeField]
    public Vector3 shootFxOffset = new Vector3(0f, 1f, 0f);

    [SerializeField]
    public float shootScreenShake = 1f;

    [Header("Recoil Animation")]
    [SerializeField]
    public Vector3 recoilOffset = new Vector3(1f, -1f, 0f);

    [SerializeField]
    public AnimationCurve recoilCurve;

    [SerializeField]
    public float recoilDuration = 1f;

    public override IEnumerator Routine(object data, float startDelay = 0f)
    {
        if (data is Entity entity)
        {
            ParticleSystem shootFx = Object.Instantiate<ParticleSystem>(shootFxPrefab, entity.transform.position + shootFxOffset, Quaternion.Euler(shootAngle));
            Events.InvokeScreenShake(shootScreenShake, shootAngle.z + 180f);
            Events.InvokeBombardShoot(entity);
            entity.curveAnimator?.Move(recoilOffset, recoilCurve, 1f, 1f);
            yield return (object)new WaitUntil((Func<bool>)(() => !(shootFx)));
        }
    }
}
[CreateAssetMenu(fileName = "ClunkerBossPhaseChange", menuName = "Card Animation/Clunker Boss Change")]
public class CardAnimationClunkerBossChange : CardAnimation
{
    [SerializeField]
    public Vector2Int explosionCountRange = new Vector2Int(3, 5);

    [SerializeField]
    public Vector2 explosionDelayRange = new Vector2(0.1f, 0.6f);

    [SerializeField]
    public ParticleSystem explosionStart;

    [SerializeField]
    public ParticleSystem explosion;

    [SerializeField]
    public ParticleSystem explosionEnd;

    [SerializeField]
    public float explosionPositionRandom = 1f;

    [SerializeField]
    public float duration = 1f;

    [SerializeField]
    public float rumbleAmount = 0.5f;

    [SerializeField]
    public float rumbleDurationIn = 0.5f;

    [SerializeField]
    public float rumbleDurationOut = 0.25f;

    public override IEnumerator Routine(object data, float startDelay = 0f)
    {
        if (data is Entity target)
        {
            SfxSystem.OneShot("event:/sfx/specific/boss_phase_change");
            float num = Mathf.Max(startDelay, duration);
            if (rumbleAmount > 0f)
            {
                Events.InvokeScreenRumble(0f, rumbleAmount, 0f, rumbleDurationIn, Mathf.Max(0f, duration - rumbleDurationIn), rumbleDurationOut);
            }
            if ((explosionStart))
            {
                Explode(explosionStart, target.transform.position + RandomOffset());
            }
            int num2 = Vector2IntExt.Random(explosionCountRange);
            Routine.Clump clump = new Routine.Clump();
            for (int i = 0; i < num2; i++)
            {
                Vector3 position = target.transform.position + RandomOffset();
                clump.Add(ExplodeAfterDelay(num * Vector2Ext.PettyRandom(explosionDelayRange), position));
            }
            clump.Add(Sequences.Wait(num));
            yield return clump.WaitForEnd();
            Explode(explosionEnd, target.transform.position, 2f);
            target.curveAnimator?.Ping();
        }
    }

    public Vector3 RandomOffset()
    {
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = new Vector3(PettyRandom.Range(-1f, 1f), PettyRandom.Range(-1f, 1f), 0f);
        return ((val)).normalized * PettyRandom.Range(0f, explosionPositionRandom);
    }

    public IEnumerator ExplodeAfterDelay(float delay, Vector3 position)
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        yield return (object)new WaitForSeconds(delay);
        Explode(explosion, position);
    }

    public void Explode(ParticleSystem prefab, Vector3 position, float screenShake = 1f)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        Object.Instantiate<ParticleSystem>(prefab, position, Quaternion.identity);
        Events.InvokeScreenShake(screenShake, 0f);
    }
}
[CreateAssetMenu(fileName = "FlyToBackpack", menuName = "Card Animation/Fly To Backpack")]
public class CardAnimationFlyToBackpack : CardAnimation
{
    [SerializeField]
    public AnimationCurve xCurve;

    [SerializeField]
    public AnimationCurve yCurve;

    [SerializeField]
    public AnimationCurve zCurve;

    [SerializeField]
    public AnimationCurve spinCurve;

    [SerializeField]
    public AnimationCurve scaleCurve;

    [SerializeField]
    public bool destroyOnEnd = true;

    [Header("Duration")]
    [SerializeField]
    public bool fixedDuration;

    [SerializeField]
    [ShowIf("fixedDuration")]
    public float duration = 0.5f;

    [SerializeField]
    [HideIf("fixedDuration")]
    public AnimationCurve durationToDistance;

    [Header("Glows")]
    [SerializeField]
    public AnimationCurve glowMain;

    [SerializeField]
    public Vector2 glowMainSize = new Vector2(4f, 6f);

    [SerializeField]
    public AnimationCurve glowExtra;

    [SerializeField]
    public int glowExtraCount = 4;

    [SerializeField]
    public Rect glowExtraArea = new Rect(-0.7f, -1.3f, 1.4f, 2.6f);

    [SerializeField]
    public Vector2 glowExtraSizeRange = new Vector2(2f, 3f);

    [SerializeField]
    public Vector2 glowExtraDelay = new Vector2(0f, 0.5f);

    [SerializeField]
    public Glow glowPrefab;

    [Header("Jump")]
    [SerializeField]
    public AnimationCurve yUpCurve;

    [SerializeField]
    public float yUpAmount = 0.25f;

    public override IEnumerator Routine(object data, float startDelay = 0f)
    {
        if (!(data is Entity { transform: { } target } entity))
        {
            yield break;
        }
        yield return (object)new WaitForSeconds(startDelay);
        Deckpack deckpack = MonoBehaviourSingleton<Deckpack>.instance;
        if (deckpack == null)
        {
            yield break;
        }
        target.SetParent(((Component)deckpack).transform, true);
        AngleWobbler[] wobblers = ((Component)target).GetComponentsInChildren<AngleWobbler>();
        AngleWobbler[] array = wobblers;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].globalSpace = false;
        }
        Vector3 start = target.localPosition;
        Vector3 zero = Vector3.zero;
        Vector3 offset = zero - start;
        float t = 0f;
        float z = target.localEulerAngles.z;
        Vector3 scale = target.localScale;
        float num;
        if (!fixedDuration)
        {
            AnimationCurve obj = durationToDistance;
            Vector3 val = Vector3Ext.WithZ(offset, 0f);
            num = obj.Evaluate(((val)).magnitude);
        }
        else
        {
            num = duration;
        }
        float dur = num;
        Object.Instantiate<Glow>(glowPrefab, target).SetColor(Color.white).SetPosition(Vector2.zero)
            .SetSize(glowMainSize)
            .Fade(glowMain, dur);
        for (int j = 0; j < glowExtraCount; j++)
        {
            float num2 = Vector2Ext.PettyRandom(glowExtraDelay);
            float num3 = dur - num2;
            Object.Instantiate<Glow>(glowPrefab, target).RandomColor().SetPosition(RectExt.RandomPosition(glowExtraArea))
                .SetSize(Vector2.one * Vector2Ext.PettyRandom(glowExtraSizeRange))
                .Fade(glowExtra, num3, num2);
        }
        yield return null;
        while (t < 1f && (target))
        {
            t += Time.deltaTime / dur;
            target.localPosition = start + Vector3Ext.Multiply(offset, xCurve.Evaluate(t), yCurve.Evaluate(t), zCurve.Evaluate(t)) + Vector3.up * yUpCurve.Evaluate(t) * yUpAmount;
            target.localEulerAngles = Vector3Ext.WithZ(target.localEulerAngles, z + spinCurve.Evaluate(t));
            target.localScale = scale * scaleCurve.Evaluate(t);
            yield return null;
        }
        if (destroyOnEnd && (target))
        {
            entity.RemoveFromContainers();
            CardManager.ReturnToPool(entity);
            array = wobblers;
            foreach (AngleWobbler angleWobbler in array)
            {
                if ((angleWobbler))
                {
                    angleWobbler.globalSpace = true;
                }
            }
        }
        if ((deckpack))
        {
            deckpack.Ping();
        }
    }
}
[CreateAssetMenu(fileName = "Miniboss Intro", menuName = "Card Animation/Miniboss Intro")]
public class CardAnimationMinibossIntro : CardAnimation
{
    [SerializeField]
    public float rumbleAmount = 1f;

    [SerializeField]
    public float wobbleAmount = 1f;

    [SerializeField]
    public CurveProfile scaleTween;

    [SerializeField]
    public Vector3 scaleTo = new Vector3(1f, 1f, 1f);

    [SerializeField]
    public CurveProfile rotateTween;

    [SerializeField]
    public Vector3 rotateAmount = new Vector3(1f, 1f, 5f);

    public override IEnumerator Routine(object data, float startDelay = 0f)
    {
        if (data is Entity target)
        {
            yield return (object)new WaitForSeconds(startDelay);
            float num = Mathf.Max(scaleTween.duration, rotateTween.duration);
            Events.InvokeScreenRumble(0f, rumbleAmount, 0f, num * 0.5f, num * 0.5f, num * 0.5f);
            target.wobbler?.WobbleRandom(wobbleAmount);
            LeanTween.scale(((Component)target).gameObject, scaleTo, scaleTween.duration).setEase(scaleTween.curve);
            LeanTween.rotateLocal(((Component)target).gameObject, rotateAmount, rotateTween.duration).setEase(rotateTween.curve);
            yield return (object)new WaitForSeconds(num);
        }
    }
}
[CreateAssetMenu(fileName = "Overburn", menuName = "Card Animation/Overburn")]
public class CardAnimationOverburn : CardAnimation
{
    public override IEnumerator Routine(object data, float startDelay = 0f)
    {
        if (data is Entity target)
        {
            yield return (object)new WaitForSeconds(startDelay);
            CurveAnimator curveAnimator = target.curveAnimator;
            if (curveAnimator != null)
            {
                curveAnimator.Scale(Vector3.one * 0.85f, Curves.Get("Buildup"), 0.67f);
                yield return (object)new WaitForSeconds(0.67f);
            }
        }
    }
}
[CreateAssetMenu(fileName = "Ping", menuName = "Card Animation/Ping")]
public class CardAnimationPing : CardAnimation
{
    [SerializeField]
    public bool waitForEnd;

    public override IEnumerator Routine(object data, float startDelay = 0f)
    {
        if (data is not Entity target)
        {
            yield break;
        }
        yield return (object)new WaitForSeconds(startDelay);
        CurveAnimator curveAnimator = target.curveAnimator;
        if (curveAnimator != null)
        {
            curveAnimator.Ping();
            if (waitForEnd)
            {
                yield return (object)new WaitForSeconds(curveAnimator.pingDuration);
            }
        }
    }
}
[CreateAssetMenu(fileName = "Punch", menuName = "Card Animation/Punch")]
public class CardAnimationPunch : CardAnimation
{
    [SerializeField]
    public AnimationCurve curve;

    [SerializeField]
    public float duration = 1f;

    [SerializeField]
    public float animationDistance = 2.5f;

    [SerializeField]
    public float hitPos = 0.22f;

    public override IEnumerator Routine(object data, float startDelay = 0f)
    {
        if (data is Trigger trigger)
        {
            yield return (object)new WaitForSeconds(startDelay);
            Vector3 val = Vector3.zero;
            Hit[] hits = trigger.hits;
            foreach (Hit hit in hits)
            {
                val += hit.target.transform.position;
            }
            if (trigger.hits.Length != 0)
            {
                val /= (float)trigger.hits.Length;
            }
            Vector3 val2 = val - trigger.entity.transform.position;
            Vector3 offset = ((val2)).normalized * animationDistance;
            offset.z = -1f;
            trigger.entity.curveAnimator.Move(offset, curve, duration);
            yield return Sequences.Wait(duration * hitPos);
        }
    }
}
[CreateAssetMenu(fileName = "Supportive", menuName = "Card Animation/Supportive")]
public class CardAnimationSupportive : CardAnimation
{
    [SerializeField]
    public float hitPos = 0.2f;

    public override IEnumerator Routine(object data, float startDelay = 0f)
    {
        if (data is Trigger trigger)
        {
            yield return (object)new WaitForSeconds(startDelay);
            float num = trigger.entity.curveAnimator.Ping();
            yield return Sequences.Wait(num * hitPos);
        }
    }
}
public abstract class CardScript : ScriptableObject
{
    public virtual void Run(CardData target)
    {
    }

    public CardScript()
    {
    }
}
[CreateAssetMenu(fileName = "CardAnimationProfile", menuName = "Card Animation Profile")]
public class CardAnimationProfile : ScriptableObject
{
    public float speedFactor;

    [Header("Movement")]
    public bool doMoveX;

    [ShowIf("doMoveX")]
    public AnimationCurve moveX;

    public bool doMoveY;

    [ShowIf("doMoveY")]
    public AnimationCurve moveY;

    public bool doMoveZ;

    [ShowIf("doMoveZ")]
    public AnimationCurve moveZ;

    public Vector3 moveAmount;

    [Header("Rotation")]
    public bool doRotateX;

    [ShowIf("doRotateX")]
    public AnimationCurve rotateX;

    public bool doRotateY;

    [ShowIf("doRotateY")]
    public AnimationCurve rotateY;

    public bool doRotateZ;

    [ShowIf("doRotateZ")]
    public AnimationCurve rotateZ;

    public Vector3 rotateAmount;

    [Header("Scale")]
    public bool doScaleX;

    [ShowIf("doScaleX")]
    public AnimationCurve ScaleX;

    public bool doScaleY;

    [ShowIf("doScaleY")]
    public AnimationCurve ScaleY;

    public bool doScaleZ;

    [ShowIf("doScaleZ")]
    public AnimationCurve ScaleZ;

    public Vector3 scaleAmount;
}
[CreateAssetMenu(fileName = "CardData", menuName = "Card Data")]
public class CardData : DataFile, ISaveable<CardSaveData>
{
    public enum PlayPosition
    {
        None,
        Friendly,
        Enemy,
        Hand,
        FriendlyRow,
        EnemyRow,
        Field,
        FriendlySlot,
        EnemySlot
    }

    [Serializable]
    public class StatusEffectStacks : ISaveable<StatusEffectSaveData>
    {
        public StatusEffectData data;

        public int count;

        public StatusEffectStacks()
        {
        }

        public StatusEffectStacks(StatusEffectData data, int count)
        {
            this.data = data;
            this.count = count;
        }

        public StatusEffectSaveData Save()
        {
            return new StatusEffectSaveData
            {
                name = (data).name,
                count = count
            };
        }

        public static StatusEffectStacks[] Stack(IEnumerable<StatusEffectStacks> currentEffects, IEnumerable<StatusEffectStacks> newEffects)
        {
            List<StatusEffectStacks> list = new List<StatusEffectStacks>(currentEffects);
            foreach (StatusEffectStacks e in newEffects)
            {
                StatusEffectStacks statusEffectStacks = list.FirstOrDefault((StatusEffectStacks a) => a.data == e.data);
                if (statusEffectStacks != null)
                {
                    statusEffectStacks.count += e.count;
                }
                else
                {
                    list.Add(new StatusEffectStacks(e.data, e.count));
                }
            }
            return list.ToArray();
        }

        public override string ToString()
        {
            return $"{count} {(data).name}";
        }

        public StatusEffectStacks Clone()
        {
            return new StatusEffectStacks(data, count);
        }
    }

    [Serializable]
    public class TraitStacks : ISaveable<TraitSaveData>
    {
        public TraitData data;

        public int count;

        public TraitStacks(TraitData data, int count)
        {
            this.data = data;
            this.count = count;
        }

        public TraitStacks()
        {
        }

        public TraitSaveData Save()
        {
            return new TraitSaveData
            {
                name = (data).name,
                count = count
            };
        }

        public static void Stack(ref List<TraitStacks> traits, IEnumerable<TraitStacks> newTraits)
        {
            foreach (TraitStacks newTrait in newTraits)
            {
                bool flag = false;
                foreach (TraitStacks trait in traits)
                {
                    if (((object)trait.data).Equals((object?)newTrait.data))
                    {
                        trait.count += newTrait.count;
                        flag = true;
                        break;
                    }
                }
                if (!flag)
                {
                    traits.Add(new TraitStacks
                    {
                        data = newTrait.data,
                        count = newTrait.count
                    });
                }
            }
        }

        public override string ToString()
        {
            return $"{(data).name} {count}";
        }
    }

    public static ulong idCurrent;

    [FormerlySerializedAs("title")]
    public string titleFallback;

    public string forceTitle;

    [TextArea]
    public string desc;

    public LocalizedString titleKey;

    public LocalizedString textKey;

    [SerializeField]
    public string textInsert;

    public string flavour;

    public LocalizedString flavourKey;

    public int value;

    public CardAnimationProfile idleAnimationProfile;

    public string[] greetMessages;

    public BloodProfile bloodProfile;

    [Header("Stats")]
    public bool hasAttack;

    public int damage;

    public bool hasHealth;

    public int hp;

    public int counter;

    [Header("Attacking")]
    public bool canBeHit;

    [Required(null)]
    public TargetMode targetMode;

    public StatusEffectStacks[] attackEffects;

    [Header("Assets")]
    [ShowAssetPreview(64, 64)]
    public Sprite mainSprite;

    [ShowAssetPreview(64, 64)]
    public Sprite backgroundSprite;

    [Header("Details")]
    public CardType cardType;

    [ShowIf("IsClunker")]
    public bool isEnemyClunker;

    public Card.PlayType playType;

    public bool needsTarget = true;

    public bool canPlayOnBoard = true;

    public bool canPlayOnHand = true;

    public bool canPlayOnFriendly = true;

    public bool canPlayOnEnemy = true;

    public bool playOnSlot;

    [ShowIf("DoesShove")]
    public bool canShoveToOtherRow = true;

    public PlayPosition defaultPlayPosition;

    public int uses;

    public StatusEffectStacks[] startWithEffects;

    public List<TraitStacks> traits;

    public TargetConstraint[] targetConstraints;

    [Space]
    [ReadOnly]
    public int effectBonus;

    [ReadOnly]
    public float effectFactor = 1f;

    public List<StatusEffectStacks> injuries;

    [ReadOnly]
    public List<CardUpgradeData> upgrades;

    [ReadOnly]
    public Vector3 random3;

    [ReadOnly]
    public int charmSlots = 3;

    [ReadOnly]
    public int tokenSlots = 1;

    [ReadOnly]
    public int crownSlots = 1;

    public ScriptableCardImage scriptableImagePrefab;

    [SerializeField]
    public CardScript[] createScripts;

    public Dictionary<string, object> customData;

    public ulong id { get; set; }

    public string title
    {
        get
        {
            if (!StringExt.IsNullOrWhitespace(forceTitle))
            {
                return forceTitle;
            }
            LocalizedString val = titleKey;
            if (val == null || ((LocalizedReference)val).IsEmpty)
            {
                return titleFallback;
            }
            return titleKey.GetLocalizedString();
        }
    }

    public bool HasCustomText => !((LocalizedReference)textKey).IsEmpty;

    public bool IsClunker => (cardType).name == "Clunker";

    public bool IsItem => playType == Card.PlayType.Play;

    public bool DoesShove
    {
        get
        {
            if (playType != Card.PlayType.Place)
            {
                if (playType == Card.PlayType.Play)
                {
                    return playOnSlot;
                }
                return false;
            }
            return true;
        }
    }

    public CardData original { get; set; }

    public bool HasCrown => GetCrown() != null;

    public void SetId(ulong value)
    {
        id = value;
        if (id > idCurrent)
        {
            idCurrent = id;
        }
    }

    public string GetCustomText(bool silenced = false)
    {
        int amount = ((attackEffects.Length != 0) ? attackEffects[0].count : ((startWithEffects.Length != 0) ? startWithEffects[0].count : 0));
        string text = Text.GetEffectText(textKey, textInsert, amount, silenced);
        for (int num = attackEffects.Length - 1; num >= 0; num--)
        {
            string oldValue = "{a" + num + "}";
            if (text.Contains(oldValue))
            {
                text = text.Replace(oldValue, attackEffects[num].count.ToString());
            }
        }
        for (int num2 = startWithEffects.Length - 1; num2 >= 0; num2--)
        {
            string oldValue2 = "{s" + num2 + "}";
            if (text.Contains(oldValue2))
            {
                text = text.Replace(oldValue2, startWithEffects[num2].count.ToString());
            }
        }
        return text;
    }

    public CardUpgradeData GetCrown()
    {
        return upgrades.Find((CardUpgradeData a) => a.type == CardUpgradeData.Type.Crown);
    }

    public void RemoveCrown()
    {
        GetCrown()?.UnAssign(this);
    }

    public CardData Clone(bool runCreateScripts = true)
    {
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f));
        Vector3 normalized = ((val)).normalized;
        return Clone(normalized, idCurrent + 1, runCreateScripts);
    }

    public CardData Clone(Vector3 random3, bool runCreateScripts = true)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return Clone(random3, idCurrent + 1, runCreateScripts);
    }

    public CardData Clone(Vector3 random3, ulong id, bool runCreateScripts = true)
    {
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        CardData cardData = ObjectExt.InstantiateKeepName<CardData>(this);
        cardData.original = this;
        cardData.SetId(id);
        cardData.random3 = random3;
        cardData.customData = customData?.ToDictionary((KeyValuePair<string, object> entry) => entry.Key, (KeyValuePair<string, object> entry) => entry.Value);
        if (runCreateScripts)
        {
            cardData.RunCreateScripts();
            Events.InvokeCardDataCreated(cardData);
        }
        return cardData;
    }

    public void RunCreateScripts()
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        if (createScripts != null && createScripts.Length != 0)
        {
            State state = Random.state;
            int num = Mathf.Abs(Mathf.RoundToInt(random3.x * 100000f));
            for (int i = 0; i < createScripts.Length; i++)
            {
                Random.InitState(num + i);
                createScripts[i].Run(this);
            }
            Random.state = state;
        }
    }

    public void SetCustomData(string key, object value)
    {
        customData ??= new Dictionary<string, object>();
        customData[key] = value;
    }

    public bool TryGetCustomData<T>(string key, out T value, T defaultValue)
    {
        if (customData != null && customData.TryGetValue(key, out var obj) && obj is T val)
        {
            value = val;
            return true;
        }
        value = defaultValue;
        return false;
    }

    public bool IsOffensive()
    {
        bool flag = damage > 0 || ((original) && original.damage > 0);
        if (!flag && attackEffects.Any((StatusEffectStacks s) => s.data.offensive))
        {
            flag = true;
        }
        if (!flag && startWithEffects.Any((StatusEffectStacks s) => s.data.makesOffensive))
        {
            flag = true;
        }
        return flag;
    }

    public CardSaveData Save()
    {
        return new CardSaveData(this);
    }

    public override int GetHashCode()
    {
        return name.GetHashCode() ^ ((object)(random3)).GetHashCode() ^ id.GetHashCode();
    }
}
[CreateAssetMenu(fileName = "CardType", menuName = "Card Type")]
public class CardType : DataFile
{
    public int sortPriority;

    [ShowAssetPreview(64, 64)]
    public Sprite icon;

    public AssetReference prefabRef;

    [Header("Details")]
    public Sprite textBoxSprite;

    public Sprite nameTagSprite;

    [SerializeField]
    public LocalizedString titleKey;

    public bool canDie;

    public bool canTakeCrown;

    public bool canRecall;

    public bool canReserve;

    public bool item;

    public bool unit;

    public string tag;

    public bool miniboss;

    public bool discoverInJournal;

    [Header("Colours")]
    public Text.ColourProfileHex descriptionColours;

    public string title => titleKey.GetLocalizedString();

    public override bool Equals(object other)
    {
        if (other is CardType cardType)
        {
            return name == (cardType).name;
        }
        return base.Equals(other);
    }
}
[CreateAssetMenu(fileName = "CardUpgradeData", menuName = "Card Upgrade Data")]
public class CardUpgradeData : DataFile, ISaveable<CardUpgradeSaveData>
{
    public enum Type
    {
        None,
        Charm,
        Token,
        Crown
    }

    public int tier;

    [SerializeField]
    public LocalizedString titleKey;

    [SerializeField]
    public LocalizedString textKey;

    [ShowAssetPreview(64, 64)]
    public Sprite image;

    public Type type;

    public CardData.StatusEffectStacks[] attackEffects;

    public CardData.StatusEffectStacks[] effects;

    public CardData.TraitStacks[] giveTraits;

    public CardScript[] scripts;

    public bool becomesTargetedCard;

    public bool canBeRemoved;

    public bool takeSlot = true;

    [Header("Constraints for applying this to a card")]
    [SerializeField]
    public TargetConstraint[] targetConstraints;

    [Header("Stat Changes")]
    public int damage;

    public int hp;

    public int counter;

    public int uses;

    public int effectBonus;

    [Header("Set Exact Stats")]
    public bool setDamage;

    public bool setHp;

    public bool setCounter;

    public bool setUses;

    public List<CardData.StatusEffectStacks> effectsAffected;

    public List<CardData.TraitStacks> traitsAffected;

    public List<CardData.StatusEffectStacks> attackEffectsApplied;

    public List<CardData.StatusEffectStacks> startWithEffectsApplied;

    public int damageChange;

    public int hpChange;

    public int counterChange;

    public int usesChange;

    public string title => titleKey.GetLocalizedString();

    public string text => textKey.GetLocalizedString();

    public void Assign(CardData cardData)
    {
        int num = cardData.damage;
        int num2 = cardData.hp;
        int num3 = cardData.counter;
        int num4 = cardData.uses;
        AdjustStats(cardData);
        RunScripts(cardData);
        damageChange = cardData.damage - num;
        hpChange = cardData.hp - num2;
        counterChange = cardData.counter - num3;
        usesChange = cardData.uses - num4;
        AdjustEffectBonus(cardData);
        GainEffects(cardData);
        cardData.upgrades.Add(this);
    }

    public void AdjustStats(CardData cardData)
    {
        if (becomesTargetedCard)
        {
            cardData.hasAttack = true;
            if (cardData.playType == Card.PlayType.None)
            {
                cardData.playType = Card.PlayType.Play;
            }
            cardData.needsTarget = true;
        }
        bool flag = cardData.counter > 0;
        cardData.damage = (setDamage ? damage : (cardData.damage + damage));
        cardData.hp = (setHp ? hp : (cardData.hp + hp));
        cardData.counter = (setCounter ? counter : Mathf.Max(flag ? 1 : 0, cardData.counter + counter));
        cardData.uses = (setUses ? uses : (cardData.uses + uses));
        cardData.damage = Mathf.Max(0, cardData.damage);
        cardData.hp = Mathf.Max(0, cardData.hp);
        cardData.counter = Mathf.Max(0, cardData.counter);
        cardData.uses = Mathf.Max(0, cardData.uses);
    }

    public void RunScripts(CardData cardData)
    {
        CardScript[] array = scripts;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].Run(cardData);
        }
    }

    public void AdjustEffectBonus(CardData cardData)
    {
        if (effectBonus == 0)
        {
            return;
        }
        effectsAffected = new List<CardData.StatusEffectStacks>();
        CardData.StatusEffectStacks[] array = cardData.attackEffects;
        foreach (CardData.StatusEffectStacks statusEffectStacks in array)
        {
            if (statusEffectStacks.data.isStatus || statusEffectStacks.data.stackable)
            {
                statusEffectStacks.count = Mathf.Max(0, statusEffectStacks.count + effectBonus);
                effectsAffected.Add(statusEffectStacks);
            }
        }
        array = cardData.startWithEffects;
        foreach (CardData.StatusEffectStacks statusEffectStacks2 in array)
        {
            if (statusEffectStacks2.data.canBeBoosted)
            {
                statusEffectStacks2.count = Mathf.Max(0, statusEffectStacks2.count + effectBonus);
                effectsAffected.Add(statusEffectStacks2);
            }
        }
        traitsAffected = new List<CardData.TraitStacks>();
        foreach (CardData.TraitStacks trait in cardData.traits)
        {
            if (trait.data.keyword.canStack)
            {
                trait.count = Mathf.Max(0, trait.count + effectBonus);
                traitsAffected.Add(trait);
            }
        }
    }

    public void GainEffects(CardData cardData)
    {
        if (attackEffects.Length != 0)
        {
            attackEffectsApplied = new List<CardData.StatusEffectStacks>();
            List<CardData.StatusEffectStacks> list = IArrayExt.ToList<CardData.StatusEffectStacks>(cardData.attackEffects);
            for (int num = attackEffects.Length - 1; num >= 0; num--)
            {
                CardData.StatusEffectStacks e2 = attackEffects[num];
                CardData.StatusEffectStacks statusEffectStacks = list.Find((CardData.StatusEffectStacks a) => a.data == e2.data);
                if (statusEffectStacks != null)
                {
                    statusEffectStacks.count += e2.count;
                }
                else
                {
                    list.Add(new CardData.StatusEffectStacks(e2.data, e2.count));
                }
                attackEffectsApplied.Add(e2);
            }
            cardData.attackEffects = list.ToArray();
        }
        if (effects.Length != 0)
        {
            startWithEffectsApplied = new List<CardData.StatusEffectStacks>();
            List<CardData.StatusEffectStacks> list2 = IArrayExt.ToList<CardData.StatusEffectStacks>(cardData.startWithEffects);
            for (int num2 = effects.Length - 1; num2 >= 0; num2--)
            {
                CardData.StatusEffectStacks e = effects[num2];
                CardData.StatusEffectStacks statusEffectStacks2 = list2.Find((CardData.StatusEffectStacks a) => a.data == e.data);
                if (statusEffectStacks2 != null)
                {
                    statusEffectStacks2.count += e.count;
                }
                else
                {
                    list2.Add(new CardData.StatusEffectStacks(e.data, e.count));
                }
                startWithEffectsApplied.Add(e);
            }
            cardData.startWithEffects = list2.ToArray();
        }
        CardData.TraitStacks.Stack(ref cardData.traits, giveTraits);
    }

    public IEnumerator Assign(Entity entity)
    {
        Events.InvokeUpgradeAssign(entity, this);
        Assign(entity.data);
        yield return entity.ClearStatuses();
        if (entity.display is Card card)
        {
            yield return card.UpdateData();
        }
    }

    public void UnAssign(CardData assignedTo)
    {
        assignedTo.damage -= damageChange;
        assignedTo.hp -= hpChange;
        assignedTo.counter -= counterChange;
        assignedTo.uses -= usesChange;
        if (effectBonus != 0)
        {
            foreach (CardData.StatusEffectStacks item in effectsAffected)
            {
                item.count -= effectBonus;
            }
            effectsAffected = null;
            foreach (CardData.TraitStacks item2 in traitsAffected)
            {
                item2.count -= effectBonus;
            }
            traitsAffected = null;
        }
        if (attackEffectsApplied != null && attackEffectsApplied.Count > 0)
        {
            List<CardData.StatusEffectStacks> list = IArrayExt.ToList<CardData.StatusEffectStacks>(assignedTo.attackEffects);
            for (int num = attackEffectsApplied.Count - 1; num >= 0; num--)
            {
                CardData.StatusEffectStacks e2 = attackEffectsApplied[num];
                CardData.StatusEffectStacks? statusEffectStacks = list.Find((CardData.StatusEffectStacks a) => a.data == e2.data);
                statusEffectStacks.count -= e2.count;
                if (statusEffectStacks.count <= 0)
                {
                    list.Remove(e2);
                }
            }
        }
        if (startWithEffectsApplied != null && startWithEffectsApplied.Count > 0)
        {
            List<CardData.StatusEffectStacks> list2 = IArrayExt.ToList<CardData.StatusEffectStacks>(assignedTo.startWithEffects);
            for (int num2 = startWithEffectsApplied.Count - 1; num2 >= 0; num2--)
            {
                CardData.StatusEffectStacks e = startWithEffectsApplied[num2];
                CardData.StatusEffectStacks? statusEffectStacks2 = list2.Find((CardData.StatusEffectStacks a) => a.data == e.data);
                statusEffectStacks2.count -= e.count;
                if (statusEffectStacks2.count <= 0)
                {
                    list2.Remove(e);
                }
            }
            assignedTo.startWithEffects = list2.ToArray();
            startWithEffectsApplied = null;
        }
        assignedTo.upgrades.Remove(this);
    }

    public bool CanAssign(Entity card)
    {
        CardData data = card.data;
        if (damage != 0 && !data.hasAttack)
        {
            return false;
        }
        if (hp != 0 && !data.hasHealth)
        {
            return false;
        }
        if (counter != 0 && data.counter <= 0)
        {
            return false;
        }
        foreach (CardData.TraitStacks t2 in giveTraits.Where((CardData.TraitStacks t) => !t.data.keyword.canStack))
        {
            if (data.traits.Any((CardData.TraitStacks a) => (a.data).name == (t2.data).name))
            {
                return false;
            }
        }
        TargetConstraint[] array = targetConstraints;
        for (int i = 0; i < array.Length; i++)
        {
            if (!array[i].Check(card))
            {
                return false;
            }
        }
        return CheckSlots(data);
    }

    public bool CanAssign(CardData cardData)
    {
        if (damage != 0 && !cardData.hasAttack)
        {
            return false;
        }
        if (hp != 0 && !cardData.hasHealth)
        {
            return false;
        }
        if (counter != 0 && cardData.counter <= 0)
        {
            return false;
        }
        foreach (CardData.TraitStacks t2 in giveTraits.Where((CardData.TraitStacks t) => !t.data.keyword.canStack))
        {
            if (cardData.traits.Any((CardData.TraitStacks a) => ((object)a.data).Equals((object?)t2.data)))
            {
                return false;
            }
        }
        TargetConstraint[] array = targetConstraints;
        for (int i = 0; i < array.Length; i++)
        {
            if (!array[i].Check(cardData))
            {
                return false;
            }
        }
        return CheckSlots(cardData);
    }

    public void Display(Entity entity)
    {
        if (type == Type.None || !(entity.display is Card card))
        {
            return;
        }
        switch (type)
        {
            case Type.Charm:
                if ((card.charmHolder))
                {
                    card.charmHolder.Create(this);
                    card.charmHolder.SetPositions();
                }
                break;
            case Type.Token:
                if ((card.tokenHolder))
                {
                    card.tokenHolder.Create(this);
                    card.tokenHolder.SetPositions();
                }
                break;
            case Type.Crown:
                if ((card.crownHolder))
                {
                    card.crownHolder.Create(this);
                    card.crownHolder.SetPositions();
                }
                break;
        }
    }

    public CardUpgradeData Clone()
    {
        return ObjectExt.InstantiateKeepName<CardUpgradeData>(this);
    }

    public CardUpgradeSaveData Save()
    {
        return new CardUpgradeSaveData(name);
    }

    public bool CheckSlots(CardData cardData)
    {
        if (!takeSlot)
        {
            return true;
        }
        switch (type)
        {
            case Type.Charm:
                {
                    int count = cardData.upgrades.FindAll((CardUpgradeData a) => a.type == type && a.takeSlot).Count;
                    int num = cardData.charmSlots;
                    if (cardData.customData != null)
                    {
                        num += DictionaryExt.Get<int>(cardData.customData, "extraCharmSlots", 0);
                    }
                    if (count >= num)
                    {
                        return false;
                    }
                    break;
                }
            case Type.Token:
                if (cardData.upgrades.FindAll((CardUpgradeData a) => a.type == type && a.takeSlot).Count >= cardData.tokenSlots)
                {
                    return false;
                }
                break;
            case Type.Crown:
                if (cardData.upgrades.FindAll((CardUpgradeData a) => a.type == type && a.takeSlot).Count >= cardData.crownSlots)
                {
                    return false;
                }
                break;
        }
        return true;
    }
}
[CreateAssetMenu(fileName = "Challenge Listener", menuName = "Town/Challenge Listener")]
public class ChallengeListener : DataFile
{
    public enum CheckType
    {
        MidRun,
        EndOfRun,
        CustomSystem
    }

    public CheckType checkType;

    [ShowIf("CheckTypeCustomSystem")]
    public string systemName;

    [HideIf("CheckTypeCustomSystem")]
    public string stat;

    [HideIf("CheckTypeCustomSystem")]
    public bool hasKey;

    [HideIf("CheckTypeCustomSystem")]
    [ShowIf("hasKey")]
    public string key;

    [HideIf("CheckTypeCustomSystem")]
    public int target;

    public bool CheckTypeCustomSystem => checkType == CheckType.CustomSystem;

    public virtual bool Check(string stat, string key)
    {
        if (stat == this.stat)
        {
            if (hasKey)
            {
                return key == this.key;
            }
            return true;
        }
        return false;
    }

    public virtual bool CheckComplete(CampaignStats stats)
    {
        return stats.Get(stat, hasKey ? key : "", 0) >= target;
    }

    public virtual void Set(string challengeName, int oldValue, int newValue)
    {
        Add(challengeName, newValue - oldValue);
    }

    public static void Add(string challengeName, int value)
    {
        ChallengeProgressSystem.AddProgress(challengeName, value);
    }

    public void AddCustomSystem(ChallengeData challengeData, ChallengeSystem challengeSystem)
    {
        if (checkType == CheckType.CustomSystem)
        {
            Component val = GameObjectExt.AddComponentByName(((Component)challengeSystem).gameObject, systemName);
            if (val is ChallengeListenerSystem challengeListenerSystem)
            {
                challengeListenerSystem.Assign(challengeData, challengeSystem);
            }
            else
            {
                ComponentExt.Destroy(val);
            }
        }
    }
}
[CreateAssetMenu(fileName = "Challenge Listener Highest", menuName = "Town/Challenge Listener Highest")]
public class ChallengeListenerHighest : ChallengeListener
{
    public override void Set(string challengeName, int oldValue, int newValue)
    {
        if (newValue >= target)
        {
            ChallengeListener.Add(challengeName, 1);
        }
    }
}
[CreateAssetMenu(menuName = "Town/Challenge", fileName = "Challenge")]
public class ChallengeData : DataFile
{
    public bool hidden;

    public LocalizedString titleKey;

    public LocalizedString textKey;

    public LocalizedString rewardKey;

    public int goal;

    public ChallengeListener listener;

    public Sprite icon;

    public ChallengeData[] requires;

    public UnlockData reward;

    public string text => textKey.GetLocalizedString();

    public string rewardText => rewardKey.GetLocalizedString();
}
[CreateAssetMenu(fileName = "CharacterType", menuName = "Character/Type")]
public class CharacterType : ScriptableObject
{
    [Serializable]
    public class PrefabGroup
    {
        public string name;

        public PrefabCollection collection;
    }

    [Serializable]
    public class SpriteGroup
    {
        public string name;

        public SpriteCollection collection;
    }

    [Serializable]
    public class ColorSetGroup
    {
        public string name;

        public ColorSetCollection collection;
    }

    [Serializable]
    public class ScaleRange
    {
        public string name;

        public bool lockRatio;

        public Vector2 xRange;

        public Vector2 yRange;

        public Vector2 Convert()
        {
            //IL_001b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0026: Unknown result type (might be due to invalid IL or missing references)
            //IL_0030: Unknown result type (might be due to invalid IL or missing references)
            //IL_0009: Unknown result type (might be due to invalid IL or missing references)
            //IL_0014: Unknown result type (might be due to invalid IL or missing references)
            if (lockRatio)
            {
                float num = Vector2Ext.Random(xRange);
                return new Vector2(num, num);
            }
            return new Vector2(Vector2Ext.Random(xRange), Vector2Ext.Random(yRange));
        }
    }

    public string race;

    public string gender;

    public PrefabGroup[] prefabs;

    public SpriteGroup[] sprites;

    public ColorSetGroup[] colorSets;

    public ScaleRange[] scales;
}
[CreateAssetMenu(fileName = "New Class", menuName = "Character/Class")]
public class ClassData : DataFile, ISaveable<ClassSaveData>
{
    public string id;

    public UnlockData requiresUnlock;

    public Inventory startingInventory;

    public CardData[] leaders;

    public Character characterPrefab;

    public RewardPool[] rewardPools;

    public EventReference selectSfxEvent;

    [ShowAssetPreview(64, 64)]
    public Sprite flag;

    public ClassSaveData Save()
    {
        return new ClassSaveData(name);
    }

    public override string ToString()
    {
        return name;
    }
}
public class Collection<T> : ScriptableObject where T : class
{
    [Serializable]
    public struct Entry<T1>
    {
        public T1 value;

        public float weight;
    }

    public float nullWeight;

    [SerializeField]
    public Entry<T>[] weightedList;

    public T this[int index] => weightedList[index].value;

    public void AddWeight(int index, float weight)
    {
        weightedList[index].weight += weight;
    }

    public T RandomItem()
    {
        int num = RandomIndex();
        if (num >= 0)
        {
            return weightedList[num].value;
        }
        return null;
    }

    public virtual int RandomIndex()
    {
        int result = -1;
        if (weightedList.Length != 0)
        {
            float num = nullWeight;
            Entry<T>[] array = weightedList;
            for (int i = 0; i < array.Length; i++)
            {
                Entry<T> entry = array[i];
                if (entry.weight > 0f)
                {
                    num += entry.weight;
                }
            }
            if (num > 0f)
            {
                float num2 = Random.value * num;
                if (num2 >= nullWeight)
                {
                    num2 -= nullWeight;
                    for (int j = 0; j < weightedList.Length; j++)
                    {
                        Entry<T> entry2 = weightedList[j];
                        if (entry2.weight > 0f)
                        {
                            if (num2 < entry2.weight)
                            {
                                result = j;
                                break;
                            }
                            num2 -= entry2.weight;
                        }
                    }
                }
            }
        }
        return result;
    }
}
[CreateAssetMenu(fileName = "CollectionModifier", menuName = "Character/Collection Modifier")]
public class CollectionModifier : ScriptableObject
{
    [Serializable]
    public struct Modify
    {
        public int index;

        public float addWeight;
    }

    public Modify[] list;
}
[CreateAssetMenu(fileName = "ColorSetCollection", menuName = "Character/Color Set Collection")]
public class ColorSetCollection : Collection<ColorSet>
{
}
[Serializable]
public class ColorSet
{
    public Color[] set;

    public Color this[int index] => set[index];
}
[CreateAssetMenu(fileName = "PrefabCollection", menuName = "Character/Prefab Collection")]
public class PrefabCollection : Collection<GameObject>
{
}
[CreateAssetMenu(fileName = "SpriteCollection", menuName = "Character/Sprite Collection")]
public class SpriteCollection : Collection<Sprite>
{
}
[CreateAssetMenu(fileName = "SpriteSetCollection", menuName = "Character/Sprite Set Collection")]
public class SpriteSetCollection : Collection<SpriteSet>
{
}
[Serializable]
public class SpriteSet
{
    public Sprite[] set;

    public Sprite this[int index] => set[index];
}
public class DataFile : ScriptableObject
{
    [NonSerialized]
    public WildfrostMod ModAdded;

    public override bool Equals(object other)
    {
        return (((other is Object) ? other : null)).GetInstanceID() == GetInstanceID();
    }

    public override int GetHashCode()
    {
        return name.GetHashCode();
    }
}
[CreateAssetMenu(fileName = "EyeData", menuName = "EyeData")]
public class EyeData : DataFile
{
    [Serializable]
    public struct Eye
    {
        public Vector2 position;

        public Vector2 scale;

        public float rotation;

        public Eye(Transform transform)
        {
            //IL_0002: Unknown result type (might be due to invalid IL or missing references)
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0013: Unknown result type (might be due to invalid IL or missing references)
            //IL_0018: Unknown result type (might be due to invalid IL or missing references)
            //IL_001d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0024: Unknown result type (might be due to invalid IL or missing references)
            position = (transform.localPosition);
            scale = (transform.localScale);
            rotation = transform.localEulerAngles.z;
        }
    }

    public string cardData;

    public Eye[] eyes;

    public void Set(params EyePositionSaver[] eyePositions)
    {
        eyes = new Eye[eyePositions.Length];
        int num = 0;
        foreach (EyePositionSaver eyePositionSaver in eyePositions)
        {
            eyes[num++] = new Eye(((Component)eyePositionSaver).transform);
        }
    }
}
[CreateAssetMenu(menuName = "Campaign/Final Boss Card Modifier", fileName = "Final Boss Card Modifier")]
public class FinalBossCardModifier : ScriptableObject
{
    public CardData card;

    public CardScript[] runAll;

    public void Run(CardData card)
    {
        CardScript[] array = runAll;
        foreach (CardScript cardScript in array)
        {
            Debug.Log(("Running [" + (cardScript).name + "] on " + (card).name));
            cardScript.Run(card);
        }
    }
}
[CreateAssetMenu(menuName = "Campaign/Final Boss Effect Swapper", fileName = "Final Boss Effect Swapper")]
public class FinalBossEffectSwapper : ScriptableObject
{
    public StatusEffectData effect;

    public bool remove = true;

    [ShowIf("remove")]
    public StatusEffectData[] replaceWithOptions;

    [ShowIf("remove")]
    public StatusEffectData replaceWithAttackEffect;

    public Vector2Int boostRange;

    public void Process(CardData card, CardData.StatusEffectStacks stack, int stackIndex)
    {
        //IL_0096: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        if (remove)
        {
            List<CardData.StatusEffectStacks> list = IArrayExt.ToList<CardData.StatusEffectStacks>(card.startWithEffects);
            if (replaceWithOptions.Length != 0)
            {
                stack.data = IArrayExt.RandomItem<StatusEffectData>(replaceWithOptions);
            }
            else
            {
                list.RemoveAt(stackIndex);
            }
            if ((replaceWithAttackEffect))
            {
                int count = stack.count + Vector2IntExt.Random(boostRange);
                CardData.StatusEffectStacks statusEffectStacks = new CardData.StatusEffectStacks(replaceWithAttackEffect, count);
                card.attackEffects = CardData.StatusEffectStacks.Stack(card.attackEffects, new CardData.StatusEffectStacks[1] { statusEffectStacks });
            }
            card.startWithEffects = list.ToArray();
        }
        stack.count += Vector2IntExt.Random(boostRange);
    }
}
[CreateAssetMenu(menuName = "Campaign/Final Boss Enemy Generator", fileName = "Final Boss Enemy Generator")]
public class FinalBossEnemyGenerator : ScriptableObject
{
    public CardData enemy;

    public CardData[] fromCards;
}
[CreateAssetMenu(menuName = "Campaign/Final Boss Generation Settings", fileName = "FinalBossGenerationSettings")]
public class FinalBossGenerationSettings : ScriptableObject
{
    [Serializable]
    public struct ReplaceCard
    {
        public CardData card;

        public CardData[] options;
    }

    [Header("Replace cards...")]
    [SerializeField]
    public ReplaceCard[] replaceCards;

    [Header("Things to ignore...")]
    [SerializeField]
    public CardUpgradeData[] ignoreUpgrades;

    [SerializeField]
    public TraitData[] ignoreTraits;

    [Header("Effects to change...")]
    [SerializeField]
    public FinalBossEffectSwapper[] effectSwappers;

    [Header("Scripts to run on cards...")]
    [SerializeField]
    public CardScript[] runOnAll;

    [SerializeField]
    public FinalBossCardModifier[] cardModifiers;

    [SerializeField]
    public CardScript[] leaderScripts;

    [Header("New enemies to add")]
    [SerializeField]
    public FinalBossEnemyGenerator[] enemyOptions;

    public void ReplaceCards(IList<CardData> cards)
    {
        ReplaceCard[] array = replaceCards;
        for (int i = 0; i < array.Length; i++)
        {
            ReplaceCard replace = array[i];
            CardData[] array2 = cards.Where((CardData a) => (a).name == (replace.card).name).ToArray();
            foreach (CardData item in array2)
            {
                int index = cards.IndexOf(item);
                CardData cardData = IArrayExt.RandomItem<CardData>(replace.options);
                cards.RemoveAt(index);
                cards.Insert(index, cardData);
                Debug.Log(((replace.card).name + " Replaced With " + (cardData).name));
            }
        }
    }

    public void Process(CardData leader, IList<CardData> cards)
    {
        RemoveInjuries(cards);
        RemoveUpgrades(cards);
        RemoveTraits(cards);
        ProcessEffects(cards);
        RunScripts(leader, cards);
    }

    public IEnumerable<CardData> GenerateBonusEnemies(int count, IEnumerable<CardData> basedOnDeck, CardData[] defaultEnemies)
    {
        WeightedRandomPool<CardData> val = new WeightedRandomPool<CardData>();
        foreach (CardData card in basedOnDeck)
        {
            FinalBossEnemyGenerator finalBossEnemyGenerator = enemyOptions.FirstOrDefault((FinalBossEnemyGenerator a) => a.fromCards.Any((CardData b) => (b).name == (card).name));
            if ((finalBossEnemyGenerator))
            {
                val.Add(finalBossEnemyGenerator.enemy);
                Debug.Log($"{finalBossEnemyGenerator.enemy} added to weighted pool");
            }
        }
        List<CardData> list = new List<CardData>();
        int num = Mathf.Min(count, val.Count);
        for (int i = 0; i < num; i++)
        {
            CardData item = val.Pull().Clone();
            list.Add(item);
        }
        if (list.Count < count)
        {
            foreach (CardData item2 in IEnumerableExt.InRandomOrder<CardData>((IEnumerable<CardData>)defaultEnemies))
            {
                list.Add(item2.Clone());
                if (list.Count >= count)
                {
                    break;
                }
            }
        }
        return list;
    }

    public static void RemoveInjuries(IEnumerable<CardData> cards)
    {
        foreach (CardData card in cards)
        {
            if (card.injuries != null && card.injuries.Count > 0)
            {
                card.injuries.Clear();
                Debug.Log(("Injuries removed from " + (card).name));
            }
        }
    }

    public void RemoveUpgrades(IList<CardData> cards)
    {
        CardUpgradeData[] array = ignoreUpgrades;
        foreach (CardUpgradeData cardUpgradeData in array)
        {
            foreach (CardData card in cards)
            {
                if (card.upgrades.Contains(cardUpgradeData))
                {
                    cardUpgradeData.UnAssign(card);
                    Debug.Log(("[" + (cardUpgradeData).name + "] Removed from " + (card).name));
                }
            }
        }
    }

    public void ProcessEffects(IEnumerable<CardData> cards)
    {
        Dictionary<string, FinalBossEffectSwapper> dictionary = new Dictionary<string, FinalBossEffectSwapper>();
        FinalBossEffectSwapper[] array = effectSwappers;
        foreach (FinalBossEffectSwapper finalBossEffectSwapper in array)
        {
            dictionary[(finalBossEffectSwapper.effect).name] = finalBossEffectSwapper;
        }
        foreach (CardData card in cards)
        {
            for (int num = card.startWithEffects.Length - 1; num >= 0; num--)
            {
                CardData.StatusEffectStacks statusEffectStacks = card.startWithEffects[num];
                if ((statusEffectStacks.data) && dictionary.TryGetValue((statusEffectStacks.data).name, out var value))
                {
                    value.Process(card, statusEffectStacks, num);
                }
            }
        }
    }

    public void RemoveTraits(IList<CardData> cards)
    {
        TraitData[] array = ignoreTraits;
        foreach (TraitData trait in array)
        {
            foreach (CardData card in cards)
            {
                CardData.TraitStacks traitStacks = card.traits.FirstOrDefault((CardData.TraitStacks a) => (a.data).name == (trait).name);
                if (traitStacks != null)
                {
                    card.traits.Remove(traitStacks);
                    Debug.Log($"[{trait}] Removed from {(card).name}");
                }
            }
        }
    }

    public void RunScripts(CardData leader, IList<CardData> cards)
    {
        CardScript[] array = runOnAll;
        foreach (CardScript cardScript in array)
        {
            foreach (CardData card2 in cards)
            {
                Debug.Log(("Running [" + (cardScript).name + "] on " + (card2).name));
                cardScript.Run(card2);
            }
        }
        foreach (CardData card in cards)
        {
            FinalBossCardModifier finalBossCardModifier = cardModifiers.FirstOrDefault((FinalBossCardModifier a) => (a.card).name == (card).name);
            if ((finalBossCardModifier))
            {
                finalBossCardModifier.Run(card);
            }
        }
        if ((leader))
        {
            array = leaderScripts;
            for (int i = 0; i < array.Length; i++)
            {
                array[i].Run(leader);
            }
        }
    }
}
[CreateAssetMenu(fileName = "GameMode", menuName = "Game Mode")]
public class GameMode : DataFile
{
    public string saveFileName = "";

    public string seed;

    public ClassData[] classes;

    public CampaignGenerator generator;

    public CampaignPopulator populator;

    public bool startInNode;

    public bool takeStartingPet = true;

    public bool countsAsWin = true;

    public bool showStats = true;

    public bool gainProgress = true;

    public bool doSave = true;

    public bool canRestart = true;

    public bool canGoBack = true;

    public bool submitScore;

    public bool mainGameMode = true;

    public bool dailyRun;

    public bool tutorialRun;

    [ShowIf("submitScore")]
    public Scores.Type leaderboardType;

    public string startScene;

    public string sceneAfterSelection = "Campaign";

    public string[] campaignSystemNames;

    public string[] systemsToDisable;
}
[CreateAssetMenu(fileName = "Modifier", menuName = "Modifiers/Game Modifier")]
public class GameModifierData : DataFile
{
    public int value = 100;

    public bool visible = true;

    [ShowAssetPreview(64, 64)]
    public Sprite bellSprite;

    [ShowAssetPreview(64, 64)]
    public Sprite dingerSprite;

    public LocalizedString titleKey;

    public LocalizedString descriptionKey;

    public string[] systemsToAdd;

    public Script[] setupScripts;

    public Script[] startScripts;

    public int scriptPriority;

    public GameModifierData[] blockedBy;

    public HardModeModifierData linkedStormBell;

    [SerializeField]
    public EventReference ringSfxEvent;

    [SerializeField]
    public Vector2 ringSfxPitch = new Vector2(1f, 1f);

    public void PlayRingSfx()
    {
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        if (!((ringSfxEvent)).IsNull)
        {
            EventInstance val = SfxSystem.OneShot(ringSfxEvent);
            ((val)).setPitch(Vector2Ext.PettyRandom(ringSfxPitch) * PettyRandom.Range(0.95f, 1.05f));
        }
    }
}
[CreateAssetMenu(menuName = "Game Stat", fileName = "Stat")]
public class GameStatData : ScriptableObject
{
    public enum Type
    {
        Normal,
        Best,
        BestAny,
        Count,
        Time,
        RandomKey,
        Rate,
        BestTime
    }

    public LocalizedString stringKey;

    [SerializeField]
    public Type type;

    [SerializeField]
    [ShowIf("NeedsStatName")]
    public string statName;

    [SerializeField]
    [ShowIf("NeedsKey")]
    public string statKey;

    [SerializeField]
    [ShowIf("NeedsRate")]
    public string statKeyOver;

    [SerializeField]
    [ShowIf("NeedsDefault")]
    public int defaultValue;

    public float displayOrder;

    public float priority;

    public float par = 1f;

    public float priorityAddOverPar;

    public float prioritySubUnderPar;

    public GameStatData[] overwrites;

    public bool NeedsStatName => type != Type.Time;

    public bool NeedsKey
    {
        get
        {
            Type type = this.type;
            return type == Type.Normal || type == Type.Best || type == Type.Rate;
        }
    }

    public bool NeedsDefault
    {
        get
        {
            if (type != Type.Count && type != Type.Time)
            {
                return type != Type.RandomKey;
            }
            return false;
        }
    }

    public bool NeedsRate => type == Type.Rate;

    public float GetPriority(float value)
    {
        float num = value - par;
        float num2 = priority;
        if (num > 0f)
        {
            return num2 + priorityAddOverPar * num;
        }
        return num2 + prioritySubUnderPar * num;
    }

    public float GetValue(CampaignStats stats)
    {
        return type switch
        {
            Type.Best => GetBestValue(stats, statKey),
            Type.BestAny => stats.Best(statName, defaultValue),
            Type.Count => stats.Count(statName),
            Type.Time => Mathf.RoundToInt(stats.time + (float)(stats.hours * 3600)),
            Type.RandomKey => 1f,
            Type.Rate => GetRateValue(stats),
            Type.BestTime => GetBestValue(stats, statKey),
            _ => GetNormalValue(stats, statKey),
        };
    }

    public int GetBestValue(CampaignStats stats, string statKey)
    {
        if (HasMultipleStatKeys(statKey))
        {
            IEnumerable<string> statKeys = GetStatKeys(statKey);
            List<int> list = new List<int>();
            foreach (string item in statKeys)
            {
                list.Add(stats.Best(statName, item, defaultValue));
            }
            return list.Max();
        }
        return stats.Best(statName, statKey, defaultValue);
    }

    public int GetNormalValue(CampaignStats stats, string statKey)
    {
        if (HasMultipleStatKeys(statKey))
        {
            IEnumerable<string> statKeys = GetStatKeys(statKey);
            int num = 0;
            {
                foreach (string item in statKeys)
                {
                    num += stats.Get(statName, item, defaultValue);
                }
                return num;
            }
        }
        return stats.Get(statName, statKey, defaultValue);
    }

    public float GetRateValue(CampaignStats stats)
    {
        float num = GetNormalValue(stats, statKey);
        float num2 = (float)GetNormalValue(stats, statKeyOver) + num;
        if (!(num2 > 0f))
        {
            return (num > 0f) ? 1 : 0;
        }
        return num / num2;
    }

    public static bool HasMultipleStatKeys(string @in)
    {
        return @in.Contains('|');
    }

    public static IEnumerable<string> GetStatKeys(string @in)
    {
        return @in.Split('|');
    }

    public string GetStringValue(CampaignStats stats, float value)
    {
        if (value <= 0f)
        {
            return "-";
        }
        return type switch
        {
            Type.RandomKey => GetRandomStringValue(stats),
            Type.Time => FromSeconds(value),
            Type.BestTime => FromSeconds(value),
            Type.Rate => (value * 100f).ToString("0") + "%",
            _ => Mathf.RoundToInt(value).ToString("N0"),
        };
    }

    public string GetRandomStringValue(CampaignStats stats)
    {
        Dictionary<string, int> dictionary = stats.Get(statName);
        if (dictionary != null)
        {
            string result = "-";
            int num = 0;
            {
                foreach (KeyValuePair<string, int> item in dictionary)
                {
                    if (item.Value >= num)
                    {
                        num = item.Value;
                        result = item.Key;
                    }
                }
                return result;
            }
        }
        return "-";
    }

    public static string FromSeconds(float seconds)
    {
        TimeSpan timeSpan = TimeSpan.FromSeconds(seconds);
        return $"{(int)timeSpan.TotalHours:00}:{timeSpan.Minutes:00}:{timeSpan.Seconds:00}";
    }
}
[CreateAssetMenu(menuName = "Modifiers/Hard Mode Modifier", fileName = "Hard Mode Modifier")]
public class HardModeModifierData : ScriptableObject
{
    public GameModifierData modifierData;

    public int stormPoints;

    public bool unlockedByDefault;

    [HideIf("unlockedByDefault")]
    public HardModeModifierData[] unlockRequires;

    [HideIf("unlockedByDefault")]
    public int unlockRequiresPoints;
}
[CreateAssetMenu(fileName = "Inventory", menuName = "Inventory")]
public class Inventory : ScriptableObject, ISaveable<InventorySaveData>
{
    public CardDataList deck = new CardDataList();

    public CardDataList reserve = new CardDataList();

    public List<CardUpgradeData> upgrades = new List<CardUpgradeData>();

    public SafeInt gold;

    public int goldOwed;

    public void AddGold(int amount)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        gold += amount;
        goldOwed = Mathf.Max(0, goldOwed - amount);
    }

    public Inventory Clone()
    {
        //IL_00ed: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f2: Unknown result type (might be due to invalid IL or missing references)
        Inventory inventory = ObjectExt.InstantiateKeepName<Inventory>(this);
        inventory.deck.Clear();
        inventory.reserve.Clear();
        inventory.upgrades.Clear();
        foreach (CardData item in deck)
        {
            inventory.deck.Add(item.Clone());
        }
        foreach (CardData item2 in reserve)
        {
            inventory.reserve.Add(item2.Clone());
        }
        foreach (CardUpgradeData upgrade in upgrades)
        {
            inventory.upgrades.Add(upgrade.Clone());
        }
        inventory.gold = new SafeInt(((gold)).Value);
        return inventory;
    }

    public InventorySaveData Save()
    {
        return new InventorySaveData(deck.SaveArray<CardData, CardSaveData>(), reserve.SaveArray<CardData, CardSaveData>(), upgrades.SaveArray<CardUpgradeData, CardUpgradeSaveData>(), ((gold)).Value + goldOwed);
    }
}
[CreateAssetMenu(fileName = "Journal Page Data", menuName = "Journal Page Data")]
public class JournalPageData : ScriptableObject
{
    public UnlockData unlock;

    public bool unlockOnMap = true;

    [ShowIf("unlockOnMap")]
    public char mapTierIndex;

    [ShowIf("unlockOnMap")]
    public char mapAfterLetter;

    [ShowIf("unlockOnMap")]
    public CampaignNodeType mapNodeType;

    public AssetReferenceGameObject prefabRef;

    public GameMode[] legalGameModes;

    public ClassData[] legalTribes;

    public GameModifierData[] requiresModifiers;

    public int requiresStormPoints;
}
[CreateAssetMenu(menuName = "Joystick Button Style", fileName = "Joystick Button Style")]
public class JoystickButtonStyle : ScriptableObject
{
    [Serializable]
    public class ElementButton
    {
        public string elementName;

        public Sprite buttonSprite;

        public LocalizedString textKey;

        public bool hasSprite => (buttonSprite);

        public string text => textKey.GetLocalizedString();
    }

    public HardwareJoystickMap[] hardwareMaps;

    public string hardwareIdentifier;

    public int templateId;

    public string tag;

    [SerializeField]
    public ElementButton[] elements;

    [SerializeField]
    public ControllerType type = (ControllerType)2;

    public IEnumerable<Guid> guids => hardwareMaps.Select((HardwareJoystickMap a) => a.Guid);

    public ElementButton GetElement(Player player, string actionName)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        ActionElementMap firstElementMapWithAction = player.controllers.maps.GetFirstElementMapWithAction(type, actionName, true);
        if (firstElementMapWithAction != null)
        {
            return elements[firstElementMapWithAction.elementIndex];
        }
        return null;
    }
}
[CreateAssetMenu(fileName = "Keyword", menuName = "Keyword")]
public class KeywordData : DataFile
{
    [SerializeField]
    public LocalizedString titleKey;

    [SerializeField]
    public LocalizedString descKey;

    public Color titleColour = new Color(1f, 0.7921569f, 0.3411765f, 1f);

    public Color bodyColour = Color.white;

    public Color noteColour = Color.gray;

    public Sprite panelSprite;

    public Color panelColor;

    public string iconName;

    public string iconTintHex;

    public bool show = true;

    public bool showName;

    public bool showIcon = true;

    public bool canStack;

    public bool HasTitle => !((LocalizedReference)titleKey).IsEmpty;

    public string title => titleKey.GetLocalizedString();

    public string body
    {
        get
        {
            string localizedString = descKey.GetLocalizedString();
            int num = localizedString.IndexOf('|');
            if (num <= 0)
            {
                return localizedString;
            }
            return localizedString.Substring(0, num);
        }
    }

    public string note
    {
        get
        {
            string localizedString = descKey.GetLocalizedString();
            int num = localizedString.IndexOf('|');
            if (num <= 0)
            {
                return null;
            }
            return localizedString.Substring(num + 1);
        }
    }
}
[CreateAssetMenu(fileName = "New Leader Profile", menuName = "Leader Profile")]
public class LeaderProfileData : ScriptableObject
{
    [Serializable]
    public class Collection
    {
        public enum Type
        {
            Prefab,
            Sprite,
            ColorSet
        }

        public string collectionName;

        public Type type;

        public CollectionModifier modifier;

        public void AddTo(CharacterType characterType, float multiply = 1f)
        {
            switch (type)
            {
                case Type.Prefab:
                    {
                        PrefabCollection collection2 = characterType.prefabs.First((CharacterType.PrefabGroup a) => a.name == collectionName).collection;
                        CollectionModifier.Modify[] list = modifier.list;
                        for (int i = 0; i < list.Length; i++)
                        {
                            CollectionModifier.Modify modify2 = list[i];
                            collection2.AddWeight(modify2.index, modify2.addWeight * multiply);
                        }
                        break;
                    }
                case Type.Sprite:
                    {
                        SpriteCollection collection3 = characterType.sprites.First((CharacterType.SpriteGroup a) => a.name == collectionName).collection;
                        CollectionModifier.Modify[] list = modifier.list;
                        for (int i = 0; i < list.Length; i++)
                        {
                            CollectionModifier.Modify modify3 = list[i];
                            collection3.AddWeight(modify3.index, modify3.addWeight * multiply);
                        }
                        break;
                    }
                case Type.ColorSet:
                    {
                        ColorSetCollection collection = characterType.colorSets.First((CharacterType.ColorSetGroup a) => a.name == collectionName).collection;
                        CollectionModifier.Modify[] list = modifier.list;
                        for (int i = 0; i < list.Length; i++)
                        {
                            CollectionModifier.Modify modify = list[i];
                            collection.AddWeight(modify.index, modify.addWeight * multiply);
                        }
                        break;
                    }
            }
        }
    }

    [SerializeField]
    public SpriteCollection backgroundPool;

    [SerializeField]
    public Collection[] collectionsToAdd;

    public Sprite GetRandomBackground()
    {
        return backgroundPool.RandomItem();
    }

    public void Apply(CharacterType type)
    {
        Collection[] array = collectionsToAdd;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].AddTo(type);
        }
    }

    public void UnApply(CharacterType type)
    {
        Collection[] array = collectionsToAdd;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].AddTo(type, -1f);
        }
    }
}
[CreateAssetMenu(fileName = "RewardData", menuName = "Reward Data")]
public class RewardData : ScriptableObject
{
    public string title;

    public string description;

    public Sprite icon;

    public GameObject buttonPrefab;

    public UISequence selectionScreenPrefab;

    public string acquireScript;

    public string[] acquireScriptArgs;

    public Sprite setCampaignNodeIcon;
}
[CreateAssetMenu(menuName = "Reward Pool", fileName = "RewardPool")]
public class RewardPool : ScriptableObject
{
    public enum Type
    {
        Items,
        Units,
        Charms
    }

    public string type;

    public int copies = 1;

    public List<DataFile> list;

    public bool isGeneralPool;
}
public abstract class ScriptableAmount : ScriptableObject
{
    public virtual int Get(Entity entity)
    {
        return 0;
    }

    public ScriptableAmount()
    {
    }
}
[CreateAssetMenu(menuName = "Scriptable Amount/Cards In Hand", fileName = "CardsInHand")]
public class ScriptableCardsInHand : ScriptableAmount
{
    public override int Get(Entity entity)
    {
        return References.Player.handContainer.Count;
    }
}
[CreateAssetMenu(menuName = "Scriptable Amount/Current Attack", fileName = "CurrentAttack")]
public class ScriptableCurrentAttack : ScriptableAmount
{
    [SerializeField]
    public float multiplier = 1f;

    [SerializeField]
    public bool roundUp;

    public override int Get(Entity entity)
    {
        if (!(entity))
        {
            return 0;
        }
        return Mult(entity.damage.current + ((entity.tempDamage)).Value);
    }

    public int Mult(int amount)
    {
        if (!roundUp)
        {
            return Mathf.FloorToInt((float)amount * multiplier);
        }
        return Mathf.RoundToInt((float)amount * multiplier);
    }
}
[CreateAssetMenu(menuName = "Scriptable Amount/Current Health", fileName = "CurrentHealth")]
public class ScriptableCurrentHealth : ScriptableAmount
{
    [SerializeField]
    public float multiplier = 1f;

    [SerializeField]
    public bool roundUp;

    public override int Get(Entity entity)
    {
        if (!(entity) || !entity.data.hasHealth)
        {
            return 0;
        }
        return Mult(entity.hp.current);
    }

    public int Mult(int amount)
    {
        if (!roundUp)
        {
            return Mathf.FloorToInt((float)amount * multiplier);
        }
        return Mathf.RoundToInt((float)amount * multiplier);
    }
}
[CreateAssetMenu(menuName = "Scriptable Amount/Current Status", fileName = "CurrentStatus")]
public class ScriptableCurrentStatus : ScriptableAmount
{
    [SerializeField]
    public string statusType = "shroom";

    [SerializeField]
    public int offset;

    [SerializeField]
    public float multiplier = 1f;

    [SerializeField]
    public bool roundUp;

    public override int Get(Entity entity)
    {
        int num;
        if (!(entity))
        {
            num = offset;
        }
        else
        {
            StatusEffectData statusEffectData = entity.FindStatus(statusType);
            num = ((statusEffectData != null) ? (statusEffectData.count + offset) : offset);
        }
        int amount = num;
        return Mult(amount);
    }

    public int Mult(int amount)
    {
        if (!roundUp)
        {
            return Mathf.FloorToInt((float)amount * multiplier);
        }
        return Mathf.RoundToInt((float)amount * multiplier);
    }
}
[CreateAssetMenu(menuName = "Scriptable Amount/Fixed Amount", fileName = "One")]
public class ScriptableFixedAmount : ScriptableAmount
{
    [SerializeField]
    public int amount = 1;

    public override int Get(Entity entity)
    {
        return amount;
    }
}
[CreateAssetMenu(menuName = "Scriptable Amount/Gold", fileName = "Gold")]
public class ScriptableGold : ScriptableAmount
{
    [SerializeField]
    public float factor;

    public override int Get(Entity entity)
    {
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        SafeInt val = References.PlayerData.inventory.gold + References.PlayerData.inventory.goldOwed;
        return Mathf.FloorToInt((float)((val)).Value * factor);
    }
}
[CreateAssetMenu(menuName = "Scriptable Amount/Health Lost", fileName = "HealthLost")]
public class ScriptableHealthLost : ScriptableAmount
{
    public override int Get(Entity entity)
    {
        if (!(entity))
        {
            return 0;
        }
        return entity.lastHit?.damageDealt ?? 0;
    }
}
public abstract class Script : ScriptableObject
{
    public virtual IEnumerator Run()
    {
        return null;
    }

    public Script()
    {
    }
}
public abstract class SelectScript<T> : ScriptableObject
{
    public abstract List<T> Run(List<T> group);

    public SelectScript()
    {
    }
}
public abstract class StatusEffectData : DataFile
{
    public delegate IEnumerator EffectEventHandler();

    public delegate IEnumerator EffectStackEventHandler(int stacks);

    public delegate IEnumerator EffectCharacterEventHandler(Character character);

    public delegate IEnumerator EffectEntityEventHandler(Entity entity);

    public delegate IEnumerator EffectEntityDeathEventHandler(Entity entity, DeathType deathType);

    public delegate IEnumerator EffectCardPlayEventHandler(Entity entity, Entity[] targets);

    public delegate IEnumerator EffectTriggerEventHandler(Trigger trigger);

    public delegate IEnumerator EffectCardMoveEventHandler(Entity entity, CardContainer[] fromContainers);

    public delegate IEnumerator EffectHitEventHandler(Hit hit);

    public delegate IEnumerator EffectApplyEventHandler(StatusEffectApply apply);

    public delegate IEnumerator EffectActionPerformedHandler(PlayAction action);

    public static ulong idCurrent;

    public ulong id;

    public StatusEffectData original;

    public bool isClone;

    public bool isStatus;

    public bool isReaction;

    public bool isKeyword;

    public string type;

    public string keyword;

    public string iconGroupName;

    public bool visible;

    public bool stackable = true;

    public bool offensive;

    public bool makesOffensive;

    public bool doesDamage;

    public bool canBeBoosted;

    [InfoBox(/*Could not decode attribute arguments.*/)]
    public LocalizedString textKey;

    public string textInsert;

    public int textOrder;

    [TextArea]
    [SerializeField]
    public string desc;

    [SerializeField]
    public string descColorHex;

    [SerializeField]
    public int descOrder;

    public KeywordData[] hiddenKeywords;

    public string applyFormat;

    public LocalizedString applyFormatKey;

    [InfoBox(/*Could not decode attribute arguments.*/)]
    [SerializeField]
    public bool affectedBySnow;

    [InfoBox(/*Could not decode attribute arguments.*/)]
    public int eventPriority;

    public bool removeOnDiscard;

    public bool preventDeath;

    [Header("Constraints that must be met for this to be applied")]
    public TargetConstraint[] targetConstraints;

    public bool removing;

    public int temporary;

    [HideInInspector]
    public Entity applier;

    [HideInInspector]
    public Character applierOwner;

    [HideInInspector]
    public Entity target;

    [ReadOnly]
    public int count;

    public bool HasDesc
    {
        get
        {
            if (!Instant)
            {
                return !((LocalizedReference)textKey).IsEmpty;
            }
            return false;
        }
    }

    public bool HasDescOrIsKeyword
    {
        get
        {
            if (!isKeyword)
            {
                return HasDesc;
            }
            return true;
        }
    }

    public virtual bool Instant => false;

    public virtual bool CanStackActions => true;

    public virtual bool HasBeginRoutine => this.OnBegin != null;

    public virtual bool HasEndRoutine => this.OnEnd != null;

    public virtual bool HasEnableRoutine => this.OnEnable != null;

    public virtual bool HasDisableRoutine => this.OnDisable != null;

    public virtual bool HasStackRoutine => this.OnStack != null;

    public virtual bool HasTurnStartRoutine
    {
        get
        {
            if (this.OnTurnStart != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasTurnRoutine
    {
        get
        {
            if (this.OnTurn != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasTurnEndRoutine
    {
        get
        {
            if (this.OnTurnEnd != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasPreAttackRoutine
    {
        get
        {
            if (this.PreAttack != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasHitRoutine
    {
        get
        {
            if (this.OnHit != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasPostHitRoutine
    {
        get
        {
            if (this.PostHit != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasPostAttackRoutine
    {
        get
        {
            if (this.PostAttack != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasApplyStatusRoutine
    {
        get
        {
            if (this.OnApplyStatus != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasPostApplyStatusRoutine
    {
        get
        {
            if (this.PostApplyStatus != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasEntityDestroyedRoutine
    {
        get
        {
            if (this.OnEntityDestroyed != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasPreTriggerRoutine
    {
        get
        {
            if (this.PreTrigger != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasPreCardPlayedRoutine
    {
        get
        {
            if (this.PreCardPlayed != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasCardMoveRoutine
    {
        get
        {
            if (this.OnCardMove != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasCardPlayedRoutine
    {
        get
        {
            if (this.OnCardPlayed != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasEffectBonusChangedRoutine
    {
        get
        {
            if (this.OnEffectBonusChanged != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasActionPerformedRoutine
    {
        get
        {
            if (this.OnActionPerformed != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public virtual bool HasBuildRoutine
    {
        get
        {
            if (this.OnBuild != null)
            {
                return HasActiveTarget;
            }
            return false;
        }
    }

    public bool HasActiveTarget
    {
        get
        {
            if (target != null)
            {
                return ((Behaviour)target).enabled;
            }
            return false;
        }
    }

    public event EffectEventHandler OnBegin;

    public event EffectEventHandler OnEnd;

    public event EffectEntityEventHandler OnEnable;

    public event EffectEntityEventHandler OnDisable;

    public event EffectStackEventHandler OnStack;

    public event EffectEntityEventHandler OnTurnStart;

    public event EffectEntityEventHandler OnTurn;

    public event EffectEntityEventHandler OnTurnEnd;

    public event EffectHitEventHandler PreAttack;

    public event EffectHitEventHandler OnHit;

    public event EffectHitEventHandler PostHit;

    public event EffectHitEventHandler PostAttack;

    public event EffectApplyEventHandler OnApplyStatus;

    public event EffectApplyEventHandler PostApplyStatus;

    public event EffectEntityDeathEventHandler OnEntityDestroyed;

    public event EffectEntityEventHandler OnCardMove;

    public event EffectTriggerEventHandler PreTrigger;

    public event EffectCardPlayEventHandler PreCardPlayed;

    public event EffectCardPlayEventHandler OnCardPlayed;

    public event EffectEventHandler OnEffectBonusChanged;

    public event EffectActionPerformedHandler OnActionPerformed;

    public event EffectEntityEventHandler OnBuild;

    public StatusEffectData Instantiate()
    {
        StatusEffectData statusEffectData = GetOriginal();
        StatusEffectData statusEffectData2 = Object.Instantiate<StatusEffectData>(statusEffectData);
        statusEffectData2.id = idCurrent++;
        (statusEffectData2).name = name;
        statusEffectData2.original = statusEffectData;
        statusEffectData2.isClone = true;
        return statusEffectData2;
    }

    public StatusEffectData GetOriginal()
    {
        if (!isClone)
        {
            return this;
        }
        return original;
    }

    public string GetDesc(int amount, bool silenced = false)
    {
        string text = Text.GetEffectText(textKey, textInsert, amount, silenced);
        if (!StringExt.IsNullOrWhitespace(descColorHex))
        {
            text = "<color=#" + descColorHex + ">" + text + "</color>";
        }
        return text;
    }

    public string GetPlainDesc()
    {
        return desc;
    }

    public string GetApplyFormat()
    {
        LocalizedString val = applyFormatKey;
        if (val == null || ((LocalizedReference)val).IsEmpty)
        {
            return null;
        }
        return Text.HandleBracketTags(applyFormatKey.GetLocalizedString());
    }

    public virtual object GetMidBattleData()
    {
        return null;
    }

    public virtual void RestoreMidBattleData(object data)
    {
    }

    public bool CanPlayOn(Entity target)
    {
        TargetConstraint[] array = targetConstraints;
        for (int i = 0; i < array.Length; i++)
        {
            if (!array[i].Check(target))
            {
                return false;
            }
        }
        return true;
    }

    public virtual bool CanTrigger()
    {
        if (((Behaviour)target).enabled && !target.silenced)
        {
            if (affectedBySnow)
            {
                if (!target.IsSnowed)
                {
                    return !target.paused;
                }
                return false;
            }
            return true;
        }
        return false;
    }

    public bool IsNegativeStatusEffect()
    {
        if (offensive && visible)
        {
            return isStatus;
        }
        return false;
    }

    public virtual bool RunBeginEvent()
    {
        return true;
    }

    public virtual bool RunEndEvent()
    {
        return true;
    }

    public virtual bool RunEnableEvent(Entity entity)
    {
        return true;
    }

    public virtual bool RunDisableEvent(Entity entity)
    {
        return true;
    }

    public virtual bool RunStackEvent(int stacks)
    {
        return true;
    }

    public virtual bool RunTurnStartEvent(Entity entity)
    {
        return true;
    }

    public virtual bool RunTurnEvent(Entity entity)
    {
        return true;
    }

    public virtual bool RunTurnEndEvent(Entity entity)
    {
        return true;
    }

    public virtual bool RunPreAttackEvent(Hit hit)
    {
        return true;
    }

    public virtual bool RunHitEvent(Hit hit)
    {
        return true;
    }

    public virtual bool RunPostHitEvent(Hit hit)
    {
        return true;
    }

    public virtual bool RunPostAttackEvent(Hit hit)
    {
        return true;
    }

    public virtual bool RunApplyStatusEvent(StatusEffectApply apply)
    {
        return true;
    }

    public virtual bool RunPostApplyStatusEvent(StatusEffectApply apply)
    {
        return true;
    }

    public virtual bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        return true;
    }

    public virtual bool RunCardMoveEvent(Entity entity)
    {
        return true;
    }

    public virtual bool RunPreTriggerEvent(Trigger trigger)
    {
        return true;
    }

    public virtual bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
    {
        return true;
    }

    public virtual bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        return true;
    }

    public virtual bool RunEffectBonusChangedEvent()
    {
        return true;
    }

    public virtual bool RunActionPerformedEvent(PlayAction action)
    {
        return true;
    }

    public virtual bool RunBuildEvent(Entity entity)
    {
        return true;
    }

    public virtual IEnumerator BeginRoutine()
    {
        return this.OnBegin();
    }

    public virtual IEnumerator EndRoutine()
    {
        return this.OnEnd();
    }

    public virtual IEnumerator EnableRoutine(Entity entity)
    {
        return this.OnEnable(entity);
    }

    public virtual IEnumerator DisableRoutine(Entity entity)
    {
        return this.OnDisable(entity);
    }

    public virtual IEnumerator StackRoutine(int stacks)
    {
        return this.OnStack(stacks);
    }

    public virtual IEnumerator TurnStartRoutine(Entity entity)
    {
        return this.OnTurnStart(entity);
    }

    public virtual IEnumerator TurnRoutine(Entity entity)
    {
        return this.OnTurn(entity);
    }

    public virtual IEnumerator TurnEndRoutine(Entity entity)
    {
        return this.OnTurnEnd(entity);
    }

    public virtual IEnumerator PreAttackRoutine(Hit hit)
    {
        return this.PreAttack(hit);
    }

    public virtual IEnumerator HitRoutine(Hit hit)
    {
        return this.OnHit(hit);
    }

    public virtual IEnumerator PostHitRoutine(Hit hit)
    {
        return this.PostHit(hit);
    }

    public virtual IEnumerator PostAttackRoutine(Hit hit)
    {
        return this.PostAttack(hit);
    }

    public virtual IEnumerator ApplyStatusRoutine(StatusEffectApply apply)
    {
        return this.OnApplyStatus(apply);
    }

    public virtual IEnumerator PostApplyStatusRoutine(StatusEffectApply apply)
    {
        return this.PostApplyStatus(apply);
    }

    public virtual IEnumerator EntityDestroyedRoutine(Entity entity, DeathType deathType)
    {
        return this.OnEntityDestroyed(entity, deathType);
    }

    public virtual IEnumerator CardMoveRoutine(Entity entity)
    {
        return this.OnCardMove(entity);
    }

    public virtual IEnumerator PreTriggerRoutine(Trigger trigger)
    {
        return this.PreTrigger(trigger);
    }

    public virtual IEnumerator PreCardPlayedRoutine(Entity entity, Entity[] targets)
    {
        return this.PreCardPlayed(entity, targets);
    }

    public virtual IEnumerator CardPlayedRoutine(Entity entity, Entity[] targets)
    {
        return this.OnCardPlayed(entity, targets);
    }

    public virtual IEnumerator EffectBonusChangedRoutine()
    {
        return this.OnEffectBonusChanged();
    }

    public virtual IEnumerator ActionPerformedRoutine(PlayAction action)
    {
        return this.OnActionPerformed(action);
    }

    public virtual IEnumerator BuildRoutine(Entity entity)
    {
        return this.OnBuild(entity);
    }

    public void Apply(int count, Entity target, Entity applier)
    {
        this.count = count;
        this.target = target;
        this.applier = applier;
        target.statusEffects.Add(this);
        Init();
    }

    public virtual void Init()
    {
    }

    public IEnumerator CountDown(Entity entity, int amount)
    {
        if ((target) && ((Behaviour)target).enabled && entity == target)
        {
            yield return RemoveStacks(amount, removeTemporary: false);
        }
    }

    public virtual IEnumerator RemoveStacks(int amount, bool removeTemporary)
    {
        count -= amount;
        if (removeTemporary)
        {
            temporary -= amount;
        }
        if (count <= 0)
        {
            yield return Remove();
        }
        target.PromptUpdate();
    }

    public IEnumerator Remove()
    {
        if (!removing)
        {
            removing = true;
            target.statusEffects.Remove(this);
            StatusEffectSystem.activeEffects.Remove(this);
            target.PromptUpdate();
            if (RunEndEvent() && HasEndRoutine)
            {
                yield return EndRoutine();
            }
            Destroy();
        }
    }

    public void Destroy()
    {
        if ((this))
        {
            string arg = ((target) ? (target).name : "null");
            Debug.Log($"[{name} {count}] removed from [{arg}]");
            StatusEffectSystem.activeEffects.Remove(this);
            Object.Destroy(this);
        }
    }

    public virtual int GetAmount()
    {
        if (!(target) || target.silenced)
        {
            return 0;
        }
        if (!canBeBoosted)
        {
            return count;
        }
        return Mathf.Max(0, Mathf.RoundToInt((float)(count + target.effectBonus) * target.effectFactor));
    }

    public Entity GetDamager()
    {
        if (!(applier))
        {
            if (!(applierOwner) || !(applierOwner.entity))
            {
                return null;
            }
            return applierOwner.entity;
        }
        return applier;
    }

    public CardContainer[] GetTargetContainers()
    {
        CardContainer[] containers = target.containers;
        if (containers != null && containers.Length != 0)
        {
            return containers;
        }
        return target.preContainers;
    }

    public CardContainer[] GetTargetActualContainers()
    {
        List<CardContainer> actualContainers = target.actualContainers;
        if (actualContainers != null && actualContainers.Count != 0)
        {
            return actualContainers.ToArray();
        }
        return target.preActualContainers;
    }

    public StatusEffectData()
    {
    }
}
public abstract class TargetConstraint : ScriptableObject
{
    [SerializeField]
    public bool not;

    public virtual bool Check(Entity target)
    {
        throw new NotImplementedException();
    }

    public virtual bool Check(CardData targetData)
    {
        throw new NotImplementedException();
    }

    public TargetConstraint()
    {
    }
}
public abstract class TargetMode : ScriptableObject
{
    public virtual bool TargetRow => false;

    public virtual bool NeedsTarget => true;

    public virtual bool Random => false;

    public virtual Entity[] GetPotentialTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        throw new NotImplementedException();
    }

    public virtual Entity[] GetTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        return GetPotentialTargets(entity, target, targetContainer);
    }

    public virtual Entity[] GetSubsequentTargets(Entity entity, Entity target, CardContainer targetContainer)
    {
        HashSet<Entity> hashSet = new HashSet<Entity>();
        if ((target))
        {
            hashSet.Add(target);
        }
        else if ((targetContainer))
        {
            HashSetExt.AddRange<Entity>(hashSet, (IEnumerable<Entity>)targetContainer);
        }
        return HashSetExt.ToArray<Entity>(hashSet);
    }

    public virtual CardSlot[] GetTargetSlots(CardSlotLane row)
    {
        return row.slots.Where((CardSlot a) => a.Empty).ToArray();
    }

    public virtual bool CanTarget(Entity entity)
    {
        return true;
    }

    public virtual Entity GetEnemyCharacter(Entity entity)
    {
        Entity result = null;
        Character character = ((entity.owner == Battle.instance.player) ? Battle.instance.enemy : Battle.instance.player);
        if ((character) && (character.entity) && character.entity.canBeHit)
        {
            result = character.entity;
        }
        return result;
    }

    public TargetMode()
    {
    }
}
[CreateAssetMenu(menuName = "Text Image Data", fileName = "Text Image Data")]
public class TextImageData : ScriptableObject
{
    [SerializeField]
    public List<char> chars;

    [SerializeField]
    public List<Sprite> sprites;

    public bool TryGetSprite(char value, out Sprite result)
    {
        int num = chars.IndexOf(value);
        if (num >= 0)
        {
            result = sprites[num];
            return true;
        }
        result = null;
        return false;
    }
}
[CreateAssetMenu(fileName = "Building Plot", menuName = "Town/Building Plot")]
public class BuildingPlotType : DataFile
{
    [SerializeField]
    public BuildingType[] illegalBuildings;
}
[CreateAssetMenu(fileName = "Building", menuName = "Town/Building")]
public class BuildingType : DataFile
{
    public LocalizedString titleKey;

    public LocalizedString helpKey;

    public Prompt.Emote.Type helpEmoteType = Prompt.Emote.Type.Explain;

    [Header("Progression")]
    public UnlockData started;

    public UnlockData finished;

    public UnlockData[] unlocks;

    public string unlockedCheckedKey;
}
[CreateAssetMenu(fileName = "New Trait", menuName = "Trait")]
public class TraitData : DataFile
{
    public KeywordData keyword;

    public StatusEffectData[] effects;

    public TraitData[] overrides;

    public bool isReaction;
}
[CreateAssetMenu(menuName = "Town/Unlock", fileName = "Unlock")]
public class UnlockData : DataFile
{
    public enum Type
    {
        None,
        BuildingStarted,
        BuildingFinished,
        Item,
        Pet,
        Tribe,
        Companion,
        Event,
        JournalPage,
        Charm
    }

    [SerializeField]
    public bool active = true;

    [ShowIf("active")]
    public bool activeInDemo = true;

    [ShowIf("active")]
    public bool activeInPressDemo = true;

    public Type type;

    public BuildingType relatedBuilding;

    public float lowPriority;

    public UnlockData[] requires;

    public LocalizedString unlockTitle;

    public LocalizedString unlockDesc;

    public bool IsActive => active;
}
public static class CreatedByLookup
{
    public static readonly Dictionary<string, string> lookup = new Dictionary<string, string>
    {
        { "Dregg", "Egg" },
        { "TailsOne", "TailsTwo" },
        { "TailsTwo", "TailsThree" },
        { "TailsThree", "TailsFour" },
        { "TailsFour", "TailsFive" },
        { "Beepop", "BeepopMask" },
        { "Plep", "JunjunMask" },
        { "Fallow", "FallowMask" },
        { "Tigris", "TigrisMask" },
        { "Leech", "Leecher" },
        { "Pigeon", "PigeonCage" },
        { "Popper", "PopPopper" },
        { "Snuffer", "SnufferMask" }
    };

    public static bool TryGetCreatedBy(string cardDataName, out string parentCardDataName)
    {
        if (lookup.TryGetValue(cardDataName, out var value))
        {
            parentCardDataName = value;
            return true;
        }
        parentCardDataName = cardDataName;
        return false;
    }

    public static void TryGetCreatedByRoot(string cardDataName, out string rootCardDataName)
    {
        rootCardDataName = cardDataName;
        while (TryGetCreatedBy(rootCardDataName, out rootCardDataName))
        {
        }
    }

    public static List<string> GetCreatedByThis(string cardDataName)
    {
        List<string> list = new List<string>();
        foreach (var (text3, text4) in lookup)
        {
            if (text4 == cardDataName)
            {
                list.Add(text3);
                list.AddRange(GetCreatedByThis(text3));
            }
        }
        return list;
    }

    public static void Add(string cardDataName, string parentCardDataName)
    {
        lookup.Add(cardDataName, parentCardDataName);
    }
}
public static class DailyFetcher
{
    public static int DayOffset;

    public static DateTime dateTime;

    public static bool fetched { get; set; }

    public static IEnumerator FetchDateTime()
    {
        dateTime = DateTime.Now.AddDays(DayOffset);
        fetched = true;
        yield break;
    }

    public static void CancelFetch()
    {
        fetched = false;
    }

    public static void SetContinueDateTime()
    {
        dateTime = DateTime.ParseExact(SaveSystem.LoadCampaignData(Campaign.Data.GameMode, "startDate", ""), "dd/MM/yyyy", GameManager.CultureInfo);
    }

    public static DateTime GetDateTime()
    {
        return dateTime;
    }

    public static DateTime GetNextDateTime()
    {
        return dateTime.Date.AddDays(1.0);
    }

    public static int GetSeed()
    {
        DateTime dateTime = GetDateTime();
        int.TryParse($"{dateTime:yyMMdd}{dateTime.DayOfYear:D3}", out var result);
        return result;
    }

    public static string GetDate()
    {
        return GetDateTime().ToString("dd/MM/yyyy");
    }

    public static string GetLeaderboardName()
    {
        return GetLeaderboardName(GetDateTime());
    }

    public static string GetLeaderboardName(DateTime dateTime)
    {
        return GetLeaderboardName(dateTime.ToString("dd/MM/yyyy"));
    }

    public static string GetLeaderboardName(string dateString)
    {
        return "Daily-" + dateString;
    }

    public static bool CanPlay()
    {
        string text = SaveSystem.LoadProgressData<string>("dailyPlayed", null);
        if (!StringExt.IsNullOrWhitespace(text) && DateTime.TryParse(text, out var result))
        {
            return !SameDay(GetDateTime(), result);
        }
        return true;
    }

    public static bool SameDay(DateTime a, DateTime b)
    {
        if (a.Year == b.Year)
        {
            return a.DayOfYear == b.DayOfYear;
        }
        return false;
    }
}
public static class Events
{
    public static event UnityAction<Scene> OnSceneLoaded;

    public static void InvokeSceneLoaded(Scene scene)
    {
        UnityAction<Scene> onSceneLoaded = global::Events.OnSceneLoaded;
        if (onSceneLoaded == null)
            return;
        onSceneLoaded(scene);
    }

    public static event UnityAction<Scene> OnSceneChanged;

    public static void InvokeSceneChanged(Scene scene)
    {
        UnityAction<Scene> onSceneChanged = global::Events.OnSceneChanged;
        if (onSceneChanged == null)
            return;
        onSceneChanged(scene);
    }

    public static event UnityAction<Scene> OnSceneUnload;

    public static void InvokeSceneUnload(Scene scene)
    {
        UnityAction<Scene> onSceneUnload = global::Events.OnSceneUnload;
        if (onSceneUnload == null)
            return;
        onSceneUnload(scene);
    }

    public static event UnityAction OnBackToMainMenu;

    public static void InvokeBackToMainMenu()
    {
        UnityAction onBackToMainMenu = global::Events.OnBackToMainMenu;
        if (onBackToMainMenu == null)
            return;
        onBackToMainMenu();
    }

    public static event UnityAction<Entity> OnEntityCreated;

    public static void InvokeEntityCreated(Entity entity)
    {
        UnityAction<Entity> onEntityCreated = global::Events.OnEntityCreated;
        if (onEntityCreated == null)
            return;
        onEntityCreated(entity);
    }

    public static event UnityAction<Entity> OnEntityDataUpdated;

    public static void InvokeEntityDataUpdated(Entity entity)
    {
        UnityAction<Entity> entityDataUpdated = global::Events.OnEntityDataUpdated;
        if (entityDataUpdated == null)
            return;
        entityDataUpdated(entity);
    }

    public static event UnityAction<Entity> OnEntityDestroyed;

    public static void InvokeEntityDestroyed(Entity entity)
    {
        UnityAction<Entity> onEntityDestroyed = global::Events.OnEntityDestroyed;
        if (onEntityDestroyed == null)
            return;
        onEntityDestroyed(entity);
    }

    public static event UnityAction<Card> OnCardPooled;

    public static void InvokeCardPooled(Card card)
    {
        UnityAction<Card> onCardPooled = global::Events.OnCardPooled;
        if (onCardPooled == null)
            return;
        onCardPooled(card);
    }

    public static event UnityAction<Entity> OnEntityEnabled;

    public static void InvokeEntityEnabled(Entity entity)
    {
        UnityAction<Entity> onEntityEnabled = global::Events.OnEntityEnabled;
        if (onEntityEnabled == null)
            return;
        onEntityEnabled(entity);
    }

    public static event UnityAction<Entity> OnEntityDisabled;

    public static void InvokeEntityDisabled(Entity entity)
    {
        UnityAction<Entity> onEntityDisabled = global::Events.OnEntityDisabled;
        if (onEntityDisabled == null)
            return;
        onEntityDisabled(entity);
    }

    public static event UnityAction<Entity, DeathType> OnEntityKilled;

    public static void InvokeEntityKilled(Entity entity, DeathType deathType)
    {
        UnityAction<Entity, DeathType> onEntityKilled = global::Events.OnEntityKilled;
        if (onEntityKilled == null)
            return;
        onEntityKilled(entity, deathType);
    }

    public static event UnityAction<Entity> OnEntityFlee;

    public static void InvokeEntityFlee(Entity entity)
    {
        UnityAction<Entity> onEntityFlee = global::Events.OnEntityFlee;
        if (onEntityFlee == null)
            return;
        onEntityFlee(entity);
    }

    public static event UnityAction<Entity> OnEntityHover;

    public static void InvokeEntityHover(Entity entity)
    {
        UnityAction<Entity> onEntityHover = global::Events.OnEntityHover;
        if (onEntityHover == null)
            return;
        onEntityHover(entity);
    }

    public static event UnityAction<Entity> OnEntityUnHover;

    public static void InvokeEntityUnHover(Entity entity)
    {
        UnityAction<Entity> onEntityUnHover = global::Events.OnEntityUnHover;
        if (onEntityUnHover == null)
            return;
        onEntityUnHover(entity);
    }

    public static event UnityAction<Entity> OnEntitySelect;

    public static void InvokeEntitySelect(Entity entity)
    {
        UnityAction<Entity> onEntitySelect = global::Events.OnEntitySelect;
        if (onEntitySelect == null)
            return;
        onEntitySelect(entity);
    }

    public static event global::Events.UnityActionRef<Entity, bool> OnCheckEntityDrag;

    public static bool CheckEntityDrag(Entity entity)
    {
        bool flag = true;
        global::Events.UnityActionRef<Entity, bool> onCheckEntityDrag = global::Events.OnCheckEntityDrag;
        if (onCheckEntityDrag != null)
            onCheckEntityDrag(ref entity, ref flag);
        return flag;
    }

    public static event UnityAction<Entity> OnEntityDrag;

    public static void InvokeEntityDrag(Entity entity)
    {
        UnityAction<Entity> onEntityDrag = global::Events.OnEntityDrag;
        if (onEntityDrag == null)
            return;
        onEntityDrag(entity);
    }

    public static event UnityAction<Entity> OnEntityRelease;

    public static void InvokeEntityRelease(Entity entity)
    {
        UnityAction<Entity> onEntityRelease = global::Events.OnEntityRelease;
        if (onEntityRelease == null)
            return;
        onEntityRelease(entity);
    }

    public static event UnityAction<Entity> OnEntityOffered;

    public static void InvokeEntityOffered(Entity entity)
    {
        UnityAction<Entity> onEntityOffered = global::Events.OnEntityOffered;
        if (onEntityOffered == null)
            return;
        onEntityOffered(entity);
    }

    public static event UnityAction<Entity> OnEntityChosen;

    public static void InvokeEntityChosen(Entity entity)
    {
        UnityAction<Entity> onEntityChosen = global::Events.OnEntityChosen;
        if (onEntityChosen == null)
            return;
        onEntityChosen(entity);
    }

    public static event UnityAction<Entity> OnEntityShowUnlocked;

    public static void InvokeEntityShowUnlocked(Entity entity)
    {
        UnityAction<Entity> entityShowUnlocked = global::Events.OnEntityShowUnlocked;
        if (entityShowUnlocked == null)
            return;
        entityShowUnlocked(entity);
    }

    public static event global::Events.UnityActionRef<Entity, bool> OnCheckEntityShove;

    public static bool CheckEntityShove(Entity entity)
    {
        bool flag = true;
        global::Events.UnityActionRef<Entity, bool> checkEntityShove = global::Events.OnCheckEntityShove;
        if (checkEntityShove != null)
            checkEntityShove(ref entity, ref flag);
        return flag;
    }

    public static event UnityAction<Entity> OnPreProcessTrigger;

    public static void InvokePreProcessTrigger(Entity entity)
    {
        UnityAction<Entity> preProcessTrigger = global::Events.OnPreProcessTrigger;
        if (preProcessTrigger == null)
            return;
        preProcessTrigger(entity);
    }

    public static event global::Events.UnityActionRef<Trigger> OnEntityPreTrigger;

    public static void InvokeEntityPreTrigger(ref Trigger trigger)
    {
        global::Events.UnityActionRef<Trigger> entityPreTrigger = global::Events.OnEntityPreTrigger;
        if (entityPreTrigger == null)
            return;
        entityPreTrigger(ref trigger);
    }

    public static event global::Events.UnityActionRef<Trigger> OnEntityTrigger;

    public static void InvokeEntityTrigger(ref Trigger trigger)
    {
        global::Events.UnityActionRef<Trigger> onEntityTrigger = global::Events.OnEntityTrigger;
        if (onEntityTrigger == null)
            return;
        onEntityTrigger(ref trigger);
    }

    public static event global::Events.UnityActionRef<Trigger> OnEntityTriggered;

    public static void InvokeEntityTriggered(ref Trigger trigger)
    {
        global::Events.UnityActionRef<Trigger> onEntityTriggered = global::Events.OnEntityTriggered;
        if (onEntityTriggered == null)
            return;
        onEntityTriggered(ref trigger);
    }

    public static event UnityAction<Entity> OnEntityMove;

    public static void InvokeEntityMove(Entity entity)
    {
        UnityAction<Entity> onEntityMove = global::Events.OnEntityMove;
        if (onEntityMove == null)
            return;
        onEntityMove(entity);
    }

    public static event UnityAction<Entity, CardContainer[], bool> OnEntityPlace;

    public static void InvokeEntityPlace(Entity entity, CardContainer[] containers, bool freeMove)
    {
        UnityAction<Entity, CardContainer[], bool> onEntityPlace = global::Events.OnEntityPlace;
        if (onEntityPlace == null)
            return;
        onEntityPlace(entity, containers, freeMove);
    }

    public static event UnityAction<Entity> OnDiscard;

    public static void InvokeDiscard(Entity entity)
    {
        UnityAction<Entity> onDiscard = global::Events.OnDiscard;
        if (onDiscard == null)
            return;
        onDiscard(entity);
    }

    public static event UnityAction<Hit> OnEntityHit;

    public static void InvokeEntityHit(Hit hit)
    {
        UnityAction<Hit> onEntityHit = global::Events.OnEntityHit;
        if (onEntityHit == null)
            return;
        onEntityHit(hit);
    }

    public static event UnityAction<Hit> OnEntityPostHit;

    public static void InvokeEntityPostHit(Hit hit)
    {
        UnityAction<Hit> onEntityPostHit = global::Events.OnEntityPostHit;
        if (onEntityPostHit == null)
            return;
        onEntityPostHit(hit);
    }

    public static event UnityAction<Hit> OnEntityDodge;

    public static void InvokeEntityDodge(Hit hit)
    {
        UnityAction<Hit> onEntityDodge = global::Events.OnEntityDodge;
        if (onEntityDodge == null)
            return;
        onEntityDodge(hit);
    }

    public static event UnityAction<Entity> OnEntityFlipUp;

    public static void InvokeEntityFlipUp(Entity entity)
    {
        UnityAction<Entity> onEntityFlipUp = global::Events.OnEntityFlipUp;
        if (onEntityFlipUp == null)
            return;
        onEntityFlipUp(entity);
    }

    public static event UnityAction<Entity> OnEntityFlipDown;

    public static void InvokeEntityFlipDown(Entity entity)
    {
        UnityAction<Entity> onEntityFlipDown = global::Events.OnEntityFlipDown;
        if (onEntityFlipDown == null)
            return;
        onEntityFlipDown(entity);
    }

    public static event UnityAction<StatusIcon> OnStatusIconCreated;

    public static void InvokeStatusIconCreated(StatusIcon icon)
    {
        UnityAction<StatusIcon> statusIconCreated = global::Events.OnStatusIconCreated;
        if (statusIconCreated == null)
            return;
        statusIconCreated(icon);
    }

    public static event UnityAction<StatusIcon, Stat, Stat> OnStatusIconChanged;

    public static void InvokeStatusIconChanged(StatusIcon icon, Stat previousValue, Stat newValue)
    {
        UnityAction<StatusIcon, Stat, Stat> statusIconChanged = global::Events.OnStatusIconChanged;
        if (statusIconChanged == null)
            return;
        statusIconChanged(icon, previousValue, newValue);
    }

    public static event UnityAction<Entity> OnEntityDisplayUpdated;

    public static void InvokeEntityDisplayUpdated(Entity entity)
    {
        UnityAction<Entity> entityDisplayUpdated = global::Events.OnEntityDisplayUpdated;
        if (entityDisplayUpdated == null)
            return;
        entityDisplayUpdated(entity);
    }

    public static event UnityAction<Entity> OnEntityFocus;

    public static void InvokeEntityFocus(Entity entity)
    {
        UnityAction<Entity> onEntityFocus = global::Events.OnEntityFocus;
        if (onEntityFocus == null)
            return;
        onEntityFocus(entity);
    }

    public static event UnityAction<Entity, CardPocket> OnEntityEnterPocket;

    public static void InvokeEntityEnterPocket(Entity card, CardPocket pocket)
    {
        UnityAction<Entity, CardPocket> entityEnterPocket = global::Events.OnEntityEnterPocket;
        if (entityEnterPocket == null)
            return;
        entityEnterPocket(card, pocket);
    }

    public static event UnityAction<Entity> OnEntityEnterBackpack;

    public static void InvokeEntityEnterBackpack(Entity entity)
    {
        UnityAction<Entity> entityEnterBackpack = global::Events.OnEntityEnterBackpack;
        if (entityEnterBackpack == null)
            return;
        entityEnterBackpack(entity);
    }

    public static event UnityAction<Entity> OnEntityChangePhase;

    public static void InvokeEntityChangePhase(Entity entity)
    {
        UnityAction<Entity> entityChangePhase = global::Events.OnEntityChangePhase;
        if (entityChangePhase == null)
            return;
        entityChangePhase(entity);
    }

    public static event UnityAction<Entity> OnNoomlinShow;

    public static void InvokeNoomlinShow(Entity entity)
    {
        UnityAction<Entity> onNoomlinShow = global::Events.OnNoomlinShow;
        if (onNoomlinShow == null)
            return;
        onNoomlinShow(entity);
    }

    public static event UnityAction<Entity> OnNoomlinUsed;

    public static void InvokeNoomlinUsed(Entity entity)
    {
        UnityAction<Entity> onNoomlinUsed = global::Events.OnNoomlinUsed;
        if (onNoomlinUsed == null)
            return;
        onNoomlinUsed(entity);
    }

    public static event UnityAction<Entity> OnEntityFlipComplete;

    public static void InvokeEntityFlipComplete(Entity entity)
    {
        UnityAction<Entity> entityFlipComplete = global::Events.OnEntityFlipComplete;
        if (entityFlipComplete == null)
            return;
        entityFlipComplete(entity);
    }

    public static event UnityAction<Entity, Entity> OnEntitySummoned;

    public static void InvokeEntitySummoned(Entity entity, Entity summonedBy)
    {
        UnityAction<Entity, Entity> onEntitySummoned = global::Events.OnEntitySummoned;
        if (onEntitySummoned == null)
            return;
        onEntitySummoned(entity, summonedBy);
    }

    public static event UnityAction<GameObject> OnEntityPing;

    public static void InvokeEntityPing(GameObject obj)
    {
        UnityAction<GameObject> onEntityPing = global::Events.OnEntityPing;
        if (onEntityPing == null)
            return;
        onEntityPing(obj);
    }

    public static event global::Events.UnityActionRef<Entity, int> OnCheckRecycleAmount;

    public static void CheckRecycleAmount(Entity entity, ref int amount)
    {
        global::Events.UnityActionRef<Entity, int> checkRecycleAmount = global::Events.OnCheckRecycleAmount;
        if (checkRecycleAmount == null)
            return;
        checkRecycleAmount(ref entity, ref amount);
    }

    public static event UnityAction<CardContainer> OnContainerHover;

    public static void InvokeContainerHover(CardContainer container)
    {
        UnityAction<CardContainer> onContainerHover = global::Events.OnContainerHover;
        if (onContainerHover == null)
            return;
        onContainerHover(container);
    }

    public static event UnityAction<CardContainer> OnContainerUnHover;

    public static void InvokeContainerUnHover(CardContainer container)
    {
        UnityAction<CardContainer> containerUnHover = global::Events.OnContainerUnHover;
        if (containerUnHover == null)
            return;
        containerUnHover(container);
    }

    public static event UnityAction<CardSlot> OnSlotHover;

    public static void InvokeSlotHover(CardSlot slot)
    {
        UnityAction<CardSlot> onSlotHover = global::Events.OnSlotHover;
        if (onSlotHover == null)
            return;
        onSlotHover(slot);
    }

    public static event UnityAction<CardSlot> OnSlotUnHover;

    public static void InvokeSlotUnHover(CardSlot slot)
    {
        UnityAction<CardSlot> onSlotUnHover = global::Events.OnSlotUnHover;
        if (onSlotUnHover == null)
            return;
        onSlotUnHover(slot);
    }

    public static event UnityAction<PlayAction> OnActionQueued;

    public static void InvokeActionQueued(PlayAction action)
    {
        UnityAction<PlayAction> onActionQueued = global::Events.OnActionQueued;
        if (onActionQueued == null)
            return;
        onActionQueued(action);
    }

    public static event UnityAction<PlayAction> OnActionPerform;

    public static void InvokeActionPerform(PlayAction action)
    {
        UnityAction<PlayAction> onActionPerform = global::Events.OnActionPerform;
        if (onActionPerform == null)
            return;
        onActionPerform(action);
    }

    public static event UnityAction<PlayAction> OnActionFinished;

    public static void InvokeActionFinished(PlayAction action)
    {
        UnityAction<PlayAction> onActionFinished = global::Events.OnActionFinished;
        if (onActionFinished == null)
            return;
        onActionFinished(action);
    }

    public static event global::Events.UnityActionRef<PlayAction, bool> OnCheckAction;

    public static bool CheckAction(PlayAction action)
    {
        bool flag = true;
        global::Events.UnityActionRef<PlayAction, bool> onCheckAction = global::Events.OnCheckAction;
        if (onCheckAction != null)
            onCheckAction(ref action, ref flag);
        return flag;
    }

    public static event UnityAction<CardContainer> OnAbilityTargetAdd;

    public static void InvokeAbilityTargetAdd(CardContainer container)
    {
        UnityAction<CardContainer> abilityTargetAdd = global::Events.OnAbilityTargetAdd;
        if (abilityTargetAdd == null)
            return;
        abilityTargetAdd(container);
    }

    public static event UnityAction<CardContainer> OnAbilityTargetRemove;

    public static void InvokeAbilityTargetRemove(CardContainer container)
    {
        UnityAction<CardContainer> abilityTargetRemove = global::Events.OnAbilityTargetRemove;
        if (abilityTargetRemove == null)
            return;
        abilityTargetRemove(container);
    }

    public static event UnityAction<int> OnCardDraw;

    public static void InvokeCardDraw(int count)
    {
        UnityAction<int> onCardDraw = global::Events.OnCardDraw;
        if (onCardDraw == null)
            return;
        onCardDraw(count);
    }

    public static event UnityAction OnCardDrawEnd;

    public static void InvokeCardDrawEnd()
    {
        UnityAction onCardDrawEnd = global::Events.OnCardDrawEnd;
        if (onCardDrawEnd == null)
            return;
        onCardDrawEnd();
    }

    public static event UnityAction<CampaignNode> PreBattleSetUp;

    public static void InvokePreBattleSetUp(CampaignNode node)
    {
        UnityAction<CampaignNode> preBattleSetUp = global::Events.PreBattleSetUp;
        if (preBattleSetUp == null)
            return;
        preBattleSetUp(node);
    }

    public static event UnityAction<CampaignNode> PostBattleSetUp;

    public static void InvokePostBattleSetUp(CampaignNode node)
    {
        UnityAction<CampaignNode> postBattleSetUp = global::Events.PostBattleSetUp;
        if (postBattleSetUp == null)
            return;
        postBattleSetUp(node);
    }

    public static event UnityAction<Battle.Phase> OnBattlePhaseStart;

    public static void InvokeBattlePhaseStart(Battle.Phase phase)
    {
        UnityAction<Battle.Phase> battlePhaseStart = global::Events.OnBattlePhaseStart;
        if (battlePhaseStart == null)
            return;
        battlePhaseStart(phase);
    }

    public static event UnityAction OnBattleStart;

    public static void InvokeBattleStart()
    {
        UnityAction onBattleStart = global::Events.OnBattleStart;
        if (onBattleStart == null)
            return;
        onBattleStart();
    }

    public static event global::Events.AsyncAction PreBattleEnd;

    public static IEnumerator InvokePreBattleEnd()
    {
        if (global::Events.PreBattleEnd != null)
        {
            Task task = global::Events.PreBattleEnd();
            yield return (object)new WaitUntil((Func<bool>)(() => task.IsCompleted));
        }
    }

    public static event UnityAction OnBattleEnd;

    public static void InvokeBattleEnd()
    {
        UnityAction onBattleEnd = global::Events.OnBattleEnd;
        if (onBattleEnd == null)
            return;
        onBattleEnd();
    }

    public static event UnityAction OnBattleWinPreRewards;

    public static void InvokeBattleWinPreRewards()
    {
        UnityAction battleWinPreRewards = global::Events.OnBattleWinPreRewards;
        if (battleWinPreRewards == null)
            return;
        battleWinPreRewards();
    }

    public static event UnityAction OnBattleWin;

    public static void InvokeBattleWin()
    {
        UnityAction onBattleWin = global::Events.OnBattleWin;
        if (onBattleWin == null)
            return;
        onBattleWin();
    }

    public static event UnityAction<CampaignNode> PostBattle;

    public static void InvokePostBattle(CampaignNode campaignNode)
    {
        UnityAction<CampaignNode> postBattle = global::Events.PostBattle;
        if (postBattle == null)
            return;
        postBattle(campaignNode);
    }

    public static event global::Events.UnityActionCheck<StatusEffectData, int> OnStatusEffectCountDown;

    public static void InvokeStatusEffectCountDown(StatusEffectData status, ref int amount)
    {
        global::Events.UnityActionCheck<StatusEffectData, int> statusEffectCountDown = global::Events.OnStatusEffectCountDown;
        if (statusEffectCountDown == null)
            return;
        statusEffectCountDown(status, ref amount);
    }

    public static event UnityAction<StatusEffectApply> OnStatusEffectApplied;

    public static void InvokeStatusEffectApplied(StatusEffectApply apply)
    {
        UnityAction<StatusEffectApply> statusEffectApplied = global::Events.OnStatusEffectApplied;
        if (statusEffectApplied == null)
            return;
        statusEffectApplied(apply);
    }

    public static event UnityAction<Character> OnPreProcessUnits;

    public static void InvokePreProcessUnits(Character character)
    {
        UnityAction<Character> onPreProcessUnits = global::Events.OnPreProcessUnits;
        if (onPreProcessUnits == null)
            return;
        onPreProcessUnits(character);
    }

    public static event UnityAction<Character> OnPostProcessUnits;

    public static void InvokePostProcessUnits(Character character)
    {
        UnityAction<Character> postProcessUnits = global::Events.OnPostProcessUnits;
        if (postProcessUnits == null)
            return;
        postProcessUnits(character);
    }

    public static event global::Events.UnityActionCheck<Entity, int> OnEntityCountDown;

    public static void InvokeEntityCountDown(Entity entity, ref int amount)
    {
        global::Events.UnityActionCheck<Entity, int> onEntityCountDown = global::Events.OnEntityCountDown;
        if (onEntityCountDown == null)
            return;
        onEntityCountDown(entity, ref amount);
    }

    public static event UnityAction<int> OnBattlePreTurnStart;

    public static void InvokeBattlePreTurnStart(int turnNumber)
    {
        UnityAction<int> battlePreTurnStart = global::Events.OnBattlePreTurnStart;
        if (battlePreTurnStart == null)
            return;
        battlePreTurnStart(turnNumber);
    }

    public static event UnityAction<int> OnBattleTurnStart;

    public static void InvokeBattleTurnStart(int turnNumber)
    {
        UnityAction<int> onBattleTurnStart = global::Events.OnBattleTurnStart;
        if (onBattleTurnStart == null)
            return;
        onBattleTurnStart(turnNumber);
    }

    public static event UnityAction<int> OnBattleTurnEnd;

    public static void InvokeBattleTurnEnd(int turnNumber)
    {
        UnityAction<int> onBattleTurnEnd = global::Events.OnBattleTurnEnd;
        if (onBattleTurnEnd == null)
            return;
        onBattleTurnEnd(turnNumber);
    }

    public static event UnityAction<Entity> OnMinibossIntro;

    public static void InvokeMinibossIntro(Entity entity)
    {
        UnityAction<Entity> onMinibossIntro = global::Events.OnMinibossIntro;
        if (onMinibossIntro == null)
            return;
        onMinibossIntro(entity);
    }

    public static event UnityAction<Entity> OnMinibossIntroDone;

    public static void InvokeMinibossIntroDone(Entity entity)
    {
        UnityAction<Entity> minibossIntroDone = global::Events.OnMinibossIntroDone;
        if (minibossIntroDone == null)
            return;
        minibossIntroDone(entity);
    }

    public static event UnityAction<int> OnKillCombo;

    public static void InvokeKillCombo(int combo)
    {
        UnityAction<int> onKillCombo = global::Events.OnKillCombo;
        if (onKillCombo == null)
            return;
        onKillCombo(combo);
    }

    public static event UnityAction<RedrawBellSystem> OnRedrawBellHit;

    public static void InvokeRedrawBellHit(RedrawBellSystem redrawBellSystem)
    {
        UnityAction<RedrawBellSystem> onRedrawBellHit = global::Events.OnRedrawBellHit;
        if (onRedrawBellHit == null)
            return;
        onRedrawBellHit(redrawBellSystem);
    }

    public static event UnityAction<RedrawBellSystem> OnRedrawBellRevealed;

    public static void InvokeRedrawBellRevealed(RedrawBellSystem redrawBellSystem)
    {
        UnityAction<RedrawBellSystem> redrawBellRevealed = global::Events.OnRedrawBellRevealed;
        if (redrawBellRevealed == null)
            return;
        redrawBellRevealed(redrawBellSystem);
    }

    public static event UnityAction<CardData> OnCardInjured;

    public static void InvokeCardInjured(CardData cardData)
    {
        UnityAction<CardData> onCardInjured = global::Events.OnCardInjured;
        if (onCardInjured == null)
            return;
        onCardInjured(cardData);
    }

    public static event UnityAction OnBattleStateBuild;

    public static void InvokeBattleStateBuild()
    {
        UnityAction battleStateBuild = global::Events.OnBattleStateBuild;
        if (battleStateBuild == null)
            return;
        battleStateBuild();
    }

    public static event UnityAction<BattleSaveData> OnBattleStateBuilt;

    public static void InvokeBattleStateBuilt(BattleSaveData battleState)
    {
        UnityAction<BattleSaveData> battleStateBuilt = global::Events.OnBattleStateBuilt;
        if (battleStateBuilt == null)
            return;
        battleStateBuilt(battleState);
    }

    public static event UnityAction<Character> OnCharacterActionPerformed;

    public static void InvokeCharacterActionPerformed(Character character)
    {
        UnityAction<Character> characterActionPerformed = global::Events.OnCharacterActionPerformed;
        if (characterActionPerformed == null)
            return;
        characterActionPerformed(character);
    }

    public static event UnityAction<int> OnWaveDeployerPreCountDown;

    public static void InvokeWaveDeployerPreCountDown(int counter)
    {
        UnityAction<int> deployerPreCountDown = global::Events.OnWaveDeployerPreCountDown;
        if (deployerPreCountDown == null)
            return;
        deployerPreCountDown(counter);
    }

    public static event UnityAction<int> OnWaveDeployerPostCountDown;

    public static void InvokeWaveDeployerPostCountDown(int counter)
    {
        UnityAction<int> deployerPostCountDown = global::Events.OnWaveDeployerPostCountDown;
        if (deployerPostCountDown == null)
            return;
        deployerPostCountDown(counter);
    }

    public static event UnityAction OnWaveDeployerEarlyDeploy;

    public static void InvokeWaveDeployerEarlyDeploy()
    {
        UnityAction deployerEarlyDeploy = global::Events.OnWaveDeployerEarlyDeploy;
        if (deployerEarlyDeploy == null)
            return;
        deployerEarlyDeploy();
    }

    public static event UnityAction<float> OnMapPathReveal;

    public static void InvokeMapPathReveal(float totalTime)
    {
        UnityAction<float> onMapPathReveal = global::Events.OnMapPathReveal;
        if (onMapPathReveal == null)
            return;
        onMapPathReveal(totalTime);
    }

    public static event UnityAction<MapNode> OnMapNodeReveal;

    public static void InvokeMapNodeReveal(MapNode node)
    {
        UnityAction<MapNode> onMapNodeReveal = global::Events.OnMapNodeReveal;
        if (onMapNodeReveal == null)
            return;
        onMapNodeReveal(node);
    }

    public static event UnityAction<MapNode> OnMapNodeSelect;

    public static void InvokeMapNodeSelect(MapNode node)
    {
        UnityAction<MapNode> onMapNodeSelect = global::Events.OnMapNodeSelect;
        if (onMapNodeSelect == null)
            return;
        onMapNodeSelect(node);
    }

    public static event UnityAction<MapNode> OnMapNodeHover;

    public static void InvokeMapNodeHover(MapNode node)
    {
        UnityAction<MapNode> onMapNodeHover = global::Events.OnMapNodeHover;
        if (onMapNodeHover == null)
            return;
        onMapNodeHover(node);
    }

    public static event UnityAction<MapNode> OnMapNodeUnHover;

    public static void InvokeMapNodeUnHover(MapNode node)
    {
        UnityAction<MapNode> onMapNodeUnHover = global::Events.OnMapNodeUnHover;
        if (onMapNodeUnHover == null)
            return;
        onMapNodeUnHover(node);
    }

    public static event UnityAction<UnlockData> OnTownUnlock;

    public static void InvokeTownUnlock(UnlockData unlockData)
    {
        UnityAction<UnlockData> onTownUnlock = global::Events.OnTownUnlock;
        if (onTownUnlock == null)
            return;
        onTownUnlock(unlockData);
    }

    public static event UnityAction<ShopItem> OnShopItemHover;

    public static void InvokeShopItemHover(ShopItem item)
    {
        UnityAction<ShopItem> onShopItemHover = global::Events.OnShopItemHover;
        if (onShopItemHover == null)
            return;
        onShopItemHover(item);
    }

    public static event UnityAction<ShopItem> OnShopItemUnHover;

    public static void InvokeShopItemUnHover(ShopItem item)
    {
        UnityAction<ShopItem> onShopItemUnHover = global::Events.OnShopItemUnHover;
        if (onShopItemUnHover == null)
            return;
        onShopItemUnHover(item);
    }

    public static event UnityAction<ShopItem> OnShopItemPurchase;

    public static void InvokeShopItemPurchase(ShopItem item)
    {
        UnityAction<ShopItem> shopItemPurchase = global::Events.OnShopItemPurchase;
        if (shopItemPurchase == null)
            return;
        shopItemPurchase(item);
    }

    public static event UnityAction<ShopItem> OnShopItemHaggled;

    public static void InvokeShopItemHaggled(ShopItem item)
    {
        UnityAction<ShopItem> onShopItemHaggled = global::Events.OnShopItemHaggled;
        if (onShopItemHaggled == null)
            return;
        onShopItemHaggled(item);
    }

    public static event UnityAction<KeywordData, CardPopUpPanel> OnPopupCreated;

    public static void InvokePopupPanelCreated(KeywordData keyword, CardPopUpPanel panel)
    {
        UnityAction<KeywordData, CardPopUpPanel> onPopupCreated = global::Events.OnPopupCreated;
        if (onPopupCreated == null)
            return;
        onPopupCreated(keyword, panel);
    }

    public static event UnityAction<ButtonType> OnButtonHover;

    public static void InvokeButtonHover(ButtonType buttonType)
    {
        UnityAction<ButtonType> onButtonHover = global::Events.OnButtonHover;
        if (onButtonHover == null)
            return;
        onButtonHover(buttonType);
    }

    public static event UnityAction<ButtonType> OnButtonPress;

    public static void InvokeButtonPress(ButtonType buttonType)
    {
        UnityAction<ButtonType> onButtonPress = global::Events.OnButtonPress;
        if (onButtonPress == null)
            return;
        onButtonPress(buttonType);
    }

    public static event UnityAction<string, float> OnAudioVolumeChange;

    public static void InvokeAudioVolumeChange(string busName, float value)
    {
        UnityAction<string, float> audioVolumeChange = global::Events.OnAudioVolumeChange;
        if (audioVolumeChange == null)
            return;
        audioVolumeChange(busName, value);
    }

    public static event UnityAction<string, float> OnAudioPitchChange;

    public static void InvokeAudioPitchChange(string busName, float value)
    {
        UnityAction<string, float> audioPitchChange = global::Events.OnAudioPitchChange;
        if (audioPitchChange == null)
            return;
        audioPitchChange(busName, value);
    }

    public static event UnityAction<Entity> OnBombardShoot;

    public static void InvokeBombardShoot(Entity entity)
    {
        UnityAction<Entity> onBombardShoot = global::Events.OnBombardShoot;
        if (onBombardShoot == null)
            return;
        onBombardShoot(entity);
    }

    public static event UnityAction<BombardRocket> OnBombardRocketFall;

    public static void InvokeBombardRocketFall(BombardRocket rocket)
    {
        UnityAction<BombardRocket> bombardRocketFall = global::Events.OnBombardRocketFall;
        if (bombardRocketFall == null)
            return;
        bombardRocketFall(rocket);
    }

    public static event UnityAction<BombardRocket> OnBombardRocketExplode;

    public static void InvokeBombardRocketExplode(BombardRocket rocket)
    {
        UnityAction<BombardRocket> bombardRocketExplode = global::Events.OnBombardRocketExplode;
        if (bombardRocketExplode == null)
            return;
        bombardRocketExplode(rocket);
    }

    public static event UnityAction<float> OnProgressStart;

    public static void InvokeProgressStart(float fill)
    {
        UnityAction<float> onProgressStart = global::Events.OnProgressStart;
        if (onProgressStart == null)
            return;
        onProgressStart(fill);
    }

    public static event UnityAction<float> OnProgressUpdate;

    public static void InvokeProgressUpdate(float fill)
    {
        UnityAction<float> onProgressUpdate = global::Events.OnProgressUpdate;
        if (onProgressUpdate == null)
            return;
        onProgressUpdate(fill);
    }

    public static event UnityAction OnProgressStop;

    public static void InvokeProgressStop()
    {
        UnityAction onProgressStop = global::Events.OnProgressStop;
        if (onProgressStop == null)
            return;
        onProgressStop();
    }

    public static event UnityAction OnProgressDing;

    public static void InvokeProgressDing()
    {
        UnityAction onProgressDing = global::Events.OnProgressDing;
        if (onProgressDing == null)
            return;
        onProgressDing();
    }

    public static event UnityAction OnProgressBlip;

    public static void InvokeProgressBlip()
    {
        UnityAction onProgressBlip = global::Events.OnProgressBlip;
        if (onProgressBlip == null)
            return;
        onProgressBlip();
    }

    public static event UnityAction OnSaveSystemEnabled;

    public static void InvokeSaveSystemEnabled()
    {
        UnityAction saveSystemEnabled = global::Events.OnSaveSystemEnabled;
        if (saveSystemEnabled == null)
            return;
        saveSystemEnabled();
    }

    public static event UnityAction OnSaveSystemDisabled;

    public static void InvokeSaveSystemDisabled()
    {
        UnityAction saveSystemDisabled = global::Events.OnSaveSystemDisabled;
        if (saveSystemDisabled == null)
            return;
        saveSystemDisabled();
    }

    public static event UnityAction OnSaveSystemProfileChanged;

    public static void InvokeSaveSystemProfileChanged()
    {
        UnityAction systemProfileChanged = global::Events.OnSaveSystemProfileChanged;
        if (systemProfileChanged == null)
            return;
        systemProfileChanged();
    }

    public static event UnityAction OnCampaignSaved;

    public static void InvokeCampaignSaved()
    {
        UnityAction onCampaignSaved = global::Events.OnCampaignSaved;
        if (onCampaignSaved == null)
            return;
        onCampaignSaved();
    }

    public static event UnityAction OnCampaignLoaded;

    public static void InvokeCampaignLoaded()
    {
        UnityAction onCampaignLoaded = global::Events.OnCampaignLoaded;
        if (onCampaignLoaded == null)
            return;
        onCampaignLoaded();
    }

    public static event UnityAction OnCampaignDeleted;

    public static void InvokeCampaignDeleted()
    {
        UnityAction onCampaignDeleted = global::Events.OnCampaignDeleted;
        if (onCampaignDeleted == null)
            return;
        onCampaignDeleted();
    }

    public static event UnityAction OnBattleSaved;

    public static void InvokeBattleSaved()
    {
        UnityAction onBattleSaved = global::Events.OnBattleSaved;
        if (onBattleSaved == null)
            return;
        onBattleSaved();
    }

    public static event UnityAction OnBattleLoaded;

    public static void InvokeBattleLoaded()
    {
        UnityAction onBattleLoaded = global::Events.OnBattleLoaded;
        if (onBattleLoaded == null)
            return;
        onBattleLoaded();
    }

    public static event UnityAction OnGameStart;

    public static void InvokeGameStart()
    {
        UnityAction onGameStart = global::Events.OnGameStart;
        if (onGameStart == null)
            return;
        onGameStart();
    }

    public static event UnityAction OnGameEnd;

    public static void InvokeGameEnd()
    {
        UnityAction onGameEnd = global::Events.OnGameEnd;
        if (onGameEnd == null)
            return;
        onGameEnd();
    }

    public static event UnityAction OnCampaignStart;

    public static void InvokeCampaignStart()
    {
        UnityAction onCampaignStart = global::Events.OnCampaignStart;
        if (onCampaignStart == null)
            return;
        onCampaignStart();
    }

    public static event UnityAction OnCampaignFinal;

    public static void InvokeCampaignFinal()
    {
        UnityAction onCampaignFinal = global::Events.OnCampaignFinal;
        if (onCampaignFinal == null)
            return;
        onCampaignFinal();
    }

    public static event UnityAction<Campaign.Result, CampaignStats, PlayerData> OnCampaignEnd;

    public static void InvokeCampaignEnd(
      Campaign.Result result,
      CampaignStats stats,
      PlayerData playerData)
    {
        UnityAction<Campaign.Result, CampaignStats, PlayerData> onCampaignEnd = global::Events.OnCampaignEnd;
        if (onCampaignEnd == null)
            return;
        onCampaignEnd(result, stats, playerData);
    }

    public static event UnityAction<CampaignStats> OnOverallStatsSaved;

    public static void InvokeOverallStatsSaved(CampaignStats stats)
    {
        UnityAction<CampaignStats> overallStatsSaved = global::Events.OnOverallStatsSaved;
        if (overallStatsSaved == null)
            return;
        overallStatsSaved(stats);
    }

    public static event UnityAction<CampaignData> OnCampaignDataCreated;

    public static void InvokeCampaignDataCreated(CampaignData data)
    {
        UnityAction<CampaignData> campaignDataCreated = global::Events.OnCampaignDataCreated;
        if (campaignDataCreated == null)
            return;
        campaignDataCreated(data);
    }

    public static event global::Events.RoutineAction OnCampaignPreInit;

    public static IEnumerator InvokeCampaignPreInit()
    {
        if (global::Events.OnCampaignPreInit != null)
            yield return (object)global::Events.OnCampaignPreInit();
    }

    public static event global::Events.RoutineAction OnCampaignInit;

    public static IEnumerator InvokeCampaignInit()
    {
        if (global::Events.OnCampaignInit != null)
            yield return (object)global::Events.OnCampaignInit();
    }

    public static event UnityAction OnPreCampaignPopulate;

    public static void InvokePreCampaignPopulate()
    {
        UnityAction campaignPopulate = global::Events.OnPreCampaignPopulate;
        if (campaignPopulate == null)
            return;
        campaignPopulate();
    }

    public static event global::Events.UnityActionRef1<List<CampaignGenerator.Node>, Vector2> OnCampaignNodesCreated;

    public static void InvokeCampaignNodesCreated(
      ref List<CampaignGenerator.Node> nodes,
      Vector2 nodeSpacing)
    {
        global::Events.UnityActionRef1<List<CampaignGenerator.Node>, Vector2> campaignNodesCreated = global::Events.OnCampaignNodesCreated;
        if (campaignNodesCreated == null)
            return;
        campaignNodesCreated(ref nodes, nodeSpacing);
    }

    public static event global::Events.UnityActionRef<string[]> OnCampaignLoadPreset;

    public static void InvokeCampaignLoadPreset(ref string[] lines)
    {
        global::Events.UnityActionRef<string[]> campaignLoadPreset = global::Events.OnCampaignLoadPreset;
        if (campaignLoadPreset == null)
            return;
        campaignLoadPreset(ref lines);
    }

    public static event global::Events.AsyncAction OnCampaignGenerated;

    public static IEnumerator InvokeCampaignGenerated()
    {
        if (global::Events.OnCampaignGenerated != null)
        {
            Delegate[] delegateArray = global::Events.OnCampaignGenerated.GetInvocationList();
            for (int index = 0; index < delegateArray.Length; ++index)
            {
                if (delegateArray[index] is global::Events.AsyncAction asyncAction)
                {
                    Task task = asyncAction();
                    yield return (object)new WaitUntil((Func<bool>)(() => task.IsCompleted));
                }
            }
            delegateArray = (Delegate[])null;
        }
    }

    public static event UnityAction<string, string, int, int> OnStatChanged;

    public static void InvokeStatChanged(string stat, string key, int oldValue, int newValue)
    {
        UnityAction<string, string, int, int> onStatChanged = global::Events.OnStatChanged;
        if (onStatChanged == null)
            return;
        onStatChanged(stat, key, oldValue, newValue);
    }

    public static event UnityAction<CardUpgradeData> OnUpgradeGained;

    public static void InvokeUpgradeGained(CardUpgradeData upgradeData)
    {
        UnityAction<CardUpgradeData> onUpgradeGained = global::Events.OnUpgradeGained;
        if (onUpgradeGained == null)
            return;
        onUpgradeGained(upgradeData);
    }

    public static event UnityAction<Entity, CardUpgradeData> OnUpgradeAssign;

    public static void InvokeUpgradeAssign(Entity entity, CardUpgradeData upgradeData)
    {
        UnityAction<Entity, CardUpgradeData> onUpgradeAssign = global::Events.OnUpgradeAssign;
        if (onUpgradeAssign == null)
            return;
        onUpgradeAssign(entity, upgradeData);
    }

    public static event UnityAction<UpgradeDisplay> OnUpgradeHover;

    public static void InvokeUpgradeHover(UpgradeDisplay upgradeDisplay)
    {
        UnityAction<UpgradeDisplay> onUpgradeHover = global::Events.OnUpgradeHover;
        if (onUpgradeHover == null)
            return;
        onUpgradeHover(upgradeDisplay);
    }

    public static event UnityAction<UpgradeDisplay> OnUpgradePickup;

    public static void InvokeUpgradePickup(UpgradeDisplay upgradeDisplay)
    {
        UnityAction<UpgradeDisplay> onUpgradePickup = global::Events.OnUpgradePickup;
        if (onUpgradePickup == null)
            return;
        onUpgradePickup(upgradeDisplay);
    }

    public static event UnityAction<UpgradeDisplay> OnUpgradeDrop;

    public static void InvokeUpgradeDrop(UpgradeDisplay upgradeDisplay)
    {
        UnityAction<UpgradeDisplay> onUpgradeDrop = global::Events.OnUpgradeDrop;
        if (onUpgradeDrop == null)
            return;
        onUpgradeDrop(upgradeDisplay);
    }

    public static event UnityAction<bool> OnUpdateInputSystem;

    public static void InvokeUpdateInputSystem(bool forceTouch)
    {
        UnityAction<bool> updateInputSystem = global::Events.OnUpdateInputSystem;
        if (updateInputSystem == null)
            return;
        updateInputSystem(forceTouch);
    }

    public static event UnityAction<float, float?> OnScreenShake;

    public static void InvokeScreenShake(float magnitude = 1f, float? direction = 0.0f)
    {
        UnityAction<float, float?> onScreenShake = global::Events.OnScreenShake;
        if (onScreenShake == null)
            return;
        onScreenShake(magnitude, direction);
    }

    public static event global::Events.UnityAction<float, float, float, float, float, float> OnScreenRumble;

    public static void InvokeScreenRumble(
      float startStrength,
      float endStrength,
      float delay,
      float fadeInTime,
      float holdTime,
      float fadeOutTime)
    {
        global::Events.UnityAction<float, float, float, float, float, float> onScreenRumble = global::Events.OnScreenRumble;
        if (onScreenRumble == null)
            return;
        onScreenRumble(startStrength, endStrength, delay, fadeInTime, holdTime, fadeOutTime);
    }

    public static event UnityAction<string> OnCameraAnimation;

    public static void InvokeCameraAnimation(string name)
    {
        UnityAction<string> onCameraAnimation = global::Events.OnCameraAnimation;
        if (onCameraAnimation == null)
            return;
        onCameraAnimation(name);
    }

    public static event UnityAction<int, string, Character, Vector3> OnDropGold;

    public static void InvokeDropGold(int amount, string source, Character owner, Vector3 position)
    {
        UnityAction<int, string, Character, Vector3> onDropGold = global::Events.OnDropGold;
        if (onDropGold == null)
            return;
        onDropGold(amount, source, owner, position);
    }

    public static event UnityAction<int, Character, Vector3> OnGoldFlyToBag;

    public static void InvokeGoldFlyToBag(int amount, Character owner, Vector3 position)
    {
        UnityAction<int, Character, Vector3> onGoldFlyToBag = global::Events.OnGoldFlyToBag;
        if (onGoldFlyToBag == null)
            return;
        onGoldFlyToBag(amount, owner, position);
    }

    public static event UnityAction<int> OnCollectGold;

    public static void InvokeCollectGold(int amount)
    {
        UnityAction<int> onCollectGold = global::Events.OnCollectGold;
        if (onCollectGold == null)
            return;
        onCollectGold(amount);
    }

    public static event UnityAction<int> OnSpendGold;

    public static void InvokeSpendGold(int amount)
    {
        UnityAction<int> onSpendGold = global::Events.OnSpendGold;
        if (onSpendGold == null)
            return;
        onSpendGold(amount);
    }

    public static event UnityAction<float> OnTimeScaleChange;

    public static void InvokeTimeScaleChange(float value)
    {
        UnityAction<float> onTimeScaleChange = global::Events.OnTimeScaleChange;
        if (onTimeScaleChange == null)
            return;
        onTimeScaleChange(value);
    }

    public static event UnityAction<Entity> OnInspect;

    public static void InvokeInspect(Entity entity)
    {
        UnityAction<Entity> onInspect = global::Events.OnInspect;
        if (onInspect == null)
            return;
        onInspect(entity);
    }

    public static event UnityAction<Entity> OnInspectEnd;

    public static void InvokeInspectEnd(Entity entity)
    {
        UnityAction<Entity> onInspectEnd = global::Events.OnInspectEnd;
        if (onInspectEnd == null)
            return;
        onInspectEnd(entity);
    }

    public static event UnityAction<Entity> OnInspectNewCard;

    public static void InvokeInspectNewCard(Entity entity)
    {
        UnityAction<Entity> onInspectNewCard = global::Events.OnInspectNewCard;
        if (onInspectNewCard == null)
            return;
        onInspectNewCard(entity);
    }

    public static event UnityAction<CardController> OnCardControllerEnabled;

    public static void InvokeCardControllerEnabled(CardController controller)
    {
        UnityAction<CardController> controllerEnabled = global::Events.OnCardControllerEnabled;
        if (controllerEnabled == null)
            return;
        controllerEnabled(controller);
    }

    public static event UnityAction<CardController> OnCardControllerDisabled;

    public static void InvokeCardControllerDisabled(CardController controller)
    {
        UnityAction<CardController> controllerDisabled = global::Events.OnCardControllerDisabled;
        if (controllerDisabled == null)
            return;
        controllerDisabled(controller);
    }

    public static event UnityAction OnDeckpackOpen;

    public static void InvokeDeckpackOpen()
    {
        UnityAction onDeckpackOpen = global::Events.OnDeckpackOpen;
        if (onDeckpackOpen == null)
            return;
        onDeckpackOpen();
    }

    public static event UnityAction OnDeckpackClose;

    public static void InvokeDeckpackClose()
    {
        UnityAction onDeckpackClose = global::Events.OnDeckpackClose;
        if (onDeckpackClose == null)
            return;
        onDeckpackClose();
    }

    public static event UnityAction<TransitionType> OnTransitionStart;

    public static void InvokeTransitionStart(TransitionType transition)
    {
        UnityAction<TransitionType> onTransitionStart = global::Events.OnTransitionStart;
        if (onTransitionStart == null)
            return;
        onTransitionStart(transition);
    }

    public static event UnityAction<TransitionType> OnTransitionEnd;

    public static void InvokeTransitionEnd(TransitionType transition)
    {
        UnityAction<TransitionType> onTransitionEnd = global::Events.OnTransitionEnd;
        if (onTransitionEnd == null)
            return;
        onTransitionEnd(transition);
    }

    public static event UnityAction<float, float> OnSetWeatherIntensity;

    public static void InvokeSetWeatherIntensity(float amount, float updateDuration)
    {
        UnityAction<float, float> weatherIntensity = global::Events.OnSetWeatherIntensity;
        if (weatherIntensity == null)
            return;
        weatherIntensity(amount, updateDuration);
    }

    public static event UnityAction<GoldDisplay, float> OnGoldCounterStart;

    public static void InvokeGoldCounterStart(GoldDisplay goldDisplay, float addAmount)
    {
        UnityAction<GoldDisplay, float> goldCounterStart = global::Events.OnGoldCounterStart;
        if (goldCounterStart == null)
            return;
        goldCounterStart(goldDisplay, addAmount);
    }

    public static event UnityAction<CampaignNode, EventRoutine> OnEventStart;

    public static void InvokeEventStart(CampaignNode node, EventRoutine @event)
    {
        UnityAction<CampaignNode, EventRoutine> onEventStart = global::Events.OnEventStart;
        if (onEventStart == null)
            return;
        onEventStart(node, @event);
    }

    public static event UnityAction<EventRoutine> OnEventPopulated;

    public static void InvokeEventPopulated(EventRoutine @event)
    {
        UnityAction<EventRoutine> onEventPopulated = global::Events.OnEventPopulated;
        if (onEventPopulated == null)
            return;
        onEventPopulated(@event);
    }

    public static event UnityAction OnMuncherDrag;

    public static void InvokeMuncherDrag()
    {
        UnityAction onMuncherDrag = global::Events.OnMuncherDrag;
        if (onMuncherDrag == null)
            return;
        onMuncherDrag();
    }

    public static event UnityAction OnMuncherDragCancel;

    public static void InvokeMuncherDragCancel()
    {
        UnityAction muncherDragCancel = global::Events.OnMuncherDragCancel;
        if (muncherDragCancel == null)
            return;
        muncherDragCancel();
    }

    public static event UnityAction<Entity> OnMuncherFeed;

    public static void InvokeMuncherFeed(Entity entity)
    {
        UnityAction<Entity> onMuncherFeed = global::Events.OnMuncherFeed;
        if (onMuncherFeed == null)
            return;
        onMuncherFeed(entity);
    }

    public static event UnityAction<string, object> OnSettingChanged;

    public static void InvokeSettingChanged(string key, object value)
    {
        UnityAction<string, object> onSettingChanged = global::Events.OnSettingChanged;
        if (onSettingChanged == null)
            return;
        onSettingChanged(key, value);
    }

    public static event UnityAction OnUINavigationReset;

    public static void InvokeUINavigationReset()
    {
        UnityAction uiNavigationReset = global::Events.OnUINavigationReset;
        if (uiNavigationReset == null)
            return;
        uiNavigationReset();
    }

    public static event UnityAction OnUINavigation;

    public static void InvokeUINavigation()
    {
        UnityAction onUiNavigation = global::Events.OnUINavigation;
        if (onUiNavigation == null)
            return;
        onUiNavigation();
    }

    public static event UnityAction OnButtonStyleChanged;

    public static void InvokeButtonStyleChanged()
    {
        UnityAction buttonStyleChanged = global::Events.OnButtonStyleChanged;
        if (buttonStyleChanged == null)
            return;
        buttonStyleChanged();
    }

    public static event UnityAction OnControllerSwitched;

    public static void InvokeControllerSwitched()
    {
        UnityAction controllerSwitched = global::Events.OnControllerSwitched;
        if (controllerSwitched == null)
            return;
        controllerSwitched();
    }

    public static event global::Events.UnityActionRef<Entity, string, bool> OnCheckRename;

    public static bool CheckRename(ref Entity entity, ref string newName)
    {
        bool flag = true;
        global::Events.UnityActionRef<Entity, string, bool> onCheckRename = global::Events.OnCheckRename;
        if (onCheckRename != null)
            onCheckRename(ref entity, ref newName, ref flag);
        return flag;
    }

    public static event UnityAction<Entity, string> OnRename;

    public static void InvokeRename(Entity entity, string newName)
    {
        UnityAction<Entity, string> onRename = global::Events.OnRename;
        if (onRename == null)
            return;
        onRename(entity, newName);
    }

    public static event global::Events.UnityActionRef<object, string, int, List<DataFile>> OnPullRewards;

    public static List<DataFile> PullRewards(object pulledBy, string poolName, ref int count)
    {
        List<DataFile> dataFileList = new List<DataFile>();
        global::Events.UnityActionRef<object, string, int, List<DataFile>> onPullRewards = global::Events.OnPullRewards;
        if (onPullRewards != null)
            onPullRewards(pulledBy, ref poolName, ref count, ref dataFileList);
        return dataFileList;
    }

    public static event UnityAction<CardData> OnCardDataCreated;

    public static void InvokeCardDataCreated(CardData cardData)
    {
        UnityAction<CardData> onCardDataCreated = global::Events.OnCardDataCreated;
        if (onCardDataCreated == null)
            return;
        onCardDataCreated(cardData);
    }

    public static event UnityAction<int> OnTutorialProgress;

    public static void InvokeTutorialProgress(int value)
    {
        UnityAction<int> tutorialProgress = global::Events.OnTutorialProgress;
        if (tutorialProgress == null)
            return;
        tutorialProgress(value);
    }

    public static event UnityAction OnTutorialSkip;

    public static void InvokeTutorialSkip()
    {
        UnityAction onTutorialSkip = global::Events.OnTutorialSkip;
        if (onTutorialSkip == null)
            return;
        onTutorialSkip();
    }

    public static event UnityAction<ChallengeData> OnChallengeCompletedSaved;

    public static void InvokeChallengeCompletedSaved(ChallengeData challengeData)
    {
        UnityAction<ChallengeData> challengeCompletedSaved = global::Events.OnChallengeCompletedSaved;
        if (challengeCompletedSaved == null)
            return;
        challengeCompletedSaved(challengeData);
    }

    public static event global::Events.UnityActionRef<int> OnGetHandSize;

    public static int GetHandSize(int baseHandSize)
    {
        int handSize = baseHandSize;
        global::Events.UnityActionRef<int> onGetHandSize = global::Events.OnGetHandSize;
        if (onGetHandSize != null)
            onGetHandSize(ref handSize);
        return handSize;
    }

    public static event UnityAction<WildfrostMod> OnModLoaded;

    public static void InvokeModLoaded(WildfrostMod mod)
    {
        UnityAction<WildfrostMod> onModLoaded = global::Events.OnModLoaded;
        if (onModLoaded == null)
            return;
        onModLoaded(mod);
    }

    public static event UnityAction<WildfrostMod> OnModUnloaded;

    public static void InvokeModUnloaded(WildfrostMod mod)
    {
        UnityAction<WildfrostMod> onModUnloaded = global::Events.OnModUnloaded;
        if (onModUnloaded == null)
            return;
        onModUnloaded(mod);
    }

    public delegate void UnityActionRef<T>(ref T arg0);

    public delegate void UnityActionRef<T0, T1>(ref T0 arg0, ref T1 arg1);

    public delegate void UnityActionRef1<T0, T1>(ref T0 arg0, T1 arg1);

    public delegate void UnityActionRef<T0, T1, T2>(ref T0 arg0, ref T1 arg1, ref T2 arg2);

    public delegate void UnityActionRef<T0, T1, T2, T3>(
      T0 arg0,
      ref T1 arg1,
      ref T2 arg2,
      ref T3 arg3);

    public delegate void UnityActionCheck<T0, T1>(T0 arg0, ref T1 arg1);

    public delegate void UnityActionCheck<T0, T1, T2>(T0 arg0, T1 arg1, ref T2 arg2);

    public delegate void UnityAction<T0, T1, T2, T3, T4>(
      T0 arg0,
      T1 arg1,
      T2 arg2,
      T3 arg3,
      T4 arg4);

    public delegate void UnityAction<T0, T1, T2, T3, T4, T5>(
      T0 arg0,
      T1 arg1,
      T2 arg2,
      T3 arg3,
      T4 arg4,
      T5 arg5);

    public delegate IEnumerator RoutineAction();

    public delegate Task AsyncAction();

    public delegate IEnumerator RoutineAction<T>(T arg);
}
public static class EyeTrackerSystem
{
}
public static class JournalNameHistory
{
    [Serializable]
    public class Name
    {
        public string text;

        public bool killed;

        public bool missing;

        public float opacity;

        public Vector2 position;

        public Vector2 offset;

        public float angle;

        public Name()
        {
        }

        public Name(string text, Vector2 randomOffset, float randomAngle)
        {
            //IL_0019: Unknown result type (might be due to invalid IL or missing references)
            //IL_002f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0045: Unknown result type (might be due to invalid IL or missing references)
            //IL_004a: Unknown result type (might be due to invalid IL or missing references)
            this.text = text;
            opacity = 1f;
            offset = new Vector2(randomOffset.x * PettyRandom.Range(-1f, 1f), randomOffset.y * PettyRandom.Range(-1f, 1f));
            angle = randomAngle * PettyRandom.Range(-1f, 1f);
        }
    }

    public const int maxEntries = 26;

    public const float fadePrevious = 0.035f;

    public static readonly Vector2 startPos = new Vector2(-1.733333f, 3f);

    public static readonly Vector2 spacing = new Vector2(1.733333f, 1f);

    public static readonly Vector2 bounds = new Vector2(1.733333f, -3f);

    public static readonly Vector2 randomOffset = new Vector2(0.5f, 0.25f);

    public const float randomAngle = 3f;

    public static void AddName(string name)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c6: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a1: Unknown result type (might be due to invalid IL or missing references)
        Name name2 = new Name(name, randomOffset, 3f);
        List<Name> list = SaveSystem.LoadProgressData<List<Name>>("leaderNameHistory");
        list ??= new List<Name>();
        Vector2 val = ((list.Count > 0) ? list[^1].position : startPos);
        if (list.Count > 0)
        {
            val.y -= spacing.y;
            if (val.y < bounds.y)
            {
                val.y = startPos.y;
                val.x += spacing.x;
                if (val.x > bounds.x)
                {
                    val.x = startPos.x;
                }
            }
        }
        name2.position = val;
        list.Add(name2);
        SaveSystem.SaveProgressData("leaderNameHistory", list);
    }

    public static void FadePrevious()
    {
        List<Name> list = SaveSystem.LoadProgressData<List<Name>>("leaderNameHistory");
        if (list == null || list.Count <= 0)
        {
            return;
        }
        while (list.Count > 25)
        {
            list.RemoveAt(0);
        }
        foreach (Name item in list)
        {
            item.opacity -= 0.035f;
        }
        SaveSystem.SaveProgressData("leaderNameHistory", list);
    }

    public static void MostRecentNameKilled()
    {
        List<Name> list = SaveSystem.LoadProgressData<List<Name>>("leaderNameHistory");
        if (list != null && list.Count > 0)
        {
            list[^1].killed = true;
            SaveSystem.SaveProgressData("leaderNameHistory", list);
        }
    }

    public static void MostRecentNameMissing()
    {
        List<Name> list = SaveSystem.LoadProgressData<List<Name>>("leaderNameHistory");
        if (list != null && list.Count > 0)
        {
            list[^1].missing = true;
            SaveSystem.SaveProgressData("leaderNameHistory", list);
        }
    }
}
public static class MissingCardSystem
{
    public static CardData Get()
    {
        return AddressableLoader.Get<CardData>("CardData", "MissingCard");
    }

    public static CardData GetClone(string cardDataName, bool runCreateScripts = true)
    {
        CardData cardData = Get();
        if (!(cardData))
        {
            return null;
        }
        CardData cardData2 = cardData.Clone(runCreateScripts);
        cardData2.forceTitle = "Missing Card " + cardDataName;
        return cardData2;
    }

    public static CardData GetCloneWithId(string cardDataName, Vector3 random3, ulong id, bool runCreateScripts = true)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        CardData cardData = Get();
        if (!(cardData))
        {
            return null;
        }
        CardData cardData2 = cardData.Clone(random3, id, runCreateScripts);
        cardData2.forceTitle = "Missing Card " + cardDataName;
        return cardData2;
    }

    public static bool IsMissing(CardData cardData)
    {
        return IsMissing((cardData).name);
    }

    public static bool IsMissing(CardSaveData cardSaveData)
    {
        return IsMissing(cardSaveData.name);
    }

    public static bool IsMissing(string cardDataName)
    {
        CardData cardData = AddressableLoader.Get<CardData>("CardData", cardDataName);
        if (!(cardData))
        {
            return true;
        }
        if ((cardData).name == "MissingCard")
        {
            return true;
        }
        return false;
    }

    public static bool HasMissingData(IEnumerable<string> cardDataNames)
    {
        foreach (string cardDataName in cardDataNames)
        {
            if (IsMissing(cardDataName))
            {
                return true;
            }
        }
        return false;
    }

    public static bool HasMissingData(CardSaveData[] cardSaveDatas)
    {
        return HasMissingData(cardSaveDatas.LoadList<CardData, CardSaveData>());
    }

    public static bool HasMissingData(IEnumerable<CardData> cardDataList)
    {
        return cardDataList.Any((CardData a) => IsMissing((a).name));
    }
}
public static class NewCardFramesChecker
{
    public static bool Check()
    {
        return SaveSystem.LoadProgressData("newFinalBoss", defaultValue: false);
    }

    public static IEnumerator Run()
    {
        SaveSystem.SaveProgressData("newFinalBoss", value: false);
        InputSystem.Disable();
        yield return SceneManager.Load("NewFrostGuardian", SceneType.Temporary);
        InputSystem.Enable();
        yield return SceneManager.WaitUntilUnloaded("NewFrostGuardian");
    }
}
public static class NewFinalBossChecker
{
    public static bool Check()
    {
        return SaveSystem.LoadProgressData("newFinalBoss", defaultValue: false);
    }

    public static IEnumerator Run()
    {
        SaveSystem.SaveProgressData("newFinalBoss", value: false);
        InputSystem.Disable();
        yield return SceneManager.Load("NewFrostGuardian", SceneType.Temporary);
        InputSystem.Enable();
        yield return SceneManager.WaitUntilUnloaded("NewFrostGuardian");
    }
}
public class Nex : MonoBehaviour
{
}
public static class NexFrequencyChecker
{
    public enum Function
    {
        PutScore,
        GetCommonData,
        PutCommonData,
        DeleteCommonData,
        GetRanking,
        GetCategorySetting,
        GetRankingChart,
        GetEstimatedScoreRank
    }

    public readonly struct Profile
    {
        public readonly int allowedRequests;

        public readonly float cooldownSeconds;

        public readonly List<float> requests;

        public Profile(int allowedRequests, float cooldownSeconds)
        {
            this.allowedRequests = allowedRequests;
            this.cooldownSeconds = cooldownSeconds;
            requests = new List<float>();
        }

        public bool Check()
        {
            float realtimeSinceStartup = Time.realtimeSinceStartup;
            RemoveInactive(realtimeSinceStartup);
            return requests.Count < allowedRequests;
        }

        public void RemoveInactive(float time)
        {
            float num = time - cooldownSeconds;
            for (int num2 = requests.Count - 1; num2 >= 0; num2--)
            {
                if (requests[num2] < num)
                {
                    requests.RemoveAt(num2);
                }
            }
        }

        public void LogRequest()
        {
            requests.Add(Time.realtimeSinceStartup);
        }
    }

    public static readonly Dictionary<Function, Profile> lookup = new Dictionary<Function, Profile>
    {
        {
            Function.PutScore,
            new Profile(10, 60f)
        },
        {
            Function.GetCommonData,
            new Profile(10, 60f)
        },
        {
            Function.PutCommonData,
            new Profile(10, 60f)
        },
        {
            Function.DeleteCommonData,
            new Profile(10, 60f)
        },
        {
            Function.GetRanking,
            new Profile(20, 60f)
        },
        {
            Function.GetCategorySetting,
            new Profile(20, 60f)
        },
        {
            Function.GetRankingChart,
            new Profile(20, 60f)
        },
        {
            Function.GetEstimatedScoreRank,
            new Profile(20, 60f)
        }
    };

    public static bool Check(Function functionName)
    {
        if (lookup.TryGetValue(functionName, out var value) && value.Check())
        {
            value.LogRequest();
            return true;
        }
        return false;
    }
}
public class References : MonoBehaviourSingleton<References>
{
    public static PlayerData PlayerData;

    public static Character Player;

    public static MapNew Map;

    public static Campaign Campaign;

    public static Battle Battle;

    public ClassData[] classes;

    public AreaData[] areas;

    public HardModeModifierData[] hardModeModifiers;

    public BossRewardPool[] bossRewardPools;

    public static Transform _minibossCameraMover;

    public const string DefaultGameModeName = "GameModeNormal";

    public const string TutorialGameModeName = "GameModeTutorial";

    public static CardData LeaderData => PlayerData.inventory.deck.First((CardData a) => a.cardType.miniboss);

    public static ClassData[] Classes => MonoBehaviourSingleton<References>.instance.classes;

    public static AreaData[] Areas => MonoBehaviourSingleton<References>.instance.areas;

    public static Transform MinibossCameraMover
    {
        get
        {
            if ((_minibossCameraMover))
            {
                return _minibossCameraMover;
            }
            GameObject val = GameObject.FindWithTag("MinibossCameraTransform");
            if (val != null)
            {
                _minibossCameraMover = val.transform;
            }
            return _minibossCameraMover;
        }
    }

    public static AreaData GetCurrentArea()
    {
        CampaignNode campaignNode = Campaign.FindCharacterNode(Player);
        return Areas[campaignNode.areaIndex];
    }
}
public static class SceneManager
{
    public static readonly Dictionary<string, Scene> Loaded = new Dictionary<string, Scene>();

    public static readonly List<string> Temporary = new List<string>();

    public static readonly List<string> Loading = new List<string>();

    public static int jobsActive;

    public static string ActiveSceneKey { get; set; }

    public static string ActiveSceneName { get; set; }

    public static bool HasNoActiveJobs => jobsActive <= 0;

    public static Scene GetActive()
    {
        //IL_000a: Unknown result type (might be due to invalid IL or missing references)
        return Loaded[ActiveSceneKey];
    }

    public static IEnumerator Load(string sceneKey, SceneType type, System.Action<Scene> onComplete = null)
    {
        JobStart();
        sceneKey = sceneKey.Replace("Scenes/", "").Replace(".unity", "");
        Debug.Log(("SceneManager → Loading Scene \"" + sceneKey + "\""));
        if (Loading.Contains(sceneKey))
        {
            yield return (object)new WaitUntil((Func<bool>)(() => !Loading.Contains(sceneKey)));
        }
        if (!IsLoaded(sceneKey))
        {
            yield return Load(sceneKey, type, activateOnLoad: true);
            Events.InvokeSceneLoaded(Loaded[sceneKey]);
        }
        else
        {
            Debug.Log(("\"" + sceneKey + "\" already loaded"));
        }
        if (type == SceneType.Active)
        {
            yield return SetActive(sceneKey);
        }
        onComplete?.Invoke(Loaded[sceneKey]);
        JobEnd();
    }

    public static IEnumerator Load(string sceneKey, SceneType type, bool activateOnLoad)
    {
        Loading.Add(sceneKey);
        AsyncOperation handle = SceneManager.LoadSceneAsync(sceneKey, (LoadSceneMode)1);
        while (!handle.isDone)
        {
            yield return null;
        }
        Loaded[sceneKey] = SceneManager.GetSceneByName(sceneKey);
        Loading.Remove(sceneKey);
        Debug.Log(("\"" + sceneKey + "\" Loaded"));
        if (type == SceneType.Temporary)
        {
            Temporary.Add(sceneKey);
        }
    }

    public static IEnumerator SetActive(string sceneKey)
    {
        Scene scene = Loaded[sceneKey];
        ActiveSceneName = ((scene)).name;
        ActiveSceneKey = sceneKey;
        Events.InvokeSceneChanged(scene);
        yield return UnloadTemporary();
    }

    public static IEnumerator Unload(string sceneKey)
    {
        if (StringExt.IsNullOrWhitespace(sceneKey))
        {
            yield break;
        }
        Debug.Log(("SceneManager → Unloading Scene \"" + sceneKey + "\""));
        if (IsLoaded(sceneKey))
        {
            Scene val = Loaded[sceneKey];
            Events.InvokeSceneUnload(val);
            AsyncOperation handle = SceneManager.UnloadSceneAsync(val);
            while (!handle.isDone)
            {
                yield return null;
            }
            Debug.Log("Scene successfully unloaded");
            Loaded.Remove(sceneKey);
            Temporary.Remove(sceneKey);
        }
        else
        {
            Debug.Log("Scene is already unloaded...");
        }
    }

    public static IEnumerator UnloadActive()
    {
        Routine.Clump clump = new Routine.Clump();
        if (!StringExt.IsNullOrWhitespace(ActiveSceneKey))
        {
            clump.Add(Unload(ActiveSceneKey));
        }
        clump.Add(UnloadTemporary());
        yield return clump.WaitForEnd();
    }

    public static IEnumerator UnloadTemporary()
    {
        Routine.Clump clump = new Routine.Clump();
        foreach (string item in Temporary)
        {
            clump.Add(Unload(item));
        }
        yield return clump.WaitForEnd();
    }

    public static bool IsLoaded(string sceneKey)
    {
        return Loaded.ContainsKey(sceneKey);
    }

    public static IEnumerator WaitUntilUnloaded(string sceneKey)
    {
        yield return (object)new WaitUntil((Func<bool>)(() => !Loaded.ContainsKey(sceneKey)));
    }

    public static void JobStart()
    {
        jobsActive++;
    }

    public static void JobEnd()
    {
        jobsActive--;
    }
}
public static class Scores
{
    public enum Type
    {
        TopScores,
        Daily
    }

    public static string GetLeaderboardName(Type boardType, DateTime date)
    {
        return boardType switch
        {
            Type.TopScores => "Scores",
            Type.Daily => DailyFetcher.GetLeaderboardName(date),
            _ => "Unknown",
        };
    }

    public static async Task<LeaderboardUpdate?> Submit(Type type, DateTime date, int score, params int[] details)
    {
        string leaderboardName = GetLeaderboardName(type, date);
        Debug.Log($"> Submitting Score [{score}] to Leaderboard [{leaderboardName}]");
        Leaderboard? val = await GetLeaderboard(leaderboardName);
        if (val.HasValue)
        {
            Leaderboard value = val.Value;
            return await ((value)).SubmitScoreAsync(score, (details.Length != 0) ? details : null);
        }
        return null;
    }

    public static async Task<Leaderboard?> GetLeaderboard(Type type, DateTime date)
    {
        if (!SteamManager.init)
        {
            return null;
        }
        return await GetLeaderboard(GetLeaderboardName(type, date));
    }

    public static async Task<Leaderboard?> GetLeaderboard(string leaderboardName)
    {
        if (!SteamManager.init)
        {
            return null;
        }
        return await SteamUserStats.FindOrCreateLeaderboardAsync(leaderboardName, (LeaderboardSort)2, (LeaderboardDisplay)1);
    }

    public static async Task<LeaderboardEntry[]> GetGlobal(Leaderboard board, int entries, int offset)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        if (!SteamManager.init)
        {
            return null;
        }
        return await ((board)).GetScoresAsync(entries, offset);
    }

    public static async Task<LeaderboardEntry[]> GetFriends(Leaderboard board, int entries)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        if (!SteamManager.init)
        {
            return null;
        }
        return await ((board)).GetScoresFromFriendsAsync();
    }

    public static async Task<LeaderboardEntry[]> GetAround(Leaderboard board, int entries)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        if (!SteamManager.init)
        {
            return null;
        }
        int num = entries / 2;
        return await ((board)).GetScoresAroundUserAsync(-num, num);
    }
}
public static class Sequences
{
    public static IEnumerator Wait(float seconds)
    {
        while (seconds > 0f)
        {
            seconds -= Time.deltaTime;
            if (!(seconds <= 0f))
            {
                yield return null;
                continue;
            }
            break;
        }
    }

    public static IEnumerator Null()
    {
        if (!GameManager.paused)
        {
            yield return (object)new WaitForFixedUpdate();
        }
    }

    public static IEnumerator WaitForAnimationEnd(Entity entity)
    {
        yield return (object)new WaitUntil((Func<bool>)(() => !entity.IsAliveAndExists() || !(entity.curveAnimator) || !entity.curveAnimator.active));
    }

    public static IEnumerator WaitForStatusEffectEvents()
    {
        while (StatusEffectSystem.EventsRunning)
        {
            yield return null;
        }
    }

    public static IEnumerator ShuffleTo(CardContainer fromContainer, CardContainer toContainer, float delayBetween = 0.05f)
    {
        if (!(toContainer) || !toContainer.Empty || !(fromContainer))
        {
            yield break;
        }
        while (!fromContainer.Empty)
        {
            int index = Random.Range(0, fromContainer.Count);
            Entity entity = fromContainer[index];
            yield return CardMove(entity, new CardContainer[1] { toContainer });
            if (delayBetween > 0f)
            {
                yield return Wait(delayBetween);
            }
        }
        if (delayBetween <= 0f)
        {
            toContainer.SetChildPositions();
        }
    }

    public static IEnumerator CardDiscard(Entity entity)
    {
        Debug.Log($"Discarding [{entity}]");
        yield return CardMove(entity, new CardContainer[1] { entity.owner.discardContainer });
    }

    public static IEnumerator CardMove(Entity entity, CardContainer[] toContainers, int insertPos = -1, bool tweenAll = true)
    {
        bool enabled = ((Behaviour)entity).enabled;
        entity.RemoveFromContainers();
        if (insertPos >= 0)
        {
            CardContainer[] array = toContainers;
            for (int i = 0; i < array.Length; i++)
            {
                array[i].Insert(insertPos, entity);
            }
        }
        else
        {
            CardContainer[] array = toContainers;
            for (int i = 0; i < array.Length; i++)
            {
                array[i].Add(entity);
            }
        }
        entity.ResetDrawOrder();
        if (!((Behaviour)entity).enabled && enabled)
        {
            yield return StatusEffectSystem.EntityDisableEvent(entity);
        }
        if (tweenAll)
        {
            CardContainer[] array = toContainers;
            for (int i = 0; i < array.Length; i++)
            {
                array[i].TweenChildPositions();
            }
            if (toContainers.Length == 1 && toContainers[0] is CardSlotLane cardSlotLane)
            {
                foreach (Entity item in cardSlotLane)
                {
                    if (item.height <= 1)
                    {
                        continue;
                    }
                    array = item.containers;
                    foreach (CardContainer cardContainer in array)
                    {
                        if (cardContainer != cardSlotLane)
                        {
                            cardContainer.TweenChildPositions();
                        }
                    }
                }
            }
        }
        Events.InvokeEntityMove(entity);
        yield return StatusEffectSystem.CardMoveEvent(entity);
    }

    public static IEnumerator CardRecall(Entity entity)
    {
        if ((entity.owner.discardContainer))
        {
            yield return Wait(0.3f);
            yield return CardMove(entity, new CardContainer[1] { entity.owner.discardContainer });
        }
        else if ((entity.owner.reserveContainer))
        {
            yield return Wait(0.3f);
            int insertPos = RandomInclusive.Range(0, entity.owner.reserveContainer.Count - 1);
            yield return CardMove(entity, new CardContainer[1] { entity.owner.reserveContainer }, insertPos);
        }
    }

    public static IEnumerator EndCampaign(string newSceneKey)
    {
        yield return Transition.WaitUntilDone(Transition.Begin());
        if ((References.Campaign))
        {
            References.Campaign.Final();
        }
        Routine.Clump clump = new Routine.Clump();
        clump.Add(SceneManager.Unload("Campaign"));
        clump.Add(SceneManager.Unload("UI"));
        yield return clump.WaitForEnd();
        yield return SceneChange(newSceneKey);
    }

    public static IEnumerator SceneChange(string newSceneKey)
    {
        string preActive = SceneManager.ActiveSceneKey;
        CardPopUp.Clear();
        yield return SceneManager.Load(newSceneKey, SceneType.Active);
        yield return SceneManager.Unload(preActive);
    }
}
public static class Settings
{
    public static readonly ES3Settings settings = new ES3Settings(new Enum[1] { (Enum)(object)(Directory)0 })
    {
        path = "settings.json",
        encryptionType = (EncryptionType)0,
        compressionType = (CompressionType)0,
        prettyPrint = true
    };

    public static void Save<T>(string key, T value)
    {
        try
        {
            ES3.Save<T>(key, value, settings);
        }
        catch (FormatException ex)
        {
            Debug.LogWarning(ex);
            ES3.DeleteFile(settings);
            try
            {
                ES3.Save<T>(key, value, settings);
            }
            catch (Exception arg)
            {
                Debug.LogError($"ES3 Failed to save Settings even after deleting file.\n{arg}");
            }
        }
        Events.InvokeSettingChanged(key, value);
        Debug.Log($"Setting Saved [{key} = {value}]");
    }

    public static T Load<T>(string key, T defaultValue)
    {
        T val = defaultValue;
        try
        {
            val = ES3.Load<T>(key, defaultValue, settings);
        }
        catch (Exception ex)
        {
            Debug.LogWarning(ex);
        }
        Debug.Log($"Setting Loaded [{key} = {val}]");
        return val;
    }

    public static bool Exists(string key)
    {
        try
        {
            return ES3.KeyExists(key, settings);
        }
        catch (Exception ex)
        {
            Debug.LogWarning(ex);
        }
        return false;
    }
}
public class StatusEffectSystem : GameSystem
{
    public class StatusEffectComparer : IComparer<StatusEffectData>
    {
        public int Compare(StatusEffectData x, StatusEffectData y)
        {
            int num = ((x != null) ? x.eventPriority : 0);
            int num2 = ((y != null) ? y.eventPriority : 0);
            if (num >= num2)
            {
                return 1;
            }
            return -1;
        }
    }

    public static readonly FreezableList<StatusEffectData> activeEffects = new FreezableList<StatusEffectData>(autoSort: true, new StatusEffectComparer());

    public static int eventRoutineCount;

    public static bool EventsRunning => eventRoutineCount > 0;

    public static IEnumerator Apply(Entity target, Entity applier, StatusEffectData effectData, int count, bool temporary = false, System.Action<StatusEffectData> onEffectApplied = null, bool fireEvents = true, bool applyEvenIfZero = false)
    {
        bool flag = true;
        if (effectData.targetConstraints != null && effectData.targetConstraints.Any((TargetConstraint constraint) => !constraint.Check(target)))
        {
            flag = false;
        }
        if (!flag)
        {
            yield break;
        }
        activeEffects.Freeze();
        StatusEffectApply s = new StatusEffectApply(applier, target, effectData, count);
        if (fireEvents)
        {
            yield return ApplyStatusEvent(s);
        }
        if ((s.effectData) && (s.count > 0 || applyEvenIfZero || !s.effectData.canBeBoosted || s.effectData is StatusEffectInstantMultiple))
        {
            StatusEffectData effect = target.statusEffects.Find((StatusEffectData a) => (a).name == (s.effectData).name);
            if ((effect) && effect.stackable)
            {
                Debug.Log($"Stacking [{(s.effectData).name} {s.count}] on top of [{(target).name}]");
                effect.count += s.count;
                if (temporary)
                {
                    effect.temporary += s.count;
                }
                effect.applier = applier;
            }
            else
            {
                Debug.Log($"[{(s.effectData).name} {s.count}] applied to [{(target).name}]");
                effect = s.effectData.Instantiate();
                effect.Apply(s.count, target, applier);
                if (temporary)
                {
                    effect.temporary = s.count;
                }
                activeEffects.Add(effect);
                onEffectApplied?.Invoke(effect);
                if (effect.RunBeginEvent() && effect.HasBeginRoutine)
                {
                    yield return effect.BeginRoutine();
                }
            }
            if ((applier))
            {
                effect.applierOwner = applier.owner;
            }
            if (effect.RunStackEvent(s.count) && effect.HasStackRoutine)
            {
                yield return effect.StackRoutine(s.count);
            }
            target.PromptUpdate();
        }
        if (target.startingEffectsApplied && target.display.init && fireEvents)
        {
            Events.InvokeStatusEffectApplied(s);
            yield return PostApplyStatusEvent(s);
        }
        activeEffects.Thaw();
    }

    public static IEnumerator Clear()
    {
        activeEffects.Freeze();
        for (int i = activeEffects.Count - 1; i >= 0; i--)
        {
            yield return activeEffects[i].Remove();
        }
        activeEffects.Thaw();
    }

    public static IEnumerator EntityEnableEvent(Entity entity)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunEnableEvent(entity) && statusEffectData.HasEnableRoutine)
            {
                yield return statusEffectData.EnableRoutine(entity);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator EntityDisableEvent(Entity entity)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunDisableEvent(entity) && statusEffectData.HasDisableRoutine)
            {
                yield return statusEffectData.DisableRoutine(entity);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator TurnStartEvent(Entity entity)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunTurnStartEvent(entity) && statusEffectData.HasTurnStartRoutine)
            {
                yield return statusEffectData.TurnStartRoutine(entity);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator TurnEvent(Entity entity)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunTurnEvent(entity) && statusEffectData.HasTurnRoutine)
            {
                yield return statusEffectData.TurnRoutine(entity);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator TurnEndEvent(Entity entity)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunTurnEndEvent(entity) && statusEffectData.HasTurnEndRoutine)
            {
                yield return statusEffectData.TurnEndRoutine(entity);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator PreAttackEvent(Hit hit)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunPreAttackEvent(hit) && statusEffectData.HasPreAttackRoutine)
            {
                yield return statusEffectData.PreAttackRoutine(hit);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator HitEvent(Hit hit)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunHitEvent(hit) && statusEffectData.HasHitRoutine)
            {
                yield return statusEffectData.HitRoutine(hit);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator PostHitEvent(Hit hit)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunPostHitEvent(hit) && statusEffectData.HasPostHitRoutine)
            {
                yield return statusEffectData.PostHitRoutine(hit);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator PostAttackEvent(Hit hit)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunPostAttackEvent(hit) && statusEffectData.HasPostAttackRoutine)
            {
                yield return statusEffectData.PostAttackRoutine(hit);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator ApplyStatusEvent(StatusEffectApply apply)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunApplyStatusEvent(apply) && statusEffectData.HasApplyStatusRoutine)
            {
                yield return statusEffectData.ApplyStatusRoutine(apply);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator PostApplyStatusEvent(StatusEffectApply apply)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunPostApplyStatusEvent(apply) && statusEffectData.HasPostApplyStatusRoutine)
            {
                yield return statusEffectData.PostApplyStatusRoutine(apply);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator EntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c2 = activeEffects.Count;
        for (int j = c2 - 1; j >= 0; j--)
        {
            int count = activeEffects.Count;
            if (count < c2)
            {
                j -= c2 - count;
                c2 = count;
            }
            if (j < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[j];
            if (statusEffectData.target != null && statusEffectData.RunEntityDestroyedEvent(entity, deathType) && statusEffectData.HasEntityDestroyedRoutine)
            {
                yield return statusEffectData.EntityDestroyedRoutine(entity, deathType);
            }
        }
        if (entity.statusEffects != null)
        {
            c2 = entity.statusEffects.Count;
            for (int j = c2 - 1; j >= 0; j--)
            {
                int count2 = activeEffects.Count;
                if (count2 < c2)
                {
                    j -= c2 - count2;
                    c2 = count2;
                }
                if (j < 0)
                {
                    break;
                }
                StatusEffectData statusEffectData2 = entity.statusEffects[j];
                if (statusEffectData2.target != null && statusEffectData2.RunDisableEvent(entity) && statusEffectData2.HasDisableRoutine)
                {
                    yield return statusEffectData2.DisableRoutine(entity);
                }
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator CardMoveEvent(Entity entity)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunCardMoveEvent(entity) && statusEffectData.HasCardMoveRoutine)
            {
                yield return statusEffectData.CardMoveRoutine(entity);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator PreTriggerEvent(Trigger trigger)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunPreTriggerEvent(trigger) && statusEffectData.HasPreTriggerRoutine)
            {
                yield return statusEffectData.PreTriggerRoutine(trigger);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator PreCardPlayedEvent(Entity entity, Entity[] targets)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunPreCardPlayedEvent(entity, targets) && statusEffectData.HasPreCardPlayedRoutine)
            {
                yield return statusEffectData.PreCardPlayedRoutine(entity, targets);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator CardPlayedEvent(Entity entity, Entity[] targets)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunCardPlayedEvent(entity, targets) && statusEffectData.HasCardPlayedRoutine)
            {
                yield return statusEffectData.CardPlayedRoutine(entity, targets);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator EffectBonusChangedEvent(Entity entity)
    {
        eventRoutineCount++;
        if (entity.statusEffects != null)
        {
            activeEffects.Freeze();
            int c = entity.statusEffects.Count;
            for (int i = c - 1; i >= 0; i--)
            {
                int count = activeEffects.Count;
                if (count < c)
                {
                    i -= c - count;
                    c = count;
                }
                if (i < 0)
                {
                    break;
                }
                StatusEffectData statusEffectData = entity.statusEffects[i];
                if (statusEffectData.target != null && statusEffectData.RunEffectBonusChangedEvent() && statusEffectData.HasEffectBonusChangedRoutine)
                {
                    yield return statusEffectData.EffectBonusChangedRoutine();
                }
            }
            activeEffects.Thaw();
        }
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator ActionPerformedEvent(PlayAction action)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunActionPerformedEvent(action) && statusEffectData.HasActionPerformedRoutine)
            {
                yield return statusEffectData.ActionPerformedRoutine(action);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }

    public static IEnumerator BuildEvent(Entity entity)
    {
        eventRoutineCount++;
        activeEffects.Freeze();
        int c = activeEffects.Count;
        for (int i = c - 1; i >= 0; i--)
        {
            int count = activeEffects.Count;
            if (count < c)
            {
                i -= c - count;
                c = count;
            }
            if (i < 0)
            {
                break;
            }
            StatusEffectData statusEffectData = activeEffects[i];
            if (statusEffectData.target != null && statusEffectData.RunBuildEvent(entity) && statusEffectData.HasBuildRoutine)
            {
                yield return statusEffectData.BuildRoutine(entity);
            }
        }
        activeEffects.Thaw();
        eventRoutineCount--;
        yield return Sequences.Null();
    }
}
public static class Targets
{
    [Flags]
    public enum Flag
    {
        None = 0,
        Self = 1,
        Hand = 2,
        EnemyHand = 4,
        Allies = 8,
        AlliesInRow = 0x10,
        FrontAlly = 0x20,
        BackAlly = 0x40,
        AllyInFrontOf = 0x80,
        AllyBehind = 0x100,
        Enemies = 0x200,
        EnemiesInRow = 0x400,
        FrontEnemy = 0x800,
        Attacker = 0x1000,
        Target = 0x2000,
        RandomAlly = 0x4000,
        RandomEnemy = 0x8000,
        RandomUnit = 0x10000
    }

    public static bool CheckFlag(Flag flags, Flag target)
    {
        return (flags & target) != 0;
    }

    public static List<Entity> Get(Entity self, Flag canTarget, StatusEffectData effectToApply, TargetConstraint[] applyConstraints, Hit hit = null)
    {
        List<Entity> list = new List<Entity>();
        if (CheckFlag(canTarget, Flag.Self))
        {
            list.Add(self);
        }
        CheckFlag(canTarget, Flag.Hand);
        CheckFlag(canTarget, Flag.EnemyHand);
        if (CheckFlag(canTarget, Flag.Allies))
        {
            list.AddRange(self.GetAllAllies());
        }
        else if (CheckFlag(canTarget, Flag.AlliesInRow))
        {
            list.AddRange(self.GetAlliesInRow());
        }
        else
        {
            if (CheckFlag(canTarget, Flag.FrontAlly))
            {
                CardContainer[] containers = self.containers;
                for (int i = 0; i < containers.Length; i++)
                {
                    foreach (Entity item3 in containers[i])
                    {
                        if ((item3))
                        {
                            list.Add(item3);
                            break;
                        }
                    }
                }
            }
            if (CheckFlag(canTarget, Flag.BackAlly))
            {
                CardContainer[] containers = self.containers;
                foreach (CardContainer cardContainer in containers)
                {
                    for (int num = cardContainer.Count - 1; num >= 0; num--)
                    {
                        Entity entity = cardContainer[num];
                        if ((entity))
                        {
                            list.Add(entity);
                            break;
                        }
                    }
                }
            }
            if (CheckFlag(canTarget, Flag.AllyInFrontOf))
            {
                foreach (CardContainer actualContainer in self.actualContainers)
                {
                    Entity entity2 = null;
                    if (actualContainer is CardSlot item && actualContainer.Group is CardSlotLane cardSlotLane)
                    {
                        for (int num2 = cardSlotLane.slots.IndexOf(item) - 1; num2 >= 0; num2--)
                        {
                            entity2 = cardSlotLane.slots[num2].GetTop();
                            if ((entity2))
                            {
                                break;
                            }
                        }
                    }
                    if ((entity2))
                    {
                        list.Add(entity2);
                        break;
                    }
                }
            }
            if (CheckFlag(canTarget, Flag.AllyBehind))
            {
                foreach (CardContainer actualContainer2 in self.actualContainers)
                {
                    Entity entity3 = null;
                    if (actualContainer2 is CardSlot item2 && actualContainer2.Group is CardSlotLane cardSlotLane2)
                    {
                        for (int j = cardSlotLane2.slots.IndexOf(item2) + 1; j < cardSlotLane2.slots.Count; j++)
                        {
                            entity3 = cardSlotLane2.slots[j].GetTop();
                            if ((entity3))
                            {
                                break;
                            }
                        }
                    }
                    if ((entity3))
                    {
                        list.Add(entity3);
                        break;
                    }
                }
            }
        }
        if (CheckFlag(canTarget, Flag.Enemies))
        {
            list.AddRange(self.GetAllEnemies());
        }
        else if (CheckFlag(canTarget, Flag.EnemiesInRow))
        {
            int[] rowIndices = Battle.instance.GetRowIndices(self);
            foreach (int rowIndex in rowIndices)
            {
                List<Entity> enemiesInRow = self.GetEnemiesInRow(rowIndex);
                if (enemiesInRow != null && enemiesInRow.Count > 0)
                {
                    list.AddRange(enemiesInRow);
                }
            }
        }
        else if (CheckFlag(canTarget, Flag.FrontEnemy))
        {
            int[] rowIndices = Battle.instance.GetRowIndices(self);
            foreach (int rowIndex2 in rowIndices)
            {
                List<Entity> enemiesInRow2 = self.GetEnemiesInRow(rowIndex2);
                if (enemiesInRow2 != null && enemiesInRow2.Count > 0)
                {
                    list.Add(enemiesInRow2[0]);
                }
            }
        }
        if (CheckFlag(canTarget, Flag.Attacker))
        {
            hit ??= self.lastHit;
            if ((hit?.attacker))
            {
                Entity entity4 = hit.attacker;
                if (!effectToApply.CanPlayOn(entity4))
                {
                    entity4 = (effectToApply.CanPlayOn(entity4.owner.entity) ? entity4.owner.entity : null);
                }
                if ((entity4))
                {
                    list.Add(entity4);
                }
            }
        }
        if (CheckFlag(canTarget, Flag.Target))
        {
            hit ??= self.lastHit;
            if ((hit?.target))
            {
                list.Add(hit.target);
            }
        }
        if (CheckFlag(canTarget, Flag.RandomUnit))
        {
            List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(self.owner);
            cardsOnBoard.AddRange(Battle.GetCardsOnBoard(Battle.GetOpponent(self.owner)));
            cardsOnBoard.Remove(self);
            RemoveIneligible(cardsOnBoard, effectToApply, applyConstraints);
            if (cardsOnBoard.Count > 0)
            {
                list.Add(IListExt.RandomItem<Entity>((IList<Entity>)cardsOnBoard));
            }
        }
        if (CheckFlag(canTarget, Flag.RandomAlly))
        {
            List<Entity> cardsOnBoard2 = Battle.GetCardsOnBoard(self.owner);
            cardsOnBoard2.Remove(self);
            RemoveIneligible(cardsOnBoard2, effectToApply, applyConstraints);
            if (cardsOnBoard2.Count > 0)
            {
                list.Add(IListExt.RandomItem<Entity>((IList<Entity>)cardsOnBoard2));
            }
        }
        if (CheckFlag(canTarget, Flag.RandomEnemy))
        {
            List<Entity> cardsOnBoard3 = Battle.GetCardsOnBoard(Battle.GetOpponent(self.owner));
            RemoveIneligible(cardsOnBoard3, effectToApply, applyConstraints);
            if (cardsOnBoard3.Count > 0)
            {
                list.Add(IListExt.RandomItem<Entity>((IList<Entity>)cardsOnBoard3));
            }
        }
        return list;
    }

    public static void RemoveIneligible(IList<Entity> list, StatusEffectData effectToApply, TargetConstraint[] applyConstraints)
    {
        for (int num = list.Count - 1; num >= 0; num--)
        {
            Entity target = list[num];
            if (!effectToApply.CanPlayOn(target))
            {
                list.RemoveAt(num);
            }
            else
            {
                for (int i = 0; i < applyConstraints.Length; i++)
                {
                    if (!applyConstraints[i].Check(target))
                    {
                        list.RemoveAt(num);
                        break;
                    }
                }
            }
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Immunity/Immune To X", fileName = "Immune To X")]
public class StatusEffectImmuneToX : StatusEffectData
{
    [SerializeField]
    public string immunityType = "snow";

    public const int max = 1;

    public override void Init()
    {
        base.OnBegin += Begin;
    }

    public IEnumerator Begin()
    {
        StatusEffectData statusEffectData = target.FindStatus(immunityType);
        if ((statusEffectData) && statusEffectData.count > 1)
        {
            yield return statusEffectData.RemoveStacks(statusEffectData.count - 1, removeTemporary: false);
        }
    }

    public override bool RunApplyStatusEvent(StatusEffectApply apply)
    {
        if (apply.target == target && (apply.effectData) && apply.effectData.type == immunityType)
        {
            StatusEffectData statusEffectData = target.FindStatus(immunityType);
            int num = ((statusEffectData) ? statusEffectData.count : 0);
            apply.count = Mathf.Max(new int[1] { 1 - num });
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Immunity/Resist X", fileName = "Resist X")]
public class StatusEffectResistX : StatusEffectData
{
    [SerializeField]
    public string resistType = "snow";

    public override bool RunApplyStatusEvent(StatusEffectApply apply)
    {
        if (apply.target == target && apply.effectData?.type == resistType)
        {
            apply.count -= count;
            if (apply.count <= 0)
            {
                apply.effectData = null;
                apply.count = 0;
            }
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Injuries/Injury", fileName = "Injury")]
public class StatusEffectInjury : StatusEffectData
{
    [SerializeField]
    public float healthFactor = 0.5f;

    [SerializeField]
    public float damageFactor = 0.5f;

    [SerializeField]
    public int counterIncrease;

    public bool hasRun;

    public override void Init()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleStart += new UnityAction(BattleStart);
    }

    public void OnDestroy()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Expected O, but got Unknown
        Events.OnBattleStart -= new UnityAction(BattleStart);
    }

    public void BattleStart()
    {
        Run();
    }

    public override bool RunBeginEvent()
    {
        if (!target.inPlay)
        {
            Run();
        }
        return false;
    }

    public void Run()
    {
        if (!hasRun)
        {
            hasRun = true;
            if (counterIncrease > 0 && target.counter.max > 0)
            {
                target.counter.max += counterIncrease;
                target.counter.current += counterIncrease;
            }
            target.damage.current = Mathf.CeilToInt((float)target.damage.current * damageFactor);
            target.hp.current = Mathf.CeilToInt((float)target.hp.current * healthFactor);
            target.PromptUpdate();
        }
    }
}
public abstract class StatusEffectInstant : StatusEffectData
{
    public override bool Instant => true;

    public override void Init()
    {
        base.OnBegin += Process;
    }

    public override IEnumerator BeginRoutine()
    {
        if (count > 0 || !canBeBoosted || this is StatusEffectInstantMultiple)
        {
            yield return base.BeginRoutine();
        }
        else
        {
            yield return Remove();
        }
    }

    public virtual IEnumerator Process()
    {
        yield return Remove();
    }

    public override int GetAmount()
    {
        return count;
    }

    public StatusEffectInstant()
    {
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Activate Sacrifice Effects", fileName = "Activate Sacrifice Effects")]
public class StatusEffectInstantActivateSacrificeEffects : StatusEffectInstant
{
    [SerializeField]
    public bool forOtherTeam;

    public override IEnumerator Process()
    {
        if (!DeathSystem.KilledByOwnTeam(target))
        {
            if (forOtherTeam)
            {
                DeathSystem.TreatAsTeam(target.data.id, Battle.GetOpponent(target.owner).team);
                target.lastHit.owner = Battle.GetOpponent(target.lastHit.owner);
            }
            else
            {
                MakeLastHitSacrifice();
            }
            TriggerSacrificeVFX();
        }
        yield return base.Process();
    }

    public void MakeLastHitSacrifice()
    {
        target.lastHit = new Hit(target, target, 1)
        {
            attacker = null
        };
    }

    public void TriggerSacrificeVFX()
    {
        Object.FindObjectOfType<VfxDeathSystem>()?.EntityKilled(target, DeathType.Normal);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Apply Status Effect", fileName = "Apply Status Effect")]
public class StatusEffectInstantApplyEffect : StatusEffectInstant
{
    [SerializeField]
    public StatusEffectData effectToApply;

    [SerializeField]
    public ScriptableAmount scriptableAmount;

    public override IEnumerator Process()
    {
        int num = ((scriptableAmount) ? scriptableAmount.Get(target) : GetAmount());
        yield return StatusEffectSystem.Apply(target, applier, effectToApply, num);
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Budge", fileName = "Budge")]
public class StatusEffectInstantBudge : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        int[] rowIndices = Battle.instance.GetRowIndices(target);
        if (rowIndices.Length == 1)
        {
            int num = rowIndices[0];
            int num2 = (num + 1) % Battle.instance.rowCount;
            if (num2 != num)
            {
                CardContainer row = Battle.instance.GetRow(target.owner, num2);
                if (row.Count < row.max)
                {
                    Battle.instance.GetRow(target.owner, num);
                    yield return Sequences.CardMove(target, new CardContainer[1] { row });
                }
            }
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Cleanse", fileName = "Cleanse")]
public class StatusEffectInstantCleanse : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        int num = target.statusEffects.Count;
        for (int i = num - 1; i >= 0; i--)
        {
            StatusEffectData statusEffectData = target.statusEffects[i];
            if (statusEffectData.IsNegativeStatusEffect())
            {
                yield return statusEffectData.Remove();
            }
        }
        target.PromptUpdate();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Copy Effects", fileName = "Copy Effects")]
public class StatusEffectInstantCopyEffects : StatusEffectInstant
{
    [SerializeField]
    public bool replaceAllEffects = true;

    [SerializeField]
    [HideIf("replaceAllEffects")]
    public int replaceEffectNumber;

    public override IEnumerator Process()
    {
        yield return replaceAllEffects ? RemoveAllEffects() : RemoveEffect(replaceEffectNumber);
        yield return AddEffectCopies();
        if (applier.display is Card card)
        {
            card.promptUpdateDescription = true;
        }
        applier.PromptUpdate();
        yield return base.Process();
    }

    public IEnumerator RemoveAllEffects()
    {
        foreach (Entity.TraitStacks trait in applier.traits)
        {
            trait.count = 0;
        }
        yield return applier.UpdateTraits();
        Routine.Clump clump = new Routine.Clump();
        foreach (StatusEffectData item in applier.statusEffects.Where((StatusEffectData e) => !e.visible))
        {
            clump.Add(item.Remove());
        }
        yield return clump.WaitForEnd();
    }

    public IEnumerator RemoveEffect(int effectNumber)
    {
        StatusEffectData statusEffectData = applier.statusEffects[effectNumber];
        yield return statusEffectData.Remove();
    }

    public IEnumerator AddEffectCopies()
    {
        List<StatusEffectData> list = target.statusEffects.Where((StatusEffectData e) => e.count > e.temporary && !e.isStatus && e != this && e.HasDescOrIsKeyword).ToList();
        foreach (Entity.TraitStacks trait in target.traits)
        {
            foreach (StatusEffectData passiveEffect in trait.passiveEffects)
            {
                list.Remove(passiveEffect);
            }
            int num = trait.count - trait.tempCount;
            if (num > 0)
            {
                applier.GainTrait(trait.data, num);
            }
        }
        foreach (StatusEffectData item in list)
        {
            yield return StatusEffectSystem.Apply(applier, item.applier, item, item.count - item.temporary);
        }
        applier.attackEffects = (from a in CardData.StatusEffectStacks.Stack(applier.attackEffects, target.attackEffects)
                                 select a.Clone()).ToList();
        yield return applier.UpdateTraits();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Destroy Cards In Hand And Apply X For Each", fileName = "Instant Destroy Cards In Hand And Apply X For Each")]
public class StatusEffectInstantDestroyCardsInHandAndApplyXForEach : StatusEffectInstant
{
    [SerializeField]
    public TargetConstraint[] destroyConstraints;

    [SerializeField]
    public StatusEffectInstant destroyCardEffect;

    [SerializeField]
    public StatusEffectData effectToApply;

    public int destroyed;

    public override IEnumerator Process()
    {
        Character player = References.Player;
        int a = GetAmount();
        yield return DestroyCardsSequence(player.handContainer);
        for (int i = 0; i < destroyed; i++)
        {
            yield return StatusEffectSystem.Apply(target, target, effectToApply, a);
        }
        yield return base.Process();
    }

    public IEnumerator DestroyCardsSequence(CardContainer container)
    {
        bool pingDone = false;
        List<Entity> list = new List<Entity>(container);
        foreach (Entity item in list)
        {
            if (CheckConstraints(item))
            {
                if (!pingDone)
                {
                    target.curveAnimator.Ping();
                    pingDone = true;
                }
                destroyed++;
                yield return StatusEffectSystem.Apply(item, target, destroyCardEffect, 1, temporary: true);
            }
        }
    }

    public bool CheckConstraints(Entity card)
    {
        TargetConstraint[] array = destroyConstraints;
        for (int i = 0; i < array.Length; i++)
        {
            if (!array[i].Check(card))
            {
                return false;
            }
        }
        return true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Double Negative Effects", fileName = "Double Negative Effects")]
public class StatusEffectInstantDoubleNegativeEffects : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        Hit hit = new Hit(applier, target, 0);
        for (int num = target.statusEffects.Count - 1; num >= 0; num--)
        {
            StatusEffectData statusEffectData = target.statusEffects[num];
            if (statusEffectData.IsNegativeStatusEffect())
            {
                hit.AddStatusEffect(statusEffectData, statusEffectData.count);
            }
        }
        if (hit.Offensive)
        {
            yield return hit.Process();
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Double X", fileName = "Double X")]
public class StatusEffectInstantDoubleX : StatusEffectInstant
{
    public StatusEffectData statusToDouble;

    [SerializeField]
    public bool countsAsHit = true;

    public override IEnumerator Process()
    {
        StatusEffectData statusEffectData = target.statusEffects.Find((StatusEffectData a) => (a).name == (statusToDouble).name);
        if ((statusEffectData))
        {
            target.curveAnimator.Ping();
            Hit hit = new Hit(applier, target, 0)
            {
                countsAsHit = countsAsHit
            };
            hit.AddStatusEffect(statusToDouble, statusEffectData.count);
            yield return hit.Process();
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Draw", fileName = "Instant Draw")]
public class StatusEffectInstantDraw : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        Character player = References.Player;
        if (player.drawContainer.Empty && player.discardContainer.Empty)
        {
            if (NoTargetTextSystem.Exists())
            {
                yield return NoTargetTextSystem.Run(target, NoTargetType.NoCardsToDraw);
            }
        }
        else
        {
            ActionQueue.Stack(new ActionDraw(player, GetAmount()), fixedPosition: true);
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Eat", fileName = "Eat")]
public class StatusEffectInstantEat : StatusEffectInstant
{
    [SerializeField]
    public bool gainHealth = true;

    [SerializeField]
    public bool gainAttack = true;

    [SerializeField]
    public bool gainEffects = true;

    [SerializeField]
    [ShowIf("gainEffects")]
    public TraitData[] illegalTraits;

    [SerializeField]
    [ShowIf("gainEffects")]
    public StatusEffectData[] illegalEffects;

    public override IEnumerator Process()
    {
        if ((applier) && applier.alive && (target) && target.alive && (gainHealth || gainAttack || gainEffects))
        {
            yield return Eat();
        }
        target.forceKill = true;
        yield return target.Kill(DeathType.Eaten);
        yield return base.Process();
    }

    public IEnumerator Eat()
    {
        if (gainHealth)
        {
            GainHealth();
        }
        if (gainAttack)
        {
            GainAttack();
        }
        if (gainEffects)
        {
            yield return GainEffects();
            applier.PromptUpdate();
        }
    }

    public void GainHealth()
    {
        applier.hp.current += target.hp.current;
        applier.hp.max += target.hp.max;
    }

    public void GainAttack()
    {
        applier.damage.current += target.damage.current;
        applier.damage.max += target.damage.max;
    }

    public IEnumerator GainEffects()
    {
        applier.attackEffects = IArrayExt.ToList<CardData.StatusEffectStacks>(CardData.StatusEffectStacks.Stack(applier.attackEffects, target.attackEffects));
        List<StatusEffectData> list = target.statusEffects.Where((StatusEffectData e) => e != this && !illegalEffects.Select((StatusEffectData e) => (e).name).Contains((e).name)).ToList();
        foreach (Entity.TraitStacks trait in target.traits)
        {
            foreach (StatusEffectData passiveEffect in trait.passiveEffects)
            {
                list.Remove(passiveEffect);
            }
            int num = trait.count - trait.tempCount;
            if (num > 0 && !illegalTraits.Select((TraitData t) => (t).name).Contains((trait.data).name))
            {
                applier.GainTrait(trait.data, num);
            }
        }
        foreach (StatusEffectData item in list)
        {
            yield return StatusEffectSystem.Apply(applier, target, item, item.count);
        }
        yield return applier.UpdateTraits();
        applier.display.promptUpdateDescription = true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Eat Something", fileName = "Eat Something")]
public class StatusEffectInstantEatSomething : StatusEffectInstant
{
    [SerializeField]
    public float delayAfter = 0.25f;

    [SerializeField]
    public StatusEffectData eatEffect;

    [SerializeField]
    public Targets.Flag targetFlags;

    public override IEnumerator Process()
    {
        List<Entity> list = Targets.Get(target, targetFlags, eatEffect, targetConstraints);
        if (list != null && list.Count > 0)
        {
            foreach (Entity item in list)
            {
                if (item.IsAliveAndExists() && eatEffect.CanPlayOn(item))
                {
                    Trigger trigger = new Trigger(target, target, "eat", new Entity[1] { item })
                    {
                        countsAsTrigger = false
                    };
                    Hit hit = new Hit(target, item, 0)
                    {
                        canBeNullified = false,
                        canRetaliate = false,
                        damageType = "eat",
                        trigger = trigger
                    };
                    hit.AddStatusEffect(eatEffect, 1);
                    trigger.hits = new Hit[1] { hit };
                    yield return trigger.Process();
                }
            }
            yield return Sequences.Wait(delayAfter);
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Escape", fileName = "Escape")]
public class StatusEffectInstantEscape : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        ActionQueue.Add(new ActionFlee(target));
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Fill Board", fileName = "Fill Board")]
public class StatusEffectInstantFillBoard : StatusEffectInstant
{
    [SerializeField]
    public bool doPing = true;

    [SerializeField]
    public EventReference sfxEvent;

    [SerializeField]
    public CardData[] withCards;

    public readonly List<CardData> pool = new List<CardData>();

    public override IEnumerator Process()
    {
        if (doPing)
        {
            target.curveAnimator.Ping();
            SfxSystem.OneShot(sfxEvent);
            Events.InvokeScreenRumble(0f, 0.4f, 0f, 0.4f, 0.1f, 0.4f);
        }
        List<CardContainer> rows = References.Battle.GetRows(target.owner);
        List<CardSlot> list = new List<CardSlot>();
        foreach (CardContainer item in rows)
        {
            if (item is CardSlotLane cardSlotLane)
            {
                list.AddRange(cardSlotLane.slots.Where((CardSlot slot) => slot.Empty));
            }
        }
        foreach (CardSlot slot2 in list)
        {
            CardData data = Pull().Clone();
            Card card = CardManager.Get(data, References.Battle.playerCardController, target.owner, inPlay: true, target.owner.team == References.Player.team);
            yield return card.UpdateData();
            target.owner.reserveContainer.Add(card.entity);
            target.owner.reserveContainer.SetChildPosition(card.entity);
            ActionQueue.Stack(new ActionMove(card.entity, slot2), fixedPosition: true);
            ActionQueue.Stack(new ActionRunEnableEvent(card.entity), fixedPosition: true);
        }
        yield return base.Process();
    }

    public CardData Pull()
    {
        if (pool.Count <= 0)
        {
            pool.AddRange(withCards);
        }
        return IListExt.TakeRandom<CardData>((IList<CardData>)pool);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Flee", fileName = "Flee")]
public class StatusEffectInstantFlee : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        yield return Sequences.CardRecall(target);
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Gain Gold", fileName = "Gain Gold")]
public class StatusEffectInstantGainGold : StatusEffectInstant
{
    [SerializeField]
    public bool take;

    public override IEnumerator Process()
    {
        if ((target))
        {
            Character player = References.Player;
            if ((player) && player.data != null && (player.data.inventory))
            {
                int amount = GetAmount();
                if (take)
                {
                    amount = Mathf.Min(((player.data.inventory.gold)).Value, amount);
                    if (amount > 0)
                    {
                        player.SpendGold(amount);
                    }
                }
                else
                {
                    Events.InvokeDropGold(amount, (applier.data).name, player, applier.transform.position);
                }
            }
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Gain Gold Range", fileName = "Gain Gold Range")]
public class StatusEffectInstantGainGoldRange : StatusEffectInstant
{
    [SerializeField]
    public Vector2Int range;

    public override IEnumerator Process()
    {
        Character owner = target.owner;
        if (owner != null)
        {
            int amount = Vector2IntExt.Random(range);
            owner.GainGold(amount);
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Gain Trait", fileName = "Gain Trait")]
public class StatusEffectInstantGainTrait : StatusEffectInstant
{
    public TraitData traitToGain;

    public override IEnumerator Process()
    {
        int amount = GetAmount();
        target.GainTrait(traitToGain, amount);
        yield return target.UpdateTraits();
        target.display.promptUpdateDescription = true;
        target.PromptUpdate();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Heal", fileName = "Heal")]
public class StatusEffectInstantHeal : StatusEffectInstant
{
    [SerializeField]
    public bool doPing = true;

    public override IEnumerator Process()
    {
        if (target.alive)
        {
            if (doPing)
            {
                target.curveAnimator?.Ping();
            }
            Hit hit = new Hit(applier, target, -GetAmount());
            yield return hit.Process();
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Heal Full, Gain Equal X", fileName = "Heal Full, Gain Equal X")]
public class StatusEffectInstantHealFullGainEqualX : StatusEffectInstant
{
    [SerializeField]
    public StatusEffectData effectToGain;

    public override IEnumerator Process()
    {
        int num = target.hp.max - target.hp.current;
        target.curveAnimator.Ping();
        target.hp.current = target.hp.max;
        Hit hit = new Hit(target, target, 0);
        hit.AddStatusEffect(effectToGain, GetAmount() * num);
        yield return hit.Process();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Increase Attack", fileName = "Increase Attack")]
public class StatusEffectInstantIncreaseAttack : StatusEffectInstant
{
    [SerializeField]
    public ScriptableAmount scriptableAmount;

    public override IEnumerator Process()
    {
        target.damage.current += ((scriptableAmount) ? scriptableAmount.Get(target) : GetAmount());
        target.PromptUpdate();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Increase Effects", fileName = "Increase Effects")]
public class StatusEffectInstantIncreaseEffects : StatusEffectInstant
{
    [SerializeField]
    public bool allEffects = true;

    [SerializeField]
    public bool allAttackEffects;

    [SerializeField]
    public bool allPassiveEffects;

    [SerializeField]
    [HideIf("allEffects")]
    public int attackEffectIndex = -1;

    [SerializeField]
    [HideIf("allEffects")]
    public int passiveEffectIndex = -1;

    public override IEnumerator Process()
    {
        int amount = GetAmount();
        if ((target.curveAnimator))
        {
            target.curveAnimator.Ping();
        }
        if (allEffects || (allAttackEffects && allPassiveEffects))
        {
            target.effectBonus += amount;
            target.PromptUpdate();
        }
        else if (allAttackEffects)
        {
            foreach (CardData.StatusEffectStacks attackEffect in target.attackEffects)
            {
                attackEffect.count += amount;
            }
            if (target.display is Card card)
            {
                card.promptUpdateDescription = true;
            }
            target.PromptUpdate();
        }
        else if (allPassiveEffects)
        {
            foreach (StatusEffectData statusEffect in target.statusEffects)
            {
                statusEffect.count += amount;
            }
            if (target.display is Card card2)
            {
                card2.promptUpdateDescription = true;
            }
            target.PromptUpdate();
        }
        else
        {
            if (attackEffectIndex >= 0)
            {
                target.attackEffects[attackEffectIndex].count += amount;
                if (target.display is Card card3)
                {
                    card3.promptUpdateDescription = true;
                }
                target.PromptUpdate();
            }
            if (passiveEffectIndex >= 0)
            {
                target.statusEffects[passiveEffectIndex].count += amount;
                if (target.display is Card card4)
                {
                    card4.promptUpdateDescription = true;
                }
                target.PromptUpdate();
            }
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Increase Max Counter", fileName = "Increase Max Counter")]
public class StatusEffectInstantIncreaseMaxCounter : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        target.counter.current += GetAmount();
        target.counter.max += GetAmount();
        target.PromptUpdate();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Increase Max Health", fileName = "Increase Max Health")]
public class StatusEffectInstantIncreaseMaxHealth : StatusEffectInstant
{
    [SerializeField]
    public bool alsoIncreaseCurrentHealth = true;

    public override IEnumerator Process()
    {
        target.hp.max += GetAmount();
        if (alsoIncreaseCurrentHealth)
        {
            target.hp.current += GetAmount();
        }
        target.PromptUpdate();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Kill", fileName = "Kill")]
public class StatusEffectInstantKill : StatusEffectInstant
{
    [SerializeField]
    public TargetConstraint[] killConstraints;

    [SerializeField]
    public string[] statusesToClear = new string[3] { "block", "shell", "scrap" };

    public override IEnumerator Process()
    {
        Routine.Clump clump = new Routine.Clump();
        string[] array = statusesToClear;
        foreach (string text in array)
        {
            StatusEffectData statusEffectData = target.FindStatus(text);
            if (statusEffectData != null)
            {
                clump.Add(statusEffectData.Remove());
            }
        }
        yield return clump.WaitForEnd();
        if (killConstraints == null || killConstraints.Length == 0 || killConstraints.Any((TargetConstraint a) => a.Check(target)))
        {
            target.forceKill = true;
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Lose Trait", fileName = "Lose Trait")]
public class StatusEffectInstantLoseTrait : StatusEffectInstant
{
    public TraitData traitToLose;

    public override IEnumerator Process()
    {
        Entity.TraitStacks traitStacks = target.traits.FirstOrDefault((Entity.TraitStacks t) => t.data == traitToLose);
        if (traitStacks != null)
        {
            traitStacks.count = 0;
            yield return target.UpdateTraits(traitStacks);
            target.display.promptUpdateDescription = true;
            target.PromptUpdate();
        }
        List<StatusEffectData> list = target.statusEffects.Where((StatusEffectData a) => a is StatusEffectTemporaryTrait statusEffectTemporaryTrait && statusEffectTemporaryTrait.Trait == traitToLose).ToList();
        foreach (StatusEffectData item in list)
        {
            yield return item.Remove();
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Lose X", fileName = "Lose X")]
public class StatusEffectInstantLoseX : StatusEffectInstant
{
    [SerializeField]
    public StatusEffectData statusToLose;

    [SerializeField]
    public bool doPing;

    public override IEnumerator Process()
    {
        StatusEffectData statusEffectData = target.statusEffects.Find((StatusEffectData a) => (a).name == (statusToLose).name);
        if ((statusEffectData))
        {
            if (doPing)
            {
                target.curveAnimator.Ping();
            }
            yield return statusEffectData.RemoveStacks(count, removeTemporary: false);
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Multiple", fileName = "Instant Apply X")]
public class StatusEffectInstantMultiple : StatusEffectInstant
{
    public StatusEffectInstant[] effects;

    public StatusEffectApplyXInstant[] applyXEffects;

    public override bool CanStackActions => false;

    public override IEnumerator Process()
    {
        int amount = GetAmount();
        Routine.Clump clump = new Routine.Clump();
        StatusEffectInstant[] array = effects;
        foreach (StatusEffectInstant statusEffectInstant in array)
        {
            if (!statusEffectInstant.canBeBoosted || amount > 0)
            {
                clump.Add(StatusEffectSystem.Apply(target, applier, statusEffectInstant, amount, temporary: true));
            }
        }
        StatusEffectApplyXInstant[] array2 = applyXEffects;
        foreach (StatusEffectApplyXInstant statusEffectApplyXInstant in array2)
        {
            if (!statusEffectApplyXInstant.canBeBoosted || amount > 0)
            {
                clump.Add(StatusEffectSystem.Apply(target, applier, statusEffectApplyXInstant, amount, temporary: true));
            }
        }
        yield return clump.WaitForEnd();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Pull", fileName = "Pull")]
public class StatusEffectInstantPull : StatusEffectInstant
{
    public const int insertPos = 0;

    public override IEnumerator Process()
    {
        int[] rowIndices = Battle.instance.GetRowIndices(target);
        if (rowIndices.Length == 1)
        {
            CardContainer row = Battle.instance.GetRow(target.owner, rowIndices[0]);
            int num = row.IndexOf(target);
            if (num != 0)
            {
                row.RemoveAt(num);
                bool flag = false;
                if (row is CardSlotLane)
                {
                    flag = row[0] == null;
                    if (!flag)
                    {
                        flag = row.PushBackwards(0);
                        if (!flag)
                        {
                            flag = row.PushForwards(0);
                        }
                    }
                }
                row.Insert((!flag) ? num : 0, target);
                if (flag)
                {
                    foreach (CardContainer row2 in References.Battle.GetRows(target.owner))
                    {
                        row2.TweenChildPositions();
                    }
                }
            }
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Push", fileName = "Push")]
public class StatusEffectInstantPush : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        int[] rowIndices = Battle.instance.GetRowIndices(target);
        if (rowIndices.Length == 1)
        {
            CardContainer row = Battle.instance.GetRow(target.owner, rowIndices[0]);
            int num = row.IndexOf(target);
            int num2 = Mathf.Min(num + GetAmount(), row.max - 1);
            if (num != num2)
            {
                row.RemoveAt(num);
                row.Insert(num2, target);
                foreach (Entity item in row)
                {
                    row.TweenChildPosition(item);
                }
            }
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Randomize Stats", fileName = "Randomize Stats")]
public class StatusEffectInstantRandomizeStats : StatusEffectInstant
{
    [SerializeField]
    public int min = 2;

    [SerializeField]
    public int max = 5;

    public override IEnumerator Process()
    {
        target.hp.max = Random.Range(min, max);
        target.damage.max = Random.Range(min, max);
        target.counter.max = Random.Range(min, max);
        target.hp.current = target.hp.max;
        target.damage.current = target.damage.max;
        target.counter.current = target.counter.max;
        target.ResetWhenHealthLostEffects();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Reduce Attack", fileName = "Reduce Attack")]
public class StatusEffectInstantReduceAttack : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        target.damage.current -= GetAmount();
        target.PromptUpdate();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Reduce Counter", fileName = "Reduce Counter")]
public class StatusEffectInstantReduceCounter : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        Hit hit = new Hit(applier, target, 0)
        {
            countsAsHit = false,
            counterReduction = GetAmount()
        };
        yield return hit.Process();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Reduce Effects", fileName = "Reduce Effects")]
public class StatusEffectInstantReduceEffects : StatusEffectInstant
{
    [SerializeField]
    public bool allEffects = true;

    [SerializeField]
    [HideIf("allEffects")]
    public int attackEffectIndex = -1;

    [SerializeField]
    [HideIf("allEffects")]
    public int passiveEffectIndex = -1;

    public override IEnumerator Process()
    {
        int amount = GetAmount();
        if ((target.curveAnimator))
        {
            target.curveAnimator.Ping();
        }
        if (allEffects)
        {
            target.effectBonus -= amount;
            target.PromptUpdate();
        }
        else
        {
            if (attackEffectIndex >= 0)
            {
                target.attackEffects[attackEffectIndex].count -= amount;
                if (target.display is Card card)
                {
                    card.promptUpdateDescription = true;
                }
                target.PromptUpdate();
            }
            if (passiveEffectIndex >= 0)
            {
                target.statusEffects[passiveEffectIndex].count -= amount;
                if (target.display is Card card2)
                {
                    card2.promptUpdateDescription = true;
                }
                target.PromptUpdate();
            }
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Reduce Max Counter", fileName = "Reduce Max Counter")]
public class StatusEffectInstantReduceMaxCounter : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        target.counter.current = Mathf.Max(0, target.counter.current - GetAmount());
        target.counter.max = Mathf.Max(1, target.counter.max - GetAmount());
        target.PromptUpdate();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Reduce Max Health", fileName = "Reduce Max Health")]
public class StatusEffectInstantReduceMaxHealth : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        target.hp.max -= GetAmount();
        target.hp.current -= GetAmount();
        target.PromptUpdate();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Sacrifice", fileName = "Sacrifice")]
public class StatusEffectInstantSacrifice : StatusEffectInstant
{
    public override IEnumerator Process()
    {
        yield return target.Kill();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Set Attack", fileName = "Set Attack")]
public class StatusEffectInstantSetAttack : StatusEffectInstant
{
    [SerializeField]
    public bool maxOnly;

    [SerializeField]
    public bool equalAmount = true;

    [SerializeField]
    [HideIf("equalAmount")]
    public StatusEffectInstantSetAttack setMaxAttackEffect;

    [SerializeField]
    [HideIf("equalAmount")]
    public float factor = 1f;

    public override IEnumerator Process()
    {
        if (equalAmount)
        {
            int amount = GetAmount();
            target.damage.max = amount;
            target.damage.current = (maxOnly ? Mathf.Min(target.damage.current, target.damage.max) : amount);
        }
        else if (factor < 1f)
        {
            int num = Mathf.CeilToInt((float)target.damage.max * factor);
            int num2 = Mathf.FloorToInt((float)target.damage.current * factor);
            if (num2 > 0)
            {
                Hit hit = new Hit(null, target, num2)
                {
                    countsAsHit = false,
                    screenShake = 0f
                };
                hit.AddStatusEffect(setMaxAttackEffect, num);
                yield return hit.Process();
            }
        }
        else
        {
            target.damage.max = Mathf.CeilToInt((float)target.damage.max * factor);
            target.damage.current = Mathf.CeilToInt((float)target.damage.current * factor);
        }
        target.PromptUpdate();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Set Health", fileName = "Set Health")]
public class StatusEffectInstantSetHealth : StatusEffectInstant
{
    [SerializeField]
    public bool maxOnly;

    [SerializeField]
    public bool equalAmount = true;

    [SerializeField]
    [HideIf("equalAmount")]
    public StatusEffectInstantSetHealth setMaxHealthEffect;

    [SerializeField]
    [HideIf("equalAmount")]
    public float factor = 1f;

    public override IEnumerator Process()
    {
        if (equalAmount)
        {
            int amount = GetAmount();
            target.hp.max = amount;
            target.hp.current = (maxOnly ? Mathf.Min(target.hp.current, target.hp.max) : amount);
        }
        else if (factor < 1f)
        {
            int num = Mathf.CeilToInt((float)target.hp.max * factor);
            int num2 = Mathf.FloorToInt((float)target.hp.current * factor);
            if (num2 > 0)
            {
                Hit hit = new Hit(null, target, num2)
                {
                    countsAsHit = false,
                    screenShake = 0f
                };
                hit.AddStatusEffect(setMaxHealthEffect, num);
                yield return hit.Process();
            }
        }
        else
        {
            target.hp.max = Mathf.CeilToInt((float)target.hp.max * factor);
            target.hp.current = Mathf.CeilToInt((float)target.hp.current * factor);
        }
        target.ResetWhenHealthLostEffects();
        target.PromptUpdate();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Split", fileName = "Split")]
public class StatusEffectInstantSplit : StatusEffectInstant
{
    [Serializable]
    public struct Profile
    {
        public string cardName;

        public string changeToCardName;
    }

    [SerializeField]
    public Profile[] profiles;

    public readonly List<Entity> newCards = new List<Entity>();

    public bool CanSplit()
    {
        if (target.height > 1)
        {
            return true;
        }
        foreach (CardContainer item in References.Battle.rows[target.owner])
        {
            if (item.Count < item.max)
            {
                return true;
            }
        }
        return false;
    }

    public override IEnumerator Process()
    {
        if (CanSplit())
        {
            yield return (target.height > 1) ? SplitDoubleHeight() : Split();
        }
        else if (NoTargetTextSystem.Exists())
        {
            yield return NoTargetTextSystem.Run(target, NoTargetType.CantSplit);
        }
        yield return base.Process();
    }

    public IEnumerator Split()
    {
        target.hp.current = Mathf.CeilToInt((float)target.hp.current * 0.5f);
        target.hp.max = target.hp.current;
        target.data.value = Mathf.CeilToInt((float)target.data.value * 0.5f);
        target.ResetWhenHealthLostEffects();
        List<StatusEffectApply> statusesToApply = (from e in target.statusEffects
                                                   where e.count > e.temporary && e.isStatus
                                                   select new StatusEffectApply(e.applier, null, e.GetOriginal(), Mathf.CeilToInt((float)(e.count - e.temporary) * 0.5f))).ToList();
        Routine.Clump clump = new Routine.Clump();
        foreach (StatusEffectData item in target.statusEffects.Where((StatusEffectData e) => e.isStatus && e.count > e.temporary))
        {
            int num = item.count - item.temporary;
            if (num > 0)
            {
                clump.Add(item.RemoveStacks(num, removeTemporary: false));
            }
        }
        yield return clump.WaitForEnd();
        yield return CreateNewCards(1);
        Entity newCard = newCards[0];
        foreach (StatusEffectApply item2 in statusesToApply)
        {
            clump.Add(StatusEffectSystem.Apply(newCard, item2.applier, item2.effectData, item2.count, temporary: false, null, fireEvents: false));
            clump.Add(StatusEffectSystem.Apply(target, item2.applier, item2.effectData, item2.count, temporary: false, null, fireEvents: false));
        }
        yield return clump.WaitForEnd();
        if (ShoveSystem.CanShove(target, target.owner.entity, out var shoveData))
        {
            CardContainer toContainer = target.actualContainers[0];
            yield return ShoveSystem.DoShove(shoveData, updatePositions: true);
            toContainer.Add(newCard);
            Transform transform = newCard.transform;
            Vector3 containerWorldPosition = newCard.GetContainerWorldPosition();
            transform.position = containerWorldPosition;
            newCard.wobbler.WobbleRandom();
            target.wobbler.WobbleRandom();
        }
        yield return EnableCards(newCards);
    }

    public IEnumerator SplitDoubleHeight()
    {
        target.hp.current = Mathf.CeilToInt((float)target.hp.current * 0.5f);
        target.hp.max = target.hp.current;
        target.data.value = Mathf.CeilToInt((float)target.data.value * 0.5f);
        yield return CreateNewCards(2);
        List<StatusEffectData> list = target.statusEffects.Where((StatusEffectData e) => e.count > e.temporary && e.isStatus).ToList();
        Routine.Clump clump = new Routine.Clump();
        foreach (StatusEffectData item in list)
        {
            int num = Mathf.CeilToInt((float)(item.count - item.temporary) * 0.5f);
            foreach (Entity newCard in newCards)
            {
                clump.Add(StatusEffectSystem.Apply(newCard, item.applier, item, num, temporary: false, null, fireEvents: false));
            }
        }
        yield return clump.WaitForEnd();
        Vector3 position = target.transform.position;
        for (int i = 0; i < newCards.Count; i++)
        {
            Entity entity = newCards[i];
            target.actualContainers[i % target.actualContainers.Count].Add(entity);
            Transform transform = entity.transform;
            Vector3 containerWorldPosition = entity.GetContainerWorldPosition();
            transform.position = Vector3.Lerp(position, containerWorldPosition, 0.1f);
            LeanTween.move(((Component)entity).gameObject, containerWorldPosition, PettyRandom.Range(0.8f, 1.2f)).setEaseOutElastic();
            entity.wobbler.WobbleRandom();
        }
        PlayAction[] actions = ActionQueue.GetActions();
        foreach (PlayAction obj in actions)
        {
            if (obj is ActionTriggerAgainst actionTriggerAgainst)
            {
                int[] rows = References.Battle.GetRowIndices(actionTriggerAgainst.entity);
                Entity[] array = newCards.Where((Entity a) => IListExt.ContainsAny<int>((IList<int>)References.Battle.GetRowIndices(a), (IEnumerable<int>)rows)).ToArray();
                actionTriggerAgainst.target = ((array.Length != 0) ? IArrayExt.RandomItem<Entity>(array) : IListExt.RandomItem<Entity>((IList<Entity>)newCards));
            }
        }
        target.RemoveFromContainers();
        CardManager.ReturnToPool(target);
        yield return EnableCards(newCards);
    }

    public IEnumerator EnableCards(IEnumerable<Entity> cards)
    {
        MinibossIntroSystem minibossIntroSystem = Object.FindObjectOfType<MinibossIntroSystem>();
        foreach (Entity card in cards)
        {
            if ((minibossIntroSystem))
            {
                minibossIntroSystem.Ignore(card);
            }
            CardContainer[] toContainers = card.actualContainers.ToArray();
            ((Behaviour)card).enabled = true;
            card.RemoveFromContainers();
            card.owner.reserveContainer.Add(card);
            yield return new ActionMove(card, toContainers).Run();
            ActionQueue.Stack(new ActionRunEnableEvent(card)
            {
                priority = eventPriority
            }, fixedPosition: true);
        }
    }

    public IEnumerator CreateNewCards(int count)
    {
        CardController controller = target.display.hover.controller;
        Character owner = target.owner;
        Routine.Clump clump = new Routine.Clump();
        for (int i = 0; i < count; i++)
        {
            CardData cardData = target.data;
            Profile[] array = profiles;
            for (int j = 0; j < array.Length; j++)
            {
                Profile profile = array[j];
                if (profile.cardName == (cardData).name)
                {
                    cardData = AddressableLoader.Get<CardData>("CardData", profile.changeToCardName);
                    break;
                }
            }
            clump.Add(CreateCard(target.data, cardData, controller, owner, delegate (Card c)
            {
                newCards.Add(c.entity);
            }));
        }
        yield return clump.WaitForEnd();
        foreach (Entity newCard in newCards)
        {
            clump.Add(CopyEntity(newCard, target));
        }
        yield return clump.WaitForEnd();
    }

    public static IEnumerator CreateCard(CardData original, CardData cardData, CardController controller, Character owner, UnityAction<Card> onComplete)
    {
        CardData cardData2 = cardData.Clone();
        original.TryGetCustomData("splitOriginalId", out var value, original.id);
        cardData2.SetCustomData("splitOriginalId", value);
        Card card = CardManager.Get(cardData2, controller, owner, inPlay: true, owner.team == References.Player.team);
        card.entity.startingEffectsApplied = true;
        onComplete?.Invoke(card);
        yield return card.UpdateData();
    }

    public IEnumerator CopyEntity(Entity entity, Entity toCopy)
    {
        List<StatusEffectData> list = toCopy.statusEffects.Where((StatusEffectData e) => e.count > e.temporary && e.HasDescOrIsKeyword && e != this).ToList();
        foreach (StatusEffectData item in list)
        {
            yield return StatusEffectSystem.Apply(entity, item.applier, item, item.count - item.temporary, temporary: false, null, fireEvents: false);
        }
        foreach (Entity.TraitStacks trait in toCopy.traits)
        {
            int num = trait.count - trait.tempCount;
            if (num > 0)
            {
                entity.GainTrait(trait.data, num);
            }
        }
        entity.attackEffects = (from a in CardData.StatusEffectStacks.Stack(entity.attackEffects, toCopy.attackEffects)
                                select a.Clone()).ToList();
        entity.hp = toCopy.hp;
        entity.damage = toCopy.damage;
        entity.counter = toCopy.counter;
        if (entity.counter.current <= 0)
        {
            entity.counter.Max();
        }
        entity.uses = toCopy.uses;
        entity.display.promptUpdateDescription = true;
        entity.ResetWhenHealthLostEffects();
        entity.PromptUpdate();
        yield return entity.UpdateTraits();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Summon", fileName = "Summon X")]
public class StatusEffectInstantSummon : StatusEffectInstant
{
    public enum Position
    {
        InFrontOf,
        EnemyRow,
        Hand,
        AppliersPosition,
        InFrontOfOrOtherRow
    }

    [SerializeField]
    public bool canSummonMultiple;

    public StatusEffectSummon targetSummon;

    [SerializeField]
    public bool summonCopy;

    [SerializeField]
    public Position summonPosition;

    [SerializeField]
    public StatusEffectData[] withEffects;

    [SerializeField]
    public bool queue = true;

    public bool buildingToSummon;

    public Entity toSummon;

    public override IEnumerator Process()
    {
        if (canSummonMultiple)
        {
            Routine.Clump clump = new Routine.Clump();
            int amount = GetAmount();
            for (int i = 0; i < amount; i++)
            {
                if (summonCopy)
                {
                    clump.Add(CreateCopyAndTrySummon());
                }
                else
                {
                    clump.Add(TrySummon());
                }
            }
            yield return clump.WaitForEnd();
        }
        else if (queue)
        {
            if (summonCopy)
            {
                new Routine(CreateCopy(target, delegate (Entity e)
                {
                    toSummon = e;
                }));
            }
            ActionQueue.Stack(new ActionSequence(TrySummon())
            {
                note = "Instant Summon"
            }, fixedPosition: true);
        }
        else
        {
            yield return TrySummon();
        }
        yield return base.Process();
    }

    public IEnumerator CreateCopy(Entity toCopy, UnityAction<Entity> onComplete)
    {
        buildingToSummon = true;
        Card card = null;
        if (CanSummon(out var container, out var _))
        {
            card = targetSummon.CreateCardCopy(target.data, container, applier.display.hover.controller);
            card.entity.startingEffectsApplied = true;
            yield return card.UpdateData();
            yield return targetSummon.CopyStatsAndEffects(card.entity, toCopy);
        }
        buildingToSummon = false;
        onComplete?.Invoke((card) ? card.entity : null);
    }

    public IEnumerator CreateCopyAndTrySummon()
    {
        yield return CreateCopy(target, delegate (Entity e)
        {
            toSummon = e;
        });
        if ((toSummon))
        {
            yield return TrySummon();
        }
    }

    public IEnumerator TrySummon()
    {
        if (buildingToSummon)
        {
            yield return (object)new WaitUntil((Func<bool>)(() => (toSummon)));
        }
        if (CanSummon(out var container, out var shoveData))
        {
            if (shoveData != null)
            {
                yield return ShoveSystem.DoShove(shoveData, updatePositions: true);
            }
            int amount = GetAmount();
            yield return (toSummon) ? targetSummon.SummonPreMade(toSummon, container, applier.display.hover.controller, applier, withEffects, amount) : (summonCopy ? targetSummon.SummonCopy(target, container, applier.display.hover.controller, applier, withEffects, amount) : targetSummon.Summon(container, applier.display.hover.controller, applier, withEffects, amount));
        }
        else if (NoTargetTextSystem.Exists())
        {
            if ((toSummon))
            {
                toSummon.RemoveFromContainers();
                Object.Destroy(toSummon);
            }
            yield return NoTargetTextSystem.Run(target, NoTargetType.NoSpaceToSummon);
        }
        yield return null;
    }

    public static IEnumerator ApplyEffects(Entity applier, Entity entity, IEnumerable<StatusEffectData> effects, int count)
    {
        Hit hit = new Hit(applier, entity, 0)
        {
            countsAsHit = false,
            canRetaliate = false
        };
        foreach (StatusEffectData effect in effects)
        {
            hit.AddStatusEffect(effect, count);
        }
        yield return hit.Process();
    }

    public bool CanSummon(out CardContainer container, out Dictionary<Entity, List<CardSlot>> shoveData)
    {
        bool result = false;
        container = null;
        shoveData = null;
        switch (summonPosition)
        {
            case Position.InFrontOf:
                result = CanSummonInFrontOf(target, out container, out shoveData);
                break;
            case Position.EnemyRow:
                result = CanSummonInEnemyRow(target, out container, out shoveData);
                break;
            case Position.Hand:
                container = References.Player.handContainer;
                result = true;
                break;
            case Position.AppliersPosition:
                result = CanSummonInFrontOf(applier, out container, out shoveData);
                break;
            case Position.InFrontOfOrOtherRow:
                if (CanSummonInFrontOf(target, out container, out shoveData))
                {
                    result = container.owner.team == applier.owner.team || CanSummonInEnemyRow(target, out container, out shoveData);
                }
                break;
        }
        return result;
    }

    public static bool CanSummonInFrontOf(Entity inFrontOf, out CardContainer container, out Dictionary<Entity, List<CardSlot>> shoveData)
    {
        bool flag = false;
        container = null;
        shoveData = null;
        bool flag2 = Battle.IsOnBoard(inFrontOf);
        if (!inFrontOf.alive || !flag2)
        {
            if (inFrontOf.actualContainers.Count > 0)
            {
                container = IListExt.RandomItem<CardContainer>((IList<CardContainer>)inFrontOf.actualContainers);
                flag = true;
            }
            else if (inFrontOf.preActualContainers.Length != 0)
            {
                container = IArrayExt.RandomItem<CardContainer>(inFrontOf.preActualContainers);
                flag = true;
            }
        }
        if (!flag && flag2)
        {
            CardContainer slotToShove = GetSlotToShove(inFrontOf);
            if (slotToShove != null)
            {
                Entity top = slotToShove.GetTop();
                if (!(top) || ShoveSystem.CanShove(top, top.owner.entity, out shoveData))
                {
                    container = slotToShove;
                    flag = true;
                }
            }
        }
        return flag;
    }

    public static CardContainer GetSlotToShove(Entity entity)
    {
        if (entity.actualContainers.Count <= 0)
        {
            if (entity.preActualContainers.Length == 0)
            {
                return null;
            }
            return IArrayExt.RandomItem<CardContainer>(entity.preActualContainers);
        }
        return IListExt.RandomItem<CardContainer>((IList<CardContainer>)entity.actualContainers);
    }

    public static bool CanSummonInEnemyRow(Entity target, out CardContainer container, out Dictionary<Entity, List<CardSlot>> shoveData)
    {
        bool result = false;
        container = null;
        shoveData = null;
        CardContainer[] array = target.containers;
        if (array == null || array.Length == 0)
        {
            array = target.preContainers;
        }
        if (array != null && array.Length != 0)
        {
            IListExt.Shuffle<CardContainer>((IList<CardContainer>)array);
            CardContainer[] array2 = array;
            for (int i = 0; i < array2.Length; i++)
            {
                if (!(array2[i] is CardSlotLane row))
                {
                    continue;
                }
                CardSlotLane oppositeRow = References.Battle.GetOppositeRow(row);
                if (oppositeRow != null)
                {
                    CardSlot cardSlot = oppositeRow.slots[0];
                    Entity top = cardSlot.GetTop();
                    if (top == null || ShoveSystem.CanShove(top, target.owner.entity, out shoveData))
                    {
                        container = cardSlot;
                        result = true;
                        break;
                    }
                }
            }
        }
        return result;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Take Attack", fileName = "Take Attack")]
public class StatusEffectInstantTakeAttack : StatusEffectInstant
{
    [SerializeField]
    public StatusEffectData increaseAttackEffect;

    public override IEnumerator Process()
    {
        int amount = GetAmount();
        target.damage.max -= amount;
        target.damage.current -= amount;
        target.PromptUpdate();
        Hit hit = new Hit(target, applier, 0)
        {
            canRetaliate = false,
            countsAsHit = false
        };
        hit.AddStatusEffect(increaseAttackEffect, amount);
        yield return hit.Process();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Take Health", fileName = "Take Health")]
public class StatusEffectInstantTakeHealth : StatusEffectInstant
{
    [SerializeField]
    public StatusEffectData increaseHealthEffect;

    public override IEnumerator Process()
    {
        int amount = GetAmount();
        int num = Mathf.Min(target.hp.current, amount);
        target.hp.max -= amount;
        target.hp.current -= amount;
        target.PromptUpdate();
        Hit hit = new Hit(target, applier, 0)
        {
            canRetaliate = false,
            countsAsHit = false
        };
        hit.AddStatusEffect(increaseHealthEffect, num);
        yield return hit.Process();
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Trigger", fileName = "Trigger")]
public class StatusEffectInstantTrigger : StatusEffectInstant
{
    [SerializeField]
    public bool againstRandomEnemy;

    [SerializeField]
    public bool reduceUses;

    [SerializeField]
    public int priority = -1;

    public override IEnumerator Process()
    {
        if (againstRandomEnemy && target.NeedsTarget)
        {
            List<Entity> allEnemies = target.GetAllEnemies();
            if (allEnemies.Count > 0)
            {
                Entity entity = IListExt.RandomItem<Entity>((IList<Entity>)allEnemies);
                CardContainer targetContainer = IArrayExt.RandomItem<CardContainer>(entity.containers);
                ActionQueue.Stack(new ActionTriggerAgainst(target, applier, entity, targetContainer), fixedPosition: true);
            }
        }
        else
        {
            ActionQueue.Stack(new ActionTrigger(target, applier)
            {
                priority = priority
            }, fixedPosition: true);
        }
        if (reduceUses)
        {
            ActionQueue.Add(new ActionReduceUses(target));
        }
        yield return base.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Instant/Trigger Against", fileName = "TriggerAgainst")]
public class StatusEffectInstantTriggerAgainst : StatusEffectInstant
{
    [SerializeField]
    public bool countsAsTrigger = true;

    [SerializeField]
    public string triggerType = "basic";

    [SerializeField]
    public bool reduceUses;

    public override IEnumerator Process()
    {
        if (applier.IsAliveAndExists() && target.IsAliveAndExists())
        {
            ActionQueue.Stack(new ActionTriggerAgainst(applier, target, target, target.containers[0])
            {
                countsAsTrigger = countsAsTrigger
            }, fixedPosition: true);
            if (reduceUses)
            {
                ActionQueue.Add(new ActionReduceUses(applier));
            }
            yield return base.Process();
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Misc/Last Stand", fileName = "Last Stand")]
public class StatusEffectLastStand : StatusEffectData
{
    public bool activated;

    public override bool RunPostHitEvent(Hit hit)
    {
        if (!activated && hit.target == target && target.hp.current <= 0 && hit.attacker.owner.team != target.owner.team && Battle.IsOnBoard(hit.attacker))
        {
            Activate(hit);
        }
        return false;
    }

    public void Activate(Hit hit)
    {
        LastStandSystem.target = this;
        LastStandSystem.subject = target;
        LastStandSystem.attacker = hit.attacker;
        LastStandSystem.previousPhase = References.Battle.phase;
        Disable();
        References.Battle.phase = Battle.Phase.LastStand;
    }

    public void Disable()
    {
        activated = true;
    }

    public void ReEnable()
    {
        target.hp.current = 1;
        target.PromptUpdate();
        activated = false;
        preventDeath = true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Misc/Next Phase", fileName = "Next Phase")]
public class StatusEffectNextPhase : StatusEffectData
{
    [SerializeField]
    public CardData nextPhase;

    [SerializeField]
    public CardData[] splitOptions;

    [SerializeField]
    public int splitCount;

    [SerializeField]
    public CardAnimation animation;

    public bool goToNextPhase;

    public bool activated;

    public override void Init()
    {
        Events.OnEntityDisplayUpdated += EntityDisplayUpdated;
    }

    public void OnDestroy()
    {
        Events.OnEntityDisplayUpdated -= EntityDisplayUpdated;
    }

    public void EntityDisplayUpdated(Entity entity)
    {
        if (!activated && target.hp.current <= 0 && entity == target)
        {
            TryActivate();
        }
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        if (!activated && hit.target == target && target.hp.current <= 0)
        {
            TryActivate();
        }
        return false;
    }

    public void TryActivate()
    {
        bool flag = true;
        foreach (StatusEffectData statusEffect in target.statusEffects)
        {
            if (statusEffect != this && statusEffect.preventDeath)
            {
                flag = false;
                break;
            }
        }
        if (!flag)
        {
            return;
        }
        activated = true;
        Object.FindObjectOfType<ChangePhaseAnimationSystem>()?.Flash();
        if ((nextPhase))
        {
            ActionQueue.Stack(new ActionChangePhase(target, nextPhase.Clone(), animation)
            {
                priority = 10
            }, fixedPosition: true);
            return;
        }
        if (splitCount > 0)
        {
            CardData[] array = splitOptions;
            if (array != null && array.Length > 0)
            {
                CardData[] newPhases = (from a in IArrayExt.RandomItems<CardData>(splitOptions, splitCount)
                                        select a.Clone()).ToArray();
                ActionQueue.Stack(new ActionChangePhase(target, newPhases, animation)
                {
                    priority = 10
                }, fixedPosition: true);
                return;
            }
        }
        throw new ArgumentException("Next phase not given!");
    }
}
public abstract class StatusEffectOngoing : StatusEffectData
{
    [InfoBox(/*Could not decode attribute arguments.*/)]
    [SerializeField]
    public bool reverse;

    public override bool HasStackRoutine => true;

    public override bool HasEndRoutine => true;

    public virtual IEnumerator Add(int add)
    {
        return null;
    }

    public virtual IEnumerator Remove(int remove)
    {
        return null;
    }

    public override IEnumerator StackRoutine(int stacks)
    {
        yield return Add(reverse ? (-stacks) : stacks);
    }

    public override IEnumerator RemoveStacks(int amount, bool removeTemporary)
    {
        int num = Mathf.Min(count, amount);
        yield return Remove(reverse ? (-num) : num);
        yield return base.RemoveStacks(amount, removeTemporary);
    }

    public override IEnumerator EndRoutine()
    {
        return Remove(reverse ? (-count) : count);
    }

    public StatusEffectOngoing()
    {
    }
}
[CreateAssetMenu(menuName = "Status Effects/Ongoing/Increase Attack", fileName = "Ongoing Increase Attack")]
public class StatusEffectOngoingAttack : StatusEffectOngoing
{
    public override IEnumerator Add(int add)
    {
        Entity entity = target;
        entity.tempDamage += add;
        target.PromptUpdate();
        yield break;
    }

    public override IEnumerator Remove(int remove)
    {
        Entity entity = target;
        entity.tempDamage -= remove;
        target.PromptUpdate();
        yield break;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Ongoing/Increase Effects", fileName = "Ongoing Increase Effects")]
public class StatusEffectOngoingEffects : StatusEffectOngoing
{
    [SerializeField]
    public bool add = true;

    [SerializeField]
    [HideIf("add")]
    public bool multiply;

    public override IEnumerator Add(int add)
    {
        if (this.add)
        {
            target.effectBonus += add;
        }
        else if (multiply)
        {
            target.effectFactor += add;
        }
        target.PromptUpdate();
        yield return Sequences.Null();
    }

    public override IEnumerator Remove(int remove)
    {
        if (add)
        {
            target.effectBonus -= remove;
        }
        else if (multiply)
        {
            target.effectFactor -= remove;
        }
        target.PromptUpdate();
        yield return Sequences.Null();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Ongoing/Increase Max Counter", fileName = "Ongoing Increase Max Counter")]
public class StatusEffectOngoingMaxCounter : StatusEffectOngoing
{
    public override IEnumerator Add(int add)
    {
        target.counter.current = Mathf.Max(0, target.counter.current + add);
        target.counter.max = Mathf.Max(1, target.counter.max + add);
        target.PromptUpdate();
        yield return Sequences.Null();
    }

    public override IEnumerator Remove(int remove)
    {
        target.counter.current = Mathf.Max(0, target.counter.current - remove);
        target.counter.max = Mathf.Max(1, target.counter.max - remove);
        target.PromptUpdate();
        yield return Sequences.Null();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Ongoing/Increase Max Health", fileName = "Ongoing Increase Max Health")]
public class StatusEffectOngoingMaxHealth : StatusEffectOngoing
{
    public override IEnumerator Add(int add)
    {
        target.hp.max += add;
        target.hp.current += add;
        target.PromptUpdate();
        yield return Sequences.Null();
    }

    public override IEnumerator Remove(int remove)
    {
        target.hp.max -= remove;
        target.hp.current -= remove;
        target.PromptUpdate();
        yield return Sequences.Null();
    }
}
public class StatusEffectReaction : StatusEffectData
{
    public override bool CanTrigger()
    {
        if (base.CanTrigger())
        {
            return target.alive;
        }
        return false;
    }

    public bool PlayedInThisRow(Entity entity, Entity[] targets)
    {
        bool result = false;
        int[] rowIndices = Battle.instance.GetRowIndices(target);
        foreach (Entity entity2 in targets)
        {
            int[] rowIndices2 = Battle.instance.GetRowIndices(entity2);
            if (IListExt.ContainsAny<int>((IList<int>)rowIndices, (IEnumerable<int>)rowIndices2))
            {
                result = true;
                break;
            }
        }
        return result;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Reactions/Trigger Against Attacker When Hit", fileName = "Trigger Against Attacker When Hit")]
public class StatusEffectTriggerAgainstAttackerWhenHit : StatusEffectReaction
{
    public Entity attacker;

    public Entity previousTarget;

    public int? effectiveHealthState;

    public override bool RunTurnEndEvent(Entity entity)
    {
        if (effectiveHealthState.HasValue && entity == target)
        {
            previousTarget = null;
            effectiveHealthState = null;
        }
        return false;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.target == target && hit.canRetaliate && !(attacker) && hit.Offensive && hit.BasicHit && (hit.target) && (hit.attacker))
        {
            Trigger trigger = hit.trigger;
            if (trigger != null && trigger.countsAsTrigger)
            {
                attacker = hit.attacker;
            }
        }
        return false;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if ((attacker) && entity == attacker)
        {
            attacker = null;
            if (Battle.IsOnBoard(target) && CanTrigger())
            {
                Run(entity);
            }
        }
        return false;
    }

    public void Run(Entity entity)
    {
        if (!(entity.data) || !entity.data.cardType.unit)
        {
            Entity entity2 = entity.owner?.entity;
            if ((entity2) && entity2.canBeHit)
            {
                entity = entity.owner?.entity;
                if (entity == target.owner?.entity)
                {
                    entity = null;
                }
            }
        }
        if ((entity) && entity.canBeHit && entity.IsAliveAndExists())
        {
            int num = CalculateEffectiveHealthState();
            if (effectiveHealthState.HasValue && (previousTarget) && previousTarget == entity && num == effectiveHealthState.Value)
            {
                Debug.LogWarning("Smackback infinite loop detected!");
                return;
            }
            previousTarget = entity;
            effectiveHealthState = num;
            CardContainer targetRow = Trigger.GetTargetRow(target, entity);
            ActionQueue.Stack(new ActionTriggerSubsequent(target, entity, entity, targetRow)
            {
                triggerType = "smackback"
            }, fixedPosition: true);
        }
    }

    public static int CalculateEffectiveHealthState()
    {
        int num = 0;
        foreach (Entity item in Battle.GetCardsOnBoard())
        {
            num += GetEffectiveHealth(item);
        }
        return num;
    }

    public static int GetEffectiveHealth(Entity entity)
    {
        int num = entity.hp.current;
        foreach (StatusEffectData statusEffect in entity.statusEffects)
        {
            switch (statusEffect.type)
            {
                case "shell":
                case "scrap":
                case "block":
                    num += statusEffect.count;
                    break;
                case "overload":
                    num -= statusEffect.count;
                    break;
                case "shroom":
                    num -= Mathf.Min(statusEffect.count, entity.hp.current);
                    break;
            }
        }
        return num;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Reactions/Trigger When Ally In Row Attacks", fileName = "Trigger When Ally In Row Attacks")]
public class StatusEffectTriggerWhenAllyAttacks : StatusEffectReaction
{
    [SerializeField]
    public bool allyInRow = true;

    [SerializeField]
    public bool againstTarget;

    public readonly HashSet<Entity> prime = new HashSet<Entity>();

    public override bool RunHitEvent(Hit hit)
    {
        if (((Behaviour)target).enabled && Battle.IsOnBoard(target) && hit.countsAsHit && hit.Offensive && (hit.target) && CheckEntity(hit.attacker))
        {
            prime.Add(hit.attacker);
        }
        return false;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (prime.Count > 0 && prime.Contains(entity) && targets != null && targets.Length > 0)
        {
            prime.Remove(entity);
            if (Battle.IsOnBoard(target) && CanTrigger())
            {
                Run(entity, targets);
            }
        }
        return false;
    }

    public void Run(Entity attacker, Entity[] targets)
    {
        if (againstTarget)
        {
            foreach (Entity entity in targets)
            {
                ActionQueue.Stack(new ActionTriggerAgainst(target, attacker, entity, null), fixedPosition: true);
            }
        }
        else
        {
            ActionQueue.Stack(new ActionTrigger(target, attacker), fixedPosition: true);
        }
    }

    public bool CheckEntity(Entity entity)
    {
        if ((entity) && entity.owner.team == target.owner.team && entity != target && CheckRow(entity) && Battle.IsOnBoard(entity) && CheckDuplicate(entity))
        {
            return CheckDuplicate(entity.triggeredBy);
        }
        return false;
    }

    public bool CheckRow(Entity entity)
    {
        if (allyInRow)
        {
            return IListExt.ContainsAny<CardContainer>((IList<CardContainer>)entity.containers, (IEnumerable<CardContainer>)target.containers);
        }
        return true;
    }

    public bool CheckDuplicate(Entity entity)
    {
        if (!entity.IsAliveAndExists())
        {
            return true;
        }
        foreach (StatusEffectData statusEffect in entity.statusEffects)
        {
            if ((statusEffect).name == name)
            {
                return false;
            }
        }
        return true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Reactions/Trigger When Card Type Used On Ally", fileName = "Trigger When Card Type Used On Ally")]
public class StatusEffectTriggerWhenCardTypeUsedOnAlly : StatusEffectReaction
{
    [SerializeField]
    public bool includeSelf;

    [SerializeField]
    public string[] cardTypeTriggers;

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (CheckCardType(entity) && CheckTargets(targets) && Battle.IsOnBoard(target) && CanTrigger())
        {
            ActionQueue.Stack(new ActionTrigger(target, entity), fixedPosition: true);
        }
        return false;
    }

    public bool CheckCardType(Entity entity)
    {
        bool result = false;
        string text = entity.data?.cardType?.tag;
        if (text != null)
        {
            string[] array = cardTypeTriggers;
            foreach (string value in array)
            {
                if (text.Equals(value))
                {
                    result = true;
                    break;
                }
            }
        }
        return result;
    }

    public bool CheckTargets(Entity[] targets)
    {
        bool result = false;
        foreach (Entity entity in targets)
        {
            if (entity.owner == target.owner && (entity != target || includeSelf))
            {
                result = true;
                break;
            }
        }
        return result;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Reactions/Trigger When Status Applied", fileName = "Trigger When Status Applied")]
public class StatusEffectTriggerWhenStatusApplied : StatusEffectReaction
{
    public enum TriggerType
    {
        Normal,
        Target,
        Applier
    }

    [SerializeField]
    public StatusEffectData targetStatus;

    [SerializeField]
    public bool friendlyFire = true;

    [SerializeField]
    public bool selfFire = true;

    [SerializeField]
    public TriggerType triggerType;

    public int busy;

    public int triggerIndex;

    public override void Init()
    {
        base.PostApplyStatus += Run;
    }

    public override bool RunPostApplyStatusEvent(StatusEffectApply apply)
    {
        if (((Behaviour)target).enabled && Battle.IsOnBoard(target) && Check(apply))
        {
            return CanTrigger();
        }
        return false;
    }

    public IEnumerator Run(StatusEffectApply apply)
    {
        int i = triggerIndex + busy;
        busy++;
        yield return (object)new WaitUntil((Func<bool>)(() => triggerIndex == i));
        switch (triggerType)
        {
            case TriggerType.Normal:
                ActionQueue.Stack(new ActionTrigger(target, apply.applier), fixedPosition: true);
                break;
            case TriggerType.Target:
                if ((apply.target) && apply.target.alive)
                {
                    CardContainer targetRow2 = Trigger.GetTargetRow(target, apply.target);
                    ActionQueue.Stack(new ActionTriggerSubsequent(target, apply.applier, apply.target, targetRow2), fixedPosition: true);
                }
                break;
            case TriggerType.Applier:
                if ((apply.applier) && apply.applier.alive)
                {
                    CardContainer targetRow = Trigger.GetTargetRow(target, apply.target);
                    ActionQueue.Stack(new ActionTriggerSubsequent(target, apply.applier, apply.applier, targetRow), fixedPosition: true);
                }
                break;
        }
        busy--;
        triggerIndex++;
    }

    public bool Check(StatusEffectApply apply)
    {
        if ((!friendlyFire && apply.applier?.owner == target.owner) || (!selfFire && apply.applier == target))
        {
            return false;
        }
        if (apply.effectData?.type == targetStatus?.type && CheckDuplicate(apply.applier))
        {
            return CheckDuplicate(apply.applier.triggeredBy);
        }
        return false;
    }

    public bool CheckDuplicate(Entity entity)
    {
        if (!(entity))
        {
            return true;
        }
        foreach (StatusEffectData statusEffect in entity.statusEffects)
        {
            if ((statusEffect).name == name)
            {
                return false;
            }
        }
        return true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Reactions/While Active Apply X To Each Card Played", fileName = "While Active Apply X To Each Card Played")]
public class StatusEffectWhileActiveApplyXToEachCardPlayed : StatusEffectReaction
{
    [SerializeField]
    public StatusEffectData effectToApply;

    public override void Init()
    {
        base.PreCardPlayed += Activate;
    }

    public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (CheckEntity(entity) && CanTrigger())
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator Activate(Entity entity, Entity[] targets)
    {
        yield return Run(entity);
    }

    public IEnumerator Run(Entity entity)
    {
        Hit hit = new Hit(target, entity, 0);
        hit.AddStatusEffect(effectToApply, GetAmount());
        Routine.Clump clump = new Routine.Clump();
        clump.Add(hit.Process());
        target.curveAnimator?.Ping();
        clump.Add(Sequences.Wait(0.3f));
        yield return clump.WaitForEnd();
    }

    public bool CheckEntity(Entity entity)
    {
        if (entity.owner == target.owner && entity.owner != null && entity.data != null)
        {
            return entity.data.cardType.item;
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Affect All X Applied", fileName = "Affect All X Applied")]
public class StatusEffectAffectAllXApplied : StatusEffectData
{
    [SerializeField]
    public StatusEffectData effectToAffect;

    [SerializeField]
    public bool setToSpecificValue;

    [SerializeField]
    [ShowIf("setToSpecificValue")]
    public int specificValue;

    [SerializeField]
    [HideIf("setToSpecificValue")]
    public int add;

    [SerializeField]
    [HideIf("setToSpecificValue")]
    public float multiplyBy = 2f;

    [SerializeField]
    public bool targetCanBeFriendly = true;

    [SerializeField]
    public bool targetCanBeEnemy = true;

    [SerializeField]
    public bool applierCanBeFriendly = true;

    [SerializeField]
    public bool applierCanBeEnemy = true;

    public override bool RunApplyStatusEvent(StatusEffectApply apply)
    {
        if (apply?.effectData != null && apply.effectData.type == effectToAffect.type && apply.count > 0 && CheckTeamOfTarget(apply.target) && CheckTeamOfApplier(apply.applier))
        {
            if (setToSpecificValue)
            {
                apply.count = specificValue;
            }
            else
            {
                apply.count += add * GetAmount();
                apply.count = Mathf.CeilToInt((float)apply.count * multiplyBy);
            }
        }
        return false;
    }

    public bool CheckTeamOfTarget(Entity target)
    {
        if (!targetCanBeFriendly || !(target.owner == base.target.owner))
        {
            if (targetCanBeEnemy)
            {
                return target.owner != base.target.owner;
            }
            return false;
        }
        return true;
    }

    public bool CheckTeamOfApplier(Entity applier)
    {
        if (!applierCanBeFriendly || !(applier.owner == target.owner))
        {
            if (applierCanBeEnemy)
            {
                return applier.owner != target.owner;
            }
            return false;
        }
        return true;
    }
}
public abstract class StatusEffectApplyX : StatusEffectData
{
    [Flags]
    public enum ApplyToFlags
    {
        None = 0,
        Self = 1,
        Hand = 2,
        EnemyHand = 4,
        Allies = 8,
        AlliesInRow = 0x10,
        FrontAlly = 0x20,
        BackAlly = 0x40,
        AllyInFrontOf = 0x80,
        AllyBehind = 0x100,
        Enemies = 0x200,
        EnemiesInRow = 0x400,
        FrontEnemy = 0x800,
        Attacker = 0x1000,
        Target = 0x2000,
        RandomAlly = 0x4000,
        RandomEnemy = 0x8000,
        RandomUnit = 0x10000,
        Applier = 0x20000,
        RightCardInHand = 0x40000,
        RandomCardInHand = 0x80000,
        RandomAllyInRow = 0x100000,
        RandomEnemyInRow = 0x200000
    }

    [Header("Status Effect To Apply")]
    public bool dealDamage;

    [HideIf("dealDamage")]
    public StatusEffectData effectToApply;

    [SerializeField]
    public SelectScript<Entity> selectScript;

    public TargetConstraint[] applyConstraints;

    public bool applyEqualAmount;

    [ShowIf("applyEqualAmount")]
    [SerializeField]
    public ScriptableAmount contextEqualAmount;

    [ShowIf("applyEqualAmount")]
    [SerializeField]
    public float equalAmountBonusMult;

    [HideIf("applyEqualAmount")]
    [SerializeField]
    public ScriptableAmount scriptableAmount;

    [Header("Who/What To Apply To")]
    public ApplyToFlags applyToFlags;

    public bool applyInReverseOrder;

    public bool canRetaliate;

    public bool countsAsHit;

    public bool waitForAnimationEnd;

    public bool waitForApplyToAnimationEnd;

    public bool queue;

    public bool separateActions;

    public bool doPing = true;

    public bool targetMustBeAlive = true;

    public float pauseAfter;

    [SerializeField]
    public NoTargetType noTargetType;

    [SerializeField]
    public string[] noTargetTypeArgs;

    public ActionEffectApply action;

    public override bool CanTrigger()
    {
        if (!base.CanTrigger() || !dealDamage)
        {
            return (effectToApply);
        }
        return true;
    }

    public virtual int GetAmount(Entity entity, bool equalAmount = false, int equalTo = 0)
    {
        if ((target) && !TargetSilenced())
        {
            if (!(scriptableAmount))
            {
                if (!equalAmount)
                {
                    return GetAmount();
                }
                return equalTo;
            }
            return scriptableAmount.Get(entity);
        }
        return 0;
    }

    public virtual bool TargetSilenced()
    {
        return target.silenced;
    }

    public bool AppliesTo(ApplyToFlags applyTo)
    {
        return (applyToFlags & applyTo) != 0;
    }

    public IEnumerator Run(List<Entity> targets, int amount = 0)
    {
        if (!(target) || !CanTrigger())
        {
            yield break;
        }
        for (int num = targets.Count - 1; num >= 0; num--)
        {
            Entity entity = targets[num];
            if (!CanAffect(entity))
            {
                targets.RemoveAt(num);
            }
        }
        TargetConstraint[] array = applyConstraints;
        foreach (TargetConstraint targetConstraint in array)
        {
            for (int num2 = targets.Count - 1; num2 >= 0; num2--)
            {
                Entity entity2 = targets[num2];
                if (!targetConstraint.Check(entity2))
                {
                    targets.RemoveAt(num2);
                }
            }
        }
        if (targets.Count > 0)
        {
            int amount2 = GetAmount(target, applyEqualAmount, Mathf.RoundToInt((float)amount * (1f + equalAmountBonusMult)));
            if (TargetSilenced() || (amount2 <= 0 && !CheckMultipleEffectsForUnboostable()))
            {
                yield break;
            }
            if (queue && target.IsAliveAndExists())
            {
                bool flag = false;
                if (effectToApply.CanStackActions)
                {
                    ActionEffectApply actionEffectApply = action;
                    if (actionEffectApply != null && !actionEffectApply.running)
                    {
                        action.Stack(targets, amount2);
                        flag = true;
                    }
                }
                if (!flag)
                {
                    action = new ActionEffectApply(this, targets, amount2)
                    {
                        note = name
                    };
                    ActionQueue.Stack(action, fixedPosition: true);
                }
            }
            else
            {
                yield return Sequence(targets, amount2);
            }
        }
        else if (noTargetType != 0 && NoTargetTextSystem.Exists())
        {
            Entity entity3 = target;
            NoTargetType num3 = noTargetType;
            object[] args = noTargetTypeArgs;
            yield return NoTargetTextSystem.Run(entity3, num3, args);
        }
    }

    public bool CheckMultipleEffectsForUnboostable()
    {
        if (effectToApply is StatusEffectInstantMultiple { effects: var effects })
        {
            for (int i = 0; i < effects.Length; i++)
            {
                if (!effects[i].canBeBoosted)
                {
                    return true;
                }
            }
        }
        return false;
    }

    public IEnumerator Sequence(List<Entity> targets, int amount)
    {
        if (!(target) || (!target.alive && targetMustBeAlive))
        {
            yield break;
        }
        if (waitForAnimationEnd)
        {
            yield return Sequences.WaitForAnimationEnd(target);
        }
        if (waitForApplyToAnimationEnd)
        {
            foreach (Entity target in targets)
            {
                yield return Sequences.WaitForAnimationEnd(target);
            }
        }
        if ((selectScript))
        {
            targets = selectScript.Run(targets);
        }
        if (separateActions)
        {
            if (queue)
            {
                foreach (Entity item in targets.AsEnumerable().Reverse())
                {
                    ActionQueue.Stack(new ActionSequence(SequenceSingle(item, amount))
                    {
                        note = name + " - " + (item).name
                    });
                }
            }
            else
            {
                foreach (Entity item2 in targets.AsEnumerable())
                {
                    yield return SequenceSingle(item2, amount);
                }
            }
        }
        else
        {
            for (int num = targets.Count - 1; num >= 0; num--)
            {
                if (!(targets[num]) || !CheckConstraints(targets[num]))
                {
                    targets.RemoveAt(num);
                }
            }
            if (targets.Count > 0)
            {
                Routine.Clump clump = new Routine.Clump();
                if (doPing && (base.target) && (base.target.curveAnimator))
                {
                    base.target.curveAnimator.Ping();
                    clump.Add(Sequences.Wait(0.13f));
                }
                foreach (Entity item3 in targets.Where((Entity t) => (t)))
                {
                    int damage = (dealDamage ? amount : 0);
                    Hit hit = new Hit(base.target, item3, damage)
                    {
                        canRetaliate = canRetaliate,
                        countsAsHit = countsAsHit
                    };
                    if (!dealDamage)
                    {
                        hit.AddStatusEffect(effectToApply, amount);
                    }
                    clump.Add(hit.Process());
                }
                yield return clump.WaitForEnd();
            }
        }
        if (pauseAfter > 0f)
        {
            yield return Sequences.Wait(pauseAfter);
        }
    }

    public IEnumerator SequenceSingle(Entity t, int amount)
    {
        if ((t) && CheckConstraints(t))
        {
            Routine.Clump clump = new Routine.Clump();
            if (doPing && (target) && (target.curveAnimator))
            {
                target.curveAnimator.Ping();
                clump.Add(Sequences.Wait(0.13f));
            }
            Hit hit = new Hit(target, t, 0)
            {
                canRetaliate = canRetaliate,
                countsAsHit = countsAsHit
            };
            hit.AddStatusEffect(effectToApply, amount);
            clump.Add(hit.Process());
            yield return clump.WaitForEnd();
            if (waitForAnimationEnd)
            {
                yield return Sequences.WaitForAnimationEnd(target);
            }
        }
    }

    public List<Entity> GetTargets(Hit hit = null, CardContainer[] wasInRows = null, CardContainer[] wasInSlots = null, Entity[] targets = null)
    {
        List<Entity> list = new List<Entity>();
        if (AppliesTo(ApplyToFlags.Self) && CanAffect(target))
        {
            list.Add(target);
        }
        if (AppliesTo(ApplyToFlags.Hand))
        {
            CardContainer handContainer = References.Player.handContainer;
            if (handContainer != null && handContainer.Count > 0)
            {
                list.AddRange(References.Player.handContainer.Where((Entity card) => card != target && CheckConstraints(card)));
                goto IL_011f;
            }
        }
        if (AppliesTo(ApplyToFlags.RightCardInHand))
        {
            CardContainer handContainer = References.Player.handContainer;
            if (handContainer != null && handContainer.Count > 0)
            {
                list.Add(References.Player.handContainer[0]);
            }
        }
        if (AppliesTo(ApplyToFlags.RandomCardInHand))
        {
            CardContainer handContainer = References.Player.handContainer;
            if (handContainer != null && handContainer.Count > 0)
            {
                foreach (Entity item3 in IEnumerableExt.InRandomOrder<Entity>((IEnumerable<Entity>)References.Player.handContainer))
                {
                    if (item3 != target && CheckConstraints(item3))
                    {
                        list.Add(item3);
                        break;
                    }
                }
            }
        }
        goto IL_011f;
    IL_011f:
        AppliesTo(ApplyToFlags.EnemyHand);
        if (AppliesTo(ApplyToFlags.Allies))
        {
            list.AddRange(target.GetAllAllies());
        }
        else if (AppliesTo(ApplyToFlags.AlliesInRow))
        {
            if (Battle.IsOnBoard(target))
            {
                list.AddRange(target.GetAlliesInRow());
            }
            else if (wasInRows != null)
            {
                CardContainer[] array = wasInRows;
                foreach (CardContainer rowContainer in array)
                {
                    int rowIndex = References.Battle.GetRowIndex(rowContainer);
                    foreach (Entity item4 in target.GetAlliesInRow(rowIndex))
                    {
                        if (!list.Contains(item4))
                        {
                            list.Add(item4);
                        }
                    }
                }
            }
        }
        else
        {
            if (AppliesTo(ApplyToFlags.FrontAlly))
            {
                List<int> list2 = new List<int>();
                if (wasInRows != null)
                {
                    list2.AddRange(References.Battle.GetRowIndices(wasInRows));
                }
                else
                {
                    Entity entity = ((hit != null) ? hit.target : target);
                    CardContainer[] array = entity.containers;
                    list2.AddRange((array != null && array.Length > 0) ? References.Battle.GetRowIndices(entity.containers) : References.Battle.GetRowIndices(entity.preContainers));
                }
                foreach (CardContainer item5 in list2.Select((int i) => References.Battle.GetRow(target.owner, i)))
                {
                    foreach (Entity item6 in item5)
                    {
                        if ((item6))
                        {
                            list.Add(item6);
                            break;
                        }
                    }
                }
            }
            if (AppliesTo(ApplyToFlags.BackAlly))
            {
                List<int> list3 = new List<int>();
                if (wasInRows != null)
                {
                    list3.AddRange(References.Battle.GetRowIndices(wasInRows));
                }
                else if (hit != null)
                {
                    list3.AddRange(References.Battle.GetRowIndices(hit.target));
                }
                else
                {
                    list3.AddRange(References.Battle.GetRowIndices(target.containers));
                }
                foreach (CardContainer item7 in list3.Select((int i) => References.Battle.GetRow(target.owner, i)))
                {
                    for (int num = item7.Count - 1; num >= 0; num--)
                    {
                        Entity entity2 = item7[num];
                        if ((entity2))
                        {
                            list.Add(entity2);
                            break;
                        }
                    }
                }
            }
            if (AppliesTo(ApplyToFlags.AllyInFrontOf))
            {
                CardContainer[] array = wasInSlots ?? target.actualContainers.ToArray();
                foreach (CardContainer cardContainer in array)
                {
                    Entity entity3 = null;
                    if (cardContainer is CardSlot item && cardContainer.Group is CardSlotLane cardSlotLane)
                    {
                        for (int num2 = cardSlotLane.slots.IndexOf(item) - 1; num2 >= 0; num2--)
                        {
                            entity3 = cardSlotLane.slots[num2].GetTop();
                            if ((entity3))
                            {
                                break;
                            }
                        }
                    }
                    if ((entity3))
                    {
                        list.Add(entity3);
                        break;
                    }
                }
            }
            if (AppliesTo(ApplyToFlags.AllyBehind))
            {
                CardContainer[] array = wasInSlots ?? target.actualContainers.ToArray();
                foreach (CardContainer cardContainer2 in array)
                {
                    Entity entity4 = null;
                    if (cardContainer2 is CardSlot item2 && cardContainer2.Group is CardSlotLane cardSlotLane2)
                    {
                        for (int k = cardSlotLane2.slots.IndexOf(item2) + 1; k < cardSlotLane2.slots.Count; k++)
                        {
                            entity4 = cardSlotLane2.slots[k].GetTop();
                            if ((entity4))
                            {
                                break;
                            }
                        }
                    }
                    if ((entity4))
                    {
                        list.Add(entity4);
                        break;
                    }
                }
            }
        }
        if (AppliesTo(ApplyToFlags.Enemies))
        {
            list.AddRange(target.GetAllEnemies());
        }
        else if (AppliesTo(ApplyToFlags.EnemiesInRow))
        {
            CardContainer[] array = wasInRows ?? target.containers;
            foreach (CardContainer rowContainer2 in array)
            {
                int rowIndex2 = References.Battle.GetRowIndex(rowContainer2);
                List<Entity> enemiesInRow = target.GetEnemiesInRow(rowIndex2);
                if (enemiesInRow != null && enemiesInRow.Count > 0)
                {
                    list.AddRange(enemiesInRow);
                }
            }
        }
        else if (AppliesTo(ApplyToFlags.FrontEnemy))
        {
            CardContainer[] array = wasInRows ?? target.containers;
            foreach (CardContainer rowContainer3 in array)
            {
                int rowIndex3 = References.Battle.GetRowIndex(rowContainer3);
                List<Entity> enemiesInRow2 = target.GetEnemiesInRow(rowIndex3);
                if (enemiesInRow2 != null && enemiesInRow2.Count > 0)
                {
                    list.Add(enemiesInRow2[0]);
                }
            }
        }
        if (AppliesTo(ApplyToFlags.Applier) && (applier) && CanAffect(applier))
        {
            list.Add(applier);
        }
        if (AppliesTo(ApplyToFlags.Attacker))
        {
            hit ??= target.lastHit;
            if ((hit?.attacker) && CanAffect(hit.attacker))
            {
                list.Add(hit.attacker);
            }
        }
        if (AppliesTo(ApplyToFlags.Target))
        {
            if (targets != null)
            {
                list.AddRange(targets.Where(CanAffect));
            }
            else
            {
                hit ??= target.lastHit;
                if ((hit?.target) && CanAffect(hit.target))
                {
                    list.Add(hit.target);
                }
            }
        }
        if (AppliesTo(ApplyToFlags.RandomUnit))
        {
            List<Entity> cardsOnBoard = Battle.GetCardsOnBoard(target.owner);
            cardsOnBoard.AddRange(Battle.GetCardsOnBoard(Battle.GetOpponent(target.owner)));
            cardsOnBoard.Remove(target);
            RemoveIneligible(cardsOnBoard);
            if (cardsOnBoard.Count > 0)
            {
                list.Add(IListExt.RandomItem<Entity>((IList<Entity>)cardsOnBoard));
            }
        }
        if (AppliesTo(ApplyToFlags.RandomAlly))
        {
            List<Entity> cardsOnBoard2 = Battle.GetCardsOnBoard(target.owner);
            cardsOnBoard2.Remove(target);
            RemoveIneligible(cardsOnBoard2);
            if (cardsOnBoard2.Count > 0)
            {
                list.Add(IListExt.RandomItem<Entity>((IList<Entity>)cardsOnBoard2));
            }
        }
        if (AppliesTo(ApplyToFlags.RandomEnemy))
        {
            List<Entity> cardsOnBoard3 = Battle.GetCardsOnBoard(Battle.GetOpponent(target.owner));
            RemoveIneligible(cardsOnBoard3);
            if (cardsOnBoard3.Count > 0)
            {
                list.Add(IListExt.RandomItem<Entity>((IList<Entity>)cardsOnBoard3));
            }
        }
        if (AppliesTo(ApplyToFlags.RandomAllyInRow))
        {
            List<Entity> list4 = new List<Entity>();
            CardContainer[] array = wasInRows ?? target.containers;
            for (int j = 0; j < array.Length; j++)
            {
                foreach (Entity item8 in array[j])
                {
                    if (!list4.Contains(item8))
                    {
                        list4.Add(item8);
                    }
                }
            }
            RemoveIneligible(list4);
            if (list4.Count > 0)
            {
                list.Add(IListExt.RandomItem<Entity>((IList<Entity>)list4));
            }
        }
        if (AppliesTo(ApplyToFlags.RandomEnemyInRow))
        {
            List<Entity> list5 = new List<Entity>();
            CardContainer[] array = wasInRows ?? target.containers;
            foreach (CardContainer rowContainer4 in array)
            {
                int rowIndex4 = References.Battle.GetRowIndex(rowContainer4);
                foreach (Entity item9 in target.GetEnemiesInRow(rowIndex4))
                {
                    if (!list5.Contains(item9))
                    {
                        list5.Add(item9);
                    }
                }
            }
            RemoveIneligible(list5);
            if (list5.Count > 0)
            {
                list.Add(IListExt.RandomItem<Entity>((IList<Entity>)list5));
            }
        }
        if (applyInReverseOrder)
        {
            list.Reverse();
        }
        return list;
    }

    public void RemoveIneligible(IList<Entity> list)
    {
        for (int num = list.Count - 1; num >= 0; num--)
        {
            Entity entity = list[num];
            if (!CheckConstraints(entity))
            {
                list.RemoveAt(num);
            }
        }
    }

    public bool CanAffect(Entity entity)
    {
        if (!dealDamage)
        {
            return effectToApply.CanPlayOn(entity);
        }
        return entity.canBeHit;
    }

    public bool CheckConstraints(Entity entity)
    {
        if (CanAffect(entity))
        {
            return applyConstraints.All((TargetConstraint c) => c.Check(entity));
        }
        return false;
    }

    public StatusEffectApplyX()
    {
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X Every Turn", fileName = "Apply X Every Turn")]
public class StatusEffectApplyXEveryTurn : StatusEffectApplyX
{
    public enum Mode
    {
        AfterTurn,
        TurnStart
    }

    [SerializeField]
    public Mode mode;

    public override void Init()
    {
        base.OnTurn += CheckTurn;
        base.OnTurnStart += CheckTurnStart;
    }

    public override bool RunTurnEvent(Entity entity)
    {
        if (mode == Mode.AfterTurn && ((Behaviour)target).enabled && entity == target)
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator CheckTurn(Entity entity)
    {
        return Run(GetTargets());
    }

    public override bool RunTurnStartEvent(Entity entity)
    {
        if (mode == Mode.TurnStart && ((Behaviour)target).enabled && entity == target)
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator CheckTurnStart(Entity entity)
    {
        return Run(GetTargets());
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Instant Apply X", fileName = "Instant Apply X")]
public class StatusEffectApplyXInstant : StatusEffectApplyX
{
    public override bool Instant => true;

    public override int GetAmount(Entity entity, bool equalAmount = false, int equalTo = 0)
    {
        if (!(scriptableAmount))
        {
            if (!equalAmount)
            {
                return GetAmount();
            }
            return equalTo;
        }
        return scriptableAmount.Get(entity);
    }

    public override int GetAmount()
    {
        return count;
    }

    public override bool TargetSilenced()
    {
        return false;
    }

    public override void Init()
    {
        base.OnBegin += Process;
    }

    public IEnumerator Process()
    {
        yield return Run(GetTargets());
        yield return Remove();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X On Card Played", fileName = "Apply X On Card Played")]
public class StatusEffectApplyXOnCardPlayed : StatusEffectApplyX
{
    public override void Init()
    {
        base.OnCardPlayed += Check;
    }

    public static CardContainer[] GetWasInRows(Entity entity, IEnumerable<Entity> targets)
    {
        if (entity.data.playType == Card.PlayType.Play && entity.NeedsTarget)
        {
            HashSet<CardContainer> hashSet = new HashSet<CardContainer>();
            foreach (Entity target in targets)
            {
                if (target.containers != null && target.containers.Length != 0)
                {
                    HashSetExt.AddRange<CardContainer>(hashSet, (IEnumerable<CardContainer>)target.containers);
                }
                else
                {
                    HashSetExt.AddRange<CardContainer>(hashSet, (IEnumerable<CardContainer>)target.preContainers);
                }
            }
            return HashSetExt.ToArray<CardContainer>(hashSet);
        }
        return entity.containers;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (((Behaviour)target).enabled)
        {
            return entity == target;
        }
        return false;
    }

    public IEnumerator Check(Entity entity, Entity[] targets)
    {
        return Run(GetTargets(null, GetWasInRows(entity, targets), null, targets));
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X On Hit", fileName = "Apply X On Hit")]
public class StatusEffectApplyXOnHit : StatusEffectApplyX
{
    [SerializeField]
    public bool postHit;

    [Header("Modify Damage")]
    [SerializeField]
    public int addDamageFactor;

    [SerializeField]
    public float multiplyDamageFactor = 1f;

    public readonly List<Hit> storedHit = new List<Hit>();

    public override void Init()
    {
        if (postHit)
        {
            base.PostHit += CheckHit;
        }
        else
        {
            base.OnHit += CheckHit;
        }
    }

    public override bool RunPreAttackEvent(Hit hit)
    {
        if (hit.attacker == target && target.alive && ((Behaviour)target).enabled && (hit.target))
        {
            if (addDamageFactor != 0 || multiplyDamageFactor != 1f)
            {
                bool flag = true;
                TargetConstraint[] array = applyConstraints;
                foreach (TargetConstraint targetConstraint in array)
                {
                    if (!targetConstraint.Check(hit.target) && (!(targetConstraint is TargetConstraintHasStatus targetConstraintHasStatus) || !targetConstraintHasStatus.CheckWillApply(hit)))
                    {
                        flag = false;
                        break;
                    }
                }
                if (flag)
                {
                    int amount = GetAmount();
                    if (addDamageFactor != 0)
                    {
                        hit.damage += amount * addDamageFactor;
                    }
                    if (multiplyDamageFactor != 1f)
                    {
                        hit.damage = Mathf.RoundToInt((float)hit.damage * multiplyDamageFactor);
                    }
                }
            }
            if (!hit.Offensive && (hit.damage > 0 || ((effectToApply) && effectToApply.offensive)))
            {
                hit.FlagAsOffensive();
            }
            storedHit.Add(hit);
        }
        return false;
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        if (storedHit.Contains(hit))
        {
            return hit.Offensive;
        }
        return false;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (storedHit.Contains(hit))
        {
            return hit.Offensive;
        }
        return false;
    }

    public IEnumerator CheckHit(Hit hit)
    {
        if ((effectToApply))
        {
            yield return Run(GetTargets(hit), hit.damage + hit.damageBlocked);
        }
        storedHit.Remove(hit);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X On Kill", fileName = "Apply X On Kill")]
public class StatusEffectApplyXOnKill : StatusEffectApplyX
{
    public override void Init()
    {
        base.OnEntityDestroyed += CheckDestroy;
    }

    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        if (entity.lastHit != null)
        {
            return entity.lastHit.attacker == target;
        }
        return false;
    }

    public IEnumerator CheckDestroy(Entity entity, DeathType deathType)
    {
        return Run(GetTargets(entity.lastHit));
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X On Overheal", fileName = "Apply X On Overheal")]
public class StatusEffectApplyXOnOverheal : StatusEffectApplyX
{
    public override void Init()
    {
        base.OnHit += Check;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.target == target && hit.damage < 0)
        {
            return target.hp.current - hit.damage - target.hp.max > 0;
        }
        return false;
    }

    public IEnumerator Check(Hit hit)
    {
        return Run(GetTargets(hit), target.hp.current - hit.damage - target.hp.max);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X On Turn", fileName = "Apply X On Turn")]
public class StatusEffectApplyXOnTurn : StatusEffectApplyX
{
    [SerializeField]
    public bool trueOnTurn;

    public bool turnTaken;

    public override void Init()
    {
        base.OnCardPlayed += CheckCardPlay;
        base.OnTurn += CheckTurn;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (!turnTaken && ((Behaviour)target).enabled && entity == target && Battle.IsOnBoard(target))
        {
            if (trueOnTurn)
            {
                turnTaken = true;
                return false;
            }
            return true;
        }
        return false;
    }

    public IEnumerator CheckCardPlay(Entity entity, Entity[] targets)
    {
        return Run(GetTargets());
    }

    public override bool RunTurnEvent(Entity entity)
    {
        if (trueOnTurn && turnTaken && entity == target)
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator CheckTurn(Entity entity)
    {
        yield return Run(GetTargets());
        turnTaken = false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X Post Attack", fileName = "Apply X Post Attack")]
public class StatusEffectApplyXPostAttack : StatusEffectApplyX
{
    public override void Init()
    {
        base.PostAttack += CheckHit;
    }

    public override bool RunPostAttackEvent(Hit hit)
    {
        if (((Behaviour)target).enabled && hit.attacker == target && target.alive)
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator CheckHit(Hit hit)
    {
        yield return Run(GetTargets(hit));
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X Pre Trigger", fileName = "Apply X Pre Trigger")]
public class StatusEffectApplyXPreTrigger : StatusEffectApplyX
{
    [SerializeField]
    public bool mustHaveTarget;

    [SerializeField]
    public bool oncePerTurn = true;

    public bool running;

    public bool hasRunThisTurn;

    public List<Entity> runAgainst;

    public override void Init()
    {
        base.PreTrigger += EntityPreTrigger;
    }

    public override bool RunPreTriggerEvent(Trigger trigger)
    {
        return CheckTrigger(trigger);
    }

    public IEnumerator EntityPreTrigger(Trigger trigger)
    {
        if (oncePerTurn)
        {
            hasRunThisTurn = true;
        }
        running = true;
        yield return Run(runAgainst);
        runAgainst = null;
        running = false;
    }

    public bool CheckTrigger(Trigger trigger)
    {
        if (hasRunThisTurn || running || !((Behaviour)target).enabled || trigger.entity != target)
        {
            return false;
        }
        runAgainst = GetTargets();
        if (mustHaveTarget && (runAgainst == null || runAgainst.Count <= 0))
        {
            trigger.nullified = true;
            return false;
        }
        return true;
    }

    public override bool RunTurnEndEvent(Entity entity)
    {
        if (hasRunThisTurn && entity == target)
        {
            hasRunThisTurn = false;
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X Pre Turn", fileName = "Apply X Pre Turn")]
public class StatusEffectApplyXPreTurn : StatusEffectApplyX
{
    [SerializeField]
    public bool mustHaveTarget;

    public bool running;

    public List<Entity> runAgainst;

    public override void Init()
    {
        if (queue)
        {
            Events.OnPreProcessTrigger += PreProcessTrigger;
            return;
        }
        Events.OnEntityTrigger += CheckTrigger;
        base.PreCardPlayed += CheckPreCardPlay;
    }

    public void OnDestroy()
    {
        if (queue)
        {
            Events.OnPreProcessTrigger -= PreProcessTrigger;
        }
        else
        {
            Events.OnEntityTrigger -= CheckTrigger;
        }
    }

    public void PreProcessTrigger(Entity entity)
    {
        if (entity == target && !running && ((Behaviour)target).enabled)
        {
            ActionQueue.Stack(new ActionSequence(Run(GetTargets())), fixedPosition: true);
        }
    }

    public void CheckTrigger(ref Trigger trigger)
    {
        if (!running && ((Behaviour)target).enabled && trigger.entity == target)
        {
            runAgainst = GetTargets();
            if (mustHaveTarget && (runAgainst == null || runAgainst.Count <= 0))
            {
                trigger.nullified = true;
            }
        }
    }

    public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (!running && ((Behaviour)target).enabled)
        {
            List<Entity> list = runAgainst;
            if (list != null && list.Count > 0)
            {
                return entity == target;
            }
        }
        return false;
    }

    public IEnumerator CheckPreCardPlay(Entity entity, Entity[] targets)
    {
        yield return RunSequence(runAgainst);
    }

    public IEnumerator RunSequence(List<Entity> targets)
    {
        running = true;
        yield return Run(targets);
        runAgainst = null;
        running = false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X To Enemies When Drawn", fileName = "Apply X To Enemies When Drawn")]
public class StatusEffectDamageEnemiesWhenDrawn : StatusEffectApplyX
{
    public override void Init()
    {
        base.OnEnable += Check;
    }

    public override bool RunEnableEvent(Entity entity)
    {
        if (entity == target)
        {
            return target.InHand();
        }
        return false;
    }

    public IEnumerator Check(Entity entity)
    {
        return Run(GetTargets());
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X To Front Allies", fileName = "Apply X To Front Allies")]
public class StatusEffectApplyXToFrontAllies : StatusEffectApplyX
{
    public override void Init()
    {
        base.OnCardPlayed += Run;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        return entity == target;
    }

    public IEnumerator Run(Entity entity, Entity[] targets)
    {
        int a = GetAmount();
        List<Entity> toAffect = new List<Entity>();
        foreach (CardContainer row in Battle.instance.GetRows(target.owner))
        {
            IListExt.AddIfNotNull<Entity>((IList<Entity>)toAffect, row.GetTop());
        }
        if (toAffect.Count <= 0)
        {
            yield break;
        }
        target.curveAnimator.Ping();
        yield return Sequences.Wait(0.13f);
        Routine.Clump clump = new Routine.Clump();
        foreach (Entity item in toAffect)
        {
            Hit hit = new Hit(target, item, 0);
            hit.AddStatusEffect(effectToApply, a);
            clump.Add(hit.Process());
        }
        yield return clump.WaitForEnd();
        yield return Sequences.Wait(0.13f);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X To Front Ally Based On Damage Dealt", fileName = "Apply X To Front Ally Based On Damage Dealt")]
public class StatusEffectApplyXToFrontAllyBasedOnDamageDealt : StatusEffectApplyX
{
    public Dictionary<Entity, int[]> entitiesHitInRows = new Dictionary<Entity, int[]>();

    public Dictionary<int, int> damageDealtInRows = new Dictionary<int, int>();

    public override void Init()
    {
        base.OnCardPlayed += Check;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.attacker == target && hit.target != null && hit.Offensive)
        {
            entitiesHitInRows.Add(hit.target, Battle.instance.GetRowIndices(hit.target));
        }
        return false;
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        if (hit.attacker == target && entitiesHitInRows.ContainsKey(hit.target) && hit.damageDealt > 0)
        {
            int[] array = entitiesHitInRows[hit.target];
            int damageDealt = hit.damageDealt;
            int[] array2 = array;
            foreach (int key in array2)
            {
                if (damageDealtInRows.ContainsKey(key))
                {
                    damageDealtInRows[key] += damageDealt;
                }
                else
                {
                    damageDealtInRows[key] = damageDealt;
                }
            }
        }
        return false;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (entity == target)
        {
            if (damageDealtInRows.Count <= 0)
            {
                return entitiesHitInRows.Count > 0;
            }
            return true;
        }
        return false;
    }

    public IEnumerator Check(Entity entity, Entity[] targets)
    {
        Dictionary<Entity, int> toAffect = new Dictionary<Entity, int>();
        foreach (int key in damageDealtInRows.Keys)
        {
            CardContainer row = Battle.instance.GetRow(target.owner, key);
            if (row != null)
            {
                Entity top = row.GetTop();
                if (top != null)
                {
                    toAffect[top] = damageDealtInRows[key];
                }
            }
        }
        if (toAffect.Count > 0)
        {
            yield return Sequences.WaitForAnimationEnd(target);
            target.curveAnimator.Ping();
            yield return Sequences.Wait(0.1f);
            Routine.Clump clump = new Routine.Clump();
            foreach (Entity key2 in toAffect.Keys)
            {
                int num = toAffect[key2];
                Hit hit = new Hit(target, key2, 0);
                hit.AddStatusEffect(effectToApply, num);
                clump.Add(hit.Process());
                if (doPing)
                {
                    key2.curveAnimator.Ping();
                }
            }
            yield return clump.WaitForEnd();
        }
        yield return Sequences.Wait(0.1f);
        damageDealtInRows.Clear();
        entitiesHitInRows.Clear();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Allies Attack", fileName = "Apply X When Allies Attack")]
public class StatusEffectApplyXWhenAlliesAttack : StatusEffectApplyX
{
    public override void Init()
    {
        base.PreAttack += HitCheck;
    }

    public override bool RunPreAttackEvent(Hit hit)
    {
        if (((Behaviour)target).enabled && target.alive && hit.attacker.owner == target.owner && hit.attacker != target)
        {
            return hit.Offensive;
        }
        return false;
    }

    public IEnumerator HitCheck(Hit hit)
    {
        return Run(GetTargets(hit));
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Ally Is Healed", fileName = "Apply X When Ally Is Healed")]
public class StatusEffectApplyXWhenAllyHealed : StatusEffectApplyX
{
    public override void Init()
    {
        base.PostHit += Check;
        base.OnApplyStatus += CheckStatus;
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        if (((Behaviour)target).enabled && hit.target != target && hit.target.owner == target.owner && hit.damage < 0)
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator Check(Hit hit)
    {
        return Run(GetTargets(hit), -hit.damage);
    }

    public override bool RunApplyStatusEvent(StatusEffectApply apply)
    {
        if (((Behaviour)target).enabled && apply.target != target && apply.target.owner == target.owner && apply.effectData.type == "max health up" && Battle.IsOnBoard(target))
        {
            return Battle.IsOnBoard(apply.target);
        }
        return false;
    }

    public IEnumerator CheckStatus(StatusEffectApply apply)
    {
        return Run(GetTargets(null, null, null, new Entity[1] { apply.target }), apply.count);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Ally Is Hit", fileName = "Apply X When Ally Is Hit")]
public class StatusEffectApplyXWhenAllyIsHit : StatusEffectApplyX
{
    [SerializeField]
    public bool includeSelf;

    public override void Init()
    {
        base.PostHit += Check;
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        if (((Behaviour)target).enabled && (includeSelf || hit.target != target) && hit.canRetaliate && hit.target.owner == target.owner && hit.Offensive && hit.BasicHit && Battle.IsOnBoard(target))
        {
            return Battle.IsOnBoard(hit.target);
        }
        return false;
    }

    public IEnumerator Check(Hit hit)
    {
        return Run(GetTargets(hit));
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Ally Is Killed", fileName = "Apply X When Ally Is Killed")]
public class StatusEffectApplyXWhenAllyIsKilled : StatusEffectApplyX
{
    [SerializeField]
    public bool sacrificed;

    public override void Init()
    {
        base.OnEntityDestroyed += Check;
    }

    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        if (((Behaviour)target).enabled && target.alive && DeathSystem.CheckTeamIsAlly(entity, target) && Battle.IsOnBoard(target) && Battle.IsOnBoard(entity))
        {
            if (sacrificed)
            {
                return DeathSystem.KilledByOwnTeam(entity);
            }
            return true;
        }
        return false;
    }

    public IEnumerator Check(Entity entity, DeathType deathType)
    {
        if ((contextEqualAmount))
        {
            int amount = contextEqualAmount.Get(entity);
            yield return Run(GetTargets(null, null, null, new Entity[1] { entity }), amount);
        }
        else
        {
            yield return Run(GetTargets(null, null, null, new Entity[1] { entity }));
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Anyone Takes Damage", fileName = "Apply X When Anyone Takes Damage")]
public class StatusEffectApplyXWhenAnyoneTakesDamage : StatusEffectApplyX
{
    [SerializeField]
    public string targetDamageType = "basic";

    public override void Init()
    {
        base.PostHit += CheckHit;
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        if (((Behaviour)target).enabled && target.alive && hit.Offensive && hit.damageType == targetDamageType)
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator CheckHit(Hit hit)
    {
        return Run(GetTargets(hit));
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Built", fileName = "Apply X When Built")]
public class StatusEffectApplyXWhenBuilt : StatusEffectApplyX
{
    public override void Init()
    {
        base.OnBuild += Build;
    }

    public override bool RunBuildEvent(Entity entity)
    {
        return entity == target;
    }

    public IEnumerator Build(Entity entity)
    {
        yield return Run(GetTargets());
        yield return Remove();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Card Destroyed", fileName = "Apply X When Card Destroyed")]
public class StatusEffectApplyXWhenCardDestroyed : StatusEffectApplyX
{
    [SerializeField]
    public bool canBeAlly = true;

    [SerializeField]
    public bool canBeEnemy = true;

    [SerializeField]
    public bool mustBeSacrificed;

    [SerializeField]
    public bool mustBeOnBoard = true;

    [SerializeField]
    public TargetConstraint[] constraints;

    public override void Init()
    {
        base.OnEntityDestroyed += Check;
    }

    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        if (((Behaviour)target).enabled && target.alive && CheckTeam(entity) && Battle.IsOnBoard(target) && (!mustBeOnBoard || Battle.IsOnBoard(entity)) && CheckConstraints(entity))
        {
            if (mustBeSacrificed)
            {
                return DeathSystem.KilledByOwnTeam(entity);
            }
            return true;
        }
        return false;
    }

    public IEnumerator Check(Entity entity, DeathType deathType)
    {
        if ((contextEqualAmount))
        {
            int amount = contextEqualAmount.Get(entity);
            yield return Run(GetTargets(entity.lastHit), amount);
        }
        else
        {
            yield return Run(GetTargets(entity.lastHit));
        }
    }

    public bool CheckTeam(Entity entity)
    {
        if (target.owner == entity.owner)
        {
            return canBeAlly;
        }
        if (target.owner != entity.owner)
        {
            return canBeEnemy;
        }
        return false;
    }

    public new bool CheckConstraints(Entity entity)
    {
        if (constraints != null)
        {
            return constraints.All((TargetConstraint c) => c.Check(entity));
        }
        return true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Clunker Destroyed", fileName = "Apply X When Clunker Destroyed")]
public class StatusEffectApplyXWhenClunkerDestroyed : StatusEffectApplyX
{
    public override void Init()
    {
        base.OnEntityDestroyed += Check;
    }

    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        if (((Behaviour)target).enabled && (entity.data.cardType).name == "Clunker")
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator Check(Entity entity, DeathType deathType)
    {
        return Run(GetTargets());
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Damage Taken", fileName = "Apply X When Damage Taken")]
public class StatusEffectApplyXWhenDamageTaken : StatusEffectApplyX
{
    [SerializeField]
    public string targetDamageType = "basic";

    public override void Init()
    {
        base.PostHit += CheckHit;
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        if (hit.target == target && ((Behaviour)target).enabled && target.alive && hit.Offensive && hit.damageType == targetDamageType)
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator CheckHit(Hit hit)
    {
        return Run(GetTargets(hit));
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Deployed", fileName = "Apply X When Deployed")]
public class StatusEffectApplyXWhenDeployed : StatusEffectApplyX
{
    [SerializeField]
    public bool whenSelfDeployed = true;

    [SerializeField]
    public bool whenAllyDeployed;

    [SerializeField]
    public bool whenEnemyDeployed;

    public Hit hackyHit;

    public bool isAlreadyOnBoard;

    public override object GetMidBattleData()
    {
        return Battle.IsOnBoard(target);
    }

    public override void RestoreMidBattleData(object data)
    {
        if (data is bool flag)
        {
            isAlreadyOnBoard = flag && Battle.IsOnBoard(target);
        }
    }

    public override void Init()
    {
        base.OnEnable += Activate;
        base.OnCardMove += Activate;
    }

    public override bool RunEnableEvent(Entity entity)
    {
        if (whenSelfDeployed && entity == target && Battle.IsOnBoard(target))
        {
            if (isAlreadyOnBoard)
            {
                isAlreadyOnBoard = false;
                return false;
            }
            hackyHit = null;
            return true;
        }
        if (whenAllyDeployed && ((Behaviour)target).enabled && IsAlly(target, entity) && Battle.IsOnBoard(target) && Battle.IsOnBoard(entity))
        {
            hackyHit = new Hit(target, entity);
            return true;
        }
        if (whenEnemyDeployed && ((Behaviour)target).enabled && IsEnemy(target, entity) && Battle.IsOnBoard(target) && Battle.IsOnBoard(entity))
        {
            hackyHit = new Hit(target, entity);
            return true;
        }
        return false;
    }

    public override bool RunCardMoveEvent(Entity entity)
    {
        if (!((Behaviour)target).enabled || !((Behaviour)entity).enabled)
        {
            return false;
        }
        if (whenSelfDeployed && entity == target && WasMovedOnToBoard(entity))
        {
            hackyHit = null;
            return true;
        }
        if (whenAllyDeployed && IsAlly(target, entity) && WasMovedOnToBoard(entity))
        {
            hackyHit = new Hit(target, entity);
            return true;
        }
        if (whenEnemyDeployed && IsEnemy(target, entity) && WasMovedOnToBoard(entity))
        {
            hackyHit = new Hit(target, entity);
            return true;
        }
        return false;
    }

    public IEnumerator Activate(Entity entity)
    {
        if ((contextEqualAmount))
        {
            int amount = contextEqualAmount.Get(entity);
            yield return Run(GetTargets(hackyHit), amount);
        }
        else
        {
            yield return Run(GetTargets(hackyHit));
        }
    }

    public static bool WasMovedOnToBoard(Entity entity)
    {
        if (Battle.IsOnBoard(entity))
        {
            return !Battle.IsOnBoard(entity.preContainers);
        }
        return false;
    }

    public static bool IsAlly(Entity a, Entity b)
    {
        if (a != b)
        {
            return a.owner.team == b.owner.team;
        }
        return false;
    }

    public static bool IsEnemy(Entity a, Entity b)
    {
        return a.owner.team != b.owner.team;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Destroyed", fileName = "Apply X When Destroyed")]
public class StatusEffectApplyXWhenDestroyed : StatusEffectApplyX
{
    [SerializeField]
    public bool sacrificed;

    [SerializeField]
    public bool consumed;

    public override void Init()
    {
        base.OnEntityDestroyed += CheckDestroy;
    }

    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        if (entity == target)
        {
            return CheckDeathType(deathType);
        }
        return false;
    }

    public IEnumerator CheckDestroy(Entity entity, DeathType deathType)
    {
        yield return Run(GetTargets(null, GetTargetContainers(), GetTargetActualContainers()));
    }

    public bool CheckDeathType(DeathType deathType)
    {
        if (consumed && deathType != DeathType.Consume)
        {
            return false;
        }
        if (sacrificed && !DeathSystem.KilledByOwnTeam(target))
        {
            return false;
        }
        return true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Discarded", fileName = "Apply X When Discarded")]
public class StatusEffectApplyXWhenDiscarded : StatusEffectApplyX
{
    public override void Init()
    {
        Events.OnActionQueued += ActionQueued;
    }

    public void ActionQueued(PlayAction action)
    {
        if (action is ActionMove actionMove && actionMove.entity == target && (target.owner) && IArrayExt.Contains<CardContainer>(actionMove.toContainers, target.owner.discardContainer))
        {
            ActionQueue.Insert(ActionQueue.IndexOf(action), new ActionSequence(Sequence()));
        }
    }

    public IEnumerator Sequence()
    {
        return Run(GetTargets());
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Drawn", fileName = "Apply X When Drawn")]
public class StatusEffectApplyXWhenDrawn : StatusEffectApplyX
{
    public override void Init()
    {
        base.OnEnable += CheckEnable;
        base.OnCardMove += CheckCardMove;
    }

    public override bool RunEnableEvent(Entity entity)
    {
        if (entity == target)
        {
            return target.InHand();
        }
        return false;
    }

    public IEnumerator CheckEnable(Entity entity)
    {
        return Run(GetTargets());
    }

    public override bool RunCardMoveEvent(Entity entity)
    {
        if (((Behaviour)target).enabled && entity == target)
        {
            return target.InHand();
        }
        return false;
    }

    public IEnumerator CheckCardMove(Entity entity)
    {
        return Run(GetTargets());
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Enemies Attack", fileName = "Apply X When Enemies Attack")]
public class StatusEffectApplyXWhenEnemiesAttack : StatusEffectApplyX
{
    public Entity attacker;

    public override void Init()
    {
        base.PreAttack += HitCheck;
    }

    public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (((Behaviour)target).enabled && target.alive && entity.owner != target.owner && Battle.IsOnBoard(target))
        {
            attacker = entity;
        }
        return false;
    }

    public override bool RunPreAttackEvent(Hit hit)
    {
        if (attacker != null && hit.attacker == attacker && ((Behaviour)target).enabled && target.alive && hit.Offensive)
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator HitCheck(Hit hit)
    {
        attacker = null;
        yield return Run(GetTargets(hit));
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Healed", fileName = "Apply X When Healed")]
public class StatusEffectApplyXWhenHealed : StatusEffectApplyX
{
    [SerializeField]
    public bool alsoWhenMaxHealthIncreased = true;

    public override void Init()
    {
        base.OnHit += Check;
        if (alsoWhenMaxHealthIncreased)
        {
            base.OnApplyStatus += CheckStatus;
        }
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.target == target)
        {
            return hit.damage < 0;
        }
        return false;
    }

    public IEnumerator Check(Hit hit)
    {
        return Run(GetTargets(hit), -hit.damage);
    }

    public override bool RunApplyStatusEvent(StatusEffectApply apply)
    {
        if (alsoWhenMaxHealthIncreased && apply.target == target)
        {
            return apply.effectData.type == "max health up";
        }
        return false;
    }

    public IEnumerator CheckStatus(StatusEffectApply apply)
    {
        return Run(GetTargets(null, null, null, new Entity[1] { apply.target }), apply.count);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Health Lost", fileName = "Apply X When Health Lost")]
public class StatusEffectApplyXWhenHealthLost : StatusEffectApplyX
{
    [SerializeField]
    public bool hasThreshold;

    public bool active;

    public int currentHealth;

    public override void Init()
    {
        Events.OnEntityDisplayUpdated += EntityDisplayUpdated;
    }

    public void OnDestroy()
    {
        Events.OnEntityDisplayUpdated -= EntityDisplayUpdated;
    }

    public override bool RunBeginEvent()
    {
        active = true;
        currentHealth = target.hp.current;
        return false;
    }

    public void EntityDisplayUpdated(Entity entity)
    {
        if (active && target.hp.current != currentHealth && entity == target)
        {
            int num = target.hp.current - currentHealth;
            currentHealth = target.hp.current;
            if (num < 0 && ((Behaviour)target).enabled && !target.silenced && CheckThreshold() && (!targetMustBeAlive || (target.alive && Battle.IsOnBoard(target))))
            {
                ActionQueue.Stack(new ActionSequence(HealthLost(-num))
                {
                    note = name,
                    priority = eventPriority
                }, fixedPosition: true);
            }
        }
    }

    public bool CheckThreshold()
    {
        if (hasThreshold)
        {
            return target.hp.current <= target.hp.max - GetAmount();
        }
        return true;
    }

    public IEnumerator HealthLost(int amount)
    {
        if ((this) && target.IsAliveAndExists())
        {
            yield return Run(GetTargets(), amount);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Hit", fileName = "Apply X When Hit")]
public class StatusEffectApplyXWhenHit : StatusEffectApplyX
{
    [SerializeField]
    public TargetConstraint[] attackerConstraints;

    public override void Init()
    {
        base.PostHit += CheckHit;
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        if (((Behaviour)target).enabled && hit.target == target && hit.canRetaliate && (!targetMustBeAlive || (target.alive && Battle.IsOnBoard(target))) && hit.Offensive && hit.BasicHit)
        {
            return CheckAttackerConstraints(hit.attacker);
        }
        return false;
    }

    public IEnumerator CheckHit(Hit hit)
    {
        return Run(GetTargets(hit, GetTargetContainers(), GetTargetActualContainers()), hit.damage + hit.damageBlocked);
    }

    public bool CheckAttackerConstraints(Entity attacker)
    {
        if (attackerConstraints != null)
        {
            TargetConstraint[] array = attackerConstraints;
            for (int i = 0; i < array.Length; i++)
            {
                if (!array[i].Check(attacker))
                {
                    return false;
                }
            }
        }
        return true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Redraw Hit", fileName = "Apply X When Redraw Hit")]
public class StatusEffectApplyXWhenRedrawHit : StatusEffectApplyX
{
    public override void Init()
    {
        Events.OnRedrawBellHit += RedrawBellHit;
    }

    public void OnDestroy()
    {
        Events.OnRedrawBellHit -= RedrawBellHit;
    }

    public void RedrawBellHit(RedrawBellSystem redrawBellSystem)
    {
        if (Battle.IsOnBoard(target) && CanTrigger())
        {
            ActionQueue.Stack(new ActionSequence(Run(GetTargets())), fixedPosition: true);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Unit Is Hit", fileName = "Apply X When Unit Is Hit")]
public class StatusEffectApplyXWhenUnitIsHit : StatusEffectApplyX
{
    [SerializeField]
    public bool ally = true;

    [SerializeField]
    public bool enemy;

    [SerializeField]
    public TargetConstraint[] unitConstraints;

    [SerializeField]
    public TargetConstraint[] attackerConstraints;

    public override void Init()
    {
        base.PostHit += Check;
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        if (((Behaviour)target).enabled && target.alive && hit.canRetaliate && hit.BasicHit && hit.Offensive && CheckTeam(hit.target) && (!targetMustBeAlive || (hit.target.alive && Battle.IsOnBoard(hit.target))) && Battle.IsOnBoard(target) && CheckConstraints(hit.target))
        {
            return CheckAttackerConstraints(hit.attacker);
        }
        return false;
    }

    public IEnumerator Check(Hit hit)
    {
        if ((contextEqualAmount))
        {
            int amount = contextEqualAmount.Get(hit.target);
            yield return Run(GetTargets(hit), amount);
        }
        else
        {
            yield return Run(GetTargets(hit));
        }
    }

    public bool CheckTeam(Entity entity)
    {
        if (target.owner == entity.owner)
        {
            return ally;
        }
        if (target.owner != entity.owner)
        {
            return enemy;
        }
        return false;
    }

    public new bool CheckConstraints(Entity entity)
    {
        if (unitConstraints != null)
        {
            return unitConstraints.All((TargetConstraint c) => c.Check(entity));
        }
        return true;
    }

    public bool CheckAttackerConstraints(Entity attacker)
    {
        if (attackerConstraints != null)
        {
            TargetConstraint[] array = attackerConstraints;
            for (int i = 0; i < array.Length; i++)
            {
                if (!array[i].Check(attacker))
                {
                    return false;
                }
            }
        }
        return true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Unit Is Killed", fileName = "Apply X When Unit Is Killed")]
public class StatusEffectApplyXWhenUnitIsKilled : StatusEffectApplyX
{
    [SerializeField]
    public bool ally = true;

    [SerializeField]
    public bool enemy;

    [SerializeField]
    public bool sacrificed;

    [SerializeField]
    public TargetConstraint[] unitConstraints;

    public override void Init()
    {
        base.OnEntityDestroyed += Check;
    }

    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        if (((Behaviour)target).enabled && target.alive && CheckTeam(entity) && Battle.IsOnBoard(entity) && Battle.IsOnBoard(target) && CheckConstraints(entity))
        {
            if (sacrificed)
            {
                return DeathSystem.KilledByOwnTeam(entity);
            }
            return true;
        }
        return false;
    }

    public IEnumerator Check(Entity entity, DeathType deathType)
    {
        if ((contextEqualAmount))
        {
            int amount = contextEqualAmount.Get(entity);
            yield return Run(GetTargets(entity.lastHit), amount);
        }
        else
        {
            yield return Run(GetTargets(entity.lastHit));
        }
    }

    public bool CheckTeam(Entity entity)
    {
        if (!DeathSystem.CheckTeamIsAlly(entity, target))
        {
            return enemy;
        }
        return ally;
    }

    public new bool CheckConstraints(Entity entity)
    {
        if (unitConstraints != null)
        {
            return unitConstraints.All((TargetConstraint c) => c.Check(entity));
        }
        return true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Unit Loses Y", fileName = "Apply X When Unit Loses Y")]
public class StatusEffectApplyXWhenUnitLosesY : StatusEffectApplyX
{
    [SerializeField]
    public bool self = true;

    [SerializeField]
    public bool allies;

    [SerializeField]
    public bool enemies;

    [SerializeField]
    public string statusType = "block";

    [SerializeField]
    public bool whenAllLost;

    public readonly Dictionary<ulong, int> currentAmounts = new Dictionary<ulong, int>();

    public override void Init()
    {
        Events.OnEntityDisplayUpdated += EntityDisplayUpdated;
    }

    public void OnDestroy()
    {
        Events.OnEntityDisplayUpdated -= EntityDisplayUpdated;
    }

    public override bool RunEnableEvent(Entity entity)
    {
        if (entity != target)
        {
            return false;
        }
        if (self)
        {
            StoreCurrentAmount(target);
        }
        if (allies)
        {
            foreach (Entity allAlly in target.GetAllAllies())
            {
                StoreCurrentAmount(allAlly);
            }
        }
        if (enemies)
        {
            foreach (Entity allEnemy in target.GetAllEnemies())
            {
                StoreCurrentAmount(allEnemy);
            }
        }
        return false;
    }

    public override bool RunDisableEvent(Entity entity)
    {
        if (entity == target)
        {
            currentAmounts.Clear();
        }
        return false;
    }

    public void EntityDisplayUpdated(Entity entity)
    {
        if (!((Behaviour)entity).enabled || !Battle.IsOnBoard(entity))
        {
            return;
        }
        if (entity == target)
        {
            if (self)
            {
                CheckEntity(entity);
            }
        }
        else if (entity.owner.team == target.owner.team)
        {
            if (allies)
            {
                CheckEntity(entity);
            }
        }
        else if (enemies)
        {
            CheckEntity(entity);
        }
    }

    public IEnumerator Lost(int amount)
    {
        if ((this) && target.IsAliveAndExists())
        {
            yield return Run(GetTargets(), amount);
        }
    }

    public int GetCurrentAmount(Entity entity)
    {
        return entity.FindStatus(statusType)?.count ?? 0;
    }

    public void StoreCurrentAmount(Entity entity)
    {
        currentAmounts[entity.data.id] = GetCurrentAmount(entity);
    }

    public void CheckEntity(Entity entity)
    {
        currentAmounts.TryGetValue(entity.data.id, out var value);
        int currentAmount = GetCurrentAmount(entity);
        currentAmounts[entity.data.id] = currentAmount;
        int num = currentAmount - value;
        if (num < 0 && (!whenAllLost || value == 0) && !target.silenced && (!targetMustBeAlive || (target.alive && Battle.IsOnBoard(target))))
        {
            ActionQueue.Stack(new ActionSequence(Lost(-num))
            {
                note = name,
                priority = eventPriority
            }, fixedPosition: true);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Y Applied To", fileName = "Apply X When Y Applied To")]
public class StatusEffectApplyXWhenYAppliedTo : StatusEffectApplyX
{
    [SerializeField]
    public bool instead;

    public bool whenAnyApplied;

    [HideIf("whenAnyApplied")]
    public string[] whenAppliedTypes = new string[1] { "snow" };

    [SerializeField]
    public ApplyToFlags whenAppliedToFlags;

    [SerializeField]
    public bool mustReachAmount;

    [Header("Adjust Amount Applied")]
    [SerializeField]
    public bool adjustAmount;

    [SerializeField]
    [ShowIf("adjustAmount")]
    public int addAmount;

    [SerializeField]
    [ShowIf("adjustAmount")]
    public float multiplyAmount = 1f;

    public override void Init()
    {
        base.PostApplyStatus += Run;
    }

    public bool CheckType(StatusEffectData effectData)
    {
        if (effectData.isStatus)
        {
            if (!whenAnyApplied)
            {
                return IArrayExt.Contains<string>(whenAppliedTypes, effectData.type);
            }
            return true;
        }
        return false;
    }

    public override bool RunApplyStatusEvent(StatusEffectApply apply)
    {
        if ((adjustAmount || instead) && ((Behaviour)target).enabled && !TargetSilenced() && (target.alive || !targetMustBeAlive) && (apply.effectData) && apply.count > 0 && CheckType(apply.effectData) && CheckTarget(apply.target))
        {
            if (instead)
            {
                apply.effectData = effectToApply;
            }
            if (adjustAmount)
            {
                apply.count += addAmount;
                apply.count = Mathf.RoundToInt((float)apply.count * multiplyAmount);
            }
        }
        return false;
    }

    public override bool RunPostApplyStatusEvent(StatusEffectApply apply)
    {
        if (((Behaviour)target).enabled && !TargetSilenced() && (apply.effectData) && apply.count > 0 && CheckType(apply.effectData) && CheckTarget(apply.target))
        {
            return CheckAmount(apply);
        }
        return false;
    }

    public IEnumerator Run(StatusEffectApply apply)
    {
        return Run(GetTargets(), apply.count);
    }

    public bool CheckFlag(ApplyToFlags whenAppliedTo)
    {
        return (whenAppliedToFlags & whenAppliedTo) != 0;
    }

    public bool CheckTarget(Entity entity)
    {
        if (!Battle.IsOnBoard(target))
        {
            return false;
        }
        if (entity == target)
        {
            return CheckFlag(ApplyToFlags.Self);
        }
        if (entity.owner == target.owner)
        {
            return CheckFlag(ApplyToFlags.Allies);
        }
        if (entity.owner != target.owner)
        {
            return CheckFlag(ApplyToFlags.Enemies);
        }
        return false;
    }

    public bool CheckAmount(StatusEffectApply apply)
    {
        if (!mustReachAmount)
        {
            return true;
        }
        StatusEffectData statusEffectData = apply.target.FindStatus(apply.effectData.type);
        if ((statusEffectData))
        {
            return statusEffectData.count >= GetAmount();
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Y Applied To Ally", fileName = "Apply X When Y Applied To Ally")]
public class StatusEffectApplyXWhenYAppliedToAlly : StatusEffectApplyX
{
    public string whenAppliedType = "snow";

    public override void Init()
    {
        base.PostApplyStatus += Check;
    }

    public override bool RunPostApplyStatusEvent(StatusEffectApply apply)
    {
        if (((Behaviour)target).enabled && apply.target.owner == target.owner && apply.effectData != null && apply.count > 0)
        {
            return apply.effectData.type == whenAppliedType;
        }
        return false;
    }

    public IEnumerator Check(StatusEffectApply apply)
    {
        return Run(GetTargets());
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Y Applied To Self", fileName = "Apply X When Y Applied To Self")]
public class StatusEffectApplyXWhenYAppliedToSelf : StatusEffectApplyX
{
    public string whenAppliedType = "spice";

    public string[] whenAppliedTypes = new string[1] { "spice" };

    public override void Init()
    {
        base.PostApplyStatus += Check;
    }

    public override bool RunPostApplyStatusEvent(StatusEffectApply apply)
    {
        if (((Behaviour)target).enabled && apply.target == target && (apply.effectData) && apply.count > 0)
        {
            return IArrayExt.Contains<string>(whenAppliedTypes, apply.effectData.type);
        }
        return false;
    }

    public IEnumerator Check(StatusEffectApply apply)
    {
        return Run(GetTargets());
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Apply X When Y Lost", fileName = "Apply X When Y Lost")]
public class StatusEffectApplyXWhenYLost : StatusEffectApplyX
{
    [SerializeField]
    public string statusType = "block";

    [SerializeField]
    public bool whenAllLost;

    public bool active;

    public int currentAmount;

    public override void Init()
    {
        Events.OnEntityDisplayUpdated += EntityDisplayUpdated;
    }

    public void OnDestroy()
    {
        Events.OnEntityDisplayUpdated -= EntityDisplayUpdated;
    }

    public override bool RunBeginEvent()
    {
        active = true;
        currentAmount = GetCurrentAmount();
        return false;
    }

    public void EntityDisplayUpdated(Entity entity)
    {
        int num = GetCurrentAmount();
        if (active && num != currentAmount && entity == target)
        {
            int num2 = num - currentAmount;
            currentAmount = num;
            if (num2 < 0 && (!whenAllLost || currentAmount == 0) && ((Behaviour)target).enabled && !target.silenced && (!targetMustBeAlive || (target.alive && Battle.IsOnBoard(target))))
            {
                ActionQueue.Stack(new ActionSequence(Lost(-num2))
                {
                    note = name,
                    priority = eventPriority
                }, fixedPosition: true);
            }
        }
    }

    public IEnumerator Lost(int amount)
    {
        if ((this) && target.IsAliveAndExists())
        {
            yield return Run(GetTargets(), amount);
        }
    }

    public int GetCurrentAmount()
    {
        return target.FindStatus(statusType)?.count ?? 0;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Bombard", fileName = "Bombard")]
public class StatusEffectBombard : StatusEffectData
{
    public class Slot
    {
        public readonly CardSlot slot;

        public readonly bool friendly;

        public readonly bool front;

        public Slot(CardSlot slot, bool friendly, bool front)
        {
            this.slot = slot;
            this.friendly = friendly;
            this.front = front;
        }
    }

    [Serializable]
    public class SlotList
    {
        public int[] list;
    }

    [SerializeField]
    public Vector2Int targetCountRange = new Vector2Int(2, 2);

    [SerializeField]
    [Range(0f, 1f)]
    public float hitFriendlyChance = 0.1f;

    [SerializeField]
    public float delayBetweenTargets = 0.1f;

    [SerializeField]
    public float delayAfter = 0.1f;

    [SerializeField]
    public int maxFrontTargets;

    public List<CardContainer> targetList = new List<CardContainer>();

    public bool triggered;

    public int[] storedTargetList;

    public override object GetMidBattleData()
    {
        List<CardContainer> list = targetList;
        if (list != null && list.Count > 0)
        {
            List<int> list2 = new List<int>();
            List<CardSlot> slots = References.Battle.GetSlots();
            foreach (CardContainer target in targetList)
            {
                if (target is CardSlot item)
                {
                    int num = slots.IndexOf(item);
                    if (num >= 0)
                    {
                        list2.Add(num);
                    }
                }
            }
            return new SlotList
            {
                list = list2.ToArray()
            };
        }
        return null;
    }

    public override void RestoreMidBattleData(object data)
    {
        if (data is SlotList slotList)
        {
            storedTargetList = slotList.list;
        }
    }

    public override void Init()
    {
        base.OnEnable += Enable;
        base.OnCardPlayed += CardPlayed;
        base.OnActionPerformed += ActionPerformed;
        Events.OnEntityTrigger += EntityTrigger;
    }

    public void OnDestroy()
    {
        Events.OnEntityTrigger -= EntityTrigger;
    }

    public void EntityTrigger(ref Trigger trigger)
    {
        if (trigger.entity == target && CanTrigger() && trigger.type == "basic")
        {
            trigger = new TriggerBombard(trigger.entity, trigger.triggeredBy, "bombard", trigger.targets, targetList.ToArray());
        }
    }

    public override bool RunEnableEvent(Entity entity)
    {
        return entity == target;
    }

    public IEnumerator Enable(Entity entity)
    {
        yield return SetTargets();
    }

    public override bool RunDisableEvent(Entity entity)
    {
        if (entity == target)
        {
            foreach (CardContainer target in targetList)
            {
                Events.InvokeAbilityTargetRemove(target);
            }
        }
        return false;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        return entity == target;
    }

    public IEnumerator CardPlayed(Entity entity, Entity[] targets)
    {
        if (CanTrigger())
        {
            triggered = true;
            yield return Sequences.WaitForAnimationEnd(target);
            yield return Sequences.Wait(delayAfter);
        }
    }

    public override bool RunActionPerformedEvent(PlayAction action)
    {
        if (triggered)
        {
            return ActionQueue.Empty;
        }
        return false;
    }

    public IEnumerator ActionPerformed(PlayAction action)
    {
        triggered = false;
        yield return SetTargets();
    }

    public override bool RunEndEvent()
    {
        foreach (CardContainer target in targetList)
        {
            Events.InvokeAbilityTargetRemove(target);
        }
        return false;
    }

    public IEnumerator SetTargets()
    {
        foreach (CardContainer target in targetList)
        {
            Events.InvokeAbilityTargetRemove(target);
        }
        if (storedTargetList != null)
        {
            List<CardSlot> slots = References.Battle.GetSlots();
            int[] array = storedTargetList;
            foreach (int index in array)
            {
                CardSlot item = slots[index];
                targetList.Add(item);
            }
            storedTargetList = null;
        }
        else
        {
            List<Slot> list = new List<Slot>();
            List<CardContainer> rows = Battle.instance.GetRows(base.target.owner);
            List<CardContainer> rows2 = Battle.instance.GetRows(Battle.GetOpponent(base.target.owner));
            for (int k = 0; k < Battle.instance.rowCount; k++)
            {
                if (rows[k] is CardSlotLane cardSlotLane)
                {
                    list.AddRange(cardSlotLane.slots.Select((CardSlot t, int i) => new Slot(t, friendly: true, i == 0)));
                }
                if (rows2[k] is CardSlotLane cardSlotLane2)
                {
                    list.AddRange(cardSlotLane2.slots.Select((CardSlot t, int i) => new Slot(t, friendly: false, i == 0)));
                }
            }
            IListExt.Shuffle<Slot>((IList<Slot>)list);
            if (maxFrontTargets <= 0)
            {
                list.RemoveAll((Slot a) => a.front);
            }
            (targetList ?? (targetList = new List<CardContainer>())).Clear();
            int num = 0;
            int num2 = Vector2IntExt.Random(targetCountRange);
            while (num2 > 0 && list.Count > 0)
            {
                bool friendly = Random.Range(0f, 1f) < hitFriendlyChance;
                Slot slot = list.Find((Slot a) => a.friendly == friendly) ?? list[0];
                targetList.Add(slot.slot);
                num2--;
                list.Remove(slot);
                if (slot.front && ++num >= maxFrontTargets)
                {
                    list.RemoveAll((Slot a) => a.front);
                }
            }
        }
        if ((base.target))
        {
            targetList.Sort(delegate (CardContainer a, CardContainer b)
            {
                //IL_000b: Unknown result type (might be due to invalid IL or missing references)
                //IL_0025: Unknown result type (might be due to invalid IL or missing references)
                //IL_0036: Unknown result type (might be due to invalid IL or missing references)
                int num3 = Mathf.RoundToInt(Mathf.Sign(base.target.transform.position.x));
                float x = ((Transform)a.holder).position.x;
                float x2 = ((Transform)b.holder).position.x;
                return (num3 != 1) ? x2.CompareTo(x) : x.CompareTo(x2);
            });
        }
        foreach (CardContainer target2 in targetList)
        {
            Events.InvokeAbilityTargetAdd(target2);
            yield return Sequences.Wait(delayBetweenTargets);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Bonus Damage Equal To Cards", fileName = "Bonus Damage Equal To Cards")]
public class StatusEffectBonusDamageEqualToCards : StatusEffectData
{
    [SerializeField]
    public string cardName = "Dart";

    [SerializeField]
    public bool inHand = true;

    [SerializeField]
    public bool onBoard;

    [SerializeField]
    public bool includeSelf = true;

    [SerializeField]
    public bool ping = true;

    public int currentAmount;

    public override void Init()
    {
        base.PreCardPlayed += Gain;
    }

    public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (entity == target && currentAmount == 0)
        {
            return CanTrigger();
        }
        return false;
    }

    public IEnumerator Gain(Entity entity, Entity[] targets)
    {
        int num = Count();
        if (num > 0)
        {
            currentAmount = num;
            Entity entity2 = target;
            entity2.tempDamage += currentAmount;
            target.PromptUpdate();
            if (ping)
            {
                target.curveAnimator?.Ping();
                yield return Sequences.Wait(0.5f);
            }
        }
    }

    public override bool RunTurnEndEvent(Entity entity)
    {
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        if (currentAmount > 0 && (target.owner) && (target.owner.entity) && entity == target.owner.entity)
        {
            Entity entity2 = target;
            entity2.tempDamage -= currentAmount;
            currentAmount = 0;
            target.PromptUpdate();
        }
        return false;
    }

    public int Count()
    {
        return 0 + (inHand ? CountInHand() : 0) + (onBoard ? CountOnBoard() : 0);
    }

    public int CountInHand()
    {
        int num = 0;
        CardContainer handContainer = target.owner.handContainer;
        if ((handContainer))
        {
            num += handContainer.Where((Entity entity) => (entity.data).name == cardName).Count((Entity entity) => includeSelf || entity != target);
        }
        return num;
    }

    public int CountOnBoard()
    {
        return (from entity in Battle.GetAllUnits()
                where (entity.data).name == cardName
                select entity).Count((Entity entity) => includeSelf || entity != target);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Bonus Damage Equal To Enemy Stat", fileName = "Bonus Damage Equal To Enemy Stat")]
public class StatusEffectBonusDamageEqualToEnemyStat : StatusEffectData
{
    [SerializeField]
    public SelectScript<Entity> selectEnemy;

    [SerializeField]
    public ScriptableAmount scriptableAmount;

    [SerializeField]
    public bool add = true;

    [SerializeField]
    public bool ping = true;

    public int currentAmount;

    public bool toReset;

    public override void Init()
    {
        base.PreCardPlayed += Gain;
    }

    public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (entity == target && !toReset)
        {
            return CanTrigger();
        }
        return false;
    }

    public IEnumerator Gain(Entity entity, Entity[] targets)
    {
        Entity enemy = SelectEnemy();
        int amount = GetAmount(enemy);
        if (amount != 0)
        {
            toReset = true;
            int value = ((target.tempDamage)).Value;
            if (add)
            {
                Entity entity2 = target;
                entity2.tempDamage += amount;
            }
            else
            {
                ((target.tempDamage)).Value = amount;
            }
            currentAmount = ((target.tempDamage)).Value - value;
            target.PromptUpdate();
            if (ping)
            {
                target.curveAnimator.Ping();
                yield return Sequences.Wait(0.5f);
            }
        }
    }

    public override bool RunTurnEndEvent(Entity entity)
    {
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        if (entity == target.owner.entity && toReset)
        {
            toReset = false;
            if (currentAmount != 0)
            {
                Entity entity2 = target;
                entity2.tempDamage -= currentAmount;
                currentAmount = 0;
                target.PromptUpdate();
            }
        }
        return false;
    }

    public Entity SelectEnemy()
    {
        List<Entity> enemies = target.GetEnemies();
        return selectEnemy.Run(enemies).FirstOrDefault();
    }

    public int GetAmount(Entity enemy)
    {
        if (!(scriptableAmount))
        {
            return GetAmount();
        }
        if (!(enemy))
        {
            return 0;
        }
        return scriptableAmount.Get(enemy);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Bonus Damage Equal To X", fileName = "Bonus Damage Equal To X")]
public class StatusEffectBonusDamageEqualToX : StatusEffectData
{
    public enum On
    {
        Self,
        Board,
        ScriptableAmount
    }

    [SerializeField]
    public On on;

    [SerializeField]
    [ShowIf("useScriptableAmount")]
    public ScriptableAmount scriptableAmount;

    [SerializeField]
    public bool add = true;

    [SerializeField]
    [HideIf("useScriptableAmount")]
    public bool health;

    [HideIf("health")]
    public string effectType = "shell";

    [SerializeField]
    public bool ping = true;

    public int currentAmount;

    public bool toReset;

    public bool useScriptableAmount => on == On.ScriptableAmount;

    public override void Init()
    {
        base.PreCardPlayed += Gain;
    }

    public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (entity == target)
        {
            return CanTrigger();
        }
        return false;
    }

    public IEnumerator Gain(Entity entity, Entity[] targets)
    {
        int num = Find();
        if (!toReset || num != currentAmount)
        {
            if (toReset)
            {
                LoseCurrentAmount();
            }
            if (num > 0)
            {
                yield return GainAmount(num);
            }
        }
    }

    public IEnumerator GainAmount(int amount)
    {
        toReset = true;
        int value = ((target.tempDamage)).Value;
        if (add)
        {
            Entity entity = target;
            entity.tempDamage += amount;
        }
        else
        {
            ((target.tempDamage)).Value = amount;
        }
        currentAmount = ((target.tempDamage)).Value - value;
        target.PromptUpdate();
        if (ping)
        {
            target.curveAnimator.Ping();
            yield return Sequences.Wait(0.5f);
        }
    }

    public override bool RunTurnEndEvent(Entity entity)
    {
        if (entity == target.owner.entity && toReset)
        {
            LoseCurrentAmount();
        }
        return false;
    }

    public void LoseCurrentAmount()
    {
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        toReset = false;
        if (currentAmount != 0)
        {
            Entity entity = target;
            entity.tempDamage -= currentAmount;
            currentAmount = 0;
            target.PromptUpdate();
        }
    }

    public int Find()
    {
        return on switch
        {
            On.Self => FindOnSelf(),
            On.Board => FindOnBoard(),
            On.ScriptableAmount => scriptableAmount.Get(target),
            _ => 0,
        };
    }

    public int FindOnSelf()
    {
        int result = 0;
        if (health)
        {
            result = target.hp.current;
        }
        else
        {
            StatusEffectData statusEffectData = target.FindStatus(effectType);
            if ((statusEffectData) && statusEffectData.count > 0)
            {
                result = statusEffectData.count;
            }
        }
        return result;
    }

    public int FindOnBoard()
    {
        int num = 0;
        if (health)
        {
            return num + Battle.GetCardsOnBoard().Sum((Entity e) => target.hp.current);
        }
        return num + (from entity in Battle.GetCardsOnBoard()
                      select entity.FindStatus(effectType) into effect
                      where (effect) && effect.count > 0
                      select effect).Sum((StatusEffectData effect) => effect.count);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Change Recycle Requirement", fileName = "Change Recycle Requirement")]
public class StatusEffectChangeRecycleRequirement : StatusEffectData
{
    [SerializeField]
    public bool lower = true;

    public override void Init()
    {
        Events.OnCheckRecycleAmount += CheckRecycleAmount;
    }

    public void OnDestroy()
    {
        Events.OnCheckRecycleAmount -= CheckRecycleAmount;
    }

    public void CheckRecycleAmount(ref Entity entity, ref int amount)
    {
        if (!(entity != target))
        {
            int amount2 = GetAmount();
            amount = Mathf.Max(0, lower ? (amount - amount2) : (amount + amount2));
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Draw When Deployed", fileName = "Draw When Deployed")]
public class StatusEffectDeployDraw : StatusEffectData
{
    public override bool RunCardMoveEvent(Entity entity)
    {
        CardContainer[] preContainers = entity.preContainers;
        if (entity == target && (IArrayExt.Contains<CardContainer>(preContainers, target.owner.handContainer) || IArrayExt.Contains<CardContainer>(preContainers, target.owner.reserveContainer)) && Battle.IsOnBoard(entity))
        {
            ActionQueue.Stack(new ActionDraw(target.owner, GetAmount()));
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Destroy Self After Turn", fileName = "Destroy Self After Turn")]
public class StatusEffectDestroySelfAfterTurn : StatusEffectData
{
    public bool cardPlayed;

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (!cardPlayed && entity == target && !target.silenced)
        {
            ActionQueue.Add(new ActionKill(entity));
            cardPlayed = true;
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Double All X When Destroyed", fileName = "Double All X When Destroyed")]
public class StatusEffectDoubleAllXWhenDestroyed : StatusEffectData
{
    [SerializeField]
    public StatusEffectData effectToDouble;

    public override void Init()
    {
        base.OnEntityDestroyed += DestroyCheck;
    }

    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        return entity == target;
    }

    public IEnumerator DestroyCheck(Entity entity, DeathType deathType)
    {
        List<Entity> allCards = Battle.GetAllCards();
        foreach (Entity item in allCards)
        {
            if (((Behaviour)item).enabled)
            {
                StatusEffectData statusEffectData = item.FindStatus(effectToDouble.type);
                if (statusEffectData != null)
                {
                    Hit hit = new Hit(target, item, 0);
                    hit.AddStatusEffect(effectToDouble, statusEffectData.count);
                    yield return hit.Process();
                }
            }
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Draw On Kill", fileName = "Draw On Kill")]
public class StatusEffectDrawOnKill : StatusEffectData
{
    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        if (entity.lastHit != null && entity.lastHit.attacker == target)
        {
            ActionQueue.Stack(new ActionDraw(target.owner, GetAmount()));
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Halt X", fileName = "Halt X")]
public class StatusEffectHaltX : StatusEffectData
{
    [SerializeField]
    public StatusEffectData effectToHalt;

    [SerializeField]
    public bool ignoreSilence = true;

    public override void Init()
    {
        Debug.Log($"→ Halting Count Down of [{(effectToHalt).name}] for [{target}]");
        Events.OnStatusEffectCountDown += StatusCountDown;
    }

    public void OnDestroy()
    {
        Debug.Log($"→ Resuming Count Down of [{(effectToHalt).name}] for [{target}]");
        Events.OnStatusEffectCountDown -= StatusCountDown;
    }

    public void StatusCountDown(StatusEffectData status, ref int amount)
    {
        if (status.type == effectToHalt.type && status.target == target && !Silenced())
        {
            amount = 0;
        }
    }

    public bool Silenced()
    {
        if (target.silenced)
        {
            return !ignoreSilence;
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Hit Allies In Row", fileName = "Hit Allies In Row")]
public class StatusEffectHitAlliesInRow : StatusEffectData
{
    public override void Init()
    {
        base.PostAttack += CheckHit;
    }

    public override bool RunPostAttackEvent(Hit hit)
    {
        if (hit.attacker == target)
        {
            return hit.target != null;
        }
        return false;
    }

    public IEnumerator CheckHit(Hit hit)
    {
        List<Entity> alliesInRow = hit.target.GetAlliesInRow();
        foreach (Entity item in alliesInRow)
        {
            Hit hit2 = new Hit(target, item, GetAmount());
            yield return hit2.Process();
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Hit Allies In Row And Self", fileName = "Hit Allies In Row And Self")]
public class StatusEffectHitAlliesInRowAndSelf : StatusEffectData
{
    public override void Init()
    {
        base.PostAttack += CheckHit;
    }

    public override bool RunPostAttackEvent(Hit hit)
    {
        return hit.attacker == target;
    }

    public IEnumerator CheckHit(Hit hit)
    {
        List<Entity> alliesInRow = target.GetAlliesInRow();
        foreach (Entity item in alliesInRow)
        {
            Hit hit2 = new Hit(target, item);
            hit2.AddAttackerStatuses();
            yield return hit2.Process();
        }
        Hit hit3 = new Hit(target, target)
        {
            doAnimation = false
        };
        hit3.AddAttackerStatuses();
        yield return hit3.Process();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Increase Attack While Damaged", fileName = "Increase Attack While Damaged")]
public class StatusEffectIncreaseAttackWhileDamaged : StatusEffectData
{
    [SerializeField]
    public StatusEffectData effectToGain;

    public int currentAmount;

    public bool active;

    public override bool HasEnableRoutine => true;

    public override bool HasDisableRoutine => true;

    public override bool HasPostHitRoutine => true;

    public override bool RunEnableEvent(Entity entity)
    {
        return entity == target;
    }

    public override IEnumerator EnableRoutine(Entity entity)
    {
        return Check();
    }

    public override bool RunDisableEvent(Entity entity)
    {
        if (entity == target)
        {
            return currentAmount != 0;
        }
        return false;
    }

    public override IEnumerator DisableRoutine(Entity entity)
    {
        return Deactivate();
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        return hit.target == target;
    }

    public override IEnumerator PostHitRoutine(Hit hit)
    {
        return Check();
    }

    public IEnumerator Check()
    {
        if (!target.alive)
        {
            yield break;
        }
        if (!active)
        {
            if (target.hp.current < target.hp.max)
            {
                yield return Activate();
            }
        }
        else if (target.hp.current >= target.hp.max)
        {
            yield return Deactivate();
        }
    }

    public IEnumerator Activate()
    {
        currentAmount = GetAmount();
        yield return StatusEffectSystem.Apply(target, target, effectToGain, currentAmount, temporary: true);
        active = true;
    }

    public IEnumerator Deactivate()
    {
        for (int num = target.statusEffects.Count - 1; num >= 0; num--)
        {
            StatusEffectData statusEffectData = target.statusEffects[num];
            if ((statusEffectData) && (statusEffectData).name == (effectToGain).name)
            {
                yield return statusEffectData.RemoveStacks(currentAmount, removeTemporary: true);
                break;
            }
        }
        currentAmount = 0;
        active = false;
    }

    public override bool RunEffectBonusChangedEvent()
    {
        if (((Behaviour)target).enabled && active)
        {
            ActionQueue.Add(new ActionSequence(ReAffect()));
        }
        return false;
    }

    public IEnumerator ReAffect()
    {
        yield return Deactivate();
        yield return Activate();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Increase Count Down", fileName = "Increase Count Down")]
public class StatusEffectIncreaseCountDown : StatusEffectData
{
    public override void Init()
    {
        Events.OnEntityCountDown += EntityCountDown;
    }

    public void OnDestroy()
    {
        Events.OnEntityCountDown -= EntityCountDown;
    }

    public void EntityCountDown(Entity entity, ref int amount)
    {
        if (entity == target)
        {
            amount += GetAmount();
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Remove Effects", fileName = "Remove Effects")]
public class StatusEffectRemoveEffects : StatusEffectData
{
    public override bool RunBeginEvent()
    {
        //IL_00c1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
        if (target.data.playType != Card.PlayType.Place)
        {
            target.data.playType = Card.PlayType.Play;
            target.data.needsTarget = true;
            target.data.canPlayOnBoard = true;
            target.data.canPlayOnHand = false;
            target.data.canPlayOnFriendly = true;
            target.data.canPlayOnEnemy = true;
            target.data.playOnSlot = false;
            target.data.defaultPlayPosition = CardData.PlayPosition.None;
            target.data.targetConstraints = null;
            ((LocalizedReference)target.data.textKey).TableReference = default(TableReference);
            target.data.desc = "";
            target.display.promptUpdateDescription = true;
            target.PromptUpdate();
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/Shuffle Enemies And Allies", fileName = "Shuffle Enemies And Allies")]
public class StatusEffectShuffleEnemiesAndAllies : StatusEffectData
{
    public override void Init()
    {
        base.OnCardPlayed += Run;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        return entity == target;
    }

    public IEnumerator Run(Entity entity, Entity[] targets)
    {
        Debug.Log($"{this} Running...");
        List<CardContainer> rows = Battle.instance.GetRows(target.owner);
        rows.AddRange(Battle.instance.GetRows(Battle.GetOpponent(target.owner)));
        foreach (CardContainer item in rows)
        {
            List<Entity> list = new List<Entity>();
            foreach (Entity item2 in item)
            {
                list.Add(item2);
            }
            if (list.Count > 0)
            {
                IListExt.Shuffle<Entity>((IList<Entity>)list);
            }
            foreach (Entity item3 in list)
            {
                item.Remove(item3);
            }
            foreach (Entity item4 in list)
            {
                item.Add(item4);
            }
            item.TweenChildPositions();
        }
        target.curveAnimator.Ping();
        yield return Sequences.Wait(0.13f);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific Effects/Temporary Trait", fileName = "Temporary Trait")]
public class StatusEffectTemporaryTrait : StatusEffectData
{
    [SerializeField]
    public TraitData trait;

    public List<Entity.TraitStacks> silenced;

    public Entity.TraitStacks added;

    public int addedAmount;

    public TraitData Trait => trait;

    public override bool HasStackRoutine => true;

    public override bool HasEndRoutine => true;

    public override IEnumerator StackRoutine(int stacks)
    {
        added = target.GainTrait(trait, stacks, temporary: true);
        yield return target.UpdateTraits();
        addedAmount += stacks;
        target.display.promptUpdateDescription = true;
        target.PromptUpdate();
    }

    public override IEnumerator EndRoutine()
    {
        if ((target))
        {
            if (added != null)
            {
                added.count -= addedAmount;
                added.tempCount -= addedAmount;
            }
            addedAmount = 0;
            yield return target.UpdateTraits(added);
            target.display.promptUpdateDescription = true;
            target.PromptUpdate();
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/While Active Allies Immune To X", fileName = "While Active Allies Immune To X")]
public class StatusEffectWhileActiveAlliesImmuneToX : StatusEffectData
{
    public List<Entity> affected = new List<Entity>();

    public bool pingDone;

    [SerializeField]
    public StatusEffectData immunityEffect;

    public override void Init()
    {
        base.OnEnable += Enable;
        base.OnDisable += Disable;
        base.OnCardMove += CardMove;
    }

    public override bool RunEnableEvent(Entity entity)
    {
        return entity == target;
    }

    public IEnumerator Enable(Entity entity)
    {
        if (!pingDone)
        {
            target.curveAnimator?.Ping();
            pingDone = true;
        }
        List<Entity> allies = target.GetAllies();
        foreach (Entity item in allies)
        {
            yield return Affect(item);
        }
    }

    public override bool RunDisableEvent(Entity entity)
    {
        return entity == target;
    }

    public IEnumerator Disable(Entity entity)
    {
        foreach (Entity item in affected)
        {
            yield return UnAffect(item);
        }
        affected.Clear();
    }

    public override bool RunCardMoveEvent(Entity entity)
    {
        if (((Behaviour)target).enabled && entity != target && entity.owner == target.owner)
        {
            return Battle.IsOnBoard(entity);
        }
        return false;
    }

    public IEnumerator CardMove(Entity entity)
    {
        yield return Affect(entity);
    }

    public IEnumerator Affect(Entity entity)
    {
        if (!affected.Contains(entity))
        {
            yield return StatusEffectSystem.Apply(entity, target, immunityEffect, 1, temporary: true);
            entity.PromptUpdate();
            affected.Add(entity);
        }
    }

    public IEnumerator UnAffect(Entity entity)
    {
        if (!affected.Contains(entity))
        {
            yield break;
        }
        for (int i = entity.statusEffects.Count - 1; i >= 0; i--)
        {
            StatusEffectData statusEffectData = entity.statusEffects[i];
            if ((statusEffectData) && (statusEffectData).name == (immunityEffect).name)
            {
                yield return statusEffectData.RemoveStacks(1, removeTemporary: true);
            }
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/While Active X", fileName = "While Active X")]
public class StatusEffectWhileActiveX : StatusEffectApplyX
{
    [SerializeField]
    public bool ifCloneAffectOriginal = true;

    [SerializeField]
    public bool affectOthersWithSameEffect = true;

    public bool active;

    public int currentAmount;

    public readonly List<Entity> affected = new List<Entity>();

    public bool pingDone;

    public readonly List<CardContainer> containersToAffect = new List<CardContainer>();

    public bool affectsSelf;

    public bool targetIsClone;

    public ulong cloneOriginalId;

    public bool AffectsRow()
    {
        if (!applyToFlags.HasFlag(ApplyToFlags.AlliesInRow) && !applyToFlags.HasFlag(ApplyToFlags.EnemiesInRow) && !applyToFlags.HasFlag(ApplyToFlags.FrontAlly) && !applyToFlags.HasFlag(ApplyToFlags.BackAlly))
        {
            return applyToFlags.HasFlag(ApplyToFlags.FrontEnemy);
        }
        return true;
    }

    public bool AffectsSlot()
    {
        if (!applyToFlags.HasFlag(ApplyToFlags.AllyInFrontOf) && !applyToFlags.HasFlag(ApplyToFlags.AllyBehind) && !applyToFlags.HasFlag(ApplyToFlags.FrontAlly))
        {
            return applyToFlags.HasFlag(ApplyToFlags.BackAlly);
        }
        return true;
    }

    public override void Init()
    {
        base.OnBegin += Begin;
        base.OnEnable += Enable;
        base.OnDisable += Disable;
        base.OnCardMove += CardMove;
        base.OnEffectBonusChanged += EffectBonusChanged;
        Events.OnEntityDataUpdated += EntityDataUpdated;
        Events.OnEntityDisplayUpdated += EntityDisplayUpdated;
        pingDone = !doPing;
        targetIsClone = target.data.TryGetCustomData("splitOriginalId", out cloneOriginalId, 0uL);
    }

    public virtual void OnDestroy()
    {
        Events.OnEntityDataUpdated -= EntityDataUpdated;
        Events.OnEntityDisplayUpdated -= EntityDisplayUpdated;
    }

    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        int num = affected.IndexOf(entity);
        if (num >= 0)
        {
            affected.RemoveAt(num);
        }
        return false;
    }

    public void EntityDataUpdated(Entity entity)
    {
        if (active && affected.Contains(entity))
        {
            ActionQueue.Add(new ActionSequence(ReAffect(entity)));
        }
    }

    public void EntityDisplayUpdated(Entity entity)
    {
        if (active && entity == target && GetAmount(target) != currentAmount)
        {
            ActionQueue.Add(new ActionRefreshWhileActiveEffect(this));
        }
    }

    public virtual bool CanActivate()
    {
        return Battle.IsOnBoard(target);
    }

    public virtual bool CheckActivateOnMove(CardContainer[] fromContainers, CardContainer[] toContainers)
    {
        if (Battle.IsOnBoard(toContainers))
        {
            return !Battle.IsOnBoard(fromContainers);
        }
        return false;
    }

    public virtual bool CheckDeactivateOnMove(CardContainer[] fromContainers, CardContainer[] toContainers)
    {
        if (!Battle.IsOnBoard(toContainers))
        {
            return Battle.IsOnBoard(fromContainers);
        }
        return false;
    }

    public static bool CompareContainerArrays(IReadOnlyList<CardContainer> a, IReadOnlyList<CardContainer> b)
    {
        if (a.Count != b.Count)
        {
            return false;
        }
        for (int i = 0; i < a.Count; i++)
        {
            if (a[i] != b[i])
            {
                return false;
            }
        }
        return true;
    }

    public override bool RunBeginEvent()
    {
        if (((Behaviour)target).enabled)
        {
            return CanActivate();
        }
        return false;
    }

    public IEnumerator Begin()
    {
        return Activate();
    }

    public override bool RunEnableEvent(Entity entity)
    {
        if (!active)
        {
            if (entity == target)
            {
                return CanActivate();
            }
            return false;
        }
        return false;
    }

    public IEnumerator Enable(Entity entity)
    {
        return Activate();
    }

    public override bool RunDisableEvent(Entity entity)
    {
        return entity == target;
    }

    public virtual IEnumerator Disable(Entity entity)
    {
        return Deactivate();
    }

    public override bool RunCardMoveEvent(Entity entity)
    {
        if (((Behaviour)target).enabled)
        {
            if (!(target == entity))
            {
                return active;
            }
            return true;
        }
        return false;
    }

    public virtual IEnumerator CardMove(Entity entity)
    {
        if (target == entity)
        {
            CardContainer[] preContainers = entity.preContainers;
            if (active)
            {
                if (CheckDeactivateOnMove(preContainers, entity.containers))
                {
                    yield return Deactivate();
                }
                else if (AffectsRow())
                {
                    if (!CompareContainerArrays(preContainers, entity.containers))
                    {
                        yield return Deactivate();
                        yield return Activate();
                    }
                }
                else if (AffectsSlot())
                {
                    yield return Deactivate();
                    yield return Activate();
                }
            }
            else if (CheckActivateOnMove(preContainers, entity.containers))
            {
                yield return Activate();
            }
        }
        else
        {
            if (!active)
            {
                yield break;
            }
            if (AffectsSlot())
            {
                CardContainer[] array = containersToAffect.Select((CardContainer a) => a.Group).ToArray();
                if (IListExt.ContainsAny<CardContainer>((IList<CardContainer>)entity.containers, (IEnumerable<CardContainer>)array) || IListExt.ContainsAny<CardContainer>((IList<CardContainer>)entity.preContainers, (IEnumerable<CardContainer>)array))
                {
                    yield return Deactivate();
                    yield return Activate();
                }
            }
            else if (affected.Contains(entity))
            {
                if (!IListExt.ContainsAny<CardContainer>((IList<CardContainer>)containersToAffect, (IEnumerable<CardContainer>)entity.containers))
                {
                    yield return UnAffect(entity);
                }
            }
            else if (IListExt.ContainsAny<CardContainer>((IList<CardContainer>)containersToAffect, (IEnumerable<CardContainer>)entity.containers))
            {
                yield return Affect(entity);
            }
        }
    }

    public override bool RunEffectBonusChangedEvent()
    {
        if (((Behaviour)target).enabled)
        {
            return active;
        }
        return false;
    }

    public IEnumerator EffectBonusChanged()
    {
        ActionQueue.Add(new ActionRefreshWhileActiveEffect(this));
        yield break;
    }

    public IEnumerator Activate()
    {
        active = true;
        if (!pingDone)
        {
            target.curveAnimator?.Ping();
            pingDone = true;
        }
        currentAmount = GetAmount(target);
        FindContainers();
        List<Entity> list = new List<Entity>();
        if (affectsSelf)
        {
            list.Add(target);
        }
        foreach (CardContainer item in containersToAffect)
        {
            foreach (Entity item2 in item)
            {
                if (!list.Contains(item2) && item2 != target)
                {
                    list.Add(item2);
                }
            }
        }
        Routine.Clump clump = new Routine.Clump();
        foreach (Entity item3 in list)
        {
            clump.Add(Affect(item3));
        }
        yield return clump.WaitForEnd();
    }

    public IEnumerator Deactivate()
    {
        active = false;
        Routine.Clump clump = new Routine.Clump();
        foreach (Entity item in affected)
        {
            clump.Add(UnAffect(item));
        }
        yield return clump.WaitForEnd();
        affected.Clear();
    }

    public void FindContainers()
    {
        containersToAffect.Clear();
        Character opponent = Battle.GetOpponent(target.owner);
        int[] rowIndices = Battle.instance.GetRowIndices(target);
        affectsSelf = AppliesTo(ApplyToFlags.Self);
        if (AppliesTo(ApplyToFlags.Allies))
        {
            containersToAffect.AddRange(Battle.instance.GetRows(target.owner));
        }
        else if (AppliesTo(ApplyToFlags.AlliesInRow))
        {
            int[] array = rowIndices;
            foreach (int rowIndex in array)
            {
                containersToAffect.Add(Battle.instance.GetRow(target.owner, rowIndex));
            }
        }
        else
        {
            if (AppliesTo(ApplyToFlags.FrontAlly))
            {
                int[] array = rowIndices;
                foreach (int rowIndex2 in array)
                {
                    if (Battle.instance.GetRow(target.owner, rowIndex2) is CardSlotLane cardSlotLane)
                    {
                        CardSlot cardSlot = cardSlotLane.slots.FirstOrDefault((CardSlot a) => !a.Empty);
                        IListExt.AddIfNotNull<CardContainer>((IList<CardContainer>)containersToAffect, (CardContainer)cardSlot);
                    }
                }
            }
            if (AppliesTo(ApplyToFlags.BackAlly))
            {
                int[] array = rowIndices;
                foreach (int rowIndex3 in array)
                {
                    if (Battle.instance.GetRow(target.owner, rowIndex3) is CardSlotLane cardSlotLane2)
                    {
                        CardSlot cardSlot2 = cardSlotLane2.slots.LastOrDefault((CardSlot a) => !a.Empty);
                        IListExt.AddIfNotNull<CardContainer>((IList<CardContainer>)containersToAffect, (CardContainer)cardSlot2);
                    }
                }
            }
            if (AppliesTo(ApplyToFlags.AllyInFrontOf))
            {
                int[] array = rowIndices;
                foreach (int rowIndex4 in array)
                {
                    if (!(Battle.instance.GetRow(target.owner, rowIndex4) is CardSlotLane cardSlotLane3))
                    {
                        continue;
                    }
                    for (int num = cardSlotLane3.IndexOf(target) - 1; num >= 0; num--)
                    {
                        CardSlot cardSlot3 = cardSlotLane3.slots[num];
                        if (!cardSlot3.Empty)
                        {
                            containersToAffect.Add(cardSlot3);
                            break;
                        }
                    }
                }
            }
            if (AppliesTo(ApplyToFlags.AllyBehind))
            {
                int[] array = rowIndices;
                foreach (int rowIndex5 in array)
                {
                    if (!(Battle.instance.GetRow(target.owner, rowIndex5) is CardSlotLane cardSlotLane4))
                    {
                        continue;
                    }
                    for (int j = cardSlotLane4.IndexOf(target) + 1; j < cardSlotLane4.slots.Count; j++)
                    {
                        CardSlot cardSlot4 = cardSlotLane4.slots[j];
                        if (!cardSlot4.Empty)
                        {
                            containersToAffect.Add(cardSlot4);
                            break;
                        }
                    }
                }
            }
        }
        if (AppliesTo(ApplyToFlags.Enemies))
        {
            containersToAffect.AddRange(Battle.instance.GetRows(opponent));
        }
        else if (AppliesTo(ApplyToFlags.EnemiesInRow))
        {
            int[] array = rowIndices;
            foreach (int rowIndex6 in array)
            {
                containersToAffect.Add(Battle.instance.GetRow(opponent, rowIndex6));
            }
        }
        if (AppliesTo(ApplyToFlags.Hand) && (References.Player))
        {
            IListExt.AddIfNotNull<CardContainer>((IList<CardContainer>)containersToAffect, References.Player.handContainer);
        }
        if (AppliesTo(ApplyToFlags.EnemyHand) && (opponent))
        {
            IListExt.AddIfNotNull<CardContainer>((IList<CardContainer>)containersToAffect, opponent.handContainer);
        }
    }

    public IEnumerator Affect(Entity entity)
    {
        if (affected.Contains(entity) || !effectToApply.CanPlayOn(entity))
        {
            yield break;
        }
        bool flag = false;
        if (targetIsClone && !ifCloneAffectOriginal)
        {
            if (entity.data.TryGetCustomData("splitOriginalId", out var value, 0uL) && cloneOriginalId == value)
            {
                flag = true;
            }
            else if (entity.data.id == cloneOriginalId)
            {
                flag = true;
            }
        }
        if (!flag && !affectOthersWithSameEffect)
        {
            foreach (StatusEffectData statusEffect in entity.statusEffects)
            {
                if ((statusEffect).name == name)
                {
                    flag = true;
                    break;
                }
            }
        }
        if (!flag && applyConstraints.All((TargetConstraint c) => c.Check(entity)))
        {
            affected.Add(entity);
            if (currentAmount > 0)
            {
                yield return StatusEffectSystem.Apply(entity, target, effectToApply, currentAmount, temporary: true);
                entity.PromptUpdate();
            }
        }
    }

    public IEnumerator UnAffect(Entity entity)
    {
        if (!affected.Contains(entity))
        {
            yield break;
        }
        for (int num = entity.statusEffects.Count - 1; num >= 0; num--)
        {
            StatusEffectData statusEffectData = entity.statusEffects[num];
            if ((statusEffectData) && (statusEffectData).name == (effectToApply).name)
            {
                yield return statusEffectData.RemoveStacks(currentAmount, removeTemporary: true);
                break;
            }
        }
        affected.Remove(entity);
    }

    public IEnumerator ReAffect(Entity entity)
    {
        if (affected.Contains(entity))
        {
            yield return UnAffect(entity);
            yield return Affect(entity);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/While In Hand X", fileName = "While In Hand X")]
public class StatusEffectWhileInHandX : StatusEffectWhileActiveX
{
    public override bool CanActivate()
    {
        return target.InHand();
    }

    public override bool CheckActivateOnMove(CardContainer[] fromContainers, CardContainer[] toContainers)
    {
        if (IArrayExt.Contains<CardContainer>(toContainers, target.owner.handContainer))
        {
            return !IArrayExt.Contains<CardContainer>(fromContainers, target.owner.handContainer);
        }
        return false;
    }

    public override bool CheckDeactivateOnMove(CardContainer[] fromContainers, CardContainer[] toContainers)
    {
        if (!IArrayExt.Contains<CardContainer>(toContainers, target.owner.handContainer))
        {
            return IArrayExt.Contains<CardContainer>(fromContainers, target.owner.handContainer);
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Specific/While Last In Hand X", fileName = "While Last In Hand X")]
public class StatusEffectWhileLastInHandX : StatusEffectWhileActiveX
{
    public bool isInHand;

    public override void Init()
    {
        base.Init();
        base.OnEntityDestroyed += EntityDestroyed;
    }

    public override bool CanActivate()
    {
        if (isInHand && target.owner.handContainer.FirstOrDefault((Entity a) => a.alive) == target)
        {
            return true;
        }
        return false;
    }

    public override bool RunBeginEvent()
    {
        isInHand = target.InHand();
        return base.RunBeginEvent();
    }

    public override bool RunEnableEvent(Entity entity)
    {
        if (target == entity)
        {
            isInHand = target.InHand();
        }
        return base.RunEnableEvent(entity);
    }

    public override bool RunCardMoveEvent(Entity entity)
    {
        return ((Behaviour)target).enabled;
    }

    public override IEnumerator CardMove(Entity entity)
    {
        if (target == entity)
        {
            isInHand = target.InHand();
        }
        if (active)
        {
            if ((target == entity || IArrayExt.Contains<CardContainer>(entity.containers, target.owner.handContainer)) && !CanActivate())
            {
                yield return Deactivate();
            }
        }
        else if (CanActivate())
        {
            yield return Activate();
        }
    }

    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        if (!active && entity != target)
        {
            return EntityInHand(entity);
        }
        return false;
    }

    public IEnumerator EntityDestroyed(Entity entity, DeathType deathType)
    {
        if (CanActivate())
        {
            yield return Activate();
        }
    }

    public bool EntityInHand(Entity entity)
    {
        if (entity.containers.Length == 0)
        {
            return IArrayExt.Contains<CardContainer>(entity.preContainers, target.owner.handContainer);
        }
        return IArrayExt.Contains<CardContainer>(entity.containers, target.owner.handContainer);
    }
}
public abstract class StatusEffect : ScriptableObject
{
    public StatusEffect()
    {
    }
}
[CreateAssetMenu(menuName = "Status Effects/Block", fileName = "Block")]
public class StatusEffectBlock : StatusEffectData
{
    public override void Init()
    {
        base.OnHit += Check;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.target == target && hit.Offensive && hit.canBeNullified)
        {
            return hit.damage > 0;
        }
        return false;
    }

    public IEnumerator Check(Hit hit)
    {
        SfxSystem.OneShot("event:/sfx/status_icon/block_decrease");
        hit.damageBlocked = hit.damage;
        hit.damage = 0;
        count--;
        if (count <= 0)
        {
            yield return Remove();
        }
        target.PromptUpdate();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Demonize", fileName = "Demonize")]
public class StatusEffectDemonize : StatusEffectData
{
    public override void Init()
    {
        base.OnHit += DemonizeHit;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.Offensive && count > 0 && hit.damage > 0)
        {
            return hit.target == target;
        }
        return false;
    }

    public IEnumerator DemonizeHit(Hit hit)
    {
        hit.damage = Mathf.RoundToInt((float)hit.damage * 2f);
        ActionQueue.Stack(new ActionSequence(CountDown())
        {
            fixedPosition = true,
            note = "Count Down Demonize"
        });
        yield break;
    }

    public IEnumerator CountDown()
    {
        if ((this) && (target) && target.alive)
        {
            int amount = 1;
            Events.InvokeStatusEffectCountDown(this, ref amount);
            if (amount != 0)
            {
                yield return CountDown(target, amount);
            }
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Focus", fileName = "Focus")]
public class StatusEffectFocus : StatusEffectData
{
    public override void Init()
    {
        base.PostApplyStatus += ApplyStatus;
    }

    public override bool RunPostApplyStatusEvent(StatusEffectApply apply)
    {
        if ((apply.effectData) && apply.count > 0 && apply.effectData.type == type)
        {
            return apply.target != target;
        }
        return false;
    }

    public IEnumerator ApplyStatus(StatusEffectApply apply)
    {
        int amount = count;
        Events.InvokeStatusEffectCountDown(this, ref amount);
        if (amount != 0)
        {
            yield return CountDown(target, amount);
        }
    }

    public override bool RunPreTriggerEvent(Trigger trigger)
    {
        if (!trigger.nullified && trigger.countsAsTrigger && trigger.entity.owner.team != target.owner.team && trigger.type == "basic" && Battle.IsOnBoard(trigger.entity))
        {
            trigger.targets = trigger.entity.targetMode.GetTargets(trigger.entity, target, IArrayExt.RandomItem<CardContainer>(target.containers));
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Frost", fileName = "Frost")]
public class StatusEffectFrost : StatusEffectData
{
    public int toClear;

    public int current;

    public int addedThisTurn;

    public override void Init()
    {
        base.OnActionPerformed += ActionPerformed;
    }

    public override bool RunPreTriggerEvent(Trigger trigger)
    {
        if (trigger.entity == target)
        {
            addedThisTurn = 0;
        }
        return false;
    }

    public override bool RunStackEvent(int stacks)
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        current += stacks;
        Entity entity = target;
        entity.tempDamage -= stacks;
        addedThisTurn += stacks;
        return false;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (toClear == 0 && entity == target && count > 0 && targets != null && targets.Length > 0)
        {
            toClear = current - addedThisTurn;
        }
        return false;
    }

    public override bool RunActionPerformedEvent(PlayAction action)
    {
        if (toClear > 0)
        {
            return ActionQueue.Empty;
        }
        return false;
    }

    public IEnumerator ActionPerformed(PlayAction action)
    {
        yield return Clear(toClear);
        toClear = 0;
    }

    public IEnumerator Clear(int amount)
    {
        Events.InvokeStatusEffectCountDown(this, ref amount);
        if (amount != 0)
        {
            current -= amount;
            Entity entity = target;
            entity.tempDamage += amount;
            yield return CountDown(target, amount);
        }
    }

    public override bool RunEndEvent()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        Entity entity = target;
        entity.tempDamage += current;
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Haze", fileName = "Haze")]
public class StatusEffectHaze : StatusEffectData
{
    public override void Init()
    {
        base.PreTrigger += EntityPreTrigger;
    }

    public override bool RunPreTriggerEvent(Trigger trigger)
    {
        if (trigger.entity == target)
        {
            return trigger.type != "haze";
        }
        return false;
    }

    public IEnumerator EntityPreTrigger(Trigger trigger)
    {
        if (TryTargetRandomAlly(trigger))
        {
            trigger.type = "haze";
        }
        else
        {
            trigger.nullified = true;
            if (NoTargetTextSystem.Exists())
            {
                yield return NoTargetTextSystem.Run(target, NoTargetType.NoAllyToAttack);
            }
        }
        yield return RemoveStacks(1, removeTemporary: false);
    }

    public bool TryTargetRandomAlly(Trigger trigger)
    {
        bool result = false;
        Entity randomAlly = GetRandomAlly();
        if ((randomAlly))
        {
            CardContainer targetContainer = IArrayExt.RandomItem<CardContainer>(randomAlly.containers);
            Entity[] subsequentTargets = target.targetMode.GetSubsequentTargets(trigger.entity, randomAlly, targetContainer);
            trigger.targets = subsequentTargets;
            result = true;
        }
        return result;
    }

    public Entity GetRandomAlly()
    {
        List<Entity> allAllies = target.GetAllAllies();
        if (allAllies.Count > 0)
        {
            return IListExt.RandomItem<Entity>((IList<Entity>)allAllies);
        }
        return null;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Ink", fileName = "Ink")]
public class StatusEffectInk : StatusEffectData
{
    public bool primed;

    public override void Init()
    {
        base.OnCardPlayed += Check;
    }

    public override bool RunPreCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (!primed && ((Behaviour)target).enabled && entity == target)
        {
            primed = true;
        }
        return false;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (primed && ((Behaviour)target).enabled)
        {
            return entity == target;
        }
        return false;
    }

    public IEnumerator Check(Entity entity, Entity[] targets)
    {
        Hit hit = new Hit(target, target);
        hit.AddAttackerStatuses();
        ActionQueue.Stack(new ActionSequence(CountDown()), fixedPosition: true);
        yield return hit.Process();
    }

    public IEnumerator CountDown()
    {
        int amount = 1;
        Events.InvokeStatusEffectCountDown(this, ref amount);
        if (amount != 0)
        {
            yield return CountDown(target, amount);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Juice", fileName = "Juice")]
public class StatusEffectJuice : StatusEffectData
{
}
[CreateAssetMenu(menuName = "Status Effects/Lumin", fileName = "Lumin")]
public class StatusEffectLumin : StatusEffectData
{
    public override bool RunPostApplyStatusEvent(StatusEffectApply apply)
    {
        if ((apply.effectData) && apply.count > 0 && apply.effectData.type == type && apply.target != target)
        {
            ActionQueue.Stack(new ActionSequence(Remove())
            {
                note = "Remove Lumin from [" + (target).name + "]"
            }, fixedPosition: true);
        }
        return false;
    }

    public override bool RunBeginEvent()
    {
        target.effectFactor += 1f;
        return false;
    }

    public override bool RunEndEvent()
    {
        target.effectFactor -= 1f;
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Multi Hit", fileName = "Multi Hit")]
public class StatusEffectMultiHit : StatusEffectData
{
    [SerializeField]
    public bool clearAfter;

    public int attackCount;

    public Trigger originalTrigger;

    public List<ActionTrigger> additionalTriggers;

    public override void Init()
    {
        Events.OnEntityTrigger += EntityTrigger;
    }

    public void OnDestroy()
    {
        Events.OnEntityTrigger -= EntityTrigger;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (entity == target && target.alive && ((Behaviour)target).enabled)
        {
            attackCount--;
            if (entity.IsSnowed)
            {
                attackCount = 0;
            }
            if (attackCount <= 0)
            {
                Cancel();
            }
        }
        return false;
    }

    public void EntityTrigger(ref Trigger trigger)
    {
        if (trigger.entity != target || !trigger.countsAsTrigger)
        {
            return;
        }
        if (originalTrigger != null)
        {
            if (target.IsSnowed)
            {
                Cancel();
            }
            return;
        }
        attackCount = 1;
        originalTrigger = trigger;
        if (trigger.triggerAgainst)
        {
            for (int i = 0; i < count; i++)
            {
                AddTrigger(new ActionTriggerSubsequent(target, null, trigger.triggerAgainstTarget, trigger.triggerAgainstContainer)
                {
                    note = "[" + (target).name + "] Frenzy"
                });
            }
        }
        else
        {
            for (int j = 0; j < count; j++)
            {
                AddTrigger(new ActionTrigger(target, null)
                {
                    note = "[" + (target).name + "] Frenzy"
                });
            }
        }
    }

    public void Cancel()
    {
        attackCount = 0;
        originalTrigger = null;
        if (additionalTriggers != null)
        {
            foreach (ActionTrigger additionalTrigger in additionalTriggers)
            {
                ActionQueue.Remove(additionalTrigger);
            }
        }
        additionalTriggers = null;
        if (clearAfter)
        {
            ActionQueue.Stack(new ActionSequence(Clear())
            {
                note = "Clear Temporary MultiHit"
            }, fixedPosition: true);
        }
    }

    public void AddTrigger(ActionTrigger trigger)
    {
        ActionQueue.Stack(trigger);
        if (additionalTriggers == null)
        {
            additionalTriggers = new List<ActionTrigger>();
        }
        additionalTriggers.Add(trigger);
        attackCount++;
    }

    public IEnumerator Clear()
    {
        int amount = count;
        Events.InvokeStatusEffectCountDown(this, ref amount);
        if (amount != 0)
        {
            yield return CountDown(target, amount);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Null", fileName = "Null")]
public class StatusEffectNull : StatusEffectData
{
    public bool primed;

    public override void Init()
    {
        base.OnTurnEnd += TurnEnd;
    }

    public override bool RunBeginEvent()
    {
        target.silenceCount++;
        return false;
    }

    public override bool RunEndEvent()
    {
        target.silenceCount--;
        return false;
    }

    public override bool RunTurnStartEvent(Entity entity)
    {
        if (!primed && entity == target && Battle.IsOnBoard(entity))
        {
            primed = true;
        }
        return false;
    }

    public override bool RunTurnEndEvent(Entity entity)
    {
        if (entity == target)
        {
            return primed;
        }
        return false;
    }

    public IEnumerator TurnEnd(Entity entity)
    {
        int amount = 1;
        Events.InvokeStatusEffectCountDown(this, ref amount);
        if (amount != 0)
        {
            yield return CountDown(entity, amount);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Overload", fileName = "Overload")]
public class StatusEffectOverload : StatusEffectData
{
    [SerializeField]
    public CardAnimation buildupAnimation;

    public bool overloading;

    public override void Init()
    {
        base.OnStack += Stack;
        Events.OnEntityDisplayUpdated += EntityDisplayUpdated;
    }

    public void OnDestroy()
    {
        Events.OnEntityDisplayUpdated -= EntityDisplayUpdated;
    }

    public void EntityDisplayUpdated(Entity entity)
    {
        if (entity == target && ((Behaviour)target).enabled)
        {
            Check();
        }
    }

    public IEnumerator Stack(int stacks)
    {
        Check();
        yield return null;
    }

    public void Check()
    {
        if (count >= target.hp.current && !overloading)
        {
            ActionQueue.Stack(new ActionSequence(DealDamage())
            {
                fixedPosition = true,
                priority = eventPriority,
                note = "Overload"
            });
            ActionQueue.Stack(new ActionSequence(Clear())
            {
                fixedPosition = true,
                priority = eventPriority,
                note = "Clear Overload"
            });
            overloading = true;
        }
    }

    public IEnumerator DealDamage()
    {
        if (!(this) || !(target) || !target.alive)
        {
            yield break;
        }
        HashSet<Entity> targets = new HashSet<Entity>();
        CardContainer[] containers = target.containers;
        foreach (CardContainer cardContainer in containers)
        {
            HashSetExt.AddRange<Entity>(targets, (IEnumerable<Entity>)cardContainer);
        }
        if ((buildupAnimation))
        {
            yield return buildupAnimation.Routine(target);
        }
        Entity damager = GetDamager();
        Routine.Clump clump = new Routine.Clump();
        foreach (Entity item in targets)
        {
            Hit hit = new Hit(damager, item, count)
            {
                damageType = "overload"
            };
            clump.Add(hit.Process());
        }
        clump.Add(Sequences.Wait(0.5f));
        yield return clump.WaitForEnd();
    }

    public IEnumerator Clear()
    {
        if ((this) && (target) && target.alive)
        {
            yield return Remove();
            overloading = false;
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Scrap", fileName = "Scrap")]
public class StatusEffectScrap : StatusEffectData
{
    public override void Init()
    {
        base.OnHit += Check;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.target == target && hit.damage > 0)
        {
            return !hit.nullified;
        }
        return false;
    }

    public IEnumerator Check(Hit hit)
    {
        hit.damageBlocked = hit.damage;
        hit.damage = 0;
        count--;
        if (count <= 0)
        {
            yield return Remove();
        }
        target.PromptUpdate();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Shell", fileName = "Shell")]
public class StatusEffectShell : StatusEffectData
{
    public override void Init()
    {
        base.OnHit += Check;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.target == target)
        {
            return hit.damage > 0;
        }
        return false;
    }

    public IEnumerator Check(Hit hit)
    {
        while (hit.damage > 0 && count > 0)
        {
            count--;
            hit.damage--;
            hit.damageBlocked++;
        }
        if (count <= 0)
        {
            yield return Remove();
        }
        target.PromptUpdate();
    }
}
[CreateAssetMenu(menuName = "Status Effects/Shroom", fileName = "Shroom")]
public class StatusEffectShroom : StatusEffectData
{
    public bool subbed;

    public bool primed;

    public override void Init()
    {
        base.OnTurnEnd += DealDamage;
        Events.OnPostProcessUnits += Prime;
        subbed = true;
    }

    public void OnDestroy()
    {
        Unsub();
    }

    public void Unsub()
    {
        if (subbed)
        {
            Events.OnPostProcessUnits -= Prime;
            subbed = false;
        }
    }

    public void Prime(Character character)
    {
        primed = true;
        Unsub();
    }

    public override bool RunTurnEndEvent(Entity entity)
    {
        if (primed && ((Behaviour)target).enabled)
        {
            return entity == target;
        }
        return false;
    }

    public IEnumerator DealDamage(Entity entity)
    {
        Hit hit = new Hit(GetDamager(), target, count)
        {
            screenShake = 0.25f,
            damageType = "shroom"
        };
        yield return hit.Process();
        yield return Sequences.Wait(0.2f);
        int amount = 1;
        Events.InvokeStatusEffectCountDown(this, ref amount);
        if (amount != 0)
        {
            yield return CountDown(entity, amount);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Silence", fileName = "Silence")]
public class StatusEffectSilence : StatusEffectData
{
    public override void Init()
    {
        base.OnTurnEnd += CustomCountDown;
    }

    public override bool RunBeginEvent()
    {
        target.silenceCount++;
        target.PromptUpdate();
        return false;
    }

    public override bool RunTurnEndEvent(Entity entity)
    {
        if (entity == target)
        {
            return ((Behaviour)target).enabled;
        }
        return false;
    }

    public IEnumerator CustomCountDown(Entity entity)
    {
        int amount = 1;
        Events.InvokeStatusEffectCountDown(this, ref amount);
        if (amount != 0)
        {
            yield return CountDown(entity, amount);
        }
    }

    public override bool RunEndEvent()
    {
        target.silenceCount--;
        target.PromptUpdate();
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Snow", fileName = "Snow")]
public class StatusEffectSnow : StatusEffectData
{
    public enum CountDownType
    {
        OnCounter,
        OnTurnEnd
    }

    [SerializeField]
    public CountDownType countDownType;

    public bool primed;

    public override void Init()
    {
        base.OnHit += Hit;
        base.OnTurnEnd += CustomCountDown;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.target == target)
        {
            return hit.counterReduction > 0;
        }
        return false;
    }

    public IEnumerator Hit(Hit hit)
    {
        while (hit.counterReduction > 0 && count > 0)
        {
            if (countDownType == CountDownType.OnCounter)
            {
                count--;
            }
            hit.counterReduction--;
        }
        if (count <= 0)
        {
            yield return Remove();
        }
    }

    public override bool RunTurnStartEvent(Entity entity)
    {
        if (!primed && entity == target && countDownType == CountDownType.OnTurnEnd && Battle.IsOnBoard(entity))
        {
            primed = true;
        }
        return false;
    }

    public override bool RunTurnEndEvent(Entity entity)
    {
        if (entity == target && primed)
        {
            return countDownType == CountDownType.OnTurnEnd;
        }
        return false;
    }

    public IEnumerator CustomCountDown(Entity entity)
    {
        int amount = 1;
        Events.InvokeStatusEffectCountDown(this, ref amount);
        if (amount != 0)
        {
            yield return CountDown(entity, amount);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Spice", fileName = "Spice")]
public class StatusEffectSpice : StatusEffectData
{
    public bool cardPlayed;

    public int current;

    public int amountToClear;

    public override void Init()
    {
        base.OnActionPerformed += ActionPerformed;
    }

    public override bool RunStackEvent(int stacks)
    {
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        current += stacks;
        Entity entity = target;
        entity.tempDamage += stacks;
        return false;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (!cardPlayed && entity == target && count > 0 && targets != null && targets.Length != 0)
        {
            cardPlayed = true;
            amountToClear = current;
        }
        return false;
    }

    public override bool RunActionPerformedEvent(PlayAction action)
    {
        if (cardPlayed)
        {
            return ActionQueue.Empty;
        }
        return false;
    }

    public IEnumerator ActionPerformed(PlayAction action)
    {
        cardPlayed = false;
        yield return Clear(amountToClear);
    }

    public IEnumerator Clear(int amount)
    {
        int amount2 = amount;
        Events.InvokeStatusEffectCountDown(this, ref amount2);
        if (amount2 != 0)
        {
            current -= amount2;
            Entity entity = target;
            entity.tempDamage -= amount2;
            yield return CountDown(target, amount2);
        }
    }

    public override bool RunEndEvent()
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        Entity entity = target;
        entity.tempDamage -= current;
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Spikes", fileName = "Spikes")]
public class StatusEffectSpikes : StatusEffectData
{
    public override void Init()
    {
        base.PostHit += Check;
    }

    public override bool RunPostHitEvent(Hit hit)
    {
        if (hit.target == target && hit.canRetaliate && hit.Offensive && hit.BasicHit)
        {
            return hit.attacker != target;
        }
        return false;
    }

    public IEnumerator Check(Hit hit)
    {
        if ((hit.attacker) && hit.attacker.canBeHit)
        {
            Hit hit2 = new Hit(target, hit.attacker, count)
            {
                canRetaliate = false,
                damageType = "spikes"
            };
            yield return hit2.Process();
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Stealth", fileName = "Stealth")]
public class StatusEffectStealth : StatusEffectData
{
    public bool cardPlayed;

    public override void Init()
    {
        base.OnActionPerformed += ActionPerformed;
    }

    public override bool RunBeginEvent()
    {
        target.cannotBeHitCount++;
        return false;
    }

    public override bool RunEndEvent()
    {
        target.cannotBeHitCount--;
        return false;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (!cardPlayed && entity == target && count > 0 && targets != null && targets.Length != 0)
        {
            cardPlayed = true;
        }
        return false;
    }

    public override bool RunActionPerformedEvent(PlayAction action)
    {
        if (cardPlayed)
        {
            return ActionQueue.Empty;
        }
        return false;
    }

    public IEnumerator ActionPerformed(PlayAction action)
    {
        yield return CountDown();
    }

    public IEnumerator CountDown()
    {
        int amount = 1;
        Events.InvokeStatusEffectCountDown(this, ref amount);
        if (amount != 0)
        {
            yield return CountDown(target, amount);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Summon", fileName = "Summon")]
public class StatusEffectSummon : StatusEffectData
{
    public CardData summonCard;

    public StatusEffectData gainTrait;

    public CardType setCardType;

    [SerializeField]
    public AssetReference effectPrefabRef;

    public bool unsubRequired;

    public CardSlot[] toSummon;

    public override void Init()
    {
        if (target.data.playOnSlot)
        {
            Events.OnActionPerform += ActionPerform;
            unsubRequired = true;
        }
        base.OnCardPlayed += CardPlayed;
    }

    public void OnDestroy()
    {
        if (unsubRequired)
        {
            Events.OnActionPerform -= ActionPerform;
        }
    }

    public void ActionPerform(PlayAction action)
    {
        if (target.silenced || !(action is ActionTriggerAgainst actionTriggerAgainst) || !(actionTriggerAgainst.targetContainer) || !(actionTriggerAgainst.entity == target))
        {
            return;
        }
        CardContainer targetContainer = actionTriggerAgainst.targetContainer;
        if (!(targetContainer is CardSlot cardSlot))
        {
            if (targetContainer is CardSlotLane row)
            {
                toSummon = target.targetMode.GetTargetSlots(row);
            }
        }
        else
        {
            toSummon = new CardSlot[1] { cardSlot };
        }
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (entity == target)
        {
            return !target.silenced;
        }
        return false;
    }

    public IEnumerator CardPlayed(Entity entity, Entity[] targets)
    {
        if (toSummon == null)
        {
            HashSet<CardContainer> hashSet = new HashSet<CardContainer>();
            HashSetExt.AddRange<CardContainer>(hashSet, (IEnumerable<CardContainer>)entity.actualContainers);
            if (hashSet.Count > 0 && IArrayExt.RandomItem<CardContainer>(HashSetExt.ToArray<CardContainer>(hashSet)) is CardSlot cardSlot)
            {
                toSummon = new CardSlot[1] { cardSlot };
            }
        }
        if (toSummon != null && toSummon.Length != 0)
        {
            CardController controller = target.display.hover.controller;
            target.curveAnimator.Ping();
            CardSlot[] array = toSummon;
            foreach (CardSlot container in array)
            {
                yield return TrySummon(container, controller, target);
            }
        }
        toSummon = null;
        yield return null;
    }

    public IEnumerator Summon(CardContainer container, CardController controller, Entity summonedBy, StatusEffectData[] withEffects = null, int withEffectsAmount = 0, UnityAction<Entity> onComplete = null)
    {
        if (!(container))
        {
            yield break;
        }
        Entity entity = null;
        yield return CreateCard(summonCard, container, controller, delegate (Entity e)
        {
            entity = e;
        });
        if (withEffectsAmount > 0 && withEffects != null)
        {
            foreach (StatusEffectData effectData in withEffects)
            {
                yield return StatusEffectSystem.Apply(entity, null, effectData, withEffectsAmount);
            }
        }
        if ((gainTrait))
        {
            ActionQueue.Stack(new ActionSequence(Animate(entity, new CardData.StatusEffectStacks(gainTrait, 1))), fixedPosition: true);
        }
        else
        {
            ActionQueue.Stack(new ActionSequence(Animate(entity)), fixedPosition: true);
        }
        ActionQueue.Stack(new ActionRunEnableEvent(entity)
        {
            fixedPosition = true
        });
        ActionQueue.Stack(new ActionMove(entity, container)
        {
            fixedPosition = true
        });
        Events.InvokeEntitySummoned(entity, summonedBy);
        onComplete?.Invoke(entity);
    }

    public IEnumerator SummonCopy(Entity toCopy, CardContainer container, CardController controller, Entity summonedBy, StatusEffectData[] withEffects = null, int withEffectsAmount = 0, UnityAction<Entity> onComplete = null)
    {
        Entity entity = null;
        yield return CreateCard(toCopy.data, container, controller, delegate (Entity e)
        {
            entity = e;
            e.startingEffectsApplied = true;
        });
        yield return CopyStatsAndEffects(entity, toCopy);
        yield return SummonPreMade(entity, container, controller, summonedBy, withEffects, withEffectsAmount, onComplete);
    }

    public IEnumerator SummonPreMade(Entity preMade, CardContainer container, CardController controller, Entity summonedBy, StatusEffectData[] withEffects = null, int withEffectsAmount = 0, UnityAction<Entity> onComplete = null)
    {
        if (withEffectsAmount > 0 && withEffects != null)
        {
            foreach (StatusEffectData effectData in withEffects)
            {
                yield return StatusEffectSystem.Apply(preMade, null, effectData, withEffectsAmount);
            }
        }
        if ((gainTrait))
        {
            yield return Animate(preMade, new CardData.StatusEffectStacks(gainTrait, 1));
        }
        else
        {
            yield return Animate(preMade);
        }
        Events.InvokeEntitySummoned(preMade, summonedBy);
        onComplete?.Invoke(preMade);
        yield return new ActionRunEnableEvent(preMade).Run();
        yield return new ActionMove(preMade, container).Run();
    }

    public IEnumerator CopyStatsAndEffects(Entity entity, Entity toCopy)
    {
        toCopy.data.TryGetCustomData("splitOriginalId", out var value, toCopy.data.id);
        entity.data.SetCustomData("splitOriginalId", value);
        List<StatusEffectData> list = toCopy.statusEffects.Where((StatusEffectData e) => e.count > e.temporary && !e.IsNegativeStatusEffect() && (e.HasDescOrIsKeyword || e.isStatus)).ToList();
        foreach (Entity.TraitStacks trait in toCopy.traits)
        {
            foreach (StatusEffectData passiveEffect in trait.passiveEffects)
            {
                list.Remove(passiveEffect);
            }
            int num = trait.count - trait.tempCount;
            if (num > 0)
            {
                entity.GainTrait(trait.data, num);
            }
        }
        foreach (StatusEffectData item in list)
        {
            yield return StatusEffectSystem.Apply(entity, item.applier, item, item.count - item.temporary);
        }
        entity.attackEffects = (from a in CardData.StatusEffectStacks.Stack(entity.attackEffects, toCopy.attackEffects)
                                select a.Clone()).ToList();
        entity.damage = toCopy.damage;
        entity.hp = toCopy.hp;
        entity.counter = toCopy.counter;
        entity.counter.current = entity.counter.max;
        entity.uses = toCopy.uses;
        entity.display.promptUpdateDescription = true;
        entity.PromptUpdate();
        yield return entity.UpdateTraits();
    }

    public IEnumerator Animate(Entity entity, params CardData.StatusEffectStacks[] withEffects)
    {
        AsyncOperationHandle<GameObject> handle = effectPrefabRef.InstantiateAsync(entity.transform, false);
        yield return handle;
        CreateCardAnimation component = handle.Result.GetComponent<CreateCardAnimation>();
        if (component != null)
        {
            yield return component.Run(entity, withEffects);
        }
    }

    public Card CreateCardCopy(CardData cardData, CardContainer container, CardController controller)
    {
        //IL_00ab: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bc: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cc: Unknown result type (might be due to invalid IL or missing references)
        CardData cardData2 = cardData.Clone(runCreateScripts: false);
        if ((setCardType))
        {
            cardData2.cardType = setCardType;
        }
        cardData2.upgrades.RemoveAll((CardUpgradeData a) => a.type == CardUpgradeData.Type.Crown);
        Card card = CardManager.Get(cardData2, controller, container.owner, inPlay: true, container.owner.team == References.Player.team);
        card.entity.flipper.FlipUpInstant();
        card.canvasGroup.alpha = 0f;
        container.Add(card.entity);
        Transform transform = card.transform;
        transform.localPosition = card.entity.GetContainerLocalPosition();
        transform.localEulerAngles = card.entity.GetContainerLocalRotation();
        transform.localScale = card.entity.GetContainerScale();
        container.Remove(card.entity);
        card.entity.owner.reserveContainer.Add(card.entity);
        return card;
    }

    public IEnumerator CreateCard(CardData cardData, CardContainer container, CardController controller, UnityAction<Entity> onComplete = null)
    {
        Card card = CreateCardCopy(cardData, container, controller);
        onComplete?.Invoke(card.entity);
        yield return card.UpdateData();
    }

    public IEnumerator TrySummon(CardContainer container, CardController controller, Entity summonedBy)
    {
        Dictionary<Entity, List<CardSlot>> shoveData;
        if (container.Count < container.max)
        {
            yield return Summon(container, controller, summonedBy);
        }
        else if (ShoveSystem.CanShove(container.GetTop(), target, out shoveData))
        {
            yield return ShoveSystem.DoShove(shoveData, updatePositions: true);
            yield return Summon(container, controller, summonedBy);
        }
        else if (NoTargetTextSystem.Exists())
        {
            yield return NoTargetTextSystem.Run(target, NoTargetType.NoSpaceToSummon);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Summoned", fileName = "Summoned")]
public class StatusEffectSummoned : StatusEffectData
{
    public bool triggered;

    public override void Init()
    {
        base.OnTurnEnd += DealDamage;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (entity == target)
        {
            triggered = true;
        }
        return false;
    }

    public override bool RunTurnEndEvent(Entity entity)
    {
        if (CanTrigger() && entity == target)
        {
            return triggered;
        }
        return false;
    }

    public IEnumerator DealDamage(Entity entity)
    {
        triggered = false;
        SfxSystem.OneShot("event:/sfx/status/shadeheart");
        Hit hit = new Hit(target, target, 1)
        {
            damageType = "summoned",
            countsAsHit = false,
            screenShake = 0f
        };
        yield return hit.Process();
        yield return Sequences.Wait(0.1f);
    }
}
[CreateAssetMenu(menuName = "Status Effects/Vim", fileName = "Vim")]
public class StatusEffectVim : StatusEffectData
{
    public override void Init()
    {
        base.OnHit += Check;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.target == target && hit.Offensive && hit.canBeNullified)
        {
            return hit.BasicHit;
        }
        return false;
    }

    public IEnumerator Check(Hit hit)
    {
        hit.dodged = true;
        hit.countsAsHit = false;
        hit.damageBlocked = hit.damage;
        hit.damage = 0;
        if ((hit.attacker) && hit.attacker.canBeHit && hit.canRetaliate)
        {
            Hit hit2 = new Hit(target, hit.attacker, count)
            {
                canRetaliate = false,
                damageType = "vim"
            };
            yield return hit2.Process();
        }
        ActionQueue.Stack(new ActionSequence(CountDown()), fixedPosition: true);
    }

    public IEnumerator CountDown()
    {
        int amount = count;
        Events.InvokeStatusEffectCountDown(this, ref amount);
        if (amount != 0)
        {
            yield return CountDown(target, amount);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Weakness", fileName = "Weakness")]
public class StatusEffectWeakness : StatusEffectData
{
    public override void Init()
    {
        base.OnHit += Hit;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit.Offensive && count > 0)
        {
            return hit.target == target;
        }
        return false;
    }

    public IEnumerator Hit(Hit hit)
    {
        hit.damage += count;
        yield break;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Apply To Summon", fileName = "Apply To Summon")]
public class StatusEffectApplyToSummon : StatusEffectData
{
    [SerializeField]
    public StatusEffectData effectToApply;

    public override void Init()
    {
        Events.OnEntitySummoned += EntitySummoned;
    }

    public void OnDestroy()
    {
        Events.OnEntitySummoned -= EntitySummoned;
    }

    public void EntitySummoned(Entity entity, Entity summonedBy)
    {
        if (summonedBy.data.id == target.data.id)
        {
            int amount = GetAmount();
            if (amount > 0)
            {
                ActionQueue.Stack(new ActionApplyStatus(entity, summonedBy, effectToApply, amount)
                {
                    fixedPosition = true
                });
            }
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Build", fileName = "Build")]
public class StatusEffectBuild : StatusEffectData
{
    [SerializeField]
    public int requires = 3;

    public override bool RunCardMoveEvent(Entity entity)
    {
        if (target == entity && Battle.IsOnBoard(entity.containers) && !Battle.IsOnBoard(entity.preContainers))
        {
            List<Entity> list = (from ally in entity.GetAllies()
                                 where ally.statusEffects.Exists((StatusEffectData a) => (a).name == name)
                                 select ally).ToList();
            list.Add(entity);
            if (list.Count >= requires)
            {
                ActionQueue.Stack(new ActionCombine(list.ToArray()), fixedPosition: true);
            }
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Cannot Recall", fileName = "Cannot Recall")]
public class StatusEffectCannotBeRecalled : StatusEffectData
{
    public bool active;

    public override bool RunBeginEvent()
    {
        if (!active && (target) && GetAmount() > 0)
        {
            Activate();
        }
        return false;
    }

    public override bool RunEndEvent()
    {
        if (active && (target))
        {
            Deactivate();
        }
        return false;
    }

    public override bool RunEffectBonusChangedEvent()
    {
        if ((target))
        {
            int amount = GetAmount();
            if (amount > 0 && !active)
            {
                Activate();
            }
            else if (amount <= 0 && active)
            {
                Deactivate();
            }
        }
        return false;
    }

    public void Activate()
    {
        target.blockRecall++;
        active = true;
    }

    public void Deactivate()
    {
        target.blockRecall--;
        active = false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Cannot Increase Max Health", fileName = "Cannot Increase Max Health")]
public class StatusEffectCannotIncreaseMaxHealth : StatusEffectData
{
    public override bool RunApplyStatusEvent(StatusEffectApply apply)
    {
        if (apply.target == target && !target.silenced && CheckEffectType(apply.effectData))
        {
            apply.count = 0;
        }
        return false;
    }

    public static bool CheckEffectType(StatusEffectData effectData)
    {
        if ((effectData))
        {
            string text = effectData.type;
            return text == "max health up" || text == "max health up only";
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Change Priority Position", fileName = "Change Priority Position")]
public class StatusEffectChangePriorityPosition : StatusEffectData
{
    [Header("-1 = Backline, 2 = Frontline")]
    [SerializeField]
    public int positionPriorityChange = -1;

    public int pre;

    public override bool RunBeginEvent()
    {
        pre = target.positionPriority;
        if (!target.silenced)
        {
            target.positionPriority = positionPriorityChange;
        }
        return false;
    }

    public override bool RunEndEvent()
    {
        target.positionPriority = pre;
        return false;
    }

    public override bool RunEffectBonusChangedEvent()
    {
        RunEndEvent();
        RunBeginEvent();
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Change Target Mode", fileName = "Change Target Mode")]
public class StatusEffectChangeTargetMode : StatusEffectData
{
    [SerializeField]
    public TargetMode targetMode;

    public TargetMode pre;

    public override bool RunBeginEvent()
    {
        pre = target.targetMode;
        if (!target.silenced)
        {
            target.targetMode = targetMode;
        }
        return false;
    }

    public override bool RunEndEvent()
    {
        target.targetMode = pre;
        return false;
    }

    public override bool RunEffectBonusChangedEvent()
    {
        RunEndEvent();
        RunBeginEvent();
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Crush", fileName = "Crush")]
public class StatusEffectCrush : StatusEffectData
{
    public override void Init()
    {
        base.OnCardPlayed += Check;
    }

    public static CardContainer[] GetWasInRows(Entity entity, IEnumerable<Entity> targets)
    {
        if (entity.data.playType == Card.PlayType.Play && entity.NeedsTarget)
        {
            HashSet<CardContainer> hashSet = new HashSet<CardContainer>();
            foreach (Entity target in targets)
            {
                if (target.containers != null && target.containers.Length != 0)
                {
                    HashSetExt.AddRange<CardContainer>(hashSet, (IEnumerable<CardContainer>)target.containers);
                }
                else
                {
                    HashSetExt.AddRange<CardContainer>(hashSet, (IEnumerable<CardContainer>)target.preContainers);
                }
            }
            return HashSetExt.ToArray<CardContainer>(hashSet);
        }
        return entity.containers;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (((Behaviour)target).enabled)
        {
            return entity == target;
        }
        return false;
    }

    public IEnumerator Check(Entity entity, Entity[] targets)
    {
        int c = GetAmount();
        for (int i = 0; i < c; i++)
        {
            yield return DestroyCard();
        }
    }

    public IEnumerator DestroyCard()
    {
        Entity entity = IEnumerableExt.InRandomOrder<Entity>((IEnumerable<Entity>)References.Player.handContainer).FirstOrDefault((Entity a) => (a).name == "Junk" && a != target);
        if (!(entity))
        {
            entity = IEnumerableExt.InRandomOrder<Entity>((IEnumerable<Entity>)References.Player.handContainer).FirstOrDefault((Entity a) => a.data.cardType.item && a != target);
        }
        if ((entity))
        {
            target.curveAnimator.Ping();
            Routine.Clump clump = new Routine.Clump();
            clump.Add(entity.Kill());
            clump.Add(Sequences.Wait(0.5f));
            yield return clump.WaitForEnd();
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Destroy After Use", fileName = "Destroy After Use")]
public class StatusEffectDestroyAfterUse : StatusEffectData
{
    public bool subbed;

    public bool destroy;

    public void OnDestroy()
    {
        Unsub();
    }

    public void Sub()
    {
        Events.OnActionPerform += CheckAction;
        subbed = true;
    }

    public void Unsub()
    {
        if (subbed)
        {
            Events.OnActionPerform -= CheckAction;
            subbed = false;
        }
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (!subbed && entity == target && !target.silenced)
        {
            Sub();
            if (target.uses.current <= 1)
            {
                destroy = true;
            }
        }
        return false;
    }

    public void CheckAction(PlayAction action)
    {
        if (action is ActionReduceUses actionReduceUses && actionReduceUses.entity == target)
        {
            Unsub();
            if (destroy)
            {
                target.alive = false;
                ActionQueue.Stack(new ActionConsume(target));
            }
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Draw Cards", fileName = "Draw Cards")]
public class StatusEffectDrawCards : StatusEffectData
{
    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (entity == target)
        {
            ActionQueue.Stack(new ActionDraw(target.owner, GetAmount()));
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Free Action", fileName = "Free Action")]
public class StatusEffectFreeAction : StatusEffectData
{
    [SerializeField]
    public ItemHolderPet petPrefab;

    public bool hasEffect;

    public override void Init()
    {
        base.OnCardPlayed += CardPlayed;
    }

    public override bool RunBeginEvent()
    {
        if (!target.inPlay || ((Behaviour)target).enabled)
        {
            hasEffect = true;
            if (!GameManager.paused && target.display is Card card)
            {
                card.itemHolderPet?.Create(petPrefab);
                Events.InvokeNoomlinShow(target);
            }
        }
        return false;
    }

    public override bool RunCardMoveEvent(Entity entity)
    {
        if (entity == target)
        {
            if (target.InHand())
            {
                RunBeginEvent();
            }
            else if (hasEffect && !Battle.IsOnBoard(entity.preContainers) && Battle.IsOnBoard(entity))
            {
                hasEffect = false;
                if (target.display is Card card)
                {
                    card.itemHolderPet?.Used();
                }
                target.owner.freeAction = true;
            }
        }
        return false;
    }

    public override bool RunEnableEvent(Entity entity)
    {
        if (entity == target)
        {
            RunBeginEvent();
        }
        return false;
    }

    public override bool RunDisableEvent(Entity entity)
    {
        if (entity == target)
        {
            RunEndEvent();
        }
        return false;
    }

    public override bool RunEndEvent()
    {
        hasEffect = false;
        if (target != null && target.display is Card card)
        {
            card.itemHolderPet?.DestroyCurrent();
        }
        return false;
    }

    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (hasEffect && entity == target)
        {
            return !target.silenced;
        }
        return false;
    }

    public IEnumerator CardPlayed(Entity entity, Entity[] targets)
    {
        hasEffect = false;
        if (target.display is Card card)
        {
            card.itemHolderPet?.Used();
            Events.InvokeNoomlinUsed(target);
            Mover mover = ((Component)card).gameObject.AddComponent<Mover>();
            mover.velocity = new Vector3(FloatExt.WithRandomSign(PettyRandom.Range(0f, 1f), 0.5f), -12f, 0f);
            mover.frictMult = 0.8f;
            target.wobbler?.WobbleRandom();
            yield return Sequences.Wait(0.6f);
        }
        target.owner.freeAction = true;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Increase Attack While Alone", fileName = "Increase Attack While Alone")]
public class StatusEffectIncreaseAttackWhileAlone : StatusEffectData
{
    [SerializeField]
    public bool active;

    [SerializeField]
    public int currentBonus;

    public override bool HasStackRoutine => active;

    public override bool RunCardMoveEvent(Entity entity)
    {
        if (entity == target && active && !CanTrigger())
        {
            Deactivate();
        }
        else if ((IListExt.ContainsAny<CardContainer>((IList<CardContainer>)entity.preContainers, (IEnumerable<CardContainer>)target.containers) || IListExt.ContainsAny<CardContainer>((IList<CardContainer>)target.containers, (IEnumerable<CardContainer>)entity.containers)) && CanTrigger())
        {
            Check();
        }
        return false;
    }

    public override bool RunEnableEvent(Entity entity)
    {
        Check();
        return false;
    }

    public override bool RunEntityDestroyedEvent(Entity entity, DeathType deathType)
    {
        if (CanTrigger())
        {
            Check();
        }
        return false;
    }

    public override bool RunEffectBonusChangedEvent()
    {
        if (active)
        {
            Deactivate();
            Activate();
        }
        return false;
    }

    public void Check()
    {
        int num = CountOthersInMyRows();
        if (!active)
        {
            if (num <= 0)
            {
                Activate();
            }
        }
        else if (num > 0)
        {
            Deactivate();
        }
    }

    public override bool RunStackEvent(int stacks)
    {
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        if (active)
        {
            currentBonus += stacks;
            Entity entity = target;
            entity.tempDamage += stacks;
            target.PromptUpdate();
        }
        return false;
    }

    public int CountOthersInMyRows()
    {
        int num = 0;
        CardContainer[] containers = target.containers;
        for (int i = 0; i < containers.Length; i++)
        {
            foreach (Entity item in containers[i])
            {
                if (item.IsAliveAndExists() && item != target)
                {
                    num++;
                }
            }
        }
        return num;
    }

    public void Activate()
    {
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        active = true;
        currentBonus = GetAmount();
        Entity entity = target;
        entity.tempDamage += currentBonus;
        target.PromptUpdate();
    }

    public void Deactivate()
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        active = false;
        Entity entity = target;
        entity.tempDamage -= currentBonus;
        target.PromptUpdate();
    }

    public override bool CanTrigger()
    {
        if (base.CanTrigger())
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Pull Target", fileName = "Pull Target")]
public class StatusEffectPullTarget : StatusEffectData
{
    public Hit storedHit;

    public override bool RunPreAttackEvent(Hit hit)
    {
        if (hit.attacker == target && target.alive && ((Behaviour)target).enabled && hit.target != null && hit.target.containers != null)
        {
            hit.FlagAsOffensive();
            storedHit = hit;
        }
        return false;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit == storedHit)
        {
            Entity entity = hit.target;
            CardContainer cardContainer = entity.containers[0];
            int num = cardContainer.IndexOf(entity);
            int num2 = Mathf.Max(num - GetAmount(), 0);
            if (num != num2)
            {
                cardContainer.RemoveAt(num);
                cardContainer.PushBackwards(num2);
                cardContainer.Insert(num2, entity);
                foreach (Entity item in cardContainer)
                {
                    cardContainer.TweenChildPosition(item);
                }
            }
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Push Target", fileName = "Push Target")]
public class StatusEffectPushTarget : StatusEffectData
{
    public Hit storedHit;

    public override bool RunPreAttackEvent(Hit hit)
    {
        if (hit.attacker == target && target.alive && ((Behaviour)target).enabled && hit.target != null && hit.target.containers != null)
        {
            hit.FlagAsOffensive();
            storedHit = hit;
        }
        return false;
    }

    public override bool RunHitEvent(Hit hit)
    {
        if (hit == storedHit)
        {
            Entity entity = hit.target;
            CardContainer cardContainer = entity.containers[0];
            int num = cardContainer.IndexOf(entity);
            int num2 = Mathf.Min(num + GetAmount(), cardContainer.max - 1);
            if (num != num2)
            {
                cardContainer.RemoveAt(num);
                cardContainer.Insert(num2, entity);
                foreach (Entity item in cardContainer)
                {
                    cardContainer.TweenChildPosition(item);
                }
            }
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Recycle", fileName = "Recycle")]
public class StatusEffectRecycle : StatusEffectData
{
    public string cardToRecycle = "Junk";

    public bool running;

    public readonly List<Entity> toDestroy = new List<Entity>();

    public override void Init()
    {
        Events.OnCheckAction += CheckAction;
        base.PreTrigger += EntityPreTrigger;
    }

    public void OnDestroy()
    {
        Events.OnCheckAction -= CheckAction;
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
        if (running || !((Behaviour)target).enabled || target.silenced || !allow || !(action is ActionTrigger actionTrigger) || !(actionTrigger.entity == target))
        {
            return;
        }
        int amount = GetAmount();
        Events.CheckRecycleAmount(target, ref amount);
        if (amount > 0 && !GetTargets(amount))
        {
            allow = false;
            if (NoTargetTextSystem.Exists())
            {
                new Routine(NoTargetTextSystem.Run(target, NoTargetType.RequiresJunk, amount));
            }
        }
    }

    public override bool RunPreTriggerEvent(Trigger trigger)
    {
        return toDestroy.Count > 0;
    }

    public IEnumerator EntityPreTrigger(Trigger trigger)
    {
        running = true;
        foreach (Entity item in toDestroy)
        {
            target.curveAnimator.Ping();
            yield return item.Kill();
        }
        toDestroy.Clear();
        running = false;
    }

    public bool GetTargets(int requiredAmount)
    {
        bool flag = false;
        toDestroy.Clear();
        foreach (Entity item in References.Player.handContainer)
        {
            if ((item.data).name == cardToRecycle)
            {
                toDestroy.Add(item);
                if (--requiredAmount <= 0)
                {
                    flag = true;
                    break;
                }
            }
        }
        if (!flag)
        {
            toDestroy.Clear();
        }
        return flag;
    }

    public bool IsEnoughJunkInHand()
    {
        int num = GetAmount();
        foreach (Entity item in References.Player.handContainer)
        {
            if ((item.data).name == cardToRecycle && --num <= 0)
            {
                return true;
            }
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Redraw Cards", fileName = "Redraw Cards")]
public class StatusEffectRedrawCards : StatusEffectData
{
    public override bool RunCardPlayedEvent(Entity entity, Entity[] targets)
    {
        if (entity == target && !target.silenced)
        {
            ActionQueue.Stack(new ActionRedraw(target.owner));
        }
        return false;
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Trigger When Deployed", fileName = "Trigger When Deployed")]
public class StatusEffectTriggerWhenDeployed : StatusEffectData
{
    public bool isAlreadyOnBoard;

    public override object GetMidBattleData()
    {
        return Battle.IsOnBoard(target);
    }

    public override void RestoreMidBattleData(object data)
    {
        if (data is bool flag)
        {
            isAlreadyOnBoard = flag && Battle.IsOnBoard(target);
        }
    }

    public override void Init()
    {
        base.OnEnable += Enable;
        base.OnCardMove += CardMove;
    }

    public override bool RunEnableEvent(Entity entity)
    {
        if (isAlreadyOnBoard)
        {
            isAlreadyOnBoard = false;
            return false;
        }
        if (entity == target)
        {
            return Battle.IsOnBoard(target);
        }
        return false;
    }

    public IEnumerator Enable(Entity entity)
    {
        yield return Sequences.Wait(0.2f);
        yield return Activate();
    }

    public override bool RunCardMoveEvent(Entity entity)
    {
        if (target == entity && ((Behaviour)target).enabled && Battle.IsOnBoard(target))
        {
            return !Battle.IsOnBoard(entity.preContainers);
        }
        return false;
    }

    public IEnumerator CardMove(Entity entity)
    {
        yield return Sequences.Wait(0.2f);
        yield return Activate();
    }

    public IEnumerator Activate()
    {
        if (!target.silenced)
        {
            yield return Sequences.Wait(0.1f);
            target.curveAnimator?.Ping();
            yield return Sequences.Wait(0.5f);
            ActionQueue.Stack(new ActionTrigger(target, null), fixedPosition: true);
        }
    }
}
[CreateAssetMenu(menuName = "Status Effects/Traits/Unmovable", fileName = "Unmovable")]
public class StatusEffectUnmovable : StatusEffectData
{
    public override void Init()
    {
        Events.OnCheckAction += CheckAction;
    }

    public void OnDestroy()
    {
        Events.OnCheckAction -= CheckAction;
    }

    public void CheckAction(ref PlayAction action, ref bool allow)
    {
        if (allow && !target.silenced && action is ActionMove actionMove && actionMove.entity == target && Battle.IsOnBoard(target) && Battle.IsOnBoard(actionMove.toContainers))
        {
            allow = false;
            if (NoTargetTextSystem.Exists())
            {
                new Routine(NoTargetTextSystem.Run(target, NoTargetType.CantMove));
            }
        }
    }
}
public static class Delta
{
    public static readonly float targetFps = 60f;

    public static float Multiply(float current, float multiply, float delta)
    {
        return current * Mathf.Pow(multiply, delta * targetFps);
    }

    public static Vector2 Multiply(Vector2 current, float multiply, float delta)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        return current * Mathf.Pow(multiply, delta * targetFps);
    }

    public static Vector2 Multiply(Vector2 current, Vector3 multiply, float delta)
    {
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        float num = delta * targetFps;
        float num2 = current.x * Mathf.Pow(multiply.x, num);
        float num3 = current.y * Mathf.Pow(multiply.y, num);
        return new Vector2(num2, num3);
    }

    public static Vector3 Multiply(Vector3 current, float multiply, float delta)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        return current * Mathf.Pow(multiply, delta * targetFps);
    }

    public static Vector3 Multiply(Vector3 current, Vector3 multiply, float delta)
    {
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        float num = delta * targetFps;
        float num2 = current.x * Mathf.Pow(multiply.x, num);
        float num3 = current.y * Mathf.Pow(multiply.y, num);
        float num4 = current.z * Mathf.Pow(multiply.z, num);
        return new Vector3(num2, num3, num4);
    }

    public static float Lerp(float current, float target, float amount, float delta)
    {
        return Mathf.Lerp(current, target, 1f - Mathf.Pow(1f - amount, delta * targetFps));
    }

    public static Vector2 Lerp(Vector2 current, Vector2 target, float amount, float delta)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        return Vector2.Lerp(current, target, 1f - Mathf.Pow(1f - amount, delta * targetFps));
    }

    public static Vector3 Lerp(Vector3 current, Vector3 target, float amount, float delta)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        return Vector3.Lerp(current, target, 1f - Mathf.Pow(1f - amount, delta * targetFps));
    }

    public static Quaternion Lerp(Quaternion current, Quaternion target, float amount, float delta)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        return Quaternion.Lerp(current, target, 1f - Mathf.Pow(1f - amount, delta * targetFps));
    }

    public static Vector3 LerpAngle(Vector3 current, Vector3 target, float amount, float delta)
    {
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        float num = 1f - Mathf.Pow(1f - amount, delta * targetFps);
        float num2 = Mathf.LerpAngle(current.x, target.x, num);
        float num3 = Mathf.LerpAngle(current.y, target.y, num);
        float num4 = Mathf.LerpAngle(current.z, target.z, num);
        return new Vector3(num2, num3, num4);
    }
}
public static class Lengthdir
{
    public static float X(float len, float radians)
    {
        return Mathf.Cos(radians) * len;
    }

    public static float Y(float len, float radians)
    {
        return Mathf.Sin(radians) * len;
    }

    public static Vector2 ToVector2(float len, float radians)
    {
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        return new Vector2(X(len, radians), Y(len, radians));
    }
}
public static class RandomInclusive
{
    public static int Range(int min, int max)
    {
        return Random.Range(min, max + 1);
    }

    public static float Range(float min, float max)
    {
        return Random.Range(min, max);
    }
}
public static class StopWatch
{
    public static float? startTime;

    public static float? stopTime;

    public static int Milliseconds => GetMilliseconds();

    public static float Seconds => (float)Milliseconds / 1000f;

    public static float StopTime => stopTime ?? Time.realtimeSinceStartup;

    public static void Start()
    {
        startTime = Time.realtimeSinceStartup;
        stopTime = null;
    }

    public static int Stop()
    {
        stopTime = Time.realtimeSinceStartup;
        return Milliseconds;
    }

    public static int GetMilliseconds()
    {
        if (startTime.HasValue)
        {
            return Mathf.RoundToInt((StopTime - startTime.Value) * 1000f);
        }
        return 0;
    }
}
public static class Text
{
    [Serializable]
    public struct ColourProfileHex
    {
        public string textColour;

        public string effectColour;

        public string effectBuffedColour;

        public string effectDebuffedColour;

        public string keywordColour;

        public string keywordSilencedColour;

        public string keywordBuffedColour;

        public string keywordDebuffedColour;

        public string flavourColour;

        public ColourProfileHex(string textColour, string effectColour, string effectBuffedColour, string effectDebuffedColour, string keywordColour, string keywordSilencedColour, string keywordBuffedColour, string keywordDebuffedColour, string flavourColour)
        {
            this.textColour = textColour;
            this.effectColour = effectColour;
            this.effectBuffedColour = effectBuffedColour;
            this.effectDebuffedColour = effectDebuffedColour;
            this.keywordColour = keywordColour;
            this.keywordSilencedColour = keywordSilencedColour;
            this.keywordBuffedColour = keywordBuffedColour;
            this.keywordDebuffedColour = keywordDebuffedColour;
            this.flavourColour = flavourColour;
        }
    }

    public static ColourProfileHex darkProfile = new ColourProfileHex("3B262C", "000", "41874AFF", "880033FF", "4B6A9CFF", "4B6A9Caa", "4188baff", "4B6A9Caa", "ffe6");

    public static ColourProfileHex lightProfile = new ColourProfileHex("FFF", "FFFF99FF", "BBFFCCFF", "FFCCBBFF", "FFFF99FF", "FFFF99aa", "BBFFCCFF", "FFCCBBFF", "ffe6");

    public static string Process(string original)
    {
        return Process(original, 0, 1f, lightProfile);
    }

    public static string Process(string original, ColourProfileHex profile)
    {
        return Process(original, 0, 1f, profile);
    }

    public static string Process(string original, int effectBonus, float effectFactor, ColourProfileHex profile)
    {
        string text = original.Trim();
        int length = text.Length;
        for (int i = 0; i < length; i++)
        {
            if (text[i] != '<')
            {
                continue;
            }
            string text2 = FindTag(text, i);
            if (text2.Length > 0)
            {
                text = text.Remove(i, text2.Length + 2);
                string text3 = ProcessTag(text, text2, effectBonus, effectFactor, profile);
                if (text3.Length > 0)
                {
                    text = text.Insert(i, text3);
                    i += text3.Length;
                }
                length = text.Length;
                i--;
            }
        }
        return text;
    }

    public static string FindTag(string text, int startIndex)
    {
        string result = "";
        int num = text.IndexOf('>', startIndex) - startIndex;
        if (num > 0)
        {
            result = text.Substring(startIndex + 1, num - 1);
        }
        return result;
    }

    public static string ProcessTag(string text, string tag, int effectBonus, float effectFactor, ColourProfileHex profile)
    {
        char c = tag[0];
        bool flag = char.IsDigit(c);
        if (tag.Length == 1 && !flag)
        {
            return "<" + tag + ">";
        }
        string text2 = string.Empty;
        string text3 = null;
        if (c == '+' || c == '-' || c == 'x')
        {
            text3 = c.ToString();
        }
        if ((flag || text3 != null) && int.TryParse(Regex.Replace(tag, "[^0-9]+", string.Empty), out var result))
        {
            int num = Mathf.Max(0, Mathf.RoundToInt((float)(result + effectBonus) * effectFactor));
            string text4 = "<color=#" + profile.effectColour + ">";
            string text5 = "</color>";
            if (num > result)
            {
                text4 = "<color=#" + profile.effectBuffedColour + ">";
            }
            else if (num < result)
            {
                text4 = "<color=#" + profile.effectDebuffedColour + ">";
            }
            text2 = $"<b>{text4}{text3}{num}{text5}</b>";
        }
        else
        {
            string[] array = tag.Split('=');
            if (array.Length == 2)
            {
                switch (array[0].Trim())
                {
                    case "keyword":
                        {
                            string text7 = array[1].Trim();
                            KeywordData keywordData = ToKeyword(text7);
                            bool flag2 = !StringExt.IsNullOrWhitespace(keywordData.iconName);
                            if (flag2 && keywordData.showIcon && !keywordData.showName)
                            {
                                text2 = "<sprite name=" + keywordData.iconName + ">";
                            }
                            else
                            {
                                if (!keywordData.showName)
                                {
                                    break;
                                }
                                string[] array2 = text7.Split(' ');
                                bool flag3 = array2.Length > 2 && array2[2] == "silenced";
                                string text8 = (flag3 ? profile.keywordSilencedColour : profile.keywordColour);
                                if (flag2 && keywordData.showIcon)
                                {
                                    text2 = text2 + "<sprite name=\"" + keywordData.iconName + "\" color=#" + text8 + ">";
                                }
                                text2 = text2 + "<color=#" + text8 + ">";
                                if (flag3)
                                {
                                    text2 += "<s>";
                                }
                                if (keywordData.canStack && array2.Length > 1)
                                {
                                    result = 1;
                                    int num2 = 1;
                                    if (array2.Length != 0 && int.TryParse(array2[1], out result))
                                    {
                                        num2 = Mathf.Max(0, Mathf.RoundToInt((float)(result + effectBonus) * effectFactor));
                                    }
                                    string text9 = "<color=#" + text8 + ">";
                                    string text10 = "</color>";
                                    if (num2 > result)
                                    {
                                        text9 = "<color=#" + profile.keywordBuffedColour + ">";
                                    }
                                    else if (num2 < result)
                                    {
                                        text9 = "<color=#" + profile.keywordDebuffedColour + ">";
                                    }
                                    text2 += $"{keywordData.title} <b>{text9}{num2}{text10}</b>";
                                }
                                else
                                {
                                    text2 += keywordData.title;
                                }
                                text2 += "</color>";
                                if (flag3)
                                {
                                    text2 += "</s>";
                                }
                            }
                            break;
                        }
                    case "card":
                        {
                            string text6 = array[1].Trim();
                            CardData cardData = AddressableLoader.Get<CardData>("CardData", text6);
                            if (!(cardData))
                            {
                                Debug.LogError(("Error processing text: " + text + "\nCard [" + text6 + "] does not exist!"));
                            }
                            text2 = "<#" + profile.keywordColour + ">" + cardData.title + "</color>";
                            break;
                        }
                    case "sprite":
                    case "sprite name":
                    case "spr":
                        text2 = "<sprite name=" + array[1].Trim() + ">";
                        break;
                    case "color":
                    case "size":
                        text2 = "<" + tag + ">";
                        break;
                }
            }
        }
        if (StringExt.IsNullOrWhitespace(text2))
        {
            text2 = ((!c.Equals('/')) ? ("<color=#" + profile.effectColour + ">" + tag + "</color>") : ("<" + tag + ">"));
        }
        return text2;
    }

    public static KeywordData ToKeyword(string text)
    {
        int num = text.IndexOf(' ');
        if (num > 0)
        {
            text = text.Remove(num, text.Length - num);
        }
        KeywordData keywordData = AddressableLoader.Get<KeywordData>("KeywordData", text);
        Debug.Log(((keywordData != null) ? ("Keyword for \"" + text + "\" = [" + (keywordData).name + "]") : ("Keyword for \"" + text + "\" = NULL")));
        if (!(keywordData))
        {
            Debug.LogError(("Keyword \"" + text + "\" not found!"));
        }
        return keywordData;
    }

    public static HashSet<KeywordData> GetKeywords(string text)
    {
        HashSet<KeywordData> hashSet = new HashSet<KeywordData>();
        for (int i = 0; i < text.Length; i++)
        {
            if (!text[i].Equals('<'))
            {
                continue;
            }
            string text2 = FindTag(text, i);
            if (text2.Length <= 0 || !text2.Contains("="))
            {
                continue;
            }
            string[] array = text2.Split('=');
            if (array.Length == 2 && array[0].Trim() == "keyword")
            {
                KeywordData keywordData = ToKeyword(array[1].Trim());
                if (keywordData.show)
                {
                    hashSet.Add(keywordData);
                }
            }
        }
        return hashSet;
    }

    public static HashSet<CardData> GetMentionedCards(string text)
    {
        HashSet<CardData> hashSet = new HashSet<CardData>();
        for (int i = 0; i < text.Length; i++)
        {
            if (!text[i].Equals('<'))
            {
                continue;
            }
            string text2 = FindTag(text, i);
            if (text2.Length > 0 && text2.Contains("="))
            {
                string[] array = text2.Split('=');
                if (array.Length == 2 && array[0].Trim() == "card")
                {
                    CardData item = AddressableLoader.Get<CardData>("CardData", array[1].Trim());
                    hashSet.Add(item);
                }
            }
        }
        return hashSet;
    }

    public static string GetEffectText(LocalizedString textKey, string textInsert, int amount, bool silenced = false)
    {
        string localizedString = textKey.GetLocalizedString();
        localizedString = localizedString.Replace("{0}", textInsert);
        localizedString = localizedString.Replace("{e}", textInsert);
        localizedString = localizedString.Replace("{a}", amount.ToString());
        localizedString = HandleBracketTags(localizedString);
        return silenced ? ("<s>" + localizedString + "</s>") : localizedString;
    }

    public static string GetEffectText(IEnumerable<LocalizedString> textKeys, string textInsert, int amount, bool silenced = false)
    {
        string text = "{0}";
        foreach (LocalizedString textKey in textKeys)
        {
            text = text.Replace("{0}", textKey.GetLocalizedString());
        }
        text = text.Replace("{0}", textInsert);
        text = text.Replace("{e}", textInsert);
        text = text.Replace("{a}", amount.ToString());
        text = HandleBracketTags(text);
        return silenced ? ("<s>" + text + "</s>") : text;
    }

    public static string HandleBracketTags(string text)
    {
        while (true)
        {
            int num = text.IndexOf('[');
            if (num < 0)
            {
                break;
            }
            int num2 = text.IndexOf(']') - num + 1;
            if (num2 <= 0)
            {
                break;
            }
            string text2 = text.Substring(num + 1, num2 - 2);
            char c = ((text2.Length > 1 && num > 0) ? text2[1] : text2[0]);
            text = text.Remove(num, num2);
            text = text.Insert(num, c.ToString());
        }
        return text;
    }
}
[Serializable]
public class SettingsLocaleSelector : IStartupLocaleSelector
{
    [SerializeField]
    public string settingsKey = "Language";

    public Locale GetStartupLocale(ILocalesProvider availableLocales)
    {
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        if (Settings.Exists(settingsKey))
        {
            string text = Settings.Load(settingsKey, "");
            if (!StringExt.IsNullOrWhitespace(text))
            {
                return availableLocales.GetLocale(LocaleIdentifier.op_Implicit(text));
            }
        }
        return null;
    }
}
public class ModHolder : MonoBehaviour
{
    public WildfrostMod Mod;

    public TextMeshProUGUI Title;

    public TextMeshProUGUI Description;

    public Image Icon;

    public GameObject PublishButton;

    public ToggleSprite[] toggleSprites;

    public BellRinger bellRinger;

    public bool DrawingUpload;

    public void OnEnable()
    {
        Events.OnModLoaded += ModToggled;
        Events.OnModUnloaded += ModToggled;
    }

    public void OnDisable()
    {
        Events.OnModLoaded -= ModToggled;
        Events.OnModUnloaded -= ModToggled;
    }

    public void ModToggled(WildfrostMod mod)
    {
        if (!(mod.GUID != Mod.GUID))
        {
            UpdateSprites();
        }
    }

    public void ToggleMod()
    {
        Mod.ModToggle();
        if (Mod.HasLoaded)
        {
            bellRinger.Ring();
        }
    }

    public void OnGUI()
    {
        if (DrawingUpload)
        {
            if (GUILayout.Button("Confirm publish for " + Mod.GUID, Array.Empty<GUILayoutOption>()))
            {
                Mod.UpdateOrPublishWorkshop();
                DrawingUpload = false;
            }
            else if (GUILayout.Button("Cancel publish for " + Mod.GUID, Array.Empty<GUILayoutOption>()))
            {
                DrawingUpload = false;
            }
        }
    }

    public void PublishMod()
    {
        DrawingUpload = true;
    }

    public void OpenModDirectory()
    {
        Process.Start(Mod.ModDirectory);
    }

    public void UpdateInfo()
    {
        ((TMP_Text)Title).text = Mod.Title;
        ((TMP_Text)Description).text = Mod.Description;
        Icon.sprite = Mod.IconSprite;
        PublishButton.SetActive(Mod.ModDirectory.Contains(Application.streamingAssetsPath));
        UpdateSprites();
    }

    public void UpdateSprites()
    {
        ToggleSprite[] array = toggleSprites;
        for (int i = 0; i < array.Length; i++)
        {
            array[i].Set(Mod.HasLoaded);
        }
    }
}
public class CoroutineManager : MonoBehaviour
{
    public class State
    {
        public delegate void FinishedHandler(bool manualStop);

        public IEnumerator coroutine;

        public bool running;

        public bool paused;

        public bool stopped;

        public bool IsRunning => running;

        public bool IsPaused => paused;

        public event FinishedHandler Finished;

        public State(IEnumerator coroutine)
        {
            this.coroutine = coroutine;
        }

        public void Pause()
        {
            paused = true;
        }

        public void Unpause()
        {
            paused = false;
        }

        public void Start()
        {
            running = true;
            ((MonoBehaviour)instance).StartCoroutine(CallWrapper());
        }

        public void Stop()
        {
            stopped = true;
            running = false;
        }

        public IEnumerator CallWrapper()
        {
            yield return null;
            IEnumerator e = coroutine;
            while (running)
            {
                if (paused)
                {
                    yield return null;
                }
                else if (e != null && e.MoveNext())
                {
                    yield return e.Current;
                }
                else
                {
                    running = false;
                }
            }
            this.Finished?.Invoke(stopped);
        }
    }

    public static CoroutineManager instance;

    public static void InstanceCheck()
    {
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        if (!(instance))
        {
            instance = Object.FindObjectOfType<CoroutineManager>();
            if (!(instance))
            {
                instance = new GameObject("CoroutineManager").AddComponent<CoroutineManager>();
            }
        }
    }

    public static State Create(IEnumerator coroutine)
    {
        InstanceCheck();
        return new State(coroutine);
    }

    public static void Start(IEnumerator coroutine)
    {
        InstanceCheck();
        ((MonoBehaviour)instance).StartCoroutine(coroutine);
    }
}
public class Routine
{
    public delegate void FinishedHandler(bool manualStop);

    public class Clump
    {
        public readonly List<Routine> list = new List<Routine>();

        public int Count => list.Count;

        public static Clump Create(params IEnumerator[] routines)
        {
            Clump clump = new Clump();
            foreach (IEnumerator c in routines)
            {
                clump.Add(c);
            }
            return clump;
        }

        public void Add(Routine item)
        {
            list.Add(item);
        }

        public void Add(IEnumerator c)
        {
            Add(new Routine(c));
        }

        public IEnumerator WaitForEnd()
        {
            while (Count > 0)
            {
                bool flag = false;
                foreach (Routine item in list)
                {
                    if (item != null && item.IsRunning)
                    {
                        flag = true;
                        break;
                    }
                }
                if (flag)
                {
                    yield return null;
                    continue;
                }
                break;
            }
        }

        public void Clear()
        {
            foreach (Routine item in list)
            {
                item.Stop();
            }
            list.Clear();
        }
    }

    public readonly CoroutineManager.State task;

    public bool IsRunning => task.IsRunning;

    public bool IsPaused => task.IsPaused;

    public event FinishedHandler Finished;

    public Routine(IEnumerator c, bool autoStart = true)
    {
        task = CoroutineManager.Create(c);
        task.Finished += TaskFinished;
        if (autoStart)
        {
            Start();
        }
    }

    public static Routine Create(IEnumerator c, bool autoStart = true)
    {
        return new Routine(c, autoStart);
    }

    public void Start()
    {
        task.Start();
    }

    public void Stop()
    {
        task.Stop();
    }

    public void Pause()
    {
        task.Pause();
    }

    public void Unpause()
    {
        task.Unpause();
    }

    public void TaskFinished(bool manual)
    {
        this.Finished?.Invoke(manual);
    }
}
public class LeanAudioStream
{
    public int position;

    public AudioClip audioClip;

    public float[] audioArr;

    public LeanAudioStream(float[] audioArr)
    {
        this.audioArr = audioArr;
    }

    public void OnAudioRead(float[] data)
    {
        for (int i = 0; i < data.Length; i++)
        {
            data[i] = audioArr[position];
            position++;
        }
    }

    public void OnAudioSetPosition(int newPosition)
    {
        position = newPosition;
    }
}
public class LeanAudio
{
    public static float MIN_FREQEUNCY_PERIOD = 0.000115f;

    public static int PROCESSING_ITERATIONS_MAX = 50000;

    public static float[] generatedWaveDistances;

    public static int generatedWaveDistancesCount = 0;

    public static float[] longList;

    public static LeanAudioOptions options()
    {
        if (generatedWaveDistances == null)
        {
            generatedWaveDistances = new float[PROCESSING_ITERATIONS_MAX];
            longList = new float[PROCESSING_ITERATIONS_MAX];
        }
        return new LeanAudioOptions();
    }

    public static LeanAudioStream createAudioStream(AnimationCurve volume, AnimationCurve frequency, LeanAudioOptions options = null)
    {
        options ??= new LeanAudioOptions();
        options.useSetData = false;
        createAudioFromWave(createAudioWave(volume, frequency, options), options);
        return options.stream;
    }

    public static AudioClip createAudio(AnimationCurve volume, AnimationCurve frequency, LeanAudioOptions options = null)
    {
        options ??= new LeanAudioOptions();
        return createAudioFromWave(createAudioWave(volume, frequency, options), options);
    }

    public static int createAudioWave(AnimationCurve volume, AnimationCurve frequency, LeanAudioOptions options)
    {
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        Keyframe val = volume[volume.length - 1];
        float time = ((val)).time;
        int num = 0;
        float num2 = 0f;
        for (int i = 0; i < PROCESSING_ITERATIONS_MAX; i++)
        {
            float num3 = frequency.Evaluate(num2);
            if (num3 < MIN_FREQEUNCY_PERIOD)
            {
                num3 = MIN_FREQEUNCY_PERIOD;
            }
            float num4 = volume.Evaluate(num2 + 0.5f * num3);
            if (options.vibrato != null)
            {
                for (int j = 0; j < options.vibrato.Length; j++)
                {
                    float num5 = Mathf.Abs(Mathf.Sin(1.5708f + num2 * (1f / ((options.vibrato[j]))[0]) * (float)Math.PI));
                    float num6 = 1f - ((options.vibrato[j]))[1];
                    num5 = ((options.vibrato[j]))[1] + num6 * num5;
                    num4 *= num5;
                }
            }
            if (num2 + 0.5f * num3 >= time)
            {
                break;
            }
            if (num >= PROCESSING_ITERATIONS_MAX - 1)
            {
                Debug.LogError(("LeanAudio has reached it's processing cap. To avoid this error increase the number of iterations ex: LeanAudio.PROCESSING_ITERATIONS_MAX = " + PROCESSING_ITERATIONS_MAX * 2));
                break;
            }
            int num7 = num / 2;
            num2 += num3;
            generatedWaveDistances[num7] = num2;
            longList[num] = num2;
            longList[num + 1] = ((i % 2 == 0) ? (0f - num4) : num4);
            num += 2;
        }
        num += -2;
        generatedWaveDistancesCount = num / 2;
        return num;
    }

    public static AudioClip createAudioFromWave(int waveLength, LeanAudioOptions options)
    {
        //IL_0270: Unknown result type (might be due to invalid IL or missing references)
        //IL_0281: Unknown result type (might be due to invalid IL or missing references)
        //IL_028b: Expected O, but got Unknown
        //IL_028b: Expected O, but got Unknown
        //IL_0231: Unknown result type (might be due to invalid IL or missing references)
        //IL_023b: Expected O, but got Unknown
        float num = longList[waveLength - 2];
        float[] array = new float[(int)((float)options.frequencyRate * num)];
        int num2 = 0;
        float num3 = longList[num2];
        float num4 = 0f;
        _ = longList[num2];
        float num5 = longList[num2 + 1];
        for (int i = 0; i < array.Length; i++)
        {
            float num6 = (float)i / (float)options.frequencyRate;
            if (num6 > longList[num2])
            {
                num4 = longList[num2];
                num2 += 2;
                num3 = longList[num2] - longList[num2 - 2];
                num5 = longList[num2 + 1];
            }
            float num7 = (num6 - num4) / num3;
            float num8 = Mathf.Sin(num7 * (float)Math.PI);
            if (options.waveStyle == LeanAudioOptions.LeanAudioWaveStyle.Square)
            {
                if (num8 > 0f)
                {
                    num8 = 1f;
                }
                if (num8 < 0f)
                {
                    num8 = -1f;
                }
            }
            else if (options.waveStyle == LeanAudioOptions.LeanAudioWaveStyle.Sawtooth)
            {
                float num9 = ((num8 > 0f) ? 1f : (-1f));
                num8 = ((!(num7 < 0.5f)) ? ((1f - num7) * 2f * num9) : (num7 * 2f * num9));
            }
            else if (options.waveStyle == LeanAudioOptions.LeanAudioWaveStyle.Noise)
            {
                float num10 = 1f - options.waveNoiseInfluence + Mathf.PerlinNoise(0f, num6 * options.waveNoiseScale) * options.waveNoiseInfluence;
                num8 *= num10;
            }
            num8 *= num5;
            if (options.modulation != null)
            {
                for (int j = 0; j < options.modulation.Length; j++)
                {
                    float num11 = Mathf.Abs(Mathf.Sin(1.5708f + num6 * (1f / ((options.modulation[j]))[0]) * (float)Math.PI));
                    float num12 = 1f - ((options.modulation[j]))[1];
                    num11 = ((options.modulation[j]))[1] + num12 * num11;
                    num8 *= num11;
                }
            }
            array[i] = num8;
        }
        int num13 = array.Length;
        AudioClip val = null;
        if (options.useSetData)
        {
            val = AudioClip.Create("Generated Audio", num13, 1, options.frequencyRate, false, (PCMReaderCallback)null, new PCMSetPositionCallback(OnAudioSetPosition));
            val.SetData(array, 0);
        }
        else
        {
            options.stream = new LeanAudioStream(array);
            val = AudioClip.Create("Generated Audio", num13, 1, options.frequencyRate, false, new PCMReaderCallback(options.stream.OnAudioRead), new PCMSetPositionCallback(options.stream.OnAudioSetPosition));
            options.stream.audioClip = val;
        }
        return val;
    }

    public static void OnAudioSetPosition(int newPosition)
    {
    }

    public static AudioClip generateAudioFromCurve(AnimationCurve curve, int frequencyRate = 44100)
    {
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        Keyframe val = curve[curve.length - 1];
        float time = ((val)).time;
        float[] array = new float[(int)((float)frequencyRate * time)];
        for (int i = 0; i < array.Length; i++)
        {
            float num = (float)i / (float)frequencyRate;
            array[i] = curve.Evaluate(num);
        }
        int num2 = array.Length;
        AudioClip obj = AudioClip.Create("Generated Audio", num2, 1, frequencyRate, false);
        obj.SetData(array, 0);
        return obj;
    }

    public static AudioSource play(AudioClip audio, float volume)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        AudioSource obj = playClipAt(audio, Vector3.zero);
        obj.volume = volume;
        return obj;
    }

    public static AudioSource play(AudioClip audio)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return playClipAt(audio, Vector3.zero);
    }

    public static AudioSource play(AudioClip audio, Vector3 pos)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return playClipAt(audio, pos);
    }

    public static AudioSource play(AudioClip audio, Vector3 pos, float volume)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        AudioSource obj = playClipAt(audio, pos);
        obj.minDistance = 1f;
        obj.volume = volume;
        return obj;
    }

    public static AudioSource playClipAt(AudioClip clip, Vector3 pos)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Expected O, but got Unknown
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        GameObject val = new GameObject();
        val.transform.position = pos;
        AudioSource obj = val.AddComponent<AudioSource>();
        obj.clip = clip;
        obj.Play();
        Object.Destroy(val, clip.length);
        return obj;
    }

    public static void printOutAudioClip(AudioClip audioClip, ref AnimationCurve curve, float scaleX = 1f)
    {
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Expected O, but got Unknown
        float[] array = new float[audioClip.samples * audioClip.channels];
        audioClip.GetData(array, 0);
        int i = 0;
        Keyframe[] array2 = (Keyframe[])(object)new Keyframe[array.Length];
        for (; i < array.Length; i++)
        {
            array2[i] = new Keyframe((float)i * scaleX, array[i]);
        }
        curve = new AnimationCurve(array2);
    }
}
public class LeanAudioOptions
{
    public enum LeanAudioWaveStyle
    {
        Sine,
        Square,
        Sawtooth,
        Noise
    }

    public LeanAudioWaveStyle waveStyle;

    public Vector3[] vibrato;

    public Vector3[] modulation;

    public int frequencyRate = 44100;

    public float waveNoiseScale = 1000f;

    public float waveNoiseInfluence = 1f;

    public bool useSetData = true;

    public LeanAudioStream stream;

    public LeanAudioOptions setFrequency(int frequencyRate)
    {
        this.frequencyRate = frequencyRate;
        return this;
    }

    public LeanAudioOptions setVibrato(Vector3[] vibrato)
    {
        this.vibrato = vibrato;
        return this;
    }

    public LeanAudioOptions setWaveSine()
    {
        waveStyle = LeanAudioWaveStyle.Sine;
        return this;
    }

    public LeanAudioOptions setWaveSquare()
    {
        waveStyle = LeanAudioWaveStyle.Square;
        return this;
    }

    public LeanAudioOptions setWaveSawtooth()
    {
        waveStyle = LeanAudioWaveStyle.Sawtooth;
        return this;
    }

    public LeanAudioOptions setWaveNoise()
    {
        waveStyle = LeanAudioWaveStyle.Noise;
        return this;
    }

    public LeanAudioOptions setWaveStyle(LeanAudioWaveStyle style)
    {
        waveStyle = style;
        return this;
    }

    public LeanAudioOptions setWaveNoiseScale(float waveScale)
    {
        waveNoiseScale = waveScale;
        return this;
    }

    public LeanAudioOptions setWaveNoiseInfluence(float influence)
    {
        waveNoiseInfluence = influence;
        return this;
    }
}
public class LeanSmooth
{
    public static float damp(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f)
    {
        if (deltaTime < 0f)
        {
            deltaTime = Time.deltaTime;
        }
        smoothTime = Mathf.Max(0.0001f, smoothTime);
        float num = 2f / smoothTime;
        float num2 = num * deltaTime;
        float num3 = 1f / (1f + num2 + 0.48f * num2 * num2 + 0.235f * num2 * num2 * num2);
        float num4 = current - target;
        float num5 = target;
        if (maxSpeed > 0f)
        {
            float num6 = maxSpeed * smoothTime;
            num4 = Mathf.Clamp(num4, 0f - num6, num6);
        }
        target = current - num4;
        float num7 = (currentVelocity + num * num4) * deltaTime;
        currentVelocity = (currentVelocity - num * num7) * num3;
        float num8 = target + (num4 + num7) * num3;
        if (num5 - current > 0f == num8 > num5)
        {
            num8 = num5;
            currentVelocity = (num8 - num5) / deltaTime;
        }
        return num8;
    }

    public static Vector3 damp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        float num = damp(current.x, target.x, ref currentVelocity.x, smoothTime, maxSpeed, deltaTime);
        float num2 = damp(current.y, target.y, ref currentVelocity.y, smoothTime, maxSpeed, deltaTime);
        float num3 = damp(current.z, target.z, ref currentVelocity.z, smoothTime, maxSpeed, deltaTime);
        return new Vector3(num, num2, num3);
    }

    public static Color damp(Color current, Color target, ref Color currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0056: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0076: Unknown result type (might be due to invalid IL or missing references)
        float num = damp(current.r, target.r, ref currentVelocity.r, smoothTime, maxSpeed, deltaTime);
        float num2 = damp(current.g, target.g, ref currentVelocity.g, smoothTime, maxSpeed, deltaTime);
        float num3 = damp(current.b, target.b, ref currentVelocity.b, smoothTime, maxSpeed, deltaTime);
        float num4 = damp(current.a, target.a, ref currentVelocity.a, smoothTime, maxSpeed, deltaTime);
        return new Color(num, num2, num3, num4);
    }

    public static float spring(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f)
    {
        if (deltaTime < 0f)
        {
            deltaTime = Time.deltaTime;
        }
        float num = target - current;
        currentVelocity += deltaTime / smoothTime * accelRate * num;
        currentVelocity *= 1f - deltaTime * friction;
        if (maxSpeed > 0f && maxSpeed < Mathf.Abs(currentVelocity))
        {
            currentVelocity = maxSpeed * Mathf.Sign(currentVelocity);
        }
        return current + currentVelocity;
    }

    public static Vector3 spring(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        float num = spring(current.x, target.x, ref currentVelocity.x, smoothTime, maxSpeed, deltaTime, friction, accelRate);
        float num2 = spring(current.y, target.y, ref currentVelocity.y, smoothTime, maxSpeed, deltaTime, friction, accelRate);
        float num3 = spring(current.z, target.z, ref currentVelocity.z, smoothTime, maxSpeed, deltaTime, friction, accelRate);
        return new Vector3(num, num2, num3);
    }

    public static Color spring(Color current, Color target, ref Color currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        float num = spring(current.r, target.r, ref currentVelocity.r, smoothTime, maxSpeed, deltaTime, friction, accelRate);
        float num2 = spring(current.g, target.g, ref currentVelocity.g, smoothTime, maxSpeed, deltaTime, friction, accelRate);
        float num3 = spring(current.b, target.b, ref currentVelocity.b, smoothTime, maxSpeed, deltaTime, friction, accelRate);
        float num4 = spring(current.a, target.a, ref currentVelocity.a, smoothTime, maxSpeed, deltaTime, friction, accelRate);
        return new Color(num, num2, num3, num4);
    }

    public static float linear(float current, float target, float moveSpeed, float deltaTime = -1f)
    {
        if (deltaTime < 0f)
        {
            deltaTime = Time.deltaTime;
        }
        bool flag = target > current;
        float num = deltaTime * moveSpeed * (flag ? 1f : (-1f));
        float num2 = current + num;
        float num3 = num2 - target;
        if ((flag && num3 > 0f) || (!flag && num3 < 0f))
        {
            return target;
        }
        return num2;
    }

    public static Vector3 linear(Vector3 current, Vector3 target, float moveSpeed, float deltaTime = -1f)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        float num = linear(current.x, target.x, moveSpeed, deltaTime);
        float num2 = linear(current.y, target.y, moveSpeed, deltaTime);
        float num3 = linear(current.z, target.z, moveSpeed, deltaTime);
        return new Vector3(num, num2, num3);
    }

    public static Color linear(Color current, Color target, float moveSpeed)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        float num = linear(current.r, target.r, moveSpeed);
        float num2 = linear(current.g, target.g, moveSpeed);
        float num3 = linear(current.b, target.b, moveSpeed);
        float num4 = linear(current.a, target.a, moveSpeed);
        return new Color(num, num2, num3, num4);
    }

    public static float bounceOut(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f, float hitDamping = 0.9f)
    {
        if (deltaTime < 0f)
        {
            deltaTime = Time.deltaTime;
        }
        float num = target - current;
        currentVelocity += deltaTime / smoothTime * accelRate * num;
        currentVelocity *= 1f - deltaTime * friction;
        if (maxSpeed > 0f && maxSpeed < Mathf.Abs(currentVelocity))
        {
            currentVelocity = maxSpeed * Mathf.Sign(currentVelocity);
        }
        float num2 = current + currentVelocity;
        bool flag = target > current;
        float num3 = num2 - target;
        if ((flag && num3 > 0f) || (!flag && num3 < 0f))
        {
            currentVelocity = (0f - currentVelocity) * hitDamping;
            num2 = current + currentVelocity;
        }
        return num2;
    }

    public static Vector3 bounceOut(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f, float hitDamping = 0.9f)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        float num = bounceOut(current.x, target.x, ref currentVelocity.x, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
        float num2 = bounceOut(current.y, target.y, ref currentVelocity.y, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
        float num3 = bounceOut(current.z, target.z, ref currentVelocity.z, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
        return new Vector3(num, num2, num3);
    }

    public static Color bounceOut(Color current, Color target, ref Color currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f, float hitDamping = 0.9f)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        float num = bounceOut(current.r, target.r, ref currentVelocity.r, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
        float num2 = bounceOut(current.g, target.g, ref currentVelocity.g, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
        float num3 = bounceOut(current.b, target.b, ref currentVelocity.b, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
        float num4 = bounceOut(current.a, target.a, ref currentVelocity.a, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
        return new Color(num, num2, num3, num4);
    }
}
public class LeanTester : MonoBehaviour
{
    public float timeout = 15f;

    public void Start()
    {
        StartCoroutine(timeoutCheck());
    }

    public IEnumerator timeoutCheck()
    {
        float pauseEndTime = Time.realtimeSinceStartup + timeout;
        while (Time.realtimeSinceStartup < pauseEndTime)
        {
            yield return 0;
        }
        if (!LeanTest.testsFinished)
        {
            Debug.Log(LeanTest.formatB("Tests timed out!"));
            LeanTest.overview();
        }
    }
}
public class LeanTest
{
    public static int expected = 0;

    public static int tests = 0;

    public static int passes = 0;

    public static float timeout = 15f;

    public static bool timeoutStarted = false;

    public static bool testsFinished = false;

    public static void debug(string name, bool didPass, string failExplaination = null)
    {
        expect(didPass, name, failExplaination);
    }

    public static void expect(bool didPass, string definition, string failExplaination = null)
    {
        //IL_010b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0110: Unknown result type (might be due to invalid IL or missing references)
        //IL_011b: Unknown result type (might be due to invalid IL or missing references)
        float num = printOutLength(definition);
        int totalWidth = 40 - (int)(num * 1.05f);
        string text = "".PadRight(totalWidth, "_"[0]);
        string text2 = formatB(definition) + " " + text + " [ " + (didPass ? formatC("pass", "green") : formatC("fail", "red")) + " ]";
        if (!didPass && failExplaination != null)
        {
            text2 = text2 + " - " + failExplaination;
        }
        Debug.Log(text2);
        if (didPass)
        {
            passes++;
        }
        tests++;
        if (tests == expected && !testsFinished)
        {
            overview();
        }
        else if (tests > expected)
        {
            Debug.Log((formatB("Too many tests for a final report!") + " set LeanTest.expected = " + tests));
        }
        if (!timeoutStarted)
        {
            timeoutStarted = true;
            GameObject val = new GameObject
            {
                name = "~LeanTest"
            };
            (val.AddComponent(typeof(LeanTester)) as LeanTester).timeout = timeout;
            (val).hideFlags = (HideFlags)61;
        }
    }

    public static string padRight(int len)
    {
        string text = "";
        for (int i = 0; i < len; i++)
        {
            text += "_";
        }
        return text;
    }

    public static float printOutLength(string str)
    {
        float num = 0f;
        for (int i = 0; i < str.Length; i++)
        {
            num = ((str[i] != "I"[0]) ? ((str[i] != "J"[0]) ? (num + 1f) : (num + 0.85f)) : (num + 0.5f));
        }
        return num;
    }

    public static string formatBC(string str, string color)
    {
        return formatC(formatB(str), color);
    }

    public static string formatB(string str)
    {
        return "<b>" + str + "</b>";
    }

    public static string formatC(string str, string color)
    {
        return "<color=" + color + ">" + str + "</color>";
    }

    public static void overview()
    {
        testsFinished = true;
        int num = expected - passes;
        string text = ((num > 0) ? formatBC(num.ToString() ?? "", "red") : (num.ToString() ?? ""));
        Debug.Log((formatB("Final Report:") + " _____________________ PASSED: " + formatBC(passes.ToString() ?? "", "green") + " FAILED: " + text + " "));
    }
}
public enum TweenAction
{
    MOVE_X,
    MOVE_Y,
    MOVE_Z,
    MOVE_LOCAL_X,
    MOVE_LOCAL_Y,
    MOVE_LOCAL_Z,
    MOVE_CURVED,
    MOVE_CURVED_LOCAL,
    MOVE_SPLINE,
    MOVE_SPLINE_LOCAL,
    SCALE_X,
    SCALE_Y,
    SCALE_Z,
    ROTATE_X,
    ROTATE_Y,
    ROTATE_Z,
    ROTATE_AROUND,
    ROTATE_AROUND_LOCAL,
    CANVAS_ROTATEAROUND,
    CANVAS_ROTATEAROUND_LOCAL,
    CANVAS_PLAYSPRITE,
    ALPHA,
    TEXT_ALPHA,
    CANVAS_ALPHA,
    CANVASGROUP_ALPHA,
    ALPHA_VERTEX,
    COLOR,
    CALLBACK_COLOR,
    TEXT_COLOR,
    CANVAS_COLOR,
    CANVAS_MOVE_X,
    CANVAS_MOVE_Y,
    CANVAS_MOVE_Z,
    CALLBACK,
    MOVE,
    MOVE_LOCAL,
    MOVE_TO_TRANSFORM,
    ROTATE,
    ROTATE_LOCAL,
    SCALE,
    VALUE3,
    GUI_MOVE,
    GUI_MOVE_MARGIN,
    GUI_SCALE,
    GUI_ALPHA,
    GUI_ROTATE,
    DELAYED_SOUND,
    CANVAS_MOVE,
    CANVAS_SCALE,
    CANVAS_SIZEDELTA,
    FOLLOW
}
public enum LeanTweenType
{
    notUsed,
    linear,
    easeOutQuad,
    easeInQuad,
    easeInOutQuad,
    easeInCubic,
    easeOutCubic,
    easeInOutCubic,
    easeInQuart,
    easeOutQuart,
    easeInOutQuart,
    easeInQuint,
    easeOutQuint,
    easeInOutQuint,
    easeInSine,
    easeOutSine,
    easeInOutSine,
    easeInExpo,
    easeOutExpo,
    easeInOutExpo,
    easeInCirc,
    easeOutCirc,
    easeInOutCirc,
    easeInBounce,
    easeOutBounce,
    easeInOutBounce,
    easeInBack,
    easeOutBack,
    easeInOutBack,
    easeInElastic,
    easeOutElastic,
    easeInOutElastic,
    easeSpring,
    easeShake,
    punch,
    once,
    clamp,
    pingPong,
    animationCurve
}
public enum LeanProp
{
    position,
    localPosition,
    x,
    y,
    z,
    localX,
    localY,
    localZ,
    scale,
    color
}
public class LeanTween : MonoBehaviour
{
    public static bool throwErrors = true;

    public static float tau = (float)Math.PI * 2f;

    public static float PI_DIV2 = (float)Math.PI / 2f;

    public static LTSeq[] sequences;

    public static LTDescr[] tweens;

    public static int[] tweensFinished;

    public static int[] tweensFinishedIds;

    public static LTDescr tween;

    public static int tweenMaxSearch = -1;

    public static int maxTweens = 400;

    public static int maxSequences = 400;

    public static int frameRendered = -1;

    public static GameObject _tweenEmpty;

    public static float dtEstimated = -1f;

    public static float dtManual;

    public static float dtActual;

    public static uint global_counter = 0u;

    public static int i;

    public static int j;

    public static int finishedCnt;

    public static AnimationCurve punch = new AnimationCurve((Keyframe[])(object)new Keyframe[9]
    {
        new Keyframe(0f, 0f),
        new Keyframe(0.112586f, 0.9976035f),
        new Keyframe(0.3120486f, -0.1720615f),
        new Keyframe(0.4316337f, 0.07030682f),
        new Keyframe(0.5524869f, -0.03141804f),
        new Keyframe(0.6549395f, 0.003909959f),
        new Keyframe(0.770987f, -0.009817753f),
        new Keyframe(0.8838775f, 0.001939224f),
        new Keyframe(1f, 0f)
    });

    public static AnimationCurve shake = new AnimationCurve((Keyframe[])(object)new Keyframe[4]
    {
        new Keyframe(0f, 0f),
        new Keyframe(0.25f, 1f),
        new Keyframe(0.75f, -1f),
        new Keyframe(1f, 0f)
    });

    public static int maxTweenReached;

    public static int startSearch = 0;

    public static LTDescr d;

    public static System.Action<LTEvent>[] eventListeners;

    public static GameObject[] goListeners;

    public static int eventsMaxSearch = 0;

    public static int EVENTS_MAX = 10;

    public static int LISTENERS_MAX = 10;

    public static int INIT_LISTENERS_MAX = LISTENERS_MAX;

    public static int maxSearch => tweenMaxSearch;

    public static int maxSimulataneousTweens => maxTweens;

    public static int tweensRunning
    {
        get
        {
            int num = 0;
            for (int i = 0; i <= tweenMaxSearch; i++)
            {
                if (tweens[i].toggle)
                {
                    num++;
                }
            }
            return num;
        }
    }

    public static GameObject tweenEmpty
    {
        get
        {
            init(maxTweens);
            return _tweenEmpty;
        }
    }

    public static void init()
    {
        init(maxTweens);
    }

    public static void init(int maxSimultaneousTweens)
    {
        init(maxSimultaneousTweens, maxSequences);
    }

    public static void init(int maxSimultaneousTweens, int maxSimultaneousSequences)
    {
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Expected O, but got Unknown
        if (tweens == null)
        {
            maxTweens = maxSimultaneousTweens;
            tweens = new LTDescr[maxTweens];
            tweensFinished = new int[maxTweens];
            tweensFinishedIds = new int[maxTweens];
            _tweenEmpty = new GameObject();
            (_tweenEmpty).name = "~LeanTween";
            _tweenEmpty.AddComponent(typeof(LeanTween));
            _tweenEmpty.isStatic = true;
            (_tweenEmpty).hideFlags = (HideFlags)61;
            Object.DontDestroyOnLoad(_tweenEmpty);
            for (int i = 0; i < maxTweens; i++)
            {
                tweens[i] = new LTDescr();
            }
            SceneManager.sceneLoaded += onLevelWasLoaded54;
            sequences = new LTSeq[maxSimultaneousSequences];
            for (int j = 0; j < maxSimultaneousSequences; j++)
            {
                sequences[j] = new LTSeq();
            }
        }
    }

    public static void reset()
    {
        if (tweens != null)
        {
            for (int i = 0; i <= tweenMaxSearch; i++)
            {
                if (tweens[i] != null)
                {
                    tweens[i].toggle = false;
                }
            }
        }
        tweens = null;
        Object.Destroy(_tweenEmpty);
    }

    public void Update()
    {
        update();
    }

    public static void onLevelWasLoaded54(Scene scene, LoadSceneMode mode)
    {
        internalOnLevelWasLoaded(((scene)).buildIndex);
    }

    public static void internalOnLevelWasLoaded(int lvl)
    {
        LTGUI.reset();
    }

    public static void update()
    {
        if (frameRendered == Time.frameCount)
        {
            return;
        }
        init();
        dtEstimated = ((dtEstimated < 0f) ? 0f : (dtEstimated = Time.unscaledDeltaTime));
        dtActual = Time.deltaTime;
        maxTweenReached = 0;
        finishedCnt = 0;
        for (int i = 0; i <= tweenMaxSearch && i < maxTweens; i++)
        {
            tween = tweens[i];
            if (tween.toggle)
            {
                maxTweenReached = i;
                if (tween.updateInternal())
                {
                    tweensFinished[finishedCnt] = i;
                    tweensFinishedIds[finishedCnt] = tweens[i].id;
                    finishedCnt++;
                }
            }
        }
        tweenMaxSearch = maxTweenReached;
        frameRendered = Time.frameCount;
        for (int j = 0; j < finishedCnt; j++)
        {
            LeanTween.j = tweensFinished[j];
            tween = tweens[LeanTween.j];
            if (tween.id == tweensFinishedIds[j])
            {
                removeTween(LeanTween.j);
                if (tween.hasExtraOnCompletes && tween.trans != null)
                {
                    tween.callOnCompletes();
                }
            }
        }
    }

    public static void removeTween(int i, int uniqueId)
    {
        if (tweens[i].uniqueId == uniqueId)
        {
            removeTween(i);
        }
    }

    public static void removeTween(int i)
    {
        if (!tweens[i].toggle)
        {
            return;
        }
        tweens[i].toggle = false;
        tweens[i].counter = uint.MaxValue;
        if (tweens[i].destroyOnComplete)
        {
            if (tweens[i]._optional.ltRect != null)
            {
                LTGUI.destroy(tweens[i]._optional.ltRect.id);
            }
            else if (tweens[i].trans != null && ((Component)tweens[i].trans).gameObject != _tweenEmpty)
            {
                Object.Destroy(((Component)tweens[i].trans).gameObject);
            }
        }
        startSearch = i;
        if (i + 1 >= tweenMaxSearch)
        {
            startSearch = 0;
        }
    }

    public static Vector3[] add(Vector3[] a, Vector3 b)
    {
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        Vector3[] array = (Vector3[])(object)new Vector3[a.Length];
        for (i = 0; i < a.Length; i++)
        {
            array[i] = a[i] + b;
        }
        return array;
    }

    public static float closestRot(float from, float to)
    {
        float num = 0f - (360f - to);
        float num2 = 360f + to;
        float num3 = Mathf.Abs(to - from);
        float num4 = Mathf.Abs(num - from);
        float num5 = Mathf.Abs(num2 - from);
        if (num3 < num4 && num3 < num5)
        {
            return to;
        }
        if (num4 < num5)
        {
            return num;
        }
        return num2;
    }

    public static void cancelAll()
    {
        cancelAll(callComplete: false);
    }

    public static void cancelAll(bool callComplete)
    {
        init();
        for (int i = 0; i <= tweenMaxSearch; i++)
        {
            if (tweens[i].trans != null)
            {
                if (callComplete && tweens[i].optional.onComplete != null)
                {
                    tweens[i].optional.onComplete();
                }
                removeTween(i);
            }
        }
    }

    public static void cancel(GameObject gameObject)
    {
        cancel(gameObject, callOnComplete: false);
    }

    public static void cancel(GameObject gameObject, bool callOnComplete)
    {
        init();
        Transform transform = gameObject.transform;
        for (int i = 0; i <= tweenMaxSearch; i++)
        {
            LTDescr lTDescr = tweens[i];
            if (lTDescr != null && lTDescr.toggle && lTDescr.trans == transform)
            {
                if (callOnComplete && lTDescr.optional.onComplete != null)
                {
                    lTDescr.optional.onComplete();
                }
                removeTween(i);
            }
        }
    }

    public static void cancel(RectTransform rect)
    {
        cancel(((Component)rect).gameObject, callOnComplete: false);
    }

    public static void cancel(GameObject gameObject, int uniqueId, bool callOnComplete = false)
    {
        if (uniqueId < 0)
        {
            return;
        }
        init();
        int num = uniqueId & 0xFFFF;
        int num2 = uniqueId >> 16;
        if (tweens[num].trans == null || (((Component)tweens[num].trans).gameObject == gameObject && tweens[num].counter == num2))
        {
            if (callOnComplete && tweens[num].optional.onComplete != null)
            {
                tweens[num].optional.onComplete();
            }
            removeTween(num);
        }
    }

    public static void cancel(LTRect ltRect, int uniqueId)
    {
        if (uniqueId >= 0)
        {
            init();
            int num = uniqueId & 0xFFFF;
            int num2 = uniqueId >> 16;
            if (tweens[num]._optional.ltRect == ltRect && tweens[num].counter == num2)
            {
                removeTween(num);
            }
        }
    }

    public static void cancel(int uniqueId)
    {
        cancel(uniqueId, callOnComplete: false);
    }

    public static void cancel(int uniqueId, bool callOnComplete)
    {
        if (uniqueId < 0)
        {
            return;
        }
        init();
        int num = uniqueId & 0xFFFF;
        int num2 = uniqueId >> 16;
        if (num > tweens.Length - 1)
        {
            int num3 = num - tweens.Length;
            LTSeq lTSeq = sequences[num3];
            for (int i = 0; i < maxSequences; i++)
            {
                if (lTSeq.current.tween != null)
                {
                    removeTween(lTSeq.current.tween.uniqueId & 0xFFFF);
                }
                if (lTSeq.current.previous != null)
                {
                    lTSeq.current = lTSeq.current.previous;
                    continue;
                }
                break;
            }
        }
        else if (tweens[num].counter == num2)
        {
            if (callOnComplete && tweens[num].optional.onComplete != null)
            {
                tweens[num].optional.onComplete();
            }
            removeTween(num);
        }
    }

    public static LTDescr descr(int uniqueId)
    {
        init();
        int num = uniqueId & 0xFFFF;
        int num2 = uniqueId >> 16;
        if (tweens[num] != null && tweens[num].uniqueId == uniqueId && tweens[num].counter == num2)
        {
            return tweens[num];
        }
        for (int i = 0; i <= tweenMaxSearch; i++)
        {
            if (tweens[i].uniqueId == uniqueId && tweens[i].counter == num2)
            {
                return tweens[i];
            }
        }
        return null;
    }

    public static LTDescr description(int uniqueId)
    {
        return descr(uniqueId);
    }

    public static LTDescr[] descriptions(GameObject gameObject = null)
    {
        if (gameObject == null)
        {
            return null;
        }
        List<LTDescr> list = new List<LTDescr>();
        Transform transform = gameObject.transform;
        for (int i = 0; i <= tweenMaxSearch; i++)
        {
            if (tweens[i].toggle && tweens[i].trans == transform)
            {
                list.Add(tweens[i]);
            }
        }
        return list.ToArray();
    }

    [Obsolete("Use 'pause( id )' instead")]
    public static void pause(GameObject gameObject, int uniqueId)
    {
        pause(uniqueId);
    }

    public static void pause(int uniqueId)
    {
        int num = uniqueId & 0xFFFF;
        int num2 = uniqueId >> 16;
        if (tweens[num].counter == num2)
        {
            tweens[num].pause();
        }
    }

    public static void pause(GameObject gameObject)
    {
        Transform transform = gameObject.transform;
        for (int i = 0; i <= tweenMaxSearch; i++)
        {
            if (tweens[i].trans == transform)
            {
                tweens[i].pause();
            }
        }
    }

    public static void pauseAll()
    {
        init();
        for (int i = 0; i <= tweenMaxSearch; i++)
        {
            tweens[i].pause();
        }
    }

    public static void resumeAll()
    {
        init();
        for (int i = 0; i <= tweenMaxSearch; i++)
        {
            tweens[i].resume();
        }
    }

    [Obsolete("Use 'resume( id )' instead")]
    public static void resume(GameObject gameObject, int uniqueId)
    {
        resume(uniqueId);
    }

    public static void resume(int uniqueId)
    {
        int num = uniqueId & 0xFFFF;
        int num2 = uniqueId >> 16;
        if (tweens[num].counter == num2)
        {
            tweens[num].resume();
        }
    }

    public static void resume(GameObject gameObject)
    {
        Transform transform = gameObject.transform;
        for (int i = 0; i <= tweenMaxSearch; i++)
        {
            if (tweens[i].trans == transform)
            {
                tweens[i].resume();
            }
        }
    }

    public static bool isPaused(GameObject gameObject = null)
    {
        if (gameObject == null)
        {
            for (int i = 0; i <= tweenMaxSearch; i++)
            {
                if (object.Equals(tweens[i].direction, 0f))
                {
                    return true;
                }
            }
            return false;
        }
        Transform transform = gameObject.transform;
        for (int j = 0; j <= tweenMaxSearch; j++)
        {
            if (object.Equals(tweens[j].direction, 0f) && tweens[j].trans == transform)
            {
                return true;
            }
        }
        return false;
    }

    public static bool isPaused(RectTransform rect)
    {
        return isTweening(((Component)rect).gameObject);
    }

    public static bool isPaused(int uniqueId)
    {
        int num = uniqueId & 0xFFFF;
        int num2 = uniqueId >> 16;
        if (num < 0 || num >= maxTweens)
        {
            return false;
        }
        if (tweens[num].counter == num2 && object.Equals(tweens[i].direction, 0f))
        {
            return true;
        }
        return false;
    }

    public static bool isTweening(GameObject gameObject = null)
    {
        if (gameObject == null)
        {
            for (int i = 0; i <= tweenMaxSearch; i++)
            {
                if (tweens[i].toggle)
                {
                    return true;
                }
            }
            return false;
        }
        Transform transform = gameObject.transform;
        for (int j = 0; j <= tweenMaxSearch; j++)
        {
            if (tweens[j].toggle && tweens[j].trans == transform)
            {
                return true;
            }
        }
        return false;
    }

    public static bool isTweening(RectTransform rect)
    {
        return isTweening(((Component)rect).gameObject);
    }

    public static bool isTweening(int uniqueId)
    {
        int num = uniqueId & 0xFFFF;
        int num2 = uniqueId >> 16;
        if (num < 0 || num >= maxTweens)
        {
            return false;
        }
        if (tweens[num].counter == num2 && tweens[num].toggle)
        {
            return true;
        }
        return false;
    }

    public static bool isTweening(LTRect ltRect)
    {
        for (int i = 0; i <= tweenMaxSearch; i++)
        {
            if (tweens[i].toggle && tweens[i]._optional.ltRect == ltRect)
            {
                return true;
            }
        }
        return false;
    }

    public static void drawBezierPath(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float arrowSize = 0f, Transform arrowTransform = null)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        //IL_0076: Unknown result type (might be due to invalid IL or missing references)
        //IL_01af: Unknown result type (might be due to invalid IL or missing references)
        //IL_01b2: Unknown result type (might be due to invalid IL or missing references)
        //IL_01b7: Unknown result type (might be due to invalid IL or missing references)
        //IL_01b8: Unknown result type (might be due to invalid IL or missing references)
        //IL_01bf: Unknown result type (might be due to invalid IL or missing references)
        //IL_01c4: Unknown result type (might be due to invalid IL or missing references)
        //IL_01c6: Unknown result type (might be due to invalid IL or missing references)
        //IL_01cd: Unknown result type (might be due to invalid IL or missing references)
        //IL_01d2: Unknown result type (might be due to invalid IL or missing references)
        //IL_01d3: Unknown result type (might be due to invalid IL or missing references)
        //IL_01d8: Unknown result type (might be due to invalid IL or missing references)
        //IL_01d9: Unknown result type (might be due to invalid IL or missing references)
        //IL_01da: Unknown result type (might be due to invalid IL or missing references)
        //IL_01e0: Unknown result type (might be due to invalid IL or missing references)
        //IL_01e1: Unknown result type (might be due to invalid IL or missing references)
        //IL_0095: Unknown result type (might be due to invalid IL or missing references)
        //IL_0098: Unknown result type (might be due to invalid IL or missing references)
        //IL_009d: Unknown result type (might be due to invalid IL or missing references)
        //IL_009e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00aa: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ac: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00be: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bf: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ca: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cf: Unknown result type (might be due to invalid IL or missing references)
        //IL_018b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0194: Unknown result type (might be due to invalid IL or missing references)
        //IL_0171: Unknown result type (might be due to invalid IL or missing references)
        //IL_0172: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fb: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fc: Unknown result type (might be due to invalid IL or missing references)
        //IL_0108: Unknown result type (might be due to invalid IL or missing references)
        //IL_010d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0112: Unknown result type (might be due to invalid IL or missing references)
        //IL_0114: Unknown result type (might be due to invalid IL or missing references)
        //IL_0115: Unknown result type (might be due to invalid IL or missing references)
        //IL_0116: Unknown result type (might be due to invalid IL or missing references)
        //IL_011b: Unknown result type (might be due to invalid IL or missing references)
        //IL_011f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0124: Unknown result type (might be due to invalid IL or missing references)
        //IL_0126: Unknown result type (might be due to invalid IL or missing references)
        //IL_0127: Unknown result type (might be due to invalid IL or missing references)
        //IL_0128: Unknown result type (might be due to invalid IL or missing references)
        //IL_012a: Unknown result type (might be due to invalid IL or missing references)
        //IL_012c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0133: Unknown result type (might be due to invalid IL or missing references)
        //IL_0138: Unknown result type (might be due to invalid IL or missing references)
        //IL_0144: Unknown result type (might be due to invalid IL or missing references)
        //IL_0149: Unknown result type (might be due to invalid IL or missing references)
        //IL_014e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0153: Unknown result type (might be due to invalid IL or missing references)
        //IL_0155: Unknown result type (might be due to invalid IL or missing references)
        //IL_0156: Unknown result type (might be due to invalid IL or missing references)
        //IL_0157: Unknown result type (might be due to invalid IL or missing references)
        //IL_0159: Unknown result type (might be due to invalid IL or missing references)
        //IL_015b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0162: Unknown result type (might be due to invalid IL or missing references)
        //IL_0167: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = a;
        Vector3 val2 = -a + 3f * (b - c) + d;
        Vector3 val3 = 3f * (a + c) - 6f * b;
        Vector3 val4 = 3f * (b - a);
        if (arrowSize > 0f)
        {
            Vector3 position = arrowTransform.position;
            Quaternion rotation = arrowTransform.rotation;
            float num = 0f;
            for (float num2 = 1f; num2 <= 120f; num2 += 1f)
            {
                float num3 = num2 / 120f;
                Vector3 val5 = ((val2 * num3 + val3) * num3 + val4) * num3 + a;
                Gizmos.DrawLine(val, val5);
                float num4 = num;
                Vector3 val6 = val5 - val;
                num = num4 + ((val6)).magnitude;
                if (num > 1f)
                {
                    num -= 1f;
                    arrowTransform.position = val5;
                    arrowTransform.LookAt(val, Vector3.forward);
                    Vector3 val7 = arrowTransform.TransformDirection(Vector3.right);
                    Vector3 val8 = val - val5;
                    val8 = ((val8)).normalized;
                    Gizmos.DrawLine(val5, val5 + (val7 + val8) * arrowSize);
                    val7 = arrowTransform.TransformDirection(-Vector3.right);
                    Gizmos.DrawLine(val5, val5 + (val7 + val8) * arrowSize);
                }
                val = val5;
            }
            arrowTransform.position = position;
            arrowTransform.rotation = rotation;
        }
        else
        {
            for (float num5 = 1f; num5 <= 30f; num5 += 1f)
            {
                float num3 = num5 / 30f;
                Vector3 val5 = ((val2 * num3 + val3) * num3 + val4) * num3 + a;
                Gizmos.DrawLine(val, val5);
                val = val5;
            }
        }
    }

    public static object logError(string error)
    {
        if (throwErrors)
        {
            Debug.LogError(error);
        }
        else
        {
            Debug.Log(error);
        }
        return null;
    }

    public static LTDescr options(LTDescr seed)
    {
        Debug.LogError("error this function is no longer used");
        return null;
    }

    public static LTDescr options()
    {
        init();
        bool flag = false;
        j = 0;
        i = startSearch;
        while (j <= maxTweens)
        {
            if (j >= maxTweens)
            {
                return logError("LeanTween - You have run out of available spaces for tweening. To avoid this error increase the number of spaces to available for tweening when you initialize the LeanTween class ex: LeanTween.init( " + maxTweens * 2 + " );") as LTDescr;
            }
            if (i >= maxTweens)
            {
                i = 0;
            }
            if (!tweens[i].toggle)
            {
                if (i + 1 > tweenMaxSearch && i + 1 < maxTweens)
                {
                    tweenMaxSearch = i + 1;
                }
                startSearch = i + 1;
                flag = true;
                break;
            }
            j++;
            i++;
        }
        if (!flag)
        {
            logError("no available tween found!");
        }
        tweens[i].reset();
        global_counter++;
        if (global_counter > 32768)
        {
            global_counter = 0u;
        }
        tweens[i].setId((uint)i, global_counter);
        return tweens[i];
    }

    public static LTDescr pushNewTween(GameObject gameObject, Vector3 to, float time, LTDescr tween)
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        init(maxTweens);
        if (gameObject == null || tween == null)
        {
            return null;
        }
        tween.trans = gameObject.transform;
        tween.to = to;
        tween.time = time;
        if (tween.time <= 0f)
        {
            tween.updateInternal();
        }
        return tween;
    }

    public static LTDescr play(RectTransform rectTransform, Sprite[] sprites)
    {
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        float time = 0.25f * (float)sprites.Length;
        return pushNewTween(((Component)rectTransform).gameObject, new Vector3((float)sprites.Length - 1f, 0f, 0f), time, options().setCanvasPlaySprite().setSprites(sprites).setRepeat(-1));
    }

    public static LTSeq sequence(bool initSequence = true)
    {
        init(maxTweens);
        for (int i = 0; i < sequences.Length; i++)
        {
            if ((sequences[i].tween != null && sequences[i].tween.toggle) || sequences[i].toggle)
            {
                continue;
            }
            LTSeq lTSeq = sequences[i];
            if (initSequence)
            {
                lTSeq.init((uint)(i + tweens.Length), global_counter);
                global_counter++;
                if (global_counter > 32768)
                {
                    global_counter = 0u;
                }
            }
            else
            {
                lTSeq.reset();
            }
            return lTSeq;
        }
        return null;
    }

    public static LTDescr alpha(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        LTDescr lTDescr = pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setAlpha());
        SpriteRenderer component = gameObject.GetComponent<SpriteRenderer>();
        lTDescr.spriteRen = component;
        return lTDescr;
    }

    public static LTDescr alpha(LTRect ltRect, float to, float time)
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        ltRect.alphaEnabled = true;
        return pushNewTween(tweenEmpty, new Vector3(to, 0f, 0f), time, options().setGUIAlpha().setRect(ltRect));
    }

    public static LTDescr textAlpha(RectTransform rectTransform, float to, float time)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTransform).gameObject, new Vector3(to, 0f, 0f), time, options().setTextAlpha());
    }

    public static LTDescr alphaText(RectTransform rectTransform, float to, float time)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTransform).gameObject, new Vector3(to, 0f, 0f), time, options().setTextAlpha());
    }

    public static LTDescr alphaCanvas(CanvasGroup canvasGroup, float to, float time)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)canvasGroup).gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasGroupAlpha());
    }

    public static LTDescr alphaVertex(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setAlphaVertex());
    }

    public static LTDescr color(GameObject gameObject, Color to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        LTDescr lTDescr = pushNewTween(gameObject, new Vector3(1f, to.a, 0f), time, options().setColor().setPoint(new Vector3(to.r, to.g, to.b)));
        SpriteRenderer component = gameObject.GetComponent<SpriteRenderer>();
        lTDescr.spriteRen = component;
        return lTDescr;
    }

    public static LTDescr textColor(RectTransform rectTransform, Color to, float time)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTransform).gameObject, new Vector3(1f, to.a, 0f), time, options().setTextColor().setPoint(new Vector3(to.r, to.g, to.b)));
    }

    public static LTDescr colorText(RectTransform rectTransform, Color to, float time)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTransform).gameObject, new Vector3(1f, to.a, 0f), time, options().setTextColor().setPoint(new Vector3(to.r, to.g, to.b)));
    }

    public static LTDescr delayedCall(float delayTime, System.Action callback)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(tweenEmpty, Vector3.zero, delayTime, options().setCallback().setOnComplete(callback));
    }

    public static LTDescr delayedCall(float delayTime, System.Action<object> callback)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(tweenEmpty, Vector3.zero, delayTime, options().setCallback().setOnComplete(callback));
    }

    public static LTDescr delayedCall(GameObject gameObject, float delayTime, System.Action callback)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, Vector3.zero, delayTime, options().setCallback().setOnComplete(callback));
    }

    public static LTDescr delayedCall(GameObject gameObject, float delayTime, System.Action<object> callback)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, Vector3.zero, delayTime, options().setCallback().setOnComplete(callback));
    }

    public static LTDescr destroyAfter(LTRect rect, float delayTime)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(tweenEmpty, Vector3.zero, delayTime, options().setCallback().setRect(rect).setDestroyOnComplete(doesDestroy: true));
    }

    public static LTDescr move(GameObject gameObject, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, to, time, options().setMove());
    }

    public static LTDescr move(GameObject gameObject, Vector2 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to.x, to.y, gameObject.transform.position.z), time, options().setMove());
    }

    public static LTDescr move(GameObject gameObject, Vector3[] to, float time)
    {
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        d = options().setMoveCurved();
        if (d.optional.path == null)
        {
            d.optional.path = new LTBezierPath(to);
        }
        else
        {
            d.optional.path.setPoints(to);
        }
        return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
    }

    public static LTDescr move(GameObject gameObject, LTBezierPath to, float time)
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        d = options().setMoveCurved();
        d.optional.path = to;
        return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
    }

    public static LTDescr move(GameObject gameObject, LTSpline to, float time)
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        d = options().setMoveSpline();
        d.optional.spline = to;
        return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
    }

    public static LTDescr moveSpline(GameObject gameObject, Vector3[] to, float time)
    {
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        d = options().setMoveSpline();
        d.optional.spline = new LTSpline(to);
        return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
    }

    public static LTDescr moveSpline(GameObject gameObject, LTSpline to, float time)
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        d = options().setMoveSpline();
        d.optional.spline = to;
        return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
    }

    public static LTDescr moveSplineLocal(GameObject gameObject, Vector3[] to, float time)
    {
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        d = options().setMoveSplineLocal();
        d.optional.spline = new LTSpline(to);
        return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
    }

    public static LTDescr move(LTRect ltRect, Vector2 to, float time)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(tweenEmpty, (to), time, options().setGUIMove().setRect(ltRect));
    }

    public static LTDescr moveMargin(LTRect ltRect, Vector2 to, float time)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(tweenEmpty, (to), time, options().setGUIMoveMargin().setRect(ltRect));
    }

    public static LTDescr moveX(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveX());
    }

    public static LTDescr moveY(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveY());
    }

    public static LTDescr moveZ(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveZ());
    }

    public static LTDescr moveLocal(GameObject gameObject, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, to, time, options().setMoveLocal());
    }

    public static LTDescr moveLocal(GameObject gameObject, Vector3[] to, float time)
    {
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        d = options().setMoveCurvedLocal();
        if (d.optional.path == null)
        {
            d.optional.path = new LTBezierPath(to);
        }
        else
        {
            d.optional.path.setPoints(to);
        }
        return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
    }

    public static LTDescr moveLocalX(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveLocalX());
    }

    public static LTDescr moveLocalY(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveLocalY());
    }

    public static LTDescr moveLocalZ(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveLocalZ());
    }

    public static LTDescr moveLocal(GameObject gameObject, LTBezierPath to, float time)
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        d = options().setMoveCurvedLocal();
        d.optional.path = to;
        return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
    }

    public static LTDescr moveLocal(GameObject gameObject, LTSpline to, float time)
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        d = options().setMoveSplineLocal();
        d.optional.spline = to;
        return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
    }

    public static LTDescr move(GameObject gameObject, Transform to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, Vector3.zero, time, options().setTo(to).setMoveToTransform());
    }

    public static LTDescr rotate(GameObject gameObject, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, to, time, options().setRotate());
    }

    public static LTDescr rotate(LTRect ltRect, float to, float time)
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(tweenEmpty, new Vector3(to, 0f, 0f), time, options().setGUIRotate().setRect(ltRect));
    }

    public static LTDescr rotateLocal(GameObject gameObject, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, to, time, options().setRotateLocal());
    }

    public static LTDescr rotateX(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setRotateX());
    }

    public static LTDescr rotateY(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setRotateY());
    }

    public static LTDescr rotateZ(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setRotateZ());
    }

    public static LTDescr rotateAround(GameObject gameObject, Vector3 axis, float add, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(add, 0f, 0f), time, options().setAxis(axis).setRotateAround());
    }

    public static LTDescr rotateAroundLocal(GameObject gameObject, Vector3 axis, float add, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(add, 0f, 0f), time, options().setRotateAroundLocal().setAxis(axis));
    }

    public static LTDescr scale(GameObject gameObject, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, to, time, options().setScale());
    }

    public static LTDescr scale(LTRect ltRect, Vector2 to, float time)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(tweenEmpty, (to), time, options().setGUIScale().setRect(ltRect));
    }

    public static LTDescr scaleX(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setScaleX());
    }

    public static LTDescr scaleY(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setScaleY());
    }

    public static LTDescr scaleZ(GameObject gameObject, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setScaleZ());
    }

    public static LTDescr value(GameObject gameObject, float from, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setCallback().setFrom(new Vector3(from, 0f, 0f)));
    }

    public static LTDescr value(float from, float to, float time)
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(tweenEmpty, new Vector3(to, 0f, 0f), time, options().setCallback().setFrom(new Vector3(from, 0f, 0f)));
    }

    public static LTDescr value(GameObject gameObject, Vector2 from, Vector2 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to.x, to.y, 0f), time, options().setValue3().setTo(new Vector3(to.x, to.y, 0f)).setFrom(new Vector3(from.x, from.y, 0f)));
    }

    public static LTDescr value(GameObject gameObject, Vector3 from, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, to, time, options().setValue3().setFrom(from));
    }

    public static LTDescr value(GameObject gameObject, Color from, Color to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        LTDescr lTDescr = pushNewTween(gameObject, new Vector3(1f, to.a, 0f), time, options().setCallbackColor().setPoint(new Vector3(to.r, to.g, to.b)).setFromColor(from)
            .setHasInitialized(has: false));
        SpriteRenderer component = gameObject.GetComponent<SpriteRenderer>();
        lTDescr.spriteRen = component;
        return lTDescr;
    }

    public static LTDescr value(GameObject gameObject, System.Action<float> callOnUpdate, float from, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setCallback().setTo(new Vector3(to, 0f, 0f)).setFrom(new Vector3(from, 0f, 0f))
            .setOnUpdate(callOnUpdate));
    }

    public static LTDescr value(GameObject gameObject, System.Action<float, float> callOnUpdateRatio, float from, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setCallback().setTo(new Vector3(to, 0f, 0f)).setFrom(new Vector3(from, 0f, 0f))
            .setOnUpdateRatio(callOnUpdateRatio));
    }

    public static LTDescr value(GameObject gameObject, System.Action<Color> callOnUpdate, Color from, Color to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(1f, to.a, 0f), time, options().setCallbackColor().setPoint(new Vector3(to.r, to.g, to.b)).setAxis(new Vector3(from.r, from.g, from.b))
            .setFrom(new Vector3(0f, from.a, 0f))
            .setHasInitialized(has: false)
            .setOnUpdateColor(callOnUpdate));
    }

    public static LTDescr value(GameObject gameObject, System.Action<Color, object> callOnUpdate, Color from, Color to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(1f, to.a, 0f), time, options().setCallbackColor().setPoint(new Vector3(to.r, to.g, to.b)).setAxis(new Vector3(from.r, from.g, from.b))
            .setFrom(new Vector3(0f, from.a, 0f))
            .setHasInitialized(has: false)
            .setOnUpdateColor(callOnUpdate));
    }

    public static LTDescr value(GameObject gameObject, System.Action<Vector2> callOnUpdate, Vector2 from, Vector2 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to.x, to.y, 0f), time, options().setValue3().setTo(new Vector3(to.x, to.y, 0f)).setFrom(new Vector3(from.x, from.y, 0f))
            .setOnUpdateVector2(callOnUpdate));
    }

    public static LTDescr value(GameObject gameObject, System.Action<Vector3> callOnUpdate, Vector3 from, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, to, time, options().setValue3().setTo(to).setFrom(from)
            .setOnUpdateVector3(callOnUpdate));
    }

    public static LTDescr value(GameObject gameObject, System.Action<float, object> callOnUpdate, float from, float to, float time)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setCallback().setTo(new Vector3(to, 0f, 0f)).setFrom(new Vector3(from, 0f, 0f))
            .setOnUpdate(callOnUpdate, gameObject));
    }

    public static LTDescr delayedSound(AudioClip audio, Vector3 pos, float volume)
    {
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(tweenEmpty, pos, 0f, options().setDelayedSound().setTo(pos).setFrom(new Vector3(volume, 0f, 0f))
            .setAudio(audio));
    }

    public static LTDescr delayedSound(GameObject gameObject, AudioClip audio, Vector3 pos, float volume)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(gameObject, pos, 0f, options().setDelayedSound().setTo(pos).setFrom(new Vector3(volume, 0f, 0f))
            .setAudio(audio));
    }

    public static LTDescr move(RectTransform rectTrans, Vector3 to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, to, time, options().setCanvasMove().setRect(rectTrans));
    }

    public static LTDescr moveX(RectTransform rectTrans, float to, float time)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasMoveX().setRect(rectTrans));
    }

    public static LTDescr moveY(RectTransform rectTrans, float to, float time)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasMoveY().setRect(rectTrans));
    }

    public static LTDescr moveZ(RectTransform rectTrans, float to, float time)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasMoveZ().setRect(rectTrans));
    }

    public static LTDescr rotate(RectTransform rectTrans, float to, float time)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasRotateAround().setRect(rectTrans).setAxis(Vector3.forward));
    }

    public static LTDescr rotate(RectTransform rectTrans, Vector3 to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, to, time, options().setCanvasRotateAround().setRect(rectTrans).setAxis(Vector3.forward));
    }

    public static LTDescr rotateAround(RectTransform rectTrans, Vector3 axis, float to, float time)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasRotateAround().setRect(rectTrans).setAxis(axis));
    }

    public static LTDescr rotateAroundLocal(RectTransform rectTrans, Vector3 axis, float to, float time)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasRotateAroundLocal().setRect(rectTrans).setAxis(axis));
    }

    public static LTDescr scale(RectTransform rectTrans, Vector3 to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, to, time, options().setCanvasScale().setRect(rectTrans));
    }

    public static LTDescr size(RectTransform rectTrans, Vector2 to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, (to), time, options().setCanvasSizeDelta().setRect(rectTrans));
    }

    public static LTDescr alpha(RectTransform rectTrans, float to, float time)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasAlpha().setRect(rectTrans));
    }

    public static LTDescr color(RectTransform rectTrans, Color to, float time)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        return pushNewTween(((Component)rectTrans).gameObject, new Vector3(1f, to.a, 0f), time, options().setCanvasColor().setRect(rectTrans).setPoint(new Vector3(to.r, to.g, to.b)));
    }

    public static float tweenOnCurve(LTDescr tweenDescr, float ratioPassed)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return tweenDescr.from.x + tweenDescr.diff.x * tweenDescr.optional.animationCurve.Evaluate(ratioPassed);
    }

    public static Vector3 tweenOnCurveVector(LTDescr tweenDescr, float ratioPassed)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_007b: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(tweenDescr.from.x + tweenDescr.diff.x * tweenDescr.optional.animationCurve.Evaluate(ratioPassed), tweenDescr.from.y + tweenDescr.diff.y * tweenDescr.optional.animationCurve.Evaluate(ratioPassed), tweenDescr.from.z + tweenDescr.diff.z * tweenDescr.optional.animationCurve.Evaluate(ratioPassed));
    }

    public static float easeOutQuadOpt(float start, float diff, float ratioPassed)
    {
        return (0f - diff) * ratioPassed * (ratioPassed - 2f) + start;
    }

    public static float easeInQuadOpt(float start, float diff, float ratioPassed)
    {
        return diff * ratioPassed * ratioPassed + start;
    }

    public static float easeInOutQuadOpt(float start, float diff, float ratioPassed)
    {
        ratioPassed /= 0.5f;
        if (ratioPassed < 1f)
        {
            return diff / 2f * ratioPassed * ratioPassed + start;
        }
        ratioPassed -= 1f;
        return (0f - diff) / 2f * (ratioPassed * (ratioPassed - 2f) - 1f) + start;
    }

    public static Vector3 easeInOutQuadOpt(Vector3 start, Vector3 diff, float ratioPassed)
    {
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        ratioPassed /= 0.5f;
        if (ratioPassed < 1f)
        {
            return diff / 2f * ratioPassed * ratioPassed + start;
        }
        ratioPassed -= 1f;
        return -diff / 2f * (ratioPassed * (ratioPassed - 2f) - 1f) + start;
    }

    public static float linear(float start, float end, float val)
    {
        return Mathf.Lerp(start, end, val);
    }

    public static float clerp(float start, float end, float val)
    {
        float num = 0f;
        float num2 = 360f;
        float num3 = Mathf.Abs((num2 - num) / 2f);
        float num4 = 0f;
        float num5 = 0f;
        if (end - start < 0f - num3)
        {
            num5 = (num2 - start + end) * val;
            return start + num5;
        }
        if (end - start > num3)
        {
            num5 = (0f - (num2 - end + start)) * val;
            return start + num5;
        }
        return start + (end - start) * val;
    }

    public static float spring(float start, float end, float val)
    {
        val = Mathf.Clamp01(val);
        val = (Mathf.Sin(val * (float)Math.PI * (0.2f + 2.5f * val * val * val)) * Mathf.Pow(1f - val, 2.2f) + val) * (1f + 1.2f * (1f - val));
        return start + (end - start) * val;
    }

    public static float easeInQuad(float start, float end, float val)
    {
        end -= start;
        return end * val * val + start;
    }

    public static float easeOutQuad(float start, float end, float val)
    {
        end -= start;
        return (0f - end) * val * (val - 2f) + start;
    }

    public static float easeInOutQuad(float start, float end, float val)
    {
        val /= 0.5f;
        end -= start;
        if (val < 1f)
        {
            return end / 2f * val * val + start;
        }
        val -= 1f;
        return (0f - end) / 2f * (val * (val - 2f) - 1f) + start;
    }

    public static float easeInOutQuadOpt2(float start, float diffBy2, float val, float val2)
    {
        val /= 0.5f;
        if (val < 1f)
        {
            return diffBy2 * val2 + start;
        }
        val -= 1f;
        return (0f - diffBy2) * (val2 - 2f - 1f) + start;
    }

    public static float easeInCubic(float start, float end, float val)
    {
        end -= start;
        return end * val * val * val + start;
    }

    public static float easeOutCubic(float start, float end, float val)
    {
        val -= 1f;
        end -= start;
        return end * (val * val * val + 1f) + start;
    }

    public static float easeInOutCubic(float start, float end, float val)
    {
        val /= 0.5f;
        end -= start;
        if (val < 1f)
        {
            return end / 2f * val * val * val + start;
        }
        val -= 2f;
        return end / 2f * (val * val * val + 2f) + start;
    }

    public static float easeInQuart(float start, float end, float val)
    {
        end -= start;
        return end * val * val * val * val + start;
    }

    public static float easeOutQuart(float start, float end, float val)
    {
        val -= 1f;
        end -= start;
        return (0f - end) * (val * val * val * val - 1f) + start;
    }

    public static float easeInOutQuart(float start, float end, float val)
    {
        val /= 0.5f;
        end -= start;
        if (val < 1f)
        {
            return end / 2f * val * val * val * val + start;
        }
        val -= 2f;
        return (0f - end) / 2f * (val * val * val * val - 2f) + start;
    }

    public static float easeInQuint(float start, float end, float val)
    {
        end -= start;
        return end * val * val * val * val * val + start;
    }

    public static float easeOutQuint(float start, float end, float val)
    {
        val -= 1f;
        end -= start;
        return end * (val * val * val * val * val + 1f) + start;
    }

    public static float easeInOutQuint(float start, float end, float val)
    {
        val /= 0.5f;
        end -= start;
        if (val < 1f)
        {
            return end / 2f * val * val * val * val * val + start;
        }
        val -= 2f;
        return end / 2f * (val * val * val * val * val + 2f) + start;
    }

    public static float easeInSine(float start, float end, float val)
    {
        end -= start;
        return (0f - end) * Mathf.Cos(val / 1f * ((float)Math.PI / 2f)) + end + start;
    }

    public static float easeOutSine(float start, float end, float val)
    {
        end -= start;
        return end * Mathf.Sin(val / 1f * ((float)Math.PI / 2f)) + start;
    }

    public static float easeInOutSine(float start, float end, float val)
    {
        end -= start;
        return (0f - end) / 2f * (Mathf.Cos((float)Math.PI * val / 1f) - 1f) + start;
    }

    public static float easeInExpo(float start, float end, float val)
    {
        end -= start;
        return end * Mathf.Pow(2f, 10f * (val / 1f - 1f)) + start;
    }

    public static float easeOutExpo(float start, float end, float val)
    {
        end -= start;
        return end * (0f - Mathf.Pow(2f, -10f * val / 1f) + 1f) + start;
    }

    public static float easeInOutExpo(float start, float end, float val)
    {
        val /= 0.5f;
        end -= start;
        if (val < 1f)
        {
            return end / 2f * Mathf.Pow(2f, 10f * (val - 1f)) + start;
        }
        val -= 1f;
        return end / 2f * (0f - Mathf.Pow(2f, -10f * val) + 2f) + start;
    }

    public static float easeInCirc(float start, float end, float val)
    {
        end -= start;
        return (0f - end) * (Mathf.Sqrt(1f - val * val) - 1f) + start;
    }

    public static float easeOutCirc(float start, float end, float val)
    {
        val -= 1f;
        end -= start;
        return end * Mathf.Sqrt(1f - val * val) + start;
    }

    public static float easeInOutCirc(float start, float end, float val)
    {
        val /= 0.5f;
        end -= start;
        if (val < 1f)
        {
            return (0f - end) / 2f * (Mathf.Sqrt(1f - val * val) - 1f) + start;
        }
        val -= 2f;
        return end / 2f * (Mathf.Sqrt(1f - val * val) + 1f) + start;
    }

    public static float easeInBounce(float start, float end, float val)
    {
        end -= start;
        float num = 1f;
        return end - easeOutBounce(0f, end, num - val) + start;
    }

    public static float easeOutBounce(float start, float end, float val)
    {
        val /= 1f;
        end -= start;
        if (val < 0.36363637f)
        {
            return end * (7.5625f * val * val) + start;
        }
        if (val < 0.72727275f)
        {
            val -= 0.54545456f;
            return end * (7.5625f * val * val + 0.75f) + start;
        }
        if ((double)val < 0.9090909090909091)
        {
            val -= 0.8181818f;
            return end * (7.5625f * val * val + 0.9375f) + start;
        }
        val -= 21f / 22f;
        return end * (7.5625f * val * val + 63f / 64f) + start;
    }

    public static float easeInOutBounce(float start, float end, float val)
    {
        end -= start;
        float num = 1f;
        if (val < num / 2f)
        {
            return easeInBounce(0f, end, val * 2f) * 0.5f + start;
        }
        return easeOutBounce(0f, end, val * 2f - num) * 0.5f + end * 0.5f + start;
    }

    public static float easeInBack(float start, float end, float val, float overshoot = 1f)
    {
        end -= start;
        val /= 1f;
        float num = 1.70158f * overshoot;
        return end * val * val * ((num + 1f) * val - num) + start;
    }

    public static float easeOutBack(float start, float end, float val, float overshoot = 1f)
    {
        float num = 1.70158f * overshoot;
        end -= start;
        val = val / 1f - 1f;
        return end * (val * val * ((num + 1f) * val + num) + 1f) + start;
    }

    public static float easeInOutBack(float start, float end, float val, float overshoot = 1f)
    {
        float num = 1.70158f * overshoot;
        end -= start;
        val /= 0.5f;
        if (val < 1f)
        {
            num *= 1.525f * overshoot;
            return end / 2f * (val * val * ((num + 1f) * val - num)) + start;
        }
        val -= 2f;
        num *= 1.525f * overshoot;
        return end / 2f * (val * val * ((num + 1f) * val + num) + 2f) + start;
    }

    public static float easeInElastic(float start, float end, float val, float overshoot = 1f, float period = 0.3f)
    {
        end -= start;
        float num = 0f;
        float num2 = 0f;
        if (val == 0f)
        {
            return start;
        }
        if (val == 1f)
        {
            return start + end;
        }
        if (num2 == 0f || num2 < Mathf.Abs(end))
        {
            num2 = end;
            num = period / 4f;
        }
        else
        {
            num = period / ((float)Math.PI * 2f) * Mathf.Asin(end / num2);
        }
        if (overshoot > 1f && val > 0.6f)
        {
            overshoot = 1f + (1f - val) / 0.4f * (overshoot - 1f);
        }
        val -= 1f;
        return start - num2 * Mathf.Pow(2f, 10f * val) * Mathf.Sin((val - num) * ((float)Math.PI * 2f) / period) * overshoot;
    }

    public static float easeOutElastic(float start, float end, float val, float overshoot = 1f, float period = 0.3f)
    {
        end -= start;
        float num = 0f;
        float num2 = 0f;
        if (val == 0f)
        {
            return start;
        }
        if (val == 1f)
        {
            return start + end;
        }
        if (num2 == 0f || num2 < Mathf.Abs(end))
        {
            num2 = end;
            num = period / 4f;
        }
        else
        {
            num = period / ((float)Math.PI * 2f) * Mathf.Asin(end / num2);
        }
        if (overshoot > 1f && val < 0.4f)
        {
            overshoot = 1f + val / 0.4f * (overshoot - 1f);
        }
        return start + end + num2 * Mathf.Pow(2f, -10f * val) * Mathf.Sin((val - num) * ((float)Math.PI * 2f) / period) * overshoot;
    }

    public static float easeInOutElastic(float start, float end, float val, float overshoot = 1f, float period = 0.3f)
    {
        end -= start;
        float num = 0f;
        float num2 = 0f;
        if (val == 0f)
        {
            return start;
        }
        val /= 0.5f;
        if (val == 2f)
        {
            return start + end;
        }
        if (num2 == 0f || num2 < Mathf.Abs(end))
        {
            num2 = end;
            num = period / 4f;
        }
        else
        {
            num = period / ((float)Math.PI * 2f) * Mathf.Asin(end / num2);
        }
        if (overshoot > 1f)
        {
            if (val < 0.2f)
            {
                overshoot = 1f + val / 0.2f * (overshoot - 1f);
            }
            else if (val > 0.8f)
            {
                overshoot = 1f + (1f - val) / 0.2f * (overshoot - 1f);
            }
        }
        if (val < 1f)
        {
            val -= 1f;
            return start - 0.5f * (num2 * Mathf.Pow(2f, 10f * val) * Mathf.Sin((val - num) * ((float)Math.PI * 2f) / period)) * overshoot;
        }
        val -= 1f;
        return end + start + num2 * Mathf.Pow(2f, -10f * val) * Mathf.Sin((val - num) * ((float)Math.PI * 2f) / period) * 0.5f * overshoot;
    }

    public static LTDescr followDamp(Transform trans, Transform target, LeanProp prop, float smoothTime, float maxSpeed = -1f)
    {
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c5: Unknown result type (might be due to invalid IL or missing references)
        //IL_0089: Unknown result type (might be due to invalid IL or missing references)
        LTDescr d = pushNewTween(((Component)trans).gameObject, Vector3.zero, float.MaxValue, options().setFollow().setTarget(target));
        switch (prop)
        {
            case LeanProp.localPosition:
                d.optional.axis = d.trans.localPosition;
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0047: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0067: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0072: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0077: Unknown result type (might be due to invalid IL or missing references)
                    d.optional.axis = LeanSmooth.damp(d.optional.axis, d.toTrans.localPosition, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime);
                    d.trans.localPosition = d.optional.axis + d.toInternal;
                };
                break;
            case LeanProp.position:
                d.diff = d.trans.position;
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0047: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0067: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0072: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0077: Unknown result type (might be due to invalid IL or missing references)
                    d.optional.axis = LeanSmooth.damp(d.optional.axis, d.toTrans.position, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime);
                    d.trans.position = d.optional.axis + d.toInternal;
                };
                break;
            case LeanProp.localX:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosX(LeanSmooth.damp(d.trans.localPosition.x, d.toTrans.localPosition.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime));
                };
                break;
            case LeanProp.localY:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosY(LeanSmooth.damp(d.trans.localPosition.y, d.toTrans.localPosition.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime));
                };
                break;
            case LeanProp.localZ:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosZ(LeanSmooth.damp(d.trans.localPosition.z, d.toTrans.localPosition.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime));
                };
                break;
            case LeanProp.x:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosX(LeanSmooth.damp(d.trans.position.x, d.toTrans.position.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime));
                };
                break;
            case LeanProp.y:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosY(LeanSmooth.damp(d.trans.position.y, d.toTrans.position.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime));
                };
                break;
            case LeanProp.z:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosZ(LeanSmooth.damp(d.trans.position.z, d.toTrans.position.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime));
                };
                break;
            case LeanProp.scale:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0047: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.localScale = LeanSmooth.damp(d.trans.localScale, d.toTrans.localScale, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime);
                };
                break;
            case LeanProp.color:
                d.easeInternal = delegate
                {
                    //IL_000b: Unknown result type (might be due to invalid IL or missing references)
                    //IL_001b: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0041: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0046: Unknown result type (might be due to invalid IL or missing references)
                    //IL_005c: Unknown result type (might be due to invalid IL or missing references)
                    Color val = LeanSmooth.damp(d.trans.LeanColor(), d.toTrans.LeanColor(), ref d.optional.color, smoothTime, maxSpeed, Time.deltaTime);
                    ((Component)d.trans).GetComponent<Renderer>().material.color = val;
                };
                break;
        }
        return d;
    }

    public static LTDescr followSpring(Transform trans, Transform target, LeanProp prop, float smoothTime, float maxSpeed = -1f, float friction = 2f, float accelRate = 0.5f)
    {
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d5: Unknown result type (might be due to invalid IL or missing references)
        //IL_0099: Unknown result type (might be due to invalid IL or missing references)
        LTDescr d = pushNewTween(((Component)trans).gameObject, Vector3.zero, float.MaxValue, options().setFollow().setTarget(target));
        switch (prop)
        {
            case LeanProp.localPosition:
                d.optional.axis = d.trans.localPosition;
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0053: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0073: Unknown result type (might be due to invalid IL or missing references)
                    //IL_007e: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0083: Unknown result type (might be due to invalid IL or missing references)
                    d.optional.axis = LeanSmooth.spring(d.optional.axis, d.toTrans.localPosition, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
                    d.trans.localPosition = d.optional.axis + d.toInternal;
                };
                break;
            case LeanProp.position:
                d.diff = d.trans.position;
                d.easeInternal = delegate
                {
                    //IL_000c: Unknown result type (might be due to invalid IL or missing references)
                    //IL_001c: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0049: Unknown result type (might be due to invalid IL or missing references)
                    //IL_004e: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0064: Unknown result type (might be due to invalid IL or missing references)
                    d.diff = LeanSmooth.spring(d.diff, d.toTrans.position, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
                    d.trans.position = d.diff;
                };
                break;
            case LeanProp.localX:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosX(LeanSmooth.spring(d.trans.localPosition.x, d.toTrans.localPosition.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
                };
                break;
            case LeanProp.localY:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosY(LeanSmooth.spring(d.trans.localPosition.y, d.toTrans.localPosition.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
                };
                break;
            case LeanProp.localZ:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosZ(LeanSmooth.spring(d.trans.localPosition.z, d.toTrans.localPosition.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
                };
                break;
            case LeanProp.x:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosX(LeanSmooth.spring(d.trans.position.x, d.toTrans.position.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
                };
                break;
            case LeanProp.y:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosY(LeanSmooth.spring(d.trans.position.y, d.toTrans.position.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
                };
                break;
            case LeanProp.z:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosZ(LeanSmooth.spring(d.trans.position.z, d.toTrans.position.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
                };
                break;
            case LeanProp.scale:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0053: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.localScale = LeanSmooth.spring(d.trans.localScale, d.toTrans.localScale, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
                };
                break;
            case LeanProp.color:
                d.easeInternal = delegate
                {
                    //IL_000b: Unknown result type (might be due to invalid IL or missing references)
                    //IL_001b: Unknown result type (might be due to invalid IL or missing references)
                    //IL_004d: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0052: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0068: Unknown result type (might be due to invalid IL or missing references)
                    Color val = LeanSmooth.spring(d.trans.LeanColor(), d.toTrans.LeanColor(), ref d.optional.color, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
                    ((Component)d.trans).GetComponent<Renderer>().material.color = val;
                };
                break;
        }
        return d;
    }

    public static LTDescr followBounceOut(Transform trans, Transform target, LeanProp prop, float smoothTime, float maxSpeed = -1f, float friction = 2f, float accelRate = 0.5f, float hitDamping = 0.9f)
    {
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a1: Unknown result type (might be due to invalid IL or missing references)
        LTDescr d = pushNewTween(((Component)trans).gameObject, Vector3.zero, float.MaxValue, options().setFollow().setTarget(target));
        switch (prop)
        {
            case LeanProp.localPosition:
                d.optional.axis = d.trans.localPosition;
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0059: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0079: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0084: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0089: Unknown result type (might be due to invalid IL or missing references)
                    d.optional.axis = LeanSmooth.bounceOut(d.optional.axis, d.toTrans.localPosition, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
                    d.trans.localPosition = d.optional.axis + d.toInternal;
                };
                break;
            case LeanProp.position:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0059: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0079: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0084: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0089: Unknown result type (might be due to invalid IL or missing references)
                    d.optional.axis = LeanSmooth.bounceOut(d.optional.axis, d.toTrans.position, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
                    d.trans.position = d.optional.axis + d.toInternal;
                };
                break;
            case LeanProp.localX:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosX(LeanSmooth.bounceOut(d.trans.localPosition.x, d.toTrans.localPosition.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
                };
                break;
            case LeanProp.localY:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosY(LeanSmooth.bounceOut(d.trans.localPosition.y, d.toTrans.localPosition.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
                };
                break;
            case LeanProp.localZ:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosZ(LeanSmooth.bounceOut(d.trans.localPosition.z, d.toTrans.localPosition.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
                };
                break;
            case LeanProp.x:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosX(LeanSmooth.bounceOut(d.trans.position.x, d.toTrans.position.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
                };
                break;
            case LeanProp.y:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosY(LeanSmooth.bounceOut(d.trans.position.y, d.toTrans.position.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
                };
                break;
            case LeanProp.z:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosZ(LeanSmooth.bounceOut(d.trans.position.z, d.toTrans.position.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
                };
                break;
            case LeanProp.scale:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0059: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.localScale = LeanSmooth.bounceOut(d.trans.localScale, d.toTrans.localScale, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
                };
                break;
            case LeanProp.color:
                d.easeInternal = delegate
                {
                    //IL_000b: Unknown result type (might be due to invalid IL or missing references)
                    //IL_001b: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0053: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0058: Unknown result type (might be due to invalid IL or missing references)
                    //IL_006e: Unknown result type (might be due to invalid IL or missing references)
                    Color val = LeanSmooth.bounceOut(d.trans.LeanColor(), d.toTrans.LeanColor(), ref d.optional.color, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
                    ((Component)d.trans).GetComponent<Renderer>().material.color = val;
                };
                break;
        }
        return d;
    }

    public static LTDescr followLinear(Transform trans, Transform target, LeanProp prop, float moveSpeed)
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0081: Unknown result type (might be due to invalid IL or missing references)
        LTDescr d = pushNewTween(((Component)trans).gameObject, Vector3.zero, float.MaxValue, options().setFollow().setTarget(target));
        switch (prop)
        {
            case LeanProp.localPosition:
                d.optional.axis = d.trans.localPosition;
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0036: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0056: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0061: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0066: Unknown result type (might be due to invalid IL or missing references)
                    d.optional.axis = LeanSmooth.linear(d.optional.axis, d.toTrans.localPosition, moveSpeed);
                    d.trans.localPosition = d.optional.axis + d.toInternal;
                };
                break;
            case LeanProp.position:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0036: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.position = LeanSmooth.linear(d.trans.position, d.toTrans.position, moveSpeed);
                };
                break;
            case LeanProp.localX:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosX(LeanSmooth.linear(d.trans.localPosition.x, d.toTrans.localPosition.x, moveSpeed));
                };
                break;
            case LeanProp.localY:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosY(LeanSmooth.linear(d.trans.localPosition.y, d.toTrans.localPosition.y, moveSpeed));
                };
                break;
            case LeanProp.localZ:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetLocalPosZ(LeanSmooth.linear(d.trans.localPosition.z, d.toTrans.localPosition.z, moveSpeed));
                };
                break;
            case LeanProp.x:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosX(LeanSmooth.linear(d.trans.position.x, d.toTrans.position.x, moveSpeed));
                };
                break;
            case LeanProp.y:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosY(LeanSmooth.linear(d.trans.position.y, d.toTrans.position.y, moveSpeed));
                };
                break;
            case LeanProp.z:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.LeanSetPosZ(LeanSmooth.linear(d.trans.position.z, d.toTrans.position.z, moveSpeed));
                };
                break;
            case LeanProp.scale:
                d.easeInternal = delegate
                {
                    //IL_0016: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0036: Unknown result type (might be due to invalid IL or missing references)
                    d.trans.localScale = LeanSmooth.linear(d.trans.localScale, d.toTrans.localScale, moveSpeed);
                };
                break;
            case LeanProp.color:
                d.easeInternal = delegate
                {
                    //IL_000b: Unknown result type (might be due to invalid IL or missing references)
                    //IL_001b: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0026: Unknown result type (might be due to invalid IL or missing references)
                    //IL_002b: Unknown result type (might be due to invalid IL or missing references)
                    //IL_0041: Unknown result type (might be due to invalid IL or missing references)
                    Color val = LeanSmooth.linear(d.trans.LeanColor(), d.toTrans.LeanColor(), moveSpeed);
                    ((Component)d.trans).GetComponent<Renderer>().material.color = val;
                };
                break;
        }
        return d;
    }

    public static void addListener(int eventId, System.Action<LTEvent> callback)
    {
        addListener(tweenEmpty, eventId, callback);
    }

    public static void addListener(GameObject caller, int eventId, System.Action<LTEvent> callback)
    {
        if (eventListeners == null)
        {
            INIT_LISTENERS_MAX = LISTENERS_MAX;
            eventListeners = new System.Action<LTEvent>[EVENTS_MAX * LISTENERS_MAX];
            goListeners = (GameObject[])(object)new GameObject[EVENTS_MAX * LISTENERS_MAX];
        }
        for (i = 0; i < INIT_LISTENERS_MAX; i++)
        {
            int num = eventId * INIT_LISTENERS_MAX + i;
            if (goListeners[num] == null || eventListeners[num] == null)
            {
                eventListeners[num] = callback;
                goListeners[num] = caller;
                if (i >= eventsMaxSearch)
                {
                    eventsMaxSearch = i + 1;
                }
                return;
            }
            if (goListeners[num] == caller && object.Equals(eventListeners[num], callback))
            {
                return;
            }
        }
        Debug.LogError(("You ran out of areas to add listeners, consider increasing LISTENERS_MAX, ex: LeanTween.LISTENERS_MAX = " + LISTENERS_MAX * 2));
    }

    public static bool removeListener(int eventId, System.Action<LTEvent> callback)
    {
        return removeListener(tweenEmpty, eventId, callback);
    }

    public static bool removeListener(int eventId)
    {
        int num = eventId * INIT_LISTENERS_MAX + i;
        eventListeners[num] = null;
        goListeners[num] = null;
        return true;
    }

    public static bool removeListener(GameObject caller, int eventId, System.Action<LTEvent> callback)
    {
        for (i = 0; i < eventsMaxSearch; i++)
        {
            int num = eventId * INIT_LISTENERS_MAX + i;
            if (goListeners[num] == caller && object.Equals(eventListeners[num], callback))
            {
                eventListeners[num] = null;
                goListeners[num] = null;
                return true;
            }
        }
        return false;
    }

    public static void dispatchEvent(int eventId)
    {
        dispatchEvent(eventId, null);
    }

    public static void dispatchEvent(int eventId, object data)
    {
        for (int i = 0; i < eventsMaxSearch; i++)
        {
            int num = eventId * INIT_LISTENERS_MAX + i;
            if (eventListeners[num] != null)
            {
                if ((goListeners[num]))
                {
                    eventListeners[num](new LTEvent(eventId, data));
                }
                else
                {
                    eventListeners[num] = null;
                }
            }
        }
    }
}
public class LTUtility
{
    public static Vector3[] reverse(Vector3[] arr)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        int num = arr.Length;
        int num2 = 0;
        int num3 = num - 1;
        while (num2 < num3)
        {
            Vector3 val = arr[num2];
            arr[num2] = arr[num3];
            arr[num3] = val;
            num2++;
            num3--;
        }
        return arr;
    }
}
public class LTBezier
{
    public float length;

    public Vector3 a;

    public Vector3 aa;

    public Vector3 bb;

    public Vector3 cc;

    public float len;

    public float[] arcLengths;

    public LTBezier(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float precision)
    {
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_000f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        //IL_006f: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b5: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ba: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bc: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00be: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d8: Unknown result type (might be due to invalid IL or missing references)
        this.a = a;
        aa = -a + 3f * (b - c) + d;
        bb = 3f * (a + c) - 6f * b;
        cc = 3f * (b - a);
        len = 1f / precision;
        arcLengths = new float[(int)len + 1];
        arcLengths[0] = 0f;
        Vector3 val = a;
        float num = 0f;
        for (int i = 1; (float)i <= len; i++)
        {
            Vector3 val2 = bezierPoint((float)i * precision);
            float num2 = num;
            Vector3 val3 = val - val2;
            num = num2 + ((val3)).magnitude;
            arcLengths[i] = num;
            val = val2;
        }
        length = num;
    }

    public float map(float u)
    {
        float num = u * arcLengths[(int)len];
        int num2 = 0;
        int num3 = (int)len;
        int num4 = 0;
        while (num2 < num3)
        {
            num4 = num2 + ((int)((float)(num3 - num2) / 2f) | 0);
            if (arcLengths[num4] < num)
            {
                num2 = num4 + 1;
            }
            else
            {
                num3 = num4;
            }
        }
        if (arcLengths[num4] > num)
        {
            num4--;
        }
        if (num4 < 0)
        {
            num4 = 0;
        }
        return ((float)num4 + (num - arcLengths[num4]) / (arcLengths[num4 + 1] - arcLengths[num4])) / len;
    }

    public Vector3 bezierPoint(float t)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        return ((aa * t + bb) * t + cc) * t + a;
    }

    public Vector3 point(float t)
    {
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        return bezierPoint(map(t));
    }
}
public class LTBezierPath
{
    public Vector3[] pts;

    public float length;

    public bool orientToPath;

    public bool orientToPath2d;

    public LTBezier[] beziers;

    public float[] lengthRatio;

    public int currentBezier;

    public int previousBezier;

    public float distance => length;

    public LTBezierPath()
    {
    }

    public LTBezierPath(Vector3[] pts_)
    {
        setPoints(pts_);
    }

    public void setPoints(Vector3[] pts_)
    {
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        //IL_007f: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        //IL_009b: Unknown result type (might be due to invalid IL or missing references)
        if (pts_.Length < 4)
        {
            LeanTween.logError("LeanTween - When passing values for a vector path, you must pass four or more values!");
        }
        if (pts_.Length % 4 != 0)
        {
            LeanTween.logError("LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...");
        }
        pts = pts_;
        int num = 0;
        beziers = new LTBezier[pts.Length / 4];
        lengthRatio = new float[beziers.Length];
        length = 0f;
        for (int i = 0; i < pts.Length; i += 4)
        {
            beziers[num] = new LTBezier(pts[i], pts[i + 2], pts[i + 1], pts[i + 3], 0.05f);
            length += beziers[num].length;
            num++;
        }
        for (int i = 0; i < beziers.Length; i++)
        {
            lengthRatio[i] = beziers[i].length / length;
        }
    }

    public Vector3 point(float ratio)
    {
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        float num = 0f;
        for (int i = 0; i < lengthRatio.Length; i++)
        {
            num += lengthRatio[i];
            if (num >= ratio)
            {
                return beziers[i].point((ratio - (num - lengthRatio[i])) / lengthRatio[i]);
            }
        }
        return beziers[lengthRatio.Length - 1].point(1f);
    }

    public void place2d(Transform transform, float ratio)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        transform.position = point(ratio);
        ratio += 0.001f;
        if (ratio <= 1f)
        {
            Vector3 val = point(ratio) - transform.position;
            float num = Mathf.Atan2(val.y, val.x) * 57.29578f;
            transform.eulerAngles = new Vector3(0f, 0f, num);
        }
    }

    public void placeLocal2d(Transform transform, float ratio)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        transform.localPosition = point(ratio);
        ratio += 0.001f;
        if (ratio <= 1f)
        {
            Vector3 val = point(ratio) - transform.localPosition;
            float num = Mathf.Atan2(val.y, val.x) * 57.29578f;
            transform.localEulerAngles = new Vector3(0f, 0f, num);
        }
    }

    public void place(Transform transform, float ratio)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        place(transform, ratio, Vector3.up);
    }

    public void place(Transform transform, float ratio, Vector3 worldUp)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        transform.position = point(ratio);
        ratio += 0.001f;
        if (ratio <= 1f)
        {
            transform.LookAt(point(ratio), worldUp);
        }
    }

    public void placeLocal(Transform transform, float ratio)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        placeLocal(transform, ratio, Vector3.up);
    }

    public void placeLocal(Transform transform, float ratio, Vector3 worldUp)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        ratio = Mathf.Clamp01(ratio);
        transform.localPosition = point(ratio);
        ratio = Mathf.Clamp01(ratio + 0.001f);
        if (ratio <= 1f)
        {
            transform.LookAt(transform.parent.TransformPoint(point(ratio)), worldUp);
        }
    }

    public void gizmoDraw(float t = -1f)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val = point(0f);
        for (int i = 1; i <= 120; i++)
        {
            float ratio = (float)i / 120f;
            Vector3 val2 = point(ratio);
            Gizmos.color = ((previousBezier == currentBezier) ? Color.magenta : Color.grey);
            Gizmos.DrawLine(val2, val);
            val = val2;
            previousBezier = currentBezier;
        }
    }

    public float ratioAtPoint(Vector3 pt, float precision = 0.01f)
    {
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        float num = float.MaxValue;
        int num2 = 0;
        int num3 = Mathf.RoundToInt(1f / precision);
        for (int i = 0; i < num3; i++)
        {
            float ratio = (float)i / (float)num3;
            float num4 = Vector3.Distance(pt, point(ratio));
            if (num4 < num)
            {
                num = num4;
                num2 = i;
            }
        }
        return (float)num2 / (float)num3;
    }
}
[Serializable]
public class LTSpline
{
    public static int DISTANCE_COUNT = 3;

    public static int SUBLINE_COUNT = 20;

    public float distance;

    public bool constantSpeed = true;

    public Vector3[] pts;

    [NonSerialized]
    public Vector3[] ptsAdj;

    public int ptsAdjLength;

    public bool orientToPath;

    public bool orientToPath2d;

    public int numSections;

    public int currPt;

    public LTSpline(Vector3[] pts)
    {
        init(pts, constantSpeed: true);
    }

    public LTSpline(Vector3[] pts, bool constantSpeed)
    {
        this.constantSpeed = constantSpeed;
        init(pts, constantSpeed);
    }

    public void init(Vector3[] pts, bool constantSpeed)
    {
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00db: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e7: Unknown result type (might be due to invalid IL or missing references)
        //IL_0108: Unknown result type (might be due to invalid IL or missing references)
        //IL_010d: Unknown result type (might be due to invalid IL or missing references)
        //IL_010f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0111: Unknown result type (might be due to invalid IL or missing references)
        //IL_0130: Unknown result type (might be due to invalid IL or missing references)
        //IL_0132: Unknown result type (might be due to invalid IL or missing references)
        //IL_0146: Unknown result type (might be due to invalid IL or missing references)
        //IL_0148: Unknown result type (might be due to invalid IL or missing references)
        if (pts.Length < 4)
        {
            LeanTween.logError("LeanTween - When passing values for a spline path, you must pass four or more values!");
            return;
        }
        this.pts = (Vector3[])(object)new Vector3[pts.Length];
        Array.Copy(pts, this.pts, pts.Length);
        numSections = pts.Length - 3;
        float num = float.PositiveInfinity;
        Vector3 val = this.pts[1];
        float num2 = 0f;
        for (int i = 1; i < this.pts.Length - 1; i++)
        {
            float num3 = Vector3.Distance(this.pts[i], val);
            if (num3 < num)
            {
                num = num3;
            }
            num2 += num3;
        }
        if (!constantSpeed)
        {
            return;
        }
        num = num2 / (float)(numSections * SUBLINE_COUNT);
        float num4 = num / (float)SUBLINE_COUNT;
        int num5 = (int)Mathf.Ceil(num2 / num4) * DISTANCE_COUNT;
        if (num5 <= 1)
        {
            num5 = 2;
        }
        ptsAdj = (Vector3[])(object)new Vector3[num5];
        val = interp(0f);
        int num6 = 1;
        ptsAdj[0] = val;
        distance = 0f;
        for (int j = 0; j < num5 + 1; j++)
        {
            float num7 = (float)j / (float)num5;
            Vector3 val2 = interp(num7);
            float num8 = Vector3.Distance(val2, val);
            if (num8 >= num4 || num7 >= 1f)
            {
                ptsAdj[num6] = val2;
                distance += num8;
                val = val2;
                num6++;
            }
        }
        ptsAdjLength = num6;
    }

    public Vector3 map(float u)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0061: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Unknown result type (might be due to invalid IL or missing references)
        if (u >= 1f)
        {
            return pts[pts.Length - 2];
        }
        float num = u * (float)(ptsAdjLength - 1);
        int num2 = (int)Mathf.Floor(num);
        int num3 = (int)Mathf.Ceil(num);
        if (num2 < 0)
        {
            num2 = 0;
        }
        Vector3 val = ptsAdj[num2];
        Vector3 val2 = ptsAdj[num3];
        float num4 = num - (float)num2;
        return val + (val2 - val) * num4;
    }

    public Vector3 interp(float t)
    {
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0058: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        //IL_007b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        //IL_0088: Unknown result type (might be due to invalid IL or missing references)
        //IL_0092: Unknown result type (might be due to invalid IL or missing references)
        //IL_0093: Unknown result type (might be due to invalid IL or missing references)
        //IL_0098: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ad: Unknown result type (might be due to invalid IL or missing references)
        //IL_00af: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ce: Unknown result type (might be due to invalid IL or missing references)
        //IL_00cf: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00de: Unknown result type (might be due to invalid IL or missing references)
        //IL_00df: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00e9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00eb: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f3: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fd: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fe: Unknown result type (might be due to invalid IL or missing references)
        //IL_0103: Unknown result type (might be due to invalid IL or missing references)
        //IL_0104: Unknown result type (might be due to invalid IL or missing references)
        //IL_010a: Unknown result type (might be due to invalid IL or missing references)
        //IL_010f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0119: Unknown result type (might be due to invalid IL or missing references)
        //IL_011a: Unknown result type (might be due to invalid IL or missing references)
        //IL_011f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0124: Unknown result type (might be due to invalid IL or missing references)
        currPt = Mathf.Min(Mathf.FloorToInt(t * (float)numSections), numSections - 1);
        float num = t * (float)numSections - (float)currPt;
        Vector3 val = pts[currPt];
        Vector3 val2 = pts[currPt + 1];
        Vector3 val3 = pts[currPt + 2];
        Vector3 val4 = pts[currPt + 3];
        return 0.5f * ((-val + 3f * val2 - 3f * val3 + val4) * (num * num * num) + (2f * val - 5f * val2 + 4f * val3 - val4) * (num * num) + (-val + val3) * num + 2f * val2);
    }

    public float ratioAtPoint(Vector3 pt)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        float num = float.MaxValue;
        int num2 = 0;
        for (int i = 0; i < ptsAdjLength; i++)
        {
            float num3 = Vector3.Distance(pt, ptsAdj[i]);
            if (num3 < num)
            {
                num = num3;
                num2 = i;
            }
        }
        return (float)num2 / (float)(ptsAdjLength - 1);
    }

    public Vector3 point(float ratio)
    {
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        float num = ((ratio > 1f) ? 1f : ratio);
        if (!constantSpeed)
        {
            return interp(num);
        }
        return map(num);
    }

    public void place2d(Transform transform, float ratio)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        transform.position = point(ratio);
        ratio += 0.001f;
        if (ratio <= 1f)
        {
            Vector3 val = point(ratio) - transform.position;
            float num = Mathf.Atan2(val.y, val.x) * 57.29578f;
            transform.eulerAngles = new Vector3(0f, 0f, num);
        }
    }

    public void placeLocal2d(Transform transform, float ratio)
    {
        //IL_001a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        if (transform.parent == null)
        {
            place2d(transform, ratio);
            return;
        }
        transform.localPosition = point(ratio);
        ratio += 0.001f;
        if (ratio <= 1f)
        {
            Vector3 val = point(ratio) - transform.localPosition;
            float num = Mathf.Atan2(val.y, val.x) * 57.29578f;
            transform.localEulerAngles = new Vector3(0f, 0f, num);
        }
    }

    public void place(Transform transform, float ratio)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        place(transform, ratio, Vector3.up);
    }

    public void place(Transform transform, float ratio, Vector3 worldUp)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        transform.position = point(ratio);
        ratio += 0.001f;
        if (ratio <= 1f)
        {
            transform.LookAt(point(ratio), worldUp);
        }
    }

    public void placeLocal(Transform transform, float ratio)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        placeLocal(transform, ratio, Vector3.up);
    }

    public void placeLocal(Transform transform, float ratio, Vector3 worldUp)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        transform.localPosition = point(ratio);
        ratio += 0.001f;
        if (ratio <= 1f)
        {
            transform.LookAt(transform.parent.TransformPoint(point(ratio)), worldUp);
        }
    }

    public void gizmoDraw(float t = -1f)
    {
        //IL_0019: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_002a: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        if (ptsAdj != null && ptsAdj.Length != 0)
        {
            Vector3 val = ptsAdj[0];
            for (int i = 0; i < ptsAdjLength; i++)
            {
                Vector3 val2 = ptsAdj[i];
                Gizmos.DrawLine(val, val2);
                val = val2;
            }
        }
    }

    public void drawGizmo(Color color)
    {
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0015: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        if (ptsAdjLength >= 4)
        {
            Vector3 val = ptsAdj[0];
            Color color2 = Gizmos.color;
            Gizmos.color = color;
            for (int i = 0; i < ptsAdjLength; i++)
            {
                Vector3 val2 = ptsAdj[i];
                Gizmos.DrawLine(val, val2);
                val = val2;
            }
            Gizmos.color = color2;
        }
    }

    public static void drawGizmo(Transform[] arr, Color color)
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_0067: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0071: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        if (arr.Length >= 4)
        {
            Vector3[] array = (Vector3[])(object)new Vector3[arr.Length];
            for (int i = 0; i < arr.Length; i++)
            {
                array[i] = arr[i].position;
            }
            LTSpline lTSpline = new LTSpline(array);
            Vector3 val = lTSpline.ptsAdj[0];
            Color color2 = Gizmos.color;
            Gizmos.color = color;
            for (int j = 0; j < lTSpline.ptsAdjLength; j++)
            {
                Vector3 val2 = lTSpline.ptsAdj[j];
                Gizmos.DrawLine(val, val2);
                val = val2;
            }
            Gizmos.color = color2;
        }
    }

    public static void drawLine(Transform[] arr, float width, Color color)
    {
        _ = arr.Length;
        _ = 4;
    }

    public void drawLinesGLLines(Material outlineMaterial, Color color, float width)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_007d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0082: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_00af: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ba: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c0: Unknown result type (might be due to invalid IL or missing references)
        //IL_004a: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        GL.PushMatrix();
        outlineMaterial.SetPass(0);
        GL.LoadPixelMatrix();
        GL.Begin(1);
        GL.Color(color);
        if (constantSpeed)
        {
            if (ptsAdjLength >= 4)
            {
                Vector3 val = ptsAdj[0];
                for (int i = 0; i < ptsAdjLength; i++)
                {
                    Vector3 val2 = ptsAdj[i];
                    GL.Vertex(val);
                    GL.Vertex(val2);
                    val = val2;
                }
            }
        }
        else if (pts.Length >= 4)
        {
            Vector3 val3 = pts[0];
            float num = 1f / ((float)pts.Length * 10f);
            for (float num2 = 0f; num2 < 1f; num2 += num)
            {
                float t = num2 / 1f;
                Vector3 val4 = interp(t);
                GL.Vertex(val3);
                GL.Vertex(val4);
                val3 = val4;
            }
        }
        GL.End();
        GL.PopMatrix();
    }

    public Vector3[] generateVectors()
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_001f: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0054: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        if (pts.Length >= 4)
        {
            List<Vector3> list = new List<Vector3>();
            Vector3 item = pts[0];
            list.Add(item);
            float num = 1f / ((float)pts.Length * 10f);
            for (float num2 = 0f; num2 < 1f; num2 += num)
            {
                float t = num2 / 1f;
                Vector3 item2 = interp(t);
                list.Add(item2);
            }
            list.ToArray();
        }
        return null;
    }
}
[Serializable]
public class LTRect
{
    public Rect _rect;

    public float alpha = 1f;

    public float rotation;

    public Vector2 pivot;

    public Vector2 margin;

    public Rect relativeRect = new Rect(0f, 0f, float.PositiveInfinity, float.PositiveInfinity);

    public bool rotateEnabled;

    [HideInInspector]
    public bool rotateFinished;

    public bool alphaEnabled;

    public string labelStr;

    public LTGUI.Element_Type type;

    public GUIStyle style;

    public bool useColor;

    public Color color = Color.white;

    public bool fontScaleToFit;

    public bool useSimpleScale;

    public bool sizeByHeight;

    public Texture texture;

    public int _id = -1;

    [HideInInspector]
    public int counter;

    public static bool colorTouched;

    public bool hasInitiliazed => _id != -1;

    public int id => _id | (counter << 16);

    public float x
    {
        get
        {
            return ((_rect)).x;
        }
        set
        {
            ((_rect)).x = value;
        }
    }

    public float y
    {
        get
        {
            return ((_rect)).y;
        }
        set
        {
            ((_rect)).y = value;
        }
    }

    public float width
    {
        get
        {
            return ((_rect)).width;
        }
        set
        {
            ((_rect)).width = value;
        }
    }

    public float height
    {
        get
        {
            return ((_rect)).height;
        }
        set
        {
            ((_rect)).height = value;
        }
    }

    public Rect rect
    {
        get
        {
            //IL_000d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0017: Unknown result type (might be due to invalid IL or missing references)
            //IL_0021: Unknown result type (might be due to invalid IL or missing references)
            //IL_0030: Unknown result type (might be due to invalid IL or missing references)
            //IL_007e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0088: Unknown result type (might be due to invalid IL or missing references)
            //IL_0092: Unknown result type (might be due to invalid IL or missing references)
            //IL_00a2: Unknown result type (might be due to invalid IL or missing references)
            //IL_006c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0059: Unknown result type (might be due to invalid IL or missing references)
            //IL_005e: Unknown result type (might be due to invalid IL or missing references)
            //IL_00ff: Unknown result type (might be due to invalid IL or missing references)
            if (colorTouched)
            {
                colorTouched = false;
                GUI.color = new Color(GUI.color.r, GUI.color.g, GUI.color.b, 1f);
            }
            if (rotateEnabled)
            {
                if (rotateFinished)
                {
                    rotateFinished = false;
                    rotateEnabled = false;
                    pivot = Vector2.zero;
                }
                else
                {
                    GUIUtility.RotateAroundPivot(rotation, pivot);
                }
            }
            if (alphaEnabled)
            {
                GUI.color = new Color(GUI.color.r, GUI.color.g, GUI.color.b, alpha);
                colorTouched = true;
            }
            if (fontScaleToFit)
            {
                if (useSimpleScale)
                {
                    style.fontSize = (int)(((_rect)).height * ((relativeRect)).height);
                }
                else
                {
                    style.fontSize = (int)((_rect)).height;
                }
            }
            return _rect;
        }
        set
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            //IL_0002: Unknown result type (might be due to invalid IL or missing references)
            _rect = value;
        }
    }

    public LTRect()
    {
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        reset();
        rotateEnabled = (alphaEnabled = true);
        _rect = new Rect(0f, 0f, 1f, 1f);
    }

    public LTRect(Rect rect)
    {
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0043: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        _rect = rect;
        reset();
    }

    public LTRect(float x, float y, float width, float height)
    {
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        _rect = new Rect(x, y, width, height);
        alpha = 1f;
        rotation = 0f;
        rotateEnabled = (alphaEnabled = false);
    }

    public LTRect(float x, float y, float width, float height, float alpha)
    {
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        _rect = new Rect(x, y, width, height);
        this.alpha = alpha;
        rotation = 0f;
        rotateEnabled = (alphaEnabled = false);
    }

    public LTRect(float x, float y, float width, float height, float alpha, float rotation)
    {
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        _rect = new Rect(x, y, width, height);
        this.alpha = alpha;
        this.rotation = rotation;
        rotateEnabled = (alphaEnabled = false);
        if (rotation != 0f)
        {
            rotateEnabled = true;
            resetForRotation();
        }
    }

    public void setId(int id, int counter)
    {
        _id = id;
        this.counter = counter;
    }

    public void reset()
    {
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        alpha = 1f;
        rotation = 0f;
        rotateEnabled = (alphaEnabled = false);
        margin = Vector2.zero;
        sizeByHeight = false;
        useColor = false;
    }

    public void resetForRotation()
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0007: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0025: Unknown result type (might be due to invalid IL or missing references)
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_006b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_0098: Unknown result type (might be due to invalid IL or missing references)
        //IL_009f: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00af: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
        Matrix4x4 matrix = GUI.matrix;
        float num = ((matrix))[0, 0];
        matrix = GUI.matrix;
        float num2 = ((matrix))[1, 1];
        matrix = GUI.matrix;
        Vector3 val = default(Vector3);
        ((val))..ctor(num, num2, ((matrix))[2, 2]);
        if (pivot == Vector2.zero)
        {
            float num3 = (((_rect)).x + ((_rect)).width * 0.5f) * val.x;
            matrix = GUI.matrix;
            float num4 = num3 + ((matrix))[0, 3];
            float num5 = (((_rect)).y + ((_rect)).height * 0.5f) * val.y;
            matrix = GUI.matrix;
            pivot = new Vector2(num4, num5 + ((matrix))[1, 3]);
        }
    }

    public LTRect setStyle(GUIStyle style)
    {
        this.style = style;
        return this;
    }

    public LTRect setFontScaleToFit(bool fontScaleToFit)
    {
        this.fontScaleToFit = fontScaleToFit;
        return this;
    }

    public LTRect setColor(Color color)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        this.color = color;
        useColor = true;
        return this;
    }

    public LTRect setAlpha(float alpha)
    {
        this.alpha = alpha;
        return this;
    }

    public LTRect setLabel(string str)
    {
        labelStr = str;
        return this;
    }

    public LTRect setUseSimpleScale(bool useSimpleScale, Rect relativeRect)
    {
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        this.useSimpleScale = useSimpleScale;
        this.relativeRect = relativeRect;
        return this;
    }

    public LTRect setUseSimpleScale(bool useSimpleScale)
    {
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        this.useSimpleScale = useSimpleScale;
        relativeRect = new Rect(0f, 0f, (float)Screen.width, (float)Screen.height);
        return this;
    }

    public LTRect setSizeByHeight(bool sizeByHeight)
    {
        this.sizeByHeight = sizeByHeight;
        return this;
    }

    public override string ToString()
    {
        return "x:" + ((_rect)).x + " y:" + ((_rect)).y + " width:" + ((_rect)).width + " height:" + ((_rect)).height;
    }
}
public class LTEvent
{
    public int id;

    public object data;

    public LTEvent(int id, object data)
    {
        this.id = id;
        this.data = data;
    }
}
public class LTGUI
{
    public enum Element_Type
    {
        Texture,
        Label
    }

    public static int RECT_LEVELS = 5;

    public static int RECTS_PER_LEVEL = 10;

    public static int BUTTONS_MAX = 24;

    public static LTRect[] levels;

    public static int[] levelDepths;

    public static Rect[] buttons;

    public static int[] buttonLevels;

    public static int[] buttonLastFrame;

    public static LTRect r;

    public static Color color = Color.white;

    public static bool isGUIEnabled = false;

    public static int global_counter = 0;

    public static void init()
    {
        if (levels == null)
        {
            levels = new LTRect[RECT_LEVELS * RECTS_PER_LEVEL];
            levelDepths = new int[RECT_LEVELS];
        }
    }

    public static void initRectCheck()
    {
        if (buttons == null)
        {
            buttons = (Rect[])(object)new Rect[BUTTONS_MAX];
            buttonLevels = new int[BUTTONS_MAX];
            buttonLastFrame = new int[BUTTONS_MAX];
            for (int i = 0; i < buttonLevels.Length; i++)
            {
                buttonLevels[i] = -1;
            }
        }
    }

    public static void reset()
    {
        if (isGUIEnabled)
        {
            isGUIEnabled = false;
            for (int i = 0; i < levels.Length; i++)
            {
                levels[i] = null;
            }
            for (int j = 0; j < levelDepths.Length; j++)
            {
                levelDepths[j] = 0;
            }
        }
    }

    public static void update(int updateLevel)
    {
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_03f6: Unknown result type (might be due to invalid IL or missing references)
        //IL_0064: Unknown result type (might be due to invalid IL or missing references)
        //IL_0193: Unknown result type (might be due to invalid IL or missing references)
        //IL_0198: Unknown result type (might be due to invalid IL or missing references)
        //IL_01b5: Unknown result type (might be due to invalid IL or missing references)
        //IL_01ba: Unknown result type (might be due to invalid IL or missing references)
        //IL_01d7: Unknown result type (might be due to invalid IL or missing references)
        //IL_01dc: Unknown result type (might be due to invalid IL or missing references)
        //IL_01e9: Unknown result type (might be due to invalid IL or missing references)
        //IL_01ee: Unknown result type (might be due to invalid IL or missing references)
        //IL_01f6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b2: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f9: Unknown result type (might be due to invalid IL or missing references)
        //IL_0136: Unknown result type (might be due to invalid IL or missing references)
        //IL_013b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0158: Unknown result type (might be due to invalid IL or missing references)
        //IL_015d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0175: Unknown result type (might be due to invalid IL or missing references)
        //IL_0274: Unknown result type (might be due to invalid IL or missing references)
        //IL_0279: Unknown result type (might be due to invalid IL or missing references)
        //IL_0291: Unknown result type (might be due to invalid IL or missing references)
        //IL_0244: Unknown result type (might be due to invalid IL or missing references)
        //IL_0249: Unknown result type (might be due to invalid IL or missing references)
        //IL_0256: Unknown result type (might be due to invalid IL or missing references)
        //IL_025b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0263: Unknown result type (might be due to invalid IL or missing references)
        //IL_0296: Unknown result type (might be due to invalid IL or missing references)
        //IL_02c6: Unknown result type (might be due to invalid IL or missing references)
        //IL_038c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0391: Unknown result type (might be due to invalid IL or missing references)
        //IL_03ae: Unknown result type (might be due to invalid IL or missing references)
        //IL_03b3: Unknown result type (might be due to invalid IL or missing references)
        //IL_03cb: Unknown result type (might be due to invalid IL or missing references)
        //IL_03d1: Unknown result type (might be due to invalid IL or missing references)
        //IL_03d7: Unknown result type (might be due to invalid IL or missing references)
        //IL_02e6: Unknown result type (might be due to invalid IL or missing references)
        //IL_02eb: Unknown result type (might be due to invalid IL or missing references)
        //IL_0328: Unknown result type (might be due to invalid IL or missing references)
        //IL_032d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0365: Unknown result type (might be due to invalid IL or missing references)
        //IL_036b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0371: Unknown result type (might be due to invalid IL or missing references)
        if (!isGUIEnabled)
        {
            return;
        }
        init();
        if (levelDepths[updateLevel] <= 0)
        {
            return;
        }
        color = GUI.color;
        int num = updateLevel * RECTS_PER_LEVEL;
        int num2 = num + levelDepths[updateLevel];
        for (int i = num; i < num2; i++)
        {
            r = levels[i];
            if (r == null)
            {
                continue;
            }
            if (r.useColor)
            {
                GUI.color = r.color;
            }
            Rect rect;
            if (r.type == Element_Type.Label)
            {
                if (r.style != null)
                {
                    GUI.skin.label = r.style;
                }
                if (r.useSimpleScale)
                {
                    rect = r.rect;
                    float num3 = (((rect)).x + r.margin.x + ((r.relativeRect)).x) * ((r.relativeRect)).width;
                    rect = r.rect;
                    float num4 = (((rect)).y + r.margin.y + ((r.relativeRect)).y) * ((r.relativeRect)).height;
                    rect = r.rect;
                    float num5 = ((rect)).width * ((r.relativeRect)).width;
                    rect = r.rect;
                    GUI.Label(new Rect(num3, num4, num5, ((rect)).height * ((r.relativeRect)).height), r.labelStr);
                }
                else
                {
                    rect = r.rect;
                    float num6 = ((rect)).x + r.margin.x;
                    rect = r.rect;
                    float num7 = ((rect)).y + r.margin.y;
                    rect = r.rect;
                    float width = ((rect)).width;
                    rect = r.rect;
                    GUI.Label(new Rect(num6, num7, width, ((rect)).height), r.labelStr);
                }
            }
            else if (r.type == Element_Type.Texture && r.texture != null)
            {
                Vector2 val;
                if (!r.useSimpleScale)
                {
                    rect = r.rect;
                    float width2 = ((rect)).width;
                    rect = r.rect;
                    val = new Vector2(width2, ((rect)).height);
                }
                else
                {
                    rect = r.rect;
                    val = new Vector2(0f, ((rect)).height * ((r.relativeRect)).height);
                }
                Vector2 val2 = val;
                if (r.sizeByHeight)
                {
                    val2.x = (float)r.texture.width / (float)r.texture.height * val2.y;
                }
                if (r.useSimpleScale)
                {
                    rect = r.rect;
                    float num8 = (((rect)).x + r.margin.x + ((r.relativeRect)).x) * ((r.relativeRect)).width;
                    rect = r.rect;
                    GUI.DrawTexture(new Rect(num8, (((rect)).y + r.margin.y + ((r.relativeRect)).y) * ((r.relativeRect)).height, val2.x, val2.y), r.texture);
                }
                else
                {
                    rect = r.rect;
                    float num9 = ((rect)).x + r.margin.x;
                    rect = r.rect;
                    GUI.DrawTexture(new Rect(num9, ((rect)).y + r.margin.y, val2.x, val2.y), r.texture);
                }
            }
        }
        GUI.color = color;
    }

    public static bool checkOnScreen(Rect rect)
    {
        bool num = ((rect)).x + ((rect)).width < 0f;
        bool flag = ((rect)).x > (float)Screen.width;
        bool flag2 = ((rect)).y > (float)Screen.height;
        bool flag3 = ((rect)).y + ((rect)).height < 0f;
        return !(num || flag || flag2 || flag3);
    }

    public static void destroy(int id)
    {
        int num = id & 0xFFFF;
        int num2 = id >> 16;
        if (id >= 0 && levels[num] != null && levels[num].hasInitiliazed && levels[num].counter == num2)
        {
            levels[num] = null;
        }
    }

    public static void destroyAll(int depth)
    {
        int num = depth * RECTS_PER_LEVEL + RECTS_PER_LEVEL;
        int num2 = depth * RECTS_PER_LEVEL;
        while (levels != null && num2 < num)
        {
            levels[num2] = null;
            num2++;
        }
    }

    public static LTRect label(Rect rect, string label, int depth)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        return LTGUI.label(new LTRect(rect), label, depth);
    }

    public static LTRect label(LTRect rect, string label, int depth)
    {
        rect.type = Element_Type.Label;
        rect.labelStr = label;
        return element(rect, depth);
    }

    public static LTRect texture(Rect rect, Texture texture, int depth)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        return LTGUI.texture(new LTRect(rect), texture, depth);
    }

    public static LTRect texture(LTRect rect, Texture texture, int depth)
    {
        rect.type = Element_Type.Texture;
        rect.texture = texture;
        return element(rect, depth);
    }

    public static LTRect element(LTRect rect, int depth)
    {
        //IL_0089: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        isGUIEnabled = true;
        init();
        int num = depth * RECTS_PER_LEVEL + RECTS_PER_LEVEL;
        int num2 = 0;
        if (rect != null)
        {
            destroy(rect.id);
        }
        if (rect.type == Element_Type.Label && rect.style != null && rect.style.normal.textColor.a <= 0f)
        {
            Debug.LogWarning("Your GUI normal color has an alpha of zero, and will not be rendered.");
        }
        if (((rect.relativeRect)).width == float.PositiveInfinity)
        {
            rect.relativeRect = new Rect(0f, 0f, (float)Screen.width, (float)Screen.height);
        }
        for (int i = depth * RECTS_PER_LEVEL; i < num; i++)
        {
            r = levels[i];
            if (r == null)
            {
                r = rect;
                r.rotateEnabled = true;
                r.alphaEnabled = true;
                r.setId(i, global_counter);
                levels[i] = r;
                if (num2 >= levelDepths[depth])
                {
                    levelDepths[depth] = num2 + 1;
                }
                global_counter++;
                return r;
            }
            num2++;
        }
        Debug.LogError("You ran out of GUI Element spaces");
        return null;
    }

    public static bool hasNoOverlap(Rect rect, int depth)
    {
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        initRectCheck();
        bool result = true;
        bool flag = false;
        for (int i = 0; i < buttonLevels.Length; i++)
        {
            if (buttonLevels[i] >= 0)
            {
                if (buttonLastFrame[i] + 1 < Time.frameCount)
                {
                    buttonLevels[i] = -1;
                }
                else if (buttonLevels[i] > depth && pressedWithinRect(buttons[i]))
                {
                    result = false;
                }
            }
            if (!flag && buttonLevels[i] < 0)
            {
                flag = true;
                buttonLevels[i] = depth;
                buttons[i] = rect;
                buttonLastFrame[i] = Time.frameCount;
            }
        }
        return result;
    }

    public static bool pressedWithinRect(Rect rect)
    {
        //IL_0000: Unknown result type (might be due to invalid IL or missing references)
        //IL_0005: Unknown result type (might be due to invalid IL or missing references)
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        Vector2 val = firstTouch();
        if (val.x < 0f)
        {
            return false;
        }
        float num = (float)Screen.height - val.y;
        if (val.x > ((rect)).x && val.x < ((rect)).x + ((rect)).width && num > ((rect)).y)
        {
            return num < ((rect)).y + ((rect)).height;
        }
        return false;
    }

    public static bool checkWithinRect(Vector2 vec2, Rect rect)
    {
        //IL_0008: Unknown result type (might be due to invalid IL or missing references)
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        vec2.y = (float)Screen.height - vec2.y;
        if (vec2.x > ((rect)).x && vec2.x < ((rect)).x + ((rect)).width && vec2.y > ((rect)).y)
        {
            return vec2.y < ((rect)).y + ((rect)).height;
        }
        return false;
    }

    public static Vector2 firstTouch()
    {
        //IL_0013: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_0026: Unknown result type (might be due to invalid IL or missing references)
        if (Input.touchCount > 0)
        {
            return ((Input.touches[0])).position;
        }
        if (Input.GetMouseButton(0))
        {
            return (Input.mousePosition);
        }
        return new Vector2(float.NegativeInfinity, float.NegativeInfinity);
    }
}
public static class LeanTweenExt
{
    public static LTDescr LeanAlpha(this GameObject gameObject, float to, float time)
    {
        return LeanTween.alpha(gameObject, to, time);
    }

    public static LTDescr LeanAlphaVertex(this GameObject gameObject, float to, float time)
    {
        return LeanTween.alphaVertex(gameObject, to, time);
    }

    public static LTDescr LeanAlpha(this RectTransform rectTransform, float to, float time)
    {
        return LeanTween.alpha(rectTransform, to, time);
    }

    public static LTDescr LeanAlpha(this CanvasGroup canvas, float to, float time)
    {
        return LeanTween.alphaCanvas(canvas, to, time);
    }

    public static LTDescr LeanAlphaText(this RectTransform rectTransform, float to, float time)
    {
        return LeanTween.alphaText(rectTransform, to, time);
    }

    public static void LeanCancel(this GameObject gameObject)
    {
        LeanTween.cancel(gameObject);
    }

    public static void LeanCancel(this GameObject gameObject, bool callOnComplete)
    {
        LeanTween.cancel(gameObject, callOnComplete);
    }

    public static void LeanCancel(this GameObject gameObject, int uniqueId, bool callOnComplete = false)
    {
        LeanTween.cancel(gameObject, uniqueId, callOnComplete);
    }

    public static void LeanCancel(this RectTransform rectTransform)
    {
        LeanTween.cancel(rectTransform);
    }

    public static LTDescr LeanColor(this GameObject gameObject, Color to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.color(gameObject, to, time);
    }

    public static LTDescr LeanColorText(this RectTransform rectTransform, Color to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.colorText(rectTransform, to, time);
    }

    public static LTDescr LeanDelayedCall(this GameObject gameObject, float delayTime, System.Action callback)
    {
        return LeanTween.delayedCall(gameObject, delayTime, callback);
    }

    public static LTDescr LeanDelayedCall(this GameObject gameObject, float delayTime, System.Action<object> callback)
    {
        return LeanTween.delayedCall(gameObject, delayTime, callback);
    }

    public static bool LeanIsPaused(this GameObject gameObject)
    {
        return LeanTween.isPaused(gameObject);
    }

    public static bool LeanIsPaused(this RectTransform rectTransform)
    {
        return LeanTween.isPaused(rectTransform);
    }

    public static bool LeanIsTweening(this GameObject gameObject)
    {
        return LeanTween.isTweening(gameObject);
    }

    public static LTDescr LeanMove(this GameObject gameObject, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.move(gameObject, to, time);
    }

    public static LTDescr LeanMove(this Transform transform, Vector3 to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.move(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMove(this RectTransform rectTransform, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.move(rectTransform, to, time);
    }

    public static LTDescr LeanMove(this GameObject gameObject, Vector2 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.move(gameObject, to, time);
    }

    public static LTDescr LeanMove(this Transform transform, Vector2 to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.move(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMove(this GameObject gameObject, Vector3[] to, float time)
    {
        return LeanTween.move(gameObject, to, time);
    }

    public static LTDescr LeanMove(this GameObject gameObject, LTBezierPath to, float time)
    {
        return LeanTween.move(gameObject, to, time);
    }

    public static LTDescr LeanMove(this GameObject gameObject, LTSpline to, float time)
    {
        return LeanTween.move(gameObject, to, time);
    }

    public static LTDescr LeanMove(this Transform transform, Vector3[] to, float time)
    {
        return LeanTween.move(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMove(this Transform transform, LTBezierPath to, float time)
    {
        return LeanTween.move(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMove(this Transform transform, LTSpline to, float time)
    {
        return LeanTween.move(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveLocal(this GameObject gameObject, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.moveLocal(gameObject, to, time);
    }

    public static LTDescr LeanMoveLocal(this GameObject gameObject, LTBezierPath to, float time)
    {
        return LeanTween.moveLocal(gameObject, to, time);
    }

    public static LTDescr LeanMoveLocal(this GameObject gameObject, LTSpline to, float time)
    {
        return LeanTween.moveLocal(gameObject, to, time);
    }

    public static LTDescr LeanMoveLocal(this Transform transform, Vector3 to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.moveLocal(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveLocal(this Transform transform, LTBezierPath to, float time)
    {
        return LeanTween.moveLocal(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveLocal(this Transform transform, LTSpline to, float time)
    {
        return LeanTween.moveLocal(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveLocalX(this GameObject gameObject, float to, float time)
    {
        return LeanTween.moveLocalX(gameObject, to, time);
    }

    public static LTDescr LeanMoveLocalY(this GameObject gameObject, float to, float time)
    {
        return LeanTween.moveLocalY(gameObject, to, time);
    }

    public static LTDescr LeanMoveLocalZ(this GameObject gameObject, float to, float time)
    {
        return LeanTween.moveLocalZ(gameObject, to, time);
    }

    public static LTDescr LeanMoveLocalX(this Transform transform, float to, float time)
    {
        return LeanTween.moveLocalX(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveLocalY(this Transform transform, float to, float time)
    {
        return LeanTween.moveLocalY(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveLocalZ(this Transform transform, float to, float time)
    {
        return LeanTween.moveLocalZ(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveSpline(this GameObject gameObject, Vector3[] to, float time)
    {
        return LeanTween.moveSpline(gameObject, to, time);
    }

    public static LTDescr LeanMoveSpline(this GameObject gameObject, LTSpline to, float time)
    {
        return LeanTween.moveSpline(gameObject, to, time);
    }

    public static LTDescr LeanMoveSpline(this Transform transform, Vector3[] to, float time)
    {
        return LeanTween.moveSpline(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveSpline(this Transform transform, LTSpline to, float time)
    {
        return LeanTween.moveSpline(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveSplineLocal(this GameObject gameObject, Vector3[] to, float time)
    {
        return LeanTween.moveSplineLocal(gameObject, to, time);
    }

    public static LTDescr LeanMoveSplineLocal(this Transform transform, Vector3[] to, float time)
    {
        return LeanTween.moveSplineLocal(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveX(this GameObject gameObject, float to, float time)
    {
        return LeanTween.moveX(gameObject, to, time);
    }

    public static LTDescr LeanMoveX(this Transform transform, float to, float time)
    {
        return LeanTween.moveX(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveX(this RectTransform rectTransform, float to, float time)
    {
        return LeanTween.moveX(rectTransform, to, time);
    }

    public static LTDescr LeanMoveY(this GameObject gameObject, float to, float time)
    {
        return LeanTween.moveY(gameObject, to, time);
    }

    public static LTDescr LeanMoveY(this Transform transform, float to, float time)
    {
        return LeanTween.moveY(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveY(this RectTransform rectTransform, float to, float time)
    {
        return LeanTween.moveY(rectTransform, to, time);
    }

    public static LTDescr LeanMoveZ(this GameObject gameObject, float to, float time)
    {
        return LeanTween.moveZ(gameObject, to, time);
    }

    public static LTDescr LeanMoveZ(this Transform transform, float to, float time)
    {
        return LeanTween.moveZ(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanMoveZ(this RectTransform rectTransform, float to, float time)
    {
        return LeanTween.moveZ(rectTransform, to, time);
    }

    public static void LeanPause(this GameObject gameObject)
    {
        LeanTween.pause(gameObject);
    }

    public static LTDescr LeanPlay(this RectTransform rectTransform, Sprite[] sprites)
    {
        return LeanTween.play(rectTransform, sprites);
    }

    public static void LeanResume(this GameObject gameObject)
    {
        LeanTween.resume(gameObject);
    }

    public static LTDescr LeanRotate(this GameObject gameObject, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.rotate(gameObject, to, time);
    }

    public static LTDescr LeanRotate(this Transform transform, Vector3 to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.rotate(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanRotate(this RectTransform rectTransform, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.rotate(rectTransform, to, time);
    }

    public static LTDescr LeanRotateAround(this GameObject gameObject, Vector3 axis, float add, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.rotateAround(gameObject, axis, add, time);
    }

    public static LTDescr LeanRotateAround(this Transform transform, Vector3 axis, float add, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.rotateAround(((Component)transform).gameObject, axis, add, time);
    }

    public static LTDescr LeanRotateAround(this RectTransform rectTransform, Vector3 axis, float add, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.rotateAround(rectTransform, axis, add, time);
    }

    public static LTDescr LeanRotateAroundLocal(this GameObject gameObject, Vector3 axis, float add, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.rotateAroundLocal(gameObject, axis, add, time);
    }

    public static LTDescr LeanRotateAroundLocal(this Transform transform, Vector3 axis, float add, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.rotateAroundLocal(((Component)transform).gameObject, axis, add, time);
    }

    public static LTDescr LeanRotateAroundLocal(this RectTransform rectTransform, Vector3 axis, float add, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.rotateAroundLocal(rectTransform, axis, add, time);
    }

    public static LTDescr LeanRotateX(this GameObject gameObject, float to, float time)
    {
        return LeanTween.rotateX(gameObject, to, time);
    }

    public static LTDescr LeanRotateX(this Transform transform, float to, float time)
    {
        return LeanTween.rotateX(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanRotateY(this GameObject gameObject, float to, float time)
    {
        return LeanTween.rotateY(gameObject, to, time);
    }

    public static LTDescr LeanRotateY(this Transform transform, float to, float time)
    {
        return LeanTween.rotateY(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanRotateZ(this GameObject gameObject, float to, float time)
    {
        return LeanTween.rotateZ(gameObject, to, time);
    }

    public static LTDescr LeanRotateZ(this Transform transform, float to, float time)
    {
        return LeanTween.rotateZ(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanScale(this GameObject gameObject, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.scale(gameObject, to, time);
    }

    public static LTDescr LeanScale(this Transform transform, Vector3 to, float time)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.scale(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanScale(this RectTransform rectTransform, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.scale(rectTransform, to, time);
    }

    public static LTDescr LeanScaleX(this GameObject gameObject, float to, float time)
    {
        return LeanTween.scaleX(gameObject, to, time);
    }

    public static LTDescr LeanScaleX(this Transform transform, float to, float time)
    {
        return LeanTween.scaleX(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanScaleY(this GameObject gameObject, float to, float time)
    {
        return LeanTween.scaleY(gameObject, to, time);
    }

    public static LTDescr LeanScaleY(this Transform transform, float to, float time)
    {
        return LeanTween.scaleY(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanScaleZ(this GameObject gameObject, float to, float time)
    {
        return LeanTween.scaleZ(gameObject, to, time);
    }

    public static LTDescr LeanScaleZ(this Transform transform, float to, float time)
    {
        return LeanTween.scaleZ(((Component)transform).gameObject, to, time);
    }

    public static LTDescr LeanSize(this RectTransform rectTransform, Vector2 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.size(rectTransform, to, time);
    }

    public static LTDescr LeanValue(this GameObject gameObject, Color from, Color to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.value(gameObject, from, to, time);
    }

    public static LTDescr LeanValue(this GameObject gameObject, float from, float to, float time)
    {
        return LeanTween.value(gameObject, from, to, time);
    }

    public static LTDescr LeanValue(this GameObject gameObject, Vector2 from, Vector2 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.value(gameObject, from, to, time);
    }

    public static LTDescr LeanValue(this GameObject gameObject, Vector3 from, Vector3 to, float time)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.value(gameObject, from, to, time);
    }

    public static LTDescr LeanValue(this GameObject gameObject, System.Action<float> callOnUpdate, float from, float to, float time)
    {
        return LeanTween.value(gameObject, callOnUpdate, from, to, time);
    }

    public static LTDescr LeanValue(this GameObject gameObject, System.Action<float, float> callOnUpdate, float from, float to, float time)
    {
        return LeanTween.value(gameObject, callOnUpdate, from, to, time);
    }

    public static LTDescr LeanValue(this GameObject gameObject, System.Action<float, object> callOnUpdate, float from, float to, float time)
    {
        return LeanTween.value(gameObject, callOnUpdate, from, to, time);
    }

    public static LTDescr LeanValue(this GameObject gameObject, System.Action<Color> callOnUpdate, Color from, Color to, float time)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.value(gameObject, callOnUpdate, from, to, time);
    }

    public static LTDescr LeanValue(this GameObject gameObject, System.Action<Vector2> callOnUpdate, Vector2 from, Vector2 to, float time)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.value(gameObject, callOnUpdate, from, to, time);
    }

    public static LTDescr LeanValue(this GameObject gameObject, System.Action<Vector3> callOnUpdate, Vector3 from, Vector3 to, float time)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        return LeanTween.value(gameObject, callOnUpdate, from, to, time);
    }

    public static void LeanSetPosX(this Transform transform, float val)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        transform.position = new Vector3(val, transform.position.y, transform.position.z);
    }

    public static void LeanSetPosY(this Transform transform, float val)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        transform.position = new Vector3(transform.position.x, val, transform.position.z);
    }

    public static void LeanSetPosZ(this Transform transform, float val)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        transform.position = new Vector3(transform.position.x, transform.position.y, val);
    }

    public static void LeanSetLocalPosX(this Transform transform, float val)
    {
        //IL_0003: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        transform.localPosition = new Vector3(val, transform.localPosition.y, transform.localPosition.z);
    }

    public static void LeanSetLocalPosY(this Transform transform, float val)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_000e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        transform.localPosition = new Vector3(transform.localPosition.x, val, transform.localPosition.z);
    }

    public static void LeanSetLocalPosZ(this Transform transform, float val)
    {
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        //IL_000d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        transform.localPosition = new Vector3(transform.localPosition.x, transform.localPosition.y, val);
    }

    public static Color LeanColor(this Transform transform)
    {
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        return ((Component)transform).GetComponent<Renderer>().material.color;
    }
}
public class LTDescr
{
    public delegate Vector3 EaseTypeDelegate();

    public delegate void ActionMethodDelegate();

    public bool toggle;

    public bool useEstimatedTime;

    public bool useFrames;

    public bool useManualTime;

    public bool usesNormalDt;

    public bool hasInitiliazed;

    public bool hasExtraOnCompletes;

    public bool hasPhysics;

    public bool onCompleteOnRepeat;

    public bool onCompleteOnStart;

    public bool useRecursion;

    public float ratioPassed;

    public float passed;

    public float delay;

    public float time;

    public float speed;

    public float lastVal;

    public uint _id;

    public int loopCount;

    public uint counter = uint.MaxValue;

    public float direction;

    public float directionLast;

    public float overshoot;

    public float period;

    public float scale;

    public bool destroyOnComplete;

    public Transform trans;

    public Vector3 fromInternal;

    public Vector3 toInternal;

    public Vector3 diff;

    public Vector3 diffDiv2;

    public TweenAction type;

    public LeanTweenType easeType;

    public LeanTweenType loopType;

    public bool hasUpdateCallback;

    public EaseTypeDelegate easeMethod;

    public SpriteRenderer spriteRen;

    public RectTransform rectTransform;

    public Text uiText;

    public Image uiImage;

    public RawImage rawImage;

    public Sprite[] sprites;

    public LTDescrOptional _optional = new LTDescrOptional();

    public static float val;

    public static float dt;

    public static Vector3 newVect;

    public Vector3 from
    {
        get
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            return fromInternal;
        }
        set
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            //IL_0002: Unknown result type (might be due to invalid IL or missing references)
            fromInternal = value;
        }
    }

    public Vector3 to
    {
        get
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            return toInternal;
        }
        set
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            //IL_0002: Unknown result type (might be due to invalid IL or missing references)
            toInternal = value;
        }
    }

    public ActionMethodDelegate easeInternal { get; set; }

    public ActionMethodDelegate initInternal { get; set; }

    public Transform toTrans => optional.toTrans;

    public int uniqueId => (int)(_id | (counter << 16));

    public int id => uniqueId;

    public LTDescrOptional optional
    {
        get
        {
            return _optional;
        }
        set
        {
            _optional = value;
        }
    }

    public override string ToString()
    {
        //IL_00b6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bb: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00dc: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f8: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fd: Unknown result type (might be due to invalid IL or missing references)
        string[] obj = new string[27]
        {
            (trans != null) ? ("name:" + (((Component)trans).gameObject).name) : "gameObject:null",
            " toggle:",
            toggle.ToString(),
            " passed:",
            passed.ToString(),
            " time:",
            time.ToString(),
            " delay:",
            delay.ToString(),
            " direction:",
            direction.ToString(),
            " from:",
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null
        };
        Vector3 val = from;
        obj[12] = ((object)(val)).ToString();
        obj[13] = " to:";
        val = to;
        obj[14] = ((object)(val)).ToString();
        obj[15] = " diff:";
        val = diff;
        obj[16] = ((object)(val)).ToString();
        obj[17] = " type:";
        obj[18] = type.ToString();
        obj[19] = " ease:";
        obj[20] = easeType.ToString();
        obj[21] = " useEstimatedTime:";
        obj[22] = useEstimatedTime.ToString();
        obj[23] = " id:";
        obj[24] = id.ToString();
        obj[25] = " hasInitiliazed:";
        obj[26] = hasInitiliazed.ToString();
        return string.Concat(obj);
    }

    [Obsolete("Use 'LeanTween.cancel( id )' instead")]
    public LTDescr cancel(GameObject gameObject)
    {
        if (gameObject == ((Component)trans).gameObject)
        {
            LeanTween.removeTween((int)_id, uniqueId);
        }
        return this;
    }

    public void reset()
    {
        //IL_00f9: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fe: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ff: Unknown result type (might be due to invalid IL or missing references)
        //IL_0105: Unknown result type (might be due to invalid IL or missing references)
        toggle = (useRecursion = (usesNormalDt = true));
        trans = null;
        spriteRen = null;
        passed = (delay = (lastVal = 0f));
        hasUpdateCallback = (useEstimatedTime = (useFrames = (hasInitiliazed = (onCompleteOnRepeat = (destroyOnComplete = (onCompleteOnStart = (useManualTime = (hasExtraOnCompletes = false))))))));
        easeType = LeanTweenType.linear;
        loopType = LeanTweenType.once;
        loopCount = 0;
        direction = (directionLast = (overshoot = (scale = 1f)));
        period = 0.3f;
        speed = -1f;
        easeMethod = easeLinear;
        Vector3 val = (to = Vector3.zero);
        from = val;
        _optional.reset();
    }

    public LTDescr setFollow()
    {
        type = TweenAction.FOLLOW;
        return this;
    }

    public LTDescr setMoveX()
    {
        type = TweenAction.MOVE_X;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.position.x;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.position = new Vector3(easeMethod().x, trans.position.y, trans.position.z);
        };
        return this;
    }

    public LTDescr setMoveY()
    {
        type = TweenAction.MOVE_Y;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.position.y;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.position = new Vector3(trans.position.x, easeMethod().x, trans.position.z);
        };
        return this;
    }

    public LTDescr setMoveZ()
    {
        type = TweenAction.MOVE_Z;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.position.z;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.position = new Vector3(trans.position.x, trans.position.y, easeMethod().x);
        };
        return this;
    }

    public LTDescr setMoveLocalX()
    {
        type = TweenAction.MOVE_LOCAL_X;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.localPosition.x;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.localPosition = new Vector3(easeMethod().x, trans.localPosition.y, trans.localPosition.z);
        };
        return this;
    }

    public LTDescr setMoveLocalY()
    {
        type = TweenAction.MOVE_LOCAL_Y;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.localPosition.y;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.localPosition = new Vector3(trans.localPosition.x, easeMethod().x, trans.localPosition.z);
        };
        return this;
    }

    public LTDescr setMoveLocalZ()
    {
        type = TweenAction.MOVE_LOCAL_Z;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.localPosition.z;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.localPosition = new Vector3(trans.localPosition.x, trans.localPosition.y, easeMethod().x);
        };
        return this;
    }

    public void initFromInternal()
    {
        fromInternal.x = 0f;
    }

    public LTDescr setOffset(Vector3 offset)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        toInternal = offset;
        return this;
    }

    public LTDescr setMoveCurved()
    {
        type = TweenAction.MOVE_CURVED;
        initInternal = initFromInternal;
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0091: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            val = newVect.x;
            if (_optional.path.orientToPath)
            {
                if (_optional.path.orientToPath2d)
                {
                    _optional.path.place2d(trans, val);
                }
                else
                {
                    _optional.path.place(trans, val);
                }
            }
            else
            {
                trans.position = _optional.path.point(val);
            }
        };
        return this;
    }

    public LTDescr setMoveCurvedLocal()
    {
        type = TweenAction.MOVE_CURVED_LOCAL;
        initInternal = initFromInternal;
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0091: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            val = newVect.x;
            if (_optional.path.orientToPath)
            {
                if (_optional.path.orientToPath2d)
                {
                    _optional.path.placeLocal2d(trans, val);
                }
                else
                {
                    _optional.path.placeLocal(trans, val);
                }
            }
            else
            {
                trans.localPosition = _optional.path.point(val);
            }
        };
        return this;
    }

    public LTDescr setMoveSpline()
    {
        type = TweenAction.MOVE_SPLINE;
        initInternal = initFromInternal;
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0091: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            val = newVect.x;
            if (_optional.spline.orientToPath)
            {
                if (_optional.spline.orientToPath2d)
                {
                    _optional.spline.place2d(trans, val);
                }
                else
                {
                    _optional.spline.place(trans, val);
                }
            }
            else
            {
                trans.position = _optional.spline.point(val);
            }
        };
        return this;
    }

    public LTDescr setMoveSplineLocal()
    {
        type = TweenAction.MOVE_SPLINE_LOCAL;
        initInternal = initFromInternal;
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0091: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            val = newVect.x;
            if (_optional.spline.orientToPath)
            {
                if (_optional.spline.orientToPath2d)
                {
                    _optional.spline.placeLocal2d(trans, val);
                }
                else
                {
                    _optional.spline.placeLocal(trans, val);
                }
            }
            else
            {
                trans.localPosition = _optional.spline.point(val);
            }
        };
        return this;
    }

    public LTDescr setScaleX()
    {
        type = TweenAction.SCALE_X;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.localScale.x;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.localScale = new Vector3(easeMethod().x, trans.localScale.y, trans.localScale.z);
        };
        return this;
    }

    public LTDescr setScaleY()
    {
        type = TweenAction.SCALE_Y;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.localScale.y;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.localScale = new Vector3(trans.localScale.x, easeMethod().x, trans.localScale.z);
        };
        return this;
    }

    public LTDescr setScaleZ()
    {
        type = TweenAction.SCALE_Z;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.localScale.z;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.localScale = new Vector3(trans.localScale.x, trans.localScale.y, easeMethod().x);
        };
        return this;
    }

    public LTDescr setRotateX()
    {
        type = TweenAction.ROTATE_X;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.eulerAngles.x;
            toInternal.x = LeanTween.closestRot(fromInternal.x, toInternal.x);
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.eulerAngles = new Vector3(easeMethod().x, trans.eulerAngles.y, trans.eulerAngles.z);
        };
        return this;
    }

    public LTDescr setRotateY()
    {
        type = TweenAction.ROTATE_Y;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.eulerAngles.y;
            toInternal.x = LeanTween.closestRot(fromInternal.x, toInternal.x);
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.eulerAngles = new Vector3(trans.eulerAngles.x, easeMethod().x, trans.eulerAngles.z);
        };
        return this;
    }

    public LTDescr setRotateZ()
    {
        type = TweenAction.ROTATE_Z;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = trans.eulerAngles.z;
            toInternal.x = LeanTween.closestRot(fromInternal.x, toInternal.x);
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            trans.eulerAngles = new Vector3(trans.eulerAngles.x, trans.eulerAngles.y, easeMethod().x);
        };
        return this;
    }

    public LTDescr setRotateAround()
    {
        type = TweenAction.ROTATE_AROUND;
        initInternal = delegate
        {
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = 0f;
            _optional.origRotation = trans.rotation;
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0025: Unknown result type (might be due to invalid IL or missing references)
            //IL_002a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0037: Unknown result type (might be due to invalid IL or missing references)
            //IL_003c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0041: Unknown result type (might be due to invalid IL or missing references)
            //IL_0048: Unknown result type (might be due to invalid IL or missing references)
            //IL_004f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0065: Unknown result type (might be due to invalid IL or missing references)
            //IL_006c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0071: Unknown result type (might be due to invalid IL or missing references)
            //IL_0076: Unknown result type (might be due to invalid IL or missing references)
            //IL_007d: Unknown result type (might be due to invalid IL or missing references)
            //IL_007e: Unknown result type (might be due to invalid IL or missing references)
            //IL_007f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0095: Unknown result type (might be due to invalid IL or missing references)
            //IL_00ab: Unknown result type (might be due to invalid IL or missing references)
            //IL_00b0: Unknown result type (might be due to invalid IL or missing references)
            //IL_00b5: Unknown result type (might be due to invalid IL or missing references)
            //IL_00bc: Unknown result type (might be due to invalid IL or missing references)
            //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            LTDescr.val = newVect.x;
            Vector3 localPosition = trans.localPosition;
            Vector3 val = trans.TransformPoint(_optional.point);
            trans.RotateAround(val, _optional.axis, 0f - _optional.lastVal);
            Vector3 val2 = localPosition - trans.localPosition;
            trans.localPosition = localPosition - val2;
            trans.rotation = _optional.origRotation;
            val = trans.TransformPoint(_optional.point);
            trans.RotateAround(val, _optional.axis, LTDescr.val);
            _optional.lastVal = LTDescr.val;
        };
        return this;
    }

    public LTDescr setRotateAroundLocal()
    {
        type = TweenAction.ROTATE_AROUND_LOCAL;
        initInternal = delegate
        {
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = 0f;
            _optional.origRotation = trans.localRotation;
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0025: Unknown result type (might be due to invalid IL or missing references)
            //IL_002a: Unknown result type (might be due to invalid IL or missing references)
            //IL_003d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0042: Unknown result type (might be due to invalid IL or missing references)
            //IL_0053: Unknown result type (might be due to invalid IL or missing references)
            //IL_0058: Unknown result type (might be due to invalid IL or missing references)
            //IL_006e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0075: Unknown result type (might be due to invalid IL or missing references)
            //IL_007a: Unknown result type (might be due to invalid IL or missing references)
            //IL_007f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0086: Unknown result type (might be due to invalid IL or missing references)
            //IL_0087: Unknown result type (might be due to invalid IL or missing references)
            //IL_0088: Unknown result type (might be due to invalid IL or missing references)
            //IL_009e: Unknown result type (might be due to invalid IL or missing references)
            //IL_00b4: Unknown result type (might be due to invalid IL or missing references)
            //IL_00b9: Unknown result type (might be due to invalid IL or missing references)
            //IL_00be: Unknown result type (might be due to invalid IL or missing references)
            //IL_00c5: Unknown result type (might be due to invalid IL or missing references)
            //IL_00d2: Unknown result type (might be due to invalid IL or missing references)
            //IL_00d7: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            LTDescr.val = newVect.x;
            Vector3 localPosition = trans.localPosition;
            trans.RotateAround(trans.TransformPoint(_optional.point), trans.TransformDirection(_optional.axis), 0f - _optional.lastVal);
            Vector3 val = localPosition - trans.localPosition;
            trans.localPosition = localPosition - val;
            trans.localRotation = _optional.origRotation;
            Vector3 val2 = trans.TransformPoint(_optional.point);
            trans.RotateAround(val2, trans.TransformDirection(_optional.axis), LTDescr.val);
            _optional.lastVal = LTDescr.val;
        };
        return this;
    }

    public LTDescr setAlpha()
    {
        type = TweenAction.ALPHA;
        initInternal = delegate
        {
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0075: Unknown result type (might be due to invalid IL or missing references)
            //IL_00cd: Unknown result type (might be due to invalid IL or missing references)
            //IL_00d2: Unknown result type (might be due to invalid IL or missing references)
            //IL_00d9: Unknown result type (might be due to invalid IL or missing references)
            //IL_010b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0111: Expected O, but got Unknown
            //IL_0134: Unknown result type (might be due to invalid IL or missing references)
            //IL_0139: Unknown result type (might be due to invalid IL or missing references)
            //IL_0141: Unknown result type (might be due to invalid IL or missing references)
            SpriteRenderer component = ((Component)trans).GetComponent<SpriteRenderer>();
            if (component != null)
            {
                fromInternal.x = component.color.a;
            }
            else if (((Component)trans).GetComponent<Renderer>() != null && ((Component)trans).GetComponent<Renderer>().material.HasProperty("_Color"))
            {
                fromInternal.x = ((Component)trans).GetComponent<Renderer>().material.color.a;
            }
            else if (((Component)trans).GetComponent<Renderer>() != null && ((Component)trans).GetComponent<Renderer>().material.HasProperty("_TintColor"))
            {
                Color color = ((Component)trans).GetComponent<Renderer>().material.GetColor("_TintColor");
                fromInternal.x = color.a;
            }
            else if (trans.childCount > 0)
            {
                foreach (Transform tran in trans)
                {
                    Transform val = tran;
                    if (((Component)val).gameObject.GetComponent<Renderer>() != null)
                    {
                        Color color2 = ((Component)val).gameObject.GetComponent<Renderer>().material.color;
                        fromInternal.x = color2.a;
                        break;
                    }
                }
            }
            easeInternal = delegate
            {
                //IL_0006: Unknown result type (might be due to invalid IL or missing references)
                //IL_002f: Unknown result type (might be due to invalid IL or missing references)
                //IL_003f: Unknown result type (might be due to invalid IL or missing references)
                //IL_004f: Unknown result type (might be due to invalid IL or missing references)
                //IL_005e: Unknown result type (might be due to invalid IL or missing references)
                LTDescr.val = easeMethod().x;
                if (spriteRen != null)
                {
                    spriteRen.color = new Color(spriteRen.color.r, spriteRen.color.g, spriteRen.color.b, LTDescr.val);
                    alphaRecursiveSprite(trans, LTDescr.val);
                }
                else
                {
                    alphaRecursive(trans, LTDescr.val, useRecursion);
                }
            };
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0039: Unknown result type (might be due to invalid IL or missing references)
            //IL_0049: Unknown result type (might be due to invalid IL or missing references)
            //IL_0059: Unknown result type (might be due to invalid IL or missing references)
            //IL_0068: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            val = newVect.x;
            if (spriteRen != null)
            {
                spriteRen.color = new Color(spriteRen.color.r, spriteRen.color.g, spriteRen.color.b, val);
                alphaRecursiveSprite(trans, val);
            }
            else
            {
                alphaRecursive(trans, val, useRecursion);
            }
        };
        return this;
    }

    public LTDescr setTextAlpha()
    {
        type = TweenAction.TEXT_ALPHA;
        initInternal = delegate
        {
            //IL_0032: Unknown result type (might be due to invalid IL or missing references)
            uiText = ((Component)trans).GetComponent<Text>();
            fromInternal.x = ((uiText != null) ? ((Graphic)uiText).color.a : 1f);
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            textAlphaRecursive(trans, easeMethod().x, useRecursion);
        };
        return this;
    }

    public LTDescr setAlphaVertex()
    {
        type = TweenAction.ALPHA_VERTEX;
        initInternal = delegate
        {
            fromInternal.x = (int)((Component)trans).GetComponent<MeshFilter>().mesh.colors32[0].a;
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0093: Unknown result type (might be due to invalid IL or missing references)
            //IL_0098: Unknown result type (might be due to invalid IL or missing references)
            //IL_0099: Unknown result type (might be due to invalid IL or missing references)
            //IL_00a0: Unknown result type (might be due to invalid IL or missing references)
            //IL_00a7: Unknown result type (might be due to invalid IL or missing references)
            //IL_00b3: Unknown result type (might be due to invalid IL or missing references)
            //IL_00b8: Unknown result type (might be due to invalid IL or missing references)
            //IL_00bd: Unknown result type (might be due to invalid IL or missing references)
            //IL_00c6: Unknown result type (might be due to invalid IL or missing references)
            //IL_00c7: Unknown result type (might be due to invalid IL or missing references)
            //IL_0071: Unknown result type (might be due to invalid IL or missing references)
            //IL_0073: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            LTDescr.val = newVect.x;
            Mesh mesh = ((Component)trans).GetComponent<MeshFilter>().mesh;
            Vector3[] vertices = mesh.vertices;
            Color32[] array = (Color32[])(object)new Color32[vertices.Length];
            if (array.Length == 0)
            {
                Color32 val = new(byte.MaxValue, byte.MaxValue, byte.MaxValue, (byte)0);
                array = (Color32[])(object)new Color32[mesh.vertices.Length];
                for (int i = 0; i < array.Length; i++)
                {
                    array[i] = val;
                }
                mesh.colors32 = array;
            }
            Color32 val2 = mesh.colors32[0];
            val2 = (new Color((float)(int)val2.r, (float)(int)val2.g, (float)(int)val2.b, LTDescr.val));
            for (int j = 0; j < vertices.Length; j++)
            {
                array[j] = val2;
            }
            mesh.colors32 = array;
        };
        return this;
    }

    public LTDescr setColor()
    {
        type = TweenAction.COLOR;
        initInternal = delegate
        {
            //IL_0017: Unknown result type (might be due to invalid IL or missing references)
            //IL_0062: Unknown result type (might be due to invalid IL or missing references)
            //IL_0067: Unknown result type (might be due to invalid IL or missing references)
            //IL_0069: Unknown result type (might be due to invalid IL or missing references)
            //IL_00b5: Unknown result type (might be due to invalid IL or missing references)
            //IL_00ba: Unknown result type (might be due to invalid IL or missing references)
            //IL_00bc: Unknown result type (might be due to invalid IL or missing references)
            //IL_00e6: Unknown result type (might be due to invalid IL or missing references)
            //IL_00ed: Expected O, but got Unknown
            //IL_0112: Unknown result type (might be due to invalid IL or missing references)
            //IL_0117: Unknown result type (might be due to invalid IL or missing references)
            //IL_011a: Unknown result type (might be due to invalid IL or missing references)
            SpriteRenderer component = ((Component)trans).GetComponent<SpriteRenderer>();
            if (component != null)
            {
                setFromColor(component.color);
            }
            else if (((Component)trans).GetComponent<Renderer>() != null && ((Component)trans).GetComponent<Renderer>().material.HasProperty("_Color"))
            {
                Color color = ((Component)trans).GetComponent<Renderer>().material.color;
                setFromColor(color);
            }
            else if (((Component)trans).GetComponent<Renderer>() != null && ((Component)trans).GetComponent<Renderer>().material.HasProperty("_TintColor"))
            {
                Color color2 = ((Component)trans).GetComponent<Renderer>().material.GetColor("_TintColor");
                setFromColor(color2);
            }
            else if (trans.childCount > 0)
            {
                foreach (Transform tran in trans)
                {
                    Transform val2 = tran;
                    if (((Component)val2).gameObject.GetComponent<Renderer>() != null)
                    {
                        Color color3 = ((Component)val2).gameObject.GetComponent<Renderer>().material.color;
                        setFromColor(color3);
                        break;
                    }
                }
            }
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0025: Unknown result type (might be due to invalid IL or missing references)
            //IL_002a: Unknown result type (might be due to invalid IL or missing references)
            //IL_003f: Unknown result type (might be due to invalid IL or missing references)
            //IL_004b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0063: Unknown result type (might be due to invalid IL or missing references)
            //IL_0093: Unknown result type (might be due to invalid IL or missing references)
            //IL_00be: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            LTDescr.val = newVect.x;
            Color val = tweenColor(this, LTDescr.val);
            if (spriteRen != null)
            {
                spriteRen.color = val;
                colorRecursiveSprite(trans, val);
            }
            else if (type == TweenAction.COLOR)
            {
                colorRecursive(trans, val, useRecursion);
            }
            if (dt != 0f && _optional.onUpdateColor != null)
            {
                _optional.onUpdateColor(val);
            }
            else if (dt != 0f && _optional.onUpdateColorObject != null)
            {
                _optional.onUpdateColorObject(val, _optional.onUpdateParam);
            }
        };
        return this;
    }

    public LTDescr setCallbackColor()
    {
        type = TweenAction.CALLBACK_COLOR;
        initInternal = delegate
        {
            //IL_0010: Unknown result type (might be due to invalid IL or missing references)
            //IL_0015: Unknown result type (might be due to invalid IL or missing references)
            diff = new Vector3(1f, 0f, 0f);
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0025: Unknown result type (might be due to invalid IL or missing references)
            //IL_002a: Unknown result type (might be due to invalid IL or missing references)
            //IL_003f: Unknown result type (might be due to invalid IL or missing references)
            //IL_004b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0063: Unknown result type (might be due to invalid IL or missing references)
            //IL_0093: Unknown result type (might be due to invalid IL or missing references)
            //IL_00be: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            LTDescr.val = newVect.x;
            Color val = tweenColor(this, LTDescr.val);
            if (spriteRen != null)
            {
                spriteRen.color = val;
                colorRecursiveSprite(trans, val);
            }
            else if (type == TweenAction.COLOR)
            {
                colorRecursive(trans, val, useRecursion);
            }
            if (dt != 0f && _optional.onUpdateColor != null)
            {
                _optional.onUpdateColor(val);
            }
            else if (dt != 0f && _optional.onUpdateColorObject != null)
            {
                _optional.onUpdateColorObject(val, _optional.onUpdateParam);
            }
        };
        return this;
    }

    public LTDescr setTextColor()
    {
        type = TweenAction.TEXT_COLOR;
        initInternal = delegate
        {
            //IL_002d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0020: Unknown result type (might be due to invalid IL or missing references)
            uiText = ((Component)trans).GetComponent<Text>();
            setFromColor((uiText != null) ? ((Graphic)uiText).color : Color.white);
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0025: Unknown result type (might be due to invalid IL or missing references)
            //IL_002a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0031: Unknown result type (might be due to invalid IL or missing references)
            //IL_005b: Unknown result type (might be due to invalid IL or missing references)
            //IL_007d: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            LTDescr.val = newVect.x;
            Color val = tweenColor(this, LTDescr.val);
            ((Graphic)uiText).color = val;
            if (dt != 0f && _optional.onUpdateColor != null)
            {
                _optional.onUpdateColor(val);
            }
            if (useRecursion && trans.childCount > 0)
            {
                textColorRecursive(trans, val);
            }
        };
        return this;
    }

    public LTDescr setCanvasAlpha()
    {
        type = TweenAction.CANVAS_ALPHA;
        initInternal = delegate
        {
            //IL_002b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0066: Unknown result type (might be due to invalid IL or missing references)
            uiImage = ((Component)trans).GetComponent<Image>();
            if (uiImage != null)
            {
                fromInternal.x = ((Graphic)uiImage).color.a;
            }
            else
            {
                rawImage = ((Component)trans).GetComponent<RawImage>();
                if (rawImage != null)
                {
                    fromInternal.x = ((Graphic)rawImage).color.a;
                }
                else
                {
                    fromInternal.x = 1f;
                }
            }
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0033: Unknown result type (might be due to invalid IL or missing references)
            //IL_0038: Unknown result type (might be due to invalid IL or missing references)
            //IL_004b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0067: Unknown result type (might be due to invalid IL or missing references)
            //IL_006c: Unknown result type (might be due to invalid IL or missing references)
            //IL_007f: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            val = newVect.x;
            if (uiImage != null)
            {
                Color color = ((Graphic)uiImage).color;
                color.a = val;
                ((Graphic)uiImage).color = color;
            }
            else if (rawImage != null)
            {
                Color color2 = ((Graphic)rawImage).color;
                color2.a = val;
                ((Graphic)rawImage).color = color2;
            }
            if (useRecursion)
            {
                alphaRecursive(rectTransform, val);
                textAlphaChildrenRecursive((Transform)(object)rectTransform, val);
            }
        };
        return this;
    }

    public LTDescr setCanvasGroupAlpha()
    {
        type = TweenAction.CANVASGROUP_ALPHA;
        initInternal = delegate
        {
            fromInternal.x = ((Component)trans).GetComponent<CanvasGroup>().alpha;
        };
        easeInternal = delegate
        {
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            ((Component)trans).GetComponent<CanvasGroup>().alpha = easeMethod().x;
        };
        return this;
    }

    public LTDescr setCanvasColor()
    {
        type = TweenAction.CANVAS_COLOR;
        initInternal = delegate
        {
            //IL_005f: Unknown result type (might be due to invalid IL or missing references)
            //IL_004c: Unknown result type (might be due to invalid IL or missing references)
            //IL_003f: Unknown result type (might be due to invalid IL or missing references)
            uiImage = ((Component)trans).GetComponent<Image>();
            if (uiImage == null)
            {
                rawImage = ((Component)trans).GetComponent<RawImage>();
                setFromColor((rawImage != null) ? ((Graphic)rawImage).color : Color.white);
            }
            else
            {
                setFromColor(((Graphic)uiImage).color);
            }
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0025: Unknown result type (might be due to invalid IL or missing references)
            //IL_002a: Unknown result type (might be due to invalid IL or missing references)
            //IL_003f: Unknown result type (might be due to invalid IL or missing references)
            //IL_005b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0099: Unknown result type (might be due to invalid IL or missing references)
            //IL_0085: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            LTDescr.val = newVect.x;
            Color val = tweenColor(this, LTDescr.val);
            if (uiImage != null)
            {
                ((Graphic)uiImage).color = val;
            }
            else if (rawImage != null)
            {
                ((Graphic)rawImage).color = val;
            }
            if (dt != 0f && _optional.onUpdateColor != null)
            {
                _optional.onUpdateColor(val);
            }
            if (useRecursion)
            {
                colorRecursive(rectTransform, val);
            }
        };
        return this;
    }

    public LTDescr setCanvasMoveX()
    {
        type = TweenAction.CANVAS_MOVE_X;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = rectTransform.anchoredPosition3D.x;
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0018: Unknown result type (might be due to invalid IL or missing references)
            //IL_0022: Unknown result type (might be due to invalid IL or missing references)
            //IL_0028: Unknown result type (might be due to invalid IL or missing references)
            //IL_002e: Unknown result type (might be due to invalid IL or missing references)
            Vector3 anchoredPosition3D = rectTransform.anchoredPosition3D;
            rectTransform.anchoredPosition3D = new Vector3(easeMethod().x, anchoredPosition3D.y, anchoredPosition3D.z);
        };
        return this;
    }

    public LTDescr setCanvasMoveY()
    {
        type = TweenAction.CANVAS_MOVE_Y;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = rectTransform.anchoredPosition3D.y;
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0012: Unknown result type (might be due to invalid IL or missing references)
            //IL_001e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0028: Unknown result type (might be due to invalid IL or missing references)
            //IL_002e: Unknown result type (might be due to invalid IL or missing references)
            Vector3 anchoredPosition3D = rectTransform.anchoredPosition3D;
            rectTransform.anchoredPosition3D = new Vector3(anchoredPosition3D.x, easeMethod().x, anchoredPosition3D.z);
        };
        return this;
    }

    public LTDescr setCanvasMoveZ()
    {
        type = TweenAction.CANVAS_MOVE_Z;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal.x = rectTransform.anchoredPosition3D.z;
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0012: Unknown result type (might be due to invalid IL or missing references)
            //IL_0018: Unknown result type (might be due to invalid IL or missing references)
            //IL_0024: Unknown result type (might be due to invalid IL or missing references)
            //IL_002e: Unknown result type (might be due to invalid IL or missing references)
            Vector3 anchoredPosition3D = rectTransform.anchoredPosition3D;
            rectTransform.anchoredPosition3D = new Vector3(anchoredPosition3D.x, anchoredPosition3D.y, easeMethod().x);
        };
        return this;
    }

    public void initCanvasRotateAround()
    {
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        lastVal = 0f;
        fromInternal.x = 0f;
        _optional.origRotation = ((Transform)rectTransform).rotation;
    }

    public LTDescr setCanvasRotateAround()
    {
        type = TweenAction.CANVAS_ROTATEAROUND;
        initInternal = initCanvasRotateAround;
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0027: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0035: Unknown result type (might be due to invalid IL or missing references)
            //IL_003a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0045: Unknown result type (might be due to invalid IL or missing references)
            //IL_0055: Unknown result type (might be due to invalid IL or missing references)
            //IL_0057: Unknown result type (might be due to invalid IL or missing references)
            //IL_005c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0061: Unknown result type (might be due to invalid IL or missing references)
            //IL_0063: Unknown result type (might be due to invalid IL or missing references)
            //IL_0064: Unknown result type (might be due to invalid IL or missing references)
            //IL_0065: Unknown result type (might be due to invalid IL or missing references)
            //IL_0076: Unknown result type (might be due to invalid IL or missing references)
            //IL_0088: Unknown result type (might be due to invalid IL or missing references)
            //IL_008d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0098: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            LTDescr.val = newVect.x;
            RectTransform val = rectTransform;
            Vector3 localPosition = ((Transform)val).localPosition;
            ((Transform)val).RotateAround(((Transform)val).TransformPoint(_optional.point), _optional.axis, 0f - LTDescr.val);
            Vector3 val2 = localPosition - ((Transform)val).localPosition;
            ((Transform)val).localPosition = localPosition - val2;
            ((Transform)val).rotation = _optional.origRotation;
            ((Transform)val).RotateAround(((Transform)val).TransformPoint(_optional.point), _optional.axis, LTDescr.val);
        };
        return this;
    }

    public LTDescr setCanvasRotateAroundLocal()
    {
        type = TweenAction.CANVAS_ROTATEAROUND_LOCAL;
        initInternal = initCanvasRotateAround;
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0027: Unknown result type (might be due to invalid IL or missing references)
            //IL_002c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0035: Unknown result type (might be due to invalid IL or missing references)
            //IL_003a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0046: Unknown result type (might be due to invalid IL or missing references)
            //IL_004b: Unknown result type (might be due to invalid IL or missing references)
            //IL_005b: Unknown result type (might be due to invalid IL or missing references)
            //IL_005d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0062: Unknown result type (might be due to invalid IL or missing references)
            //IL_0067: Unknown result type (might be due to invalid IL or missing references)
            //IL_0069: Unknown result type (might be due to invalid IL or missing references)
            //IL_006a: Unknown result type (might be due to invalid IL or missing references)
            //IL_006b: Unknown result type (might be due to invalid IL or missing references)
            //IL_007c: Unknown result type (might be due to invalid IL or missing references)
            //IL_008e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0093: Unknown result type (might be due to invalid IL or missing references)
            //IL_009f: Unknown result type (might be due to invalid IL or missing references)
            //IL_00a4: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            LTDescr.val = newVect.x;
            RectTransform val = rectTransform;
            Vector3 localPosition = ((Transform)val).localPosition;
            ((Transform)val).RotateAround(((Transform)val).TransformPoint(_optional.point), ((Transform)val).TransformDirection(_optional.axis), 0f - LTDescr.val);
            Vector3 val2 = localPosition - ((Transform)val).localPosition;
            ((Transform)val).localPosition = localPosition - val2;
            ((Transform)val).rotation = _optional.origRotation;
            ((Transform)val).RotateAround(((Transform)val).TransformPoint(_optional.point), ((Transform)val).TransformDirection(_optional.axis), LTDescr.val);
        };
        return this;
    }

    public LTDescr setCanvasPlaySprite()
    {
        type = TweenAction.CANVAS_PLAYSPRITE;
        initInternal = delegate
        {
            uiImage = ((Component)trans).GetComponent<Image>();
            fromInternal.x = 0f;
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            val = newVect.x;
            int num = (int)Mathf.Round(val);
            uiImage.sprite = sprites[num];
        };
        return this;
    }

    public LTDescr setCanvasMove()
    {
        type = TweenAction.CANVAS_MOVE;
        initInternal = delegate
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            fromInternal = rectTransform.anchoredPosition3D;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            rectTransform.anchoredPosition3D = easeMethod();
        };
        return this;
    }

    public LTDescr setCanvasScale()
    {
        type = TweenAction.CANVAS_SCALE;
        initInternal = delegate
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            from = ((Transform)rectTransform).localScale;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            ((Transform)rectTransform).localScale = easeMethod();
        };
        return this;
    }

    public LTDescr setCanvasSizeDelta()
    {
        type = TweenAction.CANVAS_SIZEDELTA;
        initInternal = delegate
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            from = (rectTransform.sizeDelta);
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            rectTransform.sizeDelta = (easeMethod());
        };
        return this;
    }

    public void callback()
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_000b: Unknown result type (might be due to invalid IL or missing references)
        newVect = easeMethod();
        val = newVect.x;
    }

    public LTDescr setCallback()
    {
        type = TweenAction.CALLBACK;
        initInternal = delegate
        {
        };
        easeInternal = callback;
        return this;
    }

    public LTDescr setValue3()
    {
        type = TweenAction.VALUE3;
        initInternal = delegate
        {
        };
        easeInternal = callback;
        return this;
    }

    public LTDescr setMove()
    {
        type = TweenAction.MOVE;
        initInternal = delegate
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            from = trans.position;
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            trans.position = newVect;
        };
        return this;
    }

    public LTDescr setMoveLocal()
    {
        type = TweenAction.MOVE_LOCAL;
        initInternal = delegate
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            from = trans.localPosition;
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            trans.localPosition = newVect;
        };
        return this;
    }

    public LTDescr setMoveToTransform()
    {
        type = TweenAction.MOVE_TO_TRANSFORM;
        initInternal = delegate
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            from = trans.position;
        };
        easeInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0018: Unknown result type (might be due to invalid IL or missing references)
            //IL_001e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0023: Unknown result type (might be due to invalid IL or missing references)
            //IL_0028: Unknown result type (might be due to invalid IL or missing references)
            //IL_002f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0039: Unknown result type (might be due to invalid IL or missing references)
            //IL_003e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0049: Unknown result type (might be due to invalid IL or missing references)
            //IL_004e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0059: Unknown result type (might be due to invalid IL or missing references)
            to = _optional.toTrans.position;
            diff = to - from;
            diffDiv2 = diff * 0.5f;
            newVect = easeMethod();
            trans.position = newVect;
        };
        return this;
    }

    public LTDescr setRotate()
    {
        type = TweenAction.ROTATE;
        initInternal = delegate
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_002e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0039: Unknown result type (might be due to invalid IL or missing references)
            //IL_0049: Unknown result type (might be due to invalid IL or missing references)
            //IL_0054: Unknown result type (might be due to invalid IL or missing references)
            //IL_0063: Unknown result type (might be due to invalid IL or missing references)
            from = trans.eulerAngles;
            to = new Vector3(LeanTween.closestRot(fromInternal.x, toInternal.x), LeanTween.closestRot(from.y, to.y), LeanTween.closestRot(from.z, to.z));
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            trans.eulerAngles = newVect;
        };
        return this;
    }

    public LTDescr setRotateLocal()
    {
        type = TweenAction.ROTATE_LOCAL;
        initInternal = delegate
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_002e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0039: Unknown result type (might be due to invalid IL or missing references)
            //IL_0049: Unknown result type (might be due to invalid IL or missing references)
            //IL_0054: Unknown result type (might be due to invalid IL or missing references)
            //IL_0063: Unknown result type (might be due to invalid IL or missing references)
            from = trans.localEulerAngles;
            to = new Vector3(LeanTween.closestRot(fromInternal.x, toInternal.x), LeanTween.closestRot(from.y, to.y), LeanTween.closestRot(from.z, to.z));
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            trans.localEulerAngles = newVect;
        };
        return this;
    }

    public LTDescr setScale()
    {
        type = TweenAction.SCALE;
        initInternal = delegate
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            from = trans.localScale;
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0016: Unknown result type (might be due to invalid IL or missing references)
            newVect = easeMethod();
            trans.localScale = newVect;
        };
        return this;
    }

    public LTDescr setGUIMove()
    {
        type = TweenAction.GUI_MOVE;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            //IL_0024: Unknown result type (might be due to invalid IL or missing references)
            //IL_0029: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            Rect rect2 = _optional.ltRect.rect;
            float x2 = ((rect2)).x;
            rect2 = _optional.ltRect.rect;
            from = new Vector3(x2, ((rect2)).y, 0f);
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0017: Unknown result type (might be due to invalid IL or missing references)
            //IL_001d: Unknown result type (might be due to invalid IL or missing references)
            //IL_002e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0033: Unknown result type (might be due to invalid IL or missing references)
            //IL_0046: Unknown result type (might be due to invalid IL or missing references)
            //IL_004b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0053: Unknown result type (might be due to invalid IL or missing references)
            Vector3 val = easeMethod();
            LTRect ltRect = _optional.ltRect;
            float x = val.x;
            float y = val.y;
            Rect rect = _optional.ltRect.rect;
            float width = ((rect)).width;
            rect = _optional.ltRect.rect;
            ltRect.rect = new Rect(x, y, width, ((rect)).height);
        };
        return this;
    }

    public LTDescr setGUIMoveMargin()
    {
        type = TweenAction.GUI_MOVE_MARGIN;
        initInternal = delegate
        {
            //IL_002b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0030: Unknown result type (might be due to invalid IL or missing references)
            from = (new Vector2(_optional.ltRect.margin.x, _optional.ltRect.margin.y));
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0017: Unknown result type (might be due to invalid IL or missing references)
            //IL_001d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0023: Unknown result type (might be due to invalid IL or missing references)
            //IL_0028: Unknown result type (might be due to invalid IL or missing references)
            Vector3 val = easeMethod();
            _optional.ltRect.margin = new Vector2(val.x, val.y);
        };
        return this;
    }

    public LTDescr setGUIScale()
    {
        type = TweenAction.GUI_SCALE;
        initInternal = delegate
        {
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            //IL_0024: Unknown result type (might be due to invalid IL or missing references)
            //IL_0029: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            Rect rect2 = _optional.ltRect.rect;
            float width = ((rect2)).width;
            rect2 = _optional.ltRect.rect;
            from = new Vector3(width, ((rect2)).height, 0f);
        };
        easeInternal = delegate
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0022: Unknown result type (might be due to invalid IL or missing references)
            //IL_0027: Unknown result type (might be due to invalid IL or missing references)
            //IL_003a: Unknown result type (might be due to invalid IL or missing references)
            //IL_003f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0047: Unknown result type (might be due to invalid IL or missing references)
            //IL_004d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0053: Unknown result type (might be due to invalid IL or missing references)
            Vector3 val = easeMethod();
            LTRect ltRect = _optional.ltRect;
            Rect rect = _optional.ltRect.rect;
            float x = ((rect)).x;
            rect = _optional.ltRect.rect;
            ltRect.rect = new Rect(x, ((rect)).y, val.x, val.y);
        };
        return this;
    }

    public LTDescr setGUIAlpha()
    {
        type = TweenAction.GUI_ALPHA;
        initInternal = delegate
        {
            fromInternal.x = _optional.ltRect.alpha;
        };
        easeInternal = delegate
        {
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            _optional.ltRect.alpha = easeMethod().x;
        };
        return this;
    }

    public LTDescr setGUIRotate()
    {
        type = TweenAction.GUI_ROTATE;
        initInternal = delegate
        {
            if (!_optional.ltRect.rotateEnabled)
            {
                _optional.ltRect.rotateEnabled = true;
                _optional.ltRect.resetForRotation();
            }
            fromInternal.x = _optional.ltRect.rotation;
        };
        easeInternal = delegate
        {
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            _optional.ltRect.rotation = easeMethod().x;
        };
        return this;
    }

    public LTDescr setDelayedSound()
    {
        type = TweenAction.DELAYED_SOUND;
        initInternal = delegate
        {
            hasExtraOnCompletes = true;
        };
        easeInternal = callback;
        return this;
    }

    public LTDescr setTarget(Transform trans)
    {
        optional.toTrans = trans;
        return this;
    }

    public void init()
    {
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_007e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0085: Unknown result type (might be due to invalid IL or missing references)
        //IL_008f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0094: Unknown result type (might be due to invalid IL or missing references)
        hasInitiliazed = true;
        usesNormalDt = !useEstimatedTime && !useManualTime && !useFrames;
        if (useFrames)
        {
            optional.initFrameCount = Time.frameCount;
        }
        if (time <= 0f)
        {
            time = Mathf.Epsilon;
        }
        if (initInternal != null)
        {
            initInternal();
        }
        diff = to - from;
        diffDiv2 = diff * 0.5f;
        if (_optional.onStart != null)
        {
            _optional.onStart();
        }
        if (onCompleteOnStart)
        {
            callOnCompletes();
        }
        if (speed >= 0f)
        {
            initSpeed();
        }
    }

    public void initSpeed()
    {
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0073: Unknown result type (might be due to invalid IL or missing references)
        if (type == TweenAction.MOVE_CURVED || type == TweenAction.MOVE_CURVED_LOCAL)
        {
            time = _optional.path.distance / speed;
            return;
        }
        if (type == TweenAction.MOVE_SPLINE || type == TweenAction.MOVE_SPLINE_LOCAL)
        {
            time = _optional.spline.distance / speed;
            return;
        }
        Vector3 val = to - from;
        time = ((val)).magnitude / speed;
    }

    public LTDescr updateNow()
    {
        updateInternal();
        return this;
    }

    public bool updateInternal()
    {
        float num = direction;
        if (usesNormalDt)
        {
            dt = LeanTween.dtActual;
        }
        else if (useEstimatedTime)
        {
            dt = LeanTween.dtEstimated;
        }
        else if (useFrames)
        {
            dt = ((optional.initFrameCount != 0) ? 1 : 0);
            optional.initFrameCount = Time.frameCount;
        }
        else if (useManualTime)
        {
            dt = LeanTween.dtManual;
        }
        if (delay <= 0f && num != 0f)
        {
            if (trans == null)
            {
                return true;
            }
            if (!hasInitiliazed)
            {
                init();
            }
            dt *= num;
            passed += dt;
            passed = Mathf.Clamp(passed, 0f, time);
            ratioPassed = passed / time;
            easeInternal();
            if (hasUpdateCallback)
            {
                _optional.callOnUpdate(val, ratioPassed);
            }
            if ((num > 0f) ? (passed >= time) : (passed <= 0f))
            {
                loopCount--;
                if (loopType == LeanTweenType.pingPong)
                {
                    direction = 0f - num;
                }
                else
                {
                    passed = Mathf.Epsilon;
                }
                int num2;
                if (loopCount != 0)
                {
                    num2 = ((loopType == LeanTweenType.once) ? 1 : 0);
                    if (num2 == 0 && onCompleteOnRepeat && hasExtraOnCompletes)
                    {
                        callOnCompletes();
                    }
                }
                else
                {
                    num2 = 1;
                }
                return (byte)num2 != 0;
            }
        }
        else
        {
            delay -= dt;
        }
        return false;
    }

    public void callOnCompletes()
    {
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_003c: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Expected O, but got Unknown
        if (type == TweenAction.GUI_ROTATE)
        {
            _optional.ltRect.rotateFinished = true;
        }
        if (type == TweenAction.DELAYED_SOUND)
        {
            AudioSource.PlayClipAtPoint((AudioClip)_optional.onCompleteParam, to, from.x);
        }
        if (_optional.onComplete != null)
        {
            _optional.onComplete();
        }
        else if (_optional.onCompleteObject != null)
        {
            _optional.onCompleteObject(_optional.onCompleteParam);
        }
    }

    public LTDescr setFromColor(Color col)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0030: Unknown result type (might be due to invalid IL or missing references)
        //IL_003b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_0047: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Unknown result type (might be due to invalid IL or missing references)
        from = new Vector3(0f, col.a, 0f);
        diff = new Vector3(1f, 0f, 0f);
        _optional.axis = new Vector3(col.r, col.g, col.b);
        return this;
    }

    public static void alphaRecursive(Transform transform, float val, bool useRecursion = true)
    {
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_007e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0086: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0094: Unknown result type (might be due to invalid IL or missing references)
        //IL_009c: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d0: Unknown result type (might be due to invalid IL or missing references)
        //IL_00dc: Expected O, but got Unknown
        Renderer component = ((Component)transform).gameObject.GetComponent<Renderer>();
        if (component != null)
        {
            Material[] materials = component.materials;
            foreach (Material val2 in materials)
            {
                if (val2.HasProperty("_Color"))
                {
                    val2.color = new Color(val2.color.r, val2.color.g, val2.color.b, val);
                }
                else if (val2.HasProperty("_TintColor"))
                {
                    Color color = val2.GetColor("_TintColor");
                    val2.SetColor("_TintColor", new Color(color.r, color.g, color.b, val));
                }
            }
        }
        if (!useRecursion || transform.childCount <= 0)
        {
            return;
        }
        foreach (Transform item in transform)
        {
            alphaRecursive(item, val, useRecursion: true);
        }
    }

    public static void colorRecursive(Transform transform, Color toColor, bool useRecursion = true)
    {
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_004e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Expected O, but got Unknown
        Renderer component = ((Component)transform).gameObject.GetComponent<Renderer>();
        if (component != null)
        {
            Material[] materials = component.materials;
            for (int i = 0; i < materials.Length; i++)
            {
                materials[i].color = toColor;
            }
        }
        if (!useRecursion || transform.childCount <= 0)
        {
            return;
        }
        foreach (Transform item in transform)
        {
            colorRecursive(item, toColor, useRecursion: true);
        }
    }

    public static void alphaRecursive(RectTransform rectTransform, float val, int recursiveLevel = 0)
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0021: Expected O, but got Unknown
        //IL_0032: Unknown result type (might be due to invalid IL or missing references)
        //IL_0037: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_005f: Unknown result type (might be due to invalid IL or missing references)
        //IL_006a: Unknown result type (might be due to invalid IL or missing references)
        if (((Transform)rectTransform).childCount <= 0)
        {
            return;
        }
        foreach (RectTransform item in (Transform)rectTransform)
        {
            RectTransform val2 = item;
            MaskableGraphic component = (MaskableGraphic)(object)((Component)val2).GetComponent<Image>();
            if (component != null)
            {
                Color color = ((Graphic)component).color;
                color.a = val;
                ((Graphic)component).color = color;
            }
            else
            {
                component = (MaskableGraphic)(object)((Component)val2).GetComponent<RawImage>();
                if (component != null)
                {
                    Color color2 = ((Graphic)component).color;
                    color2.a = val;
                    ((Graphic)component).color = color2;
                }
            }
            alphaRecursive(val2, val, recursiveLevel + 1);
        }
    }

    public static void alphaRecursiveSprite(Transform transform, float val)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Expected O, but got Unknown
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        if (transform.childCount <= 0)
        {
            return;
        }
        foreach (Transform item in transform)
        {
            SpriteRenderer component = ((Component)item).GetComponent<SpriteRenderer>();
            if (component != null)
            {
                component.color = new Color(component.color.r, component.color.g, component.color.b, val);
            }
            alphaRecursiveSprite(item, val);
        }
    }

    public static void colorRecursiveSprite(Transform transform, Color toColor)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Expected O, but got Unknown
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        if (transform.childCount <= 0)
        {
            return;
        }
        foreach (Transform item in transform)
        {
            SpriteRenderer component = ((Component)transform).gameObject.GetComponent<SpriteRenderer>();
            if (component != null)
            {
                component.color = toColor;
            }
            colorRecursiveSprite(item, toColor);
        }
    }

    public static void colorRecursive(RectTransform rectTransform, Color toColor)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Expected O, but got Unknown
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_004f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        if (((Transform)rectTransform).childCount <= 0)
        {
            return;
        }
        foreach (RectTransform item in (Transform)rectTransform)
        {
            RectTransform val = item;
            MaskableGraphic component = (MaskableGraphic)(object)((Component)val).GetComponent<Image>();
            if (component != null)
            {
                ((Graphic)component).color = toColor;
            }
            else
            {
                component = (MaskableGraphic)(object)((Component)val).GetComponent<RawImage>();
                if (component != null)
                {
                    ((Graphic)component).color = toColor;
                }
            }
            colorRecursive(val, toColor);
        }
    }

    public static void textAlphaChildrenRecursive(Transform trans, float val, bool useRecursion = true)
    {
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Expected O, but got Unknown
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_0040: Unknown result type (might be due to invalid IL or missing references)
        if (!useRecursion || trans.childCount <= 0)
        {
            return;
        }
        foreach (Transform tran in trans)
        {
            Text component = ((Component)tran).GetComponent<Text>();
            if (component != null)
            {
                Color color = ((Graphic)component).color;
                color.a = val;
                ((Graphic)component).color = color;
            }
            textAlphaChildrenRecursive(tran, val);
        }
    }

    public static void textAlphaRecursive(Transform trans, float val, bool useRecursion = true)
    {
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_0020: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_004d: Expected O, but got Unknown
        Text component = ((Component)trans).GetComponent<Text>();
        if (component != null)
        {
            Color color = ((Graphic)component).color;
            color.a = val;
            ((Graphic)component).color = color;
        }
        if (!useRecursion || trans.childCount <= 0)
        {
            return;
        }
        foreach (Transform tran in trans)
        {
            textAlphaRecursive(tran, val);
        }
    }

    public static void textColorRecursive(Transform trans, Color toColor)
    {
        //IL_0018: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Expected O, but got Unknown
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        if (trans.childCount <= 0)
        {
            return;
        }
        foreach (Transform tran in trans)
        {
            Text component = ((Component)tran).GetComponent<Text>();
            if (component != null)
            {
                ((Graphic)component).color = toColor;
            }
            textColorRecursive(tran, toColor);
        }
    }

    public static Color tweenColor(LTDescr tween, float val)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        //IL_0011: Unknown result type (might be due to invalid IL or missing references)
        //IL_0016: Unknown result type (might be due to invalid IL or missing references)
        //IL_001b: Unknown result type (might be due to invalid IL or missing references)
        //IL_001d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        //IL_006c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0076: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_008e: Unknown result type (might be due to invalid IL or missing references)
        Vector3 val2 = tween._optional.point - tween._optional.axis;
        float num = tween.to.y - tween.from.y;
        return new Color(tween._optional.axis.x + val2.x * val, tween._optional.axis.y + val2.y * val, tween._optional.axis.z + val2.z * val, tween.from.y + num * val);
    }

    public LTDescr pause()
    {
        if (direction != 0f)
        {
            directionLast = direction;
            direction = 0f;
        }
        return this;
    }

    public LTDescr resume()
    {
        direction = directionLast;
        return this;
    }

    public LTDescr setAxis(Vector3 axis)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        _optional.axis = axis;
        return this;
    }

    public LTDescr setDelay(float delay)
    {
        this.delay = delay;
        return this;
    }

    public LTDescr setEase(LeanTweenType easeType)
    {
        switch (easeType)
        {
            case LeanTweenType.linear:
                setEaseLinear();
                break;
            case LeanTweenType.easeOutQuad:
                setEaseOutQuad();
                break;
            case LeanTweenType.easeInQuad:
                setEaseInQuad();
                break;
            case LeanTweenType.easeInOutQuad:
                setEaseInOutQuad();
                break;
            case LeanTweenType.easeInCubic:
                setEaseInCubic();
                break;
            case LeanTweenType.easeOutCubic:
                setEaseOutCubic();
                break;
            case LeanTweenType.easeInOutCubic:
                setEaseInOutCubic();
                break;
            case LeanTweenType.easeInQuart:
                setEaseInQuart();
                break;
            case LeanTweenType.easeOutQuart:
                setEaseOutQuart();
                break;
            case LeanTweenType.easeInOutQuart:
                setEaseInOutQuart();
                break;
            case LeanTweenType.easeInQuint:
                setEaseInQuint();
                break;
            case LeanTweenType.easeOutQuint:
                setEaseOutQuint();
                break;
            case LeanTweenType.easeInOutQuint:
                setEaseInOutQuint();
                break;
            case LeanTweenType.easeInSine:
                setEaseInSine();
                break;
            case LeanTweenType.easeOutSine:
                setEaseOutSine();
                break;
            case LeanTweenType.easeInOutSine:
                setEaseInOutSine();
                break;
            case LeanTweenType.easeInExpo:
                setEaseInExpo();
                break;
            case LeanTweenType.easeOutExpo:
                setEaseOutExpo();
                break;
            case LeanTweenType.easeInOutExpo:
                setEaseInOutExpo();
                break;
            case LeanTweenType.easeInCirc:
                setEaseInCirc();
                break;
            case LeanTweenType.easeOutCirc:
                setEaseOutCirc();
                break;
            case LeanTweenType.easeInOutCirc:
                setEaseInOutCirc();
                break;
            case LeanTweenType.easeInBounce:
                setEaseInBounce();
                break;
            case LeanTweenType.easeOutBounce:
                setEaseOutBounce();
                break;
            case LeanTweenType.easeInOutBounce:
                setEaseInOutBounce();
                break;
            case LeanTweenType.easeInBack:
                setEaseInBack();
                break;
            case LeanTweenType.easeOutBack:
                setEaseOutBack();
                break;
            case LeanTweenType.easeInOutBack:
                setEaseInOutBack();
                break;
            case LeanTweenType.easeInElastic:
                setEaseInElastic();
                break;
            case LeanTweenType.easeOutElastic:
                setEaseOutElastic();
                break;
            case LeanTweenType.easeInOutElastic:
                setEaseInOutElastic();
                break;
            case LeanTweenType.punch:
                setEasePunch();
                break;
            case LeanTweenType.easeShake:
                setEaseShake();
                break;
            case LeanTweenType.easeSpring:
                setEaseSpring();
                break;
            default:
                setEaseLinear();
                break;
        }
        return this;
    }

    public LTDescr setEaseLinear()
    {
        easeType = LeanTweenType.linear;
        easeMethod = easeLinear;
        return this;
    }

    public LTDescr setEaseSpring()
    {
        easeType = LeanTweenType.easeSpring;
        easeMethod = easeSpring;
        return this;
    }

    public LTDescr setEaseInQuad()
    {
        easeType = LeanTweenType.easeInQuad;
        easeMethod = easeInQuad;
        return this;
    }

    public LTDescr setEaseOutQuad()
    {
        easeType = LeanTweenType.easeOutQuad;
        easeMethod = easeOutQuad;
        return this;
    }

    public LTDescr setEaseInOutQuad()
    {
        easeType = LeanTweenType.easeInOutQuad;
        easeMethod = easeInOutQuad;
        return this;
    }

    public LTDescr setEaseInCubic()
    {
        easeType = LeanTweenType.easeInCubic;
        easeMethod = easeInCubic;
        return this;
    }

    public LTDescr setEaseOutCubic()
    {
        easeType = LeanTweenType.easeOutCubic;
        easeMethod = easeOutCubic;
        return this;
    }

    public LTDescr setEaseInOutCubic()
    {
        easeType = LeanTweenType.easeInOutCubic;
        easeMethod = easeInOutCubic;
        return this;
    }

    public LTDescr setEaseInQuart()
    {
        easeType = LeanTweenType.easeInQuart;
        easeMethod = easeInQuart;
        return this;
    }

    public LTDescr setEaseOutQuart()
    {
        easeType = LeanTweenType.easeOutQuart;
        easeMethod = easeOutQuart;
        return this;
    }

    public LTDescr setEaseInOutQuart()
    {
        easeType = LeanTweenType.easeInOutQuart;
        easeMethod = easeInOutQuart;
        return this;
    }

    public LTDescr setEaseInQuint()
    {
        easeType = LeanTweenType.easeInQuint;
        easeMethod = easeInQuint;
        return this;
    }

    public LTDescr setEaseOutQuint()
    {
        easeType = LeanTweenType.easeOutQuint;
        easeMethod = easeOutQuint;
        return this;
    }

    public LTDescr setEaseInOutQuint()
    {
        easeType = LeanTweenType.easeInOutQuint;
        easeMethod = easeInOutQuint;
        return this;
    }

    public LTDescr setEaseInSine()
    {
        easeType = LeanTweenType.easeInSine;
        easeMethod = easeInSine;
        return this;
    }

    public LTDescr setEaseOutSine()
    {
        easeType = LeanTweenType.easeOutSine;
        easeMethod = easeOutSine;
        return this;
    }

    public LTDescr setEaseInOutSine()
    {
        easeType = LeanTweenType.easeInOutSine;
        easeMethod = easeInOutSine;
        return this;
    }

    public LTDescr setEaseInExpo()
    {
        easeType = LeanTweenType.easeInExpo;
        easeMethod = easeInExpo;
        return this;
    }

    public LTDescr setEaseOutExpo()
    {
        easeType = LeanTweenType.easeOutExpo;
        easeMethod = easeOutExpo;
        return this;
    }

    public LTDescr setEaseInOutExpo()
    {
        easeType = LeanTweenType.easeInOutExpo;
        easeMethod = easeInOutExpo;
        return this;
    }

    public LTDescr setEaseInCirc()
    {
        easeType = LeanTweenType.easeInCirc;
        easeMethod = easeInCirc;
        return this;
    }

    public LTDescr setEaseOutCirc()
    {
        easeType = LeanTweenType.easeOutCirc;
        easeMethod = easeOutCirc;
        return this;
    }

    public LTDescr setEaseInOutCirc()
    {
        easeType = LeanTweenType.easeInOutCirc;
        easeMethod = easeInOutCirc;
        return this;
    }

    public LTDescr setEaseInBounce()
    {
        easeType = LeanTweenType.easeInBounce;
        easeMethod = easeInBounce;
        return this;
    }

    public LTDescr setEaseOutBounce()
    {
        easeType = LeanTweenType.easeOutBounce;
        easeMethod = easeOutBounce;
        return this;
    }

    public LTDescr setEaseInOutBounce()
    {
        easeType = LeanTweenType.easeInOutBounce;
        easeMethod = easeInOutBounce;
        return this;
    }

    public LTDescr setEaseInBack()
    {
        easeType = LeanTweenType.easeInBack;
        easeMethod = easeInBack;
        return this;
    }

    public LTDescr setEaseOutBack()
    {
        easeType = LeanTweenType.easeOutBack;
        easeMethod = easeOutBack;
        return this;
    }

    public LTDescr setEaseInOutBack()
    {
        easeType = LeanTweenType.easeInOutBack;
        easeMethod = easeInOutBack;
        return this;
    }

    public LTDescr setEaseInElastic()
    {
        easeType = LeanTweenType.easeInElastic;
        easeMethod = easeInElastic;
        return this;
    }

    public LTDescr setEaseOutElastic()
    {
        easeType = LeanTweenType.easeOutElastic;
        easeMethod = easeOutElastic;
        return this;
    }

    public LTDescr setEaseInOutElastic()
    {
        easeType = LeanTweenType.easeInOutElastic;
        easeMethod = easeInOutElastic;
        return this;
    }

    public LTDescr setEasePunch()
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        _optional.animationCurve = LeanTween.punch;
        toInternal.x = from.x + to.x;
        easeMethod = tweenOnCurve;
        return this;
    }

    public LTDescr setEaseShake()
    {
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        _optional.animationCurve = LeanTween.shake;
        toInternal.x = from.x + to.x;
        easeMethod = tweenOnCurve;
        return this;
    }

    public Vector3 tweenOnCurve()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_005d: Unknown result type (might be due to invalid IL or missing references)
        //IL_008a: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(from.x + diff.x * _optional.animationCurve.Evaluate(ratioPassed), from.y + diff.y * _optional.animationCurve.Evaluate(ratioPassed), from.z + diff.z * _optional.animationCurve.Evaluate(ratioPassed));
    }

    public Vector3 easeInOutQuad()
    {
        //IL_00be: Unknown result type (might be due to invalid IL or missing references)
        //IL_00db: Unknown result type (might be due to invalid IL or missing references)
        //IL_00f8: Unknown result type (might be due to invalid IL or missing references)
        //IL_0103: Unknown result type (might be due to invalid IL or missing references)
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed * 2f;
        if (val < 1f)
        {
            val *= val;
            return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
        }
        val = (1f - val) * (val - 3f) + 1f;
        return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
    }

    public Vector3 easeInQuad()
    {
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed * ratioPassed;
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeOutQuad()
    {
        //IL_0023: Unknown result type (might be due to invalid IL or missing references)
        //IL_002d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0038: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed;
        val = (0f - val) * (val - 2f);
        return diff * val + from;
    }

    public Vector3 easeLinear()
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed;
        return new Vector3(from.x + diff.x * val, from.y + diff.y * val, from.z + diff.z * val);
    }

    public Vector3 easeSpring()
    {
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        //IL_007e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0088: Unknown result type (might be due to invalid IL or missing references)
        //IL_008d: Unknown result type (might be due to invalid IL or missing references)
        val = Mathf.Clamp01(ratioPassed);
        val = (Mathf.Sin(val * (float)Math.PI * (0.2f + 2.5f * val * val * val)) * Mathf.Pow(1f - val, 2.2f) + val) * (1f + 1.2f * (1f - val));
        return from + diff * val;
    }

    public Vector3 easeInCubic()
    {
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0048: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed * ratioPassed * ratioPassed;
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeOutCubic()
    {
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed - 1f;
        val = val * val * val + 1f;
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeInOutCubic()
    {
        //IL_00ce: Unknown result type (might be due to invalid IL or missing references)
        //IL_00eb: Unknown result type (might be due to invalid IL or missing references)
        //IL_0108: Unknown result type (might be due to invalid IL or missing references)
        //IL_0113: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_007f: Unknown result type (might be due to invalid IL or missing references)
        //IL_008a: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed * 2f;
        if (val < 1f)
        {
            val = val * val * val;
            return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
        }
        val -= 2f;
        val = val * val * val + 2f;
        return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
    }

    public Vector3 easeInQuart()
    {
        //IL_0021: Unknown result type (might be due to invalid IL or missing references)
        //IL_002b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0031: Unknown result type (might be due to invalid IL or missing references)
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed * ratioPassed * ratioPassed * ratioPassed;
        return diff * val + from;
    }

    public Vector3 easeOutQuart()
    {
        //IL_0046: Unknown result type (might be due to invalid IL or missing references)
        //IL_0063: Unknown result type (might be due to invalid IL or missing references)
        //IL_0080: Unknown result type (might be due to invalid IL or missing references)
        //IL_008b: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed - 1f;
        val = 0f - (val * val * val * val - 1f);
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeInOutQuart()
    {
        //IL_00a7: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ac: Unknown result type (might be due to invalid IL or missing references)
        //IL_00ce: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d4: Unknown result type (might be due to invalid IL or missing references)
        //IL_00d9: Unknown result type (might be due to invalid IL or missing references)
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_0085: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed * 2f;
        if (val < 1f)
        {
            val = val * val * val * val;
            return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
        }
        val -= 2f;
        return -diffDiv2 * (val * val * val * val - 2f) + from;
    }

    public Vector3 easeInQuint()
    {
        //IL_003f: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        //IL_0084: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed;
        val = val * val * val * val * val;
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeOutQuint()
    {
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0068: Unknown result type (might be due to invalid IL or missing references)
        //IL_0085: Unknown result type (might be due to invalid IL or missing references)
        //IL_0090: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed - 1f;
        val = val * val * val * val * val + 1f;
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeInOutQuint()
    {
        //IL_00e6: Unknown result type (might be due to invalid IL or missing references)
        //IL_0103: Unknown result type (might be due to invalid IL or missing references)
        //IL_0120: Unknown result type (might be due to invalid IL or missing references)
        //IL_012b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_008b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0096: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed * 2f;
        if (val < 1f)
        {
            val = val * val * val * val * val;
            return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
        }
        val -= 2f;
        val = val * val * val * val * val + 2f;
        return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
    }

    public Vector3 easeInSine()
    {
        //IL_0035: Unknown result type (might be due to invalid IL or missing references)
        //IL_005e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        //IL_0092: Unknown result type (might be due to invalid IL or missing references)
        val = 0f - Mathf.Cos(ratioPassed * LeanTween.PI_DIV2);
        return new Vector3(diff.x * val + diff.x + from.x, diff.y * val + diff.y + from.y, diff.z * val + diff.z + from.z);
    }

    public Vector3 easeOutSine()
    {
        //IL_0028: Unknown result type (might be due to invalid IL or missing references)
        //IL_0045: Unknown result type (might be due to invalid IL or missing references)
        //IL_0062: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        val = Mathf.Sin(ratioPassed * LeanTween.PI_DIV2);
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeInOutSine()
    {
        //IL_002f: Unknown result type (might be due to invalid IL or missing references)
        //IL_004c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0069: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        val = 0f - (Mathf.Cos((float)Math.PI * ratioPassed) - 1f);
        return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
    }

    public Vector3 easeInExpo()
    {
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_0050: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        val = Mathf.Pow(2f, 10f * (ratioPassed - 1f));
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeOutExpo()
    {
        //IL_0034: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0079: Unknown result type (might be due to invalid IL or missing references)
        val = 0f - Mathf.Pow(2f, -10f * ratioPassed) + 1f;
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeInOutExpo()
    {
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0081: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        //IL_008c: Unknown result type (might be due to invalid IL or missing references)
        //IL_001e: Unknown result type (might be due to invalid IL or missing references)
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0044: Unknown result type (might be due to invalid IL or missing references)
        //IL_0049: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed * 2f;
        if (val < 1f)
        {
            return diffDiv2 * Mathf.Pow(2f, 10f * (val - 1f)) + from;
        }
        val -= 1f;
        return diffDiv2 * (0f - Mathf.Pow(2f, -10f * val) + 2f) + from;
    }

    public Vector3 easeInCirc()
    {
        //IL_0036: Unknown result type (might be due to invalid IL or missing references)
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0070: Unknown result type (might be due to invalid IL or missing references)
        //IL_007b: Unknown result type (might be due to invalid IL or missing references)
        val = 0f - (Mathf.Sqrt(1f - ratioPassed * ratioPassed) - 1f);
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeOutCirc()
    {
        //IL_003e: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0078: Unknown result type (might be due to invalid IL or missing references)
        //IL_0083: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed - 1f;
        val = Mathf.Sqrt(1f - val * val);
        return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
    }

    public Vector3 easeInOutCirc()
    {
        //IL_00df: Unknown result type (might be due to invalid IL or missing references)
        //IL_00fc: Unknown result type (might be due to invalid IL or missing references)
        //IL_0119: Unknown result type (might be due to invalid IL or missing references)
        //IL_0124: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_006e: Unknown result type (might be due to invalid IL or missing references)
        //IL_008b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0096: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed * 2f;
        if (val < 1f)
        {
            val = 0f - (Mathf.Sqrt(1f - val * val) - 1f);
            return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
        }
        val -= 2f;
        val = Mathf.Sqrt(1f - val * val) + 1f;
        return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
    }

    public Vector3 easeInBounce()
    {
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        //IL_0074: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a6: Unknown result type (might be due to invalid IL or missing references)
        //IL_00b1: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed;
        val = 1f - val;
        return new Vector3(diff.x - LeanTween.easeOutBounce(0f, diff.x, val) + from.x, diff.y - LeanTween.easeOutBounce(0f, diff.y, val) + from.y, diff.z - LeanTween.easeOutBounce(0f, diff.z, val) + from.z);
    }

    public Vector3 easeOutBounce()
    {
        //IL_0165: Unknown result type (might be due to invalid IL or missing references)
        //IL_016f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0175: Unknown result type (might be due to invalid IL or missing references)
        //IL_017a: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed;
        float num2;
        float num;
        if (val < (num = 1f - 1.75f * overshoot / 2.75f))
        {
            val = 1f / num / num * val * val;
        }
        else if (val < (num2 = 1f - 0.75f * overshoot / 2.75f))
        {
            val -= (num + num2) / 2f;
            val = 7.5625f * val * val + 1f - 0.25f * overshoot * overshoot;
        }
        else if (val < (num = 1f - 0.25f * overshoot / 2.75f))
        {
            val -= (num + num2) / 2f;
            val = 7.5625f * val * val + 1f - 0.0625f * overshoot * overshoot;
        }
        else
        {
            val -= (num + 1f) / 2f;
            val = 7.5625f * val * val + 1f - 1f / 64f * overshoot * overshoot;
        }
        return diff * val + from;
    }

    public Vector3 easeInOutBounce()
    {
        //IL_00e7: Unknown result type (might be due to invalid IL or missing references)
        //IL_011f: Unknown result type (might be due to invalid IL or missing references)
        //IL_0157: Unknown result type (might be due to invalid IL or missing references)
        //IL_0162: Unknown result type (might be due to invalid IL or missing references)
        //IL_0041: Unknown result type (might be due to invalid IL or missing references)
        //IL_006d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0099: Unknown result type (might be due to invalid IL or missing references)
        //IL_00a4: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed * 2f;
        if (val < 1f)
        {
            return new Vector3(LeanTween.easeInBounce(0f, diff.x, val) * 0.5f + from.x, LeanTween.easeInBounce(0f, diff.y, val) * 0.5f + from.y, LeanTween.easeInBounce(0f, diff.z, val) * 0.5f + from.z);
        }
        val -= 1f;
        return new Vector3(LeanTween.easeOutBounce(0f, diff.x, val) * 0.5f + diffDiv2.x + from.x, LeanTween.easeOutBounce(0f, diff.y, val) * 0.5f + diffDiv2.y + from.y, LeanTween.easeOutBounce(0f, diff.z, val) * 0.5f + diffDiv2.z + from.z);
    }

    public Vector3 easeInBack()
    {
        //IL_0029: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0051: Unknown result type (might be due to invalid IL or missing references)
        //IL_0057: Unknown result type (might be due to invalid IL or missing references)
        //IL_005c: Unknown result type (might be due to invalid IL or missing references)
        val = ratioPassed;
        val /= 1f;
        float num = 1.70158f * overshoot;
        return diff * val * val * ((num + 1f) * val - num) + from;
    }

    public Vector3 easeOutBack()
    {
        //IL_004b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        float num = 1.70158f * overshoot;
        val = ratioPassed / 1f - 1f;
        val = val * val * ((num + 1f) * val + num) + 1f;
        return diff * val + from;
    }

    public Vector3 easeInOutBack()
    {
        //IL_00b1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00bb: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c1: Unknown result type (might be due to invalid IL or missing references)
        //IL_00c6: Unknown result type (might be due to invalid IL or missing references)
        //IL_003a: Unknown result type (might be due to invalid IL or missing references)
        //IL_005a: Unknown result type (might be due to invalid IL or missing references)
        //IL_0060: Unknown result type (might be due to invalid IL or missing references)
        //IL_0065: Unknown result type (might be due to invalid IL or missing references)
        float num = 1.70158f * overshoot;
        val = ratioPassed * 2f;
        if (val < 1f)
        {
            num *= 1.525f * overshoot;
            return diffDiv2 * (val * val * ((num + 1f) * val - num)) + from;
        }
        val -= 2f;
        num *= 1.525f * overshoot;
        val = val * val * ((num + 1f) * val + num) + 2f;
        return diffDiv2 * val + from;
    }

    public Vector3 easeInElastic()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(LeanTween.easeInElastic(from.x, to.x, ratioPassed, overshoot, period), LeanTween.easeInElastic(from.y, to.y, ratioPassed, overshoot, period), LeanTween.easeInElastic(from.z, to.z, ratioPassed, overshoot, period));
    }

    public Vector3 easeOutElastic()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(LeanTween.easeOutElastic(from.x, to.x, ratioPassed, overshoot, period), LeanTween.easeOutElastic(from.y, to.y, ratioPassed, overshoot, period), LeanTween.easeOutElastic(from.z, to.z, ratioPassed, overshoot, period));
    }

    public Vector3 easeInOutElastic()
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        //IL_002e: Unknown result type (might be due to invalid IL or missing references)
        //IL_0039: Unknown result type (might be due to invalid IL or missing references)
        //IL_005b: Unknown result type (might be due to invalid IL or missing references)
        //IL_0066: Unknown result type (might be due to invalid IL or missing references)
        //IL_0087: Unknown result type (might be due to invalid IL or missing references)
        return new Vector3(LeanTween.easeInOutElastic(from.x, to.x, ratioPassed, overshoot, period), LeanTween.easeInOutElastic(from.y, to.y, ratioPassed, overshoot, period), LeanTween.easeInOutElastic(from.z, to.z, ratioPassed, overshoot, period));
    }

    public LTDescr setOvershoot(float overshoot)
    {
        this.overshoot = overshoot;
        return this;
    }

    public LTDescr setPeriod(float period)
    {
        this.period = period;
        return this;
    }

    public LTDescr setScale(float scale)
    {
        this.scale = scale;
        return this;
    }

    public LTDescr setEase(AnimationCurve easeCurve)
    {
        _optional.animationCurve = easeCurve;
        easeMethod = tweenOnCurve;
        easeType = LeanTweenType.animationCurve;
        return this;
    }

    public LTDescr setTo(Vector3 to)
    {
        //IL_0024: Unknown result type (might be due to invalid IL or missing references)
        //IL_0009: Unknown result type (might be due to invalid IL or missing references)
        //IL_0010: Unknown result type (might be due to invalid IL or missing references)
        //IL_0012: Unknown result type (might be due to invalid IL or missing references)
        //IL_0017: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        if (hasInitiliazed)
        {
            this.to = to;
            diff = to - from;
        }
        else
        {
            this.to = to;
        }
        return this;
    }

    public LTDescr setTo(Transform to)
    {
        _optional.toTrans = to;
        return this;
    }

    public LTDescr setFrom(Vector3 from)
    {
        //IL_0014: Unknown result type (might be due to invalid IL or missing references)
        //IL_001c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0022: Unknown result type (might be due to invalid IL or missing references)
        //IL_0027: Unknown result type (might be due to invalid IL or missing references)
        //IL_002c: Unknown result type (might be due to invalid IL or missing references)
        //IL_0033: Unknown result type (might be due to invalid IL or missing references)
        //IL_003d: Unknown result type (might be due to invalid IL or missing references)
        //IL_0042: Unknown result type (might be due to invalid IL or missing references)
        if ((trans))
        {
            init();
        }
        this.from = from;
        diff = to - this.from;
        diffDiv2 = diff * 0.5f;
        return this;
    }

    public LTDescr setFrom(float from)
    {
        //IL_000c: Unknown result type (might be due to invalid IL or missing references)
        return setFrom(new Vector3(from, 0f, 0f));
    }

    public LTDescr setDiff(Vector3 diff)
    {
        //IL_0001: Unknown result type (might be due to invalid IL or missing references)
        //IL_0002: Unknown result type (might be due to invalid IL or missing references)
        this.diff = diff;
        return this;
    }

    public LTDescr setHasInitialized(bool has)
    {
        hasInitiliazed = has;
        return this;
    }

    public LTDescr setId(uint id, uint global_counter)
    {
        _id = id;
        counter = global_counter;
        return this;
    }

    public LTDescr setPassed(float passed)
    {
        this.passed = passed;
        return this;
    }

    public LTDescr setTime(float time)
    {
        float num = passed / this.time;
        passed = time * num;
        this.time = time;
        return this;
    }

    public LTDescr setSpeed(float speed)
    {
        this.speed = speed;
        if (hasInitiliazed)
        {
            initSpeed();
        }
        return this;
    }

    public LTDescr setRepeat(int repeat)
    {
        loopCount = repeat;
        if ((repeat > 1 && loopType == LeanTweenType.once) || (repeat < 0 && loopType == LeanTweenType.once))
        {
            loopType = LeanTweenType.clamp;
        }
        if (type == TweenAction.CALLBACK || type == TweenAction.CALLBACK_COLOR)
        {
            setOnCompleteOnRepeat(isOn: true);
        }
        return this;
    }

    public LTDescr setLoopType(LeanTweenType loopType)
    {
        this.loopType = loopType;
        return this;
    }

    public LTDescr setUseEstimatedTime(bool useEstimatedTime)
    {
        this.useEstimatedTime = useEstimatedTime;
        usesNormalDt = false;
        return this;
    }

    public LTDescr setIgnoreTimeScale(bool useUnScaledTime)
    {
        useEstimatedTime = useUnScaledTime;
        usesNormalDt = false;
        return this;
    }

    public LTDescr setUseFrames(bool useFrames)
    {
        this.useFrames = useFrames;
        usesNormalDt = false;
        return this;
    }

    public LTDescr setUseManualTime(bool useManualTime)
    {
        this.useManualTime = useManualTime;
        usesNormalDt = false;
        return this;
    }

    public LTDescr setLoopCount(int loopCount)
    {
        loopType = LeanTweenType.clamp;
        this.loopCount = loopCount;
        return this;
    }

    public LTDescr setLoopOnce()
    {
        loopType = LeanTweenType.once;
        return this;
    }

    public LTDescr setLoopClamp()
    {
        loopType = LeanTweenType.clamp;
        if (loopCount == 0)
        {
            loopCount = -1;
        }
        return this;
    }

    public LTDescr setLoopClamp(int loops)
    {
        loopCount = loops;
        return this;
    }

    public LTDescr setLoopPingPong()
    {
        loopType = LeanTweenType.pingPong;
        if (loopCount == 0)
        {
            loopCount = -1;
        }
        return this;
    }

    public LTDescr setLoopPingPong(int loops)
    {
        loopType = LeanTweenType.pingPong;
        loopCount = ((loops == -1) ? loops : (loops * 2));
        return this;
    }

    public LTDescr setOnComplete(System.Action onComplete)
    {
        _optional.onComplete = onComplete;
        hasExtraOnCompletes = true;
        return this;
    }

    public LTDescr setOnComplete(System.Action<object> onComplete)
    {
        _optional.onCompleteObject = onComplete;
        hasExtraOnCompletes = true;
        return this;
    }

    public LTDescr setOnComplete(System.Action<object> onComplete, object onCompleteParam)
    {
        _optional.onCompleteObject = onComplete;
        hasExtraOnCompletes = true;
        if (onCompleteParam != null)
        {
            _optional.onCompleteParam = onCompleteParam;
        }
        return this;
    }

    public LTDescr setOnCompleteParam(object onCompleteParam)
    {
        _optional.onCompleteParam = onCompleteParam;
        hasExtraOnCompletes = true;
        return this;
    }

    public LTDescr setOnUpdate(System.Action<float> onUpdate)
    {
        _optional.onUpdateFloat = onUpdate;
        hasUpdateCallback = true;
        return this;
    }

    public LTDescr setOnUpdateRatio(System.Action<float, float> onUpdate)
    {
        _optional.onUpdateFloatRatio = onUpdate;
        hasUpdateCallback = true;
        return this;
    }

    public LTDescr setOnUpdateObject(System.Action<float, object> onUpdate)
    {
        _optional.onUpdateFloatObject = onUpdate;
        hasUpdateCallback = true;
        return this;
    }

    public LTDescr setOnUpdateVector2(System.Action<Vector2> onUpdate)
    {
        _optional.onUpdateVector2 = onUpdate;
        hasUpdateCallback = true;
        return this;
    }

    public LTDescr setOnUpdateVector3(System.Action<Vector3> onUpdate)
    {
        _optional.onUpdateVector3 = onUpdate;
        hasUpdateCallback = true;
        return this;
    }

    public LTDescr setOnUpdateColor(System.Action<Color> onUpdate)
    {
        _optional.onUpdateColor = onUpdate;
        hasUpdateCallback = true;
        return this;
    }

    public LTDescr setOnUpdateColor(System.Action<Color, object> onUpdate)
    {
        _optional.onUpdateColorObject = onUpdate;
        hasUpdateCallback = true;
        return this;
    }

    public LTDescr setOnUpdate(System.Action<Color> onUpdate)
    {
        _optional.onUpdateColor = onUpdate;
        hasUpdateCallback = true;
        return this;
    }

    public LTDescr setOnUpdate(System.Action<Color, object> onUpdate)
    {
        _optional.onUpdateColorObject = onUpdate;
        hasUpdateCallback = true;
        return this;
    }

    public LTDescr setOnUpdate(System.Action<float, object> onUpdate, object onUpdateParam = null)
    {
        _optional.onUpdateFloatObject = onUpdate;
        hasUpdateCallback = true;
        if (onUpdateParam != null)
        {
            _optional.onUpdateParam = onUpdateParam;
        }
        return this;
    }

    public LTDescr setOnUpdate(System.Action<Vector3, object> onUpdate, object onUpdateParam = null)
    {
        _optional.onUpdateVector3Object = onUpdate;
        hasUpdateCallback = true;
        if (onUpdateParam != null)
        {
            _optional.onUpdateParam = onUpdateParam;
        }
        return this;
    }

    public LTDescr setOnUpdate(System.Action<Vector2> onUpdate, object onUpdateParam = null)
    {
        _optional.onUpdateVector2 = onUpdate;
        hasUpdateCallback = true;
        if (onUpdateParam != null)
        {
            _optional.onUpdateParam = onUpdateParam;
        }
        return this;
    }

    public LTDescr setOnUpdate(System.Action<Vector3> onUpdate, object onUpdateParam = null)
    {
        _optional.onUpdateVector3 = onUpdate;
        hasUpdateCallback = true;
        if (onUpdateParam != null)
        {
            _optional.onUpdateParam = onUpdateParam;
        }
        return this;
    }

    public LTDescr setOnUpdateParam(object onUpdateParam)
    {
        _optional.onUpdateParam = onUpdateParam;
        return this;
    }

    public LTDescr setOrientToPath(bool doesOrient)
    {
        if (type == TweenAction.MOVE_CURVED || type == TweenAction.MOVE_CURVED_LOCAL)
        {
            _optional.path ??= new LTBezierPath();
            _optional.path.orientToPath = doesOrient;
        }
        else
        {
            _optional.spline.orientToPath = doesOrient;
        }
        return this;
    }

    public LTDescr setOrientToPath2d(bool doesOrient2d)
    {
        setOrientToPath(doesOrient2d);
        if (type == TweenAction.MOVE_CURVED || type == TweenAction.MOVE_CURVED_LOCAL)
        {
            _optional.path.orientToPath2d = doesOrient2d;
        }
        else
        {
            _optional.spline.orientToPath2d = doesOrient2d;
        }
        return this;
    }

    public LTDescr setRect(LTRect rect)
    {
        _optional.ltRect = rect;
        return this;
    }

    public LTDescr setRect(Rect rect)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        _optional.ltRect = new LTRect(rect);
        return this;
    }

    public LTDescr setPath(LTBezierPath path)
    {
        _optional.path = path;
        return this;
    }

    public LTDescr setPoint(Vector3 point)
    {
        //IL_0006: Unknown result type (might be due to invalid IL or missing references)
        _optional.point = point;
        return this;
    }

    public LTDescr setDestroyOnComplete(bool doesDestroy)
    {
        destroyOnComplete = doesDestroy;
        return this;
    }

    public LTDescr setAudio(object audio)
    {
        _optional.onCompleteParam = audio;
        return this;
    }

    public LTDescr setOnCompleteOnRepeat(bool isOn)
    {
        onCompleteOnRepeat = isOn;
        return this;
    }

    public LTDescr setOnCompleteOnStart(bool isOn)
    {
        onCompleteOnStart = isOn;
        return this;
    }

    public LTDescr setRect(RectTransform rect)
    {
        rectTransform = rect;
        return this;
    }

    public LTDescr setSprites(Sprite[] sprites)
    {
        this.sprites = sprites;
        return this;
    }

    public LTDescr setFrameRate(float frameRate)
    {
        time = (float)sprites.Length / frameRate;
        return this;
    }

    public LTDescr setOnStart(System.Action onStart)
    {
        _optional.onStart = onStart;
        return this;
    }

    public LTDescr setDirection(float direction)
    {
        if (this.direction != -1f && this.direction != 1f)
        {
            Debug.LogWarning(("You have passed an incorrect direction of '" + direction + "', direction must be -1f or 1f"));
            return this;
        }
        if (this.direction != direction)
        {
            if (hasInitiliazed)
            {
                this.direction = direction;
            }
            else if (_optional.path != null)
            {
                _optional.path = new LTBezierPath(LTUtility.reverse(_optional.path.pts));
            }
            else if (_optional.spline != null)
            {
                _optional.spline = new LTSpline(LTUtility.reverse(_optional.spline.pts));
            }
        }
        return this;
    }

    public LTDescr setRecursive(bool useRecursion)
    {
        this.useRecursion = useRecursion;
        return this;
    }
}
public class LTDescrOptional
{
    public AnimationCurve animationCurve;

    public int initFrameCount;

    public Color color;

    public Transform toTrans { get; set; }

    public Vector3 point { get; set; }

    public Vector3 axis { get; set; }

    public float lastVal { get; set; }

    public Quaternion origRotation { get; set; }

    public LTBezierPath path { get; set; }

    public LTSpline spline { get; set; }

    public LTRect ltRect { get; set; }

    public System.Action<float> onUpdateFloat { get; set; }

    public System.Action<float, float> onUpdateFloatRatio { get; set; }

    public System.Action<float, object> onUpdateFloatObject { get; set; }

    public System.Action<Vector2> onUpdateVector2 { get; set; }

    public System.Action<Vector3> onUpdateVector3 { get; set; }

    public System.Action<Vector3, object> onUpdateVector3Object { get; set; }

    public System.Action<Color> onUpdateColor { get; set; }

    public System.Action<Color, object> onUpdateColorObject { get; set; }

    public System.Action onComplete { get; set; }

    public System.Action<object> onCompleteObject { get; set; }

    public object onCompleteParam { get; set; }

    public object onUpdateParam { get; set; }

    public System.Action onStart { get; set; }

    public void reset()
    {
        //IL_0055: Unknown result type (might be due to invalid IL or missing references)
        animationCurve = null;
        onUpdateFloat = null;
        onUpdateFloatRatio = null;
        onUpdateVector2 = null;
        onUpdateVector3 = null;
        onUpdateFloatObject = null;
        onUpdateVector3Object = null;
        onUpdateColor = null;
        onComplete = null;
        onCompleteObject = null;
        onCompleteParam = null;
        onStart = null;
        point = Vector3.zero;
        initFrameCount = 0;
    }

    public void callOnUpdate(float val, float ratioPassed)
    {
        //IL_0053: Unknown result type (might be due to invalid IL or missing references)
        //IL_0072: Unknown result type (might be due to invalid IL or missing references)
        //IL_009f: Unknown result type (might be due to invalid IL or missing references)
        if (onUpdateFloat != null)
        {
            onUpdateFloat(val);
        }
        if (onUpdateFloatRatio != null)
        {
            onUpdateFloatRatio(val, ratioPassed);
        }
        else if (onUpdateFloatObject != null)
        {
            onUpdateFloatObject(val, onUpdateParam);
        }
        else if (onUpdateVector3Object != null)
        {
            onUpdateVector3Object(LTDescr.newVect, onUpdateParam);
        }
        else if (onUpdateVector3 != null)
        {
            onUpdateVector3(LTDescr.newVect);
        }
        else if (onUpdateVector2 != null)
        {
            onUpdateVector2(new Vector2(LTDescr.newVect.x, LTDescr.newVect.y));
        }
    }
}
public class LTSeq
{
    public LTSeq previous;

    public LTSeq current;

    public LTDescr tween;

    public float totalDelay;

    public float timeScale;

    public int debugIter;

    public uint counter;

    public bool toggle;

    public uint _id;

    public int id => (int)(_id | (counter << 16));

    public void reset()
    {
        previous = null;
        tween = null;
        totalDelay = 0f;
    }

    public void init(uint id, uint global_counter)
    {
        reset();
        _id = id;
        counter = global_counter;
        current = this;
    }

    public LTSeq addOn()
    {
        current.toggle = true;
        LTSeq lTSeq = current;
        current = LeanTween.sequence();
        current.previous = lTSeq;
        lTSeq.toggle = false;
        current.totalDelay = lTSeq.totalDelay;
        current.debugIter = lTSeq.debugIter + 1;
        return current;
    }

    public float addPreviousDelays()
    {
        LTSeq lTSeq = current.previous;
        if (lTSeq != null && lTSeq.tween != null)
        {
            return current.totalDelay + lTSeq.tween.time;
        }
        return current.totalDelay;
    }

    public LTSeq append(float delay)
    {
        current.totalDelay += delay;
        return current;
    }

    public LTSeq append(System.Action callback)
    {
        LTDescr lTDescr = LeanTween.delayedCall(0f, callback);
        return append(lTDescr);
    }

    public LTSeq append(System.Action<object> callback, object obj)
    {
        append(LeanTween.delayedCall(0f, callback).setOnCompleteParam(obj));
        return addOn();
    }

    public LTSeq append(GameObject gameObject, System.Action callback)
    {
        append(LeanTween.delayedCall(gameObject, 0f, callback));
        return addOn();
    }

    public LTSeq append(GameObject gameObject, System.Action<object> callback, object obj)
    {
        append(LeanTween.delayedCall(gameObject, 0f, callback).setOnCompleteParam(obj));
        return addOn();
    }

    public LTSeq append(LTDescr tween)
    {
        current.tween = tween;
        current.totalDelay = addPreviousDelays();
        tween.setDelay(current.totalDelay);
        return addOn();
    }

    public LTSeq insert(LTDescr tween)
    {
        current.tween = tween;
        tween.setDelay(addPreviousDelays());
        return addOn();
    }

    public LTSeq setScale(float timeScale)
    {
        setScaleRecursive(current, timeScale, 500);
        return addOn();
    }

    public void setScaleRecursive(LTSeq seq, float timeScale, int count)
    {
        if (count <= 0)
        {
            return;
        }
        this.timeScale = timeScale;
        seq.totalDelay *= timeScale;
        if (seq.tween != null)
        {
            if (seq.tween.time != 0f)
            {
                seq.tween.setTime(seq.tween.time * timeScale);
            }
            seq.tween.setDelay(seq.tween.delay * timeScale);
        }
        if (seq.previous != null)
        {
            setScaleRecursive(seq.previous, timeScale, count - 1);
        }
    }

    public LTSeq reverse()
    {
        return addOn();
    }
}
namespace Deadpan.Enums
{
    [Serializable]
    public enum UINavigationTag
    {
        DiscardPocket = 0,
        DrawPocket = 1,
        EnemyCard = 2,
        EnemyCardSlot = 3,
        PlayerCard = 6,
        PlayerCardSlot = 4,
        RedrawBell = 5,
        Card = 7
    }
}
namespace Deadpan.Enums.Engine.Components.Modding
{
    public class BattleDataBuilder : DataFileBuilder<BattleData, BattleDataBuilder>
    {
        public BattleDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public BattleDataBuilder()
        {
        }

        public BattleDataBuilder WithTitle(string title)
        {
            _data.title = title;
            return this;
        }

        public BattleDataBuilder WithPointFactor(float factor = 1f)
        {
            _data.pointFactor = factor;
            return this;
        }

        public BattleDataBuilder WithWaveCounter(int waveCounter = 4)
        {
            _data.waveCounter = waveCounter;
            return this;
        }

        public BattleDataBuilder WithPools(params BattleWavePoolData[] pools)
        {
            _data.pools = pools;
            return this;
        }

        public BattleDataBuilder WithBonusUnitPool(params CardData[] pools)
        {
            _data.bonusUnitPool = pools;
            return this;
        }

        public BattleDataBuilder WithBonusUnitRange(Vector2Int v)
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            _data.bonusUnitRange = v;
            return this;
        }

        public BattleDataBuilder WithGoldGiverPool(params CardData[] pools)
        {
            _data.goldGiverPool = pools;
            return this;
        }

        public BattleDataBuilder WithGoldGivers(int amount = 1)
        {
            _data.goldGivers = amount;
            return this;
        }

        public BattleDataBuilder WithGenerationScript(BattleGenerationScript s)
        {
            _data.generationScript = s;
            return this;
        }

        public BattleDataBuilder WithSetUpScript(Script s)
        {
            _data.setUpScript = s;
            return this;
        }

        public BattleDataBuilder WithSprite(Sprite sprite)
        {
            _data.sprite = sprite;
            return this;
        }

        public BattleDataBuilder WithSprite(string sprite)
        {
            _data.sprite = Mod.GetImageSprite(sprite);
            return this;
        }

        public BattleDataBuilder WithName(string name, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_ref", name);
            _data.nameRef = collection.GetString((_data).name + "_ref");
            return this;
        }
    }
    public class BossRewardDataBuilder : DataFileBuilder<BossRewardData, BossRewardDataBuilder>
    {
        public BossRewardDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public BossRewardDataBuilder()
        {
        }
    }
    public class BuildingPlotTypeBuilder : DataFileBuilder<BuildingPlotType, BuildingPlotTypeBuilder>
    {
        public BuildingPlotTypeBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public BuildingPlotTypeBuilder()
        {
        }

        public BuildingPlotTypeBuilder WithIllegalBuildings(params BuildingType[] illegalBuildings)
        {
            _data.illegalBuildings = illegalBuildings;
            return this;
        }
    }
    public class BuildingTypeBuilder : DataFileBuilder<BuildingType, BuildingTypeBuilder>
    {
        public BuildingTypeBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public BuildingTypeBuilder()
        {
        }

        public BuildingTypeBuilder WithTitle(LocalizedString title)
        {
            _data.titleKey = title;
            return this;
        }

        public BuildingTypeBuilder WithTitle(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_building_title", title);
            _data.titleKey = collection.GetString((_data).name + "_building_title");
            return this;
        }

        public BuildingTypeBuilder WithHelp(LocalizedString title)
        {
            _data.helpKey = title;
            return this;
        }

        public BuildingTypeBuilder WithHelp(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_building_help", title);
            _data.helpKey = collection.GetString((_data).name + "_building_help");
            return this;
        }

        public BuildingTypeBuilder WithHelpEmoteType(Prompt.Emote.Type helpEmoteType = Prompt.Emote.Type.Explain)
        {
            _data.helpEmoteType = helpEmoteType;
            return this;
        }

        public BuildingTypeBuilder WithStarted(UnlockData started)
        {
            _data.started = started;
            return this;
        }

        public BuildingTypeBuilder WithFinished(UnlockData finished)
        {
            _data.finished = finished;
            return this;
        }

        public BuildingTypeBuilder WithUnlocks(params UnlockData[] unlocks)
        {
            _data.unlocks = unlocks;
            return this;
        }

        public BuildingTypeBuilder WithUnlockedCheckedKey(string unlockedCheckedKey)
        {
            _data.unlockedCheckedKey = unlockedCheckedKey;
            return this;
        }
    }
    public class CampaignNodeTypeBuilder : DataFileBuilder<CampaignNodeType, CampaignNodeTypeBuilder>
    {
        public CampaignNodeTypeBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public CampaignNodeTypeBuilder()
        {
        }

        public CampaignNodeTypeBuilder WithLetter(string letter)
        {
            _data.letter = letter;
            return this;
        }

        public CampaignNodeTypeBuilder WithZoneName(string zoneName)
        {
            _data.zoneName = zoneName;
            return this;
        }

        public CampaignNodeTypeBuilder WithMustClear(bool mustClear)
        {
            _data.mustClear = mustClear;
            return this;
        }

        public CampaignNodeTypeBuilder WithCanSkip(bool canSkip)
        {
            _data.canSkip = canSkip;
            return this;
        }

        public CampaignNodeTypeBuilder WithCanEnter(bool canEnter)
        {
            _data.canEnter = canEnter;
            return this;
        }

        public CampaignNodeTypeBuilder WithIsBattle(bool isBattle)
        {
            _data.isBattle = isBattle;
            return this;
        }

        public CampaignNodeTypeBuilder WithIsBoss(bool isBoss)
        {
            _data.isBoss = isBoss;
            return this;
        }

        public CampaignNodeTypeBuilder WithModifierReward(bool modifierReward)
        {
            _data.modifierReward = modifierReward;
            return this;
        }

        public CampaignNodeTypeBuilder WithInteractable(bool interactable)
        {
            _data.interactable = interactable;
            return this;
        }

        public CampaignNodeTypeBuilder WithStartRevealed(bool startRevealed)
        {
            _data.startRevealed = startRevealed;
            return this;
        }

        public CampaignNodeTypeBuilder WithFinalNode(bool finalNode)
        {
            _data.finalNode = finalNode;
            return this;
        }

        public CampaignNodeTypeBuilder WithMapNodePrefab(MapNode mapNodePrefab)
        {
            _data.mapNodePrefab = mapNodePrefab;
            return this;
        }

        public CampaignNodeTypeBuilder WithMapNodeSprite(Sprite mapNodeSprite)
        {
            _data.mapNodeSprite = mapNodeSprite;
            return this;
        }

        public CampaignNodeTypeBuilder WithMapNodeSprite(string mapNodeSprite)
        {
            _data.mapNodeSprite = Mod.GetImageSprite(mapNodeSprite);
            return this;
        }

        public CampaignNodeTypeBuilder WithSize(float size = 1f)
        {
            _data.size = size;
            return this;
        }

        public CampaignNodeTypeBuilder WithCanLink(bool canLink)
        {
            _data.canLink = canLink;
            return this;
        }
    }
    public class CardDataBuilder : DataFileBuilder<CardData, CardDataBuilder>
    {
        public ChallengeData UnlockChallenge;

        public CardDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public CardDataBuilder()
        {
        }

        public CardDataBuilder SetStats(int? health = null, int? damage = null, int counter = 0)
        {
            return SetHealth(health).SetDamage(damage).SetCounter(counter);
        }

        public CardDataBuilder SetCounter(int counter)
        {
            _data.counter = counter;
            return this;
        }

        public CardDataBuilder SetDamage(int? damage)
        {
            if (damage.HasValue)
            {
                _data.damage = damage.Value;
            }
            _data.hasAttack = damage.HasValue;
            return this;
        }

        public CardDataBuilder NeedsTarget(bool value = true)
        {
            _data.needsTarget = value;
            return this;
        }

        public CardDataBuilder SetHealth(int? health)
        {
            if (health.HasValue)
            {
                _data.hp = health.Value;
            }
            _data.hasHealth = health.HasValue;
            return this;
        }

        public CardDataBuilder SetSprites(Sprite mainSprite, Sprite backgroundSprite)
        {
            _data.mainSprite = mainSprite;
            _data.backgroundSprite = backgroundSprite;
            return this;
        }

        public CardDataBuilder SetSprites(string mainSprite, string backgroundSprite)
        {
            return SetSprites(Mod.ImagePath(mainSprite).ToSprite(), Mod.ImagePath(backgroundSprite).ToSprite());
        }

        public CardDataBuilder SetStartWithEffect(params CardData.StatusEffectStacks[] stacks)
        {
            _data.startWithEffects = stacks;
            return this;
        }

        public CardDataBuilder SetTraits(params CardData.TraitStacks[] stacks)
        {
            _data.traits = IArrayExt.ToList<CardData.TraitStacks>(stacks);
            return this;
        }

        public CardDataBuilder WithDescription(string desc)
        {
            _data.desc = desc;
            return this;
        }

        public CardDataBuilder WithValue(int price)
        {
            _data.value = price;
            return this;
        }

        public CardDataBuilder WithTargetMode(TargetMode mode)
        {
            _data.targetMode = mode;
            return this;
        }

        public CardDataBuilder WithTargetMode(string mode = "TargetModeBasic")
        {
            _data.targetMode = Extensions.GetTargetMode(mode);
            return this;
        }

        public CardDataBuilder WithPlayType(Card.PlayType type)
        {
            _data.playType = type;
            return this;
        }

        public CardDataBuilder SetAttackEffect(params CardData.StatusEffectStacks[] stacks)
        {
            _data.attackEffects = stacks;
            return this;
        }

        public CardDataBuilder WithIdleAnimationProfile(CardAnimationProfile bp)
        {
            _data.idleAnimationProfile = bp;
            return this;
        }

        public CardDataBuilder WithIdleAnimationProfile(string bp = "SwayAnimationProfile")
        {
            return WithIdleAnimationProfile(Extensions.GetCardAnimationProfile(bp));
        }

        public CardDataBuilder WithBloodProfile(BloodProfile bp)
        {
            _data.bloodProfile = bp;
            return this;
        }

        public CardDataBuilder WithBloodProfile(string bp = "Blood Profile Normal")
        {
            return WithBloodProfile(Mod.GetAsset<BloodProfile>(bp));
        }

        public CardDataBuilder CanPlayOnBoard(bool value = true)
        {
            _data.canPlayOnBoard = value;
            return this;
        }

        public CardDataBuilder CanPlayOnEnemy(bool value = true)
        {
            _data.canPlayOnEnemy = value;
            return this;
        }

        public CardDataBuilder CanPlayOnFriendly(bool value = true)
        {
            _data.canPlayOnFriendly = value;
            return this;
        }

        public CardDataBuilder CanPlayOnHand(bool value = true)
        {
            _data.canPlayOnHand = value;
            return this;
        }

        public CardDataBuilder CanBeHit(bool value = true)
        {
            _data.canBeHit = value;
            return this;
        }

        public CardDataBuilder CanShoveToOtherRow(bool value = true)
        {
            _data.canShoveToOtherRow = value;
            return this;
        }

        public CardDataBuilder AsUnit(string targetMode = "TargetModeBasic", string idleAnim = "SwayAnimationProfile", string bloodProfile = "Blood Profile Normal")
        {
            _data.canPlayOnEnemy = true;
            _data.canBeHit = true;
            _data.playType = Card.PlayType.Place;
            _data.canPlayOnBoard = true;
            _data.cardType = Mod.Get<CardType>("Friendly");
            return SetStats(0, 0).WithTargetMode(targetMode).WithBloodProfile(bloodProfile).WithIdleAnimationProfile(idleAnim);
        }

        public CardDataBuilder AsItem(string targetMode = "TargetModeBasic", string idleAnim = "SwayAnimationProfile")
        {
            _data.canPlayOnEnemy = true;
            _data.canBeHit = false;
            _data.playType = Card.PlayType.Play;
            _data.canPlayOnBoard = true;
            _data.cardType = Mod.Get<CardType>("Item");
            return FreeModify(delegate (CardData a)
            {
                a.uses = 1;
            }).WithTargetMode(targetMode).WithIdleAnimationProfile(idleAnim).CanPlayOnHand(value: false);
        }

        public CardDataBuilder IsCompanion(ChallengeData challenge, bool value = true)
        {
            UnlockChallenge = challenge;
            if (value)
            {
                _data.AddToCompanions();
                BuildingSequenceWithUnlocks<BuildingCardUnlockSequence>.OnStart += UnlockSequenceOnOnStart;
            }
            else
            {
                _data.RemoveFromCompanions();
                BuildingSequenceWithUnlocks<BuildingCardUnlockSequence>.OnStart -= UnlockSequenceOnOnStart;
            }
            return this;
        }

        public CardDataBuilder IsItem(ChallengeData challenge, bool value = true)
        {
            UnlockChallenge = challenge;
            if (value)
            {
                _data.AddToItems();
                BuildingSequenceWithUnlocks<InventorHutSequence>.OnStart += UnlockSequenceOnOnStart;
            }
            else
            {
                _data.RemoveFromItems();
                BuildingSequenceWithUnlocks<InventorHutSequence>.OnStart -= UnlockSequenceOnOnStart;
            }
            return this;
        }

        public CardDataBuilder IsPet(string challenge, bool value = true)
        {
            return IsPet(Mod.Get<ChallengeData>(challenge), value);
        }

        public CardDataBuilder IsPet(ChallengeData challenge, bool value = true)
        {
            UnlockChallenge = challenge;
            if (value)
            {
                _data.AddToPets((challenge == null) ? null : (challenge).name);
                BuildingSequenceWithUnlocks<PetHutSequence>.OnStart += UnlockSequenceOnOnStart;
            }
            else
            {
                _data.RemoveFromPets();
                BuildingSequenceWithUnlocks<PetHutSequence>.OnStart -= UnlockSequenceOnOnStart;
            }
            return this;
        }

        public void UnlockSequenceOnOnStart<T>(BuildingSequenceWithUnlocks<T> obj) where T : BuildingSequenceWithUnlocks<T>
        {
            obj.AddSlot(UnlockChallenge);
        }

        public CardDataBuilder CreateItem(string name, string englishTitle, string targetMode = "TargetModeBasic", string idleAnim = "SwayAnimationProfile")
        {
            return Create(name).WithTitle(englishTitle, (SystemLanguage)10).AsItem(targetMode, idleAnim);
        }

        [Obsolete("Reverse", true)]
        public CardDataBuilder CreateItem(string name, string englishTitle, string targetMode, string wtv, string idleAnim)
        {
            return Create(name).WithTitle(englishTitle, (SystemLanguage)10).AsItem(targetMode, idleAnim);
        }

        public CardDataBuilder CreateUnit(string name, string englishTitle, string targetMode = "TargetModeBasic", string bloodProfile = "Blood Profile Normal", string idleAnim = "SwayAnimationProfile")
        {
            return Create(name).WithTitle(englishTitle, (SystemLanguage)10).AsUnit(targetMode, idleAnim, bloodProfile);
        }

        public CardDataBuilder WithPools(params RewardPool[] pools)
        {
            base.AfterBuildEvent += delegate (CardData data)
            {
                data.WithPools(pools);
            };
            return this;
        }

        public CardDataBuilder WithPools(params string[] pools)
        {
            base.AfterBuildEvent += delegate (CardData data)
            {
                data.WithPools(pools.Select(Extensions.GetRewardPool).ToArray());
            };
            return this;
        }

        public CardDataBuilder AddPool(RewardPool pool)
        {
            base.AfterBuildEvent += delegate (CardData data)
            {
                data.AddPool(pool);
            };
            return this;
        }

        public CardDataBuilder AddPool(string pool = "GeneralUnitPool")
        {
            base.AfterBuildEvent += delegate (CardData data)
            {
                data.AddPool(Extensions.GetRewardPool(pool));
            };
            return this;
        }

        public CardDataBuilder WithCardType(CardType type)
        {
            _data.cardType = type;
            return this;
        }

        public CardDataBuilder WithCardType(string type = "Friendly")
        {
            _data.cardType = Mod.Get<CardType>(type);
            return this;
        }

        public CardDataBuilder WithTitle(LocalizedString title)
        {
            _data.titleKey = title;
            return this;
        }

        public CardDataBuilder WithFlavour(LocalizedString flavour)
        {
            _data.flavourKey = flavour;
            return this;
        }

        public CardDataBuilder WithText(LocalizedString text)
        {
            _data.textKey = text;
            return this;
        }

        public CardDataBuilder WithTitle(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_title", title);
            _data.titleKey = collection.GetString((_data).name + "_title");
            return this;
        }

        public CardDataBuilder WithFlavour(string flavour, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_flavour", flavour);
            _data.flavourKey = collection.GetString((_data).name + "_flavour");
            return this;
        }

        public CardDataBuilder WithText(string text, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_text", text);
            _data.textKey = collection.GetString((_data).name + "_text");
            return this;
        }

        ~CardDataBuilder()
        {
            Object.Destroy(_data);
        }

        public CardDataBuilder Clone()
        {
            return new CardDataBuilder(Mod)
            {
                _data = ObjectExt.InstantiateKeepName<CardData>(_data)
            };
        }
    }
    public class CardTypeBuilder : DataFileBuilder<CardType, CardTypeBuilder>
    {
        public CardTypeBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public CardTypeBuilder()
        {
        }

        public CardTypeBuilder WithSortPriority(int sortPriority)
        {
            _data.sortPriority = sortPriority;
            return this;
        }

        public CardTypeBuilder WithIcon(Sprite icon)
        {
            _data.icon = icon;
            return this;
        }

        public CardTypeBuilder WithIcon(string icon)
        {
            _data.icon = Mod.GetImageSprite(icon);
            return this;
        }

        public CardTypeBuilder WithPrefabRef(AssetReference prefabRef)
        {
            _data.prefabRef = prefabRef;
            return this;
        }

        public CardTypeBuilder WithTextBoxSprite(Sprite icon)
        {
            _data.textBoxSprite = icon;
            return this;
        }

        public CardTypeBuilder WithTextBoxSprite(string icon)
        {
            _data.textBoxSprite = Mod.GetImageSprite(icon);
            return this;
        }

        public CardTypeBuilder WithNameTagSprite(Sprite icon)
        {
            _data.nameTagSprite = icon;
            return this;
        }

        public CardTypeBuilder WithNameTagSprite(string icon)
        {
            _data.nameTagSprite = Mod.GetImageSprite(icon);
            return this;
        }

        public CardTypeBuilder WithTitle(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_type_title", title);
            _data.titleKey = collection.GetString((_data).name + "_type_title");
            return this;
        }

        public CardTypeBuilder WithTitle(LocalizedString str)
        {
            _data.titleKey = str;
            return this;
        }

        public CardTypeBuilder WithCanDie(bool canDie)
        {
            _data.canDie = canDie;
            return this;
        }

        public CardTypeBuilder WithCanTakeCrown(bool canTakeCrown)
        {
            _data.canTakeCrown = canTakeCrown;
            return this;
        }

        public CardTypeBuilder WithCanRecall(bool canRecall)
        {
            _data.canRecall = canRecall;
            return this;
        }

        public CardTypeBuilder WithCanReserve(bool canReserve)
        {
            _data.canReserve = canReserve;
            return this;
        }

        public CardTypeBuilder WithItem(bool item)
        {
            _data.item = item;
            return this;
        }

        public CardTypeBuilder WithUnit(bool unit)
        {
            _data.unit = unit;
            return this;
        }

        public CardTypeBuilder WithTag(string tag)
        {
            _data.tag = tag;
            return this;
        }

        public CardTypeBuilder WithMiniboss(bool miniboss)
        {
            _data.miniboss = miniboss;
            return this;
        }

        public CardTypeBuilder WithDiscoverInJournal(bool discoverInJournal)
        {
            _data.discoverInJournal = discoverInJournal;
            return this;
        }

        public CardTypeBuilder WithDescriptionColours(Text.ColourProfileHex descriptionColours)
        {
            _data.descriptionColours = descriptionColours;
            return this;
        }
    }
    public class CardUpgradeDataBuilder : DataFileBuilder<CardUpgradeData, CardUpgradeDataBuilder>
    {
        public ChallengeData UnlockChallenge;

        public CardUpgradeDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public CardUpgradeDataBuilder()
        {
        }

        public CardUpgradeDataBuilder CreateCharm(string name)
        {
            return Create(name).WithType(CardUpgradeData.Type.Charm).AddPool();
        }

        public CardUpgradeDataBuilder WithPools(params RewardPool[] pools)
        {
            base.AfterBuildEvent += delegate (CardUpgradeData data)
            {
                data.WithPools(pools);
            };
            return this;
        }

        public CardUpgradeDataBuilder WithPools(params string[] pools)
        {
            base.AfterBuildEvent += delegate (CardUpgradeData data)
            {
                data.WithPools(pools.Select(Extensions.GetRewardPool).ToArray());
            };
            return this;
        }

        public CardUpgradeDataBuilder AddPool(RewardPool pool)
        {
            base.AfterBuildEvent += delegate (CardUpgradeData data)
            {
                data.AddPool(pool);
            };
            return this;
        }

        public CardUpgradeDataBuilder AddPool(string pool = "GeneralCharmPool")
        {
            base.AfterBuildEvent += delegate (CardUpgradeData data)
            {
                data.AddPool(Extensions.GetRewardPool(pool));
            };
            return this;
        }

        public CardUpgradeDataBuilder WithTier(int tier)
        {
            _data.tier = tier;
            return this;
        }

        public CardUpgradeDataBuilder WithImage(Sprite img)
        {
            _data.image = img;
            return this;
        }

        public CardUpgradeDataBuilder WithType(CardUpgradeData.Type type)
        {
            _data.type = type;
            return this;
        }

        public CardUpgradeDataBuilder SetAttackEffects(params CardData.StatusEffectStacks[] efs)
        {
            _data.attackEffects = efs;
            return this;
        }

        public CardUpgradeDataBuilder SetEffects(params CardData.StatusEffectStacks[] efs)
        {
            _data.effects = efs;
            return this;
        }

        public CardUpgradeDataBuilder SetTraits(params CardData.TraitStacks[] efs)
        {
            _data.giveTraits = efs;
            return this;
        }

        public CardUpgradeDataBuilder SetScripts(params CardScript[] efs)
        {
            _data.scripts = efs;
            return this;
        }

        public CardUpgradeDataBuilder SetConstraints(params TargetConstraint[] efs)
        {
            _data.targetConstraints = efs;
            return this;
        }

        public CardUpgradeDataBuilder SetBecomesTarget(bool val)
        {
            _data.becomesTargetedCard = val;
            return this;
        }

        public CardUpgradeDataBuilder SetCanBeRemoved(bool val)
        {
            _data.canBeRemoved = val;
            return this;
        }

        public CardUpgradeDataBuilder ChangeDamage(int val)
        {
            _data.damage = val;
            return this;
        }

        public CardUpgradeDataBuilder ChangeHP(int val)
        {
            _data.hp = val;
            return this;
        }

        public CardUpgradeDataBuilder ChangeCounter(int val)
        {
            _data.counter = val;
            return this;
        }

        public CardUpgradeDataBuilder ChangeUses(int val)
        {
            _data.uses = val;
            return this;
        }

        public CardUpgradeDataBuilder ChangeEffectBonus(int val)
        {
            _data.effectBonus = val;
            return this;
        }

        public CardUpgradeDataBuilder WithSetDamage(bool val)
        {
            _data.setDamage = val;
            return this;
        }

        public CardUpgradeDataBuilder WithSetHP(bool val)
        {
            _data.setHp = val;
            return this;
        }

        public CardUpgradeDataBuilder WithSetCounter(bool val)
        {
            _data.setCounter = val;
            return this;
        }

        public CardUpgradeDataBuilder WithSetUses(bool val)
        {
            _data.setUses = val;
            return this;
        }

        public CardUpgradeDataBuilder IsCharm(ChallengeData challenge, bool value = true)
        {
            UnlockChallenge = challenge;
            if (value)
            {
                _data.AddToCharms(challenge.reward);
                BuildingSequenceWithUnlocks<ChallengeShrineSequence>.OnStart += UnlockSequenceOnOnStart;
            }
            else
            {
                _data.RemoveFromCharms(challenge.reward);
                BuildingSequenceWithUnlocks<ChallengeShrineSequence>.OnStart -= UnlockSequenceOnOnStart;
            }
            return this;
        }

        public void UnlockSequenceOnOnStart<T>(BuildingSequenceWithUnlocks<T> obj) where T : BuildingSequenceWithUnlocks<T>
        {
            obj.AddChallengeStone(UnlockChallenge);
        }

        public CardUpgradeDataBuilder WithImage(string img)
        {
            _data.image = Mod.ImagePath(img).ToSprite();
            return this;
        }

        public CardUpgradeDataBuilder WithTitle(LocalizedString title)
        {
            _data.titleKey = title;
            return this;
        }

        public CardUpgradeDataBuilder WithText(LocalizedString text)
        {
            _data.textKey = text;
            return this;
        }

        public CardUpgradeDataBuilder WithTitle(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Upgrades", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_title", title);
            _data.titleKey = collection.GetString((_data).name + "_title");
            return this;
        }

        public CardUpgradeDataBuilder WithText(string text, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Upgrades", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_text", text);
            _data.textKey = collection.GetString((_data).name + "_text");
            return this;
        }
    }
    public class ChallengeDataBuilder : DataFileBuilder<ChallengeData, ChallengeDataBuilder>
    {
        public ChallengeDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public ChallengeDataBuilder WithTitle(LocalizedString str)
        {
            _data.titleKey = str;
            return this;
        }

        public ChallengeDataBuilder WithText(LocalizedString str)
        {
            _data.textKey = str;
            return this;
        }

        public ChallengeDataBuilder WithRewardText(LocalizedString str)
        {
            _data.rewardKey = str;
            return this;
        }

        public ChallengeDataBuilder WithTitle(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Challenges", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_title", title);
            _data.titleKey = collection.GetString((_data).name + "_title");
            return this;
        }

        public ChallengeDataBuilder WithText(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Challenges", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_text", title);
            _data.textKey = collection.GetString((_data).name + "_text");
            return this;
        }

        public ChallengeDataBuilder()
        {
        }

        public ChallengeDataBuilder WithRewardText(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Challenges", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_reward", title);
            _data.rewardKey = collection.GetString((_data).name + "_reward");
            return this;
        }

        public ChallengeDataBuilder WithGoal(int amountGoal)
        {
            _data.goal = amountGoal;
            return this;
        }

        public ChallengeDataBuilder WithListener(ChallengeListener listener)
        {
            _data.listener = listener;
            return this;
        }

        public ChallengeDataBuilder WithListener(string listener)
        {
            _data.listener = Mod.Get<ChallengeListener>(listener);
            return this;
        }

        public ChallengeDataBuilder WithIcon(Sprite icon)
        {
            _data.icon = icon;
            return this;
        }

        public ChallengeDataBuilder WithRequires(params ChallengeData[] requires)
        {
            _data.requires = requires;
            return this;
        }

        public ChallengeDataBuilder WithRequires(params string[] requires)
        {
            _data.requires = requires.Select(Mod.Get<ChallengeData>).ToArray();
            return this;
        }

        public ChallengeDataBuilder WithReward(UnlockData reward)
        {
            _data.reward = reward;
            return this;
        }

        public ChallengeDataBuilder WithReward(string reward)
        {
            _data.reward = Mod.Get<UnlockData>(reward);
            return this;
        }
    }
    public class ChallengeListenerBuilder : DataFileBuilder<ChallengeListener, ChallengeListenerBuilder>
    {
        public ChallengeListenerBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public ChallengeListenerBuilder()
        {
        }

        public ChallengeListenerBuilder WithKey(string key)
        {
            _data.key = key;
            _data.hasKey = true;
            return this;
        }

        public ChallengeListenerBuilder WithCheckType(ChallengeListener.CheckType type)
        {
            _data.checkType = type;
            return this;
        }

        public ChallengeListenerBuilder WithStat(string stat)
        {
            _data.stat = stat;
            return this;
        }

        public ChallengeListenerBuilder WithStat(int toReach)
        {
            _data.target = toReach;
            return this;
        }
    }
    public class ClassDataBuilder : DataFileBuilder<ClassData, ClassDataBuilder>
    {
        public ClassDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public ClassDataBuilder()
        {
        }

        public ClassDataBuilder WithRequiresUnlock(UnlockData requiresUnlock)
        {
            _data.requiresUnlock = requiresUnlock;
            return this;
        }

        public ClassDataBuilder WithStartingInventory(Inventory startingInventory)
        {
            _data.startingInventory = startingInventory;
            return this;
        }

        public ClassDataBuilder WithLeaders(params CardData[] leaders)
        {
            _data.leaders = leaders;
            return this;
        }

        public ClassDataBuilder WithCharacterPrefab(Character characterPrefab)
        {
            _data.characterPrefab = characterPrefab;
            return this;
        }

        public ClassDataBuilder WithRewardPools(params RewardPool[] rewardPools)
        {
            _data.rewardPools = rewardPools;
            return this;
        }

        public ClassDataBuilder WithSelectSfxEvent(EventReference selectSfxEvent)
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            _data.selectSfxEvent = selectSfxEvent;
            return this;
        }

        public ClassDataBuilder WithFlag(Sprite flag)
        {
            _data.flag = flag;
            return this;
        }

        public ClassDataBuilder WithFlag(string flag)
        {
            _data.flag = Mod.GetImageSprite(flag);
            return this;
        }
    }
    public abstract class DataFileBuilder<T, Y> where T : DataFile where Y : DataFileBuilder<T, Y>, new()
    {
        public delegate void AfterBuildDelegate(T d);

        public T _data;

        public WildfrostMod Mod;

        public event AfterBuildDelegate AfterBuildEvent;

        public event AfterBuildDelegate AfterAllModBuildsEvent;

        public virtual T BuildInstance()
        {
            return ObjectExt.InstantiateKeepName<T>(_data);
        }

        public T Build()
        {
            T val = BuildInstance();
            OnAfterBuildEvent(val);
            return val;
        }

        public DataFileBuilder(WildfrostMod mod)
        {
            Mod = mod;
        }

        public DataFileBuilder()
        {
        }

        public Y FreeModify(System.Action<T> action)
        {
            action?.Invoke(_data);
            return (Y)this;
        }

        public Y FreeModify<D>(System.Action<D> action) where D : T
        {
            action?.Invoke(_data as D);
            return (Y)this;
        }

        public virtual Y Create(string name)
        {
            if (Mod != null)
            {
                name = Extensions.PrefixGUID(name, Mod);
            }
            if (_data != null)
            {
                Object.Destroy(_data);
            }
            _data = ScriptableObject.CreateInstance<T>();
            (_data).name = name;
            return this as Y;
        }

        public virtual Y Create<X>(string name) where X : T
        {
            if (Mod != null)
            {
                name = Extensions.PrefixGUID(name, Mod);
            }
            if (_data != null)
            {
                Object.Destroy(_data);
            }
            _data = (T)ScriptableObject.CreateInstance<X>();
            (_data).name = name;
            return this as Y;
        }

        public static implicit operator T(DataFileBuilder<T, Y> t)
        {
            return t.Build();
        }

        public virtual Y SubscribeToBuildEvent(AfterBuildDelegate d)
        {
            AfterBuildEvent += d;
            return (Y)this;
        }

        public virtual Y UnsubscribeToBuildEvent(AfterBuildDelegate d)
        {
            AfterBuildEvent -= d;
            return (Y)this;
        }

        public virtual Y SubscribeToAfterAllBuildEvent(AfterBuildDelegate d)
        {
            AfterAllModBuildsEvent += d;
            return (Y)this;
        }

        public virtual Y UnubscribeToAfterAllBuildEvent(AfterBuildDelegate d)
        {
            AfterAllModBuildsEvent -= d;
            return (Y)this;
        }

        public virtual void OnAfterBuildEvent(T d)
        {
            this.AfterBuildEvent?.Invoke(d);
        }

        public virtual void OnAfterAllModBuildsEvent(T d)
        {
            this.AfterAllModBuildsEvent?.Invoke(d);
        }
    }
    public static class Extensions
    {
        public static CardData[] GetCategoryCardData(string category, bool mustBeFinal = true)
        {
            return AddressableLoader.GetGroup<CardData>("CardData").FindAll(Condition).ToArray();
            bool Condition(CardData a)
            {
                if (((a.cardType).name == category && !a.isEnemyClunker) || ((a.cardType).name == "Clunker" && a.isEnemyClunker && category == "Enemy"))
                {
                    if (mustBeFinal)
                    {
                        LocalizedString titleKey = a.titleKey;
                        if (titleKey != null)
                        {
                            return !((LocalizedReference)titleKey).IsEmpty;
                        }
                        return false;
                    }
                    return true;
                }
                return false;
            }
        }

        public static StatusEffectDataBuilder SetSummonPrefabRef(this StatusEffectDataBuilder inst, string name = "SummonCreateCard")
        {
            inst.FreeModify(delegate (StatusEffectSummon summon)
            {
                //IL_0007: Unknown result type (might be due to invalid IL or missing references)
                //IL_0011: Expected O, but got Unknown
                summon.effectPrefabRef = (AssetReference)new AssetReferenceGameObject(name);
            });
            return inst;
        }

        public static bool IsCharm(this CardUpgradeData inst)
        {
            return MetaprogressionSystem.Get<List<string>>("charms").Contains((inst).name);
        }

        public static void AddToCharms(this CardUpgradeData inst, UnlockData data)
        {
            MetaprogressionSystem.Add("charms", (data).name, (inst).name);
        }

        public static bool RemoveFromCharms(this CardUpgradeData inst, UnlockData data)
        {
            return MetaprogressionSystem.Remove("charms", (data).name, (inst).name);
        }

        public static bool IsCompanion(this CardData inst)
        {
            return MetaprogressionSystem.Get<List<string>>("companions").Contains((inst).name);
        }

        public static void AddToCompanions(this CardData inst)
        {
            MetaprogressionSystem.Add("companions", (inst).name);
        }

        public static bool RemoveFromCompanions(this CardData inst)
        {
            return MetaprogressionSystem.Remove("companions", (inst).name);
        }

        public static bool IsItem(this CardData inst)
        {
            return MetaprogressionSystem.Get<List<string>>("items").Contains((inst).name);
        }

        public static void AddToItems(this CardData inst)
        {
            MetaprogressionSystem.Add("items", (inst).name);
        }

        public static bool RemoveFromItems(this CardData inst)
        {
            return MetaprogressionSystem.Remove("items", (inst).name);
        }

        public static bool IsPet(this CardData inst)
        {
            return MetaprogressionSystem.Get<Dictionary<string, string>>("pets").ContainsKey((inst).name);
        }

        public static void AddToPets(this CardData inst, string requiredUnlock = null)
        {
            MetaprogressionSystem.Add("pets", (inst).name, requiredUnlock);
        }

        public static bool RemoveFromPets(this CardData inst)
        {
            return MetaprogressionSystem.Remove<string, string>("pets", (inst).name, null);
        }

        public static T[] RemoveFromArray<T>(this T[] sequence, T item)
        {
            return sequence.Where((T a) => !a.Equals(item)).ToArray();
        }

        public static T[] RemoveFromArray<T>(this T[] sequence, Func<T, bool> item)
        {
            return sequence.Where(item).ToArray();
        }

        public static string PrefixGUID(string name, WildfrostMod mod)
        {
            if (mod == null)
            {
                return name;
            }
            return mod.GUID + "." + name;
        }

        public static string GetGUID(string name)
        {
            return name[0..name.LastIndexOf('.')];
        }

        public static WildfrostMod GetModFromGuid(string guid)
        {
            return Bootstrap.Mods.ToList().Find((WildfrostMod a) => a.GUID == guid);
        }

        public static CardAnimationProfile GetCardAnimationProfile(string name)
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            return Addressables.LoadAssetAsync<CardAnimationProfile>((object)name).WaitForCompletion();
        }

        public static TargetMode GetTargetMode(string name)
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            return Addressables.LoadAssetAsync<TargetMode>((object)name).WaitForCompletion();
        }

        public static void WithPools(this CardData data, params RewardPool[] pools)
        {
            for (int i = 0; i < pools.Length; i++)
            {
                pools[i].list.Add(data);
            }
        }

        public static void AddPool(this CardData data, RewardPool pool)
        {
            pool.list.Add(data);
        }

        public static void WithPools(this CardUpgradeData data, params RewardPool[] pools)
        {
            for (int i = 0; i < pools.Length; i++)
            {
                pools[i].list.Add(data);
            }
        }

        public static void AddPool(this CardUpgradeData data, RewardPool pool)
        {
            pool.list.Add(data);
        }

        public static LocalizedString GetLocalizedString(string table, string key)
        {
            //IL_0003: Unknown result type (might be due to invalid IL or missing references)
            return LocalizationHelper.GetCollection(table, new LocaleIdentifier((SystemLanguage)10)).GetString(key);
        }

        public static HashSet<RewardPool> GetAllRewardPools()
        {
            HashSet<RewardPool> hashSet = new HashSet<RewardPool>();
            foreach (ClassData item in AddressableLoader.GetGroup<ClassData>("ClassData"))
            {
                HashSetExt.AddRange<RewardPool>(hashSet, (IEnumerable<RewardPool>)item.rewardPools);
            }
            return hashSet;
        }

        public static Y Edit<T, Y>(this T data) where T : DataFile where Y : DataFileBuilder<T, Y>, new()
        {
            return new Y
            {
                Mod = (data.ModAdded ?? new InternalMod(null)),
                _data = data
            };
        }

        public static RewardPool GetRewardPool(string name)
        {
            foreach (ClassData item in AddressableLoader.GetGroup<ClassData>("ClassData"))
            {
                RewardPool[] rewardPools = item.rewardPools;
                foreach (RewardPool rewardPool in rewardPools)
                {
                    if ((rewardPool).name == name)
                    {
                        return rewardPool;
                    }
                }
            }
            return null;
        }

        public static Texture2D ToTex(this string path)
        {
            //IL_0004: Unknown result type (might be due to invalid IL or missing references)
            //IL_000a: Expected O, but got Unknown
            Texture2D val = new Texture2D(0, 0, (TextureFormat)4, false);
            if (!File.Exists(path))
            {
                return val;
            }
            ImageConversion.LoadImage(val, File.ReadAllBytes(path));
            return val;
        }

        public static Sprite ToSprite(this string path)
        {
            return path.ToTex().ToSprite();
        }

        public static Sprite ToSprite(this Texture2D t, Vector2? v = null)
        {
            //IL_001e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0015: Unknown result type (might be due to invalid IL or missing references)
            //IL_0023: Unknown result type (might be due to invalid IL or missing references)
            //IL_003d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0042: Unknown result type (might be due to invalid IL or missing references)
            Vector2 val = v ?? new Vector2(0.5f, 0.5f);
            return Sprite.Create(t, new Rect(0f, 0f, (float)((Texture)t).width, (float)((Texture)t).height), val);
        }
    }
    public class EyeDataBuilder : DataFileBuilder<EyeData, EyeDataBuilder>
    {
        public EyeDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public EyeDataBuilder()
        {
        }

        public EyeDataBuilder WithCardData(string cardData)
        {
            _data.cardData = cardData;
            return this;
        }

        public EyeDataBuilder WithCardData(CardData cardData)
        {
            _data.cardData = (cardData).name;
            return this;
        }

        public EyeDataBuilder WithEyes(params EyeData.Eye[] eyes)
        {
            _data.eyes = eyes;
            return this;
        }
    }
    public class GameModeBuilder : DataFileBuilder<GameMode, GameModeBuilder>
    {
        public GameModeBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public GameModeBuilder()
        {
        }

        public GameModeBuilder WithSaveFileName(string saveFileName)
        {
            _data.saveFileName = saveFileName;
            return this;
        }

        public GameModeBuilder WithSeed(string seed)
        {
            _data.seed = seed;
            return this;
        }

        public GameModeBuilder WithClasses(params ClassData[] classes)
        {
            _data.classes = classes;
            return this;
        }

        public GameModeBuilder WithGenerator(CampaignGenerator generator)
        {
            _data.generator = generator;
            return this;
        }

        public GameModeBuilder WithPopulator(CampaignPopulator populator)
        {
            _data.populator = populator;
            return this;
        }

        public GameModeBuilder WithStartInNode(bool startInNode)
        {
            _data.startInNode = startInNode;
            return this;
        }

        public GameModeBuilder WithTakeStartingPet(bool takeStartingPet = true)
        {
            _data.takeStartingPet = takeStartingPet;
            return this;
        }

        public GameModeBuilder WithCountsAsWin(bool countsAsWin = true)
        {
            _data.countsAsWin = countsAsWin;
            return this;
        }

        public GameModeBuilder WithShowStats(bool showStats = true)
        {
            _data.showStats = showStats;
            return this;
        }

        public GameModeBuilder WithGainProgress(bool gainProgress = true)
        {
            _data.gainProgress = gainProgress;
            return this;
        }

        public GameModeBuilder WithDoSave(bool doSave = true)
        {
            _data.doSave = doSave;
            return this;
        }

        public GameModeBuilder WithCanRestart(bool canRestart = true)
        {
            _data.canRestart = canRestart;
            return this;
        }

        public GameModeBuilder WithCanGoBack(bool canGoBack = true)
        {
            _data.canGoBack = canGoBack;
            return this;
        }

        public GameModeBuilder WithSubmitScore(bool submitScore = false)
        {
            _data.submitScore = submitScore;
            return this;
        }

        public GameModeBuilder WithMainGameMode(bool mainGameMode = true)
        {
            _data.mainGameMode = mainGameMode;
            return this;
        }

        public GameModeBuilder WithDailyRun(bool dailyRun = false)
        {
            _data.dailyRun = dailyRun;
            return this;
        }

        public GameModeBuilder WithTutorialRun(bool tutorialRun = false)
        {
            _data.tutorialRun = tutorialRun;
            return this;
        }

        public GameModeBuilder WithLeaderboardType(Scores.Type leaderboardType)
        {
            _data.leaderboardType = leaderboardType;
            return this;
        }

        public GameModeBuilder WithStartScene(string startScene)
        {
            _data.startScene = startScene;
            return this;
        }

        public GameModeBuilder WithSceneAfterSelection(string sceneAfterSelection = "Campaign")
        {
            _data.sceneAfterSelection = sceneAfterSelection;
            return this;
        }

        public GameModeBuilder WithCampaignSystemNames(params string[] campaignSystemNames)
        {
            _data.campaignSystemNames = campaignSystemNames;
            return this;
        }

        public GameModeBuilder WithSystemsToDisable(params string[] systemsToDisable)
        {
            _data.systemsToDisable = systemsToDisable;
            return this;
        }
    }
    public class GameModifierDataBuilder : DataFileBuilder<GameModifierData, GameModifierDataBuilder>
    {
        public GameModifierDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public GameModifierDataBuilder()
        {
        }

        public GameModifierDataBuilder WithValue(int value = 100)
        {
            _data.value = value;
            return this;
        }

        public GameModifierDataBuilder WithVisible(bool visible = true)
        {
            _data.visible = visible;
            return this;
        }

        public GameModifierDataBuilder WithBellSprite(Sprite bellSprite)
        {
            _data.bellSprite = bellSprite;
            return this;
        }

        public GameModifierDataBuilder WithBellSprite(string bellSprite)
        {
            _data.bellSprite = Mod.GetImageSprite(bellSprite);
            return this;
        }

        public GameModifierDataBuilder WithDingerSprite(Sprite dingerSprite)
        {
            _data.dingerSprite = dingerSprite;
            return this;
        }

        public GameModifierDataBuilder WithDingerSprite(string dingerSprite)
        {
            _data.dingerSprite = Mod.GetImageSprite(dingerSprite);
            return this;
        }

        public GameModifierDataBuilder WithTitle(LocalizedString title)
        {
            _data.titleKey = title;
            return this;
        }

        public GameModifierDataBuilder WithTitle(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_modifier_title", title);
            _data.titleKey = collection.GetString((_data).name + "_modifier_title");
            return this;
        }

        public GameModifierDataBuilder WithDescription(LocalizedString title)
        {
            _data.descriptionKey = title;
            return this;
        }

        public GameModifierDataBuilder WithDescription(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Cards", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_modifier_desc", title);
            _data.descriptionKey = collection.GetString((_data).name + "_modifier_desc");
            return this;
        }

        public GameModifierDataBuilder WithSystemsToAdd(params string[] systemsToAdd)
        {
            _data.systemsToAdd = systemsToAdd;
            return this;
        }

        public GameModifierDataBuilder WithSetupScripts(params Script[] setupScripts)
        {
            _data.setupScripts = setupScripts;
            return this;
        }

        public GameModifierDataBuilder WithStartScripts(params Script[] startScripts)
        {
            _data.startScripts = startScripts;
            return this;
        }

        public GameModifierDataBuilder WithScriptPriority(int scriptPriority)
        {
            _data.scriptPriority = scriptPriority;
            return this;
        }

        public GameModifierDataBuilder WithBlockedBy(params GameModifierData[] blockedBy)
        {
            _data.blockedBy = blockedBy;
            return this;
        }

        public GameModifierDataBuilder WithLinkedStormBell(HardModeModifierData linkedStormBell)
        {
            _data.linkedStormBell = linkedStormBell;
            return this;
        }

        public GameModifierDataBuilder WithRingSfxEvent(EventReference ringSfxEvent)
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            _data.ringSfxEvent = ringSfxEvent;
            return this;
        }

        public GameModifierDataBuilder WithRingSfxPitch()
        {
            //IL_0010: Unknown result type (might be due to invalid IL or missing references)
            //IL_0015: Unknown result type (might be due to invalid IL or missing references)
            _data.ringSfxPitch = new Vector2(1f, 1f);
            return this;
        }

        public GameModifierDataBuilder WithRingSfxPitch(Vector2 ringSfxPitch)
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            _data.ringSfxPitch = ringSfxPitch;
            return this;
        }
    }
    public class KeywordDataBuilder : DataFileBuilder<KeywordData, KeywordDataBuilder>
    {
        public KeywordDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public KeywordDataBuilder()
        {
        }

        public KeywordDataBuilder WithTitle(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Tooltips", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_title", title);
            _data.titleKey = collection.GetString((_data).name + "_title");
            return this;
        }

        public KeywordDataBuilder WithDescription(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Tooltips", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_desc", title);
            _data.descKey = collection.GetString((_data).name + "_desc");
            return this;
        }

        public KeywordDataBuilder WithTitleColour(Color? theColour = null)
        {
            //IL_0031: Unknown result type (might be due to invalid IL or missing references)
            //IL_0036: Unknown result type (might be due to invalid IL or missing references)
            //IL_001f: Unknown result type (might be due to invalid IL or missing references)
            if (!theColour.HasValue)
            {
                theColour = new Color(1f, 0.7921569f, 0.3411765f, 1f);
            }
            _data.titleColour = theColour.Value;
            return this;
        }

        public KeywordDataBuilder WithBodyColour(Color? theColour = null)
        {
            //IL_001d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0022: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            if (!theColour.HasValue)
            {
                theColour = Color.white;
            }
            _data.bodyColour = theColour.Value;
            return this;
        }

        public KeywordDataBuilder WithNoteColour(Color? theColour = null)
        {
            //IL_001d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0022: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            if (!theColour.HasValue)
            {
                theColour = Color.gray;
            }
            _data.noteColour = theColour.Value;
            return this;
        }

        public KeywordDataBuilder WithPanelColour(Color theColour)
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            _data.panelColor = theColour;
            return this;
        }

        public KeywordDataBuilder WithPanelSprite(string image)
        {
            _data.panelSprite = Mod.GetImageSprite(image);
            return this;
        }

        public KeywordDataBuilder WithIconName(string iconName)
        {
            _data.iconName = iconName;
            return this;
        }

        public KeywordDataBuilder WithIconTint(Color hexColor)
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            _data.iconTintHex = ColorExt.ToHexRGB(hexColor);
            return this;
        }

        public KeywordDataBuilder WithShow(bool show = true)
        {
            _data.show = show;
            return this;
        }

        public KeywordDataBuilder WithShowName(bool show)
        {
            _data.showName = show;
            return this;
        }

        public KeywordDataBuilder WithShowIcon(bool show = true)
        {
            _data.showIcon = show;
            return this;
        }

        public KeywordDataBuilder WithCanStack(bool show)
        {
            _data.canStack = show;
            return this;
        }
    }
    public static class LocalizationHelper
    {
        [HarmonyPatch(typeof(LocalizedString), "GetLocalizedString", new Type[] { })]
        public class PatchLocalie1
        {
            [HarmonyPostfix]
            public static void Postfix(ref string __result, LocalizedString __instance)
            {
                //IL_000a: Unknown result type (might be due to invalid IL or missing references)
                //IL_000f: Unknown result type (might be due to invalid IL or missing references)
                //IL_001c: Unknown result type (might be due to invalid IL or missing references)
                //IL_0028: Unknown result type (might be due to invalid IL or missing references)
                //IL_002d: Unknown result type (might be due to invalid IL or missing references)
                //IL_0031: Unknown result type (might be due to invalid IL or missing references)
                //IL_0037: Invalid comparison between Unknown and I4
                //IL_0056: Unknown result type (might be due to invalid IL or missing references)
                //IL_005b: Unknown result type (might be due to invalid IL or missing references)
                //IL_0040: Unknown result type (might be due to invalid IL or missing references)
                //IL_0045: Unknown result type (might be due to invalid IL or missing references)
                if (string.IsNullOrEmpty(__result))
                {
                    TableReference tableReference = ((LocalizedReference)__instance).TableReference;
                    StringTable collection = GetCollection(((tableReference)).TableCollectionName, LocalizationSettings.SelectedLocale.Identifier);
                    TableEntryReference tableEntryReference = ((LocalizedReference)__instance).TableEntryReference;
                    long num;
                    if ((int)((tableEntryReference)).ReferenceType != 2)
                    {
                        SharedTableData sharedData = ((LocalizationTable)collection).SharedData;
                        tableEntryReference = ((LocalizedReference)__instance).TableEntryReference;
                        num = sharedData.GetId(((tableEntryReference)).Key);
                    }
                    else
                    {
                        tableEntryReference = ((LocalizedReference)__instance).TableEntryReference;
                        num = ((tableEntryReference)).KeyId;
                    }
                    long num2 = num;
                    StringTableEntry val = default(StringTableEntry);
                    if (((DetailedLocalizationTable<StringTableEntry>)(object)collection).TryGetValue(num2, ref val))
                    {
                        __result = val.Value;
                    }
                }
            }
        }

        [HarmonyPatch(typeof(LocalizedStringDatabase), "GenerateLocalizedString", new Type[]
        {
            typeof(StringTable),
            typeof(StringTableEntry),
            typeof(TableReference),
            typeof(TableEntryReference),
            typeof(Locale),
            typeof(IList<object>)
        })]
        public class PatchLocalie2
        {
            [HarmonyPostfix]
            public static void Postfix(ref string __result, LocalizedStringDatabase __instance, StringTable table, StringTableEntry entry, TableReference tableReference, TableEntryReference tableEntryReference, Locale locale, IList<object> arguments)
            {
                //IL_0012: Unknown result type (might be due to invalid IL or missing references)
                //IL_001f: Unknown result type (might be due to invalid IL or missing references)
                //IL_0025: Invalid comparison between Unknown and I4
                if (string.IsNullOrEmpty(__result))
                {
                    StringTable collection = GetCollection(((tableReference)).TableCollectionName, locale.Identifier);
                    long num = (((int)((tableEntryReference)).ReferenceType == 2) ? ((tableEntryReference)).KeyId : ((LocalizationTable)collection).SharedData.GetId(((tableEntryReference)).Key));
                    StringTableEntry val = default(StringTableEntry);
                    if (((DetailedLocalizationTable<StringTableEntry>)(object)collection).TryGetValue(num, ref val))
                    {
                        __result = val.Value;
                    }
                }
            }
        }

        [HarmonyPatch(typeof(LocalizedStringDatabase), "GetLocalizedString", new Type[]
        {
            typeof(TableReference),
            typeof(TableEntryReference),
            typeof(IList<object>),
            typeof(Locale),
            typeof(FallbackBehavior)
        })]
        public class PatchLocalie3
        {
            [HarmonyPostfix]
            public static void Postfix(ref string __result, LocalizedStringDatabase __instance, TableReference tableReference, TableEntryReference tableEntryReference, IList<object> arguments, Locale locale = null, FallbackBehavior fallbackBehavior = 0)
            {
                //IL_0023: Unknown result type (might be due to invalid IL or missing references)
                //IL_0030: Unknown result type (might be due to invalid IL or missing references)
                //IL_0036: Invalid comparison between Unknown and I4
                if (string.IsNullOrEmpty(__result))
                {
                    if (locale == null)
                    {
                        locale = LocalizationSettings.SelectedLocale;
                    }
                    StringTable collection = GetCollection(((tableReference)).TableCollectionName, locale.Identifier);
                    long num = (((int)((tableEntryReference)).ReferenceType == 2) ? ((tableEntryReference)).KeyId : ((LocalizationTable)collection).SharedData.GetId(((tableEntryReference)).Key));
                    StringTableEntry val = default(StringTableEntry);
                    if (((DetailedLocalizationTable<StringTableEntry>)(object)collection).TryGetValue(num, ref val))
                    {
                        __result = val.Value;
                    }
                }
            }
        }

        public static readonly Dictionary<string, StringTable> stringTables;

        public static Harmony _harmony;

        public static Locale TryAddLocale(LocaleIdentifier locali)
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_0008: Unknown result type (might be due to invalid IL or missing references)
            //IL_002b: Unknown result type (might be due to invalid IL or missing references)
            if (LocalizationSettings.AvailableLocales.Locales.All((Locale a) => a.Identifier != locali))
            {
                Locale val = Locale.CreateLocale(locali);
                val.SortOrder = (ushort)LocalizationSettings.AvailableLocales.Locales.Count;
                LocalizationSettings.AvailableLocales.Locales.Add(val);
                return val;
            }
            return LocalizationSettings.AvailableLocales.Locales.Find((Locale a) => a.Identifier == locali);
        }

        static LocalizationHelper()
        {
            //IL_000f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0019: Expected O, but got Unknown
            stringTables = new Dictionary<string, StringTable>();
            _harmony = new Harmony("wildfrost");
            _harmony.PatchAll(typeof(LocalizationHelper).Assembly);
        }

        public static StringTable GetCollection(string name, LocaleIdentifier identifier)
        {
            //IL_0014: Unknown result type (might be due to invalid IL or missing references)
            //IL_0019: Unknown result type (might be due to invalid IL or missing references)
            //IL_004d: Unknown result type (might be due to invalid IL or missing references)
            //IL_005b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0060: Unknown result type (might be due to invalid IL or missing references)
            //IL_006e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0073: Unknown result type (might be due to invalid IL or missing references)
            string text = name + "_" + ((identifier)).Code;
            StringTable val = Addressables.LoadAssetAsync<StringTable>((object)text).WaitForCompletion();
            if (val == null)
            {
                if (stringTables.TryGetValue(text, out var value))
                {
                    return value;
                }
                StringTable val2 = ScriptableObject.CreateInstance<StringTable>();
                (val2).name = text;
                ((LocalizationTable)val2).LocaleIdentifier = identifier;
                LocaleIdentifier val3 = new LocaleIdentifier((SystemLanguage)10);
                StringTable val4 = Addressables.LoadAssetAsync<StringTable>((object)(name + "_" + ((val3)).Code)).WaitForCompletion();
                ((LocalizationTable)val2).SharedData = ((LocalizationTable)val4).SharedData;
                stringTables.Add(text, val2);
                return val2;
            }
            return val;
        }

        public static LocalizedString GetString(this StringTable table, string key)
        {
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0011: Unknown result type (might be due to invalid IL or missing references)
            //IL_0012: Unknown result type (might be due to invalid IL or missing references)
            //IL_0014: Unknown result type (might be due to invalid IL or missing references)
            //IL_001f: Expected O, but got Unknown
            TableReference val = TableReference.op_Implicit(((LocalizationTable)table).TableCollectionName);
            LocalizedString val2 = new LocalizedString();
            ((LocalizedReference)val2).SetReference(val, TableEntryReference.op_Implicit(key));
            return val2;
        }

        public static void SetString(this StringTable table, string key, string value)
        {
            long id = ((LocalizationTable)table).SharedData.GetId(key);
            if (id == 0L)
            {
                id = ((LocalizationTable)table).SharedData.AddKey(key).Id;
            }
            if (!((DetailedLocalizationTable<StringTableEntry>)(object)table).ContainsKey(id))
            {
                ((DetailedLocalizationTable<StringTableEntry>)(object)table).AddEntry(key, value);
            }
            else
            {
                ((DetailedLocalizationTable<StringTableEntry>)(object)table)[id].Value = value;
            }
        }
    }
    public class ModsSceneManager : MonoBehaviour
    {
        [SerializeField]
        public GameObject Content;

        [SerializeField]
        public GameObject ModPrefab;

        public List<WildfrostMod> instantiatedMods = new List<WildfrostMod>();

        public IEnumerator Start()
        {
            foreach (WildfrostMod mod in Bootstrap.Mods)
            {
                if (!instantiatedMods.Contains(mod))
                {
                    GameObject val = ObjectExt.InstantiateKeepName<GameObject>(ModPrefab);
                    val.transform.SetParent(Content.transform);
                    TransformExt.SetLocalZ(val.transform, 0f);
                    val.transform.SetLocalPositionAndRotation(val.transform.localPosition, Quaternion.identity);
                    ModHolder componentInChildren = val.GetComponentInChildren<ModHolder>();
                    componentInChildren.Mod = mod;
                    componentInChildren.UpdateInfo();
                    instantiatedMods.Add(mod);
                }
            }
            Time.timeScale = 1f;
            yield break;
        }
    }
    public class StatusEffectDataBuilder : DataFileBuilder<StatusEffectData, StatusEffectDataBuilder>
    {
        public StatusEffectDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public StatusEffectDataBuilder()
        {
        }

        public StatusEffectDataBuilder WithIsStatus(bool value)
        {
            _data.isStatus = value;
            return this;
        }

        public StatusEffectDataBuilder WithIsReaction(bool value)
        {
            _data.isReaction = value;
            return this;
        }

        public StatusEffectDataBuilder WithIsKeyword(bool value)
        {
            _data.isKeyword = value;
            return this;
        }

        public StatusEffectDataBuilder WithType(string type)
        {
            _data.type = type;
            return this;
        }

        public StatusEffectDataBuilder WithKeyword(string type)
        {
            _data.keyword = type;
            return this;
        }

        public StatusEffectDataBuilder WithIconGroupName(string type)
        {
            _data.iconGroupName = type;
            return this;
        }

        public StatusEffectDataBuilder WithVisible(bool value)
        {
            _data.visible = value;
            return this;
        }

        public StatusEffectDataBuilder WithStackable(bool value)
        {
            _data.stackable = value;
            return this;
        }

        public StatusEffectDataBuilder WithOffensive(bool value)
        {
            _data.offensive = value;
            return this;
        }

        public StatusEffectDataBuilder WithMakesOffensive(bool value)
        {
            _data.makesOffensive = value;
            return this;
        }

        public StatusEffectDataBuilder WithDoesDamage(bool value)
        {
            _data.doesDamage = value;
            return this;
        }

        public StatusEffectDataBuilder WithCanBeBoosted(bool value)
        {
            _data.canBeBoosted = value;
            return this;
        }

        public StatusEffectDataBuilder WithText(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("Card Text", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_text", title);
            _data.textKey = collection.GetString((_data).name + "_text");
            return this;
        }

        public StatusEffectDataBuilder WithTextInsert(string value)
        {
            _data.textInsert = value;
            return this;
        }

        public StatusEffectDataBuilder WithOrder(int order)
        {
            _data.textOrder = order;
            return this;
        }
    }
    public class TraitDataBuilder : DataFileBuilder<TraitData, TraitDataBuilder>
    {
        public TraitDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public TraitDataBuilder()
        {
        }

        public TraitDataBuilder WithKeyword(KeywordData data)
        {
            _data.keyword = data;
            return this;
        }

        public TraitDataBuilder WithEffects(params StatusEffectData[] effects)
        {
            _data.effects = effects;
            return this;
        }

        public TraitDataBuilder WithOverrides(params TraitData[] traits)
        {
            _data.overrides = traits;
            return this;
        }

        public TraitDataBuilder WithIsReaction(bool isReaction)
        {
            _data.isReaction = isReaction;
            return this;
        }
    }
    public class UnlockDataBuilder : DataFileBuilder<UnlockData, UnlockDataBuilder>
    {
        public UnlockDataBuilder(WildfrostMod mod)
            : base(mod)
        {
        }

        public UnlockDataBuilder()
        {
        }

        public UnlockDataBuilder WithUnlockDescription(LocalizedString str)
        {
            _data.unlockDesc = str;
            return this;
        }

        public UnlockDataBuilder WithUnlockTitle(LocalizedString str)
        {
            _data.unlockTitle = str;
            return this;
        }

        public UnlockDataBuilder WithUnlockDescription(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("UI Text", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_unlockDesc", title);
            _data.unlockDesc = collection.GetString((_data).name + "_unlockDesc");
            return this;
        }

        public UnlockDataBuilder WithUnlockTitle(string title, SystemLanguage lang = 10)
        {
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            StringTable collection = LocalizationHelper.GetCollection("UI Text", new LocaleIdentifier(lang));
            collection.SetString((_data).name + "_unlockTitle", title);
            _data.unlockTitle = collection.GetString((_data).name + "_unlockTitle");
            return this;
        }

        public UnlockDataBuilder WithRequires(params UnlockData[] requires)
        {
            _data.requires = requires;
            return this;
        }

        public UnlockDataBuilder WithRequires(params string[] requires)
        {
            _data.requires = requires.Select(Mod.Get<UnlockData>).ToArray();
            return this;
        }

        public UnlockDataBuilder WithLowPriority(float priority)
        {
            _data.lowPriority = priority;
            return this;
        }

        public UnlockDataBuilder WithBuilding(BuildingType relatedBuilding)
        {
            _data.relatedBuilding = relatedBuilding;
            SubscribeToBuildEvent(delegate (UnlockData data)
            {
                relatedBuilding.unlocks = CollectionExtensions.AddToArray<UnlockData>(relatedBuilding.unlocks, data);
            });
            return this;
        }

        public UnlockDataBuilder WithBuilding(string relatedBuilding)
        {
            return WithBuilding(Mod.Get<BuildingType>(relatedBuilding));
        }

        public UnlockDataBuilder WithType(UnlockData.Type type)
        {
            _data.type = type;
            return this;
        }
    }
    public class InternalMod : WildfrostMod
    {
        public override string GUID => "wildfrost";

        public override string[] Depends => new string[0];

        public override string Title => "wildfrost";

        public override string Description => "wildfrost";

        public InternalMod(string modDirectory)
            : base(modDirectory)
        {
        }
    }
    public abstract class WildfrostMod : IComparable<WildfrostMod>
    {
        [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
        public sealed class ConfigItemAttribute : Attribute
        {
            public string comment;

            public string forceTitle;

            public string fieldName;

            public string defaultValue;

            public string Title
            {
                get
                {
                    if (!string.IsNullOrEmpty(forceTitle))
                    {
                        return forceTitle;
                    }
                    return fieldName;
                }
            }

            [Obsolete("Use new constructor", true)]
            public ConfigItemAttribute(object defaultValue, string forceTitle = null)
            {
                comment = "";
                this.forceTitle = forceTitle;
                this.defaultValue = TypeDescriptor.GetConverter(defaultValue.GetType()).ConvertToString(defaultValue);
            }

            public ConfigItemAttribute(object defaultValue, string comment = "", string forceTitle = null)
            {
                this.comment = comment;
                this.forceTitle = forceTitle;
                this.defaultValue = TypeDescriptor.GetConverter(defaultValue.GetType()).ConvertToString(defaultValue);
            }
        }

        public struct ConfigStorage
        {
            public class FileIsCorrupted : Exception
            {
                public FileIsCorrupted(string s)
                    : base(s)
                {
                }
            }

            public (ConfigItemAttribute atr, FieldInfo field)[] Store;

            public (string title, string value)[] Read;

            public WildfrostMod Mod;

            public void WriteToFile(string name)
            {
                StringBuilder stringBuilder = new StringBuilder();
                (ConfigItemAttribute, FieldInfo)[] store = Store;
                for (int i = 0; i < store.Length; i++)
                {
                    (ConfigItemAttribute, FieldInfo) tuple = store[i];
                    tuple.Item1.fieldName = tuple.Item2.Name;
                    stringBuilder.AppendLine("//" + tuple.Item1.comment);
                    stringBuilder.AppendLine(tuple.Item2.FieldType.FullName + " : " + tuple.Item1.Title + " = " + tuple.Item1.defaultValue);
                }
                File.WriteAllText(name, stringBuilder.ToString());
            }

            public void ReadFromFile(string name)
            {
                int num = 0;
                while (true)
                {
                    try
                    {
                        IEnumerable<string> enumerable = File.ReadLines(name);
                        (ConfigItemAttribute, FieldInfo)[] store = Store;
                        for (int i = 0; i < store.Length; i++)
                        {
                            (ConfigItemAttribute, FieldInfo) tuple = store[i];
                            tuple.Item1.fieldName = tuple.Item2.Name;
                        }
                        List<(ConfigItemAttribute, FieldInfo)> list = IArrayExt.ToList<(ConfigItemAttribute, FieldInfo)>(Store);
                        foreach (string item in enumerable)
                        {
                            if (item.StartsWith("//"))
                            {
                                continue;
                            }
                            int num2 = item.IndexOf(':');
                            int num3 = item.IndexOf('=');
                            string text = item[..(num2 - 1)];
                            string title = item[(num2 + 2)..(num3 - 1)];
                            string text2 = item[(num3 + 2)..];
                            (ConfigItemAttribute, FieldInfo) tuple2 = list.Find(((ConfigItemAttribute atr, FieldInfo field) a) => a.atr.Title == title);
                            var (configItemAttribute, fieldInfo) = tuple2;
                            if (configItemAttribute == null && fieldInfo == null)
                            {
                                throw new FileIsCorrupted("Config error, no store");
                            }
                            if (tuple2.Item2 == null)
                            {
                                throw new Exception("Config value not found " + tuple2.Item1.Title);
                            }
                            Type type = null;
                            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
                            for (int i = 0; i < assemblies.Length; i++)
                            {
                                Type type2 = assemblies[i].GetType(text);
                                if (type2 != null)
                                {
                                    type = type2;
                                    break;
                                }
                            }
                            if (type == null)
                            {
                                throw new Exception("Unknown value type " + text);
                            }
                            object value = TypeDescriptor.GetConverter(type).ConvertFromInvariantString(text2);
                            tuple2.Item2.SetValue(Mod, value);
                        }
                        break;
                    }
                    catch (FileIsCorrupted)
                    {
                        num++;
                        if (num > 1)
                        {
                            throw;
                        }
                        File.Delete(name);
                        WriteToFile(name);
                    }
                }
            }
        }

        public struct BuilderToBuilt<T, Y> where T : DataFile where Y : DataFileBuilder<T, Y>, new()
        {
            public List<T> built;

            public List<Y> builder;

            public BuilderToBuilt(List<T> dataFiles, List<Y> builders)
            {
                built = dataFiles;
                builder = builders;
            }

            public void OnAfterAllModBuildsEvent()
            {
                for (int i = 0; i < builder.Count; i++)
                {
                    Y val = builder[i];
                    T d = built[i];
                    val.OnAfterAllModBuildsEvent(d);
                }
            }
        }

        public class DebugLoggerTextWriter : TextWriter
        {
            public override Encoding Encoding => Encoding.UTF8;

            public override void Write(string value)
            {
                value = "[HARMONY] " + value;
                Debug.Log(value);
            }

            public override void WriteLine(string value)
            {
                value = "[HARMONY] " + value;
                Debug.Log((value + "\n"));
            }
        }

        public string ModDirectory;

        public Sprite _iconSprite;

        public Harmony HarmonyInstance;

        public static List<Type> AllBuiledrs;

        public static List<Type> AllDataTypes;

        public virtual string IconPath => Path.Combine(ModDirectory, "icon.png");

        public virtual Sprite IconSprite => _iconSprite ??= IconPath.ToSprite();

        public abstract string GUID { get; }

        public abstract string[] Depends { get; }

        public abstract string Title { get; }

        public abstract string Description { get; }

        public bool HasLoaded { get; set; }

        public virtual string ImagesDirectory => Path.Combine(ModDirectory, "images");

        public virtual TMP_SpriteAsset SpriteAsset { get; }

        public T GetAsset<T>(string name)
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            return Addressables.LoadAssetAsync<T>((object)name).WaitForCompletion();
        }

        public Sprite GetImageSprite(string relPath)
        {
            return RelToAbsPath(relPath).ToSprite();
        }

        public string RelToAbsPath(params string[] relPath)
        {
            string[] array = new string[relPath.Length + 1];
            array[0] = ModDirectory;
            for (int i = 1; i < array.Length; i++)
            {
                array[i] = relPath[i - 1];
            }
            return Path.Combine(array);
        }

        public CardData.TraitStacks CreateTraitStack(string name, int amount)
        {
            return new CardData.TraitStacks(Get<TraitData>(name), amount);
        }

        public CardData.StatusEffectStacks CreateEffectStack(string name, int amount)
        {
            return new CardData.StatusEffectStacks(Get<StatusEffectData>(name), amount);
        }

        [Obsolete("Use one without type parameters", true)]
        public CardData.StatusEffectStacks CreateEffectStack<T>(string name, int amount) where T : StatusEffectData
        {
            return new CardData.StatusEffectStacks(Get<StatusEffectData>(name), amount);
        }

        public T Get<T>(string name) where T : DataFile
        {
            string assetName = Extensions.PrefixGUID(name, this);
            T val = AddressableLoader.Get<T>(typeof(T).Name, assetName);
            if ((val))
            {
                return val;
            }
            return AddressableLoader.Get<T>(typeof(T).Name, name);
        }

        public T GetStatusEffect<T>(string name) where T : StatusEffectData
        {
            string assetName = Extensions.PrefixGUID(name, this);
            StatusEffectData statusEffectData = AddressableLoader.Get<StatusEffectData>("StatusEffectData", assetName);
            if ((statusEffectData))
            {
                return (T)statusEffectData;
            }
            return (T)AddressableLoader.Get<StatusEffectData>("StatusEffectData", name);
        }

        public static WildfrostMod[] GetLastMods()
        {
            string[] array = SaveSystem.LoadProgressData<string[]>("lastSavedMods");
            if (array != null)
            {
                return array.Select(Extensions.GetModFromGuid).ToArray();
            }
            return new WildfrostMod[0];
        }

        public static void SetLastMods(WildfrostMod[] enabled)
        {
            string[] value = enabled.Select((WildfrostMod a) => a.GUID).ToArray();
            SaveSystem.SaveProgressData("lastSavedMods", value);
        }

        public ConfigStorage FromConfigs()
        {
            (ConfigItemAttribute, FieldInfo)[] configs = GetConfigs();
            ConfigStorage result = default(ConfigStorage);
            result.Store = configs;
            result.Mod = this;
            return result;
        }

        public (ConfigItemAttribute atr, FieldInfo field)[] GetConfigs()
        {
            List<(ConfigItemAttribute, FieldInfo)> list = new List<(ConfigItemAttribute, FieldInfo)>();
            FieldInfo[] fields = GetType().GetFields(BindingFlags.Instance | BindingFlags.Public);
            foreach (FieldInfo fieldInfo in fields)
            {
                ConfigItemAttribute customAttribute = fieldInfo.GetCustomAttribute<ConfigItemAttribute>();
                if (customAttribute != null)
                {
                    list.Add((customAttribute, fieldInfo));
                }
            }
            return list.ToArray();
        }

        public WildfrostMod(string modDirectory)
            : this()
        {
            ModDirectory = modDirectory;
        }

        public string ImagePath(string fileName)
        {
            return Path.Combine(ImagesDirectory, fileName);
        }

        public WildfrostMod[] GetDependancies(bool throwIfNotFound = true)
        {
            ILookup<string, WildfrostMod> look = Bootstrap.Mods.ToLookup((WildfrostMod a) => a.GUID);
            List<(string, WildfrostMod)> list = Depends.Select((string a) => (a: a, look[a].FirstOrDefault())).ToList();
            if (throwIfNotFound)
            {
                (string, WildfrostMod) tuple = list.Find(((string a, WildfrostMod) a) => a.Item2 == null);
                if (tuple.Item2 == null && !string.IsNullOrEmpty(tuple.Item1))
                {
                    throw new Exception("Mod " + tuple.Item1 + " not found! While it is a dependency for " + GUID);
                }
            }
            return list.Select<(string, WildfrostMod), WildfrostMod>(((string a, WildfrostMod) a) => a.Item2).ToArray();
        }

        public void LoadDependancies()
        {
            WildfrostMod[] dependancies = GetDependancies();
            for (int i = 0; i < dependancies.Length; i++)
            {
                dependancies[i].ModLoad();
            }
        }

        public void UnloadModsDependantOnThis()
        {
            foreach (WildfrostMod item in Bootstrap.Mods.Where((WildfrostMod a) => a.HasLoaded && IArrayExt.Contains<string>(a.Depends, GUID)))
            {
                item.ModUnload();
            }
        }

        public void ModLoad()
        {
            if (!HasLoaded)
            {
                LoadDependancies();
                ConfigStorage configStorage = FromConfigs();
                string text = Path.Combine(ModDirectory, "config.cfg");
                if (!File.Exists(text))
                {
                    configStorage.WriteToFile(text);
                }
                configStorage.ReadFromFile(text);
                Load();
                UpdateSave();
                Events.InvokeModLoaded(this);
            }
        }

        public void UpdateSave()
        {
            SetLastMods(Bootstrap.Mods.ToList().FindAll((WildfrostMod a) => a.HasLoaded).ToArray());
        }

        public void ModToggle()
        {
            if (HasLoaded)
            {
                ModUnload();
            }
            else if (!HasLoaded)
            {
                ModLoad();
            }
        }

        public virtual void Load()
        {
            HarmonyInstance.PatchAll(GetType().Assembly);
            List<Type> allBuiledrs = AllBuiledrs;
            List<Type> allDataTypes = AllDataTypes;
            Dictionary<Type, object> dictionary = new Dictionary<Type, object>();
            foreach (Type dataType2 in allDataTypes)
            {
                Type type = allBuiledrs.Find((Type a) => a.BaseType.GetGenericArguments()[0] == dataType2);
                if (!(type == null))
                {
                    object value = typeof(WildfrostMod).GetMethod("AddAllTAssetsToGroup", BindingFlags.Instance | BindingFlags.NonPublic).MakeGenericMethod(dataType2, type).Invoke(this, new object[0]);
                    dictionary.Add(dataType2, value);
                }
            }
            foreach (Type dataType in allDataTypes)
            {
                Type type2 = allBuiledrs.Find((Type a) => a.BaseType.GetGenericArguments()[0] == dataType);
                if (!(type2 == null))
                {
                    object obj = dictionary[dataType];
                    typeof(BuilderToBuilt<,>).MakeGenericType(dataType, type2).GetMethod("OnAfterAllModBuildsEvent", BindingFlags.Instance | BindingFlags.Public).Invoke(obj, new object[0]);
                }
            }
            HasLoaded = true;
        }

        public BuilderToBuilt<T, Y> AddAllTAssetsToGroup<T, Y>() where T : DataFile where Y : DataFileBuilder<T, Y>, new()
        {
            List<Y> list = AddAssets<Y, T>();
            if (list == null)
            {
                BuilderToBuilt<T, Y> result = default(BuilderToBuilt<T, Y>);
                result.builder = new List<Y>();
                result.built = new List<T>();
                return result;
            }
            List<T> list2 = list.Select((Y a) => a.Build()).ToList();
            if (list2 != null)
            {
                foreach (T item in list2)
                {
                    item.ModAdded = this;
                    if (item is CardData cardData && !(cardData.targetMode))
                    {
                        throw new Exception("Card must have a target mode " + (cardData).name);
                    }
                }
                AddressableLoader.AddRangeToGroup(typeof(T).Name, list2);
            }
            return new BuilderToBuilt<T, Y>(list2, list);
        }

        [CanBeNull]
        public virtual List<T> AddAssets<T, Y>() where T : DataFileBuilder<Y, T>, new() where Y : DataFile
        {
            return null;
        }

        public void ModUnload()
        {
            if (HasLoaded)
            {
                Unload();
                UnloadModsDependantOnThis();
                UpdateSave();
                Events.InvokeModUnloaded(this);
            }
        }

        public virtual void Unload()
        {
            if (!HasLoaded)
            {
                return;
            }
            HarmonyInstance.UnpatchAll(HarmonyInstance.Id);
            HasLoaded = false;
            foreach (Type item in IArrayExt.ToList<Type>(typeof(WildfrostMod).Assembly.GetTypes()).FindAll((Type a) => a.BaseType == typeof(DataFile)))
            {
                typeof(WildfrostMod).GetMethod("RemoveeAllTAssetsFromGroup", BindingFlags.Instance | BindingFlags.NonPublic).MakeGenericMethod(item).Invoke(this, new object[0]);
            }
        }

        public void RemoveeAllTAssetsFromGroup<T>() where T : DataFile
        {
            T[] array = Object.FindObjectsOfType<T>();
            foreach (T val in array)
            {
                if (val.ModAdded == this)
                {
                    if (val is CardData inst)
                    {
                        inst.RemoveFromPets();
                    }
                    AddressableLoader.RemoveFromGroup(typeof(T).Name, val);
                    ObjectExt.Destroy(val);
                }
            }
        }

        public WildfrostMod()
        {
            //IL_000d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0017: Expected O, but got Unknown
            HarmonyInstance = new Harmony(GUID);
        }

        static WildfrostMod()
        {
            AllBuiledrs = IArrayExt.ToList<Type>(typeof(WildfrostMod).Assembly.GetTypes()).FindAll(delegate (Type a)
            {
                Type baseType = a.BaseType;
                return (object)baseType != null && baseType.IsGenericType && a.BaseType.GetGenericTypeDefinition() == typeof(DataFileBuilder<,>);
            });
            AllDataTypes = IArrayExt.ToList<Type>(typeof(WildfrostMod).Assembly.GetTypes()).FindAll((Type a) => a.BaseType == typeof(DataFile));
            Harmony.DEBUG = true;
            HarmonyFileLog.Enabled = true;
            Logger.ChannelFilter = (LogChannel)34;
            HarmonyFileLog.Writer = new DebugLoggerTextWriter();
        }

        public void WriteLine(string text)
        {
            Debug.Log(("[" + GUID + "] " + text));
        }

        public void WriteWarn(string text)
        {
            Debug.LogWarning(("[" + GUID + "] " + text));
        }

        public void WriteError(string text)
        {
            Debug.LogError(("[" + GUID + "] " + text));
        }

        public int CompareTo(WildfrostMod other)
        {
            if (this == other)
            {
                return 0;
            }
            if (other == null)
            {
                return 1;
            }
            return string.Compare(GUID, other.GUID, StringComparison.Ordinal);
        }

        public async void UpdateOrPublishWorkshop()
        {
            Query val = new Query((UgcType)0, (UserUGCList)0, (UserUGCListSortOrder)0, SteamClient.SteamId, (AppId?)null, (AppId?)null);
            val = ((val)).WithMetadata(true);
            Query val2 = ((val)).WithTag("Mod");
            ResultPage value = (await ((val2)).GetPageAsync(1)).Value;
            List<Item> entries = ((value)).Entries.ToList().FindAll((Item a) => (int)((a)).Result != 9);
            Item curItem = entries.Find((Item a) => ((a)).Metadata == GUID);
            Item val3;
            Editor val4;
            PublishResult result;
            string[] depends;
            if (entries.Count != 0)
            {
                val3 = default(Item);
                if (!((object)(curItem)).Equals((object?)val3))
                {
                    val4 = new Editor(((curItem)).Id);
                    val4 = ((val4)).WithTitle(Title);
                    val4 = ((val4)).WithDescription(Description);
                    val4 = ((val4)).WithTag("Mod");
                    val4 = ((val4)).ForAppId(SteamClient.AppId);
                    val4 = ((val4)).WithPublicVisibility();
                    val4 = ((val4)).WithPreviewFile(IconPath);
                    val4 = ((val4)).WithContent(ModDirectory);
                    val4 = ((val4)).WithMetaData(GUID);
                    result = await ((val4)).SubmitAsync((IProgress<float>)null, (System.Action<PublishResult>)null);
                    Item? val5 = await Item.GetAsync(result.FileId, true, 0);
                    depends = Depends;
                    foreach (string depend2 in depends)
                    {
                        Item val6 = entries.Find((Item a) => ((a)).Metadata == depend2);
                        val3 = default(Item);
                        if (!((object)(curItem)).Equals((object?)val3) && val5.HasValue)
                        {
                            val3 = val5.GetValueOrDefault();
                            ((val3)).AddDependency(((val6)).Id);
                        }
                    }
                    Debug.Log(("Update result " + ((object)(result)).ToString()));
                    result = default(PublishResult);
                    return;
                }
            }
            val4 = Editor.NewCommunityFile;
            val4 = ((val4)).WithTitle(Title);
            val4 = ((val4)).WithDescription(Description);
            val4 = ((val4)).WithTag("Mod");
            val4 = ((val4)).ForAppId(SteamClient.AppId);
            val4 = ((val4)).WithPublicVisibility();
            val4 = ((val4)).WithPreviewFile(IconPath);
            val4 = ((val4)).WithContent(ModDirectory);
            val4 = ((val4)).WithMetaData(GUID);
            result = await ((val4)).SubmitAsync((IProgress<float>)null, (System.Action<PublishResult>)null);
            Item? val7 = await Item.GetAsync(result.FileId, true, 0);
            depends = Depends;
            foreach (string depend in depends)
            {
                Item val8 = entries.Find((Item a) => ((a)).Metadata == depend);
                val3 = default(Item);
                if (!((object)(curItem)).Equals((object?)val3) && val7.HasValue)
                {
                    val3 = val7.GetValueOrDefault();
                    ((val3)).AddDependency(((val8)).Id);
                }
            }
            Debug.Log(("Upload result " + ((object)(result)).ToString()));
            result = default(PublishResult);
        }
    }
}
namespace UnityEngine.UI.Extensions
{
    [AddComponentMenu("Layout/Extensions/Flow Layout Group")]
    public class FlowLayoutGroup : LayoutGroup
    {
        public enum Axis
        {
            Horizontal,
            Vertical
        }

        public float SpacingX;

        public float SpacingY;

        public bool ExpandHorizontalSpacing;

        public bool ChildForceExpandWidth;

        public bool ChildForceExpandHeight;

        public bool invertOrder;

        public float _layoutHeight;

        public float _layoutWidth;

        public float maxWidth = 20f;

        public float maxHeight = 10f;

        [SerializeField]
        public Axis m_StartAxis;

        public readonly IList<RectTransform> _itemList = new List<RectTransform>();

        public Axis startAxis
        {
            get
            {
                return m_StartAxis;
            }
            set
            {
                SetProperty<Axis>(ref m_StartAxis, value);
            }
        }

        public bool IsCenterAlign
        {
            get
            {
                //IL_0001: Unknown result type (might be due to invalid IL or missing references)
                //IL_0007: Invalid comparison between Unknown and I4
                //IL_000a: Unknown result type (might be due to invalid IL or missing references)
                //IL_0010: Invalid comparison between Unknown and I4
                //IL_0013: Unknown result type (might be due to invalid IL or missing references)
                //IL_0019: Invalid comparison between Unknown and I4
                if ((int)childAlignment != 7 && (int)childAlignment != 4)
                {
                    return (int)childAlignment == 1;
                }
                return true;
            }
        }

        public bool IsRightAlign
        {
            get
            {
                //IL_0001: Unknown result type (might be due to invalid IL or missing references)
                //IL_0007: Invalid comparison between Unknown and I4
                //IL_000a: Unknown result type (might be due to invalid IL or missing references)
                //IL_0010: Invalid comparison between Unknown and I4
                //IL_0013: Unknown result type (might be due to invalid IL or missing references)
                //IL_0019: Invalid comparison between Unknown and I4
                if ((int)childAlignment != 8 && (int)childAlignment != 5)
                {
                    return (int)childAlignment == 2;
                }
                return true;
            }
        }

        public bool IsMiddleAlign
        {
            get
            {
                //IL_0001: Unknown result type (might be due to invalid IL or missing references)
                //IL_0007: Invalid comparison between Unknown and I4
                //IL_000a: Unknown result type (might be due to invalid IL or missing references)
                //IL_0010: Invalid comparison between Unknown and I4
                //IL_0013: Unknown result type (might be due to invalid IL or missing references)
                //IL_0019: Invalid comparison between Unknown and I4
                if ((int)childAlignment != 3 && (int)childAlignment != 5)
                {
                    return (int)childAlignment == 4;
                }
                return true;
            }
        }

        public bool IsLowerAlign
        {
            get
            {
                //IL_0001: Unknown result type (might be due to invalid IL or missing references)
                //IL_0007: Invalid comparison between Unknown and I4
                //IL_000a: Unknown result type (might be due to invalid IL or missing references)
                //IL_0010: Invalid comparison between Unknown and I4
                //IL_0013: Unknown result type (might be due to invalid IL or missing references)
                //IL_0019: Invalid comparison between Unknown and I4
                if ((int)childAlignment != 6 && (int)childAlignment != 8)
                {
                    return (int)childAlignment == 7;
                }
                return true;
            }
        }

        public override void CalculateLayoutInputHorizontal()
        {
            if (startAxis == Axis.Horizontal)
            {
                CalculateLayoutInputHorizontal();
                float num = GetGreatestMinimumChildWidth() + (float)padding.left + (float)padding.right;
                SetLayoutInputForAxis(num, -1f, -1f, 0);
            }
            else
            {
                _layoutWidth = SetLayout(0, layoutInput: true);
            }
        }

        public override void SetLayoutHorizontal()
        {
            SetLayout(0, layoutInput: false);
        }

        public override void SetLayoutVertical()
        {
            SetLayout(1, layoutInput: false);
        }

        public override void CalculateLayoutInputVertical()
        {
            if (startAxis == Axis.Horizontal)
            {
                _layoutHeight = SetLayout(1, layoutInput: true);
                return;
            }
            CalculateLayoutInputHorizontal();
            float num = GetGreatestMinimumChildHeigth() + (float)padding.bottom + (float)padding.top;
            SetLayoutInputForAxis(num, -1f, -1f, 1);
        }

        public float SetLayout(int axis, bool layoutInput)
        {
            //IL_000f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0014: Unknown result type (might be due to invalid IL or missing references)
            //IL_0034: Unknown result type (might be due to invalid IL or missing references)
            //IL_0039: Unknown result type (might be due to invalid IL or missing references)
            //IL_048c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0492: Unknown result type (might be due to invalid IL or missing references)
            //IL_046e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0474: Unknown result type (might be due to invalid IL or missing references)
            Rect rect;
            float height;
            if (startAxis != Axis.Vertical)
            {
                rect = rectTransform.rect;
                height = ((rect)).height;
            }
            else
            {
                height = maxHeight;
            }
            float num = height;
            float width;
            if (startAxis != 0)
            {
                rect = rectTransform.rect;
                width = ((rect)).width;
            }
            else
            {
                width = maxWidth;
            }
            float num2 = width;
            float num3 = 0f;
            float num4 = 0f;
            float num5 = 0f;
            float num6 = 0f;
            float num7 = 0f;
            float num8 = 0f;
            float num9 = 0f;
            if (startAxis == Axis.Horizontal)
            {
                num8 = num;
                num9 = num2 - (float)padding.left - (float)padding.right;
                if (IsLowerAlign)
                {
                    num6 = padding.bottom;
                    num7 = padding.top;
                }
                else
                {
                    num6 = padding.top;
                    num7 = padding.bottom;
                }
                num4 = SpacingY;
                num5 = SpacingX;
            }
            else if (startAxis == Axis.Vertical)
            {
                num8 = num2;
                num9 = num - (float)padding.top - (float)padding.bottom;
                if (IsRightAlign)
                {
                    num6 = padding.right;
                    num7 = padding.left;
                }
                else
                {
                    num6 = padding.left;
                    num7 = padding.right;
                }
                num4 = SpacingX;
                num5 = SpacingY;
            }
            float num10 = 0f;
            float num11 = 0f;
            for (int i = 0; i < rectChildren.Count; i++)
            {
                int index = i;
                RectTransform val = rectChildren[index];
                float num12 = 0f;
                float num13 = 0f;
                if (startAxis == Axis.Horizontal)
                {
                    if (invertOrder)
                    {
                        index = (IsLowerAlign ? (rectChildren.Count - 1 - i) : i);
                    }
                    val = rectChildren[index];
                    num12 = LayoutUtility.GetPreferredSize(val, 0);
                    num12 = Mathf.Min(num12, num9);
                    num13 = LayoutUtility.GetPreferredSize(val, 1);
                    num13 = Mathf.Min(num13, num9);
                }
                else if (startAxis == Axis.Vertical)
                {
                    if (invertOrder)
                    {
                        index = (IsRightAlign ? (rectChildren.Count - 1 - i) : i);
                    }
                    val = rectChildren[index];
                    num12 = LayoutUtility.GetPreferredSize(val, 1);
                    num12 = Mathf.Min(num12, num9);
                    num13 = LayoutUtility.GetPreferredSize(val, 0);
                    num13 = Mathf.Min(num13, num9);
                }
                if (num10 + num12 > num9)
                {
                    num10 -= num5;
                    if (!layoutInput)
                    {
                        if (startAxis == Axis.Horizontal)
                        {
                            float yOffset = CalculateRowVerticalOffset(num8, num6, num11);
                            LayoutRow(_itemList, num10, num11, num9, padding.left, yOffset, axis);
                        }
                        else if (startAxis == Axis.Vertical)
                        {
                            float xOffset = CalculateColHorizontalOffset(num8, num6, num11);
                            LayoutCol(_itemList, num11, num10, num9, xOffset, padding.top, axis);
                        }
                    }
                    _itemList.Clear();
                    num3 = Mathf.Max(num3, num10);
                    num6 += num11;
                    num6 += num4;
                    num11 = 0f;
                    num10 = 0f;
                }
                num10 += num12;
                _itemList.Add(val);
                if (num13 > num11)
                {
                    num11 = num13;
                }
                if (i < rectChildren.Count - 1)
                {
                    num10 += num5;
                }
            }
            if (!layoutInput)
            {
                if (startAxis == Axis.Horizontal)
                {
                    float yOffset2 = CalculateRowVerticalOffset(num, num6, num11);
                    num10 -= num5;
                    LayoutRow(_itemList, num10, num11, num9 - (ChildForceExpandWidth ? 0f : num5), padding.left, yOffset2, axis);
                }
                else if (startAxis == Axis.Vertical)
                {
                    float xOffset2 = CalculateColHorizontalOffset(num2, num6, num11);
                    num10 -= num5;
                    LayoutCol(_itemList, num11, num10, num9 - (ChildForceExpandHeight ? 0f : num5), xOffset2, padding.top, axis);
                }
            }
            _itemList.Clear();
            num3 = Mathf.Max(num3, num10);
            num6 += num11;
            num6 += num7;
            if (layoutInput)
            {
                SetLayoutInputForAxis(num6, num6, -1f, axis);
            }
            if (startAxis == Axis.Vertical)
            {
                rectTransform.sizeDelta = Vector2Ext.WithY(rectTransform.sizeDelta, num3);
            }
            else
            {
                rectTransform.sizeDelta = Vector2Ext.WithX(rectTransform.sizeDelta, num3);
            }
            return num6;
        }

        public float CalculateRowVerticalOffset(float groupHeight, float yOffset, float currentRowHeight)
        {
            if (IsLowerAlign)
            {
                return groupHeight - yOffset - currentRowHeight;
            }
            if (IsMiddleAlign)
            {
                return groupHeight * 0.5f - _layoutHeight * 0.5f + yOffset;
            }
            return yOffset;
        }

        public float CalculateColHorizontalOffset(float groupWidth, float xOffset, float currentColWidth)
        {
            if (IsRightAlign)
            {
                return groupWidth - xOffset - currentColWidth;
            }
            if (IsCenterAlign)
            {
                return groupWidth * 0.5f - _layoutWidth * 0.5f + xOffset;
            }
            return xOffset;
        }

        public void LayoutRow(IList<RectTransform> contents, float rowWidth, float rowHeight, float maxWidth, float xOffset, float yOffset, int axis)
        {
            float num = xOffset;
            if (!ChildForceExpandWidth && IsCenterAlign)
            {
                num += (maxWidth - rowWidth) * 0.5f;
            }
            else if (!ChildForceExpandWidth && IsRightAlign)
            {
                num += maxWidth - rowWidth;
            }
            float num2 = 0f;
            float num3 = 0f;
            if (ChildForceExpandWidth)
            {
                num2 = (maxWidth - rowWidth) / (float)_itemList.Count;
            }
            else if (ExpandHorizontalSpacing)
            {
                num3 = (maxWidth - rowWidth) / (float)(_itemList.Count - 1);
                if (_itemList.Count > 1)
                {
                    if (IsCenterAlign)
                    {
                        num -= num3 * 0.5f * (float)(_itemList.Count - 1);
                    }
                    else if (IsRightAlign)
                    {
                        num -= num3 * (float)(_itemList.Count - 1);
                    }
                }
            }
            for (int i = 0; i < _itemList.Count; i++)
            {
                int index = (IsLowerAlign ? (_itemList.Count - 1 - i) : i);
                RectTransform val = _itemList[index];
                float num4 = LayoutUtility.GetPreferredSize(val, 0) + num2;
                float num5 = LayoutUtility.GetPreferredSize(val, 1);
                if (ChildForceExpandHeight)
                {
                    num5 = rowHeight;
                }
                num4 = Mathf.Min(num4, maxWidth);
                float num6 = yOffset;
                if (IsMiddleAlign)
                {
                    num6 += (rowHeight - num5) * 0.5f;
                }
                else if (IsLowerAlign)
                {
                    num6 += rowHeight - num5;
                }
                if (ExpandHorizontalSpacing && i > 0)
                {
                    num += num3;
                }
                if (axis == 0)
                {
                    SetChildAlongAxis(val, 0, num, num4);
                }
                else
                {
                    SetChildAlongAxis(val, 1, num6, num5);
                }
                if (i < _itemList.Count - 1)
                {
                    num += num4 + SpacingX;
                }
            }
        }

        public void LayoutCol(IList<RectTransform> contents, float colWidth, float colHeight, float maxHeight, float xOffset, float yOffset, int axis)
        {
            float num = yOffset;
            if (!ChildForceExpandHeight && IsMiddleAlign)
            {
                num += (maxHeight - colHeight) * 0.5f;
            }
            else if (!ChildForceExpandHeight && IsLowerAlign)
            {
                num += maxHeight - colHeight;
            }
            float num2 = 0f;
            float num3 = 0f;
            if (ChildForceExpandHeight)
            {
                num2 = (maxHeight - colHeight) / (float)_itemList.Count;
            }
            else if (ExpandHorizontalSpacing)
            {
                num3 = (maxHeight - colHeight) / (float)(_itemList.Count - 1);
                if (_itemList.Count > 1)
                {
                    if (IsMiddleAlign)
                    {
                        num -= num3 * 0.5f * (float)(_itemList.Count - 1);
                    }
                    else if (IsLowerAlign)
                    {
                        num -= num3 * (float)(_itemList.Count - 1);
                    }
                }
            }
            for (int i = 0; i < _itemList.Count; i++)
            {
                int index = (IsRightAlign ? (_itemList.Count - 1 - i) : i);
                RectTransform val = _itemList[index];
                float num4 = LayoutUtility.GetPreferredSize(val, 0);
                float num5 = LayoutUtility.GetPreferredSize(val, 1) + num2;
                if (ChildForceExpandWidth)
                {
                    num4 = colWidth;
                }
                num5 = Mathf.Min(num5, maxHeight);
                float num6 = xOffset;
                if (IsCenterAlign)
                {
                    num6 += (colWidth - num4) * 0.5f;
                }
                else if (IsRightAlign)
                {
                    num6 += colWidth - num4;
                }
                if (ExpandHorizontalSpacing && i > 0)
                {
                    num += num3;
                }
                if (axis == 0)
                {
                    SetChildAlongAxis(val, 0, num6, num4);
                }
                else
                {
                    SetChildAlongAxis(val, 1, num, num5);
                }
                if (i < _itemList.Count - 1)
                {
                    num += num5 + SpacingY;
                }
            }
        }

        public float GetGreatestMinimumChildWidth()
        {
            float num = 0f;
            for (int i = 0; i < rectChildren.Count; i++)
            {
                num = Mathf.Max(LayoutUtility.GetMinWidth(rectChildren[i]), num);
            }
            return num;
        }

        public float GetGreatestMinimumChildHeigth()
        {
            float num = 0f;
            for (int i = 0; i < rectChildren.Count; i++)
            {
                num = Mathf.Max(LayoutUtility.GetMinHeight(rectChildren[i]), num);
            }
            return num;
        }
    }
}
namespace UnityEngine.EventSystems
{
    [AddComponentMenu("Event/Standalone Input Module")]
    public class ModifiedStandaloneInputModule : PointerInputModule
    {
        [Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", false)]
        public enum InputMode
        {
            Mouse,
            Buttons
        }

        public float m_PrevActionTime;

        public Vector2 m_LastMoveVector;

        public int m_ConsecutiveMoveCount;

        public Vector2 m_LastMousePosition;

        public Vector2 m_MousePosition;

        public GameObject m_CurrentFocusedGameObject;

        public PointerEventData m_InputPointerEvent;

        [SerializeField]
        public string m_HorizontalAxis = "Horizontal";

        [SerializeField]
        public string m_VerticalAxis = "Vertical";

        [SerializeField]
        public string m_SubmitButton = "Submit";

        [SerializeField]
        public string m_CancelButton = "Cancel";

        [SerializeField]
        public float m_InputActionsPerSecond = 10f;

        [SerializeField]
        public float m_RepeatDelay = 0.5f;

        [SerializeField]
        [FormerlySerializedAs("m_AllowActivationOnMobileDevice")]
        public bool m_ForceModuleActive;

        [Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", false)]
        public InputMode inputMode => InputMode.Mouse;

        [Obsolete("allowActivationOnMobileDevice has been deprecated. Use forceModuleActive instead (UnityUpgradable) -> forceModuleActive")]
        public bool allowActivationOnMobileDevice
        {
            get
            {
                return m_ForceModuleActive;
            }
            set
            {
                m_ForceModuleActive = value;
            }
        }

        public bool forceModuleActive
        {
            get
            {
                return m_ForceModuleActive;
            }
            set
            {
                m_ForceModuleActive = value;
            }
        }

        public float inputActionsPerSecond
        {
            get
            {
                return m_InputActionsPerSecond;
            }
            set
            {
                m_InputActionsPerSecond = value;
            }
        }

        public float repeatDelay
        {
            get
            {
                return m_RepeatDelay;
            }
            set
            {
                m_RepeatDelay = value;
            }
        }

        public string horizontalAxis
        {
            get
            {
                return m_HorizontalAxis;
            }
            set
            {
                m_HorizontalAxis = value;
            }
        }

        public string verticalAxis
        {
            get
            {
                return m_VerticalAxis;
            }
            set
            {
                m_VerticalAxis = value;
            }
        }

        public string submitButton
        {
            get
            {
                return m_SubmitButton;
            }
            set
            {
                m_SubmitButton = value;
            }
        }

        public string cancelButton
        {
            get
            {
                return m_CancelButton;
            }
            set
            {
                m_CancelButton = value;
            }
        }

        public bool ShouldIgnoreEventsOnNoFocus()
        {
            return true;
        }

        public override void UpdateModule()
        {
            //IL_0009: Unknown result type (might be due to invalid IL or missing references)
            //IL_000e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0024: Unknown result type (might be due to invalid IL or missing references)
            //IL_0029: Unknown result type (might be due to invalid IL or missing references)
            //IL_009b: Unknown result type (might be due to invalid IL or missing references)
            //IL_00a0: Unknown result type (might be due to invalid IL or missing references)
            //IL_00ac: Unknown result type (might be due to invalid IL or missing references)
            //IL_00b1: Unknown result type (might be due to invalid IL or missing references)
            //IL_0078: Unknown result type (might be due to invalid IL or missing references)
            //IL_007d: Unknown result type (might be due to invalid IL or missing references)
            if (InputSwitcher.justSwitched)
            {
                m_LastMousePosition = m_MousePosition;
                m_MousePosition = new Vector2((float)(Screen.width * 2), (float)(Screen.height * 2));
            }
            if (!((BaseInputModule)this).eventSystem.isFocused && ShouldIgnoreEventsOnNoFocus())
            {
                if (m_InputPointerEvent != null && m_InputPointerEvent.pointerDrag != null && m_InputPointerEvent.dragging)
                {
                    PointerEventData inputPointerEvent = m_InputPointerEvent;
                    RaycastResult pointerCurrentRaycast = m_InputPointerEvent.pointerCurrentRaycast;
                    ReleaseMouse(inputPointerEvent, ((pointerCurrentRaycast)).gameObject);
                }
                m_InputPointerEvent = null;
            }
            else if (!InputSwitcher.justSwitched)
            {
                m_LastMousePosition = m_MousePosition;
                m_MousePosition = ((BaseInputModule)this).input.mousePosition;
            }
        }

        public void ReleaseMouse(PointerEventData pointerEvent, GameObject currentOverGo)
        {
            //IL_0012: Unknown result type (might be due to invalid IL or missing references)
            if (InputSwitcher.justSwitched)
            {
                pointerEvent.position = new Vector2(-1000f, -1000f);
            }
            ExecuteEvents.Execute<IPointerUpHandler>(pointerEvent.pointerPress, (BaseEventData)(object)pointerEvent, ExecuteEvents.pointerUpHandler);
            GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(currentOverGo);
            if (pointerEvent.pointerClick == eventHandler && pointerEvent.eligibleForClick)
            {
                ExecuteEvents.Execute<IPointerClickHandler>(pointerEvent.pointerClick, (BaseEventData)(object)pointerEvent, ExecuteEvents.pointerClickHandler);
            }
            if (pointerEvent.pointerDrag != null && pointerEvent.dragging)
            {
                ExecuteEvents.ExecuteHierarchy<IDropHandler>(currentOverGo, (BaseEventData)(object)pointerEvent, ExecuteEvents.dropHandler);
            }
            pointerEvent.eligibleForClick = false;
            pointerEvent.pointerPress = null;
            pointerEvent.rawPointerPress = null;
            pointerEvent.pointerClick = null;
            if (pointerEvent.pointerDrag != null && pointerEvent.dragging)
            {
                ExecuteEvents.Execute<IEndDragHandler>(pointerEvent.pointerDrag, (BaseEventData)(object)pointerEvent, ExecuteEvents.endDragHandler);
            }
            pointerEvent.dragging = false;
            pointerEvent.pointerDrag = null;
            if (currentOverGo != pointerEvent.pointerEnter)
            {
                ((BaseInputModule)this).HandlePointerExitAndEnter(pointerEvent, (GameObject)null);
                ((BaseInputModule)this).HandlePointerExitAndEnter(pointerEvent, currentOverGo);
            }
            m_InputPointerEvent = pointerEvent;
        }

        public override bool IsModuleSupported()
        {
            if (!m_ForceModuleActive && !((BaseInputModule)this).input.mousePresent)
            {
                return ((BaseInputModule)this).input.touchSupported;
            }
            return true;
        }

        public override bool ShouldActivateModule()
        {
            //IL_007d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0083: Unknown result type (might be due to invalid IL or missing references)
            //IL_0088: Unknown result type (might be due to invalid IL or missing references)
            //IL_008d: Unknown result type (might be due to invalid IL or missing references)
            if (!((BaseInputModule)this).ShouldActivateModule())
            {
                return false;
            }
            bool flag = m_ForceModuleActive;
            flag |= ((BaseInputModule)this).input.GetButtonDown(m_SubmitButton);
            flag |= ((BaseInputModule)this).input.GetButtonDown(m_CancelButton);
            flag |= !Mathf.Approximately(((BaseInputModule)this).input.GetAxisRaw(m_HorizontalAxis), 0f);
            flag |= !Mathf.Approximately(((BaseInputModule)this).input.GetAxisRaw(m_VerticalAxis), 0f);
            bool num = flag;
            Vector2 val = m_MousePosition - m_LastMousePosition;
            flag = num | (((val)).sqrMagnitude > 0f);
            flag |= ((BaseInputModule)this).input.GetMouseButtonDown(0);
            if (((BaseInputModule)this).input.touchCount > 0)
            {
                flag = true;
            }
            return flag;
        }

        public override void ActivateModule()
        {
            //IL_0053: Unknown result type (might be due to invalid IL or missing references)
            //IL_0058: Unknown result type (might be due to invalid IL or missing references)
            //IL_0064: Unknown result type (might be due to invalid IL or missing references)
            //IL_0069: Unknown result type (might be due to invalid IL or missing references)
            //IL_0025: Unknown result type (might be due to invalid IL or missing references)
            //IL_002a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0040: Unknown result type (might be due to invalid IL or missing references)
            //IL_0045: Unknown result type (might be due to invalid IL or missing references)
            if (((BaseInputModule)this).eventSystem.isFocused || !ShouldIgnoreEventsOnNoFocus())
            {
                ((BaseInputModule)this).ActivateModule();
                if (InputSwitcher.justSwitched)
                {
                    m_LastMousePosition = m_MousePosition;
                    m_MousePosition = new Vector2((float)(Screen.width * 2), (float)(Screen.height * 2));
                }
                else
                {
                    m_MousePosition = ((BaseInputModule)this).input.mousePosition;
                    m_LastMousePosition = ((BaseInputModule)this).input.mousePosition;
                }
                GameObject val = ((BaseInputModule)this).eventSystem.currentSelectedGameObject;
                if (val == null)
                {
                    val = ((BaseInputModule)this).eventSystem.firstSelectedGameObject;
                }
                ((BaseInputModule)this).eventSystem.SetSelectedGameObject(val, ((BaseInputModule)this).GetBaseEventData());
            }
        }

        public override void DeactivateModule()
        {
            ((BaseInputModule)this).DeactivateModule();
            ((PointerInputModule)this).ClearSelection();
        }

        public override void Process()
        {
            if (!((BaseInputModule)this).eventSystem.isFocused && ShouldIgnoreEventsOnNoFocus())
            {
                return;
            }
            bool flag = SendUpdateEventToSelectedObject();
            if (!ProcessTouchEvents() && ((BaseInputModule)this).input.mousePresent)
            {
                ProcessMouseEvent();
            }
            if (((BaseInputModule)this).eventSystem.sendNavigationEvents)
            {
                if (!flag)
                {
                    flag |= SendMoveEventToSelectedObject();
                }
                if (!flag)
                {
                    SendSubmitEventToSelectedObject();
                }
            }
        }

        public bool ProcessTouchEvents()
        {
            //IL_000b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0010: Unknown result type (might be due to invalid IL or missing references)
            //IL_0013: Unknown result type (might be due to invalid IL or missing references)
            //IL_0019: Invalid comparison between Unknown and I4
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            bool pressed = default(bool);
            bool flag = default(bool);
            for (int i = 0; i < ((BaseInputModule)this).input.touchCount; i++)
            {
                Touch touch = ((BaseInputModule)this).input.GetTouch(i);
                if ((int)((touch)).type != 1)
                {
                    PointerEventData touchPointerEventData = ((PointerInputModule)this).GetTouchPointerEventData(touch, ref pressed, ref flag);
                    ProcessTouchPress(touchPointerEventData, pressed, flag);
                    if (!flag)
                    {
                        ((PointerInputModule)this).ProcessMove(touchPointerEventData);
                        ((PointerInputModule)this).ProcessDrag(touchPointerEventData);
                    }
                    else
                    {
                        ((PointerInputModule)this).RemovePointerData(touchPointerEventData);
                    }
                }
            }
            return ((BaseInputModule)this).input.touchCount > 0;
        }

        public void ProcessTouchPress(PointerEventData pointerEvent, bool pressed, bool released)
        {
            //IL_0001: Unknown result type (might be due to invalid IL or missing references)
            //IL_0006: Unknown result type (might be due to invalid IL or missing references)
            //IL_0021: Unknown result type (might be due to invalid IL or missing references)
            //IL_0039: Unknown result type (might be due to invalid IL or missing references)
            //IL_0053: Unknown result type (might be due to invalid IL or missing references)
            //IL_005f: Unknown result type (might be due to invalid IL or missing references)
            RaycastResult pointerCurrentRaycast = pointerEvent.pointerCurrentRaycast;
            GameObject gameObject = ((pointerCurrentRaycast)).gameObject;
            if (InputSwitcher.justSwitched)
            {
                pointerEvent.position = new Vector2(-1000f, -1000f);
            }
            if (pressed)
            {
                pointerEvent.eligibleForClick = true;
                pointerEvent.delta = Vector2.zero;
                pointerEvent.dragging = false;
                pointerEvent.useDragThreshold = true;
                pointerEvent.pressPosition = pointerEvent.position;
                pointerEvent.pointerPressRaycast = pointerEvent.pointerCurrentRaycast;
                ((PointerInputModule)this).DeselectIfSelectionChanged(gameObject, (BaseEventData)(object)pointerEvent);
                if (pointerEvent.pointerEnter != gameObject)
                {
                    ((BaseInputModule)this).HandlePointerExitAndEnter(pointerEvent, gameObject);
                    pointerEvent.pointerEnter = gameObject;
                }
                GameObject val = ExecuteEvents.ExecuteHierarchy<IPointerDownHandler>(gameObject, (BaseEventData)(object)pointerEvent, ExecuteEvents.pointerDownHandler);
                GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
                if (val == null)
                {
                    val = eventHandler;
                }
                float unscaledTime = Time.unscaledTime;
                if (val == pointerEvent.lastPress)
                {
                    if (unscaledTime - pointerEvent.clickTime < 0.3f)
                    {
                        int clickCount = pointerEvent.clickCount + 1;
                        pointerEvent.clickCount = clickCount;
                    }
                    else
                    {
                        pointerEvent.clickCount = 1;
                    }
                    pointerEvent.clickTime = unscaledTime;
                }
                else
                {
                    pointerEvent.clickCount = 1;
                }
                pointerEvent.pointerPress = val;
                pointerEvent.rawPointerPress = gameObject;
                pointerEvent.pointerClick = eventHandler;
                pointerEvent.clickTime = unscaledTime;
                pointerEvent.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
                if (pointerEvent.pointerDrag != null)
                {
                    ExecuteEvents.Execute<IInitializePotentialDragHandler>(pointerEvent.pointerDrag, (BaseEventData)(object)pointerEvent, ExecuteEvents.initializePotentialDrag);
                }
            }
            if (released)
            {
                ExecuteEvents.Execute<IPointerUpHandler>(pointerEvent.pointerPress, (BaseEventData)(object)pointerEvent, ExecuteEvents.pointerUpHandler);
                GameObject eventHandler2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
                if (pointerEvent.pointerClick == eventHandler2 && pointerEvent.eligibleForClick)
                {
                    ExecuteEvents.Execute<IPointerClickHandler>(pointerEvent.pointerClick, (BaseEventData)(object)pointerEvent, ExecuteEvents.pointerClickHandler);
                }
                if (pointerEvent.pointerDrag != null && pointerEvent.dragging)
                {
                    ExecuteEvents.ExecuteHierarchy<IDropHandler>(gameObject, (BaseEventData)(object)pointerEvent, ExecuteEvents.dropHandler);
                }
                pointerEvent.eligibleForClick = false;
                pointerEvent.pointerPress = null;
                pointerEvent.rawPointerPress = null;
                pointerEvent.pointerClick = null;
                if (pointerEvent.pointerDrag != null && pointerEvent.dragging)
                {
                    ExecuteEvents.Execute<IEndDragHandler>(pointerEvent.pointerDrag, (BaseEventData)(object)pointerEvent, ExecuteEvents.endDragHandler);
                }
                pointerEvent.dragging = false;
                pointerEvent.pointerDrag = null;
                ExecuteEvents.ExecuteHierarchy<IPointerExitHandler>(pointerEvent.pointerEnter, (BaseEventData)(object)pointerEvent, ExecuteEvents.pointerExitHandler);
                pointerEvent.pointerEnter = null;
            }
            m_InputPointerEvent = pointerEvent;
        }

        public bool SendSubmitEventToSelectedObject()
        {
            if (((BaseInputModule)this).eventSystem.currentSelectedGameObject == null)
            {
                return false;
            }
            BaseEventData baseEventData = ((BaseInputModule)this).GetBaseEventData();
            if (((BaseInputModule)this).input.GetButtonDown(m_SubmitButton))
            {
                ExecuteEvents.Execute<ISubmitHandler>(((BaseInputModule)this).eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.submitHandler);
            }
            if (((BaseInputModule)this).input.GetButtonDown(m_CancelButton))
            {
                ExecuteEvents.Execute<ICancelHandler>(((BaseInputModule)this).eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.cancelHandler);
            }
            return ((AbstractEventData)baseEventData).used;
        }

        public Vector2 GetRawMoveVector()
        {
            //IL_0000: Unknown result type (might be due to invalid IL or missing references)
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_0049: Unknown result type (might be due to invalid IL or missing references)
            //IL_00c0: Unknown result type (might be due to invalid IL or missing references)
            //IL_008e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0062: Unknown result type (might be due to invalid IL or missing references)
            //IL_00a7: Unknown result type (might be due to invalid IL or missing references)
            Vector2 zero = Vector2.zero;
            zero.x = ((BaseInputModule)this).input.GetAxisRaw(m_HorizontalAxis);
            zero.y = ((BaseInputModule)this).input.GetAxisRaw(m_VerticalAxis);
            if (((BaseInputModule)this).input.GetButtonDown(m_HorizontalAxis))
            {
                if (zero.x < 0f)
                {
                    zero.x = -1f;
                }
                if (zero.x > 0f)
                {
                    zero.x = 1f;
                }
            }
            if (((BaseInputModule)this).input.GetButtonDown(m_VerticalAxis))
            {
                if (zero.y < 0f)
                {
                    zero.y = -1f;
                }
                if (zero.y > 0f)
                {
                    zero.y = 1f;
                }
            }
            return zero;
        }

        public bool SendMoveEventToSelectedObject()
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_000d: Unknown result type (might be due to invalid IL or missing references)
            //IL_003a: Unknown result type (might be due to invalid IL or missing references)
            //IL_003c: Unknown result type (might be due to invalid IL or missing references)
            //IL_001f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0085: Unknown result type (might be due to invalid IL or missing references)
            //IL_008b: Unknown result type (might be due to invalid IL or missing references)
            //IL_009d: Unknown result type (might be due to invalid IL or missing references)
            //IL_00a3: Invalid comparison between Unknown and I4
            //IL_00dc: Unknown result type (might be due to invalid IL or missing references)
            //IL_00dd: Unknown result type (might be due to invalid IL or missing references)
            float unscaledTime = Time.unscaledTime;
            Vector2 rawMoveVector = GetRawMoveVector();
            if (Mathf.Approximately(rawMoveVector.x, 0f) && Mathf.Approximately(rawMoveVector.y, 0f))
            {
                m_ConsecutiveMoveCount = 0;
                return false;
            }
            bool flag = Vector2.Dot(rawMoveVector, m_LastMoveVector) > 0f;
            if (flag && m_ConsecutiveMoveCount == 1)
            {
                if (unscaledTime <= m_PrevActionTime + m_RepeatDelay)
                {
                    return false;
                }
            }
            else if (unscaledTime <= m_PrevActionTime + 1f / m_InputActionsPerSecond)
            {
                return false;
            }
            AxisEventData axisEventData = ((BaseInputModule)this).GetAxisEventData(rawMoveVector.x, rawMoveVector.y, 0.6f);
            if ((int)axisEventData.moveDir != 4)
            {
                ExecuteEvents.Execute<IMoveHandler>(((BaseInputModule)this).eventSystem.currentSelectedGameObject, (BaseEventData)(object)axisEventData, ExecuteEvents.moveHandler);
                if (!flag)
                {
                    m_ConsecutiveMoveCount = 0;
                }
                m_ConsecutiveMoveCount++;
                m_PrevActionTime = unscaledTime;
                m_LastMoveVector = rawMoveVector;
            }
            else
            {
                m_ConsecutiveMoveCount = 0;
            }
            return ((AbstractEventData)axisEventData).used;
        }

        public void ProcessMouseEvent()
        {
            ProcessMouseEvent(0);
        }

        [Obsolete("This method is no longer checked, overriding it with return true does nothing!")]
        public virtual bool ForceAutoSelect()
        {
            return false;
        }

        public void ProcessMouseEvent(int id)
        {
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0021: Unknown result type (might be due to invalid IL or missing references)
            //IL_00a5: Unknown result type (might be due to invalid IL or missing references)
            //IL_00aa: Unknown result type (might be due to invalid IL or missing references)
            //IL_00c4: Unknown result type (might be due to invalid IL or missing references)
            //IL_00c9: Unknown result type (might be due to invalid IL or missing references)
            MouseState mousePointerEventData = ((PointerInputModule)this).GetMousePointerEventData(id);
            MouseButtonEventData eventData = mousePointerEventData.GetButtonState((InputButton)0).eventData;
            RaycastResult pointerCurrentRaycast = eventData.buttonData.pointerCurrentRaycast;
            m_CurrentFocusedGameObject = ((pointerCurrentRaycast)).gameObject;
            ProcessMousePress(eventData);
            ((PointerInputModule)this).ProcessMove(eventData.buttonData);
            ((PointerInputModule)this).ProcessDrag(eventData.buttonData);
            ProcessMousePress(mousePointerEventData.GetButtonState((InputButton)1).eventData);
            ((PointerInputModule)this).ProcessDrag(mousePointerEventData.GetButtonState((InputButton)1).eventData.buttonData);
            ProcessMousePress(mousePointerEventData.GetButtonState((InputButton)2).eventData);
            ((PointerInputModule)this).ProcessDrag(mousePointerEventData.GetButtonState((InputButton)2).eventData.buttonData);
            Vector2 scrollDelta = eventData.buttonData.scrollDelta;
            if (!Mathf.Approximately(((scrollDelta)).sqrMagnitude, 0f))
            {
                pointerCurrentRaycast = eventData.buttonData.pointerCurrentRaycast;
                ExecuteEvents.ExecuteHierarchy<IScrollHandler>(ExecuteEvents.GetEventHandler<IScrollHandler>(((pointerCurrentRaycast)).gameObject), (BaseEventData)(object)eventData.buttonData, ExecuteEvents.scrollHandler);
            }
        }

        public bool SendUpdateEventToSelectedObject()
        {
            if (((BaseInputModule)this).eventSystem.currentSelectedGameObject == null)
            {
                return false;
            }
            BaseEventData baseEventData = ((BaseInputModule)this).GetBaseEventData();
            ExecuteEvents.Execute<IUpdateSelectedHandler>(((BaseInputModule)this).eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.updateSelectedHandler);
            return ((AbstractEventData)baseEventData).used;
        }

        public void ProcessMousePress(MouseButtonEventData data)
        {
            //IL_0008: Unknown result type (might be due to invalid IL or missing references)
            //IL_000d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0028: Unknown result type (might be due to invalid IL or missing references)
            //IL_0045: Unknown result type (might be due to invalid IL or missing references)
            //IL_005f: Unknown result type (might be due to invalid IL or missing references)
            //IL_006b: Unknown result type (might be due to invalid IL or missing references)
            PointerEventData buttonData = data.buttonData;
            RaycastResult pointerCurrentRaycast = buttonData.pointerCurrentRaycast;
            GameObject gameObject = ((pointerCurrentRaycast)).gameObject;
            if (InputSwitcher.justSwitched)
            {
                buttonData.position = new Vector2(-1000f, -1000f);
            }
            if (data.PressedThisFrame())
            {
                buttonData.eligibleForClick = true;
                buttonData.delta = Vector2.zero;
                buttonData.dragging = false;
                buttonData.useDragThreshold = true;
                buttonData.pressPosition = buttonData.position;
                buttonData.pointerPressRaycast = buttonData.pointerCurrentRaycast;
                ((PointerInputModule)this).DeselectIfSelectionChanged(gameObject, (BaseEventData)(object)buttonData);
                GameObject val = ExecuteEvents.ExecuteHierarchy<IPointerDownHandler>(gameObject, (BaseEventData)(object)buttonData, ExecuteEvents.pointerDownHandler);
                GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
                if (val == null)
                {
                    val = eventHandler;
                }
                float unscaledTime = Time.unscaledTime;
                if (val == buttonData.lastPress)
                {
                    if (unscaledTime - buttonData.clickTime < 0.3f)
                    {
                        int clickCount = buttonData.clickCount + 1;
                        buttonData.clickCount = clickCount;
                    }
                    else
                    {
                        buttonData.clickCount = 1;
                    }
                    buttonData.clickTime = unscaledTime;
                }
                else
                {
                    buttonData.clickCount = 1;
                }
                buttonData.pointerPress = val;
                buttonData.rawPointerPress = gameObject;
                buttonData.pointerClick = eventHandler;
                buttonData.clickTime = unscaledTime;
                buttonData.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
                if (buttonData.pointerDrag != null)
                {
                    ExecuteEvents.Execute<IInitializePotentialDragHandler>(buttonData.pointerDrag, (BaseEventData)(object)buttonData, ExecuteEvents.initializePotentialDrag);
                }
                m_InputPointerEvent = buttonData;
            }
            if (data.ReleasedThisFrame())
            {
                ReleaseMouse(buttonData, gameObject);
            }
        }

        public GameObject GetCurrentFocusedGameObject()
        {
            return m_CurrentFocusedGameObject;
        }
    }
    [AddComponentMenu("Event/Virtual Input Module")]
    public class VirtualInputModule : PointerInputModule
    {
        [Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", false)]
        public enum InputMode
        {
            Mouse,
            Buttons
        }

        public float m_PrevActionTime;

        public Vector2 m_LastMoveVector;

        public int m_ConsecutiveMoveCount;

        public Vector2 m_LastMousePosition;

        public Vector2 m_MousePosition;

        [SerializeField]
        public RectTransform m_VirtualCursor;

        public Camera _cam;

        [SerializeField]
        public string m_HorizontalAxis = "Horizontal";

        [SerializeField]
        public string m_VerticalAxis = "Vertical";

        [SerializeField]
        public string m_SubmitButton = "Submit";

        [SerializeField]
        public string m_CancelButton = "Cancel";

        [SerializeField]
        public float m_InputActionsPerSecond = 10f;

        [SerializeField]
        public float m_RepeatDelay = 0.5f;

        [SerializeField]
        [FormerlySerializedAs("m_AllowActivationOnMobileDevice")]
        public bool m_ForceModuleActive;

        public FramePressState oldButtonState = (FramePressState)3;

        public readonly MouseState m_MouseState = new MouseState();

        [Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", false)]
        public InputMode inputMode => InputMode.Mouse;

        public Camera m_canvasCamera => _cam ??= Camera.main;

        [Obsolete("allowActivationOnMobileDevice has been deprecated. Use forceModuleActive instead (UnityUpgradable) -> forceModuleActive")]
        public bool allowActivationOnMobileDevice
        {
            get
            {
                return m_ForceModuleActive;
            }
            set
            {
                m_ForceModuleActive = value;
            }
        }

        public bool forceModuleActive
        {
            get
            {
                return m_ForceModuleActive;
            }
            set
            {
                m_ForceModuleActive = value;
            }
        }

        public float inputActionsPerSecond
        {
            get
            {
                return m_InputActionsPerSecond;
            }
            set
            {
                m_InputActionsPerSecond = value;
            }
        }

        public float repeatDelay
        {
            get
            {
                return m_RepeatDelay;
            }
            set
            {
                m_RepeatDelay = value;
            }
        }

        public string horizontalAxis
        {
            get
            {
                return m_HorizontalAxis;
            }
            set
            {
                m_HorizontalAxis = value;
            }
        }

        public string verticalAxis
        {
            get
            {
                return m_VerticalAxis;
            }
            set
            {
                m_VerticalAxis = value;
            }
        }

        public string submitButton
        {
            get
            {
                return m_SubmitButton;
            }
            set
            {
                m_SubmitButton = value;
            }
        }

        public string cancelButton
        {
            get
            {
                return m_CancelButton;
            }
            set
            {
                m_CancelButton = value;
            }
        }

        public override void UpdateModule()
        {
            //IL_0002: Unknown result type (might be due to invalid IL or missing references)
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_0013: Unknown result type (might be due to invalid IL or missing references)
            //IL_0018: Unknown result type (might be due to invalid IL or missing references)
            m_LastMousePosition = m_MousePosition;
            m_MousePosition = m_VirtualCursor.anchoredPosition;
        }

        public override bool IsModuleSupported()
        {
            if (!m_ForceModuleActive)
            {
                return Input.mousePresent;
            }
            return true;
        }

        public override bool ShouldActivateModule()
        {
            //IL_005b: Unknown result type (might be due to invalid IL or missing references)
            //IL_0061: Unknown result type (might be due to invalid IL or missing references)
            //IL_0066: Unknown result type (might be due to invalid IL or missing references)
            //IL_006b: Unknown result type (might be due to invalid IL or missing references)
            if (!((BaseInputModule)this).ShouldActivateModule())
            {
                return false;
            }
            bool flag = m_ForceModuleActive;
            flag |= !Mathf.Approximately(Mathf.Abs(RewiredControllerManager.instance.GetAnalog("Move Horizontal")), 0f);
            flag |= !Mathf.Approximately(Mathf.Abs(RewiredControllerManager.instance.GetAnalog("Move Vertical")), 0f);
            bool num = flag;
            Vector2 val = m_MousePosition - m_LastMousePosition;
            flag = num | (((val)).sqrMagnitude > 0f);
            flag |= RewiredControllerManager.instance.IsButtonPressed("Select");
            if (Console.active)
            {
                flag = false;
            }
            return flag;
        }

        public override void ActivateModule()
        {
            //IL_000d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0012: Unknown result type (might be due to invalid IL or missing references)
            //IL_001e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0023: Unknown result type (might be due to invalid IL or missing references)
            ((BaseInputModule)this).ActivateModule();
            m_MousePosition = m_VirtualCursor.anchoredPosition;
            m_LastMousePosition = m_VirtualCursor.anchoredPosition;
            GameObject val = ((BaseInputModule)this).eventSystem.currentSelectedGameObject;
            if (val == null)
            {
                val = ((BaseInputModule)this).eventSystem.firstSelectedGameObject;
            }
            ((BaseInputModule)this).eventSystem.SetSelectedGameObject(val, ((BaseInputModule)this).GetBaseEventData());
        }

        public override void DeactivateModule()
        {
            ((BaseInputModule)this).DeactivateModule();
            ((PointerInputModule)this).ClearSelection();
        }

        public override void Process()
        {
            bool flag = SendUpdateEventToSelectedObject();
            if (((BaseInputModule)this).eventSystem.sendNavigationEvents)
            {
                if (!flag)
                {
                    flag |= SendMoveEventToSelectedObject();
                }
                if (!flag)
                {
                    SendSubmitEventToSelectedObject();
                }
            }
            ProcessMouseEvent();
            ProcessRewiredEvent();
        }

        public bool SendSubmitEventToSelectedObject()
        {
            if (((BaseInputModule)this).eventSystem.currentSelectedGameObject == null)
            {
                return false;
            }
            return ((AbstractEventData)((BaseInputModule)this).GetBaseEventData()).used;
        }

        public Vector2 GetRawMoveVector()
        {
            //IL_0000: Unknown result type (might be due to invalid IL or missing references)
            //IL_0005: Unknown result type (might be due to invalid IL or missing references)
            //IL_004d: Unknown result type (might be due to invalid IL or missing references)
            //IL_00cc: Unknown result type (might be due to invalid IL or missing references)
            //IL_009a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0066: Unknown result type (might be due to invalid IL or missing references)
            //IL_00b3: Unknown result type (might be due to invalid IL or missing references)
            Vector2 zero = Vector2.zero;
            zero.x = RewiredControllerManager.instance.GetAnalog("Move Vertical");
            zero.y = RewiredControllerManager.instance.GetAnalog("Move Horizontal");
            if (Mathf.Abs(RewiredControllerManager.instance.GetAnalog("Move Horizontal")) >= 0.05f)
            {
                if (zero.x < 0f)
                {
                    zero.x = -1f;
                }
                if (zero.x > 0f)
                {
                    zero.x = 1f;
                }
            }
            if (Mathf.Abs(RewiredControllerManager.instance.GetAnalog("Move Vertical")) >= 0.05f)
            {
                if (zero.y < 0f)
                {
                    zero.y = -1f;
                }
                if (zero.y > 0f)
                {
                    zero.y = 1f;
                }
            }
            return zero;
        }

        public bool SendMoveEventToSelectedObject()
        {
            //IL_0007: Unknown result type (might be due to invalid IL or missing references)
            //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //IL_000d: Unknown result type (might be due to invalid IL or missing references)
            //IL_001f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0077: Unknown result type (might be due to invalid IL or missing references)
            //IL_0079: Unknown result type (might be due to invalid IL or missing references)
            //IL_00ca: Unknown result type (might be due to invalid IL or missing references)
            //IL_00d0: Unknown result type (might be due to invalid IL or missing references)
            //IL_011a: Unknown result type (might be due to invalid IL or missing references)
            //IL_011b: Unknown result type (might be due to invalid IL or missing references)
            float unscaledTime = Time.unscaledTime;
            Vector2 rawMoveVector = GetRawMoveVector();
            if (Mathf.Approximately(rawMoveVector.x, 0f) && Mathf.Approximately(rawMoveVector.y, 0f))
            {
                m_ConsecutiveMoveCount = 0;
                return false;
            }
            bool flag = Mathf.Abs(RewiredControllerManager.instance.GetAnalog("Move Vertical")) >= 0.05f || Mathf.Abs(RewiredControllerManager.instance.GetAnalog("Move Horizontal")) >= 0.05f;
            bool flag2 = Vector2.Dot(rawMoveVector, m_LastMoveVector) > 0f;
            if (!flag)
            {
                flag = ((!flag2 || m_ConsecutiveMoveCount != 1) ? (unscaledTime > m_PrevActionTime + 1f / m_InputActionsPerSecond) : (unscaledTime > m_PrevActionTime + m_RepeatDelay));
            }
            if (!flag)
            {
                return false;
            }
            AxisEventData axisEventData = ((BaseInputModule)this).GetAxisEventData(rawMoveVector.x, rawMoveVector.y, 0.6f);
            ExecuteEvents.Execute<IMoveHandler>(((BaseInputModule)this).eventSystem.currentSelectedGameObject, (BaseEventData)(object)axisEventData, ExecuteEvents.moveHandler);
            if (!flag2)
            {
                m_ConsecutiveMoveCount = 0;
            }
            m_ConsecutiveMoveCount++;
            m_PrevActionTime = unscaledTime;
            m_LastMoveVector = rawMoveVector;
            return ((AbstractEventData)axisEventData).used;
        }

        public void ProcessRewiredEvent()
        {
            //IL_0014: Unknown result type (might be due to invalid IL or missing references)
            //IL_0028: Unknown result type (might be due to invalid IL or missing references)
            //IL_003d: Unknown result type (might be due to invalid IL or missing references)
            //IL_003f: Unknown result type (might be due to invalid IL or missing references)
            //IL_003c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0049: Unknown result type (might be due to invalid IL or missing references)
            //IL_004a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0047: Unknown result type (might be due to invalid IL or missing references)
            //IL_007e: Unknown result type (might be due to invalid IL or missing references)
            //IL_0083: Unknown result type (might be due to invalid IL or missing references)
            //IL_0084: Unknown result type (might be due to invalid IL or missing references)
            //IL_0085: Unknown result type (might be due to invalid IL or missing references)
            //IL_008a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0097: Expected O, but got Unknown
            //IL_00a4: Unknown result type (might be due to invalid IL or missing references)
            //IL_00a9: Unknown result type (might be due to invalid IL or missing references)
            //IL_00c3: Unknown result type (might be due to invalid IL or missing references)
            //IL_00c8: Unknown result type (might be due to invalid IL or missing references)
            MouseButtonEventData eventData = ((PointerInputModule)this).GetMousePointerEventData(0).GetButtonState((InputButton)0).eventData;
            FramePressState val = (FramePressState)3;
            if (RewiredControllerManager.instance.IsButtonPressed("Select"))
            {
                val = (FramePressState)0;
            }
            if (RewiredControllerManager.instance.IsButtonReleased("Select"))
            {
                val = (FramePressState)1;
            }
            if (val == oldButtonState)
            {
                val = (FramePressState)3;
            }
            oldButtonState = val;
            if (MonoBehaviourSingleton<UINavigationSystem>.instance != null && MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem != null)
            {
                _ = MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem.clickHandler;
            }
            MouseButtonEventData val2 = new MouseButtonEventData
            {
                buttonState = val,
                buttonData = eventData.buttonData
            };
            ProcessMousePress(val2);
            Vector2 scrollDelta = val2.buttonData.scrollDelta;
            if (!Mathf.Approximately(((scrollDelta)).sqrMagnitude, 0f))
            {
                RaycastResult pointerCurrentRaycast = val2.buttonData.pointerCurrentRaycast;
                ExecuteEvents.ExecuteHierarchy<IScrollHandler>(ExecuteEvents.GetEventHandler<IScrollHandler>(((pointerCurrentRaycast)).gameObject), (BaseEventData)(object)val2.buttonData, ExecuteEvents.scrollHandler);
            }
        }

        public void ProcessMouseEvent()
        {
            ProcessMouseEvent(0);
        }

        public void ProcessMouseEvent(int id)
        {
            //IL_007a: Unknown result type (might be due to invalid IL or missing references)
            //IL_007f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0099: Unknown result type (might be due to invalid IL or missing references)
            //IL_009e: Unknown result type (might be due to invalid IL or missing references)
            //IL_003a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0056: Unknown result type (might be due to invalid IL or missing references)
            MouseButtonEventData eventData = ((PointerInputModule)this).GetMousePointerEventData(id).GetButtonState((InputButton)0).eventData;
            RaycastResult pointerCurrentRaycast;
            if (MonoBehaviourSingleton<UINavigationSystem>.instance != null && MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem != null)
            {
                PointerEventData buttonData = eventData.buttonData;
                pointerCurrentRaycast = default(RaycastResult);
                ((pointerCurrentRaycast)).gameObject = MonoBehaviourSingleton<UINavigationSystem>.instance.currentNavigationItem.clickHandler;
                buttonData.pointerCurrentRaycast = pointerCurrentRaycast;
            }
            ((PointerInputModule)this).ProcessMove(eventData.buttonData);
            ((PointerInputModule)this).ProcessDrag(eventData.buttonData);
            Vector2 scrollDelta = eventData.buttonData.scrollDelta;
            if (!Mathf.Approximately(((scrollDelta)).sqrMagnitude, 0f))
            {
                pointerCurrentRaycast = eventData.buttonData.pointerCurrentRaycast;
                ExecuteEvents.GetEventHandler<IScrollHandler>(((pointerCurrentRaycast)).gameObject);
            }
        }

        public bool SendUpdateEventToSelectedObject()
        {
            if (((BaseInputModule)this).eventSystem.currentSelectedGameObject == null)
            {
                return false;
            }
            BaseEventData baseEventData = ((BaseInputModule)this).GetBaseEventData();
            ExecuteEvents.Execute<IUpdateSelectedHandler>(((BaseInputModule)this).eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.updateSelectedHandler);
            return ((AbstractEventData)baseEventData).used;
        }

        public void ProcessMousePress(MouseButtonEventData data)
        {
            //IL_0008: Unknown result type (might be due to invalid IL or missing references)
            //IL_000d: Unknown result type (might be due to invalid IL or missing references)
            //IL_0029: Unknown result type (might be due to invalid IL or missing references)
            //IL_0043: Unknown result type (might be due to invalid IL or missing references)
            //IL_004f: Unknown result type (might be due to invalid IL or missing references)
            //IL_0060: Unknown result type (might be due to invalid IL or missing references)
            PointerEventData buttonData = data.buttonData;
            RaycastResult pointerCurrentRaycast = buttonData.pointerCurrentRaycast;
            GameObject gameObject = ((pointerCurrentRaycast)).gameObject;
            if (data.PressedThisFrame())
            {
                buttonData.eligibleForClick = true;
                buttonData.delta = Vector2.zero;
                buttonData.dragging = false;
                buttonData.useDragThreshold = true;
                buttonData.pressPosition = buttonData.position;
                buttonData.pointerPressRaycast = buttonData.pointerCurrentRaycast;
                buttonData.position = m_VirtualCursor.anchoredPosition;
                ((PointerInputModule)this).DeselectIfSelectionChanged(gameObject, (BaseEventData)(object)buttonData);
                GameObject val = ExecuteEvents.ExecuteHierarchy<IPointerDownHandler>(gameObject, (BaseEventData)(object)buttonData, ExecuteEvents.pointerDownHandler);
                if (val == null)
                {
                    val = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
                }
                float unscaledTime = Time.unscaledTime;
                if (val == buttonData.lastPress)
                {
                    if (unscaledTime - buttonData.clickTime < 0.3f)
                    {
                        int clickCount = buttonData.clickCount + 1;
                        buttonData.clickCount = clickCount;
                    }
                    else
                    {
                        buttonData.clickCount = 1;
                    }
                    buttonData.clickTime = unscaledTime;
                }
                else
                {
                    buttonData.clickCount = 1;
                }
                buttonData.pointerPress = val;
                buttonData.rawPointerPress = gameObject;
                buttonData.clickTime = unscaledTime;
                buttonData.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
                if (buttonData.pointerDrag != null)
                {
                    ExecuteEvents.Execute<IInitializePotentialDragHandler>(buttonData.pointerDrag, (BaseEventData)(object)buttonData, ExecuteEvents.initializePotentialDrag);
                }
            }
            if (data.ReleasedThisFrame())
            {
                GameObject val2 = ExecuteEvents.ExecuteHierarchy<IPointerUpHandler>(gameObject, (BaseEventData)(object)buttonData, ExecuteEvents.pointerUpHandler);
                if (val2 == null)
                {
                    val2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
                }
                buttonData.pointerPress = val2;
                ExecuteEvents.Execute<IPointerUpHandler>(buttonData.pointerPress, (BaseEventData)(object)buttonData, ExecuteEvents.pointerUpHandler);
                GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
                if (buttonData.pointerPress == eventHandler && buttonData.eligibleForClick)
                {
                    ExecuteEvents.Execute<IPointerClickHandler>(buttonData.pointerPress, (BaseEventData)(object)buttonData, ExecuteEvents.pointerClickHandler);
                }
                else if (buttonData.pointerDrag != null && buttonData.dragging)
                {
                    ExecuteEvents.ExecuteHierarchy<IDropHandler>(gameObject, (BaseEventData)(object)buttonData, ExecuteEvents.dropHandler);
                }
                buttonData.eligibleForClick = false;
                buttonData.pointerPress = null;
                buttonData.rawPointerPress = null;
                if (buttonData.pointerDrag != null && buttonData.dragging)
                {
                    ExecuteEvents.Execute<IEndDragHandler>(buttonData.pointerDrag, (BaseEventData)(object)buttonData, ExecuteEvents.endDragHandler);
                }
                buttonData.dragging = false;
                buttonData.pointerDrag = null;
                if (gameObject != buttonData.pointerEnter)
                {
                    ((BaseInputModule)this).HandlePointerExitAndEnter(buttonData, (GameObject)null);
                    ((BaseInputModule)this).HandlePointerExitAndEnter(buttonData, gameObject);
                }
            }
        }

        public override MouseState GetMousePointerEventData(int id)
        {
            //IL_001c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0021: Unknown result type (might be due to invalid IL or missing references)
            //IL_0026: Unknown result type (might be due to invalid IL or missing references)
            //IL_0030: Unknown result type (might be due to invalid IL or missing references)
            //IL_0031: Unknown result type (might be due to invalid IL or missing references)
            //IL_0033: Unknown result type (might be due to invalid IL or missing references)
            //IL_0035: Unknown result type (might be due to invalid IL or missing references)
            //IL_003a: Unknown result type (might be due to invalid IL or missing references)
            //IL_0045: Unknown result type (might be due to invalid IL or missing references)
            //IL_004c: Unknown result type (might be due to invalid IL or missing references)
            //IL_0075: Unknown result type (might be due to invalid IL or missing references)
            //IL_007a: Unknown result type (might be due to invalid IL or missing references)
            //IL_007c: Unknown result type (might be due to invalid IL or missing references)
            //IL_00d0: Unknown result type (might be due to invalid IL or missing references)
            //IL_00e4: Unknown result type (might be due to invalid IL or missing references)
            //IL_00f9: Unknown result type (might be due to invalid IL or missing references)
            //IL_002a: Unknown result type (might be due to invalid IL or missing references)
            PointerEventData val = default(PointerEventData);
            bool pointerData = ((PointerInputModule)this).GetPointerData(-1, ref val, true);
            ((AbstractEventData)val).Reset();
            Vector2 val2 = RectTransformUtility.WorldToScreenPoint(m_canvasCamera, ((Transform)m_VirtualCursor).position);
            if (pointerData)
            {
                val.position = val2;
            }
            Vector2 val3 = val2;
            val.delta = val3 - val.position;
            val.position = val3;
            val.scrollDelta = Input.mouseScrollDelta;
            val.button = (InputButton)0;
            ((BaseInputModule)this).eventSystem.RaycastAll(val, ((BaseInputModule)this).m_RaycastResultCache);
            RaycastResult pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(((BaseInputModule)this).m_RaycastResultCache);
            val.pointerCurrentRaycast = pointerCurrentRaycast;
            ((BaseInputModule)this).m_RaycastResultCache.Clear();
            PointerEventData val4 = default(PointerEventData);
            ((PointerInputModule)this).GetPointerData(-2, ref val4, true);
            ((PointerInputModule)this).CopyFromTo(val, val4);
            val4.button = (InputButton)1;
            PointerEventData val5 = default(PointerEventData);
            ((PointerInputModule)this).GetPointerData(-3, ref val5, true);
            ((PointerInputModule)this).CopyFromTo(val, val5);
            val5.button = (InputButton)2;
            m_MouseState.SetButtonState((InputButton)0, ((PointerInputModule)this).StateForMouseButton(0), val);
            m_MouseState.SetButtonState((InputButton)1, ((PointerInputModule)this).StateForMouseButton(1), val4);
            m_MouseState.SetButtonState((InputButton)2, ((PointerInputModule)this).StateForMouseButton(2), val5);
            return m_MouseState;
        }
    }
}